{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_vec = vld1_u8(mask + i);\n        int64x2_t src_vec_0 = vld1q_s64(src + i);\n        int64x2_t src_vec_1 = vld1q_s64(src + i + 2);\n        int64x2_t src_vec_2 = vld1q_s64(src + i + 4);\n        int64x2_t src_vec_3 = vld1q_s64(src + i + 6);\n\n        int64x2_t dst_vec_0 = vld1q_s64(dst + i);\n        int64x2_t dst_vec_1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst_vec_2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst_vec_3 = vld1q_s64(dst + i + 6);\n\n        uint8x8_t mask_0 = vdup_n_u8(0);\n        uint8x8_t mask_1 = vdup_n_u8(0);\n        uint8x8_t mask_2 = vdup_n_u8(0);\n        uint8x8_t mask_3 = vdup_n_u8(0);\n\n        if (mask[i + 0]) mask_0 = vset_lane_u8(0xFF, mask_0, 0);\n        if (mask[i + 1]) mask_0 = vset_lane_u8(0xFF, mask_0, 1);\n        if (mask[i + 2]) mask_1 = vset_lane_u8(0xFF, mask_1, 0);\n        if (mask[i + 3]) mask_1 = vset_lane_u8(0xFF, mask_1, 1);\n        if (mask[i + 4]) mask_2 = vset_lane_u8(0xFF, mask_2, 0);\n        if (mask[i + 5]) mask_2 = vset_lane_u8(0xFF, mask_2, 1);\n        if (mask[i + 6]) mask_3 = vset_lane_u8(0xFF, mask_3, 0);\n        if (mask[i + 7]) mask_3 = vset_lane_u8(0xFF, mask_3, 1);\n\n        dst_vec_0 = vbslq_s64((int64x2_t)mask_0, src_vec_0, dst_vec_0);\n        dst_vec_1 = vbslq_s64((int64x2_t)mask_1, src_vec_1, dst_vec_1);\n        dst_vec_2 = vbslq_s64((int64x2_t)mask_2, src_vec_2, dst_vec_2);\n        dst_vec_3 = vbslq_s64((int64x2_t)mask_3, src_vec_3, dst_vec_3);\n\n        vst1q_s64(dst + i, dst_vec_0);\n        vst1q_s64(dst + i + 2, dst_vec_1);\n        vst1q_s64(dst + i + 4, dst_vec_2);\n        vst1q_s64(dst + i + 6, dst_vec_3);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_vec = vld1_u8(mask + i);\n        int64x2_t src_vec_0 = vld1q_s64(src + i);\n        int64x2_t src_vec_1 = vld1q_s64(src + i + 2);\n        int64x2_t src_vec_2 = vld1q_s64(src + i + 4);\n        int64x2_t src_vec_3 = vld1q_s64(src + i + 6);\n\n        int64x2_t dst_vec_0 = vld1q_s64(dst + i);\n        int64x2_t dst_vec_1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst_vec_2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst_vec_3 = vld1q_s64(dst + i + 6);\n\n        uint8x8_t mask_0 = vdup_n_u8(0);\n        uint8x8_t mask_1 = vdup_n_u8(0);\n        uint8x8_t mask_2 = vdup_n_u8(0);\n        uint8x8_t mask_3 = vdup_n_u8(0);\n        uint8x8_t mask_4 = vdup_n_u8(0);\n        uint8x8_t mask_5 = vdup_n_u8(0);\n        uint8x8_t mask_6 = vdup_n_u8(0);\n        uint8x8_t mask_7 = vdup_n_u8(0);\n\n        if (mask_vec[0]) mask_0 = vdup_n_u8(0xFF);\n        if (mask_vec[1]) mask_1 = vdup_n_u8(0xFF);\n        if (mask_vec[2]) mask_2 = vdup_n_u8(0xFF);\n        if (mask_vec[3]) mask_3 = vdup_n_u8(0xFF);\n        if (mask_vec[4]) mask_4 = vdup_n_u8(0xFF);\n        if (mask_vec[5]) mask_5 = vdup_n_u8(0xFF);\n        if (mask_vec[6]) mask_6 = vdup_n_u8(0xFF);\n        if (mask_vec[7]) mask_7 = vdup_n_u8(0xFF);\n\n        if (mask_vec[0]) dst[i + 0] = src[i + 0];\n        if (mask_vec[1]) dst[i + 1] = src[i + 1];\n        if (mask_vec[2]) dst[i + 2] = src[i + 2];\n        if (mask_vec[3]) dst[i + 3] = src[i + 3];\n        if (mask_vec[4]) dst[i + 4] = src[i + 4];\n        if (mask_vec[5]) dst[i + 5] = src[i + 5];\n        if (mask_vec[6]) dst[i + 6] = src[i + 6];\n        if (mask_vec[7]) dst[i + 7] = src[i + 7];\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_vec = vld1_u8(mask + i);\n        int64x2_t src_vec_0 = vld1q_s64(src + i);\n        int64x2_t src_vec_1 = vld1q_s64(src + i + 2);\n        int64x2_t src_vec_2 = vld1q_s64(src + i + 4);\n        int64x2_t src_vec_3 = vld1q_s64(src + i + 6);\n        \n        int64x2_t dst_vec_0 = vld1q_s64(dst + i);\n        int64x2_t dst_vec_1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst_vec_2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst_vec_3 = vld1q_s64(dst + i + 6);\n\n        uint8x8_t mask_0 = vdup_n_u8(mask[i+0] ? 0xFF : 0x00);\n        uint8x8_t mask_1 = vdup_n_u8(mask[i+1] ? 0xFF : 0x00);\n        uint8x8_t mask_2 = vdup_n_u8(mask[i+2] ? 0xFF : 0x00);\n        uint8x8_t mask_3 = vdup_n_u8(mask[i+3] ? 0xFF : 0x00);\n        uint8x8_t mask_4 = vdup_n_u8(mask[i+4] ? 0xFF : 0x00);\n        uint8x8_t mask_5 = vdup_n_u8(mask[i+5] ? 0xFF : 0x00);\n        uint8x8_t mask_6 = vdup_n_u8(mask[i+6] ? 0xFF : 0x00);\n        uint8x8_t mask_7 = vdup_n_u8(mask[i+7] ? 0xFF : 0x00);\n        \n        if (mask[i+0]) dst_vec_0 = vsetq_lane_s64(src[i+0], dst_vec_0, 0);\n        if (mask[i+1]) dst_vec_0 = vsetq_lane_s64(src[i+1], dst_vec_0, 1);\n        if (mask[i+2]) dst_vec_1 = vsetq_lane_s64(src[i+2], dst_vec_1, 0);\n        if (mask[i+3]) dst_vec_1 = vsetq_lane_s64(src[i+3], dst_vec_1, 1);\n        if (mask[i+4]) dst_vec_2 = vsetq_lane_s64(src[i+4], dst_vec_2, 0);\n        if (mask[i+5]) dst_vec_2 = vsetq_lane_s64(src[i+5], dst_vec_2, 1);\n        if (mask[i+6]) dst_vec_3 = vsetq_lane_s64(src[i+6], dst_vec_3, 0);\n        if (mask[i+7]) dst_vec_3 = vsetq_lane_s64(src[i+7], dst_vec_3, 1);\n        \n        vst1q_s64(dst + i, dst_vec_0);\n        vst1q_s64(dst + i + 2, dst_vec_1);\n        vst1q_s64(dst + i + 4, dst_vec_2);\n        vst1q_s64(dst + i + 6, dst_vec_3);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_vec = vld1_u8(mask + i);\n        int64x2_t src_vec_0 = vld1q_s64(src + i);\n        int64x2_t src_vec_1 = vld1q_s64(src + i + 2);\n        int64x2_t src_vec_2 = vld1q_s64(src + i + 4);\n        int64x2_t src_vec_3 = vld1q_s64(src + i + 6);\n\n        int64x2_t dst_vec_0 = vld1q_s64(dst + i);\n        int64x2_t dst_vec_1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst_vec_2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst_vec_3 = vld1q_s64(dst + i + 6);\n\n        uint8x8_t mask_0 = vdup_n_u8(0);\n        uint8x8_t mask_1 = vdup_n_u8(0);\n        uint8x8_t mask_2 = vdup_n_u8(0);\n        uint8x8_t mask_3 = vdup_n_u8(0);\n        uint8x8_t mask_4 = vdup_n_u8(0);\n        uint8x8_t mask_5 = vdup_n_u8(0);\n        uint8x8_t mask_6 = vdup_n_u8(0);\n        uint8x8_t mask_7 = vdup_n_u8(0);\n\n        if (mask_vec[0]) mask_0 = vdup_n_u8(0xFF);\n        if (mask_vec[1]) mask_1 = vdup_n_u8(0xFF);\n        if (mask_vec[2]) mask_2 = vdup_n_u8(0xFF);\n        if (mask_vec[3]) mask_3 = vdup_n_u8(0xFF);\n        if (mask_vec[4]) mask_4 = vdup_n_u8(0xFF);\n        if (mask_vec[5]) mask_5 = vdup_n_u8(0xFF);\n        if (mask_vec[6]) mask_6 = vdup_n_u8(0xFF);\n        if (mask_vec[7]) mask_7 = vdup_n_u8(0xFF);\n\n        if (mask_vec[0]) dst[i + 0] = src[i + 0];\n        if (mask_vec[1]) dst[i + 1] = src[i + 1];\n        if (mask_vec[2]) dst[i + 2] = src[i + 2];\n        if (mask_vec[3]) dst[i + 3] = src[i + 3];\n        if (mask_vec[4]) dst[i + 4] = src[i + 4];\n        if (mask_vec[5]) dst[i + 5] = src[i + 5];\n        if (mask_vec[6]) dst[i + 6] = src[i + 6];\n        if (mask_vec[7]) dst[i + 7] = src[i + 7];\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_vec = vld1_u8(mask + i);\n        int64x2_t src_vec_0 = vld1q_s64(src + i);\n        int64x2_t src_vec_1 = vld1q_s64(src + i + 2);\n        int64x2_t src_vec_2 = vld1q_s64(src + i + 4);\n        int64x2_t src_vec_3 = vld1q_s64(src + i + 6);\n\n        int64x2_t dst_vec_0 = vld1q_s64(dst + i);\n        int64x2_t dst_vec_1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst_vec_2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst_vec_3 = vld1q_s64(dst + i + 6);\n        \n        int64x2_t res_vec_0 = vbslq_s64(vreinterpretq_s64_u8(vdupq_lane_u8(mask_vec, 0)), src_vec_0, dst_vec_0);\n        int64x2_t res_vec_1 = vbslq_s64(vreinterpretq_s64_u8(vdupq_lane_u8(mask_vec, 2)), src_vec_1, dst_vec_1);\n        int64x2_t res_vec_2 = vbslq_s64(vreinterpretq_s64_u8(vdupq_lane_u8(mask_vec, 4)), src_vec_2, dst_vec_2);\n        int64x2_t res_vec_3 = vbslq_s64(vreinterpretq_s64_u8(vdupq_lane_u8(mask_vec, 6)), src_vec_3, dst_vec_3);\n\n        vst1q_s64(dst + i, res_vec_0);\n        vst1q_s64(dst + i + 2, res_vec_1);\n        vst1q_s64(dst + i + 4, res_vec_2);\n        vst1q_s64(dst + i + 6, res_vec_3);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(scaled_vec, 3);\n        int32x4_t tmp2 = vshlq_n_s32(scaled_vec, 3);\n        int32x4_t result_vec = vmlaq_s32(scaled_vec, tmp1, tmp2);\n        int32x4_t final_result = vqdmulhq_n_s32(result_vec, 1170453046 / 16777216.0f); // Divide by 7 using fixed-point multiplication\n        vst1q_s32(dst + i, final_result);\n    }\n\n    for (; i < length; ++i) {\n        int scaled_val = src[i] * scale;\n        int tmp1 = scaled_val >> 3;\n        int tmp2 = scaled_val << 3;\n        int result = (scaled_val + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(scaled_vec, 3);\n        int32x4_t tmp2 = vshlq_n_s32(scaled_vec, 3);\n        int32x4_t result_vec = vmlaq_s32(scaled_vec, tmp1, tmp2);\n        int32x4_t final_result = vdivq_n_s32(result_vec, 7);\n        vst1q_s32(dst + i, final_result);\n    }\n\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(scaled_vec, 3);\n        int32x4_t tmp2 = vshlq_n_s32(scaled_vec, 3);\n        int32x4_t product = vmulq_s32(tmp1, tmp2);\n        int32x4_t sum = vaddq_s32(scaled_vec, product);\n        int32x4_t result = vdivq_s32(sum, vdupq_n_s32(7));\n        vst1q_s32(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(scaled_vec, 3);\n        int32x4_t tmp2 = vshlq_n_s32(scaled_vec, 3);\n        int32x4_t result_vec = vmlaq_s32(scaled_vec, tmp1, tmp2);\n        int32x4_t final_result = vqdmulhq_n_s32(result_vec, 119124); // Divide by 7 using magic number\n        vst1q_s32(dst + i, final_result);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t prod_vec = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(prod_vec, 3);\n        int32x4_t tmp2 = vshlq_n_s32(prod_vec, 3);\n        int32x4_t tmp1_tmp2 = vmulq_s32(tmp1, tmp2);\n        int32x4_t sum_vec = vaddq_s32(prod_vec, tmp1_tmp2);\n\n        // Divide by 7.  Since we don't have integer division, approximate by multiplying by 1/7.\n        // 1/7 is approximately 0.142857.  We can multiply by 0.142857 * 2^32 and then shift right by 32.\n        // 0.142857 * 2^32 = 614891469.12, so we can use 614891469.\n        int32x4_t const_vec = vdupq_n_s32(614891469);\n        int64x2_t sum_vec_0_1 = vmull_s32(vget_low_s32(sum_vec), vget_low_s32(const_vec));\n        int64x2_t sum_vec_2_3 = vmull_s32(vget_high_s32(sum_vec), vget_high_s32(const_vec));\n        int32x4_t result_vec = vcombine_s32(vshrn_n_s64(sum_vec_0_1, 32), vshrn_n_s64(sum_vec_2_3, 32));\n\n        vst1q_s32(dst + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        double const *src1 = src + i * cols + stride;\n        double const *src2 = src + (i + 1) * cols + stride;\n\n        float64x2_t vec = vld1q_f64(src1);\n        vst1_lane_f64(dst + i, vec, 0);\n\n        vec = vld1q_f64(src2);\n        vst1_lane_f64(dst + i + 1, vec, 0);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        double const *src1 = src + i * cols + stride;\n        double const *src2 = src + (i + 1) * cols + stride;\n\n        float64x2_t vec = vld1q_f64(src1);\n        vst1_lane_f64(dst + i, vec, 0);\n\n        vec = vld1q_f64(src2);\n        vst1_lane_f64(dst + i + 1, vec, 0);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        double const *src1 = src + i * cols + stride;\n        double const *src2 = src + (i + 1) * cols + stride;\n\n        float64x2_t vec = vld1q_f64(src1);\n        vst1_lane_f64(dst + i, vec, 0);\n\n        vec = vld1q_f64(src2);\n        vst1_lane_f64(dst + i + 1, vec, 0);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        double const *src1 = src + i * cols + stride;\n        double const *src2 = src + (i + 1) * cols + stride;\n\n        float64x2_t vec = vld1q_f64(src1);\n        vst1_lane_f64(dst + i, vec, 0);\n\n        vec = vld1q_f64(src2);\n        vst1_lane_f64(dst + i + 1, vec, 0);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        double const *src1 = src + i * cols + stride;\n        double const *src2 = src + (i + 1) * cols + stride;\n\n        float64x2_t vec = vld1q_f64(src1);\n        vst1_lane_f64(dst + i, vec, 0);\n\n        vec = vld1q_f64(src2);\n        vst1_lane_f64(dst + i + 1, vec, 0);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_gather = {\n            src[vgetq_lane_s32(v_indices, 0)],\n            src[vgetq_lane_s32(v_indices, 1)],\n            src[vgetq_lane_s32(v_indices, 2)],\n            src[vgetq_lane_s32(v_indices, 3)]\n        };\n        vst1q_f32(dst + i, v_gather);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_src = vld1q_f32(src + i);\n\n        dst[vgetq_lane_s32(v_indices, 0)] = vgetq_lane_f32(v_src, 0);\n        dst[vgetq_lane_s32(v_indices, 1)] = vgetq_lane_f32(v_src, 1);\n        dst[vgetq_lane_s32(v_indices, 2)] = vgetq_lane_f32(v_src, 2);\n        dst[vgetq_lane_s32(v_indices, 3)] = vgetq_lane_f32(v_src, 3);\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_gather = {\n            src[vgetq_lane_s32(v_indices, 0)],\n            src[vgetq_lane_s32(v_indices, 1)],\n            src[vgetq_lane_s32(v_indices, 2)],\n            src[vgetq_lane_s32(v_indices, 3)]\n        };\n        vst1q_f32(dst + i, v_gather);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        \n        dst[vgetq_lane_s32(v_indices, 0)] = src[i + 0];\n        dst[vgetq_lane_s32(v_indices, 1)] = src[i + 1];\n        dst[vgetq_lane_s32(v_indices, 2)] = src[i + 2];\n        dst[vgetq_lane_s32(v_indices, 3)] = src[i + 3];\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t index_vec = vld1q_s32(indices + i);\n        float32x4_t gathered_vec;\n\n        // Gather operation\n        gathered_vec[0] = src[index_vec[0]];\n        gathered_vec[1] = src[index_vec[1]];\n        gathered_vec[2] = src[index_vec[2]];\n        gathered_vec[3] = src[index_vec[3]];\n        \n        vst1q_f32(dst + i, gathered_vec);\n\n        // Scatter operation\n        dst[index_vec[0]] = src[i + 0];\n        dst[index_vec[1]] = src[i + 1];\n        dst[index_vec[2]] = src[i + 2];\n        dst[index_vec[3]] = src[i + 3];\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_gather = {\n            src[vgetq_lane_s32(v_indices, 0)],\n            src[vgetq_lane_s32(v_indices, 1)],\n            src[vgetq_lane_s32(v_indices, 2)],\n            src[vgetq_lane_s32(v_indices, 3)]\n        };\n        vst1q_f32(dst + i, v_gather);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_src = vld1q_f32(src + i);\n\n        dst[vgetq_lane_s32(v_indices, 0)] = vgetq_lane_f32(v_src, 0);\n        dst[vgetq_lane_s32(v_indices, 1)] = vgetq_lane_f32(v_src, 1);\n        dst[vgetq_lane_s32(v_indices, 2)] = vgetq_lane_f32(v_src, 2);\n        dst[vgetq_lane_s32(v_indices, 3)] = vgetq_lane_f32(v_src, 3);\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_gather = {\n            src[vgetq_lane_s32(v_indices, 0)],\n            src[vgetq_lane_s32(v_indices, 1)],\n            src[vgetq_lane_s32(v_indices, 2)],\n            src[vgetq_lane_s32(v_indices, 3)]\n        };\n        vst1q_f32(dst + i, v_gather);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_indices = vld1q_s32(indices + i);\n        float32x4_t v_src = vld1q_f32(src + i);\n\n        dst[vgetq_lane_s32(v_indices, 0)] = vgetq_lane_f32(v_src, 0);\n        dst[vgetq_lane_s32(v_indices, 1)] = vgetq_lane_f32(v_src, 1);\n        dst[vgetq_lane_s32(v_indices, 2)] = vgetq_lane_f32(v_src, 2);\n        dst[vgetq_lane_s32(v_indices, 3)] = vgetq_lane_f32(v_src, 3);\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n    uint64_t remaining = len % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        int16_t *p1 = arr + start + i * 8;\n        int16_t *p2 = arr + end - (i * 8);\n\n        int16x8_t v1 = vld1q_s16(p1);\n        int16x8_t v2 = vld1q_s16(p2 - 7);\n\n        vst1q_s16(p1, v2);\n        vst1q_s16(p2 - 7, v1);\n    }\n\n    uint64_t offset = num_iters * 8;\n    for (uint64_t i = 0; i < remaining / 2; ++i) {\n        int16_t temp = arr[start + offset + i];\n        arr[start + offset + i] = arr[end - offset - i];\n        arr[end - offset - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n    uint64_t remaining = len % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        int16_t *p1 = arr + start + i * 8;\n        int16_t *p2 = arr + end - (i * 8) - 7;\n\n        int16x8_t v1 = vld1q_s16(p1);\n        int16x8_t v2 = vld1q_s16(p2);\n\n        vst1q_s16(p1, v2);\n        vst1q_s16(p2, v1);\n    }\n\n    uint64_t offset = num_iters * 8;\n    for (uint64_t i = 0; i < remaining / 2; ++i) {\n        int16_t temp = arr[start + offset + i];\n        arr[start + offset + i] = arr[end - offset - i];\n        arr[end - offset - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n    uint64_t remaining = len % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        int16_t *p1 = arr + start + i * 8;\n        int16_t *p2 = arr + end - (i * 8) - 7;\n\n        int16x8_t v1 = vld1q_s16(p1);\n        int16x8_t v2 = vld1q_s16(p2);\n\n        vst1q_s16(p1, v2);\n        vst1q_s16(p2, v1);\n    }\n\n    uint64_t offset = num_iters * 8;\n    for (uint64_t i = 0; i < remaining / 2; ++i) {\n        int16_t temp = arr[start + offset + i];\n        arr[start + offset + i] = arr[end - offset - i];\n        arr[end - offset - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n    uint64_t remaining = len % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        int16_t *p1 = arr + start + i * 8;\n        int16_t *p2 = arr + end - (i * 8);\n\n        int16x8_t v1 = vld1q_s16(p1);\n        int16x8_t v2 = vld1q_s16(p2 - 7);\n\n        vst1q_s16(p1, v2);\n        vst1q_s16(p2 - 7, v1);\n    }\n\n    uint64_t offset = num_iters * 8;\n    for (uint64_t i = 0; i < remaining / 2; ++i) {\n        int16_t temp = arr[start + offset + i];\n        arr[start + offset + i] = arr[end - offset - i];\n        arr[end - offset - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n    uint64_t remaining = len % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        int16_t *p1 = arr + start + i * 8;\n        int16_t *p2 = arr + end - (i * 8) - 7;\n\n        int16x8_t v1 = vld1q_s16(p1);\n        int16x8_t v2 = vld1q_s16(p2);\n\n        vst1q_s16(p1, v2);\n        vst1q_s16(p2, v1);\n    }\n\n    uint64_t offset = num_iters * 8;\n    for (uint64_t i = 0; i < remaining; ++i) {\n        int16_t temp = arr[start + offset + i];\n        arr[start + offset + i] = arr[end - offset - i];\n        arr[end - offset - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx;\n\n    for (size_t i = 0; i < dim1; ++i) {\n        size_t row_offset = i * dim2;\n        const uint8_t *tensor_row_ptr = slice_start + row_offset * dim3;\n        uint8_t *slice_row_ptr = slice + row_offset;\n\n        size_t j = 0;\n        for (; j + 16 <= dim2; j += 16) {\n            uint8x16_t vec = vld1q_u8(tensor_row_ptr + j);\n            vst1q_u8(slice_row_ptr + j, vec);\n        }\n\n        for (; j < dim2; ++j) {\n            slice_row_ptr[j] = tensor_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice_ptr = tensor + slice_idx * dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + 16 <= slice_size; i += 16) {\n        vst1q_u8(slice + i, vld1q_u8(tensor_slice_ptr + i));\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = tensor_slice_ptr[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice_ptr = tensor + slice_idx * dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + 16 <= slice_size; i += 16) {\n        vst1q_u8(slice + i, vld1q_u8(tensor_slice_ptr + i));\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = tensor_slice_ptr[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice_ptr = tensor + slice_idx * dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + 16 <= slice_size; i += 16) {\n        vst1q_u8(slice + i, vld1q_u8(tensor_slice_ptr + i));\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = tensor_slice_ptr[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + 16 <= slice_size; i += 16) {\n        uint8x16_t vec = vld1q_u8(slice_start + i);\n        vst1q_u8(slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; y += 8) {\n                    if (j + y + 7 < cols) {\n                        int16_t const *src_ptr = src + (i + x) * cols + j + y;\n                        int16x8_t v = vld1q_s16(src_ptr);\n                        int16_t *dst_ptr = dst + (j + y) * rows + i + x;\n                        vst1q_s16(dst_ptr, v);\n                    } else {\n                        for (size_t yy = y; yy < block_cols; ++yy) {\n                            dst[(j + yy) * rows + i + x] = src[(i + x) * cols + j + yy];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; y += 8) {\n                    if (j + y + 7 < cols) {\n                        int16_t const *src_ptr = src + (i + x) * cols + j + y;\n                        int16x8_t v = vld1q_s16(src_ptr);\n                        int16_t *dst_ptr = dst + (j + y) * rows + i + x;\n                        vst1q_s16(dst_ptr, v);\n                    } else {\n                        for (size_t z = y; z < block_cols; ++z) {\n                            dst[(j + z) * rows + i + x] = src[(i + x) * cols + j + z];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; y += 8) {\n                    if (j + y + 7 < cols) {\n                        int16_t const *src_ptr = src + (i + x) * cols + j + y;\n                        int16x8_t v = vld1q_s16(src_ptr);\n                        int16_t *dst_ptr = dst + (j + y) * rows + i + x;\n                        vst1q_s16(dst_ptr, v);\n                    } else {\n                        for (size_t yy = y; yy < block_cols; ++yy) {\n                            dst[(j + yy) * rows + i + x] = src[(i + x) * cols + j + yy];\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; y += 8) {\n                    if (j + y + 7 < cols) {\n                        int16_t const *src_ptr = src + (i + x) * cols + j + y;\n                        int16x8_t v = vld1q_s16(src_ptr);\n                        int16_t *dst_ptr = dst + (j + y) * rows + i + x;\n                        vst1q_s16(dst_ptr, v);\n                    } else {\n                        for (size_t z = y; z < block_cols; ++z) {\n                            dst[(j + z) * rows + i + x] = src[(i + x) * cols + j + z];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < (i + block_size > rows ? rows : i + block_size); ++x) {\n                for (size_t y = j; y < (j + block_size > cols ? cols : j + block_size); ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t index = 0;\n\n    for (size_t i = 0; i < dim; ++i) {\n        index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t index = 0;\n\n    for (size_t i = 0; i < dim; ++i) {\n        index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n    size_t num_elements = dim;\n\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i + 4 <= num_elements; i += 4) {\n        float32x4_t diag_vec = vld1q_f32(array + i * stride);\n        sum_vec = vaddq_f32(sum_vec, diag_vec);\n    }\n\n    sum += vgetq_lane_f32(sum_vec, 0);\n    sum += vgetq_lane_f32(sum_vec, 1);\n    sum += vgetq_lane_f32(sum_vec, 2);\n    sum += vgetq_lane_f32(sum_vec, 3);\n\n    for (; i < num_elements; ++i) {\n        sum += array[i * stride];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t index = 0;\n\n    for (size_t i = 0; i < dim; ++i) {\n        index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t index = 0;\n\n    for (size_t i = 0; i < dim; ++i) {\n        index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            float64x2_t v_src = vld1q_f64(src + i * cols + j);\n            float64x2_t v_threshold = vdupq_n_f64(threshold);\n            float64x2_t v_scale = vdupq_n_f64(scale);\n\n            uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n\n            float64x2_t v_result = vbslq_f64(mask, v_scaled, v_src);\n\n            vst1q_f64(dst + i * cols + j, v_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            float64x2_t v_src = vld1q_f64(src + i * cols + j);\n            float64x2_t v_threshold = vdupq_n_f64(threshold);\n            float64x2_t v_scale = vdupq_n_f64(scale);\n\n            uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n\n            float64x2_t v_result = vbslq_f64(mask, v_scaled, v_src);\n\n            vst1q_f64(dst + i * cols + j, v_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    size_t total_elements = rows * cols;\n    size_t vectorizable_elements = total_elements - (total_elements % 2);\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n    float64x2_t scale_vec = vdupq_n_float64(scale);\n\n    for (i = 0; i < vectorizable_elements; i += 2) {\n        float64x2_t src_vec = vld1q_f64(src + i);\n        uint64x2_t cmp_vec = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(cmp_vec, scaled_vec, src_vec);\n        vst1q_f64(dst + i, result_vec);\n    }\n\n    for (i = vectorizable_elements; i < total_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    size_t total_elements = rows * cols;\n    size_t vectorized_loop_count = total_elements / 2;\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n    float64x2_t scale_vec = vdupq_n_float64(scale);\n\n    for (i = 0; i < vectorized_loop_count; ++i) {\n        float64x2_t src_vec = vld1q_f64(src + i * 2);\n        uint64x2_t cmp_vec = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t result_vec = vbslq_f64(cmp_vec, vmulq_f64(src_vec, scale_vec), src_vec);\n        vst1q_f64(dst + i * 2, result_vec);\n    }\n\n    // Handle remaining elements if total_elements is not a multiple of 2\n    for (i = vectorized_loop_count * 2; i < total_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols / cols_per_loop * cols_per_loop; j += cols_per_loop) {\n            float64x2_t v_src = vld1q_f64(src + i * cols + j);\n            float64x2_t v_threshold = vdupq_n_f64(threshold);\n            float64x2_t v_scale = vdupq_n_f64(scale);\n\n            uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n\n            float64x2_t v_dst = vbslq_f64(mask, v_scaled, v_src);\n\n            vst1q_f64(dst + i * cols + j, v_dst);\n        }\n\n        for (j = cols / cols_per_loop * cols_per_loop; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index < rows) {\n            size_t col_blocks = cols / 2;\n            size_t remaining_cols = cols % 2;\n\n            for (j = 0; j < col_blocks; ++j) {\n                double const *src_ptr = src + index * cols + j * 2;\n                double *dst_ptr = dst + i * cols + j * 2;\n\n                float64x2_t data = vld1q_f64(src_ptr);\n                vst1q_f64(dst_ptr, data);\n            }\n\n            if (remaining_cols > 0) {\n                for (j = col_blocks * 2; j < cols; ++j) {\n                    dst[i * cols + j] = src[index * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index < rows) {\n            size_t col_blocks = cols / 2;\n            size_t remaining_cols = cols % 2;\n\n            for (j = 0; j < col_blocks; ++j) {\n                double const *src_ptr = src + index * cols + j * 2;\n                double *dst_ptr = dst + i * cols + j * 2;\n\n                float64x2_t data = vld1q_f64(src_ptr);\n                vst1q_f64(dst_ptr, data);\n            }\n\n            if (remaining_cols > 0) {\n                for (j = col_blocks * 2; j < cols; ++j) {\n                    dst[i * cols + j] = src[index * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index < rows) {\n            const double *src_row = src + index * cols;\n            double *dst_row = dst + i * cols;\n\n            size_t col = 0;\n            for (col = 0; col + 1 < cols; col += 2) {\n                float64x2_t vec = vld1q_f64(src_row + col);\n                vst1q_f64(dst_row + col, vec);\n            }\n            for (; col < cols; ++col) {\n                dst_row[col] = src_row[col];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index < rows) {\n            const double *src_row = src + index * cols;\n            double *dst_row = dst + i * cols;\n\n            size_t col = 0;\n            for (col = 0; col + 1 < cols; col += 2) {\n                float64x2_t vec = vld1q_f64(src_row + col);\n                vst1q_f64(dst_row + col, vec);\n            }\n            for (; col < cols; ++col) {\n                dst_row[col] = src_row[col];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index < rows) {\n            const double *src_row = src + index * cols;\n            double *dst_row = dst + i * cols;\n\n            size_t col = 0;\n            for (col = 0; col + 3 < cols; col += 4) {\n                float64x2x2_t data = vld2q_f64(src_row + col);\n                vst2q_f64(dst_row + col, data);\n            }\n            for (; col < cols; ++col) {\n                dst_row[col] = src_row[col];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x1_t scalar_vec = vdup_n_s64(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        int64x2_t added_scalar = vaddq_s64(sum, vcombine_s64(scalar_vec, scalar_vec));\n        int64x2_t result = vshrq_n_s64(added_scalar, 1);\n\n        vst1q_s64(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        int64x2_t added = vaddq_s64(sum, scalar_vec);\n        int64x2_t result = vshrq_n_s64(added, 1);\n        vst1q_s64(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        int64x2_t added = vaddq_s64(sum, scalar_vec);\n        int64x2_t result = vshrq_n_s64(added, 1);\n        vst1q_s64(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x1_t scalar_vec = vdup_n_s64(scalar);\n\n    for (i = 0; i + 1 < length; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        int64x2_t added_scalar = vaddq_s64(sum, vcombine_s64(scalar_vec, scalar_vec));\n        int64x2_t result = vshrq_n_s64(added_scalar, 1);\n\n        vst1q_s64(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        int64x2_t added_scalar = vaddq_s64(sum, scalar_vec);\n        int64x2_t result = vshrq_n_s64(added_scalar, 1);\n        vst1q_s64(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t i = 0;\n\n    if (length >= 4) {\n        int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n\n        for (; i + 7 < length; i += 8) {\n            int32x4_t vec1 = vld1q_s32(src + i);\n            int32x4_t vec2 = vld1q_s32(src + i + 4);\n\n            int32x2_t even_vec1 = vget_low_s32(vec1);\n            int32x2_t even_vec2 = vget_high_s32(vec1);\n            int32x2_t even_vec3 = vget_low_s32(vec2);\n            int32x2_t even_vec4 = vget_high_s32(vec2);\n\n            int32x4_t combined_even = vcombine_s32(even_vec1, even_vec2);\n            int32x4_t combined_even2 = vcombine_s32(even_vec3, even_vec4);\n\n            min_vec = vminq_s32(min_vec, combined_even);\n            min_vec = vminq_s32(min_vec, combined_even2);\n        }\n\n        int32x2_t min_pair = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n        min_val = vget_lane_s32(min_pair, 0);\n        min_val = (vget_lane_s32(min_pair, 1) < min_val) ? vget_lane_s32(min_pair, 1) : min_val;\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_val = (src[i] < min_val) ? src[i] : min_val;\n        }\n    }\n\n    return (min_val == INT_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t i = 0;\n\n    if (length >= 4) {\n        int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n\n        for (; i + 7 < length; i += 8) {\n            int32x4_t vec1 = vld1q_s32(src + i);\n            int32x4_t vec2 = vld1q_s32(src + i + 4);\n\n            int32x2_t even_vec1 = vget_low_s32(vec1);\n            int32x2_t even_vec2 = vget_high_s32(vec1);\n            int32x2_t even_vec3 = vget_low_s32(vec2);\n            int32x2_t even_vec4 = vget_high_s32(vec2);\n\n            int32x4_t combined_even = vcombine_s32(even_vec1, even_vec3);\n\n            min_vec = vminq_s32(min_vec, combined_even);\n        }\n\n        int32_t temp_min[4];\n        vst1q_s32(temp_min, min_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp_min[j] < min_val) {\n                min_val = temp_min[j];\n            }\n        }\n    }\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t i = 0;\n\n    if (length >= 4) {\n        int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n\n        for (; i + 7 < length; i += 8) {\n            int32x4_t vec1 = vld1q_s32(src + i);\n            int32x4_t vec2 = vld1q_s32(src + i + 4);\n\n            int32x2_t even_vec1 = vget_low_s32(vec1);\n            int32x2_t even_vec2 = vget_high_s32(vec1);\n            int32x2_t even_vec3 = vget_low_s32(vec2);\n            int32x2_t even_vec4 = vget_high_s32(vec2);\n\n            int32x4_t combined_even = vcombine_s32(even_vec1, even_vec3);\n\n            min_vec = vminq_s32(min_vec, combined_even);\n        }\n\n        int32_t temp_min[4];\n        vst1q_s32(temp_min, min_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp_min[j] < min_val) {\n                min_val = temp_min[j];\n            }\n        }\n    }\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t i = 0;\n\n    if (length >= 4) {\n        int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n\n        for (; i + 7 < length; i += 8) {\n            int32x4_t vec1 = vld1q_s32(src + i);\n            int32x4_t vec2 = vld1q_s32(src + i + 4);\n\n            int32x2_t even_vec1 = vget_low_s32(vec1);\n            int32x2_t even_vec2 = vget_high_s32(vec1);\n            int32x2_t even_vec3 = vget_low_s32(vec2);\n            int32x2_t even_vec4 = vget_high_s32(vec2);\n\n            int32x4_t combined_even = vcombine_s32(even_vec1, even_vec3);\n\n            min_vec = vminq_s32(min_vec, combined_even);\n        }\n\n        int32_t temp_min[4];\n        vst1q_s32(temp_min, min_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp_min[j] < min_val) {\n                min_val = temp_min[j];\n            }\n        }\n    }\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t i = 0;\n\n    if (length >= 4) {\n        int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n\n        for (; i + 7 < length; i += 8) {\n            int32x4_t vec1 = vld1q_s32(src + i);\n            int32x4_t vec2 = vld1q_s32(src + i + 4);\n\n            int32x2_t even_vec1 = vget_low_s32(vec1);\n            int32x2_t even_vec2 = vget_high_s32(vec1);\n            int32x2_t even_vec3 = vget_low_s32(vec2);\n            int32x2_t even_vec4 = vget_high_s32(vec2);\n\n            int32x4_t combined_even = vcombine_s32(even_vec1, even_vec3);\n\n            min_vec = vminq_s32(min_vec, combined_even);\n        }\n\n        int32_t temp_min[4];\n        vst1q_s32(temp_min, min_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp_min[j] < min_val) {\n                min_val = temp_min[j];\n            }\n        }\n    }\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t vec_asr = vshrq_n_s32(vec_src, shift);\n        \n        // Logical right shift\n        uint32x4_t vec_uint = vreinterpretq_u32_s32(vec_src);\n        uint32x4_t vec_lsr = vshrq_n_u32(vec_uint, shift);\n        int32x4_t vec_lsr_int = vreinterpretq_s32_u32(vec_lsr);\n        \n        // Add the results\n        int32x4_t vec_dst = vaddq_s32(vec_asr, vec_lsr_int);\n        \n        // Store the result\n        vst1q_s32(dst + i, vec_dst);\n    }\n    \n    // Process remaining elements\n    for (; i < length; ++i) {\n        int asr = src[i] >> shift;\n        int lsr = (int)((uint32_t)src[i] >> shift);\n        dst[i] = asr + lsr;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t vec_asr = vshrq_n_s32(vec_src, shift);\n        \n        // Logical right shift\n        uint32x4_t vec_uint = vreinterpretq_u32_s32(vec_src);\n        uint32x4_t vec_lsr = vshrq_n_u32(vec_uint, shift);\n        int32x4_t vec_lsr_int = vreinterpretq_s32_u32(vec_lsr);\n        \n        // Add the results\n        int32x4_t vec_dst = vaddq_s32(vec_asr, vec_lsr_int);\n        \n        // Store the result\n        vst1q_s32(dst + i, vec_dst);\n    }\n    \n    // Process remaining elements\n    for (; i < length; ++i) {\n        int asr = src[i] >> shift;\n        int lsr = (int)((uint32_t)src[i] >> shift);\n        dst[i] = asr + lsr;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t vec_arith_shift = vshrq_n_s32(vec_src, shift);\n        \n        // Logical right shift\n        uint32x4_t vec_uint_src = vreinterpretq_u32_s32(vec_src);\n        uint32x4_t vec_logical_shift_uint = vshrq_n_u32(vec_uint_src, shift);\n        int32x4_t vec_logical_shift = vreinterpretq_s32_u32(vec_logical_shift_uint);\n        \n        // Add the results\n        int32x4_t vec_sum = vaddq_s32(vec_arith_shift, vec_logical_shift);\n        \n        // Store the result\n        vst1q_s32(dst + i, vec_sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t vec_arithmetic = vshrq_n_s32(vec_src, shift);\n        \n        // Logical right shift\n        uint32x4_t vec_uint = vreinterpretq_u32_s32(vec_src);\n        uint32x4_t vec_logical_uint = vshrq_n_u32(vec_uint, shift);\n        int32x4_t vec_logical = vreinterpretq_s32_u32(vec_logical_uint);\n        \n        // Add the results\n        int32x4_t vec_result = vaddq_s32(vec_arithmetic, vec_logical);\n        \n        // Store the result\n        vst1q_s32(dst + i, vec_result);\n    }\n    \n    // Process remaining elements\n    for (; i < length; ++i) {\n        int arithmetic = src[i] >> shift;\n        int logical = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t vec_arithmetic_shift = vshrq_n_s32(vec_src, shift);\n        \n        // Logical right shift\n        uint32x4_t vec_uint_src = vreinterpretq_u32_s32(vec_src);\n        uint32x4_t vec_logical_shift_uint = vshrq_n_u32(vec_uint_src, shift);\n        int32x4_t vec_logical_shift = vreinterpretq_s32_u32(vec_logical_shift_uint);\n        \n        // Add the results\n        int32x4_t vec_sum = vaddq_s32(vec_arithmetic_shift, vec_logical_shift);\n        \n        // Store the result\n        vst1q_s32(dst + i, vec_sum);\n    }\n    \n    // Process remaining elements\n    for (; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    // Use Neon to sum 4 integers at a time\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vreinterpretq_s64_s32(vaddw_s32(vcreate_s32(0), vget_low_s32(vec)));\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(vaddw_s32(vcreate_s32(0), vget_high_s32(vec))));\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    // Use Neon to sum 4 integers at a time\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vreinterpretq_s64_s32(vaddw_s32(vcreate_s32(0), vget_low_s32(vec)));\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(vaddw_s32(vcreate_s32(0), vget_high_s32(vec))));\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    if (total_elements >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (; i <= total_elements - 4; i += 4) {\n            int32x4_t data_vec = vld1q_s32(matrix + i);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        int32x2_t sum_low = vget_low_s32(sum_vec);\n        int32x2_t sum_high = vget_high_s32(sum_vec);\n        int32x2_t total_sum_vec = vadd_s32(sum_low, sum_high);\n        sum = vget_lane_s32(total_sum_vec, 0) + vget_lane_s32(total_sum_vec, 1);\n    }\n    \n\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    // Use Neon to sum 4 integers at a time\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    // Process 4 elements at a time using NEON\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        int8x16_t max_val_vec = vdupq_n_s8(max_value);\n        uint8x16_t index_vec = vdupq_n_u8(0);\n        uint8x16_t increment_vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n        for (; i <= length - 16; i += 16) {\n            int8x16_t current_vec = vld1q_s8(src + i);\n            uint8x16_t mask = vcltq_s8(max_val_vec, current_vec);\n            max_val_vec = vbslq_s8(mask, current_vec, max_val_vec);\n            index_vec = vbslq_u8(mask, vdupq_n_u8(i) + increment_vec, index_vec);\n        }\n\n        int8_t max_val_arr[16];\n        uint8_t index_arr[16];\n        vst1q_s8(max_val_arr, max_val_vec);\n        vst1q_u8(index_arr, index_vec);\n\n        for (int j = 0; j < 16; ++j) {\n            if (max_val_arr[j] > max_value) {\n                max_value = max_val_arr[j];\n                max_index = i - 16 + index_arr[j];\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        int8x16_t max_val_vec = vdupq_n_s8(max_value);\n        uint8x16_t index_vec = vdupq_n_u8(0);\n        uint8x16_t increment_vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n        for (; i <= length - 16; i += 16) {\n            int8x16_t current_vec = vld1q_s8(src + i);\n            uint8x16_t mask = vcltq_s8(max_val_vec, current_vec);\n            max_val_vec = vbslq_s8(mask, current_vec, max_val_vec);\n            index_vec = vbslq_u8(mask, vdupq_n_u8(i) + increment_vec, index_vec);\n        }\n\n        int8_t max_val_arr[16];\n        uint8_t index_arr[16];\n        vst1q_s8(max_val_arr, max_val_vec);\n        vst1q_u8(index_arr, index_vec);\n\n        for (int j = 0; j < 16; ++j) {\n            if (max_val_arr[j] > max_value) {\n                max_value = max_val_arr[j];\n                max_index = i - 16 + index_arr[j];\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        int8x16_t max_val_vec = vdupq_n_s8(max_value);\n        uint8x16_t index_vec = vdupq_n_u8(0);\n        uint8x16_t increment_vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n        for (; i <= length - 16; i += 16) {\n            int8x16_t current_vec = vld1q_s8(src + i);\n            uint8x16_t mask = vcltq_s8(max_val_vec, current_vec);\n            max_val_vec = vbslq_s8(mask, current_vec, max_val_vec);\n            index_vec = vbslq_u8(mask, vdupq_n_u8(i) + increment_vec, index_vec);\n        }\n\n        int8_t max_val_arr[16];\n        uint8_t index_arr[16];\n        vst1q_s8(max_val_arr, max_val_vec);\n        vst1q_u8(index_arr, index_vec);\n\n        for (int j = 0; j < 16; ++j) {\n            if (max_val_arr[j] > max_value) {\n                max_value = max_val_arr[j];\n                max_index = i - 16 + index_arr[j];\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        int8x16_t max_val_vec = vdupq_n_s8(max_value);\n        uint8x16_t index_vec = vdupq_n_u8(0);\n        uint8x16_t increment_vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n\n        for (; i <= length - 16; i += 16) {\n            int8x16_t current_vec = vld1q_s8(src + i);\n            uint8x16_t mask = vcltq_s8(max_val_vec, current_vec);\n            max_val_vec = vbslq_s8(mask, current_vec, max_val_vec);\n            index_vec = vbslq_u8(mask, vdupq_n_u8(i) + increment_vec, index_vec);\n        }\n\n        int8_t max_val_arr[16];\n        uint8_t index_arr[16];\n        vst1q_s8(max_val_arr, max_val_vec);\n        vst1q_u8(index_arr, index_vec);\n\n        for (int j = 0; j < 16; ++j) {\n            if (max_val_arr[j] > max_value) {\n                max_value = max_val_arr[j];\n                max_index = i - 16 + index_arr[j];\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t i = 0;\n    int8_t max_val = src[0];\n    size_t max_index = 0;\n\n    if (length >= 16) {\n        int8x16_t max_vec = vdupq_n_s8(src[0]);\n        uint8x16_t index_vec = vdupq_n_u8(0);\n        int8_t current_max_val = src[0];\n        size_t current_max_index = 0;\n\n        for (; i <= length - 16; i += 16) {\n            int8x16_t data_vec = vld1q_s8(src + i);\n            uint8x16_t offset_vec = vdupq_n_u8(i);\n            uint8x16_t index_increment = vcreateq_u8((uint64_t){0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n            uint8x16_t current_index_vec = vaddq_u8(offset_vec, index_increment);\n\n            int8x16_t cmp_vec = vcgtq_s8(data_vec, max_vec);\n            \n            if (vmaxvq_s8(cmp_vec) > 0) {\n                uint8x16_t mask = (uint8x16_t)vmovq_s8(cmp_vec);\n                uint8x16_t masked_index = vandq_u8(current_index_vec, mask);\n\n                uint8_t temp_index[16];\n                vst1q_u8(temp_index, masked_index);\n\n                int8_t temp_data[16];\n                vst1q_s8(temp_data, data_vec);\n\n                for(int j = 0; j < 16; ++j) {\n                    if(cmp_vec[j] != 0) {\n                        if (temp_data[j] > current_max_val) {\n                            current_max_val = temp_data[j];\n                            current_max_index = temp_index[j];\n                        }\n                    }\n                }\n                max_vec = vdupq_n_s8(current_max_val);\n                max_index = current_max_index;\n            }\n        }\n        max_val = current_max_val;\n        \n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            uint16x8_t vec_src1 = vld1q_u16(src1 + i);\n            uint16x8_t vec_src2 = vld1q_u16(src2 + i);\n            uint16x8_t vec_mask;\n            uint16_t mask_arr[8];\n            for (int j = 0; j < 8; ++j) {\n                if ((i + j) & mask) {\n                    mask_arr[j] = 0xFFFF;\n                } else {\n                    mask_arr[j] = 0x0000;\n                }\n            }\n            vec_mask = vld1q_u16(mask_arr);\n            uint16x8_t vec_dst = vbslq_u16(vec_mask, vec_src1, vec_src2);\n            vst1q_u16(dst + i, vec_dst);\n        }\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            uint16x8_t vec1 = vld1q_u16(src1 + i);\n            uint16x8_t vec2 = vld1q_u16(src2 + i);\n            uint16x8_t blend_mask;\n\n            uint16_t blend_array[8];\n            for (int j = 0; j < 8; ++j) {\n                if ((i + j) & mask) {\n                    blend_array[j] = 0xFFFF; \n                } else {\n                    blend_array[j] = 0x0000;\n                }\n            }\n            blend_mask = vld1q_u16(blend_array);\n\n            uint16x8_t result = vbslq_u16(blend_mask, vec1, vec2);\n            vst1q_u16(dst + i, result);\n        }\n    }\n    for (; i < length; ++i) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            uint16x8_t v_src1 = vld1q_u16(src1 + i);\n            uint16x8_t v_src2 = vld1q_u16(src2 + i);\n            uint16x8_t v_mask;\n            uint16_t mask_arr[8];\n            for (int j = 0; j < 8; ++j) {\n                if ((i + j) & mask) {\n                    mask_arr[j] = 0xFFFF;\n                } else {\n                    mask_arr[j] = 0x0000;\n                }\n            }\n            v_mask = vld1q_u16(mask_arr);\n            uint16x8_t v_result = vbslq_u16(v_mask, v_src1, v_src2);\n            vst1q_u16(dst + i, v_result);\n        }\n    }\n    for (; i < length; ++i) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            uint16x8_t v_src1 = vld1q_u16(src1 + i);\n            uint16x8_t v_src2 = vld1q_u16(src2 + i);\n            uint16x8_t v_mask;\n\n            uint16_t mask_arr[8];\n            for (int j = 0; j < 8; ++j) {\n                if ((i + j) & mask) {\n                    mask_arr[j] = 0xFFFF;\n                } else {\n                    mask_arr[j] = 0x0000;\n                }\n            }\n            v_mask = vld1q_u16(mask_arr);\n\n            uint16x8_t v_result = vbslq_u16(v_mask, v_src1, v_src2);\n            vst1q_u16(dst + i, v_result);\n        }\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            uint32x2_t index_vec_0 = {i, i + 1};\n            uint32x2_t index_vec_1 = {i + 2, i + 3};\n            uint32x2_t index_vec_2 = {i + 4, i + 5};\n            uint32x2_t index_vec_3 = {i + 6, i + 7};\n\n            uint32x4_t index_vec_low = vcombine_u32(index_vec_0, index_vec_1);\n            uint32x4_t index_vec_high = vcombine_u32(index_vec_2, index_vec_3);\n            \n            uint32x4_t mask_vec_low = vdupq_n_u32(mask);\n            uint32x4_t mask_vec_high = vdupq_n_u32(mask);\n\n            uint32x4_t and_result_low = vandq_u32(index_vec_low, mask_vec_low);\n            uint32x4_t and_result_high = vandq_u32(index_vec_high, mask_vec_high);\n\n            uint16x8_t src1_vec = vld1q_u16(src1 + i);\n            uint16x8_t src2_vec = vld1q_u16(src2 + i);\n\n            uint16x8_t result_vec;\n            for (int j = 0; j < 4; ++j) {\n                if (and_result_low[j] != 0) {\n                    dst[i + j] = src1[i + j];\n                } else {\n                    dst[i + j] = src2[i + j];\n                }\n            }\n            for (int j = 0; j < 4; ++j) {\n                if (and_result_high[j] != 0) {\n                    dst[i + 4 + j] = src1[i + 4 + j];\n                } else {\n                    dst[i + 4 + j] = src2[i + 4 + j];\n                }\n            }\n        }\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(data));\n        uint32x4_t sum1 = vpaddlq_u16(vreinterpretq_u16_u8(vget_low_u8(count)));\n        uint32x4_t sum2 = vpaddlq_u16(vreinterpretq_u16_u8(vget_high_u8(count)));\n        uint32x4_t total_sum = vaddq_u32(sum1, sum2);\n        vst1q_u32(dst + i, total_sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t val = src[i];\n        uint32_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(data));\n        uint32x4_t sum1 = vpaddlq_u16(vreinterpretq_u16_u8(vget_low_u8(count)));\n        uint32x4_t sum2 = vpaddlq_u16(vreinterpretq_u16_u8(vget_high_u8(count)));\n        uint32x4_t total_sum = vaddq_u32(sum1, sum2);\n        vst1q_u32(dst + i, total_sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t val = src[i];\n        uint32_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        uint32x4_t tmp;\n\n        tmp = vandq_u32(data, vdupq_n_u32(0x55555555));\n        count = vaddq_u32(count, tmp);\n        data = vshrq_n_u32(data, 1);\n\n        tmp = vandq_u32(data, vdupq_n_u32(0x55555555));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vandq_u32(count, vdupq_n_u32(0x33333333));\n        count = vshrq_n_u32(count, 2);\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x33333333));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vshrq_n_u32(count, 4);\n        count = vandq_u32(count, vdupq_n_u32(0x0F0F0F0F));\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x0F0F0F0F));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vshrq_n_u32(count, 8);\n        count = vandq_u32(count, vdupq_n_u32(0x00FF00FF));\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x00FF00FF));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vshrq_n_u32(count, 16);\n        count = vandq_u32(count, vdupq_n_u32(0x0000FFFF));\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x0000FFFF));\n        count = vaddq_u32(count, tmp);\n\n        vst1q_u32(dst + i, count);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x0000003F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(data));\n        uint32x4_t sum1 = vpaddlq_u16(vreinterpretq_u16_u8(vget_low_u8(count)));\n        uint32x4_t sum2 = vpaddlq_u16(vreinterpretq_u16_u8(vget_high_u8(count)));\n        uint32x4_t total = vaddq_u32(sum1, sum2);\n        vst1q_u32(dst + i, total);\n    }\n    for (; i < length; ++i) {\n        uint32_t val = src[i];\n        uint32_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        uint32x4_t tmp;\n\n        tmp = vandq_u32(data, vdupq_n_u32(0x55555555));\n        count = vaddq_u32(count, tmp);\n        data = vshrq_n_u32(data, 1);\n\n        tmp = vandq_u32(data, vdupq_n_u32(0x55555555));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vandq_u32(count, vdupq_n_u32(0x33333333));\n        count = vshrq_n_u32(count, 2);\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x33333333));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vandq_u32(count, vdupq_n_u32(0x0F0F0F0F));\n        count = vshrq_n_u32(count, 4);\n        tmp = vandq_u32(tmp, vdupq_n_u32(0x0F0F0F0F));\n        count = vaddq_u32(count, tmp);\n\n        tmp = vshrq_n_u32(count, 8);\n        count = vaddq_u32(count, tmp);\n        tmp = vshrq_n_u32(count, 16);\n        count = vaddq_u32(count, tmp);\n\n        vst1q_u32(dst + i, count);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t x = src[i];\n        x = (x & 0x55555555) + ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);\n        x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);\n        x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF);\n        dst[i] = x;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t sum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t sum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t sum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t sum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        uint16x8_t sum_vec = vqaddq_u16(vec1, vec2);\n        vst1q_u16(dst + i, sum_vec);\n    }\n    for (; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        vst1q_s64(C + i, sum);\n    }\n\n    // Handle remaining elements if the total number of elements is odd\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        vst1q_s64(C + i, sum);\n    }\n\n    // Handle the remaining element if the total number of elements is odd\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        vst1q_s64(C + i, sum);\n    }\n\n    // Handle remaining elements if the total number of elements is odd\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        vst1q_s64(C + i, sum);\n    }\n\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        vst1q_s64(C + i, sum);\n    }\n\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtnq_s32_f32(sum);\n        float32x4_t rounded_float = vcvtq_f32_s32(rounded);\n        vst1q_f32(dst + i, rounded_float);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtnq_s32_f32(sum);\n        float32x4_t rounded_float = vcvtq_f32_s32(rounded);\n        vst1q_f32(dst + i, rounded_float);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtnq_s32_f32(sum);\n        float32x4_t rounded_float = vcvtq_f32_s32(rounded);\n        vst1q_f32(dst + i, rounded_float);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vsubq_f32(vsrc1, vsrc2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        uint32x4_t mask = vcltq_f32(abs_diff, threshold);\n\n        if ((i % 2) != 0) {\n            uint32x4_t even_lane_mask = {0, 1, 0, 1};\n            uint32x4_t even_lane_mask_v = vdupq_lane_u32(vget_low_u32(vcreate_u32(0b00101010)), 1);\n            mask = vandq_u32(mask, even_lane_mask_v);\n        } else {\n            uint32x4_t even_lane_mask = {1, 0, 1, 0};\n            uint32x4_t even_lane_mask_v = vdupq_lane_u32(vget_low_u32(vcreate_u32(0b10101010)), 0);\n            mask = vandq_u32(mask, even_lane_mask_v);\n        }\n\n        float32x4_t mul_result = vmulq_f32(vsrc1, vsrc2);\n        float32x4_t rounded_result;\n\n        float temp[4];\n        vst1q_f32(temp, mul_result);\n        for(int j = 0; j < 4; j++){\n            temp[j] = ceilf(temp[j]);\n        }\n        rounded_result = vld1q_f32(temp);\n\n        float32x4_t final_result = vbslq_f32(mask, rounded_result, neg_one);\n        vst1q_f32(dst + i, final_result);\n    }\n\n    for (; i < length; ++i) {\n        if (fabsf(src1[i] - src2[i]) < 50.0f && (i % 2) == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vsubq_f32(vsrc1, vsrc2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        uint32x4_t mask = vcltq_f32(abs_diff, threshold);\n\n        if ((i % 2) != 0) {\n            mask[0] = 0;\n            mask[1] = 0;\n            mask[2] = 0;\n            mask[3] = 0;\n        }\n\n        float32x4_t mul_result = vmulq_f32(vsrc1, vsrc2);\n        float32x4_t rounded_result;\n        rounded_result[0] = ceilf(mul_result[0]);\n        rounded_result[1] = ceilf(mul_result[1]);\n        rounded_result[2] = ceilf(mul_result[2]);\n        rounded_result[3] = ceilf(mul_result[3]);\n\n        float32x4_t result = vbslq_f32(mask, rounded_result, neg_one);\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if ((i % 2) == 0 && fabs(src1[i] - src2[i]) < 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    uint32x4_t even_mask = {1, 0, 1, 0}; \n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vsubq_f32(vsrc1, vsrc2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n\n        uint32x4_t cond_mask = vcltq_f32(abs_diff, threshold);\n        \n        uint32x4_t index_mask = vdupq_n_u32(0);\n        if (i % 2 == 0) {\n            index_mask = vceqzq_u32(vdupq_n_u32(0), vshlq_n_u32((uint32x4_t) {1, 1, 1, 1}, 31));\n        } else {\n            index_mask = vceqzq_u32(vdupq_n_u32(0), vshlq_n_u32((uint32x4_t) {0, 0, 0, 0}, 31));\n        }\n\n        uint32x4_t combined_mask = vandq_u32(cond_mask, index_mask);\n\n        float32x4_t mul_result = vmulq_f32(vsrc1, vsrc2);\n\n        float32x4_t rounded_result;\n        float temp[4];\n        vst1q_f32(temp, mul_result);\n        for(int j = 0; j < 4; ++j){\n            temp[j] = ceilf(temp[j]);\n        }\n        rounded_result = vld1q_f32(temp);\n\n        float32x4_t final_result = vbslq_f32(combined_mask, rounded_result, neg_one);\n\n        vst1q_f32(dst + i, final_result);\n    }\n\n    for (; i < length; ++i) {\n        if (fabsf(src1[i] - src2[i]) <= 50 && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vsubq_f32(vsrc1, vsrc2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        uint32x4_t mask = vcltq_f32(abs_diff, threshold);\n\n        if ((i % 2) != 0) {\n            uint32x4_t even_lane_mask = {0, 1, 0, 1};\n            uint32x4_t even_lane_mask_neon = vld1q_u32(even_lane_mask);\n            uint32x4_t zero = vdupq_n_u32(0);\n            uint32x4_t even_lane_compare = vceqq_u32(vandq_u32(mask, even_lane_mask_neon), zero);\n            mask = vmvnq_u32(even_lane_compare);\n        }\n\n        float32x4_t mul_result = vmulq_f32(vsrc1, vsrc2);\n        float32x4_t rounded_result;\n\n        float temp[4];\n        vst1q_f32(temp, mul_result);\n        for(int j = 0; j < 4; j++){\n            temp[j] = ceilf(temp[j]);\n        }\n        rounded_result = vld1q_f32(temp);\n\n        float32x4_t final_result = vbslq_f32(mask, rounded_result, neg_one);\n        vst1q_f32(dst + i, final_result);\n    }\n\n    for (; i < length; ++i) {\n        if (fabsf(src1[i] - src2[i]) <= 50.0f && (i % 2) == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n\n    for (i = 0; i + 3 < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vsubq_f32(v_src1, v_src2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n\n        uint32x4_t mask = vcltq_f32(abs_diff, threshold);\n\n        if (i % 2 == 0) {\n            float32x4_t mul_result = vmulq_f32(v_src1, v_src2);\n            float32x4_t rounded_result = vrndpq_f32(mul_result);\n            float32x4_t final_result = vbslq_f32(mask, rounded_result, neg_one);\n            vst1q_f32(dst + i, final_result);\n        } else {\n            vst1q_f32(dst + i, neg_one);\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (fabsf(src1[i] - src2[i]) < 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_loop) {\n            if (j + 1 < n) {\n                float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n                float64x2_t dst_vec = vmulq_f64(mat_vec, scalar_vec);\n                vst1q_f64(dst + i * n + j, dst_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_loop) {\n            if (j + 1 < n) {\n                float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n                float64x2_t res_vec = vmulq_f64(mat_vec, scalar_vec);\n                vst1q_f64(dst + i * n + j, res_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_loop) {\n            if (j + 1 < n) {\n                float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n                float64x2_t res_vec = vmulq_f64(mat_vec, scalar_vec);\n                vst1q_f64(dst + i * n + j, res_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_iter) {\n            if (j + 1 < n) {\n                float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n                float64x2_t dst_vec = vmulq_f64(mat_vec, scalar_vec);\n                vst1q_f64(dst + i * n + j, dst_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_loop) {\n            if (j + 1 < n) {\n                float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n                float64x2_t dst_vec = vmulq_f64(mat_vec, scalar_vec);\n                vst1q_f64(dst + i * n + j, dst_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        float* row_ptr = mat + i * n;\n\n        // Calculate sum of squares using Neon\n        size_t j = 0;\n        if (n >= 4) {\n            float32x4_t sum_sq_vec = vdupq_n_f32(0.0f);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                sum_sq_vec = vmlaq_f32(sum_sq_vec, row_vec, row_vec);\n            }\n            // Accumulate the vector elements into a scalar\n            float sum_sq_arr[4];\n            vst1q_f32(sum_sq_arr, sum_sq_vec);\n            sum_sq += sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row using Neon\n        j = 0;\n        if (n >= 4) {\n            float32x4_t norm_vec = vdupq_n_f32(norm);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                float32x4_t normalized_vec = vdivq_f32(row_vec, norm_vec);\n                vst1q_f32(row_ptr + j, normalized_vec);\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row_ptr[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        float* row_ptr = mat + i * n;\n\n        // Calculate sum of squares using NEON\n        size_t j = 0;\n        if (n >= 4) {\n            float32x4_t sum_vec = vdupq_n_f32(0.0f);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t vec = vld1q_f32(row_ptr + j);\n                sum_vec = vmlaq_f32(sum_vec, vec, vec);\n            }\n            float sum_arr[4];\n            vst1q_f32(sum_arr, sum_vec);\n            sum_sq = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row using NEON\n        j = 0;\n        if (n >= 4) {\n            float32x4_t norm_vec = vdupq_n_f32(norm);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t vec = vld1q_f32(row_ptr + j);\n                float32x4_t normalized_vec = vdivq_f32(vec, norm_vec);\n                vst1q_f32(row_ptr + j, normalized_vec);\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row_ptr[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        float* row_ptr = mat + i * n;\n\n        // Calculate sum of squares using Neon\n        size_t j = 0;\n        if (n >= 4) {\n            float32x4_t sum_sq_vec = vdupq_n_f32(0.0f);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                sum_sq_vec = vmlaq_f32(sum_sq_vec, row_vec, row_vec);\n            }\n            // Accumulate the vector into a scalar\n            float temp[4];\n            vst1q_f32(temp, sum_sq_vec);\n            sum_sq += temp[0] + temp[1] + temp[2] + temp[3];\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row using Neon\n        j = 0;\n        if (n >= 4) {\n            float32x4_t norm_vec = vdupq_n_f32(norm);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                float32x4_t normalized_vec = vdivq_f32(row_vec, norm_vec);\n                vst1q_f32(row_ptr + j, normalized_vec);\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row_ptr[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        float* row_ptr = mat + i * n;\n\n        // Calculate sum of squares using NEON\n        size_t j = 0;\n        if (n >= 4) {\n            float32x4_t sum_vec = vdupq_n_f32(0.0f);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t data_vec = vld1q_f32(row_ptr + j);\n                sum_vec = vmlaq_f32(sum_vec, data_vec, data_vec);\n            }\n            // Accumulate the vector sum into a scalar\n            float temp[4];\n            vst1q_f32(temp, sum_vec);\n            sum_sq += temp[0] + temp[1] + temp[2] + temp[3];\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row using NEON\n        j = 0;\n        if (n >= 4) {\n            float32x4_t norm_vec = vdupq_n_f32(norm);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t data_vec = vld1q_f32(row_ptr + j);\n                float32x4_t normalized_vec = vdivq_f32(data_vec, norm_vec);\n                vst1q_f32(row_ptr + j, normalized_vec);\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row_ptr[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        float* row_ptr = mat + i * n;\n\n        // Calculate sum of squares using NEON\n        size_t j = 0;\n        if (n >= 4) {\n            float32x4_t sum_sq_vec = vdupq_n_f32(0.0f);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                sum_sq_vec = vmlaq_f32(sum_sq_vec, row_vec, row_vec);\n            }\n            // Accumulate the vector into a scalar\n            float temp[4];\n            vst1q_f32(temp, sum_sq_vec);\n            sum_sq += temp[0] + temp[1] + temp[2] + temp[3];\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row using NEON\n        j = 0;\n        if (n >= 4) {\n            float32x4_t norm_vec = vdupq_n_f32(norm);\n            for (; j <= n - 4; j += 4) {\n                float32x4_t row_vec = vld1q_f32(row_ptr + j);\n                float32x4_t normalized_vec = vdivq_f32(row_vec, norm_vec);\n                vst1q_f32(row_ptr + j, normalized_vec);\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row_ptr[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            // Process two elements at a time using Neon intrinsics\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = vld1q_f64(mat2 + j * n + k);\n\n                float64x2_t b_transposed = {mat2[k * p + j], mat2[(k + 1) * p + j]};\n                float64x2_t c = {mat1[i * n + k], mat1[i * n + k + 1]};\n                sum += c[0] * b_transposed[0] + c[1] * b_transposed[1];\n            }\n\n            // Handle the remaining element if n is odd\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = vld1q_f64(mat2 + j * n + k);\n                float64x2_t c = {mat2[k * p + j], mat2[(k + 1) * p + j]};\n                float64x2_t d = {mat1[i * n + k], mat1[i * n + k + 1]};\n                float64x2_t prod = vmulq_f64(a, b);\n                sum += prod[0] + prod[1];\n            }\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = {mat2[k * p + j], mat2[(k + 1) * p + j]};\n                float64x2_t prod = vmulq_f64(a, b);\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            // Process 2 elements at a time using Neon\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = vld1q_f64(mat2 + j * n + k);\n\n                float64x2_t b_transposed = {mat2[k * p + j], mat2[(k + 1) * p + j]};\n                float64x2_t c = vmulq_lane_f64(a, vdup_n_f64(b_transposed[0]), 0);\n                c = vmlaq_lane_f64(c, a, vdup_n_f64(b_transposed[1]), 1);\n\n                sum += vgetq_lane_f64(c, 0) + vgetq_lane_f64(c, 1);\n            }\n\n            // Handle remaining element if n is odd\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            // Process 2 elements at a time using Neon\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = vld1q_f64(mat2 + j * n + k);\n\n                float64x2_t b_transposed = {mat2[k * p + j], mat2[(k + 1) * p + j]};\n                float64x2_t c = vmulq_lane_f64(a, vdup_n_f64(b_transposed[0]), 0);\n                c = vmlaq_lane_f64(c, a, vdup_n_f64(b_transposed[1]), 1);\n\n                sum += vgetq_lane_f64(c, 0) + vgetq_lane_f64(c, 1);\n            }\n\n            // Handle remaining element if n is odd\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; ++j) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded_val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded_val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vrndmq_f32(result); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vrndmq_f32(result); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t sub_result = vsubq_f32(v1, v2);\n\n        float temp[4];\n        vst1q_f32(temp, sub_result);\n\n        for(int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                dst[i + j] = floorf(temp[j]);\n            } else {\n                dst[i + j] = ceilf(temp[j]);\n            }\n        }\n    }\n\n    for (; i < total_elements; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        if (sub_result > 0.0f) {\n            dst[i] = floorf(sub_result);\n        } else {\n            dst[i] = ceilf(sub_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t sub_result = vsubq_f32(v1, v2);\n\n        float rounded_values[4];\n        rounded_values[0] = (sub_result[0] > 0.0f) ? floorf(sub_result[0]) : ceilf(sub_result[0]);\n        rounded_values[1] = (sub_result[1] > 0.0f) ? floorf(sub_result[1]) : ceilf(sub_result[1]);\n        rounded_values[2] = (sub_result[2] > 0.0f) ? floorf(sub_result[2]) : ceilf(sub_result[2]);\n        rounded_values[3] = (sub_result[3] > 0.0f) ? floorf(sub_result[3]) : ceilf(sub_result[3]);\n\n        vst1q_f32(dst + i, vld1q_f32(rounded_values));\n    }\n\n    for (; i < total_elements; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        dst[i] = (sub_result > 0.0f) ? floorf(sub_result) : ceilf(sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t sub_result = vsubq_f32(v1, v2);\n\n        float temp[4];\n        vst1q_f32(temp, sub_result);\n\n        for(int j = 0; j < 4; ++j){\n            if (temp[j] > 0.0f) {\n                dst[i + j] = floorf(temp[j]);\n            } else {\n                dst[i + j] = ceilf(temp[j]);\n            }\n        }\n    }\n\n    for (; i < total_elements; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        if (sub_result > 0.0f) {\n            dst[i] = floorf(sub_result);\n        } else {\n            dst[i] = ceilf(sub_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            if (n - j >= 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + j);\n                float64x2_t b = vld1q_f64(mat2 + i * n + j);\n                float64x2_t c = vmulq_f64(a, b);\n                vst1q_f64(dst + i * n + j, c);\n            } else if (n - j == 1) {\n                dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            if (j + 1 < n) {\n                float64x2_t v1 = vld1q_f64(mat1 + i * n + j);\n                float64x2_t v2 = vld1q_f64(mat2 + i * n + j);\n                float64x2_t result = vmulq_f64(v1, v2);\n                vst1q_f64(dst + i * n + j, result);\n            } else {\n                dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrices (m);\n- The number of columns in the matrices (n).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform the Hadamard product (element-wise multiplication) of mat1 and mat2,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t cols_per_loop = 2;\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += cols_per_loop) {\n            if (j + 1 < n) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + j);\n                float64x2_t b = vld1q_f64(mat2 + i * n + j);\n                float64x2_t result = vmulq_f64(a, b);\n                vst1q_f64(dst + i * n + j, result);\n            } else {\n                dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_val = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_val);\n        }\n        float32x2_t sum_pair = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        sum_pair = vpadd_f32(sum_pair, sum_pair);\n        dst[i] = vget_lane_f32(sum_pair, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_elements = vld1q_f32(vec + j);\n            float32x4_t prod = vmulq_f32(mat_row, vec_elements);\n            sum += vgetq_lane_f32(prod, 0) + vgetq_lane_f32(prod, 1) +\n                   vgetq_lane_f32(prod, 2) + vgetq_lane_f32(prod, 3);\n        }\n\n        // Process remaining elements sequentially\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_part = vld1q_f32(vec + j);\n            float32x4_t mul_result = vmulq_f32(mat_row, vec_part);\n            sum += vgetq_lane_f32(mul_result, 0) + vgetq_lane_f32(mul_result, 1) +\n                   vgetq_lane_f32(mul_result, 2) + vgetq_lane_f32(mul_result, 3);\n        }\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_part = vld1q_f32(vec + j);\n            float32x4_t mul_result = vmulq_f32(mat_row, vec_part);\n            sum += vgetq_lane_f32(mul_result, 0) + vgetq_lane_f32(mul_result, 1) +\n                   vgetq_lane_f32(mul_result, 2) + vgetq_lane_f32(mul_result, 3);\n        }\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_elements = vld1q_f32(vec + j);\n            float32x4_t mul_result = vmulq_f32(mat_row, vec_elements);\n            sum += vgetq_lane_f32(mul_result, 0) + vgetq_lane_f32(mul_result, 1) +\n                   vgetq_lane_f32(mul_result, 2) + vgetq_lane_f32(mul_result, 3);\n        }\n\n        // Process remaining elements\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    for (; i + 3 < total_elements; i += 4) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        float64x2_t vec2 = vld1q_f64(mat + i + 2);\n        float64x2_t sum_vec = vaddq_f64(vec, vec2);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vectorized_elements = total_elements / 4;\n    double sum = 0.0;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vectorized_elements; ++i) {\n        float64x2_t data_vec = vld1q_f64(mat + i * 4);\n        sum_vec = vaddq_f64(sum_vec, data_vec);\n    }\n\n    // Horizontal add to get the total sum\n    float64x2_t sum_vec1 = vuzpq_f64(sum_vec, sum_vec).val[0];\n    sum += vgetq_lane_f64(sum_vec1, 0) + vgetq_lane_f64(sum_vec1, 1);\n\n    // Handle remaining elements\n    for (size_t i = vectorized_elements * 4; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    // Use Neon to sum the elements in pairs\n    size_t i = 0;\n    for (; i < total_elements - 1; i += 2) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum += vgetq_lane_f64(vec, 0) + vgetq_lane_f64(vec, 1);\n    }\n\n    // Handle the case where the number of elements is odd\n    if (i < total_elements) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    // Use Neon to sum the elements in pairs\n    size_t i = 0;\n    for (; i < total_elements - 1; i += 2) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum += vgetq_lane_f64(vec, 0) + vgetq_lane_f64(vec, 1);\n    }\n\n    // Handle the case where the number of elements is odd\n    if (i < total_elements) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    if (total_elements >= 2) {\n        for (; i <= total_elements - 2; i += 2) {\n            float64x2_t vec = vld1q_f64(mat + i);\n            sum += vgetq_lane_f64(vec, 0) + vgetq_lane_f64(vec, 1);\n        }\n    }\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 4);\n\n            if (ascending) {\n                int32x4_t cmp = vcgtq_s32(current, next);\n                if (vmaxvq_s32(cmp) != 0) {\n                    return false;\n                }\n            } else {\n                int32x4_t cmp = vcltq_s32(current, next);\n                if (vmaxvq_s32(cmp) != 0) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            uint32x4_t comparison;\n            if (ascending) {\n                comparison = vcleq_s32(current, next);\n            } else {\n                comparison = vcgeq_s32(current, next);\n            }\n\n            uint32_t result = vgetq_lane_u32(comparison, 0) &\n                              vgetq_lane_u32(comparison, 1) &\n                              vgetq_lane_u32(comparison, 2) &\n                              vgetq_lane_u32(comparison, 3);\n\n            if (!result) {\n                return false;\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (ascending) {\n                    if (row[j - 1] > row[j]) {\n                        return false;\n                    }\n                } else {\n                    if (row[j - 1] < row[j]) {\n                        return false;\n                    }\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t prev = vld1q_s32(row + j - 1);\n            int32x4_t curr = vld1q_s32(row + j);\n\n            if (ascending) {\n                int32x4_t cmp = vcgtq_s32(prev, curr);\n                uint32x4_t mask = vmovq_n_u32(0);\n                if (vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 0) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 1) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 2) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 3) != 1)\n                {\n                    return false;\n                }\n            } else {\n                int32x4_t cmp = vcltq_s32(prev, curr);\n                uint32x4_t mask = vmovq_n_u32(0);\n                if (vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 0) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 1) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 2) != 1 ||\n                    vgetq_lane_u32(vceqq_u32(vreinterpretq_u32_s32(cmp), mask), 3) != 1)\n                {\n                    return false;\n                }\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (ascending) {\n                    if (row[j - 1] > row[j]) {\n                        return false;\n                    }\n                } else {\n                    if (row[j - 1] < row[j]) {\n                        return false;\n                    }\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t prev = vld1q_s32(row + j - 1);\n            int32x4_t curr = vld1q_s32(row + j);\n\n            if (ascending) {\n                int32x4_t cmp = vcgtq_s32(prev, curr);\n                if (vgetq_lane_s32(cmp, 0) || vgetq_lane_s32(cmp, 1) || vgetq_lane_s32(cmp, 2) || vgetq_lane_s32(cmp, 3)) {\n                    return false;\n                }\n            } else {\n                int32x4_t cmp = vcltq_s32(prev, curr);\n                if (vgetq_lane_s32(cmp, 0) || vgetq_lane_s32(cmp, 1) || vgetq_lane_s32(cmp, 2) || vgetq_lane_s32(cmp, 3)) {\n                    return false;\n                }\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 4);\n\n            if (ascending) {\n                int32x4_t cmp = vcgtq_s32(next, current);\n                uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n                uint32x4_t result = vceqq_u32(vreinterpretq_u32_s32(cmp), mask);\n\n                if (vgetq_lane_u32(result, 0) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 1) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 2) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 3) != 0xFFFFFFFF) {\n                    for(size_t k = j; k < cols - 1; ++k){\n                        if(ascending){\n                            if(row[k+1] < row[k]) return false;\n                        } else {\n                            if(row[k+1] > row[k]) return false;\n                        }\n                    }\n                    goto end_row;\n                }\n            } else {\n                int32x4_t cmp = vcgtq_s32(current, next);\n                uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n                uint32x4_t result = vceqq_u32(vreinterpretq_u32_s32(cmp), mask);\n\n                if (vgetq_lane_u32(result, 0) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 1) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 2) != 0xFFFFFFFF ||\n                    vgetq_lane_u32(result, 3) != 0xFFFFFFFF) {\n                    for(size_t k = j; k < cols - 1; ++k){\n                        if(ascending){\n                            if(row[k+1] < row[k]) return false;\n                        } else {\n                            if(row[k+1] > row[k]) return false;\n                        }\n                    }\n                    goto end_row;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4 == 0 ? 4 : cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j + 1] < row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j + 1] > row[j]) {\n                    return false;\n                }\n            }\n        }\n        end_row:;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t b = (int16_t)base;\n\n    if (base == 1) {\n        for (i = 0; i < length; ++i) {\n            dst[i] = src[i];\n        }\n        return;\n    }\n\n    if (length >= 8) {\n        size_t loop_end = length - length % 8;\n        int16x8_t base_vec = vdupq_n_s16(b);\n\n        for (i = 0; i < loop_end; i += 8) {\n            int16x8_t src_vec = vld1q_s16(src + i);\n            int16x8_t div_vec = vdivq_s16(src_vec, base_vec);\n            int16x8_t trunc_vec = vcvtq_s16_f32(vfloorq_f32(vcvtq_f32_s16(div_vec)));\n            int16x8_t res_vec = vmulq_s16(trunc_vec, base_vec);\n            vst1q_s16(dst + i, res_vec);\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / b) * b;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16x8_t base_vec = vdupq_n_s16(base);\n\n    for (; i + 7 < length; i += 8) {\n        int16x8_t src_vec = vld1q_s16(src + i);\n        int16x8_t temp_vec = vdivq_s16(src_vec, base_vec);\n        int16x8_t res_vec = vmulq_s16(temp_vec, base_vec);\n        vst1q_s16(dst + i, res_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t b = (int16_t)base;\n\n    if (length >= 8) {\n        size_t loop_end = length - (length % 8);\n        int16x8_t base_vec = vdupq_n_s16(b);\n\n        for (i = 0; i < loop_end; i += 8) {\n            int16x8_t src_vec = vld1q_s16(src + i);\n            int16x8_t rem_vec = vmodq_s16(src_vec, base_vec);\n            int16x8_t res_vec = vsubq_s16(src_vec, rem_vec);\n            vst1q_s16(dst + i, res_vec);\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[i] - (src[i] % b);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t b = (int16_t)base;\n\n    if (length >= 8) {\n        size_t loop_end = length - (length % 8);\n        int16x8_t base_vec = vdupq_n_s16(b);\n\n        for (i = 0; i < loop_end; i += 8) {\n            int16x8_t src_vec = vld1q_s16(src + i);\n            int16x8_t div_vec = vdivq_s16(src_vec, base_vec);\n            int16x8_t trunc_vec = vcvtq_s16_f32(vfloorq_f32(vcvtq_f32_s16(div_vec)));\n            int16x8_t result_vec = vmulq_s16(trunc_vec, base_vec);\n            vst1q_s16(dst + i, result_vec);\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / b) * b;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t b = (int16_t)base;\n\n    if (length >= 8) {\n        size_t loop_end = length - (length % 8);\n        int16x8_t base_vec = vdupq_n_s16(b);\n\n        for (i = 0; i < loop_end; i += 8) {\n            int16x8_t src_vec = vld1q_s16(src + i);\n            int16x8_t rem_vec = vmodq_s16(src_vec, base_vec);\n            int16x8_t res_vec = vsubq_s16(src_vec, rem_vec);\n            vst1q_s16(dst + i, res_vec);\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[i] - (src[i] % b);\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        bool row_match = true;\n\n        if (cols >= 2) {\n            for (; j <= cols - 2; j += 2) {\n                float64x2_t matrix_row = vld1q_f64(matrix + i * cols + j);\n                float64x2_t vec = vld1q_f64(vector + j);\n                float64x2_t diff = vsubq_f64(matrix_row, vec);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vceqzq_f64(abs_diff);\n\n                if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_match && j < cols) {\n            for (; j < cols; ++j) {\n                if (matrix[i * cols + j] != vector[j]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        bool row_match = true;\n\n        if (cols >= 2) {\n            for (; j <= cols - 2; j += 2) {\n                float64x2_t matrix_row = vld1q_f64(matrix + i * cols + j);\n                float64x2_t vec = vld1q_f64(vector + j);\n                float64x2_t diff = vsubq_f64(matrix_row, vec);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vceqzq_f64(abs_diff);\n\n                if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_match) {\n            for (; j < cols; ++j) {\n                if (matrix[i * cols + j] != vector[j]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        bool match = true;\n\n        if (cols >= 2) {\n            for (; j <= cols - 2; j += 2) {\n                float64x2_t matrix_row = vld1q_f64(matrix + i * cols + j);\n                float64x2_t vec = vld1q_f64(vector + j);\n                float64x2_t diff = vsubq_f64(matrix_row, vec);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vceqzq_f64(abs_diff);\n\n                if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                    match = false;\n                    break;\n                }\n            }\n        }\n\n        if (match && j < cols) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t cols_per_vector = 2;\n    size_t cols_processed;\n\n    for (size_t i = 0; i < rows; ++i) {\n        cols_processed = 0;\n        bool row_matches = true;\n\n        while (cols_processed + cols_per_vector <= cols) {\n            float64x2_t matrix_row_vec = vld1q_f64(matrix + i * cols + cols_processed);\n            float64x2_t vector_vec = vld1q_f64(vector + cols_processed);\n            float64x2_t comparison_result = vceqq_f64(matrix_row_vec, vector_vec);\n            uint64x1_t result = vreinterpret_u64_f64(comparison_result);\n\n            if (vget_lane_u64(result, 0) != 0xFFFFFFFFFFFFFFFF || vget_lane_u64(result, 1) != 0xFFFFFFFFFFFFFFFF) {\n                row_matches = false;\n                break;\n            }\n\n            cols_processed += cols_per_vector;\n        }\n\n        if (row_matches && cols_processed < cols) {\n            for (size_t j = cols_processed; j < cols; ++j) {\n                if (matrix[i * cols + j] != vector[j]) {\n                    row_matches = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_matches) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t cols_per_vector = 2;\n    size_t vector_count = cols / cols_per_vector;\n    size_t remaining_cols = cols % cols_per_vector;\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool row_matches = true;\n        size_t j = 0;\n\n        for (; j < vector_count; ++j) {\n            float64x2_t matrix_row_vector = vld1q_f64(matrix + i * cols + j * cols_per_vector);\n            float64x2_t vector_vector = vld1q_f64(vector + j * cols_per_vector);\n            float64x2_t comparison_result = vceqq_f64(matrix_row_vector, vector_vector);\n            uint64x2_t comparison_mask = vmvnq_u64(vreinterpretq_u64_f64(comparison_result));\n\n            if (vgetq_lane_u64(comparison_mask, 0) != 0 || vgetq_lane_u64(comparison_mask, 1) != 0) {\n                continue;\n            } else {\n                row_matches = false;\n                break;\n            }\n        }\n\n        if (row_matches && remaining_cols > 0) {\n            for (size_t k = j * cols_per_vector; k < cols; ++k) {\n                if (matrix[i * cols + k] != vector[k]) {\n                    row_matches = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_matches) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cstdint>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (B);\n- An array of 4 size_t integers representing the dimensions of the tensors (dims).\n\nA and B are flattened into 1D arrays.\nYour goal is to count the number of equal elements between the two tensors.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i + 16 <= total_elements; i += 16) {\n        uint8x16_t va = vld1q_u8(A + i);\n        uint8x16_t vb = vld1q_u8(B + i);\n        uint8x16_t veq = vceqq_u8(va, vb);\n        uint64x2_t vsum64 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(veq)));\n        count += vgetq_lane_u64(vsum64, 0) + vgetq_lane_u64(vsum64, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cstdint>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (B);\n- An array of 4 size_t integers representing the dimensions of the tensors (dims).\n\nA and B are flattened into 1D arrays.\nYour goal is to count the number of equal elements between the two tensors.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i + 16 <= total_elements; i += 16) {\n        uint8x16_t va = vld1q_u8(A + i);\n        uint8x16_t vb = vld1q_u8(B + i);\n        uint8x16_t veq = vceqq_u8(va, vb);\n        uint64x2_t vcnt = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(veq)));\n        count += vgetq_lane_u64(vcnt, 0) + vgetq_lane_u64(vcnt, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cstdint>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SIMD\n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(A + i);\n        uint8x16_t vec_b = vld1q_u8(B + i);\n        uint8x16_t cmp_result = vceqq_u8(vec_a, vec_b); // Compare elements for equality\n        uint64x2_t packed_result = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(cmp_result))); // Pack the comparison results\n        equal_count += vgetq_lane_u64(packed_result, 0) + vgetq_lane_u64(packed_result, 1); // Sum the packed results\n    }\n\n    // Process remaining elements sequentially\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cstdint>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SIMD\n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t va = vld1q_u8(A + i);\n        uint8x16_t vb = vld1q_u8(B + i);\n        uint8x16_t veq = vceqq_u8(va, vb); // Compare elements for equality\n\n        // Move the comparison result to a general-purpose register\n        uint64x2_t eq_long = vreinterpretq_u64_u8(veq);\n\n        // Count the number of equal elements (bytes with value 0xFF)\n        uint64_t eq_low = vgetq_lane_u64(eq_long, 0);\n        uint64_t eq_high = vgetq_lane_u64(eq_long, 1);\n\n        equal_count += __builtin_popcountll(eq_low) / 8;\n        equal_count += __builtin_popcountll(eq_high) / 8;\n    }\n\n    // Process remaining elements sequentially\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cstdint>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SIMD\n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec); // Compare elements\n        uint64x2_t eq_long = vreinterpretq_u64_u8(eq_vec); // Reinterpret as 64-bit integers\n        uint64_t eq_arr[2];\n        vst1q_u64(eq_arr, eq_long);\n\n        // Count the number of equal elements in the vector\n        equal_count += __builtin_popcountll(eq_arr[0]) + __builtin_popcountll(eq_arr[1]);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    if (length >= 2) {\n        for (; i <= length - 2; i += 2) {\n            int64x2_t vx = vld1q_s64(x + i);\n            int64x2_t va = vdupq_n_s64(a);\n            int64x2_t vresult = vmulq_s64(va, vx);\n            int64x2_t vabs = vabsq_s64(vld1q_s64(y + i));\n            vresult = vsubq_s64(vresult, vabs);\n            vst1q_s64(y + i, vresult);\n        }\n    }\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    if (length >= 2) {\n        for (; i <= length - 2; i += 2) {\n            int64x2_t vx = vld1q_s64(x + i);\n            int64x2_t va = vdupq_n_s64(a);\n            int64x2_t vresult = vmulq_s64(va, vx);\n            int64x2_t vabs = vabsq_s64(vresult);\n            int64x2_t vy = vld1q_s64(y + i);\n            vst1q_s64(y + i, vsubq_s64(vy, vabs));\n        }\n    }\n    for (; i < length; ++i) {\n        int64_t result = a * x[i];\n        result = result >= 0 ? result : -result;\n        y[i] = y[i] - result;\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    if (length >= 2) {\n        for (; i <= length - 2; i += 2) {\n            int64x2_t vx = vld1q_s64(x + i);\n            int64x2_t va = vdupq_n_s64(a);\n            int64x2_t vresult = vmulq_s64(va, vx);\n            int64x2_t vabs = vabsq_s64(vld1q_s64(y + i));\n            vresult = vsubq_s64(vresult, vabs);\n            vst1q_s64(y + i, vresult);\n        }\n    }\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    if (length >= 2) {\n        for (; i <= length - 2; i += 2) {\n            int64x2_t vx = vld1q_s64(x + i);\n            int64x2_t va = vdupq_n_s64(a);\n            int64x2_t vax = vmulq_s64(va, vx);\n            int64x2_t vy = vld1q_s64(y + i);\n            int64x2_t vabs_y = vabsq_s64(vy);\n            int64x2_t result = vsubq_s64(vax, vabs_y);\n            vst1q_s64(y + i, result);\n        }\n    }\n    for (; i < length; ++i) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = y[i] >= 0 ? y[i] : -y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    if (length >= 2) {\n        for (; i <= length - 2; i += 2) {\n            int64x2_t vx = vld1q_s64(x + i);\n            int64x2_t va = vdupq_n_s64(a);\n            int64x2_t vresult = vmulq_s64(va, vx);\n            int64x2_t vabs = vabsq_s64(vresult);\n            int64x2_t vy = vld1q_s64(y + i);\n            vst1q_s64(y + i, vsubq_s64(vy, vabs));\n        }\n    }\n    for (; i < length; ++i) {\n        int64_t result = a * x[i];\n        result = result >= 0 ? result : -result;\n        y[i] = y[i] - result;\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t min_val = SHRT_MAX;\n    int16_t max_val = SHRT_MIN;\n\n    if (length == 0) {\n        return (MinMaxPair){min_val, max_val};\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        int16x8_t min_vec = vdupq_n_s16(SHRT_MAX);\n        int16x8_t max_vec = vdupq_n_s16(SHRT_MIN);\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t data_vec = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, data_vec);\n            max_vec = vmaxq_s16(max_vec, data_vec);\n        }\n\n        int16_t min_arr[8];\n        int16_t max_arr[8];\n        vst1q_s16(min_arr, min_vec);\n        vst1q_s16(max_arr, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (min_val < min_arr[j]) ? min_val : min_arr[j];\n            max_val = (max_val > max_arr[j]) ? max_val : max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (min_val < vec[i]) ? min_val : vec[i];\n        max_val = (max_val > vec[i]) ? max_val : vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t min_val = SHRT_MAX;\n    int16_t max_val = SHRT_MIN;\n\n    if (length == 0) {\n        return (MinMaxPair){min_val, max_val};\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        int16x8_t min_vec = vdupq_n_s16(SHRT_MAX);\n        int16x8_t max_vec = vdupq_n_s16(SHRT_MIN);\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t data_vec = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, data_vec);\n            max_vec = vmaxq_s16(max_vec, data_vec);\n        }\n\n        int16_t min_arr[8];\n        int16_t max_arr[8];\n        vst1q_s16(min_arr, min_vec);\n        vst1q_s16(max_arr, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (min_val < min_arr[j]) ? min_val : min_arr[j];\n            max_val = (max_val > max_arr[j]) ? max_val : max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (min_val < vec[i]) ? min_val : vec[i];\n        max_val = (max_val > vec[i]) ? max_val : vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t min_val = SHRT_MAX;\n    int16_t max_val = SHRT_MIN;\n\n    if (length == 0) {\n        return (MinMaxPair){min_val, max_val};\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        int16x8_t min_vec = vdupq_n_s16(SHRT_MAX);\n        int16x8_t max_vec = vdupq_n_s16(SHRT_MIN);\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t data_vec = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, data_vec);\n            max_vec = vmaxq_s16(max_vec, data_vec);\n        }\n\n        int16_t min_arr[8];\n        int16_t max_arr[8];\n        vst1q_s16(min_arr, min_vec);\n        vst1q_s16(max_arr, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (min_val < min_arr[j]) ? min_val : min_arr[j];\n            max_val = (max_val > max_arr[j]) ? max_val : max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (min_val < vec[i]) ? min_val : vec[i];\n        max_val = (max_val > vec[i]) ? max_val : vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t min_val = SHRT_MAX;\n    int16_t max_val = SHRT_MIN;\n\n    if (length == 0) {\n        return (MinMaxPair){min_val, max_val};\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        int16x8_t min_vec = vdupq_n_s16(SHRT_MAX);\n        int16x8_t max_vec = vdupq_n_s16(SHRT_MIN);\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t data_vec = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, data_vec);\n            max_vec = vmaxq_s16(max_vec, data_vec);\n        }\n\n        int16_t min_arr[8];\n        int16_t max_arr[8];\n        vst1q_s16(min_arr, min_vec);\n        vst1q_s16(max_arr, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (min_val < min_arr[j]) ? min_val : min_arr[j];\n            max_val = (max_val > max_arr[j]) ? max_val : max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (min_val < vec[i]) ? min_val : vec[i];\n        max_val = (max_val > vec[i]) ? max_val : vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t min_val = SHRT_MAX;\n    int16_t max_val = SHRT_MIN;\n\n    if (length == 0) {\n        return (MinMaxPair){min_val, max_val};\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        int16x8_t min_vec = vdupq_n_s16(SHRT_MAX);\n        int16x8_t max_vec = vdupq_n_s16(SHRT_MIN);\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t data_vec = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, data_vec);\n            max_vec = vmaxq_s16(max_vec, data_vec);\n        }\n\n        int16_t min_arr[8];\n        int16_t max_arr[8];\n        vst1q_s16(min_arr, min_vec);\n        vst1q_s16(max_arr, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (min_val < min_arr[j]) ? min_val : min_arr[j];\n            max_val = (max_val > max_arr[j]) ? max_val : max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (min_val < vec[i]) ? min_val : vec[i];\n        max_val = (max_val > vec[i]) ? max_val : vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] <= row[j - 1]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j - 1);\n            int32x4_t v2 = vld1q_s32(row + j);\n            int32x4_t result = vcleq_s32(v2, v1);\n            uint32x4_t mask = vmvnq_u32(vceqq_u32(result, vdupq_n_u32(0)));\n\n            if (vgetq_lane_u32(mask, 0) != 0 || vgetq_lane_u32(mask, 1) != 0 ||\n                vgetq_lane_u32(mask, 2) != 0 || vgetq_lane_u32(mask, 3) != 0) {\n                return false;\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] <= row[j - 1]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t previous = vld1q_s32(row + j - 1);\n            int32x4_t cmp = vcleq_s32(current, previous);\n            uint32x4_t result = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (vgetq_lane_u32(result, 0) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 1) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 2) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 3) != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] <= row[j - 1]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t previous = vld1q_s32(row + j - 1);\n\n            int32x4_t cmp = vcleq_s32(current, previous);\n            uint32x4_t result = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (vgetq_lane_u32(result, 0) != 0 ||\n                vgetq_lane_u32(result, 1) != 0 ||\n                vgetq_lane_u32(result, 2) != 0 ||\n                vgetq_lane_u32(result, 3) != 0) {\n                return false;\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] <= row[j - 1]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t previous = vld1q_s32(row + j - 1);\n\n            int32x4_t cmp = vcleq_s32(current, previous);\n            uint32x4_t result = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (vgetq_lane_u32(result, 0) != 0 ||\n                vgetq_lane_u32(result, 1) != 0 ||\n                vgetq_lane_u32(result, 2) != 0 ||\n                vgetq_lane_u32(result, 3) != 0) {\n                return false;\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] <= row[j - 1]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n\n        size_t j = 1;\n        for (; j < cols - 3; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t previous = vld1q_s32(row + j - 1);\n            int32x4_t cmp = vcleq_s32(current, previous);\n            uint32x4_t result = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (vgetq_lane_u32(result, 0) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 1) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 2) != 0xFFFFFFFF ||\n                vgetq_lane_u32(result, 3) != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Extract the first block\n    int* first_block = new int[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = block_row * block_size + i;\n                for (size_t j = 0; j < block_size; j += 4) {\n                    size_t col_offset = block_col * block_size + j;\n\n                    if (col_offset + 3 >= block_size * num_block_cols * block_size && col_offset >= cols) continue;\n\n                    int32x4_t block1_vec;\n                    int32x4_t block2_vec;\n\n                    if (j + 3 < block_size) {\n                        block1_vec = vld1q_s32(first_block + i * block_size + j);\n                        block2_vec = vld1q_s32(matrix + row_offset * cols + col_offset);\n                    } else {\n                        int temp1[4] = {0};\n                        int temp2[4] = {0};\n                        for (int k = 0; k < 4; ++k) {\n                            if (j + k < block_size) {\n                                temp1[k] = first_block[i * block_size + j + k];\n                                temp2[k] = matrix[row_offset * cols + col_offset + k];\n                            }\n                        }\n                        block1_vec = vld1q_s32(temp1);\n                        block2_vec = vld1q_s32(temp2);\n                    }\n\n                    int32x4_t eq_vec = vceqq_s32(block1_vec, block2_vec);\n                    uint32x4_t mask = vmvnq_u32(vceqq_s32(eq_vec, eq_vec));\n\n                    if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0 ||\n                        vgetq_lane_u32(mask, 2) == 0 || vgetq_lane_u32(mask, 3) == 0) {\n                        delete[] first_block;\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    delete[] first_block;\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Extract the first block\n    int* first_block = new int[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t block_row = 0; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = block_row * block_size + i;\n                for (size_t j = 0; j < block_size; j += 4) {\n                    size_t col_offset = block_col * block_size + j;\n\n                    int32x4_t first_block_vec;\n                    int32x4_t matrix_vec;\n\n                    // Load data into Neon vectors\n                    if (j + 3 < block_size) {\n                        first_block_vec = vld1q_s32(&first_block[i * block_size + j]);\n                        matrix_vec = vld1q_s32(&matrix[row_offset * cols + col_offset]);\n                    } else {\n                        int32_t first_block_arr[4];\n                        int32_t matrix_arr[4];\n                        for (int k = 0; k < 4; ++k) {\n                            if (j + k < block_size) {\n                                first_block_arr[k] = first_block[i * block_size + j + k];\n                                matrix_arr[k] = matrix[row_offset * cols + col_offset + k];\n                            } else {\n                                first_block_arr[k] = 0;\n                                matrix_arr[k] = 0;\n                            }\n                        }\n                        first_block_vec = vld1q_s32(first_block_arr);\n                        matrix_vec = vld1q_s32(matrix_arr);\n                    }\n\n                    // Compare the vectors\n                    uint32x4_t eq = vceqq_s32(first_block_vec, matrix_vec);\n                    uint32_t mask = vmovmask_s32(eq);\n\n                    if (mask != 0b1111) {\n                        delete[] first_block;\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    delete[] first_block;\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = block_row * block_size + i;\n                for (size_t j = 0; j < block_size; j += 4) {\n                    size_t col_offset = block_col * block_size + j;\n\n                    if (col_offset + 3 >= block_size * num_blocks_col * block_size && j >= block_size) continue;\n                    \n                    int block_data[4];\n                    int first_block_data[4];\n                    \n                    for(int k = 0; k < 4; ++k){\n                        if(j + k < block_size){\n                            block_data[k] = matrix[row_offset * cols + col_offset + k];\n                            first_block_data[k] = first_block[i * block_size + j + k];\n                        } else {\n                            block_data[k] = 0;\n                            first_block_data[k] = 0;\n                        }\n                    }\n\n                    int32x4_t block_vec = vld1q_s32(block_data);\n                    int32x4_t first_block_vec = vld1q_s32(first_block_data);\n\n                    uint32x4_t comparison_result = vceqq_s32(block_vec, first_block_vec);\n                    uint32_t mask = vgetq_lane_u32(comparison_result, 0) &\n                                    vgetq_lane_u32(comparison_result, 1) &\n                                    vgetq_lane_u32(comparison_result, 2) &\n                                    vgetq_lane_u32(comparison_result, 3);\n\n                    if (mask != 0xFFFFFFFF) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Extract the first block\n    int* first_block = new int[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t block_row = 0; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = block_row * block_size + i;\n                for (size_t j = 0; j < block_size; j += 4) {\n                    size_t col_offset = block_col * block_size + j;\n\n                    int32x4_t first_block_vec;\n                    int32x4_t matrix_vec;\n\n                    if (j + 3 < block_size) {\n                        first_block_vec = vld1q_s32(&first_block[i * block_size + j]);\n                        matrix_vec = vld1q_s32(&matrix[row_offset * cols + col_offset]);\n                    } else {\n                        int32_t first_block_arr[4];\n                        int32_t matrix_arr[4];\n                        for (int k = 0; k < 4; ++k) {\n                            if (j + k < block_size) {\n                                first_block_arr[k] = first_block[i * block_size + j + k];\n                                matrix_arr[k] = matrix[row_offset * cols + col_offset + k];\n                            } else {\n                                first_block_arr[k] = 0;\n                                matrix_arr[k] = 0;\n                            }\n                        }\n                        first_block_vec = vld1q_s32(first_block_arr);\n                        matrix_vec = vld1q_s32(matrix_arr);\n                    }\n\n                    int32x4_t neq = vceqzq_s32(veorq_s32(first_block_vec, matrix_vec));\n                    uint32x4_t mask = vmvnq_u32(vreinterpretq_u32_s32(neq));\n\n                    if (!vgetq_lane_u32(mask, 0) || !vgetq_lane_u32(mask, 1) || !vgetq_lane_u32(mask, 2) || !vgetq_lane_u32(mask, 3)) {\n                        delete[] first_block;\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    delete[] first_block;\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t col = 0;\n                for (; col + 4 <= block_size; col += 4) {\n                    int32x4_t first_vec = vld1q_s32(first_block + row * cols + col);\n                    int32x4_t current_vec = vld1q_s32(current_block + row * cols + col);\n                    int32x4_t neq = vceqzq_s32(veorq_s32(first_vec, current_vec));\n                    uint32x4_t mask = vmvnq_u32(vreinterpretq_u32_s32(neq));\n\n                    if (vgetq_lane_u32(mask, 0) != 0xFFFFFFFF ||\n                        vgetq_lane_u32(mask, 1) != 0xFFFFFFFF ||\n                        vgetq_lane_u32(mask, 2) != 0xFFFFFFFF ||\n                        vgetq_lane_u32(mask, 3) != 0xFFFFFFFF) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            if (j + 1 >= block_size) {\n                if (std::fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                    return false;\n                }\n                break;\n            }\n\n            float64x2_t block1 = vld1q_f64(vec + j);\n            float64x2_t block2 = vld1q_f64(vec + i * block_size + j);\n            float64x2_t diff = vsubq_f64(block1, block2);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            float64x2_t tol_vec = vdupq_n_f64(tolerance);\n            uint64x2_t cmp = vcgeq_f64(tol_vec, abs_diff);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            if (j + 1 < block_size) {\n                float64x2_t block1 = vld1q_f64(vec + j);\n                float64x2_t block2 = vld1q_f64(vec + i * block_size + j);\n\n                float64x2_t diff = vsubq_f64(block1, block2);\n                float64x2_t abs_diff = vabsq_f64(diff);\n\n                float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n                uint64x2_t cmp = vcgeq_f64(tolerance_vec, abs_diff);\n\n                if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                    return false;\n                }\n            } else {\n                if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* block_ptr = vec + i * block_size;\n        const double* first_block_ptr = vec;\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            if (j + 1 < block_size) {\n                float64x2_t block_val = vld1q_f64(block_ptr + j);\n                float64x2_t first_block_val = vld1q_f64(first_block_ptr + j);\n                float64x2_t diff = vsubq_f64(block_val, first_block_val);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vcgeq_f64(abs_diff, vdupq_n_f64(tolerance));\n\n                if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                    return false;\n                }\n            } else {\n                if (std::fabs(block_ptr[j] - first_block_ptr[j]) > tolerance) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            if (j + 1 >= block_size) {\n                if (std::fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                    return false;\n                }\n                break;\n            }\n\n            float64x2_t block1 = vld1q_f64(vec + j);\n            float64x2_t block2 = vld1q_f64(vec + i * block_size + j);\n            float64x2_t diff = vsubq_f64(block1, block2);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            float64x2_t tol_vec = vdupq_n_f64(tolerance);\n            uint64x2_t cmp = vcgeq_f64(tol_vec, abs_diff);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            if (j + 1 >= block_size) {\n                if (std::fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                    return false;\n                }\n                break;\n            }\n\n            float64x2_t block1 = vld1q_f64(vec + j);\n            float64x2_t block2 = vld1q_f64(vec + i * block_size + j);\n            float64x2_t diff = vsubq_f64(block1, block2);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            float64x2_t tol_vec = vdupq_n_f64(tolerance);\n            uint64x2_t cmp = vcgeq_f64(tol_vec, abs_diff);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        size_t j = 0;\n\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix + i * cols + j);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        for (; j < cols; ++j) {\n            sum_vec = vfmaq_n_f64(sum_vec, matrix[i * cols + j], matrix[i * cols + j]);\n        }\n\n        double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        result[i] = (sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process two elements at a time using SIMD\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix + i * cols + j);\n            sum += vgetq_lane_f64(vmulq_f64(row_vec, row_vec), 0);\n            sum += vgetq_lane_f64(vmulq_f64(row_vec, row_vec), 1);\n        }\n\n        // Process remaining element if cols is odd\n        for (; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process two elements at a time using SIMD\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_elements = vld1q_f64(matrix + i * cols + j);\n            sum += vgetq_lane_f64(vmulq_f64(row_elements, row_elements), 0);\n            sum += vgetq_lane_f64(vmulq_f64(row_elements, row_elements), 1);\n        }\n\n        // Process the remaining element if cols is odd\n        for (; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process two elements at a time using SIMD\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix + i * cols + j);\n            sum += vgetq_lane_f64(row_vec, 0) * vgetq_lane_f64(row_vec, 0);\n            sum += vgetq_lane_f64(row_vec, 1) * vgetq_lane_f64(row_vec, 1);\n        }\n\n        // Handle the remaining element if cols is odd\n        for (; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process two elements at a time using Neon\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix + i * cols + j);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum += vgetq_lane_f64(squared_vec, 0) + vgetq_lane_f64(squared_vec, 1);\n        }\n\n        // Process the remaining element if cols is odd\n        for (; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t or_result = vorrq_u32(a, b);\n        vst1q_u32(C + i, or_result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t or_result = vorrq_u32(a, b);\n        vst1q_u32(C + i, or_result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t result = vorrq_u32(a, b);\n        vst1q_u32(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t result = vorrq_u32(a, b);\n        vst1q_u32(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t result = vorrq_u32(a, b);\n        vst1q_u32(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_lo = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_hi = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_lo = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_hi = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_lo_lo = vmovl_s16(vget_low_s16(va_lo));\n        int32x4_t va_lo_hi = vmovl_s16(vget_high_s16(va_lo));\n        int32x4_t va_hi_lo = vmovl_s16(vget_low_s16(va_hi));\n        int32x4_t va_hi_hi = vmovl_s16(vget_high_s16(va_hi));\n\n        int32x4_t vb_lo_lo = vmovl_s16(vget_low_s16(vb_lo));\n        int32x4_t vb_lo_hi = vmovl_s16(vget_high_s16(vb_lo));\n        int32x4_t vb_hi_lo = vmovl_s16(vget_low_s16(vb_hi));\n        int32x4_t vb_hi_hi = vmovl_s16(vget_high_s16(vb_hi));\n\n        int64x2_t va_lo_lo_lo = vmovl_s32(vget_low_s32(va_lo_lo));\n        int64x2_t va_lo_lo_hi = vmovl_s32(vget_high_s32(va_lo_lo));\n        int64x2_t va_lo_hi_lo = vmovl_s32(vget_low_s32(va_lo_hi));\n        int64x2_t va_lo_hi_hi = vmovl_s32(vget_high_s32(va_lo_hi));\n        int64x2_t va_hi_lo_lo = vmovl_s32(vget_low_s32(va_hi_lo));\n        int64x2_t va_hi_lo_hi = vmovl_s32(vget_high_s32(va_hi_lo));\n        int64x2_t va_hi_hi_lo = vmovl_s32(vget_low_s32(va_hi_hi));\n        int64x2_t va_hi_hi_hi = vmovl_s32(vget_high_s32(va_hi_hi));\n\n        int64x2_t vb_lo_lo_lo = vmovl_s32(vget_low_s32(vb_lo_lo));\n        int64x2_t vb_lo_lo_hi = vmovl_s32(vget_high_s32(vb_lo_lo));\n        int64x2_t vb_lo_hi_lo = vmovl_s32(vget_low_s32(vb_lo_hi));\n        int64x2_t vb_lo_hi_hi = vmovl_s32(vget_high_s32(vb_lo_hi));\n        int64x2_t vb_hi_lo_lo = vmovl_s32(vget_low_s32(vb_hi_lo));\n        int64x2_t vb_hi_lo_hi = vmovl_s32(vget_high_s32(vb_hi_lo));\n        int64x2_t vb_hi_hi_lo = vmovl_s32(vget_low_s32(vb_hi_hi));\n        int64x2_t vb_hi_hi_hi = vmovl_s32(vget_high_s32(vb_hi_hi));\n\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(va_hi_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(va_hi_hi)), 0);\n\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(vb_hi_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(vb_hi_hi)), 0);\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_lo = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_hi = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_lo = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_hi = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_lo_lo = vmovl_s16(vget_low_s16(va_lo));\n        int32x4_t va_lo_hi = vmovl_s16(vget_high_s16(va_lo));\n        int32x4_t va_hi_lo = vmovl_s16(vget_low_s16(va_hi));\n        int32x4_t va_hi_hi = vmovl_s16(vget_high_s16(va_hi));\n\n        int32x4_t vb_lo_lo = vmovl_s16(vget_low_s16(vb_lo));\n        int32x4_t vb_lo_hi = vmovl_s16(vget_high_s16(vb_lo));\n        int32x4_t vb_hi_lo = vmovl_s16(vget_low_s16(vb_hi));\n        int32x4_t vb_hi_hi = vmovl_s16(vget_high_s16(vb_hi));\n\n        int64x2_t va_lo_lo_lo = vmovl_s32(vget_low_s32(va_lo_lo));\n        int64x2_t va_lo_lo_hi = vmovl_s32(vget_high_s32(va_lo_lo));\n        int64x2_t va_lo_hi_lo = vmovl_s32(vget_low_s32(va_lo_hi));\n        int64x2_t va_lo_hi_hi = vmovl_s32(vget_high_s32(va_lo_hi));\n        int64x2_t va_hi_lo_lo = vmovl_s32(vget_low_s32(va_hi_lo));\n        int64x2_t va_hi_lo_hi = vmovl_s32(vget_high_s32(va_hi_lo));\n        int64x2_t va_hi_hi_lo = vmovl_s32(vget_low_s32(va_hi_hi));\n        int64x2_t va_hi_hi_hi = vmovl_s32(vget_high_s32(va_hi_hi));\n\n        int64x2_t vb_lo_lo_lo = vmovl_s32(vget_low_s32(vb_lo_lo));\n        int64x2_t vb_lo_lo_hi = vmovl_s32(vget_high_s32(vb_lo_lo));\n        int64x2_t vb_lo_hi_lo = vmovl_s32(vget_low_s32(vb_lo_hi));\n        int64x2_t vb_lo_hi_hi = vmovl_s32(vget_high_s32(vb_lo_hi));\n        int64x2_t vb_hi_lo_lo = vmovl_s32(vget_low_s32(vb_hi_lo));\n        int64x2_t vb_hi_lo_hi = vmovl_s32(vget_high_s32(vb_hi_lo));\n        int64x2_t vb_hi_hi_lo = vmovl_s32(vget_low_s32(vb_hi_hi));\n        int64x2_t vb_hi_hi_hi = vmovl_s32(vget_high_s32(vb_hi_hi));\n\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(va_hi_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(va_hi_hi)), 0);\n\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(vb_hi_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(vb_hi_hi)), 0);\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_lo = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_hi = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_lo = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_hi = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_lo_sq = vmull_s16(vget_low_s16(va_lo), vget_low_s16(va_lo));\n        int32x4_t va_hi_sq = vmull_s16(vget_high_s16(va_lo), vget_high_s16(va_lo));\n        int32x4_t va_lo_sq_hi = vmull_s16(vget_low_s16(va_hi), vget_low_s16(va_hi));\n        int32x4_t va_hi_sq_hi = vmull_s16(vget_high_s16(va_hi), vget_high_s16(va_hi));\n\n        int32x4_t prod_lo = vmull_s16(vget_low_s16(va_lo), vget_low_s16(vb_lo));\n        int32x4_t prod_hi = vmull_s16(vget_high_s16(va_lo), vget_high_s16(vb_lo));\n        int32x4_t prod_lo_hi = vmull_s16(vget_low_s16(va_hi), vget_low_s16(vb_hi));\n        int32x4_t prod_hi_hi = vmull_s16(vget_high_s16(va_hi), vget_high_s16(vb_hi));\n\n        int64x2_t sum_sq_lo = vmovl_s32(vget_low_s32(va_lo_sq));\n        int64x2_t sum_sq_hi = vmovl_s32(vget_high_s32(va_lo_sq));\n        int64x2_t sum_sq_lo_hi = vmovl_s32(vget_low_s32(va_hi_sq));\n        int64x2_t sum_sq_hi_hi = vmovl_s32(vget_high_s32(va_hi_sq));\n        \n        int64x2_t sum_sq_lo_lo_hi = vmovl_s32(vget_low_s32(va_lo_sq_hi));\n        int64x2_t sum_sq_hi_lo_hi = vmovl_s32(vget_high_s32(va_lo_sq_hi));\n        int64x2_t sum_sq_lo_hi_hi = vmovl_s32(vget_low_s32(va_hi_sq_hi));\n        int64x2_t sum_sq_hi_hi_hi = vmovl_s32(vget_high_s32(va_hi_sq_hi));\n\n        int64x2_t sum_prod_lo = vmovl_s32(vget_low_s32(prod_lo));\n        int64x2_t sum_prod_hi = vmovl_s32(vget_high_s32(prod_lo));\n        int64x2_t sum_prod_lo_hi = vmovl_s32(vget_low_s32(prod_lo_hi));\n        int64x2_t sum_prod_hi_hi = vmovl_s32(vget_high_s32(prod_lo_hi));\n        \n        int64x2_t sum_prod_lo_lo_hi = vmovl_s32(vget_low_s32(prod_hi));\n        int64x2_t sum_prod_hi_lo_hi = vmovl_s32(vget_high_s32(prod_hi));\n        int64x2_t sum_prod_lo_hi_hi = vmovl_s32(vget_low_s32(prod_hi_hi));\n        int64x2_t sum_prod_hi_hi_hi = vmovl_s32(vget_high_s32(prod_hi_hi));\n\n        sum_sq += vgetq_lane_s64(vaddq_s64(vaddq_s64(sum_sq_lo, sum_sq_hi), vaddq_s64(sum_sq_lo_lo_hi, sum_sq_hi_lo_hi)), 0);\n        sum_sq += vgetq_lane_s64(vaddq_s64(vaddq_s64(sum_sq_lo_hi_hi, sum_sq_hi_hi_hi),vaddq_s64(sum_sq_hi_hi, sum_sq_lo)), 1);\n        sum_prod += vgetq_lane_s64(vaddq_s64(vaddq_s64(sum_prod_lo, sum_prod_hi), vaddq_s64(sum_prod_lo_lo_hi, sum_prod_hi_lo_hi)), 0);\n        sum_prod += vgetq_lane_s64(vaddq_s64(vaddq_s64(sum_prod_lo_hi_hi, sum_prod_hi_hi_hi),vaddq_s64(sum_prod_hi_hi, sum_prod_lo)), 1);\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_lo = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_hi = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_lo = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_hi = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_lo_lo = vmovl_s16(vget_low_s16(va_lo));\n        int32x4_t va_lo_hi = vmovl_s16(vget_high_s16(va_lo));\n        int32x4_t va_hi_lo = vmovl_s16(vget_low_s16(va_hi));\n        int32x4_t va_hi_hi = vmovl_s16(vget_high_s16(va_hi));\n\n        int32x4_t vb_lo_lo = vmovl_s16(vget_low_s16(vb_lo));\n        int32x4_t vb_lo_hi = vmovl_s16(vget_high_s16(vb_lo));\n        int32x4_t vb_hi_lo = vmovl_s16(vget_low_s16(vb_hi));\n        int32x4_t vb_hi_hi = vmovl_s16(vget_high_s16(vb_hi));\n\n        int64x2_t va_lo_lo_lo = vmovl_s32(vget_low_s32(va_lo_lo));\n        int64x2_t va_lo_lo_hi = vmovl_s32(vget_high_s32(va_lo_lo));\n        int64x2_t va_lo_hi_lo = vmovl_s32(vget_low_s32(va_lo_hi));\n        int64x2_t va_lo_hi_hi = vmovl_s32(vget_high_s32(va_lo_hi));\n        int64x2_t va_hi_lo_lo = vmovl_s32(vget_low_s32(va_hi_lo));\n        int64x2_t va_hi_lo_hi = vmovl_s32(vget_high_s32(va_hi_lo));\n        int64x2_t va_hi_hi_lo = vmovl_s32(vget_low_s32(va_hi_hi));\n        int64x2_t va_hi_hi_hi = vmovl_s32(vget_high_s32(va_hi_hi));\n\n        int64x2_t vb_lo_lo_lo = vmovl_s32(vget_low_s32(vb_lo_lo));\n        int64x2_t vb_lo_lo_hi = vmovl_s32(vget_high_s32(vb_lo_lo));\n        int64x2_t vb_lo_hi_lo = vmovl_s32(vget_low_s32(vb_lo_hi));\n        int64x2_t vb_lo_hi_hi = vmovl_s32(vget_high_s32(vb_lo_hi));\n        int64x2_t vb_hi_lo_lo = vmovl_s32(vget_low_s32(vb_hi_lo));\n        int64x2_t vb_hi_lo_hi = vmovl_s32(vget_high_s32(vb_hi_lo));\n        int64x2_t vb_hi_hi_lo = vmovl_s32(vget_low_s32(vb_hi_hi));\n        int64x2_t vb_hi_hi_hi = vmovl_s32(vget_high_s32(vb_hi_hi));\n\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(va_hi_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(va_hi_hi)), 0);\n\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(vb_hi_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(vb_hi_hi)), 0);\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_lo = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_hi = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_lo = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_hi = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_lo_lo = vmovl_s16(vget_low_s16(va_lo));\n        int32x4_t va_lo_hi = vmovl_s16(vget_high_s16(va_lo));\n        int32x4_t va_hi_lo = vmovl_s16(vget_low_s16(va_hi));\n        int32x4_t va_hi_hi = vmovl_s16(vget_high_s16(va_hi));\n\n        int32x4_t vb_lo_lo = vmovl_s16(vget_low_s16(vb_lo));\n        int32x4_t vb_lo_hi = vmovl_s16(vget_high_s16(vb_lo));\n        int32x4_t vb_hi_lo = vmovl_s16(vget_low_s16(vb_hi));\n        int32x4_t vb_hi_hi = vmovl_s16(vget_high_s16(vb_hi));\n\n        int64x2_t va_lo_lo_lo = vmovl_s32(vget_low_s32(va_lo_lo));\n        int64x2_t va_lo_lo_hi = vmovl_s32(vget_high_s32(va_lo_lo));\n        int64x2_t va_lo_hi_lo = vmovl_s32(vget_low_s32(va_lo_hi));\n        int64x2_t va_lo_hi_hi = vmovl_s32(vget_high_s32(va_lo_hi));\n        int64x2_t va_hi_lo_lo = vmovl_s32(vget_low_s32(va_hi_lo));\n        int64x2_t va_hi_lo_hi = vmovl_s32(vget_high_s32(va_hi_lo));\n        int64x2_t va_hi_hi_lo = vmovl_s32(vget_low_s32(va_hi_hi));\n        int64x2_t va_hi_hi_hi = vmovl_s32(vget_high_s32(va_hi_hi));\n\n        int64x2_t vb_lo_lo_lo = vmovl_s32(vget_low_s32(vb_lo_lo));\n        int64x2_t vb_lo_lo_hi = vmovl_s32(vget_high_s32(vb_lo_lo));\n        int64x2_t vb_lo_hi_lo = vmovl_s32(vget_low_s32(vb_lo_hi));\n        int64x2_t vb_lo_hi_hi = vmovl_s32(vget_high_s32(vb_lo_hi));\n        int64x2_t vb_hi_lo_lo = vmovl_s32(vget_low_s32(vb_hi_lo));\n        int64x2_t vb_hi_lo_hi = vmovl_s32(vget_high_s32(vb_hi_lo));\n        int64x2_t vb_hi_hi_lo = vmovl_s32(vget_low_s32(vb_hi_hi));\n        int64x2_t vb_hi_hi_hi = vmovl_s32(vget_high_s32(vb_hi_hi));\n\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(va_lo_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(va_lo_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(va_hi_lo)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(va_hi_hi)), 0);\n        sum_sq += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(va_hi_hi)), 0);\n\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_lo), vget_low_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_lo), vget_high_s32(vb_lo_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_lo_hi), vget_low_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_lo_hi), vget_high_s32(vb_lo_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_lo), vget_low_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_lo), vget_high_s32(vb_hi_lo)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_low_s32(va_hi_hi), vget_low_s32(vb_hi_hi)), 0);\n        sum_prod += vget_lane_s64(vmull_s32(vget_high_s32(va_hi_hi), vget_high_s32(vb_hi_hi)), 0);\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(C + i, result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int8x16_t positive_mask_a = vcgtq_s8(va, vdupq_n_s8(0));\n        int8x16_t positive_mask_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        int8x16_t negative_mask_a = vcltq_s8(va, vdupq_n_s8(0));\n        int8x16_t negative_mask_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        int8x16_t both_positive = vandq_s8(positive_mask_a, positive_mask_b);\n        int8x16_t both_negative = vandq_s8(negative_mask_a, negative_mask_b);\n\n        int8x16_t result = vbslq_s8(both_positive, vdupq_n_s8(1), vbslq_s8(both_negative, vdupq_n_s8(-1), vdupq_n_s8(0)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int8x16_t positive_mask = vandq_s8(va, vb);\n        positive_mask = vcgtq_s8(positive_mask, vdupq_n_s8(0));\n\n        int8x16_t negative_mask = vorrq_s8(va, vb);\n        negative_mask = vcleq_s8(negative_mask, vdupq_n_s8(0));\n        negative_mask = vandq_s8(negative_mask, vandq_s8(vcgeq_s8(va, vdupq_n_s8(-128)), vcleq_s8(va, vdupq_n_s8(-1))));\n        negative_mask = vandq_s8(negative_mask, vandq_s8(vcgeq_s8(vb, vdupq_n_s8(-128)), vcleq_s8(vb, vdupq_n_s8(-1))));\n\n        int8x16_t result = vbslq_s8(positive_mask, vdupq_n_s8(1), vdupq_n_s8(0));\n        result = vbslq_s8(negative_mask, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int8x16_t positive_mask_a = vcgtq_s8(va, vdupq_n_s8(0));\n        int8x16_t positive_mask_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        int8x16_t negative_mask_a = vcltq_s8(va, vdupq_n_s8(0));\n        int8x16_t negative_mask_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        int8x16_t both_positive = vandq_s8(positive_mask_a, positive_mask_b);\n        int8x16_t both_negative = vandq_s8(negative_mask_a, negative_mask_b);\n\n        int8x16_t result = vbslq_s8(both_positive, vdupq_n_s8(1), vbslq_s8(both_negative, vdupq_n_s8(-1), vdupq_n_s8(0)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int8x16_t positive_mask_a = vcgtq_s8(va, vdupq_n_s8(0));\n        int8x16_t positive_mask_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        int8x16_t negative_mask_a = vcltq_s8(va, vdupq_n_s8(0));\n        int8x16_t negative_mask_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        int8x16_t both_positive = vandq_s8(positive_mask_a, positive_mask_b);\n        int8x16_t both_negative = vandq_s8(negative_mask_a, negative_mask_b);\n\n        int8x16_t result = vbslq_s8(both_positive, vdupq_n_s8(1), vbslq_s8(both_negative, vdupq_n_s8(-1), vdupq_n_s8(0)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int8x16_t positive_mask_a = vcgtq_s8(va, vdupq_n_s8(0));\n        int8x16_t positive_mask_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        int8x16_t negative_mask_a = vcltq_s8(va, vdupq_n_s8(0));\n        int8x16_t negative_mask_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        int8x16_t both_positive = vandq_s8(positive_mask_a, positive_mask_b);\n        int8x16_t both_negative = vandq_s8(negative_mask_a, negative_mask_b);\n\n        int8x16_t result = vbslq_s8(both_positive, vdupq_n_s8(1), vbslq_s8(both_negative, vdupq_n_s8(-1), vdupq_n_s8(0)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint using SIMD (8 elements at a time)\n    for (; i + 7 < midpoint; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        uint16x8_t vxor = veorq_u16(va, vb);\n        vst1q_u16(C + i, vxor);\n    }\n\n    // Process remaining elements before the midpoint (if any)\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    C[midpoint] = A[midpoint];\n    i = midpoint + 1;\n\n    // Process elements after the midpoint using SIMD (8 elements at a time)\n    for (; i + 7 < length; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        uint16x8_t vand = vandq_u16(va, vb);\n        vst1q_u16(C + i, vand);\n    }\n\n    // Process remaining elements after the midpoint (if any)\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint using SIMD\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n\n    // Process remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Process the element at the midpoint\n    C[midpoint] = A[midpoint];\n    i = midpoint + 1;\n\n    // Process elements after the midpoint using SIMD\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n\n    // Process remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    // Process elements before the midpoint with XOR\n    for (i = 0; i < midpoint / 8 * 8; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Store the midpoint value from A\n    C[midpoint] = A[midpoint];\n\n    // Process elements after the midpoint with AND\n    for (i = midpoint + 1; i < length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    // Process elements before the midpoint\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t xor_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, xor_vec);\n    }\n\n    // Keep the value in A at the midpoint\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (; i < length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t and_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, and_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n\n    // Keep the value in A at the midpoint\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t mask1 = vshrq_n_u32(cond1_vec, 31);\n        uint32x4_t mask2 = vshrq_n_u32(cond2_vec, 31);\n\n        float32x4_t out_vec = vbslq_f32(mask1, A_vec, D_vec);\n        out_vec = vbslq_f32(mask2, C_vec, out_vec);\n        vst1q_f32(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t c1 = vmov_n_u32(0);\n        uint32x4_t c2 = vmov_n_u32(0);\n\n        if (cond1[i]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 0);\n        if (cond1[i+1]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 1);\n        if (cond1[i+2]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 2);\n        if (cond1[i+3]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 3);\n\n        if (cond2[i]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 0);\n        if (cond2[i+1]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 1);\n        if (cond2[i+2]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 2);\n        if (cond2[i+3]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 3);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result;\n\n        uint32x4_t both = vandq_u32(c1, c2);\n        uint32x4_t c1_not_c2 = vandq_u32(c1, vmvnq_u32(c2));\n        uint32x4_t not_c1_c2 = vandq_u32(vmvnq_u32(c1), c2);\n        uint32x4_t neither = vandq_u32(vmvnq_u32(c1), vmvnq_u32(c2));\n\n        result = vbslq_f32(vreinterpretq_f32_u32(both), a, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(c1_not_c2), b, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(not_c1_c2), c, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(neither), d, result);\n\n        vst1q_f32(out + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t c1 = vmov_n_u32(0);\n        uint32x4_t c2 = vmov_n_u32(0);\n\n        if (cond1[i + 0]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 0);\n        if (cond1[i + 1]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 1);\n        if (cond1[i + 2]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 2);\n        if (cond1[i + 3]) c1 = vset_lane_u32(0xFFFFFFFF, c1, 3);\n\n        if (cond2[i + 0]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 0);\n        if (cond2[i + 1]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 1);\n        if (cond2[i + 2]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 2);\n        if (cond2[i + 3]) c2 = vset_lane_u32(0xFFFFFFFF, c2, 3);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result;\n\n        uint32x4_t both = vandq_u32(c1, c2);\n        uint32x4_t only_c1 = vandq_u32(c1, vmvnq_u32(c2));\n        uint32x4_t only_c2 = vandq_u32(vmvnq_u32(c1), c2);\n        uint32x4_t neither = vandq_u32(vmvnq_u32(c1), vmvnq_u32(c2));\n\n        result = vbslq_f32(vreinterpretq_f32_u32(both), a, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(only_c1), b, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(only_c2), c, result);\n        result = vbslq_f32(vreinterpretq_f32_u32(neither), d, result);\n\n        vst1q_f32(out + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t v_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t v_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        float32x4_t v_A = vld1q_f32(A + i);\n        float32x4_t v_B = vld1q_f32(B + i);\n        float32x4_t v_C = vld1q_f32(C + i);\n        float32x4_t v_D = vld1q_f32(D + i);\n\n        uint32x4_t both_true = vandq_u32(v_cond1, v_cond2);\n        uint32x4_t cond1_true_cond2_false = vandq_u32(v_cond1, vmvnq_u32(v_cond2));\n        uint32x4_t cond1_false_cond2_true = vandq_u32(vmvnq_u32(v_cond1), v_cond2);\n        uint32x4_t both_false = vandq_u32(vmvnq_u32(v_cond1), vmvnq_u32(v_cond2));\n\n        float32x4_t result = vbslq_f32(vceqzq_f32(vcvtq_f32_u32(both_true)), v_A,\n                             vbslq_f32(vceqzq_f32(vcvtq_f32_u32(cond1_true_cond2_false)), v_B,\n                             vbslq_f32(vceqzq_f32(vcvtq_f32_u32(cond1_false_cond2_true)), v_C, v_D)));\n\n        vst1q_f32(out + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t v_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t v_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        float32x4_t v_A = vld1q_f32(A + i);\n        float32x4_t v_B = vld1q_f32(B + i);\n        float32x4_t v_C = vld1q_f32(C + i);\n        float32x4_t v_D = vld1q_f32(D + i);\n\n        uint32x4_t both_true = vandq_u32(v_cond1, v_cond2);\n        uint32x4_t cond1_true_cond2_false = vandq_u32(v_cond1, vmvnq_u32(v_cond2));\n        uint32x4_t cond1_false_cond2_true = vandq_u32(vmvnq_u32(v_cond1), v_cond2);\n        uint32x4_t both_false = vandq_u32(vmvnq_u32(v_cond1), vmvnq_u32(v_cond2));\n\n        float32x4_t result = vbslq_f32(vreinterpretq_f32_u32(both_true), v_A,\n                                vbslq_f32(vreinterpretq_f32_u32(cond1_true_cond2_false), v_B,\n                                vbslq_f32(vreinterpretq_f32_u32(cond1_false_cond2_true), v_C, v_D)));\n\n        vst1q_f32(out + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint8x16_t bit_counts = {0};\n\n        // Count bits using a lookup table approach with NEON\n        uint8x16_t lookup_table = {\n            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4\n        };\n\n        uint8x16_t counts0 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_low_u8(vreinterpretq_u8_u32(data))), 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts1 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_high_u8(vreinterpretq_u8_u32(data))), 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts2 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_low_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 8)))), 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts3 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_high_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 8)))) , 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts4 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_low_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 16)))) , 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts5 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_high_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 16)))) , 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts6 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_low_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 24)))) , 4), vdupq_n_u8(0x0F)));\n        uint8x16_t counts7 = vtbl1q_u8(lookup_table, vandq_u8(vshrn_n_u16(vmovl_u8(vget_high_u8(vreinterpretq_u8_u32(vshr_n_u32(data, 24)))) , 4), vdupq_n_u8(0x0F)));\n\n        uint8x16_t sum1 = vaddq_u8(counts0, counts1);\n        uint8x16_t sum2 = vaddq_u8(counts2, counts3);\n        uint8x16_t sum3 = vaddq_u8(counts4, counts5);\n        uint8x16_t sum4 = vaddq_u8(counts6, counts7);\n\n        uint8x16_t sum5 = vaddq_u8(sum1, sum2);\n        uint8x16_t sum6 = vaddq_u8(sum3, sum4);\n\n        uint8x16_t final_sum = vaddq_u8(sum5, sum6);\n\n        uint8x4_t result = vadd_u8(vget_low_u8(final_sum), vget_high_u8(final_sum));\n\n        vst1_u8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint8x16_t bit_counts = {0};\n\n        // Count bits using a lookup table approach with NEON\n        uint8x16_t lookup_table = {\n            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4\n        };\n\n        uint8x16_t counts = {0};\n\n        // Process each 8-bit chunk of the 32-bit integers\n        for (int j = 0; j < 4; ++j) {\n            uint8x16_t byte_data;\n            if (j == 0) byte_data = vmovq_n_u8(data[0] & 0xFF);\n            else if (j == 1) byte_data = vmovq_n_u8((data[1] >> 8) & 0xFF);\n            else if (j == 2) byte_data = vmovq_n_u8((data[2] >> 16) & 0xFF);\n            else byte_data = vmovq_n_u8((data[3] >> 24) & 0xFF);\n\n            uint8x16_t low_nibble = vandq_u8(byte_data, vdupq_n_u8(0x0F));\n            uint8x16_t high_nibble = vandq_u8(vshrq_n_u8(byte_data, 4), vdupq_n_u8(0x0F));\n\n            counts = vqaddq_u8(counts, vtbl1q_u8(lookup_table, low_nibble));\n            counts = vqaddq_u8(counts, vtbl1q_u8(lookup_table, high_nibble));\n        }\n\n        out[i] = counts[0];\n        out[i+1] = counts[1];\n        out[i+2] = counts[2];\n        out[i+3] = counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint8x16_t lookup = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n        uint8x16_t nibbles_0 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 0), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_1 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 4), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_2 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 8), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_3 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 12), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_4 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 16), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_5 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 20), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_6 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 24), vdupq_n_u32(0x0F)));\n        uint8x16_t nibbles_7 = vtbl1q_u8(lookup, vandq_u8(vshrq_n_u32(data, 28), vdupq_n_u32(0x0F)));\n\n        uint8x16_t sum1 = vaddq_u8(nibbles_0, nibbles_1);\n        uint8x16_t sum2 = vaddq_u8(nibbles_2, nibbles_3);\n        uint8x16_t sum3 = vaddq_u8(nibbles_4, nibbles_5);\n        uint8x16_t sum4 = vaddq_u8(nibbles_6, nibbles_7);\n\n        uint8x16_t sum5 = vaddq_u8(sum1, sum2);\n        uint8x16_t sum6 = vaddq_u8(sum3, sum4);\n\n        uint8x16_t sum7 = vaddq_u8(sum5, sum6);\n\n        uint8x8_t res = vget_low_u8(vaddq_u8(sum7, vcombine_u8(vget_high_u8(sum7), vget_high_u8(sum7))));\n\n        uint8x8_t res2 = vpadd_u8(res, res);\n        uint8x8_t res3 = vpadd_u8(res2, res2);\n        uint8x8_t res4 = vpadd_u8(res3, res3);\n\n        vst1_lane_u8(out + i + 0, res4, 0);\n        vst1_lane_u8(out + i + 1, res4, 1);\n        vst1_lane_u8(out + i + 2, res4, 2);\n        vst1_lane_u8(out + i + 3, res4, 3);\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint8x16_t cnt = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        uint8x16_t lookup = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n\n        uint32x4_t tmp = a;\n        uint32x4_t low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0);\n\n        tmp = vshrq_n_u32(a, 4);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 8);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 12);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 16);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 20);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 24);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        tmp = vshrq_n_u32(a, 28);\n        low = vandq_u32(tmp, vdupq_n_u32(0x0F));\n        cnt = vaddq_u8(cnt, vgetq_lane_u8x16(vreinterpretq_u8_u16(vtbl1q_u8(lookup, vreinterpretq_u8_u32(low))), 0));\n\n        uint8x4_t res = vget_low_u8(vmovn_u16(vaddq_u16(vreinterpretq_u16_u8(cnt), vdupq_n_u16(0))));\n        vst1_u8(out + i, res);\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint8x16_t bit_counts = {0};\n\n        // Count bits using a lookup table approach with NEON\n        uint8x16_t lookup_table = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};\n\n        uint8x16_t low_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        data = vshrq_n_u32(data, 4);\n        uint8x16_t high_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, low_nibble);\n        bit_counts = vaddq_u8(bit_counts, high_nibble);\n        data = vshrq_n_u32(data, 4);\n        low_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, low_nibble);\n        data = vshrq_n_u32(data, 4);\n        high_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, high_nibble);\n        data = vshrq_n_u32(data, 4);\n        low_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, low_nibble);\n        data = vshrq_n_u32(data, 4);\n        high_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, high_nibble);\n        data = vshrq_n_u32(data, 4);\n        low_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, low_nibble);\n        data = vshrq_n_u32(data, 4);\n        high_nibble = vtbl1q_u8(lookup_table, vandq_u8(vmovq_n_u8(0x0F), vreinterpretq_u8_u32(data)));\n        bit_counts = vaddq_u8(bit_counts, high_nibble);\n\n        uint8x8_t result = vget_low_u8(bit_counts);\n        vst1_u8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 4) {\n            int32x4_t a = vld1q_s32(A + i * cols + j);\n            int32x4_t mod_result = vandq_s32(a, vdupq_n_s32(3));\n            int32x4_t mask = vceqq_s32(vsubq_s32(a, vmulq_s32(vdivq_s32(vcvtq_f32_s32(vcvtq_f32_s32(a)), vcvtq_f32_s32(vdupq_n_s32(3))), vdupq_n_s32(3))), vdupq_n_s32(0));\n            int32x4_t abs_a = vabsq_s32(a);\n            int32x4_t result = vbslq_s32(mask, abs_a, a);\n            vst1q_s32(B + i * cols + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 4) {\n            int32x4_t a = vld1q_s32(A + i * cols + j);\n            int32x4_t mod_result = vandq_s32(a, vdupq_n_s32(3));\n            int32x4_t condition = vceqzq_s32(vmodq_s32(a, vdupq_n_s32(3)));\n            int32x4_t abs_a = vabsq_s32(a);\n            int32x4_t result = vbslq_s32(condition, abs_a, a);\n            vst1q_s32(B + i * cols + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 4) {\n            int32x4_t a = vld1q_s32(A + i * cols + j);\n            int32x4_t mod_result = vandq_s32(a, vdupq_n_s32(3));\n            int32x4_t condition = vceqzq_s32(vmodq_s32(a, vdupq_n_s32(3)));\n            int32x4_t abs_a = vabsq_s32(a);\n            int32x4_t result = vbslq_s32(condition, abs_a, a);\n            vst1q_s32(B + i * cols + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 4) {\n            int32x4_t a = vld1q_s32(A + i * cols + j);\n            int32x4_t mod_result = vandq_s32(a, vdupq_n_s32(3));\n            int32x4_t condition = vceqzq_s32(vmodq_s32(a, vdupq_n_s32(3)));\n            int32x4_t abs_a = vabsq_s32(a);\n            int32x4_t result = vbslq_s32(condition, abs_a, a);\n            vst1q_s32(B + i * cols + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 4) {\n            int32x4_t a = vld1q_s32(A + i * cols + j);\n            int32x4_t mod_result = vandq_s32(a, vdupq_n_s32(3));\n            int32x4_t condition = vceqzq_s32(vmodq_s32(a, vdupq_n_s32(3)));\n            int32x4_t abs_a = vabsq_s32(a);\n            int32x4_t result = vbslq_s32(condition, abs_a, a);\n            vst1q_s32(B + i * cols + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32_t mask = 0x0F;\n\n    if (rotate_bits == 0) {\n        uint32x4_t mask_v = vdupq_n_u32(mask);\n        for (i = 0; i + 4 <= length; i += 4) {\n            uint32x4_t src_v = vld1q_u32(src + i);\n            uint32x4_t low_bits = vandq_u32(src_v, mask_v);\n            uint32x4_t condition = vceqq_u32(low_bits, mask_v);\n            uint32x4_t not_src = vmvnq_u32(src_v);\n            uint32x4_t result = vbslq_u32(condition, src_v, not_src);\n            vst1q_u32(dst + i, result);\n        }\n    } else {\n        for (i = 0; i + 4 <= length; i += 4) {\n            uint32x4_t src_v = vld1q_u32(src + i);\n            uint32x4_t mask_v = vdupq_n_u32(mask);\n            uint32x4_t low_bits = vandq_u32(src_v, mask_v);\n            uint32x4_t condition = vceqq_u32(low_bits, mask_v);\n\n            uint32x4_t rotated_v;\n            uint32_t rotate_bits_local = rotate_bits % 32;\n            if (rotate_bits_local != 0) {\n                uint32x4_t left_shift = vshlq_u32(src_v, vdupq_n_s32(rotate_bits_local));\n                uint32x4_t right_shift = vshrq_n_u32(src_v, 32 - rotate_bits_local);\n                rotated_v = vorrq_u32(left_shift, right_shift);\n            } else {\n                rotated_v = src_v;\n            }\n\n            uint32x4_t not_src = vmvnq_u32(src_v);\n            uint32x4_t result = vbslq_u32(condition, rotated_v, not_src);\n            vst1q_u32(dst + i, result);\n        }\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & mask) == mask) {\n            uint32_t rotate_bits_local = rotate_bits % 32;\n            dst[i] = (src[i] << rotate_bits_local) | (src[i] >> (32 - rotate_bits_local));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32_t mask = 0x0F;\n\n    if (rotate_bits == 0) {\n        for (; i < length; ++i) {\n            if ((src[i] & mask) == mask) {\n                dst[i] = src[i];\n            } else {\n                dst[i] = ~src[i];\n            }\n        }\n        return;\n    }\n\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t mask_vec = vdupq_n_u32(mask);\n        uint32x4_t all_ones_vec = vdupq_n_u32(mask); \n\n        uint32x4_t low_bits = vandq_u32(src_vec, mask_vec);\n        uint32x4_t condition = vceqq_u32(low_bits, all_ones_vec);\n\n        uint32x4_t rotated_vec;\n        if (rotate_bits > 0 && rotate_bits < 32) {\n            rotated_vec = vshrq_n_u32(src_vec, rotate_bits) | vshlq_n_u32(src_vec, 32 - rotate_bits);\n        } else {\n            rotated_vec = src_vec;\n        }\n        uint32x4_t not_src_vec = vmvnq_u32(src_vec);\n\n        uint32x4_t result_vec = vbslq_u32(condition, rotated_vec, not_src_vec);\n\n        vst1q_u32(dst + i, result_vec);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & mask) == mask) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32_t mask = 0x0F;\n\n    if (rotate_bits == 0) {\n        uint32x4_t mask_v = vdupq_n_u32(mask);\n        for (i = 0; i + 4 <= length; i += 4) {\n            uint32x4_t src_v = vld1q_u32(src + i);\n            uint32x4_t low_bits = vandq_u32(src_v, mask_v);\n            uint32x4_t cmp_result = vceqq_u32(low_bits, mask_v);\n            uint32x4_t not_src_v = vmvnq_u32(src_v);\n            uint32x4_t result = vbslq_u32(cmp_result, src_v, not_src_v);\n            vst1q_u32(dst + i, result);\n        }\n    } else {\n        uint32x4_t mask_v = vdupq_n_u32(mask);\n        for (i = 0; i + 4 <= length; i += 4) {\n            uint32x4_t src_v = vld1q_u32(src + i);\n            uint32x4_t low_bits = vandq_u32(src_v, mask_v);\n            uint32x4_t cmp_result = vceqq_u32(low_bits, mask_v);\n            uint32x4_t not_src_v = vmvnq_u32(src_v);\n\n            uint32x4_t rotated_v;\n            uint32_t arr[4];\n            vst1q_u32(arr, src_v);\n            for(int j = 0; j < 4; j++){\n                arr[j] = (arr[j] >> rotate_bits) | (arr[j] << (32 - rotate_bits));\n            }\n            rotated_v = vld1q_u32(arr);\n            \n            uint32x4_t result = vbslq_u32(cmp_result, rotated_v, not_src_v);\n            vst1q_u32(dst + i, result);\n        }\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & mask) == mask) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32_t mask = 0x0F;\n\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t mask_vec = vdupq_n_u32(mask);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask_vec);\n        uint32x4_t cmp_vec = vceqq_u32(low_bits, mask_vec);\n\n        uint32x4_t rotated_vec;\n        if (rotate_bits != 0) {\n            uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits);\n            uint32x4_t shift_right_vec = vshrq_u32(src_vec, rotate_bits);\n            uint32x4_t shift_left_vec = vshlq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_bits_vec));\n            rotated_vec = vorrq_u32(shift_right_vec, shift_left_vec);\n        } else {\n            rotated_vec = src_vec;\n        }\n\n        uint32x4_t not_src_vec = vmvnq_u32(src_vec);\n        uint32x4_t result_vec = vbslq_u32(cmp_vec, rotated_vec, not_src_vec);\n\n        vst1q_u32(dst + i, result_vec);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & mask) == mask) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32_t mask = 0x0F;\n\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t mask_vec = vdupq_n_u32(mask);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask_vec);\n        uint32x4_t cmp_vec = vceqq_u32(low_bits, mask_vec);\n\n        uint32x4_t rotated_vec;\n        if (rotate_bits != 0) {\n            uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits);\n            uint32x4_t shift_right = vshrq_u32(src_vec, rotate_bits);\n            uint32x4_t shift_left = vshlq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_bits_vec));\n            rotated_vec = vorrq_u32(shift_right, shift_left);\n        } else {\n            rotated_vec = src_vec;\n        }\n\n        uint32x4_t not_src_vec = vmvnq_u32(src_vec);\n        uint32x4_t result_vec = vbslq_u32(cmp_vec, rotated_vec, not_src_vec);\n\n        vst1q_u32(dst + i, result_vec);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & mask) == mask) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    float32x4_t epsilon_vec = vdupq_n_f32(abs_epsilon);\n    \n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n\n        // Compare A[i] - B[i] > abs(epsilon)\n        uint32x4_t gt_mask = vcgtq_f32(diff_vec, epsilon_vec);\n\n        // Compare A[i] - B[i] < -abs(epsilon)\n        float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff_vec, neg_epsilon_vec);\n\n        // Set out[i] to 1 where A[i] - B[i] > abs(epsilon)\n        int8x4_t out_vec = vdup_n_s8(0); // Initialize to 0\n        out_vec = vbsl_s8(vreinterpret_u8_s8(gt_mask), vdup_n_s8(1), out_vec);\n\n        // Set out[i] to -1 where A[i] - B[i] < -abs(epsilon)\n        out_vec = vbsl_s8(vreinterpret_u8_s8(lt_mask), vdup_n_s8(-1), out_vec);\n\n        vst1_s8(out + i, out_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        \n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n        uint32x4_t greater_than = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t less_than = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n        \n        int32x4_t result = vdupq_n_s32(0);\n        result = vbslq_s32(greater_than, vdupq_n_s32(1), result);\n        result = vbslq_s32(less_than, vdupq_n_s32(-1), result);\n        \n        int8x16_t out_vec = vcombine_s8(vqmovn_s16(vshlq_n_s16(vreinterpretq_s16_s32(result), 8)),\n                                         vqmovn_s16(vreinterpretq_s16_s32(result)));\n        \n        vst1q_s8(out + i, out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = std::abs(epsilon);\n    float32x4_t epsilon_vec = vdupq_n_f32(abs_epsilon);\n    \n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n\n        uint32x4_t gt_mask = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n        uint32x4_t eq_mask = vcleq_f32(abs_diff_vec, epsilon_vec);\n\n        int8x4_t result_vec = vdup_n_s8(0);\n\n        result_vec = vbsl_s8(vreinterpret_u8_s8(gt_mask), vdup_n_s8(1), result_vec);\n        result_vec = vbsl_s8(vreinterpret_u8_s8(lt_mask), vdup_n_s8(-1), result_vec);\n        \n        vst1_s8(out + i, result_vec);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = std::abs(epsilon);\n    float32x4_t epsilon_vec = vdupq_n_f32(abs_epsilon);\n    \n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n\n        // Compare A[i] - B[i] > abs(epsilon)\n        uint32x4_t gt_mask = vcgtq_f32(diff_vec, epsilon_vec);\n\n        // Compare A[i] - B[i] < -abs(epsilon)\n        float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff_vec, neg_epsilon_vec);\n\n        // If A[i] - B[i] > abs(epsilon), out[i] = 1\n        int8x4_t out_vec = vdup_n_s8(0);\n        out_vec = vbsl_s8(vreinterpret_u8_s8(gt_mask), vdup_n_s8(1), out_vec);\n\n        // If A[i] - B[i] < -abs(epsilon), out[i] = -1\n        out_vec = vbsl_s8(vreinterpret_u8_s8(lt_mask), vdup_n_s8(-1), out_vec);\n\n        vst1_s8(out + i, out_vec);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n\n        uint32x4_t greater_than = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t less_than = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n        \n        int8x8_t result = vdup_n_s8(0);\n        result = vorr_s8(result, vshl_n_s8(vreinterpret_s8_u32(vmovn_u32(greater_than)), 1));\n        result = vorr_s8(result, vshl_n_s8(vreinterpret_s8_u32(vmovn_u32(less_than)), -1));\n\n        vst1_s8(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t float_vec = vld1q_f32(A + i);\n        int32x4_t int_vec = vcvtnq_s32_f32(float_vec);\n\n        float32x4_t max_val = vdupq_n_f32(INT32_MAX);\n        float32x4_t min_val = vdupq_n_f32(INT32_MIN);\n\n        int32x4_t max_mask = vcvtq_s32_f32(vcleq_f32(float_vec, max_val));\n        int32x4_t min_mask = vcvtq_s32_f32(vcgeq_f32(float_vec, min_val));\n\n        int_vec = vbslq_s32(max_mask, int_vec, vdupq_n_s32(INT32_MAX));\n        int_vec = vbslq_s32(min_mask, int_vec, vdupq_n_s32(INT32_MIN));\n\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t float_vec = vld1q_f32(A + i);\n        int32x4_t int_vec = vcvtnq_s32_f32(float_vec);\n\n        float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n        int32x4_t max_int = vdupq_n_s32(INT32_MAX);\n        int32x4_t min_int = vdupq_n_s32(INT32_MIN);\n\n        uint32x4_t greater_than_max = vcgtq_f32(float_vec, max_val);\n        uint32x4_t less_than_min = vcltq_f32(float_vec, min_val);\n\n        int_vec = vbslq_s32(greater_than_max, max_int, int_vec);\n        int_vec = vbslq_s32(less_than_min, min_int, int_vec);\n\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t float_vec = vld1q_f32(A + i);\n        int32x4_t int_vec = vcvtnq_s32_f32(float_vec);\n\n        float32x4_t max_val = vdupq_n_f32(INT32_MAX);\n        float32x4_t min_val = vdupq_n_f32(INT32_MIN);\n\n        int32x4_t saturated_max = vdupq_n_s32(INT32_MAX);\n        int32x4_t saturated_min = vdupq_n_s32(INT32_MIN);\n\n        uint32x4_t greater_than_max = vcgtq_f32(float_vec, max_val);\n        uint32x4_t less_than_min = vcltq_f32(float_vec, min_val);\n\n        int_vec = vbslq_s32(greater_than_max, saturated_max, int_vec);\n        int_vec = vbslq_s32(less_than_min, saturated_min, int_vec);\n\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t float_vec = vld1q_f32(A + i);\n        int32x4_t int_vec = vcvtnq_s32_f32(float_vec);\n\n        float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n        int32x4_t max_int = vdupq_n_s32(INT32_MAX);\n        int32x4_t min_int = vdupq_n_s32(INT32_MIN);\n\n        uint32x4_t greater_than_max = vcgtq_f32(float_vec, max_val);\n        uint32x4_t less_than_min = vcltq_f32(float_vec, min_val);\n\n        int_vec = vbslq_s32(greater_than_max, max_int, int_vec);\n        int_vec = vbslq_s32(less_than_min, min_int, int_vec);\n\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t float_vec = vld1q_f32(A + i);\n        int32x4_t int_vec = vcvtnq_s32_f32(float_vec);\n\n        float32x4_t max_val = vdupq_n_f32(INT32_MAX);\n        float32x4_t min_val = vdupq_n_f32(INT32_MIN);\n\n        int32x4_t max_mask = vcvtq_s32_f32(vcleq_f32(float_vec, max_val));\n        int32x4_t min_mask = vcvtq_s32_f32(vcgeq_f32(float_vec, min_val));\n\n        int_vec = vbslq_s32(max_mask, int_vec, vdupq_n_s32(INT32_MAX));\n        int_vec = vbslq_s32(min_mask, int_vec, vdupq_n_s32(INT32_MIN));\n\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32_t scale_float = (float32_t)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_float);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(A + i);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float32_t)A[i] * scale_float;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32_t scale_float = (float32_t)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_float);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(A + i);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float32_t)A[i] * scale_float;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32_t scale_float = (float32_t)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_float);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(A + i);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float32_t)A[i] * scale_float;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32_t scale_float = (float32_t)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_float);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(A + i);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float32_t)A[i] * scale_float;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_vec = vdupq_n_s32((int32_t)scale);\n    float32x4_t scale_float_vec = vcvtq_f32_s32(scale_vec);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(A + i);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled_float_vec = vmulq_f32(float_vec, scale_float_vec);\n        vst1q_f32(B + i, scaled_float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtnq_s32_f32(div_result);\n        vst1q_s32(C + i, rounded_result);\n    }\n\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtnq_s32_f32(div_result);\n        vst1q_s32(C + i, rounded_result);\n    }\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtnq_s32_f32(div_result);\n        vst1q_s32(C + i, rounded_result);\n    }\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtnq_s32_f32(div_result);\n        vst1q_s32(C + i, rounded_result);\n    }\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtnq_s32_f32(div_result);\n        vst1q_s32(C + i, rounded_result);\n    }\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        float64x2_t double_vec = vld1q_f64(A + i);\n        float32x4_t float_vec = vcvtq_f32_f64(double_vec);\n\n        float32x4_t saturated_vec = vbslq_f32(vcltq_f32(float_vec, min_float), min_float, float_vec);\n        saturated_vec = vbslq_f32(vcgtq_f32(saturated_vec, max_float), max_float, saturated_vec);\n\n        vst1q_f32(B + i, saturated_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        float64x2_t double_vec = vld1q_f64(A + i);\n        float32x4_t float_vec = vcvtq_f32_f64(double_vec);\n\n        float32x4_t saturated_vec = float_vec;\n        saturated_vec = vmaxq_f32(saturated_vec, min_float);\n        saturated_vec = vminq_f32(saturated_vec, max_float);\n\n        vst1q_f32(B + i, saturated_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        float64x2_t double_vec = vld1q_f64(A + i);\n        float32x4_t float_vec = vcvtq_f32_f64(double_vec);\n\n        float32x4_t saturated_vec = vbslq_f32(vcltq_f32(float_vec, min_float), min_float, float_vec);\n        saturated_vec = vbslq_f32(vcgtq_f32(saturated_vec, max_float), max_float, saturated_vec);\n\n        vst1q_f32(B + i, saturated_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        float64x2_t double_vec = vld1q_f64(A + i);\n        float32x4_t float_vec = vcvtq_f32_f64(double_vec);\n\n        float32x4_t saturated_vec = vbslq_f32(vcgtq_f32(float_vec, max_float), max_float, float_vec);\n        saturated_vec = vbslq_f32(vcltq_f32(saturated_vec, min_float), min_float, saturated_vec);\n\n        vst1q_f32(B + i, saturated_vec);\n    }\n\n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        float64x2_t double_vec = vld1q_f64(A + i);\n        float32x4_t float_vec = vcvtq_f32_f64(double_vec);\n\n        float32x4_t saturated_vec = vbslq_f32(vcltq_f32(float_vec, min_float), min_float, float_vec);\n        saturated_vec = vbslq_f32(vcgtq_f32(saturated_vec, max_float), max_float, saturated_vec);\n\n        vst1q_f32(B + i, saturated_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t vec_A = vld1q_s16(A + i);\n        int32x4_t vec_B_low = vmovl_s16(vget_low_s16(vec_A));\n        int32x4_t vec_B_high = vmovl_s16(vget_high_s16(vec_A));\n        vst1q_s32(B + i, vec_B_low);\n        vst1q_s32(B + i + 4, vec_B_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t vec_A = vld1q_s16(A + i);\n        int32x4_t vec_B_low = vmovl_s16(vget_low_s16(vec_A));\n        int32x4_t vec_B_high = vmovl_s16(vget_high_s16(vec_A));\n        vst1q_s32(B + i, vec_B_low);\n        vst1q_s32(B + i + 4, vec_B_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t vec_A = vld1q_s16(A + i);\n        int32x4_t vec_B_low = vmovl_s16(vget_low_s16(vec_A));\n        int32x4_t vec_B_high = vmovl_s16(vget_high_s16(vec_A));\n        vst1q_s32(B + i, vec_B_low);\n        vst1q_s32(B + i + 4, vec_B_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with Neon (Advanced SIMD) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t vec_A = vld1q_s16(A + i);\n        int32x4_t vec_B_low = vmovl_s16(vget_low_s16(vec_A));\n        int32x4_t vec_B_high = vmovl_s16(vget_high_s16(vec_A));\n        vst1q_s32(B + i, vec_B_low);\n        vst1q_s32(B + i + 4, vec_B_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t vec_A = vld1q_s16(A + i);\n        int32x4_t vec_B_low = vmovl_s16(vget_low_s16(vec_A));\n        int32x4_t vec_B_high = vmovl_s16(vget_high_s16(vec_A));\n        vst1q_s32(B + i, vec_B_low);\n        vst1q_s32(B + i + 4, vec_B_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vdupq_n_f32(max_val - min_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        float32x4_t result_vec = A_vec;\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            float32x4_t temp_vec = vsubq_f32(A_vec, min_vec);\n            temp_vec = vdivq_f32(temp_vec, range_vec);\n            temp_vec = vmaxq_f32(temp_vec, zero_vec);\n            temp_vec = vminq_f32(temp_vec, one_vec);\n            result_vec = vbslq_f32(mask, temp_vec, A_vec);\n        }\n\n        vst1q_f32(B + i, result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vdupq_n_f32(max_val - min_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        float32x4_t result_vec;\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            float32x4_t temp_vec = vsubq_f32(A_vec, min_vec);\n            result_vec = vdivq_f32(temp_vec, range_vec);\n\n            result_vec = vmaxq_f32(result_vec, zero_vec);\n            result_vec = vminq_f32(result_vec, one_vec);\n\n            float32x4_t not_mask_f32 = vbslq_f32(vmvnq_u32(mask), vld1q_f32(A + i), result_vec);\n            vst1q_f32(B + i, not_mask_f32);\n        } else {\n            vst1q_f32(B + i, A_vec);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vdupq_n_f32(max_val - min_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            float32x4_t val_vec = vdivq_f32(vsubq_f32(A_vec, min_vec), range_vec);\n\n            val_vec = vmaxq_f32(val_vec, zero_vec);\n            val_vec = vminq_f32(val_vec, one_vec);\n\n            vst1q_f32(B + i, vbslq_f32(mask, val_vec, A_vec));\n        } else {\n            vst1q_f32(B + i, A_vec);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vdupq_n_f32(max_val - min_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            float32x4_t val_vec = vdivq_f32(vsubq_f32(A_vec, min_vec), range_vec);\n\n            val_vec = vmaxq_f32(val_vec, zero_vec);\n            val_vec = vminq_f32(val_vec, one_vec);\n\n            vst1q_f32(B + i, vbslq_f32(mask, val_vec, A_vec));\n        } else {\n            vst1q_f32(B + i, A_vec);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vdupq_n_f32(max_val - min_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            float32x4_t val_vec = vdivq_f32(vsubq_f32(A_vec, min_vec), range_vec);\n\n            val_vec = vmaxq_f32(val_vec, zero_vec);\n            val_vec = vminq_f32(val_vec, one_vec);\n\n            vst1q_f32(B + i, vbslq_f32(mask, val_vec, A_vec));\n        } else {\n            vst1q_f32(B + i, A_vec);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        uint32x4_t uint32_vec = vld1q_u32(A + i);\n        uint32x4_t uint32_high = vshrq_n_u32(uint32_vec, 16);\n        \n        float32x4_t float_vec = vcvtq_f32_u32(uint32_high);\n        float_vec = vsqrtq_f32(float_vec);\n        \n        vst1q_f32(B + i, float_vec);\n    }\n    \n    for (; i < size; ++i) {\n        uint32_t high = (A[i] >> 16) & 0xFFFF;\n        float float_val = (float)high;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        uint32x4_t uint32_values = vld1q_u32(A + i);\n        uint32x4_t uint32_high = vshrq_n_u32(uint32_values, 16);\n        \n        float32x4_t float_values = vcvtq_f32_u32(uint32_high);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        \n        vst1q_f32(B + i, sqrt_values);\n    }\n    \n    for (; i < size; ++i) {\n        uint32_t uint32_value = A[i];\n        uint32_t uint32_high = uint32_value >> 16;\n        \n        float float_value = (float)uint32_high;\n        float sqrt_value = sqrtf(float_value);\n        \n        B[i] = sqrt_value;\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t high_bits = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(B + i, sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        float32x4_t fvec = vreinterpretq_f32_u32(vec);\n        vst1q_f32(B + i, fvec);\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        float32x4_t fvec = vreinterpretq_f32_u32(vec);\n        vst1q_f32(B + i, fvec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size / 4 * 4; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(&A[i]);\n        float32x4_t b_vec = vreinterpretq_f32_u32(a_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        float32x4_t b_vec = vreinterpretq_f32_u32(a_vec);\n        vst1q_f32(B + i, b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a = vld1q_s32(A + i);\n        int32x4_t a_prev = vld1q_s32(A + i - 1);\n        uint32x4_t c = vld1q_u32((uint32_t*)(cond + i));\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(vreinterpretq_f32_u32(c), diff_float, zero);\n\n        vst1q_f32(diff + i, result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a = vld1q_s32(A + i);\n        int32x4_t a_prev = vld1q_s32(A + i - 1);\n        uint32x4_t c = vld1q_u32((uint32_t*)(cond + i));\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(vreinterpretq_f32_u32(c), diff_float, zero);\n\n        vst1q_f32(diff + i, result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a = vld1q_s32(A + i);\n        int32x4_t a_prev = vld1q_s32(A + i - 1);\n        uint32x4_t c = vld1q_u32((uint32_t*)(cond + i));\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(vreinterpretq_f32_u32(c), diff_float, zero);\n\n        vst1q_f32(diff + i, result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a = vld1q_s32(A + i);\n        int32x4_t a_prev = vld1q_s32(A + i - 1);\n        uint32x4_t c = vld1q_u32((uint32_t*)(cond + i));\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vceqq_u32(c, vdupq_n_u32(true));\n        float32x4_t result = vbslq_f32(mask, diff_float, zero);\n\n        vst1q_f32(diff + i, result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a = vld1q_s32(A + i);\n        int32x4_t a_prev = vld1q_s32(A + i - 1);\n        uint32x4_t c = vld1q_u32((uint32_t*)(cond + i));\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(vreinterpretq_f32_u32(c), diff_float, zero);\n\n        vst1q_f32(diff + i, result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint32x2_t vec_src = vld1_u32(src + i);\n        uint64x2_t vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        vst1q_u64(dst + i, vec_dst);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint32x2_t vec_src = vld1_u32(src + i);\n        uint64x2_t vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        vst1q_u64(dst + i, vec_dst);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint32x2_t vec_src = vld1_u32(src + i);\n        uint64x2_t vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        vst1q_u64(dst + i, vec_dst);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint32x2_t vec_src = vld1_u32(src + i);\n        uint64x2_t vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        vst1q_u64(dst + i, vec_dst);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint32x2_t vec_src = vld1_u32(src + i);\n        uint64x2_t vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, vdupq_n_u64(0xFFFFFFFF00000000));\n        vst1q_u64(dst + i, vec_dst);\n    }\n    for (; i < length; ++i) {\n        uint64_t val = (uint64_t)src[i];\n        val |= 0xFFFFFFFF00000000;\n        dst[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    if (length >= 4) {\n        float64x2_t sum_vec = vdupq_n_float64(0.0);\n\n        for (; i <= length - 4; i += 4) {\n            int16x4_t indices = vld1_s16(index + i);\n\n            // Check if indices are valid\n            int valid0 = (indices[0] >= 0 && indices[0] < length);\n            int valid1 = (indices[1] >= 0 && indices[1] < length);\n            int valid2 = (indices[2] >= 0 && indices[2] < length);\n            int valid3 = (indices[3] >= 0 && indices[3] < length);\n\n            double val0 = valid0 ? vec[indices[0]] : 0.0;\n            double val1 = valid1 ? vec[indices[1]] : 0.0;\n            double val2 = valid2 ? vec[indices[2]] : 0.0;\n            double val3 = valid3 ? vec[indices[3]] : 0.0;\n\n            float64x2_t vec1 = vld1q_dup_f64(&val0);\n            float64x2_t vec2 = vld1q_dup_f64(&val1);\n            float64x2_t vec3 = vld1q_dup_f64(&val2);\n            float64x2_t vec4 = vld1q_dup_f64(&val3);\n\n            sum_vec = vaddq_f64(sum_vec, vec1);\n            sum_vec = vaddq_f64(sum_vec, vec2);\n            sum_vec = vaddq_f64(sum_vec, vec3);\n            sum_vec = vaddq_f64(sum_vec, vec4);\n        }\n\n        sum += vgetq_lane_f64(sum_vec, 0);\n        sum += vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    if (length >= 4) {\n        float64x2_t sum_vec = vdupq_n_float64(0.0);\n\n        for (; i <= length - 4; i += 4) {\n            int16x4_t indices = vld1_s16(index + i);\n\n            int16_t index0 = vget_lane_s16(indices, 0);\n            int16_t index1 = vget_lane_s16(indices, 1);\n            int16_t index2 = vget_lane_s16(indices, 2);\n            int16_t index3 = vget_lane_s16(indices, 3);\n\n            if (index0 >= 0 && (size_t)index0 < length &&\n                index1 >= 0 && (size_t)index1 < length &&\n                index2 >= 0 && (size_t)index2 < length &&\n                index3 >= 0 && (size_t)index3 < length)\n            {\n                double val0 = vec[index0];\n                double val1 = vec[index1];\n                double val2 = vec[index2];\n                double val3 = vec[index3];\n\n                float64x2_t vec1 = vld1q_dup_f64(&val0);\n                float64x2_t vec2 = vld1q_dup_f64(&val1);\n                float64x2_t vec3 = vld1q_dup_f64(&val2);\n                float64x2_t vec4 = vld1q_dup_f64(&val3);\n\n                sum_vec = vaddq_f64(sum_vec, vec1);\n                sum_vec = vaddq_f64(sum_vec, vec2);\n                sum_vec = vaddq_f64(sum_vec, vec3);\n                sum_vec = vaddq_f64(sum_vec, vec4);\n            }\n        }\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    if (length >= 4) {\n        float64x2_t sum_vec = vdupq_n_float64(0.0);\n\n        for (; i <= length - 4; i += 4) {\n            int16x4_t indices = vld1_s16(index + i);\n\n            int16_t index0 = vget_lane_s16(indices, 0);\n            int16_t index1 = vget_lane_s16(indices, 1);\n            int16_t index2 = vget_lane_s16(indices, 2);\n            int16_t index3 = vget_lane_s16(indices, 3);\n\n            double val0 = (index0 >= 0 && index0 < length) ? vec[index0] : 0.0;\n            double val1 = (index1 >= 0 && index1 < length) ? vec[index1] : 0.0;\n            double val2 = (index2 >= 0 && index2 < length) ? vec[index2] : 0.0;\n            double val3 = (index3 >= 0 && index3 < length) ? vec[index3] : 0.0;\n\n            float64x2_t val_vec1 = vcreate_float64(val0);\n            float64x2_t val_vec2 = vcreate_float64(val1);\n            float64x2_t val_vec3 = vcreate_float64(val2);\n            float64x2_t val_vec4 = vcreate_float64(val3);\n\n            sum_vec = vaddq_f64(sum_vec, val_vec1);\n            sum_vec = vaddq_f64(sum_vec, val_vec2);\n            sum_vec = vaddq_f64(sum_vec, val_vec3);\n            sum_vec = vaddq_f64(sum_vec, val_vec4);\n        }\n\n        sum += vgetq_lane_f64(sum_vec, 0);\n        sum += vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    if (length >= 4) {\n        float64x2_t sum_vec = vdupq_n_float64(0.0);\n\n        for (; i <= length - 4; i += 4) {\n            int16x4_t indices = vld1_s16(index + i);\n\n            int16_t index0 = vget_lane_s16(indices, 0);\n            int16_t index1 = vget_lane_s16(indices, 1);\n            int16_t index2 = vget_lane_s16(indices, 2);\n            int16_t index3 = vget_lane_s16(indices, 3);\n\n            if (index0 >= 0 && (size_t)index0 < length &&\n                index1 >= 0 && (size_t)index1 < length &&\n                index2 >= 0 && (size_t)index2 < length &&\n                index3 >= 0 && (size_t)index3 < length) {\n\n                double val0 = vec[index0];\n                double val1 = vec[index1];\n                double val2 = vec[index2];\n                double val3 = vec[index3];\n\n                float64x2_t val_vec1 = vld1q_dup_f64(&val0);\n                float64x2_t val_vec2 = vld1q_dup_f64(&val2);\n\n                sum_vec = vaddq_f64(sum_vec, val_vec1);\n                sum_vec = vaddq_f64(sum_vec, val_vec2);\n                \n                val_vec1 = vld1q_dup_f64(&val1);\n                val_vec2 = vld1q_dup_f64(&val3);\n                \n                sum_vec = vaddq_f64(sum_vec, val_vec1);\n                sum_vec = vaddq_f64(sum_vec, val_vec2);\n            }\n        }\n\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    if (length >= 4) {\n        float64x2_t sum_vec = vdupq_n_float64(0.0);\n\n        for (; i <= length - 4; i += 4) {\n            int16x4_t indices = vld1_s16(index + i);\n\n            int16_t index0 = vget_lane_s16(indices, 0);\n            int16_t index1 = vget_lane_s16(indices, 1);\n            int16_t index2 = vget_lane_s16(indices, 2);\n            int16_t index3 = vget_lane_s16(indices, 3);\n\n            if (index0 >= 0 && (size_t)index0 < length &&\n                index1 >= 0 && (size_t)index1 < length &&\n                index2 >= 0 && (size_t)index2 < length &&\n                index3 >= 0 && (size_t)index3 < length) {\n\n                double val0 = vec[index0];\n                double val1 = vec[index1];\n                double val2 = vec[index2];\n                double val3 = vec[index3];\n\n                float64x2_t val_vec1 = vld1q_dup_f64(&val0);\n                float64x2_t val_vec2 = vld1q_dup_f64(&val2);\n\n                sum_vec = vaddq_f64(sum_vec, val_vec1);\n                sum_vec = vaddq_f64(sum_vec, val_vec2);\n\n                val_vec1 = vld1q_dup_f64(&val1);\n                val_vec2 = vld1q_dup_f64(&val3);\n\n                sum_vec = vaddq_f64(sum_vec, val_vec1);\n                sum_vec = vaddq_f64(sum_vec, val_vec2);\n            }\n        }\n\n        sum += vgetq_lane_f64(sum_vec, 0);\n        sum += vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    \n    int size = numbers.size();\n    int i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n\n    for (i = 0; i < size - 1; ++i) {\n        for (int j = i + 1; j < size; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    \n    int n = numbers.size();\n    int i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n\n    for (i = 0; i <= n - 2; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    \n    int n = numbers.size();\n    int i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n\n    for (i = 0; i <= n - 2; ++i) {\n        for(int j = i + 1; j < n; ++j){\n            if(abs(numbers[i] - numbers[j]) < threshold){\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    int n = numbers.size();\n    int i = 0;\n    for (; i < n - 3; i += 4) {\n        float64x2_t v1 = vld1q_f64(&numbers[i]);\n        for (int j = i + 1; j < n; ++j) {\n            float64x2_t v2 = vdupq_n_f64(numbers[j]);\n            float64x2_t diff = vabdq_f64(v1, v2);\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n    }\n    for (; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    int n = numbers.size();\n    int i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_float64(threshold);\n\n    for (i = 0; i <= n - 2; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (size_t i = 0; i + 3 < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        int32x4_t bal = vdupq_n_s32(balance);\n        bal = vaddq_s32(bal, ops);\n\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t below = vcltq_s32(bal, zero);\n\n        if (vgetq_lane_u32(below, 0) || vgetq_lane_u32(below, 1) ||\n            vgetq_lane_u32(below, 2) || vgetq_lane_u32(below, 3)) {\n            return true;\n        }\n\n        balance += operations[i] + operations[i + 1] + operations[i + 2] + operations[i + 3];\n    }\n\n    for (size_t i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (size_t i = 0; i + 3 < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        int32x4_t bal = vdupq_n_s32(balance);\n        bal = vaddq_s32(bal, ops);\n\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t below = vcltq_s32(bal, zero);\n\n        if (vgetq_lane_u32(below, 0) || vgetq_lane_u32(below, 1) ||\n            vgetq_lane_u32(below, 2) || vgetq_lane_u32(below, 3)) {\n            return true;\n        }\n\n        balance += operations[i] + operations[i + 1] + operations[i + 2] + operations[i + 3];\n    }\n\n    for (size_t i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (size_t i = 0; i + 3 < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        int32x4_t bal = vdupq_n_s32(balance);\n        bal = vaddq_s32(bal, ops);\n\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t below = vcgeq_s32(bal, zero);\n        uint32_t result = vgetq_lane_u32(below, 0) & vgetq_lane_u32(below, 1) &\n                          vgetq_lane_u32(below, 2) & vgetq_lane_u32(below, 3);\n\n        if (result == 0) {\n            for(int j = 0; j < 4; ++j){\n                if(balance + operations[i+j] < 0){\n                    return true;\n                }\n                balance += operations[i+j];\n            }\n            return true;\n        }\n        balance = vgetq_lane_s32(bal, 3);\n    }\n    for (size_t i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int n = operations.size();\n    int i = 0;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        int32x4_t bal = vdupq_n_s32(balance);\n        bal = vaddq_s32(bal, ops);\n\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t below = vcltq_s32(bal, zero);\n\n        if (vgetq_lane_u32(below, 0) || vgetq_lane_u32(below, 1) ||\n            vgetq_lane_u32(below, 2) || vgetq_lane_u32(below, 3)) {\n            return true;\n        }\n\n        balance = operations[i+3] + operations[i+2] + operations[i+1] + operations[i] + balance;\n    }\n\n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (size_t i = 0; i + 3 < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        int32x4_t bal = vdupq_n_s32(balance);\n        bal = vaddq_s32(bal, ops);\n\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t below = vcltq_s32(bal, zero);\n\n        if (vgetq_lane_u32(below, 0) || vgetq_lane_u32(below, 1) ||\n            vgetq_lane_u32(below, 2) || vgetq_lane_u32(below, 3)) {\n            return true;\n        }\n\n        balance += operations[i] + operations[i + 1] + operations[i + 2] + operations[i + 3];\n    }\n\n    for (size_t i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    int size = numbers.size();\n    int i = 0;\n    double mad_sum = 0.0;\n\n    if (size >= 4) {\n        int loop_end = size - (size % 4);\n        float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n\n        for (; i < loop_end; i += 2) {\n            float64x2_t data_vec = vld1q_f64(&numbers[i]);\n            float64x2_t diff_vec = vsubq_f64(data_vec, mean_vec);\n            float64x2_t abs_diff_vec = vabsq_f64(diff_vec);\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec);\n        }\n        mad_sum += vgetq_lane_f64(mad_sum_vec, 0);\n        mad_sum += vgetq_lane_f64(mad_sum_vec, 1);\n    }\n\n    for (; i < size; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        size_t i = 0;\n        float64x2_t mad_sum_vec = vdupq_n_float64(0.0);\n        float64x2_t mean_vec = vdupq_n_float64(mean);\n\n        for (; i + 3 < size; i += 4) {\n            float64x2_t num_vec1 = vld1q_f64(&numbers[i]);\n            float64x2_t num_vec2 = vld1q_f64(&numbers[i + 2]);\n\n            float64x2_t diff_vec1 = vsubq_f64(num_vec1, mean_vec);\n            float64x2_t diff_vec2 = vsubq_f64(num_vec2, mean_vec);\n\n            float64x2_t abs_diff_vec1 = vabsq_f64(diff_vec1);\n            float64x2_t abs_diff_vec2 = vabsq_f64(diff_vec2);\n\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec1);\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec2);\n        }\n\n        double temp_arr[2];\n        vst1q_f64(temp_arr, mad_sum_vec);\n        mad_sum = temp_arr[0] + temp_arr[1];\n\n        for (; i < size; ++i) {\n            mad_sum += std::abs(numbers[i] - mean);\n        }\n    } else {\n        for (double number : numbers) {\n            mad_sum += std::abs(number - mean);\n        }\n    }\n\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    int size = numbers.size();\n    int aligned_size = size - (size % 2);\n    double abs_sum = 0.0;\n\n    for (int i = 0; i < aligned_size; i += 2) {\n        float64x2_t data = vld1q_f64(&numbers[i]);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n        float64x2_t diff = vsubq_f64(data, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_sum += vgetq_lane_f64(abs_diff, 0) + vgetq_lane_f64(abs_diff, 1);\n    }\n\n    for (int i = aligned_size; i < size; ++i) {\n        abs_sum += std::abs(numbers[i] - mean);\n    }\n\n    return abs_sum / size;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        size_t i = 0;\n        float64x2_t mad_sum_vec = vdupq_n_float64(0.0);\n        float64x2_t mean_vec = vdupq_n_float64(mean);\n\n        for (; i + 3 < size; i += 4) {\n            float64x2_t num_vec1 = vld1q_f64(&numbers[i]);\n            float64x2_t num_vec2 = vld1q_f64(&numbers[i + 2]);\n\n            float64x2_t diff_vec1 = vsubq_f64(num_vec1, mean_vec);\n            float64x2_t diff_vec2 = vsubq_f64(num_vec2, mean_vec);\n\n            float64x2_t abs_diff_vec1 = vabsq_f64(diff_vec1);\n            float64x2_t abs_diff_vec2 = vabsq_f64(diff_vec2);\n\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec1);\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec2);\n        }\n\n        double temp_mad_sum[2];\n        vst1q_f64(temp_mad_sum, mad_sum_vec);\n        mad_sum = temp_mad_sum[0] + temp_mad_sum[1];\n\n        for (; i < size; ++i) {\n            mad_sum += std::abs(numbers[i] - mean);\n        }\n    } else {\n        for (double number : numbers) {\n            mad_sum += std::abs(number - mean);\n        }\n    }\n\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        size_t i = 0;\n        float64x2_t mad_sum_vec = vdupq_n_float64(0.0);\n        float64x2_t mean_vec = vdupq_n_float64(mean);\n\n        for (; i <= size - 4; i += 2) {\n            float64x2_t data_vec = vld1q_f64(&numbers[i]);\n            float64x2_t diff_vec = vsubq_f64(data_vec, mean_vec);\n            float64x2_t abs_diff_vec = vabsq_f64(diff_vec);\n            mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec);\n        }\n        \n        double temp_arr[2];\n        vst1q_f64(temp_arr, mad_sum_vec);\n        mad_sum = temp_arr[0] + temp_arr[1];\n\n        for (; i < size; ++i) {\n            mad_sum += std::abs(numbers[i] - mean);\n        }\n    } else {\n        for (double number : numbers) {\n            mad_sum += std::abs(number - mean);\n        }\n    }\n\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    result.reserve(2 * n - 1);\n\n    for (int i = 0; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    result.reserve(2 * n - 1);\n\n    for (int i = 0; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int len = numbers.size();\n    int i = 0;\n\n    if (len >= 8) {\n        int num_vectors = len / 8;\n\n        int64x2_t sum_vec = vdupq_n_s64(0);\n        int64x2_t prod_vec = vdupq_n_s64(1);\n\n        for (int j = 0; j < num_vectors; ++j) {\n            int16x8_t vec = vld1q_s16(&numbers[i]);\n\n            int32x4_t vec_low = vmovl_s16(vget_low_s16(vec));\n            int32x4_t vec_high = vmovl_s16(vget_high_s16(vec));\n\n            int64x2_t vec_low_low = vmovl_s32(vget_low_s32(vec_low));\n            int64x2_t vec_low_high = vmovl_s32(vget_high_s32(vec_low));\n            int64x2_t vec_high_low = vmovl_s32(vget_low_s32(vec_high));\n            int64x2_t vec_high_high = vmovl_s32(vget_high_s32(vec_high));\n\n            sum_vec = vaddq_s64(sum_vec, vec_low_low);\n            sum_vec = vaddq_s64(sum_vec, vec_low_high);\n            sum_vec = vaddq_s64(sum_vec, vec_high_low);\n            sum_vec = vaddq_s64(sum_vec, vec_high_high);\n\n            prod_vec = vmulq_s64(prod_vec, vec_low_low);\n            prod_vec = vmulq_s64(prod_vec, vec_low_high);\n            prod_vec = vmulq_s64(prod_vec, vec_high_low);\n            prod_vec = vmulq_s64(prod_vec, vec_high_high);\n\n            i += 8;\n        }\n\n        int64_t sum_arr[2];\n        int64_t prod_arr[2];\n        vst1q_s64(sum_arr, sum_vec);\n        vst1q_s64(prod_arr, prod_vec);\n\n        sum = sum_arr[0] + sum_arr[1];\n        product = prod_arr[0] * prod_arr[1];\n    }\n\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int len = numbers.size();\n    int i = 0;\n\n    if (len >= 8) {\n        int num_vectors = len / 8;\n\n        int64x2_t sum_vec = vdupq_n_s64(0);\n        int64x2_t prod_vec = vdupq_n_s64(1);\n\n        for (int j = 0; j < num_vectors; ++j) {\n            int16x8_t vec = vld1q_s16(numbers.data() + i);\n\n            int32x4_t vec_low = vmovl_s16(vget_low_s16(vec));\n            int32x4_t vec_high = vmovl_s16(vget_high_s16(vec));\n\n            int64x2_t vec_low_low = vmovl_s32(vget_low_s32(vec_low));\n            int64x2_t vec_low_high = vmovl_s32(vget_high_s32(vec_low));\n            int64x2_t vec_high_low = vmovl_s32(vget_low_s32(vec_high));\n            int64x2_t vec_high_high = vmovl_s32(vget_high_s32(vec_high));\n\n            sum_vec = vaddq_s64(sum_vec, vec_low_low);\n            sum_vec = vaddq_s64(sum_vec, vec_low_high);\n            sum_vec = vaddq_s64(sum_vec, vec_high_low);\n            sum_vec = vaddq_s64(sum_vec, vec_high_high);\n\n            prod_vec = vmulq_s64(prod_vec, vec_low_low);\n            prod_vec = vmulq_s64(prod_vec, vec_low_high);\n            prod_vec = vmulq_s64(prod_vec, vec_high_low);\n            prod_vec = vmulq_s64(prod_vec, vec_high_high);\n\n            i += 8;\n        }\n\n        int64_t sum_arr[2];\n        int64_t prod_arr[2];\n        vst1q_s64(sum_arr, sum_vec);\n        vst1q_s64(prod_arr, prod_vec);\n\n        sum = sum_arr[0] + sum_arr[1];\n        product = prod_arr[0] * prod_arr[1];\n    }\n\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        int loop_end = size - (size % 8);\n\n        int16x8_t sum_vec = vdupq_n_s16(0);\n        int16x8_t prod_vec = vdupq_n_s16(1);\n\n        for (i = 0; i < loop_end; i += 8) {\n            int16x8_t data_vec = vld1q_s16(&numbers[i]);\n            sum_vec = vaddq_s16(sum_vec, data_vec);\n            prod_vec = vmulq_s16(prod_vec, data_vec);\n        }\n\n        int32x4_t sum_long_vec1 = vmovl_s16(vget_low_s16(sum_vec));\n        int32x4_t sum_long_vec2 = vmovl_s16(vget_high_s16(sum_vec));\n        int32x4_t prod_long_vec1 = vmovl_s16(vget_low_s16(prod_vec));\n        int32x4_t prod_long_vec2 = vmovl_s16(vget_high_s16(prod_vec));\n\n        int64x2_t sum_long_long_vec1 = vmovl_s32(vget_low_s32(sum_long_vec1));\n        int64x2_t sum_long_long_vec2 = vmovl_s32(vget_high_s32(sum_long_vec1));\n        int64x2_t sum_long_long_vec3 = vmovl_s32(vget_low_s32(sum_long_vec2));\n        int64x2_t sum_long_long_vec4 = vmovl_s32(vget_high_s32(sum_long_vec2));\n\n        int64x2_t prod_long_long_vec1 = vmovl_s32(vget_low_s32(prod_long_vec1));\n        int64x2_t prod_long_long_vec2 = vmovl_s32(vget_high_s32(prod_long_vec1));\n        int64x2_t prod_long_long_vec3 = vmovl_s32(vget_low_s32(prod_long_vec2));\n        int64x2_t prod_long_long_vec4 = vmovl_s32(vget_high_s32(prod_long_vec2));\n\n        sum += vgetq_lane_s64(sum_long_long_vec1, 0);\n        sum += vgetq_lane_s64(sum_long_long_vec1, 1);\n        sum += vgetq_lane_s64(sum_long_long_vec2, 0);\n        sum += vgetq_lane_s64(sum_long_long_vec2, 1);\n        sum += vgetq_lane_s64(sum_long_long_vec3, 0);\n        sum += vgetq_lane_s64(sum_long_long_vec3, 1);\n        sum += vgetq_lane_s64(sum_long_long_vec4, 0);\n        sum += vgetq_lane_s64(sum_long_long_vec4, 1);\n\n        product *= vgetq_lane_s64(prod_long_long_vec1, 0);\n        product *= vgetq_lane_s64(prod_long_long_vec1, 1);\n        product *= vgetq_lane_s64(prod_long_long_vec2, 0);\n        product *= vgetq_lane_s64(prod_long_long_vec2, 1);\n        product *= vgetq_lane_s64(prod_long_long_vec3, 0);\n        product *= vgetq_lane_s64(prod_long_long_vec3, 1);\n        product *= vgetq_lane_s64(prod_long_long_vec4, 0);\n        product *= vgetq_lane_s64(prod_long_long_vec4, 1);\n    }\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int len = numbers.size();\n    int i = 0;\n\n    if (len >= 8) {\n        int num_vectors = len / 8;\n\n        int64x2_t sum_vec = vdupq_n_s64(0);\n        int64x2_t product_vec = vdupq_n_s64(1);\n\n        for (int j = 0; j < num_vectors; ++j) {\n            int16x8_t vec = vld1q_s16(numbers.data() + i);\n\n            int32x4_t vec_low = vmovl_s16(vget_low_s16(vec));\n            int32x4_t vec_high = vmovl_s16(vget_high_s16(vec));\n\n            int64x2_t vec_low_low = vmovl_s32(vget_low_s32(vec_low));\n            int64x2_t vec_low_high = vmovl_s32(vget_high_s32(vec_low));\n            int64x2_t vec_high_low = vmovl_s32(vget_low_s32(vec_high));\n            int64x2_t vec_high_high = vmovl_s32(vget_high_s32(vec_high));\n\n            sum_vec = vaddq_s64(sum_vec, vec_low_low);\n            sum_vec = vaddq_s64(sum_vec, vec_low_high);\n            sum_vec = vaddq_s64(sum_vec, vec_high_low);\n            sum_vec = vaddq_s64(sum_vec, vec_high_high);\n\n            product_vec = vmulq_s64(product_vec, vec_low_low);\n            product_vec = vmulq_s64(product_vec, vec_low_high);\n            product_vec = vmulq_s64(product_vec, vec_high_low);\n            product_vec = vmulq_s64(product_vec, vec_high_high);\n\n            i += 8;\n        }\n\n        int64_t sum_arr[2];\n        int64_t product_arr[2];\n        vst1q_s64(sum_arr, sum_vec);\n        vst1q_s64(product_arr, product_vec);\n\n        sum = sum_arr[0] + sum_arr[1];\n        product = product_arr[0] * product_arr[1];\n    }\n\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int len = numbers.size();\n    int i = 0;\n\n    if (len >= 8) {\n        int num_vectors = len / 8;\n\n        int64x2_t sum_vec = vdupq_n_s64(0);\n        int64x2_t prod_vec = vdupq_n_s64(1);\n\n        for (int j = 0; j < num_vectors; ++j) {\n            int16x8_t vec = vld1q_s16(numbers.data() + i);\n\n            int32x4_t vec_low = vmovl_s16(vget_low_s16(vec));\n            int32x4_t vec_high = vmovl_s16(vget_high_s16(vec));\n\n            int64x2_t vec_low_low = vmovl_s32(vget_low_s32(vec_low));\n            int64x2_t vec_low_high = vmovl_s32(vget_high_s32(vec_low));\n            int64x2_t vec_high_low = vmovl_s32(vget_low_s32(vec_high));\n            int64x2_t vec_high_high = vmovl_s32(vget_high_s32(vec_high));\n\n            sum_vec = vaddq_s64(sum_vec, vec_low_low);\n            sum_vec = vaddq_s64(sum_vec, vec_low_high);\n            sum_vec = vaddq_s64(sum_vec, vec_high_low);\n            sum_vec = vaddq_s64(sum_vec, vec_high_high);\n\n            prod_vec = vmulq_s64(prod_vec, vec_low_low);\n            prod_vec = vmulq_s64(prod_vec, vec_low_high);\n            prod_vec = vmulq_s64(prod_vec, vec_high_low);\n            prod_vec = vmulq_s64(prod_vec, vec_high_high);\n\n            i += 8;\n        }\n\n        int64_t sum_arr[2];\n        int64_t prod_arr[2];\n        vst1q_s64(sum_arr, sum_vec);\n        vst1q_s64(prod_arr, prod_vec);\n\n        sum = sum_arr[0] + sum_arr[1];\n        product = prod_arr[0] * prod_arr[1];\n    }\n\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    int i = 1;\n\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    int i = 1;\n\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    int i = 1;\n\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    int i = 1;\n\n    if (n >= 4) {\n        for (; i < 4; ++i) {\n            result[i] = std::max(result[i], result[i - 1]);\n        }\n\n        for (; i + 3 < n; i += 4) {\n            int32x4_t current = vld1q_s32(&result[i]);\n            int max_val = std::max({result[i - 1], result[i - 2], result[i - 3], result[i - 4]});\n            int32x4_t max_vec = vdupq_n_s32(max_val);\n            int32x4_t rolling_max = vmaxq_s32(current, max_vec);\n            vst1q_s32(&result[i], rolling_max);\n\n            result[i] = std::max(result[i], result[i - 1]);\n            result[i + 1] = std::max(result[i + 1], result[i]);\n            result[i + 2] = std::max(result[i + 2], result[i + 1]);\n            result[i + 3] = std::max(result[i + 3], result[i + 2]);\n        }\n    }\n\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int n = numbers.size();\n    int i = 1;\n\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)(b.data() + i));\n        uint8x16_t vec_xor = veorq_u8(vec_a, vec_b);\n        uint8_t xor_result[16];\n        vst1q_u8(xor_result, vec_xor);\n        for (int j = 0; j < 16; ++j) {\n            result += (xor_result[j] == '0' ? '0' : '1');\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] == b[i]) ? '0' : '1');\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)(b.data() + i));\n        uint8x16_t vec_xor = veorq_u8(vec_a, vec_b);\n        uint8_t temp_res[16];\n        vst1q_u8(temp_res, vec_xor);\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_res[j] - '0' == 1) ? '1' : '0';\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        uint8_t temp_result[16];\n        vst1q_u8(temp_result, vec_result);\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] == '1' ? '1' : '0');\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        uint8_t temp_result[16];\n        vst1q_u8(temp_result, vec_result);\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] == '1' ? '1' : '0');\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        uint8_t res[16];\n        vst1q_u8(res, vec_result);\n        for (int j = 0; j < 16; ++j) {\n            result += (res[j] - '0' + 0) + '0';\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = \"\";\n    size_t max_len = 0;\n\n    for (const auto& str : strings) {\n        if (str.length() > max_len) {\n            max_len = str.length();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = \"\";\n    size_t max_length = 0;\n\n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = \"\";\n    size_t max_length = 0;\n\n    for (const auto& str : strings) {\n        if (str.length() > max_length) {\n            max_length = str.length();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = \"\";\n    size_t max_len = 0;\n\n    for (const auto& str : strings) {\n        if (str.length() > max_len) {\n            max_len = str.length();\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        size_t current_len = strings[i].length();\n        if (current_len > max_len) {\n            max_len = current_len;\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <limits>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t vector_size = numbers.size();\n    size_t loop_count = vector_size / 4;\n    size_t remainder = vector_size % 4;\n\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t range_vec = vdupq_n_f32(range);\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        float32x4_t data_vec = vld1q_f32(&numbers[i * 4]);\n        float32x4_t sub_vec = vsubq_f32(data_vec, min_vec);\n        float32x4_t result_vec = vdivq_f32(sub_vec, range_vec);\n        vst1q_f32(&numbers[i * 4], result_vec);\n    }\n\n    for (size_t i = vector_size - remainder; i < vector_size; ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t vector_size = numbers.size();\n    size_t loop_count = vector_size / 4;\n    size_t remainder = vector_size % 4;\n\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t range_vec = vdupq_n_f32(range);\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        float32x4_t data_vec = vld1q_f32(&numbers[i * 4]);\n        float32x4_t sub_vec = vsubq_f32(data_vec, min_vec);\n        float32x4_t result_vec = vdivq_f32(sub_vec, range_vec);\n        vst1q_f32(&numbers[i * 4], result_vec);\n    }\n\n    for (size_t i = vector_size - remainder; i < vector_size; ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t vector_size = numbers.size();\n    size_t i = 0;\n\n    for (; i + 3 < vector_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t min_vec = vdupq_n_f32(min_val);\n        float32x4_t range_vec = vdupq_n_f32(range);\n\n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range_vec);\n\n        vst1q_f32(&numbers[i], vec);\n    }\n\n    for (; i < vector_size; ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t vector_size = numbers.size();\n    size_t i = 0;\n\n    for (; i + 3 < vector_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t min_vec = vdupq_n_f32(min_val);\n        float32x4_t range_vec = vdupq_n_f32(range);\n\n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range_vec);\n\n        vst1q_f32(&numbers[i], vec);\n    }\n\n    for (; i < vector_size; ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t vector_size = numbers.size();\n    size_t i = 0;\n\n    for (; i + 3 < vector_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t min_vec = vdupq_n_f32(min_val);\n        float32x4_t range_vec = vdupq_n_f32(range);\n\n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range_vec);\n\n        vst1q_f32(&numbers[i], vec);\n    }\n\n    for (; i < vector_size; ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t i;\n    for (i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n    if (n % 2 == 0) return n / 2;\n\n    uint64_t i;\n    for (i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t i;\n    for (i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n    if (n % 2 == 0) return n / 2;\n\n    uint64_t i;\n    for (i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t i;\n    for (i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        // Extract the positive numbers using the mask\n        if (vgetq_lane_u32(mask, 0)) result.push_back(l[i]);\n        if (vgetq_lane_u32(mask, 1)) result.push_back(l[i+1]);\n        if (vgetq_lane_u32(mask, 2)) result.push_back(l[i+2]);\n        if (vgetq_lane_u32(mask, 3)) result.push_back(l[i+3]);\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        // Extract positive numbers using the mask\n        if (vgetq_lane_u32(mask, 0)) result.push_back(l[i]);\n        if (vgetq_lane_u32(mask, 1)) result.push_back(l[i+1]);\n        if (vgetq_lane_u32(mask, 2)) result.push_back(l[i+2]);\n        if (vgetq_lane_u32(mask, 3)) result.push_back(l[i+3]);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        // Extract the positive numbers\n        if (vgetq_lane_u32(mask, 0)) result.push_back(l[i + 0]);\n        if (vgetq_lane_u32(mask, 1)) result.push_back(l[i + 1]);\n        if (vgetq_lane_u32(mask, 2)) result.push_back(l[i + 2]);\n        if (vgetq_lane_u32(mask, 3)) result.push_back(l[i + 3]);\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        // Extract the positive numbers using the mask\n        if (vgetq_lane_u32(mask, 0)) result.push_back(l[i]);\n        if (vgetq_lane_u32(mask, 1)) result.push_back(l[i+1]);\n        if (vgetq_lane_u32(mask, 2)) result.push_back(l[i+2]);\n        if (vgetq_lane_u32(mask, 3)) result.push_back(l[i+3]);\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero); // Create a mask where vec > 0\n\n        // Extract elements based on the mask\n        if (vgetq_lane_u32(mask, 0)) result.push_back(l[i + 0]);\n        if (vgetq_lane_u32(mask, 1)) result.push_back(l[i + 1]);\n        if (vgetq_lane_u32(mask, 2)) result.push_back(l[i + 2]);\n        if (vgetq_lane_u32(mask, 3)) result.push_back(l[i + 3]);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = std::sqrt(n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = std::sqrt(n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = std::sqrt(n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = std::sqrt(n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = std::sqrt(n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int len = s.length();\n    bool hasLetters = false;\n\n    for (int i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgtq_u8(chars, vdupq_n_u8('z'));\n        uint8x16_t lower_mask2 = vcltq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t upper_mask2 = vcgtq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t letter_mask = vorrq_u8(veorq_u8(lower_mask, upper_mask), veorq_u8(lower_mask2, upper_mask2));\n\n        uint8x16_t case_change = veorq_u8(letter_mask, vdupq_n_u8(32));\n        uint8x16_t new_chars = veorq_u8(chars, case_change);\n        vst1q_u8((uint8_t*)&result[i], new_chars);\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int len = s.length();\n    int i = 0;\n    bool has_letter = false;\n\n    if (len == 0) return result;\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t str = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t lower = vcltq_u8(str, vdupq_n_u8('a'));\n        uint8x16_t upper = vcgtq_u8(str, vdupq_n_u8('z'));\n        uint8x16_t not_letter = vorrq_u8(lower, upper);\n        uint8x16_t letter = vmvnq_u8(not_letter);\n\n        uint8x16_t a_to_z = vandq_u8(vcleq_u8(str, vdupq_n_u8('z')), vcgeq_u8(str, vdupq_n_u8('a')));\n        uint8x16_t A_to_Z = vandq_u8(vcleq_u8(str, vdupq_n_u8('Z')), vcgeq_u8(str, vdupq_n_u8('A')));\n        uint8x16_t is_lower = vandq_u8(a_to_z, letter);\n        uint8x16_t is_upper = vandq_u8(A_to_Z, letter);\n\n        has_letter |= (vmaxvq_u8(letter) != 0);\n\n        uint8x16_t lower_to_upper = vsubq_u8(str, vdupq_n_u8(32));\n        uint8x16_t upper_to_lower = vaddq_u8(str, vdupq_n_u8(32));\n\n        uint8x16_t temp1 = vbslq_u8(is_lower, lower_to_upper, str);\n        uint8x16_t final_str = vbslq_u8(is_upper, upper_to_lower, temp1);\n\n        vst1q_u8((uint8_t*)&result[i], final_str);\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int len = s.length();\n    int i = 0;\n    bool has_letter = false;\n\n    if (len == 0) return result;\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t str = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t lower = vcltq_u8(str, vdupq_n_u8('a'));\n        uint8x16_t upper = vcgtq_u8(str, vdupq_n_u8('z'));\n        uint8x16_t lower2 = vcltq_u8(str, vdupq_n_u8('A'));\n        uint8x16_t upper2 = vcgtq_u8(str, vdupq_n_u8('Z'));\n\n        uint8x16_t is_letter = vorrq_u8(vorrq_u8(lower, upper), vorrq_u8(lower2, upper2));\n        uint8x16_t letter_mask = vmvnq_u8(is_letter);\n\n        uint8x16_t a_to_z = vandq_u8(vcgeq_u8(str, vdupq_n_u8('a')), vcleq_u8(str, vdupq_n_u8('z')));\n        uint8x16_t A_to_Z = vandq_u8(vcgeq_u8(str, vdupq_n_u8('A')), vcleq_u8(str, vdupq_n_u8('Z')));\n\n        uint8x16_t lower_to_upper_mask = vandq_u8(a_to_z, letter_mask);\n        uint8x16_t upper_to_lower_mask = vandq_u8(A_to_Z, letter_mask);\n\n        uint8x16_t lower_to_upper = vsubq_u8(str, vandq_u8(lower_to_upper_mask, vdupq_n_u8(32)));\n        uint8x16_t upper_to_lower = vaddq_u8(str, vandq_u8(upper_to_lower_mask, vdupq_n_u8(32)));\n\n        uint8x16_t changed_chars = vorrq_u8(vandq_u8(lower_to_upper_mask, lower_to_upper), vandq_u8(upper_to_lower_mask, upper_to_lower));\n        uint8x16_t unchanged_chars = vandq_u8(vmvnq_u8(vorrq_u8(lower_to_upper_mask, upper_to_lower_mask)), str);\n\n        uint8x16_t final_chars = vorrq_u8(changed_chars, unchanged_chars);\n\n        vst1q_u8((uint8_t*)&result[i], final_chars);\n\n        if (vmaxvq_u8(is_letter) > 0) {\n            has_letter = true;\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int len = s.length();\n    int i = 0;\n    bool has_letter = false;\n\n    if (len == 0) return result;\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t str = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t lower = vcltq_u8(str, vdupq_n_u8('a'));\n        uint8x16_t upper = vcgtq_u8(str, vdupq_n_u8('z'));\n        uint8x16_t not_letter = vorrq_u8(lower, upper);\n        uint8x16_t letter = vmvnq_u8(not_letter);\n\n        uint8x16_t a_to_z = vandq_u8(str, vdupq_n_u8(0x20));\n        uint8x16_t change_case = veorq_u8(str, a_to_z);\n        uint8x16_t final_str = vbslq_u8(letter, change_case, str);\n\n        vst1q_u8((uint8_t*)&result[i], final_str);\n\n        uint64x2_t tmp = vpmaxq_u8(letter, letter);\n        if (vgetq_lane_u64(vreinterpretq_u64_u8(tmp), 0) != 0 || vgetq_lane_u64(vreinterpretq_u64_u8(tmp), 1) != 0)\n        {\n            has_letter = true;\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int len = s.length();\n    int i = 0;\n    bool has_letter = false;\n\n    if (len == 0) return result;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t str = vld1q_u8((const uint8_t*)(s.data() + i));\n        uint8x16_t lower = vcltq_u8(str, vdupq_n_u8('a'));\n        uint8x16_t upper = vcgtq_u8(str, vdupq_n_u8('z'));\n        uint8x16_t lower_upper = vorrq_u8(lower, upper);\n        uint8x16_t A_lower = vcltq_u8(str, vdupq_n_u8('A'));\n        uint8x16_t A_upper = vcgtq_u8(str, vdupq_n_u8('Z'));\n        uint8x16_t A_lower_upper = vorrq_u8(A_lower, A_upper);\n        uint8x16_t is_letter = veorq_u8(lower_upper, A_lower_upper);\n\n        uint8x16_t lower_case = vandq_u8(str, is_letter);\n        uint8x16_t upper_case = vandq_u8(veorq_u8(is_letter, vdupq_n_u8(0xFF)), str);\n\n        uint8x16_t diff = veorq_u8(lower_case, vdupq_n_u8(32));\n        uint8x16_t res = vorrq_u8(diff, upper_case);\n\n        vst1q_u8((uint8_t*)(result.data() + i), res);\n\n        uint64x2_t tmp = {0};\n        vst1q_u64((uint64_t*)&tmp, vreinterpretq_u64_u8(is_letter));\n        if (tmp[0] != 0 || tmp[1] != 0) has_letter = true;\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            result[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n            has_letter = true;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n            \n            int arr[] = {a, b, c};\n            std::sort(arr, arr + 3);\n            \n            result[i] = arr[0];\n        } else {\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n            \n            int arr[] = {a, b, c};\n            std::sort(arr, arr + 3);\n            \n            result[i] = arr[0];\n        } else {\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n / 3; ++i) {\n        int index = i * 3;\n        if (index + 2 < n) {\n            int a = l[index];\n            int b = l[index + 1];\n            int c = l[index + 2];\n\n            std::vector<int> temp = {a, b, c};\n            std::sort(temp.begin(), temp.end());\n\n            result[index] = temp[0];\n            result[index + 1] = temp[1];\n            result[index + 2] = temp[2];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n            \n            int arr[] = {a, b, c};\n            std::sort(arr, arr + 3);\n            \n            result[i] = arr[0];\n        } else {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n / 3; ++i) {\n        int index = i * 3;\n        if (index + 2 < n) {\n            int a = l[index];\n            int b = l[index + 1];\n            int c = l[index + 2];\n\n            std::vector<int> temp = {a, b, c};\n            std::sort(temp.begin(), temp.end());\n\n            result[index] = temp[0];\n            result[index + 1] = temp[1];\n            result[index + 2] = temp[2];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return 0;\n    }\n\n    size_t size = l.size();\n    float max_val = l[0];\n\n    if (size >= 4) {\n        float32x4_t max_vec = vld1q_dup_f32(&max_val);\n        size_t i = 0;\n        for (i = 0; i <= size - 4; i += 4) {\n            float32x4_t current_vec = vld1q_f32(&l[i]);\n            max_vec = vmaxq_f32(max_vec, current_vec);\n        }\n\n        float temp_max[4];\n        vst1q_f32(temp_max, max_vec);\n        for (int j = 0; j < 4; ++j) {\n            if (temp_max[j] > max_val) {\n                max_val = temp_max[j];\n            }\n        }\n        \n        for (; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    } else {\n        for (size_t i = 1; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return 0;\n    }\n\n    size_t size = l.size();\n    size_t aligned_size = size - (size % 4);\n\n    float max_val = l[0];\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n\n    for (size_t i = 0; i < aligned_size; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    float max_arr[4];\n    vst1q_f32(max_arr, max_vec);\n\n    for (int i = 0; i < 4; ++i) {\n        if (max_arr[i] > max_val) {\n            max_val = max_arr[i];\n        }\n    }\n\n    for (size_t i = aligned_size; i < size; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return 0;\n    }\n\n    size_t size = l.size();\n    float max_val = l[0];\n\n    if (size >= 4) {\n        float32x4_t max_vec = vld1q_dup_f32(&max_val);\n        size_t i = 0;\n        for (i = 0; i <= size - 4; i += 4) {\n            float32x4_t current_vec = vld1q_f32(&l[i]);\n            max_vec = vmaxq_f32(max_vec, current_vec);\n        }\n\n        float temp_max[4];\n        vst1q_f32(temp_max, max_vec);\n        for (int j = 0; j < 4; ++j) {\n            if (temp_max[j] > max_val) {\n                max_val = temp_max[j];\n            }\n        }\n        \n        for (; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    } else {\n        for (size_t i = 1; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l){\n    if (l.empty()) {\n        return 0;\n    }\n\n    size_t size = l.size();\n    float max_val = l[0];\n\n    if (size >= 4) {\n        size_t aligned_size = size - (size % 4);\n        float32x4_t max_vec = vld1q_dup_f32(&l[0]);\n\n        for (size_t i = 0; i < aligned_size; i += 4) {\n            float32x4_t current_vec = vld1q_f32(&l[i]);\n            max_vec = vmaxq_f32(max_vec, current_vec);\n        }\n\n        float temp_max[4];\n        vst1q_f32(temp_max, max_vec);\n\n        for (int i = 0; i < 4; ++i) {\n            if (temp_max[i] > max_val) {\n                max_val = temp_max[i];\n            }\n        }\n\n        for (size_t i = aligned_size; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    } else {\n        for (size_t i = 1; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return 0;\n    }\n\n    size_t size = l.size();\n    float max_val = l[0];\n\n    if (size >= 4) {\n        float32x4_t max_vec = vld1q_dup_f32(&max_val);\n        size_t i = 0;\n        for (i = 0; i <= size - 4; i += 4) {\n            float32x4_t current_vec = vld1q_f32(&l[i]);\n            max_vec = vmaxq_f32(max_vec, current_vec);\n        }\n\n        float temp_max[4];\n        vst1q_f32(temp_max, max_vec);\n        for (int j = 0; j < 4; ++j) {\n            if (temp_max[j] > max_val) {\n                max_val = temp_max[j];\n            }\n        }\n        \n        for (; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    } else {\n        for (size_t i = 1; i < size; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n % 2 != 0) {\n        return l;\n    }\n\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    for (size_t i = 0, j = 0; i < n; i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n % 2 != 0) {\n        return l;\n    }\n\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    for (size_t i = 0, j = 0; i < n; i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n % 2 != 0) {\n        return l;\n    }\n\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    for (size_t i = 0, j = 0; i < n; i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n % 2 != 0) {\n        return l;\n    }\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    for (size_t i = 0, j = 0; i < n; i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n <= 1) return l;\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int n = l.size();\n    int i = 0;\n    std::vector<int> result(n);\n\n    // Process the vector in chunks of 4\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, vdupq_n_s32(1));\n        vst1q_s32(&result[i], v);\n    }\n\n    // Process the remaining elements\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    for (; i < size; ++i) {\n        l[i]++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    for (; i < size; ++i) {\n        l[i]++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int i = 0;\n    for (; (i + 3) < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    for (; i < size; ++i) {\n        l[i]++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, vdupq_n_s32(1));\n        vst1q_s32(&l[i], v);\n    }\n    for (; i < size; ++i) {\n        l[i]++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) {\n        return true;\n    }\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) {\n        return true;\n    }\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t five_vec = vdupq_n_u8(5);\n\n            uint8x16_t shifted_vec = vsubq_u8(vec, five_vec);\n\n            uint8x16_t lt_a = vcltq_u8(shifted_vec, a_vec);\n            uint8x16_t add_26 = vandq_u8(lt_a, vdupq_n_u8(26));\n            shifted_vec = vaddq_u8(shifted_vec, add_26);\n\n            vst1q_u8((uint8_t*)&out[i], shifted_vec);\n        }\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t five_vec = vdupq_n_u8(5);\n\n            uint8x16_t shifted_vec = vsubq_u8(vec, five_vec);\n\n            uint8x16_t lt_a = vcltq_u8(shifted_vec, a_vec);\n            uint8x16_t add_26 = vandq_u8(lt_a, vdupq_n_u8(26));\n            shifted_vec = vaddq_u8(shifted_vec, add_26);\n\n            vst1q_u8((uint8_t*)&out[i], shifted_vec);\n        }\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t five_vec = vdupq_n_u8(5);\n\n            uint8x16_t shifted_vec = vsubq_u8(vec, five_vec);\n\n            uint8x16_t lt_a = vcltq_u8(shifted_vec, a_vec);\n            uint8x16_t add_26 = vandq_u8(lt_a, vdupq_n_u8(26));\n            shifted_vec = vaddq_u8(shifted_vec, add_26);\n\n            vst1q_u8((uint8_t*)&out[i], shifted_vec);\n        }\n    }\n\n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t five_vec = vdupq_n_u8(5);\n\n            uint8x16_t shifted_vec = vsubq_u8(vec, five_vec);\n\n            uint8x16_t lt_a = vcltq_u8(shifted_vec, a_vec);\n            uint8x16_t add_26 = vandq_u8(lt_a, vdupq_n_u8(26));\n            shifted_vec = vaddq_u8(shifted_vec, add_26);\n\n            vst1q_u8((uint8_t*)&out[i], shifted_vec);\n        }\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t five_vec = vdupq_n_u8(5);\n\n            uint8x16_t shifted_vec = vsubq_u8(vec, five_vec);\n\n            uint8x16_t lt_a = vcltq_u8(shifted_vec, a_vec);\n            uint8x16_t add_26 = vandq_u8(lt_a, vdupq_n_u8(26));\n            shifted_vec = vaddq_u8(shifted_vec, add_26);\n\n            vst1q_u8((uint8_t*)&out[i], shifted_vec);\n        }\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n\n    if (size >= 4) {\n        int num_vectors = size / 4;\n        for (int j = 0; j < num_vectors; ++j) {\n            int32x4_t vec = vld1q_s32(&l[i]);\n            int32x4_t threshold_vec = vdupq_n_s32(t);\n            int32x4_t cmp = vcltq_s32(vec, threshold_vec);\n            uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n            uint32x4_t result_mask = vandq_u32(vreinterpretq_u32_s32(cmp), mask);\n\n            if (vgetq_lane_u32(result_mask, 0) == 0 &&\n                vgetq_lane_u32(result_mask, 1) == 0 &&\n                vgetq_lane_u32(result_mask, 2) == 0 &&\n                vgetq_lane_u32(result_mask, 3) == 0) {\n                return false;\n            }\n            i += 4;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n\n    if (size >= 4) {\n        int num_vectors = size / 4;\n        for (int j = 0; j < num_vectors; ++j) {\n            int32x4_t vec = vld1q_s32(&l[i]);\n            int32x4_t threshold_vec = vdupq_n_s32(t);\n            int32x4_t cmp = vcltq_s32(vec, threshold_vec);\n            uint32x4_t mask = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (vgetq_lane_u32(mask, 0) != 0 ||\n                vgetq_lane_u32(mask, 1) != 0 ||\n                vgetq_lane_u32(mask, 2) != 0 ||\n                vgetq_lane_u32(mask, 3) != 0) {\n                return false;\n            }\n            i += 4;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t threshold_vec = vdupq_n_s32(t);\n        int32x4_t cmp = vcltq_s32(vec, threshold_vec);\n        uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF); // All bits set to 1\n        uint32x4_t result = vandq_u32(vreinterpretq_u32_s32(cmp), mask);\n\n        // Check if all elements are below the threshold\n        if (vgetq_lane_u32(result, 0) == 0 &&\n            vgetq_lane_u32(result, 1) == 0 &&\n            vgetq_lane_u32(result, 2) == 0 &&\n            vgetq_lane_u32(result, 3) == 0) {\n            return false;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n\n    if (size >= 4) {\n        int num_vectors = size / 4;\n        for (int j = 0; j < num_vectors; ++j) {\n            int32x4_t vec = vld1q_s32(&l[i]);\n            int32x4_t threshold_vec = vdupq_n_s32(t);\n            int32x4_t cmp = vcltq_s32(vec, threshold_vec);\n            uint32x4_t mask = vmvnq_u32(vreinterpretq_u32_s32(cmp));\n\n            if (!vgetq_lane_u32(mask, 0) || !vgetq_lane_u32(mask, 1) ||\n                !vgetq_lane_u32(mask, 2) || !vgetq_lane_u32(mask, 3)) {\n                return false;\n            }\n            i += 4;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n\n    // Process the vector in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t threshold_vec = vdupq_n_s32(t);\n        int32x4_t cmp = vcltq_s32(vec, threshold_vec); // Compare less than\n        uint32x4_t mask = vmvnq_u32(vreinterpretq_u32_s32(cmp)); // Create mask\n\n        if (vgetq_lane_u32(mask, 0) != 0 ||\n            vgetq_lane_u32(mask, 1) != 0 ||\n            vgetq_lane_u32(mask, 2) != 0 ||\n            vgetq_lane_u32(mask, 3) != 0) {\n            return false;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    for (int i = 0; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(vec, vdupq_n_u8('<'));\n        uint8x16_t close_mask = vceqq_u8(vec, vdupq_n_u8('>'));\n\n        uint64x2_t open_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(open_mask)), vmovl_u8(vget_high_u8(open_mask))), vdupq_n_u16(0)));\n        uint64x2_t close_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(close_mask)), vmovl_u8(vget_high_u8(close_mask))), vdupq_n_u16(0)));\n\n        balance += vgetq_lane_u64(open_counts, 0) - vgetq_lane_u64(close_counts, 0);\n\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    for (int i = 0; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    for (int i = 0; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    for (int i = 0; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        uint64x2_t open_counts = vpaddlq_u32(vmovl_u16(vpaddl_u8(vget_low_u8(open_mask))));\n        uint64x2_t close_counts = vpaddlq_u32(vmovl_u16(vpaddl_u8(vget_low_u8(close_mask))));\n\n        balance += vgetq_lane_u64(open_counts, 0) + vgetq_lane_u64(open_counts, 1);\n        balance -= vgetq_lane_u64(close_counts, 0) + vgetq_lane_u64(close_counts, 1);\n\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        uint64x2_t open_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(open_mask)), vmovl_u8(vget_high_u8(open_mask))), vdupq_n_u16(0)));\n        uint64x2_t close_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(close_mask)), vmovl_u8(vget_high_u8(close_mask))), vdupq_n_u16(0)));\n\n        balance += vgetq_lane_u64(open_counts, 0) + vgetq_lane_u64(open_counts, 1);\n        balance -= vgetq_lane_u64(close_counts, 0) + vgetq_lane_u64(close_counts, 1);\n\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        uint64x2_t open_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(open_mask)))))), vmovl_u8(vget_high_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(open_mask))))))), vmovl_u8(vget_low_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(open_mask)))))), vmovl_u8(vget_high_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(open_mask))))))));\n        uint64x2_t close_counts = vpaddlq_u32(vpadalq_u16(vpadalq_u8(vmovl_u8(vget_low_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(close_mask)))))), vmovl_u8(vget_high_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(close_mask))))))), vmovl_u8(vget_low_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(close_mask)))))), vmovl_u8(vget_high_u8(vmovn_u16(vmovn_u32(vmovn_u64(vreinterpretq_u64_u8(close_mask))))))));\n\n        balance += vgetq_lane_u64(open_counts, 0) + vgetq_lane_u64(open_counts, 1);\n        balance -= vgetq_lane_u64(close_counts, 0) + vgetq_lane_u64(close_counts, 1);\n\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int len = brackets.length();\n    int i = 0;\n\n    if (len == 0) return true;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        int open_count = 0;\n        int close_count = 0;\n\n        for (int j = 0; j < 16; ++j) {\n            if (vgetq_lane_u8(open_mask, j)) {\n                open_count++;\n            }\n            if (vgetq_lane_u8(close_mask, j)) {\n                close_count++;\n            }\n        }\n\n        balance += open_count - close_count;\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        uint64x2_t open_counts = vpaddlq_u32(vmovl_u16(vpaddl_u8(vget_low_u8(open_mask))));\n        uint64x2_t close_counts = vpaddlq_u32(vmovl_u16(vpaddl_u8(vget_low_u8(close_mask))));\n\n        balance += vgetq_lane_u64(open_counts, 0) + vgetq_lane_u64(open_counts, 1);\n        balance -= vgetq_lane_u64(close_counts, 0) + vgetq_lane_u64(close_counts, 1);\n\n        if (balance < 0) return false;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    uint8_t y = 'y';\n\n    uint8x16_t vowels_vec = vld1q_u8(vowels);\n\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t data_vec = vld1q_u8((uint8_t*)(s.data() + i));\n        uint8x16_t eq1 = vceqzq_u8(data_vec - vdupq_n_u8('a'));\n        uint8x16_t eq2 = vceqzq_u8(data_vec - vdupq_n_u8('e'));\n        uint8x16_t eq3 = vceqzq_u8(data_vec - vdupq_n_u8('i'));\n        uint8x16_t eq4 = vceqzq_u8(data_vec - vdupq_n_u8('o'));\n        uint8x16_t eq5 = vceqzq_u8(data_vec - vdupq_n_u8('u'));\n\n        uint8x16_t or1 = vorrq_u8(eq1, eq2);\n        uint8x16_t or2 = vorrq_u8(eq3, eq4);\n        uint8x16_t or3 = vorrq_u8(or1, or2);\n        uint8x16_t or4 = vorrq_u8(or3, eq5);\n\n        uint64_t tmp = vmvnq_u64(vreinterpretq_u64_u8(or4)).val[0] | vmvnq_u64(vreinterpretq_u64_u8(or4)).val[1];\n        count += __builtin_popcountll(tmp);\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == len - 1 && c == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    uint8x16_t vowels_vec = vld1q_u8(vowels);\n\n    for (int i = 0; i < len; i += 16) {\n        int current_len = std::min(16, len - i);\n        uint8_t current_block[16];\n        for (int j = 0; j < 16; ++j) {\n            current_block[j] = (j < current_len) ? (uint8_t)s[i + j] : 0;\n        }\n\n        uint8x16_t data_vec = vld1q_u8(current_block);\n        uint8x16_t cmp_a = vceqq_u8(data_vec, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(data_vec, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(data_vec, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(data_vec, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(data_vec, vdupq_n_u8('u'));\n\n        uint8x16_t or_ae = vorrq_u8(cmp_a, cmp_e);\n        uint8x16_t or_io = vorrq_u8(cmp_i, cmp_o);\n        uint8x16_t or_aeio = vorrq_u8(or_ae, or_io);\n        uint8x16_t or_aeiou = vorrq_u8(or_aeio, cmp_u);\n\n        uint8_t result[16];\n        vst1q_u8(result, or_aeiou);\n\n        for (int j = 0; j < current_len; ++j) {\n            if (result[j]) {\n                count++;\n            }\n        }\n    }\n\n    if (s[len - 1] == 'y' || s[len - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    uint8_t y = 'y';\n\n    uint8x16_t vowels_vec = vld1q_u8(vowels);\n\n    int i = 0;\n    for (; i < len - (len % 16); i += 16) {\n        uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n        uint8x16_t cmp_a = vceqq_u8(str_vec, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(str_vec, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(str_vec, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(str_vec, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(str_vec, vdupq_n_u8('u'));\n\n        uint8x16_t or1 = vorrq_u8(cmp_a, cmp_e);\n        uint8x16_t or2 = vorrq_u8(cmp_i, cmp_o);\n        uint8x16_t or3 = vorrq_u8(or1, or2);\n        uint8x16_t or4 = vorrq_u8(or3, cmp_u);\n\n        uint64x2_t sum_long = vpaddlq_u32(vmovl_u16(vpaddlq_u8(or4)));\n        uint64_t sum = vgetq_lane_u64(sum_long, 0) + vgetq_lane_u64(sum_long, 1);\n        count += sum;\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == len - 1 && c == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    uint8_t y = 'y';\n\n    uint8x16_t vowels_vec = vld1q_u8(vowels);\n\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t data_vec = vld1q_u8((uint8_t*)(s.data() + i));\n        uint8x16_t eq1 = vceqhq_u8(data_vec, vdupq_n_u8('a'));\n        uint8x16_t eq2 = vceqhq_u8(data_vec, vdupq_n_u8('e'));\n        uint8x16_t eq3 = vceqhq_u8(data_vec, vdupq_n_u8('i'));\n        uint8x16_t eq4 = vceqhq_u8(data_vec, vdupq_n_u8('o'));\n        uint8x16_t eq5 = vceqhq_u8(data_vec, vdupq_n_u8('u'));\n\n        uint8x16_t or1 = vorrq_u8(eq1, eq2);\n        uint8x16_t or2 = vorrq_u8(eq3, eq4);\n        uint8x16_t or3 = vorrq_u8(or1, or2);\n        uint8x16_t or4 = vorrq_u8(or3, eq5);\n\n        uint64x2_t sum_long = vpaddlq_u8(or4);\n        uint64_t sum = vgetq_lane_u64(sum_long, 0) + vgetq_lane_u64(sum_long, 1);\n        count += sum;\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == len - 1 && c == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    uint8x16_t vowels_vec = vld1q_u8(vowels);\n\n    for (int i = 0; i < len; i += 16) {\n        int current_len = std::min(16, len - i);\n        uint8_t current_block[16];\n        for (int j = 0; j < 16; ++j) {\n            current_block[j] = (j < current_len) ? (uint8_t)std::tolower(s[i + j]) : 0;\n        }\n\n        uint8x16_t data_vec = vld1q_u8(current_block);\n        uint8x16_t cmp_a = vceqq_u8(data_vec, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(data_vec, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(data_vec, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(data_vec, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(data_vec, vdupq_n_u8('u'));\n\n        uint8x16_t or_ae = vorrq_u8(cmp_a, cmp_e);\n        uint8x16_t or_aei = vorrq_u8(or_ae, cmp_i);\n        uint8x16_t or_aeio = vorrq_u8(or_aei, cmp_o);\n        uint8x16_t or_aeiou = vorrq_u8(or_aeio, cmp_u);\n\n        uint8_t result[16];\n        vst1q_u8(result, or_aeiou);\n\n        for (int j = 0; j < current_len; ++j) {\n            if (result[j] != 0) {\n                count++;\n            }\n        }\n    }\n\n    if (s[len - 1] == 'y' || s[len - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n            uint8x16_t mask_lower = vcleq_u8(str_vec, Z_vec);\n            uint8x16_t mask_upper = vcgeq_u8(str_vec, A_vec);\n            uint8x16_t mask = vandq_u8(mask_lower, mask_upper);\n            \n            uint8x16_t masked_vec = vandq_u8(str_vec, mask);\n\n            uint8_t temp_sum[16];\n            vst1q_u8(temp_sum, masked_vec);\n\n            for (int j = 0; j < 16; ++j) {\n                sum += temp_sum[j];\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n            uint8x16_t mask_lower = vcleq_u8(str_vec, Z_vec);\n            uint8x16_t mask_upper = vcgeq_u8(str_vec, A_vec);\n            uint8x16_t mask = vandq_u8(mask_lower, mask_upper);\n            \n            uint8x16_t masked_vec = vandq_u8(str_vec, mask);\n\n            uint8x8_t low = vget_low_u8(masked_vec);\n            uint8x8_t high = vget_high_u8(masked_vec);\n\n            uint16x8_t low_wide = vmovl_u8(low);\n            uint16x8_t high_wide = vmovl_u8(high);\n\n            uint32x4_t low_sum1 = vpaddlq_u16(low_wide);\n            uint32x4_t high_sum1 = vpaddlq_u16(high_wide);\n\n            uint32x2_t low_sum2 = vpadd_u32(vget_low_u32(low_sum1), vget_high_u32(low_sum1));\n            uint32x2_t high_sum2 = vpadd_u32(vget_low_u32(high_sum1), vget_high_u32(high_sum1));\n\n            sum += vget_lane_u32(low_sum2, 0) + vget_lane_u32(low_sum2, 1) + vget_lane_u32(high_sum2, 0) + vget_lane_u32(high_sum2, 1);\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n            uint8x16_t mask_lower = vcleq_u8(str_vec, Z_vec);\n            uint8x16_t mask_upper = vcgeq_u8(str_vec, A_vec);\n            uint8x16_t mask = vandq_u8(mask_lower, mask_upper);\n            \n            uint8x16_t masked_vec = vandq_u8(str_vec, mask);\n\n            uint8x8_t low = vget_low_u8(masked_vec);\n            uint8x8_t high = vget_high_u8(masked_vec);\n\n            uint16x8_t low_wide = vmovl_u8(low);\n            uint16x8_t high_wide = vmovl_u8(high);\n\n            uint32x4_t low_sum = vpaddlq_u16(low_wide);\n            uint32x4_t high_sum = vpaddlq_u16(high_wide);\n\n            uint32x2_t sum_pair = vpadd_u32(vget_low_u32(low_sum), vget_low_u32(high_sum));\n            sum += vget_lane_u32(sum_pair, 0) + vget_lane_u32(sum_pair, 1);\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n            uint8x16_t mask1 = vcleq_u8(A_vec, str_vec);\n            uint8x16_t mask2 = vcleq_u8(str_vec, Z_vec);\n            uint8x16_t mask = vandq_u8(mask1, mask2);\n\n            uint8x16_t masked_str_vec = vandq_u8(str_vec, mask);\n\n            uint8x8_t low = vget_low_u8(masked_str_vec);\n            uint8x8_t high = vget_high_u8(masked_str_vec);\n\n            uint16x8_t low_wide = vmovl_u8(low);\n            uint16x8_t high_wide = vmovl_u8(high);\n\n            uint32x4_t sum_low = vpaddlq_u16(low_wide);\n            uint32x4_t sum_high = vpaddlq_u16(high_wide);\n\n            uint32x2_t final_sum_low = vpadd_u32(vget_low_u32(sum_low), vget_high_u32(sum_low));\n            uint32x2_t final_sum_high = vpadd_u32(vget_low_u32(sum_high), vget_high_u32(sum_high));\n\n            sum += vget_lane_u32(final_sum_low, 0) + vget_lane_u32(final_sum_low, 1) + vget_lane_u32(final_sum_high, 0) + vget_lane_u32(final_sum_high, 1);\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8((uint8_t*)(s.c_str() + i));\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n            uint8x16_t mask1 = vcleq_u8(A_vec, str_vec);\n            uint8x16_t mask2 = vcleq_u8(str_vec, Z_vec);\n            uint8x16_t mask = vandq_u8(mask1, mask2);\n\n            uint8x16_t masked_vec = vandq_u8(str_vec, mask);\n\n            uint16x8_t wide1 = vmovl_u8(vget_low_u8(masked_vec));\n            uint16x8_t wide2 = vmovl_u8(vget_high_u8(masked_vec));\n\n            uint32x4_t wide3 = vmovl_u16(vget_low_u16((wide1)));\n            uint32x4_t wide4 = vmovl_u16(vget_high_u16((wide1)));\n            uint32x4_t wide5 = vmovl_u16(vget_low_u16((wide2)));\n            uint32x4_t wide6 = vmovl_u16(vget_high_u16((wide2)));\n\n            sum += vaddvq_u32(wide3) + vaddvq_u32(wide4) + vaddvq_u32(wide5) + vaddvq_u32(wide6);\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> counts(max_val + 1, 0);\n\n    for (int val : lst) {\n        counts[val]++;\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (counts[i] >= i) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    std::sort(lst.begin(), lst.end());\n    int max_val = -1;\n\n    for (int i = lst.size() - 1; i >= 0; --i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == num) {\n                count++;\n            }\n        }\n\n        if (count >= num) {\n            max_val = num;\n            break;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) {\n        return -1;\n    }\n\n    std::sort(lst.begin(), lst.end());\n    int max_val = -1;\n\n    for (int i = lst.size() - 1; i >= 0; --i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == num) {\n                count++;\n            }\n        }\n\n        if (count >= num) {\n            max_val = num;\n            break;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> counts(max_val + 1, 0);\n\n    for (int val : lst) {\n        counts[val]++;\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (counts[i] >= i) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) {\n        return -1;\n    }\n\n    std::sort(lst.begin(), lst.end());\n    int max_val = -1;\n\n    for (int i = lst.size() - 1; i >= 0; --i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == num) {\n                count++;\n            }\n        }\n\n        if (count >= num) {\n            max_val = num;\n            break;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements using NEON intrinsics\n    int sum = 0;\n    if (n >= 4) {\n        int num_vectors = n / 4;\n        int remaining_elements = n % 4;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t data_vec = vld1q_s32(&q[i * 4]);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        // Sum the elements of the vector\n        int32_t temp[4];\n        vst1q_s32(temp, sum_vec);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        // Add remaining elements\n        for (int i = n - remaining_elements; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If the size is less than 4, calculate the sum normally\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindrome)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using NEON if possible\n    int sum = 0;\n    if (n >= 4) {\n        int num_vectors = n / 4;\n        int remaining = n % 4;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t data_vec = vld1q_s32(&q[i * 4]);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        // Horizontal add\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum += vget_lane_s32(sum_pair, 0);\n        sum += vget_lane_s32(sum_pair, 1);\n\n        // Add remaining elements\n        for (int i = n - remaining; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If less than 4 elements, just sum them up\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using NEON intrinsics if possible\n    int sum = 0;\n    if (n >= 4) {\n        int num_vectors = n / 4;\n        int remaining = n % 4;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t data_vec = vld1q_s32(&q[i * 4]);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        // Horizontal add\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Add remaining elements\n        for (int i = n - remaining; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If less than 4 elements, just sum them up\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using NEON intrinsics if possible\n    int sum = 0;\n    if (n >= 4) {\n        int num_vectors = n / 4;\n        int remaining = n % 4;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t data_vec = vld1q_s32(&q[i * 4]);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        // Horizontal add\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Add remaining elements\n        for (int i = n - remaining; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If less than 4 elements, calculate sum normally\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    // Check if sum is less than or equal to w\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using NEON intrinsics if possible\n    int sum = 0;\n    if (n >= 4) {\n        int num_vectors = n / 4;\n        int remaining_elements = n % 4;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t data_vec = vld1q_s32(&q[i * 4]);\n            sum_vec = vaddq_s32(sum_vec, data_vec);\n        }\n\n        // Horizontal add\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum += vget_lane_s32(sum_pair, 0);\n        sum += vget_lane_s32(sum_pair, 1);\n\n        // Add remaining elements\n        for (int i = n - remaining_elements; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If less than 4 elements, just sum them up\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double log_x = std::log(x);\n    double log_n = std::log(n);\n    double power = log_x / log_n;\n\n    return std::abs(power - std::round(power)) < 1e-10;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)(num.data() + i));\n\n        uint8x16_t prime_mask = vdupq_n_u8(0);\n\n        uint8x16_t eq2 = vceqq_u8(input, vdupq_n_u8('2'));\n        uint8x16_t eq3 = vceqq_u8(input, vdupq_n_u8('3'));\n        uint8x16_t eq5 = vceqq_u8(input, vdupq_n_u8('5'));\n        uint8x16_t eq7 = vceqq_u8(input, vdupq_n_u8('7'));\n        uint8x16_t eqB = vceqq_u8(input, vdupq_n_u8('B'));\n        uint8x16_t eqD = vceqq_u8(input, vdupq_n_u8('D'));\n\n        prime_mask = vorrq_u8(prime_mask, eq2);\n        prime_mask = vorrq_u8(prime_mask, eq3);\n        prime_mask = vorrq_u8(prime_mask, eq5);\n        prime_mask = vorrq_u8(prime_mask, eq7);\n        prime_mask = vorrq_u8(prime_mask, eqB);\n        prime_mask = vorrq_u8(prime_mask, eqD);\n\n        uint8_t temp_count[2];\n        vst1_u8(temp_count, vget_low_u8(vcountq_u8(prime_mask)));\n        vst1_u8(temp_count + 1, vget_high_u8(vcountq_u8(prime_mask)));\n\n        count += temp_count[0] + temp_count[1];\n    }\n\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8((const uint8_t*)(num.data() + i));\n            uint8x16_t prime_mask = vdupq_n_u8(0);\n\n            uint8x16_t eq2 = vceqq_u8(input, vdupq_n_u8('2'));\n            uint8x16_t eq3 = vceqq_u8(input, vdupq_n_u8('3'));\n            uint8x16_t eq5 = vceqq_u8(input, vdupq_n_u8('5'));\n            uint8x16_t eq7 = vceqq_u8(input, vdupq_n_u8('7'));\n            uint8x16_t eqB = vceqq_u8(input, vdupq_n_u8('B'));\n            uint8x16_t eqD = vceqq_u8(input, vdupq_n_u8('D'));\n\n            prime_mask = vorrq_u8(prime_mask, eq2);\n            prime_mask = vorrq_u8(prime_mask, eq3);\n            prime_mask = vorrq_u8(prime_mask, eq5);\n            prime_mask = vorrq_u8(prime_mask, eq7);\n            prime_mask = vorrq_u8(prime_mask, eqB);\n            prime_mask = vorrq_u8(prime_mask, eqD);\n\n            uint8_t temp_count[16];\n            vst1q_u8(temp_count, prime_mask);\n\n            for (int j = 0; j < 16; ++j) {\n                if (temp_count[j] != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8((const uint8_t*)(num.data() + i));\n            uint8x16_t prime_mask = vdupq_n_u8(0);\n\n            uint8x16_t eq2 = vceqq_u8(input, vdupq_n_u8('2'));\n            uint8x16_t eq3 = vceqq_u8(input, vdupq_n_u8('3'));\n            uint8x16_t eq5 = vceqq_u8(input, vdupq_n_u8('5'));\n            uint8x16_t eq7 = vceqq_u8(input, vdupq_n_u8('7'));\n            uint8x16_t eqB = vceqq_u8(input, vdupq_n_u8('B'));\n            uint8x16_t eqD = vceqq_u8(input, vdupq_n_u8('D'));\n\n            prime_mask = vorrq_u8(prime_mask, eq2);\n            prime_mask = vorrq_u8(prime_mask, eq3);\n            prime_mask = vorrq_u8(prime_mask, eq5);\n            prime_mask = vorrq_u8(prime_mask, eq7);\n            prime_mask = vorrq_u8(prime_mask, eqB);\n            prime_mask = vorrq_u8(prime_mask, eqD);\n\n            uint8_t temp_count[16];\n            vst1q_u8(temp_count, prime_mask);\n\n            for (int j = 0; j < 16; ++j) {\n                if (temp_count[j] != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8((const uint8_t*)(num.data() + i));\n            uint8x16_t prime_mask = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n            uint8x16_t hex_values = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n            uint8x16_t a_values = vdupq_n_u8('A');\n            uint8x16_t diff = vsubq_u8(input, a_values);\n            uint8x16_t mask = vcleq_u8(diff, vdupq_n_u8(5));\n            uint8x16_t hex_digits = vbslq_u8(mask, vaddq_u8(diff, vdupq_n_u8(10)), input);\n            uint8x16_t digits = vsubq_u8(hex_digits, vdupq_n_u8('0'));\n            uint8x16_t prime_flags = vtbl1q_u8(prime_mask, digits);\n            uint8_t temp[16];\n            vst1q_u8(temp, prime_flags);\n            for (int j = 0; j < 16; ++j) {\n                count += temp[j];\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        char c = num[i];\n        int digit;\n        if (c >= '0' && c <= '9') {\n            digit = c - '0';\n        } else {\n            digit = c - 'A' + 10;\n        }\n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8((const uint8_t*)(num.data() + i));\n            uint8x16_t prime_mask = vdupq_n_u8(0);\n\n            uint8x16_t eq2 = vceqq_u8(input, vdupq_n_u8('2'));\n            uint8x16_t eq3 = vceqq_u8(input, vdupq_n_u8('3'));\n            uint8x16_t eq5 = vceqq_u8(input, vdupq_n_u8('5'));\n            uint8x16_t eq7 = vceqq_u8(input, vdupq_n_u8('7'));\n            uint8x16_t eqB = vceqq_u8(input, vdupq_n_u8('B'));\n            uint8x16_t eqD = vceqq_u8(input, vdupq_n_u8('D'));\n\n            prime_mask = vorrq_u8(prime_mask, eq2);\n            prime_mask = vorrq_u8(prime_mask, eq3);\n            prime_mask = vorrq_u8(prime_mask, eq5);\n            prime_mask = vorrq_u8(prime_mask, eq7);\n            prime_mask = vorrq_u8(prime_mask, eqB);\n            prime_mask = vorrq_u8(prime_mask, eqD);\n\n            uint8_t temp_count[16];\n            vst1q_u8(temp_count, prime_mask);\n\n            for (int j = 0; j < 16; ++j) {\n                if (temp_count[j] != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    int i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n        i = i + 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    int i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n        i = i + 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 1; i < lst.size(); i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int n = lst.size();\n\n    for (int i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i+=2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t plaintext = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t shift = vdupq_n_u8(4);\n        uint8x16_t a_vec = vdupq_n_u8('a');\n        uint8x16_t z_vec = vdupq_n_u8('z');\n\n        uint8x16_t lower = vandq_u8(vcgeq_u8(plaintext, a_vec), vcleq_u8(plaintext, z_vec));\n        uint8x16_t shifted = vaddq_u8(plaintext, shift);\n        uint8x16_t overflow = vcgtq_u8(shifted, z_vec);\n        shifted = vbslq_u8(overflow, vaddq_u8(shifted, vdupq_n_u8('a' - 'z' - 1)), shifted);\n        shifted = vbslq_u8(lower, shifted, plaintext);\n\n        vst1q_u8((uint8_t*)&encrypted_string[i], shifted);\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = (s[i] + 4);\n            if (encrypted_string[i] > 'z') {\n                encrypted_string[i] = 'a' + (encrypted_string[i] - 'z' - 1);\n            }\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; i += 16) {\n        int count = std::min(16, len - i);\n        uint8x16_t input_vec;\n\n        // Load the input string into the vector\n        for (int j = 0; j < count; ++j) {\n            encrypted_string[i + j] = s[i + j];\n        }\n        \n        if (count < 16) {\n            char temp_arr[16];\n            for(int j = 0; j < count; ++j){\n                temp_arr[j] = s[i+j];\n            }\n            for(int j = count; j < 16; ++j){\n                temp_arr[j] = ' ';\n            }\n            input_vec = vld1q_u8((uint8_t*)temp_arr);\n        } else {\n            input_vec = vld1q_u8((uint8_t*)s.data() + i);\n        }\n        \n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift_vec = vdupq_n_u8(4);\n\n        // Add the shift value to the input vector\n        uint8x16_t result_vec = vaddq_u8(input_vec, shift_vec);\n\n        // Apply the alphabet wrapping logic\n        uint8x16_t a_vec = vdupq_n_u8('a');\n        uint8x16_t z_vec = vdupq_n_u8('z');\n\n        uint8x16_t lower_mask = vandq_u8(vcleq_u8(a_vec, input_vec), vcgeq_u8(z_vec, input_vec));\n        uint8x16_t overflow_mask = vcgtq_u8(result_vec, z_vec);\n\n        uint8x16_t wrapped_result = vsubq_u8(result_vec, vdupq_n_u8(26));\n        result_vec = vbslq_u8(vandq_u8(lower_mask, overflow_mask), wrapped_result, result_vec);\n\n        // Store the result back into the encrypted string\n        uint8_t result_arr[16];\n        vst1q_u8(result_arr, result_vec);\n\n        for (int j = 0; j < count; ++j) {\n            if (s[i+j] >= 'a' && s[i+j] <= 'z') {\n                encrypted_string[i + j] = (char)result_arr[j];\n            }\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; i += 16) {\n        int count = std::min(16, len - i);\n        uint8x16_t input_vec;\n\n        // Load data into the vector\n        for (int j = 0; j < count; ++j) {\n            input_vec[j] = s[i + j];\n        }\n        // Pad the rest with zeros if count < 16\n        for (int j = count; j < 16; ++j) {\n            input_vec[j] = 0;\n        }\n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift_vec = vdupq_n_u8(4);\n\n        // Add the shift value to the input vector\n        uint8x16_t result_vec = vaddq_u8(input_vec, shift_vec);\n\n        // Handle wrapping around the alphabet (a-z)\n        uint8x16_t a_vec = vdupq_n_u8('a');\n        uint8x16_t z_vec = vdupq_n_u8('z');\n        uint8x16_t wrap_around_vec = vdupq_n_u8(26);\n\n        uint8x16_t is_lower_alpha_vec = vandq_u8(vcleq_u8(a_vec, input_vec), vcgeq_u8(z_vec, input_vec));\n        uint8x16_t overflow_vec = vcleq_u8(z_vec, result_vec);\n\n        result_vec = vbslq_u8(vandq_u8(is_lower_alpha_vec, overflow_vec), vsubq_u8(result_vec, wrap_around_vec), result_vec);\n\n        // Store the result back into the encrypted string\n        for (int j = 0; j < count; ++j) {\n            encrypted_string[i + j] = result_vec[j];\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; i += 16) {\n        int count = std::min(16, len - i);\n        uint8x16_t input_vec;\n\n        // Load data into the vector\n        for (int j = 0; j < count; ++j) {\n            encrypted_string[i + j] = s[i + j];\n        }\n        \n        uint8_t temp_data[16];\n        for(int j = 0; j < count; ++j){\n            temp_data[j] = encrypted_string[i+j];\n        }\n        for(int j = count; j < 16; ++j){\n            temp_data[j] = 0;\n        }\n        input_vec = vld1q_u8(temp_data);\n\n        // Add 4 to each element (rotate alphabet by 4)\n        uint8x16_t shift_vec = vdupq_n_u8(4);\n        uint8x16_t result_vec = vaddq_u8(input_vec, shift_vec);\n\n        // Handle wrapping around the alphabet\n        uint8x16_t a_vec = vdupq_n_u8('a');\n        uint8x16_t z_vec = vdupq_n_u8('z');\n        uint8x16_t A_vec = vdupq_n_u8('A');\n        uint8x16_t Z_vec = vdupq_n_u8('Z');\n\n        uint8x16_t lower_case_mask = vandq_u8(vcleq_u8(a_vec, input_vec), vcgeq_u8(z_vec, input_vec));\n        uint8x16_t upper_case_mask = vandq_u8(vcleq_u8(A_vec, input_vec), vcgeq_u8(Z_vec, input_vec));\n\n        uint8x16_t overflow_lower = vcgtq_u8(vaddq_u8(input_vec, shift_vec), z_vec);\n        uint8x16_t overflow_upper = vcgtq_u8(vaddq_u8(input_vec, shift_vec), Z_vec);\n\n        uint8x16_t wrapped_lower = vsubq_u8(result_vec, vdupq_n_u8(26));\n        uint8x16_t wrapped_upper = vsubq_u8(result_vec, vdupq_n_u8(26));\n\n        result_vec = vbslq_u8(vandq_u8(lower_case_mask, overflow_lower), wrapped_lower, result_vec);\n        result_vec = vbslq_u8(vandq_u8(upper_case_mask, overflow_upper), wrapped_upper, result_vec);\n\n        // Store the result back into the string\n        uint8_t result_data[16];\n        vst1q_u8(result_data, result_vec);\n        for (int j = 0; j < count; ++j) {\n            encrypted_string[i + j] = result_data[j];\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; i += 16) {\n        int count = std::min(16, len - i);\n        uint8x16_t input_vec;\n\n        // Load the input string into a vector\n        for (int j = 0; j < count; ++j) {\n            input_vec[j] = s[i + j];\n        }\n        for (int j = count; j < 16; ++j) {\n            input_vec[j] = 0;\n        }\n\n        // Add 4 to each character (rotate alphabet by 4)\n        uint8x16_t shift_vec = vdupq_n_u8(4);\n        uint8x16_t encrypted_vec = vaddq_u8(input_vec, shift_vec);\n\n        // Handle wrapping around the alphabet (a-z)\n        uint8x16_t a_vec = vdupq_n_u8('a');\n        uint8x16_t z_vec = vdupq_n_u8('z');\n        uint8x16_t overflow_mask = vcgeq_u8(encrypted_vec, vdupq_n_u8('z' + 1));\n        uint8x16_t diff_vec = vsubq_u8(encrypted_vec, vdupq_n_u8(26));\n        encrypted_vec = vbslq_u8(overflow_mask, diff_vec, encrypted_vec);\n\n        uint8x16_t underflow_mask = vcleq_u8(encrypted_vec, vdupq_n_u8('a' - 1));\n        diff_vec = vaddq_u8(encrypted_vec, vdupq_n_u8(26));\n        encrypted_vec = vbslq_u8(underflow_mask, diff_vec, encrypted_vec);\n\n        // Store the encrypted vector back into the string\n        for (int j = 0; j < count; ++j) {\n            encrypted_string[i + j] = encrypted_vec[j];\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i + 15 < len; i += 16) {\n        uint8x16_t input_vec = vld1q_u8((const uint8_t*)&message[i]);\n        uint8x16_t output_vec = input_vec;\n\n        // Swap case\n        uint8x16_t lowercase_mask = vandq_u8(input_vec, vdupq_n_u8(0xDF)); // Keep only bits that matter for case\n        lowercase_mask = vceqq_u8(lowercase_mask, input_vec); // Check if char is already uppercase\n        uint8x16_t case_swap_mask = vandq_u8(lowercase_mask, vcltq_u8(input_vec, vdupq_n_u8('a'))); // Check if char is a letter\n        case_swap_mask = vmvnq_u8(case_swap_mask); // Invert mask\n        output_vec = veorq_u8(output_vec, vandq_u8(case_swap_mask, vdupq_n_u8(32))); // XOR with 32 to swap case\n\n        // Replace vowels\n        uint8x16_t a_mask = vceqq_u8(input_vec, vdupq_n_u8('a'));\n        uint8x16_t e_mask = vceqq_u8(input_vec, vdupq_n_u8('e'));\n        uint8x16_t i_mask = vceqq_u8(input_vec, vdupq_n_u8('i'));\n        uint8x16_t o_mask = vceqq_u8(input_vec, vdupq_n_u8('o'));\n        uint8x16_t u_mask = vceqq_u8(input_vec, vdupq_n_u8('u'));\n        uint8x16_t A_mask = vceqq_u8(input_vec, vdupq_n_u8('A'));\n        uint8x16_t E_mask = vceqq_u8(input_vec, vdupq_n_u8('E'));\n        uint8x16_t I_mask = vceqq_u8(input_vec, vdupq_n_u8('I'));\n        uint8x16_t O_mask = vceqq_u8(input_vec, vdupq_n_u8('O'));\n        uint8x16_t U_mask = vceqq_u8(input_vec, vdupq_n_u8('U'));\n\n        output_vec = vbslq_u8(a_mask, vdupq_n_u8('c'), output_vec);\n        output_vec = vbslq_u8(e_mask, vdupq_n_u8('g'), output_vec);\n        output_vec = vbslq_u8(i_mask, vdupq_n_u8('k'), output_vec);\n        output_vec = vbslq_u8(o_mask, vdupq_n_u8('q'), output_vec);\n        output_vec = vbslq_u8(u_mask, vdupq_n_u8('w'), output_vec);\n        output_vec = vbslq_u8(A_mask, vdupq_n_u8('C'), output_vec);\n        output_vec = vbslq_u8(E_mask, vdupq_n_u8('G'), output_vec);\n        output_vec = vbslq_u8(I_mask, vdupq_n_u8('K'), output_vec);\n        output_vec = vbslq_u8(O_mask, vdupq_n_u8('Q'), output_vec);\n        output_vec = vbslq_u8(U_mask, vdupq_n_u8('W'), output_vec);\n\n        vst1q_u8((uint8_t*)&encoded_message[i], output_vec);\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = encoded_message[i];\n        if (isalpha(c)) {\n            if (islower(c)) {\n                encoded_message[i] = toupper(c);\n            } else {\n                encoded_message[i] = tolower(c);\n            }\n        }\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = encoded_message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char &c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            c = c - 32; // Convert to uppercase\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c + 32; // Convert to lowercase\n        }\n\n        // Replace vowels\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i + 15 < len; i += 16) {\n        uint8x16_t input_vec = vld1q_u8((const uint8_t*)&message[i]);\n        uint8x16_t output_vec = input_vec;\n\n        // Swap case\n        uint8x16_t lowercase_mask = vandq_u8(input_vec, vdupq_n_u8(0xDF)); // Keep only bits that matter for case\n        lowercase_mask = vceqq_u8(lowercase_mask, input_vec); // Check if the original char was lowercase\n        output_vec = veorq_u8(output_vec, vandq_u8(lowercase_mask, vdupq_n_u8(0x20))); // XOR with 0x20 to swap case\n\n        // Replace vowels\n        uint8x16_t a_mask = vceqq_u8(input_vec, vdupq_n_u8('a'));\n        uint8x16_t e_mask = vceqq_u8(input_vec, vdupq_n_u8('e'));\n        uint8x16_t i_mask = vceqq_u8(input_vec, vdupq_n_u8('i'));\n        uint8x16_t o_mask = vceqq_u8(input_vec, vdupq_n_u8('o'));\n        uint8x16_t u_mask = vceqq_u8(input_vec, vdupq_n_u8('u'));\n        uint8x16_t A_mask = vceqq_u8(input_vec, vdupq_n_u8('A'));\n        uint8x16_t E_mask = vceqq_u8(input_vec, vdupq_n_u8('E'));\n        uint8x16_t I_mask = vceqq_u8(input_vec, vdupq_n_u8('I'));\n        uint8x16_t O_mask = vceqq_u8(input_vec, vdupq_n_u8('O'));\n        uint8x16_t U_mask = vceqq_u8(input_vec, vdupq_n_u8('U'));\n\n        output_vec = vbslq_u8(a_mask, vdupq_n_u8('c'), output_vec);\n        output_vec = vbslq_u8(e_mask, vdupq_n_u8('g'), output_vec);\n        output_vec = vbslq_u8(i_mask, vdupq_n_u8('k'), output_vec);\n        output_vec = vbslq_u8(o_mask, vdupq_n_u8('q'), output_vec);\n        output_vec = vbslq_u8(u_mask, vdupq_n_u8('w'), output_vec);\n        output_vec = vbslq_u8(A_mask, vdupq_n_u8('C'), output_vec);\n        output_vec = vbslq_u8(E_mask, vdupq_n_u8('G'), output_vec);\n        output_vec = vbslq_u8(I_mask, vdupq_n_u8('K'), output_vec);\n        output_vec = vbslq_u8(O_mask, vdupq_n_u8('Q'), output_vec);\n        output_vec = vbslq_u8(U_mask, vdupq_n_u8('W'), output_vec);\n\n        vst1q_u8((uint8_t*)&encoded_message[i], output_vec);\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = encoded_message[i];\n        if (isalpha(c)) {\n            if (islower(c)) {\n                encoded_message[i] = toupper(c);\n            } else {\n                encoded_message[i] = tolower(c);\n            }\n        }\n        \n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = encoded_message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char &c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            c = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c + 32;\n        }\n\n        // Replace vowels\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = encoded_message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char &c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            c = c - 32; // Convert to uppercase\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c + 32; // Convert to lowercase\n        }\n\n        // Replace vowels\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (auto const& [key, val] : dict) {\n    const std::string& k = key;\n    const char* str = k.c_str();\n    size_t len = k.length();\n\n    if (len == 0) continue;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n      uint8x16_t v = vld1q_u8((const uint8_t*)(str + i));\n      uint8x16_t lower_bound = vdupq_n_u8('a');\n      uint8x16_t upper_bound = vdupq_n_u8('z');\n      uint8x16_t upper_lower_bound = vdupq_n_u8('A');\n      uint8x16_t upper_upper_bound = vdupq_n_u8('Z');\n      uint8x16_t zero = vdupq_n_u8(0);\n\n      uint8x16_t is_lower = vandq_u8(vcgeq_u8(v, lower_bound), vcleq_u8(v, upper_bound));\n      uint8x16_t is_upper = vandq_u8(vcgeq_u8(v, upper_lower_bound), vcleq_u8(v, upper_upper_bound));\n      uint8x16_t is_alpha = vorrq_u8(is_lower, is_upper);\n      \n      if (vmaxvq_u8(is_lower) == 0) key_all_lower = false;\n      if (vmaxvq_u8(is_upper) == 0) key_all_upper = false;\n      if (vmaxvq_u8(is_alpha) == 0) {\n          key_all_lower = false;\n          key_all_upper = false;\n      }\n    }\n\n    for (; i < len; ++i) {\n      if (str[i] >= 'a' && str[i] <= 'z') {\n        // Lowercase\n      } else if (str[i] >= 'A' && str[i] <= 'Z') {\n        // Uppercase\n      } else {\n        key_all_lower = false;\n        key_all_upper = false;\n        break;\n      }\n      if (!(str[i] >= 'a' && str[i] <= 'z')) key_all_lower = false;\n      if (!(str[i] >= 'A' && str[i] <= 'Z')) key_all_upper = false;\n    }\n\n    all_lower &= key_all_lower;\n    all_upper &= key_all_upper;\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    const char* key_ptr = key.c_str();\n    size_t key_len = key.length();\n\n    if (key_len == 0) return false;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    size_t i = 0;\n    for (; i + 16 <= key_len; i += 16) {\n      uint8x16_t chars = vld1q_u8((const uint8_t*)(key_ptr + i));\n      uint8x16_t lower_mask = vandq_u8(chars, vdupq_n_u8(0xDF)); \n      uint8x16_t upper_mask = vorrq_u8(chars, vdupq_n_u8(0x20));\n\n      uint8x16_t is_lower = vceqq_u8(chars, lower_mask);\n      uint8x16_t is_upper = vceqq_u8(chars, upper_mask);\n\n      if (vmaxvq_u8(is_lower) == 0) key_all_lower = false;\n      if (vmaxvq_u8(is_upper) == 0) key_all_upper = false;\n\n      if (!key_all_lower && !key_all_upper) break;\n    }\n\n    if (i < key_len && (key_all_lower || key_all_upper)) {\n        for (; i < key_len; ++i) {\n            if (key_all_lower && !(key_ptr[i] >= 'a' && key_ptr[i] <= 'z')) {\n                key_all_lower = false;\n            }\n            if (key_all_upper && !(key_ptr[i] >= 'A' && key_ptr[i] <= 'Z')) {\n                key_all_upper = false;\n            }\n            if (!key_all_lower && !key_all_upper) break;\n        }\n    }\n\n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    const char* key_ptr = key.c_str();\n    size_t key_len = key.length();\n\n    if (key_len == 0) {\n      return false;\n    }\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    size_t i = 0;\n    for (; i + 16 <= key_len; i += 16) {\n      uint8x16_t chars = vld1q_u8((const uint8_t*)(key_ptr + i));\n      uint8x16_t lower_mask = vandq_u8(chars, vdupq_n_u8(0xDF)); \n      uint8x16_t upper_mask = vorrq_u8(chars, vdupq_n_u8(0x20));\n\n      uint8x16_t lower_cmp = vceqq_u8(chars, lower_mask);\n      uint8x16_t upper_cmp = vceqq_u8(chars, upper_mask);\n\n      if (vmaxvq_u8(lower_cmp) != 0xFF) {\n        key_all_lower = false;\n      }\n      if (vmaxvq_u8(upper_cmp) != 0xFF) {\n        key_all_upper = false;\n      }\n    }\n\n    for (; i < key_len; ++i) {\n      if (key_ptr[i] < 'A' || (key_ptr[i] > 'Z' && key_ptr[i] < 'a') || key_ptr[i] > 'z') {\n          return false;\n      }\n      if (key_ptr[i] >= 'A' && key_ptr[i] <= 'Z') {\n        key_all_lower = false;\n      } else if (key_ptr[i] >= 'a' && key_ptr[i] <= 'z') {\n        key_all_upper = false;\n      }\n    }\n\n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    const char* key_ptr = key.c_str();\n    size_t key_len = key.length();\n\n    if (key_len == 0) {\n      return false;\n    }\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    size_t i = 0;\n    for (; i + 16 <= key_len; i += 16) {\n      uint8x16_t chars = vld1q_u8((const uint8_t*)(key_ptr + i));\n      uint8x16_t lower_mask = vandq_u8(chars, vdupq_n_u8(0xDF)); \n      uint8x16_t upper_mask = vorrq_u8(chars, vdupq_n_u8(0x20));\n\n      uint8x16_t is_lower = vceqq_u8(chars, lower_mask);\n      uint8x16_t is_upper = vceqq_u8(chars, upper_mask);\n\n      if (vmaxvq_u8(is_lower) == 0) {\n        key_all_lower = false;\n      }\n      if (vmaxvq_u8(is_upper) == 0) {\n        key_all_upper = false;\n      }\n      if (!key_all_lower && !key_all_upper) break;\n    }\n\n    if (i < key_len && (key_all_lower || key_all_upper)) {\n        for (; i < key_len; ++i) {\n            if (key[i] < 'a' || key[i] > 'z') {\n                key_all_lower = false;\n            }\n            if (key[i] < 'A' || key[i] > 'Z') {\n                key_all_upper = false;\n            }\n            if (!key_all_lower && !key_all_upper) break;\n        }\n    }\n    \n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    const char* key_str = key.c_str();\n    size_t key_len = key.length();\n\n    if (key_len == 0) {\n      return false;\n    }\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    size_t i = 0;\n    for (; i + 16 <= key_len; i += 16) {\n      uint8x16_t chars = vld1q_u8((const uint8_t*)(key_str + i));\n      uint8x16_t lower_bound = vdupq_n_u8('a');\n      uint8x16_t upper_bound = vdupq_n_u8('z');\n      uint8x16_t upper_bound_upper = vdupq_n_u8('A');\n      uint8x16_t lower_bound_upper = vdupq_n_u8('Z');\n      \n      uint8x16_t is_lower = vandq_u8(vcgeq_u8(chars, lower_bound), vcleq_u8(chars, upper_bound));\n      uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, upper_bound_upper), vcleq_u8(chars, lower_bound_upper));\n\n      if (vmaxvq_u8(is_lower) == 0) {\n        key_all_lower = false;\n      }\n      if (vmaxvq_u8(is_upper) == 0) {\n        key_all_upper = false;\n      }\n    }\n\n    for (; i < key_len; ++i) {\n      if (key_str[i] < 'a' || key_str[i] > 'z') {\n        key_all_lower = false;\n      }\n      if (key_str[i] < 'A' || key_str[i] > 'Z') {\n        key_all_upper = false;\n      }\n    }\n\n    all_lower &= key_all_lower;\n    all_upper &= key_all_upper;\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n\n    if (n == 2) {\n        return primes;\n    }\n\n    primes.push_back(2);\n\n    for (int i = 3; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n\n    if (n == 2) {\n        return primes;\n    }\n\n    primes.push_back(2);\n\n    for (int i = 3; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n\n    if (n == 2) {\n        return primes;\n    }\n\n    primes.push_back(2);\n\n    for (int i = 3; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i += 8) {\n        if (i + 7 < len) {\n            uint8x8_t str = vld1_u8((const uint8_t*)(s.c_str() + i));\n            uint8x8_t mask_A = vceq_u8(str, vdup_n_u8('A'));\n            uint8x8_t mask_E = vceq_u8(str, vdup_n_u8('E'));\n            uint8x8_t mask_I = vceq_u8(str, vdup_n_u8('I'));\n            uint8x8_t mask_O = vceq_u8(str, vdup_n_u8('O'));\n            uint8x8_t mask_U = vceq_u8(str, vdup_n_u8('U'));\n\n            uint8x8_t mask_vowels = vorr_u8(vorr_u8(mask_A, mask_E), vorr_u8(mask_I, mask_O));\n            mask_vowels = vorr_u8(mask_vowels, mask_U);\n\n            uint8x8_t mask_even = {1, 0, 1, 0, 1, 0, 1, 0};\n            uint8x8_t mask_even_indices = vand_u8(mask_vowels, mask_even);\n\n            uint8_t temp[8];\n            vst1_u8(temp, mask_even_indices);\n\n            for (int j = 0; j < 8; ++j) {\n                if (temp[j] != 0) {\n                    count++;\n                }\n            }\n        } else {\n            for (int j = i; j < len; j += 2) {\n                if (s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i += 8) {\n        if (i + 7 < len) {\n            uint8x8_t str = vld1_u8((const uint8_t*)(s.data() + i));\n            uint8x8_t index = vdup_n_u8(0);\n\n            uint8x8_t mask_A = vceq_u8(str, vdup_n_u8('A'));\n            uint8x8_t mask_E = vceq_u8(str, vdup_n_u8('E'));\n            uint8x8_t mask_I = vceq_u8(str, vdup_n_u8('I'));\n            uint8x8_t mask_O = vceq_u8(str, vdup_n_u8('O'));\n            uint8x8_t mask_U = vceq_u8(str, vdup_n_u8('U'));\n\n            uint8x8_t vowels = vorr_u8(vorr_u8(mask_A, mask_E), vorr_u8(mask_I, vorr_u8(mask_O, mask_U)));\n\n            uint8x8_t even_indices = vdup_n_u8(0);\n            uint8_t even_values[] = {1, 0, 1, 0, 1, 0, 1, 0};\n            even_indices = vld1_u8(even_values);\n\n            uint8x8_t masked_vowels = vand_u8(vowels, even_indices);\n\n            uint8_t temp[8];\n            vst1_u8(temp, masked_vowels);\n\n            for (int j = 0; j < 8; ++j) {\n                count += temp[j];\n            }\n        } else {\n            for (int j = i; j < len; j += 2) {\n                if (s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i += 8) {\n        if (i + 7 < len) {\n            uint8x8_t str = vld1_u8((const uint8_t*)(s.c_str() + i));\n            uint8x8_t mask_A = vceq_u8(str, vdup_n_u8('A'));\n            uint8x8_t mask_E = vceq_u8(str, vdup_n_u8('E'));\n            uint8x8_t mask_I = vceq_u8(str, vdup_n_u8('I'));\n            uint8x8_t mask_O = vceq_u8(str, vdup_n_u8('O'));\n            uint8x8_t mask_U = vceq_u8(str, vdup_n_u8('U'));\n\n            uint8x8_t mask_vowels = vorr_u8(vorr_u8(mask_A, mask_E), vorr_u8(mask_I, mask_O));\n            mask_vowels = vorr_u8(mask_vowels, mask_U);\n\n            uint8x8_t mask_even = {1, 0, 1, 0, 1, 0, 1, 0};\n            uint8x8_t mask_even_indices = vand_u8(mask_vowels, mask_even);\n\n            uint8_t temp[8];\n            vst1_u8(temp, mask_even_indices);\n\n            for (int j = 0; j < 8; ++j) {\n                if (temp[j] != 0) {\n                    count++;\n                }\n            }\n        } else {\n            for (int j = i; j < len; j += 2) {\n                if (s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i += 8) {\n        if (i + 7 < len) {\n            uint8x8_t str = vld1_u8((const uint8_t*)(s.c_str() + i));\n            uint8x8_t index = vdup_n_u8(0);\n            uint8x8_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n            uint8x8_t masked_str = vand_u8(str, even_mask);\n\n            uint8x8_t A = vdup_n_u8('A');\n            uint8x8_t E = vdup_n_u8('E');\n            uint8x8_t I = vdup_n_u8('I');\n            uint8x8_t O = vdup_n_u8('O');\n            uint8x8_t U = vdup_n_u8('U');\n\n            uint8x8_t cmpA = vceq_u8(masked_str, A);\n            uint8x8_t cmpE = vceq_u8(masked_str, E);\n            uint8x8_t cmpI = vceq_u8(masked_str, I);\n            uint8x8_t cmpO = vceq_u8(masked_str, O);\n            uint8x8_t cmpU = vceq_u8(masked_str, U);\n\n            uint8x8_t or1 = vorr_u8(cmpA, cmpE);\n            uint8x8_t or2 = vorr_u8(cmpI, cmpO);\n            uint8x8_t or3 = vorr_u8(or1, or2);\n            uint8x8_t or4 = vorr_u8(or3, cmpU);\n\n            uint8_t result[8];\n            vst1_u8(result, or4);\n\n            for (int j = 0; j < 8; ++j) {\n                if (result[j]) {\n                    count++;\n                }\n            }\n        } else {\n            for (int j = i; j < len; ++j) {\n                if (j % 2 == 0 && s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    if (len == 0) return 0;\n\n    for (int i = 0; i < len; i += 8) {\n        if (i + 7 < len) {\n            uint8x8_t str = vld1_u8((const uint8_t*)(s.c_str() + i));\n            uint8x8_t mask_A = vceq_u8(str, vdup_n_u8('A'));\n            uint8x8_t mask_E = vceq_u8(str, vdup_n_u8('E'));\n            uint8x8_t mask_I = vceq_u8(str, vdup_n_u8('I'));\n            uint8x8_t mask_O = vceq_u8(str, vdup_n_u8('O'));\n            uint8x8_t mask_U = vceq_u8(str, vdup_n_u8('U'));\n\n            uint8x8_t mask_vowels = vorr_u8(vorr_u8(mask_A, mask_E), vorr_u8(mask_I, mask_O));\n            mask_vowels = vorr_u8(mask_vowels, mask_U);\n\n            uint8x8_t mask_even = {1, 0, 1, 0, 1, 0, 1, 0};\n            uint8x8_t mask_even_indices = vand_u8(mask_vowels, mask_even);\n\n            uint8_t temp[8];\n            vst1_u8(temp, mask_even_indices);\n\n            for (int j = 0; j < 8; ++j) {\n                if (temp[j] != 0) {\n                    count++;\n                }\n            }\n        } else {\n            for (int j = i; j < len; j += 2) {\n                if (s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64_t remainder = count % 4;\n    int64_t vectorized_count = count - remainder;\n\n    int64_t i = n;\n    if (vectorized_count > 0) {\n        int64x2_t vec_sum = vdupq_n_s64(0);\n        for (; i < n + vectorized_count; i += 2) {\n            int64x2_t vec_i = vcreate_s64(i | ((i + 1) << 32));\n            vec_sum = vaddq_s64(vec_sum, vec_i);\n        }\n        sum += vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    }\n\n    for (; i <= m; ++i) {\n        sum += i;\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64_t loop_count = count / 8;\n    int64_t remainder = count % 8;\n\n    int64x2_t vec_sum = vdupq_n_s64(0);\n    int64x2_t vec_index = vld1q_s64(&n);\n    int64x2_t vec_increment = vdupq_n_s64(1);\n\n    for (int64_t i = 0; i < loop_count; ++i) {\n        int64x2_t vec1 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec1);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec2 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec2);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec3 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec3);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec4 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec4);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n    }\n\n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    n = vgetq_lane_s64(vec_index, 0);\n\n    for (int64_t i = 0; i < remainder; ++i) {\n        sum += n;\n        n++;\n    }\n    \n    int64_t avg = (sum + count / 2) / count;\n\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    // Use NEON to accelerate the summation if the range is large enough\n    if (count >= 8) {\n        int64_t i = n;\n        int64_t remaining = count % 8;\n\n        int64x2_t vec_sum = vdupq_n_s64(0);\n        for (; i <= m - remaining; i += 8) {\n            int64x2_t vec1 = vld1q_s64(&i);\n            int64x2_t vec2 = vld1q_s64(&i + 2);\n            int64x2_t vec3 = vld1q_s64(&i + 4);\n            int64x2_t vec4 = vld1q_s64(&i + 6);\n\n            vec_sum = vaddq_s64(vec_sum, vec1);\n            vec_sum = vaddq_s64(vec_sum, vec2);\n            vec_sum = vaddq_s64(vec_sum, vec3);\n            vec_sum = vaddq_s64(vec_sum, vec4);\n        }\n\n        sum += vgetq_lane_s64(vec_sum, 0);\n        sum += vgetq_lane_s64(vec_sum, 1);\n\n        sum += vgetq_lane_s64(vec_sum, 2);\n        sum += vgetq_lane_s64(vec_sum, 3);\n\n        sum += vgetq_lane_s64(vec_sum, 4);\n        sum += vgetq_lane_s64(vec_sum, 5);\n\n        sum += vgetq_lane_s64(vec_sum, 6);\n        sum += vgetq_lane_s64(vec_sum, 7);\n        \n        i = m - remaining + 1;\n        for (; i <= m; ++i) {\n            sum += i;\n        }\n    } else {\n        for (int64_t i = n; i <= m; ++i) {\n            sum += i;\n        }\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64_t loop_count = count / 8;\n    int64_t remainder = count % 8;\n\n    int64x2_t vec_sum = vdupq_n_s64(0);\n    int64x2_t vec_index = vld1q_s64(&n);\n    int64x2_t vec_increment = vdupq_n_s64(1);\n\n    for (int64_t i = 0; i < loop_count; ++i) {\n        int64x2_t vec1 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec1);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec2 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec2);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec3 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec3);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n\n        int64x2_t vec4 = vec_index;\n        vec_sum = vaddq_s64(vec_sum, vec4);\n        vec_index = vaddq_s64(vec_index, vec_increment);\n    }\n\n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    n = vgetq_lane_s64(vec_index, 0);\n\n    for (int64_t i = 0; i < remainder; ++i) {\n        sum += n;\n        n++;\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64_t loop_count = count / 8;\n    int64_t remainder = count % 8;\n\n    int64x2_t vec_sum = vdupq_n_s64(0);\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_inc = vdupq_n_s64(1);\n\n    for (int64_t i = 0; i < loop_count; ++i) {\n        int64x2_t vec1 = vec_n;\n        vec_sum = vaddq_s64(vec_sum, vec1);\n        vec_n = vaddq_s64(vec_n, vec_inc);\n\n        int64x2_t vec2 = vec_n;\n        vec_sum = vaddq_s64(vec_sum, vec2);\n        vec_n = vaddq_s64(vec_n, vec_inc);\n\n        int64x2_t vec3 = vec_n;\n        vec_sum = vaddq_s64(vec_sum, vec3);\n        vec_n = vaddq_s64(vec_n, vec_inc);\n\n        int64x2_t vec4 = vec_n;\n        vec_sum = vaddq_s64(vec_sum, vec4);\n        vec_n = vaddq_s64(vec_n, vec_inc);\n    }\n\n    int64_t temp_sum[2];\n    vst1q_s64(temp_sum, vec_sum);\n    sum = temp_sum[0] + temp_sum[1];\n\n    n = n + loop_count * 4 * 2;\n\n    for (int64_t i = 0; i < remainder; ++i) {\n        sum += n;\n        n++;\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n\n    int16x8_t even_indices = {2, 4, 6, 8, 10, 12, 14, 16};\n    int16x8_t odd_indices = {1, 3, 5, 7, 9, 11, 13, 15};\n    int16x8_t ones = {1, 1, 1, 1, 1, 1, 1, 1};\n\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n\n    int16x8_t even_indices = {2, 4, 6, 8, 10, 12, 14, 16};\n    int16x8_t odd_indices = {1, 3, 5, 7, 9, 11, 13, 15};\n    int16x8_t ones = {1, 1, 1, 1, 1, 1, 1, 1};\n\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n\n    int16x8_t even_indices = {2, 4, 6, 8, 10, 12, 14, 16};\n    int16x8_t odd_indices = {1, 3, 5, 7, 9, 11, 13, 15};\n    int16x8_t ones = {1, 1, 1, 1, 1, 1, 1, 1};\n\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    int fact = 1;\n    int sum = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact = (fact * j) % 10000;\n            }\n            result[i - 1] = fact;\n        } else {\n            sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    int fact = 1;\n    int sum = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact = (fact * j) % 10000;\n            }\n            result[i - 1] = fact;\n        } else {\n            sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n\n        if (s == reversed_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t vec = vld1q_s32(&n[i]);\n            int32x4_t sum_vec = vdupq_n_s32(0);\n\n            int32x4_t temp_vec = vec;\n            int32x4_t sign_vec = vcltzq_s32(vec); \n\n            int32x4_t abs_vec = vbslq_s32(sign_vec, vnegq_s32(vec), vec);\n\n            int32x4_t num1000 = vdivq_s32(abs_vec, vdupq_n_s32(1000));\n            sum_vec = vaddq_s32(sum_vec, num1000);\n            abs_vec = vsubq_s32(abs_vec, vmulq_s32(num1000, vdupq_n_s32(1000)));\n\n            int32x4_t num100 = vdivq_s32(abs_vec, vdupq_n_s32(100));\n            sum_vec = vaddq_s32(sum_vec, num100);\n            abs_vec = vsubq_s32(abs_vec, vmulq_s32(num100, vdupq_n_s32(100)));\n\n            int32x4_t num10 = vdivq_s32(abs_vec, vdupq_n_s32(10));\n            sum_vec = vaddq_s32(sum_vec, num10);\n            abs_vec = vsubq_s32(abs_vec, vmulq_s32(num10, vdupq_n_s32(10)));\n\n            sum_vec = vaddq_s32(sum_vec, abs_vec);\n\n            int gt0_mask = vgetq_lane_s32(sum_vec, 0) > 0;\n            count += gt0_mask;\n            gt0_mask = vgetq_lane_s32(sum_vec, 1) > 0;\n            count += gt0_mask;\n            gt0_mask = vgetq_lane_s32(sum_vec, 2) > 0;\n            count += gt0_mask;\n            gt0_mask = vgetq_lane_s32(sum_vec, 3) > 0;\n            count += gt0_mask;\n        }\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int temp = abs(num);\n        \n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            int temp_num = abs(num);\n            int pow10 = 1;\n            while (temp_num >= 10) {\n                temp_num /= 10;\n                pow10 *= 10;\n            }\n            sum += (num / pow10);\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t sum = vdupq_n_s32(0);\n\n        int32x4_t temp_nums = nums;\n        int32x4_t sign = vdupq_n_s32(1);\n\n        int32x4_t abs_nums = vabsq_s32(temp_nums);\n\n        int32x4_t digit1 = vdivq_s32(abs_nums, vdupq_n_s32(1));\n        sum = vsubq_s32(sum, vmulq_s32(sign, vdivq_s32(abs_nums, vdupq_n_s32(1000))));\n        abs_nums = vmodq_s32(abs_nums, vdupq_n_s32(1000));\n\n        sum = vaddq_s32(sum, vdivq_s32(abs_nums, vdupq_n_s32(100)));\n        abs_nums = vmodq_s32(abs_nums, vdupq_n_s32(100));\n\n        sum = vaddq_s32(sum, vdivq_s32(abs_nums, vdupq_n_s32(10)));\n        abs_nums = vmodq_s32(abs_nums, vdupq_n_s32(10));\n\n        sum = vaddq_s32(sum, abs_nums);\n\n        uint32x4_t mask = vcgtq_s32(sum, vdupq_n_s32(0));\n        count += vcnt_u32(vget_low_u32(mask)) + vcnt_u32(vget_high_u32(mask));\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n\n        int temp_num = abs(num);\n\n        sum -= sign * (temp_num / 1000);\n        temp_num %= 1000;\n\n        sum += (temp_num / 100);\n        temp_num %= 100;\n\n        sum += (temp_num / 10);\n        temp_num %= 10;\n\n        sum += temp_num;\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t sum = vdupq_n_s32(0);\n\n        int32x4_t temp_nums = nums;\n        int32x4_t sign = vdupq_n_s32(1);\n\n        int32x4_t abs_nums = vabsq_s32(temp_nums);\n\n        int32x4_t digit1 = vdivq_s32(abs_nums, vdupq_n_s32(1000));\n        abs_nums = vsubq_s32(abs_nums, vmulq_s32(digit1, vdupq_n_s32(1000)));\n        sum = vaddq_s32(sum, vmulq_s32(digit1, sign));\n        temp_nums = vsubq_s32(temp_nums, vmulq_s32(digit1, vdupq_n_s32(1000)));\n\n        int32x4_t digit2 = vdivq_s32(abs_nums, vdupq_n_s32(100));\n        abs_nums = vsubq_s32(abs_nums, vmulq_s32(digit2, vdupq_n_s32(100)));\n        sum = vaddq_s32(sum, digit2);\n        temp_nums = vsubq_s32(temp_nums, vmulq_s32(digit2, vdupq_n_s32(100)));\n\n        int32x4_t digit3 = vdivq_s32(abs_nums, vdupq_n_s32(10));\n        abs_nums = vsubq_s32(abs_nums, vmulq_s32(digit3, vdupq_n_s32(10)));\n        sum = vaddq_s32(sum, digit3);\n        temp_nums = vsubq_s32(temp_nums, vmulq_s32(digit3, vdupq_n_s32(10)));\n\n        int32x4_t digit4 = abs_nums;\n        sum = vaddq_s32(sum, digit4);\n\n        uint32x4_t mask = vcgtq_s32(sum, vdupq_n_s32(0));\n        uint32_t temp_count = vcntq_u32(mask);\n        count += temp_count;\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n        int temp_num = num;\n        num = abs(num);\n\n        sum += (num / 1000) * sign;\n        num %= 1000;\n        sum += (num / 100);\n        num %= 100;\n        sum += (num / 10);\n        num %= 10;\n        sum += num;\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t vec = vld1q_s32(&n[i]);\n            int32x4_t sum_vec = vdupq_n_s32(0);\n\n            int32x4_t temp_vec = vec;\n            int32x4_t sign_vec = vcltzq_s32(vec);\n            int32x4_t abs_vec = vbslq_s32(sign_vec, vnegq_s32(vec), vec);\n\n            int32x4_t num1_vec = vdivq_s32(abs_vec, vdupq_n_s32(1));\n\n            int32x4_t digit1_vec = vmulq_s32(vdivq_s32(abs_vec, vdupq_n_s32(1000)), vdupq_n_s32(1000));\n            int32x4_t digit2_vec = vmulq_s32(vdivq_s32(vsubq_s32(abs_vec, digit1_vec), vdupq_n_s32(100)), vdupq_n_s32(100));\n            int32x4_t digit3_vec = vmulq_s32(vdivq_s32(vsubq_s32(vsubq_s32(abs_vec, digit1_vec), digit2_vec), vdupq_n_s32(10)), vdupq_n_s32(10));\n            int32x4_t digit4_vec = vsubq_s32(vsubq_s32(vsubq_s32(vsubq_s32(abs_vec, digit1_vec), digit2_vec), digit3_vec), vmulq_s32(vdivq_s32(vsubq_s32(vsubq_s32(abs_vec, digit1_vec), digit2_vec), vdupq_n_s32(1)), vdupq_n_s32(1)));\n\n            int32x4_t d1_vec = vdivq_s32(abs_vec, vdupq_n_s32(1000));\n            int32x4_t d2_vec = vdivq_s32(vsubq_s32(abs_vec, vmulq_s32(d1_vec, vdupq_n_s32(1000))), vdupq_n_s32(100));\n            int32x4_t d3_vec = vdivq_s32(vsubq_s32(vsubq_s32(abs_vec, vmulq_s32(d1_vec, vdupq_n_s32(1000))), vmulq_s32(d2_vec, vdupq_n_s32(100))), vdupq_n_s32(10));\n            int32x4_t d4_vec = vsubq_s32(vsubq_s32(vsubq_s32(abs_vec, vmulq_s32(d1_vec, vdupq_n_s32(1000))), vmulq_s32(d2_vec, vdupq_n_s32(100))), vmulq_s32(d3_vec, vdupq_n_s32(10)));\n\n            int32x4_t zero_vec = vdupq_n_s32(0);\n            int32x4_t first_digit_vec = vdivq_s32(vec, vdupq_n_s32(1000));\n            int32x4_t first_digit_abs_vec = vabsq_s32(first_digit_vec);\n            int32x4_t first_digit_signed_vec = vbslq_s32(sign_vec, vnegq_s32(first_digit_abs_vec), first_digit_abs_vec);\n\n            sum_vec = vaddq_s32(sum_vec, first_digit_signed_vec);\n            sum_vec = vaddq_s32(sum_vec, d2_vec);\n            sum_vec = vaddq_s32(sum_vec, d3_vec);\n            sum_vec = vaddq_s32(sum_vec, d4_vec);\n\n            uint32x4_t mask = vceqq_s32(sum_vec, zero_vec);\n            uint32x4_t not_mask = vmvnq_u32(mask);\n            uint32_t temp_count = vcntq_u32(not_mask);\n            count += temp_count;\n        }\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int temp = abs(num);\n        int sign = (num < 0) ? -1 : 1;\n\n        if (num < -999 || num > 999){\n            sum += (num / 1000) * sign;\n            temp = abs(num);\n            sum += (temp / 100) % 10;\n            sum += (temp / 10) % 10;\n            sum += temp % 10;\n        }\n        else if (num < -99 || num > 99){\n            sum += (num / 100) * sign;\n            temp = abs(num);\n            sum += (temp / 10) % 10;\n            sum += temp % 10;\n        }\n        else if (num < -9 || num > 9){\n            sum += (num / 10) * sign;\n            temp = abs(num);\n            sum += temp % 10;\n        }\n        else{\n            sum += num;\n        }\n\n        if (sum != 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t vec = vld1q_s32(&n[i]);\n            int32x4_t sum_vec = vdupq_n_s32(0);\n\n            int32x4_t temp_vec = vec;\n            int32x4_t sign_vec = vcltzq_s32(vec); \n\n            int32x4_t abs_vec = vbslq_s32(sign_vec, vnegq_s32(vec), vec);\n\n            int32x4_t num1_vec = vdivq_s32(abs_vec, vdupq_n_s32(1));\n\n            int32x4_t digit1_vec = vmodq_s32(abs_vec, vdupq_n_s32(10));\n\n            int32x4_t is_negative_vec = vcltzq_s32(vec);\n            digit1_vec = vbslq_s32(is_negative_vec, vnegq_s32(digit1_vec), digit1_vec);\n\n            sum_vec = vaddq_s32(sum_vec, digit1_vec);\n\n            uint32x4_t gt_zero = vcgtq_s32(sum_vec, vdupq_n_s32(0));\n            uint32_t mask = vgetq_lane_u32(gt_zero, 0) | (vgetq_lane_u32(gt_zero, 1) << 1) |\n                            (vgetq_lane_u32(gt_zero, 2) << 2) | (vgetq_lane_u32(gt_zero, 3) << 3);\n\n            count += __builtin_popcount(mask);\n        }\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int temp = num;\n        int sign = 1;\n        if (temp < 0) {\n            sign = -1;\n            temp = -temp;\n        }\n        \n        int digit = (temp % 10) * sign;\n        sum += digit;\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n\n    // Count odd numbers in lst1\n    for (int i = 0; i < n1; ++i) {\n        if (lst1[i] % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int i = 0; i < n2; ++i) {\n        if (lst2[i] % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    if (even_count_lst2 >= odd_count_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n\n    // Count odd numbers in lst1\n    for (int i = 0; i < n1; ++i) {\n        if (lst1[i] % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int i = 0; i < n2; ++i) {\n        if (lst2[i] % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    if (even_count_lst2 >= odd_count_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t vec = vld1q_u8((const uint8_t*)(str.data() + i));\n                uint8x16_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n                uint8x16_t digit_mask = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};\n                uint8x16_t digits = vsubq_u8(vec, digit_mask);\n                uint8x16_t and_result = vandq_u8(digits, odd_mask);\n                uint8x16_t cmp_result = vceqq_u8(and_result, odd_mask);\n                uint64x2_t sum_parts = vpaddlq_u32(vmovl_u16(vadd_u16(vget_low_u8(cmp_result), vget_high_u8(cmp_result))));\n                count += vgetq_lane_u64(sum_parts, 0) + vgetq_lane_u64(sum_parts, 1);\n            }\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t vec = vld1q_u8((const uint8_t*)(str.data() + i));\n                uint8x16_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n                uint8x16_t digit_mask = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};\n                uint8x16_t digits = veorq_u8(vec, digit_mask);\n                uint8x16_t and_result = vandq_u8(digits, odd_mask);\n                uint8x16_t cmp_result = vceqq_u8(and_result, odd_mask);\n                uint64x2_t sum_parts = vpaddlq_u32(vmovl_u16(vpadal_u8(vdupq_n_u16(0), cmp_result)));\n                count += vgetq_lane_u64(sum_parts, 0) + vgetq_lane_u64(sum_parts, 1);\n            }\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t vec = vld1q_u8((const uint8_t*)(str.data() + i));\n                uint8x16_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n                uint8x16_t digit_mask = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};\n                uint8x16_t digits = veorq_u8(vec, digit_mask);\n                uint8x16_t and_result = vandq_u8(digits, odd_mask);\n                uint8x16_t cmp_result = vceqzq_u8(and_result);\n                uint64x2_t reduced = vpaddlq_u32(vmovl_u16(vpadal_u8(vdupq_n_u8(0), cmp_result)));\n                uint64_t sum = vgetq_lane_u64(reduced, 0) + vgetq_lane_u64(reduced, 1);\n                count += 16 - sum;\n            }\n        }\n        \n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t vec = vld1q_u8((const uint8_t*)(str.data() + i));\n                uint8x16_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n                uint8x16_t digit_mask = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};\n                uint8x16_t digits = veorq_u8(vec, digit_mask);\n                uint8x16_t and_result = vandq_u8(digits, odd_mask);\n                uint8x16_t cmp_result = vceqzq_u8(and_result);\n                uint64x2_t reduced = vpaddlq_u32(vmovl_u16(vpadal_u8(vdupq_n_u16(0), cmp_result)));\n                count += 16 - (vgetq_lane_u64(reduced, 0) + vgetq_lane_u64(reduced, 1));\n            }\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t vec = vld1q_u8((const uint8_t*)(str.data() + i));\n                uint8x16_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n                uint8x16_t digit_mask = {0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30};\n                uint8x16_t digits = veorq_u8(vec, digit_mask);\n                uint8x16_t and_result = vandq_u8(digits, odd_mask);\n                uint8x16_t cmp_result = vceqzq_u8(and_result);\n                uint8x16_t ones = vdupq_n_u8(1);\n                uint8x16_t select_result = vbslq_u8(cmp_result, vdupq_n_u8(0), ones);\n\n                uint8x8_t low = vget_low_u8(select_result);\n                uint8x8_t high = vget_high_u8(select_result);\n\n                uint16x4_t sum_low = vpaddl_u8(low);\n                uint16x4_t sum_high = vpaddl_u8(high);\n\n                uint32x2_t sum_total_low = vpaddl_u16(sum_low);\n                uint32x2_t sum_total_high = vpaddl_u16(sum_high);\n\n                count += vget_lane_u32(sum_total_low, 0) + vget_lane_u32(sum_total_low, 1) + vget_lane_u32(sum_total_high, 0) + vget_lane_u32(sum_total_high, 1);\n            }\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    for (int64_t num : nums) {\n        current_min += num;\n        if (current_min > num) {\n            current_min = num;\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    for (int64_t num : nums) {\n        current_min += num;\n        if (current_min > num) {\n            current_min = num;\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    for (int64_t num : nums) {\n        current_min += num;\n        if (current_min > num) {\n            current_min = num;\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    for (int64_t num : nums) {\n        current_min += num;\n        if (current_min > num) {\n            current_min = num;\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    for(int i = 0; i < nums.size(); ++i){\n        current_min += nums[i];\n        if(current_min < min_so_far){\n            min_so_far = current_min;\n        }\n        if(current_min > 0){\n            current_min = 0;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_fills = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int row_sum = 0;\n        int j = 0;\n        \n        #if defined(__ARM_NEON__)\n        int const vector_size = 4;\n        int loop_end = cols - (cols % vector_size);\n\n        for (; j < loop_end; j += vector_size) {\n            int32x4_t vec = vld1q_s32(&grid[i][j]);\n            int32x4_t sum_vec = vpaddq_s32(vec, vec);\n            sum_vec = vpaddq_s32(sum_vec, sum_vec);\n            row_sum += vgetq_lane_s32(sum_vec, 0);\n        }\n        #endif\n\n        for (; j < cols; ++j) {\n            row_sum += grid[i][j];\n        }\n\n        total_fills += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for(int i = 0; i < rows; ++i){\n        int row_sum = 0;\n        int j = 0;\n        \n        // Process 4 elements at a time using SIMD\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t vec = vld1q_s32(&grid[i][j]); // Load 4 integers from the grid\n            int32x4_t sum_vec = vpaddlq_s16(vmovl_s16(vadd_s16(vmovn_s32(vec), vmovn_s32(vec)))); // Sum the 4 integers\n            row_sum += vgetq_lane_s32(sum_vec, 0); // Extract the sum from the vector\n        }\n\n        // Process remaining elements\n        for (; j < cols; ++j) {\n            row_sum += grid[i][j];\n        }\n\n        count += (row_sum + capacity - 1) / capacity;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int j = 0;\n        while (j < cols) {\n            int sum = 0;\n            \n            #ifdef __ARM_NEON__\n            int simd_lane = 4;\n            for(; j + simd_lane <= cols; j += simd_lane){\n                int8x4_t vec = vld1_s8(&grid[i][j]);\n                int total = 0;\n                for(int k = 0; k < simd_lane; ++k){\n                    total += (int8_t)vget_lane_s8(vec, k);\n                }\n                sum += total;\n            }\n            #endif\n            \n            for (; j < cols; ++j) {\n                sum += grid[i][j];\n            }\n\n            count += (sum + capacity - 1) / capacity;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int j = 0;\n        for (; j + 3 < cols; j += 4) {\n            int32x4_t vec = vld1q_s32(&grid[i][j]);\n            int sum = 0;\n            for(int k = 0; k < 4; ++k){\n                sum += grid[i][j+k];\n            }\n            count += (sum + capacity - 1) / capacity;\n        }\n        for (; j < cols; ++j) {\n            count += (grid[i][j] + capacity - 1) / capacity;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int j = 0;\n        for (; j + 3 < cols; j += 4) {\n            int32x4_t vec = vld1q_s32(&grid[i][j]);\n            int sum = 0;\n            sum += vgetq_lane_s32(vec, 0);\n            sum += vgetq_lane_s32(vec, 1);\n            sum += vgetq_lane_s32(vec, 2);\n            sum += vgetq_lane_s32(vec, 3);\n            count += (sum + capacity - 1) / capacity;\n        }\n        for (; j < cols; ++j) {\n            count += (grid[i][j] + capacity - 1) / capacity;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        if (i + 7 < n) {\n            int16x8_t vec = vld1q_s16(&lst[i]);\n            int16x8_t odd_mask = vmovq_n_s16(1);\n            odd_mask = veorq_s16(odd_mask, vec);\n            odd_mask = vandq_s16(odd_mask, vmovq_n_s16(1));\n\n            int32x4_t sum_low = vmull_s16(vget_low_s16(vec), vget_low_s16(odd_mask));\n            int32x4_t sum_high = vmull_s16(vget_high_s16(vec), vget_high_s16(odd_mask));\n\n            sum += vaddvq_s32(sum_low);\n            sum += vaddvq_s32(sum_high);\n        } else {\n            for (int j = i; j < n; ++j) {\n                if (j % 2 == 0 && lst[j] % 2 != 0) {\n                    sum += lst[j];\n                }\n            }\n            break;\n        }\n    }\n\n    int remaining = n % 8;\n    for(int i = n - remaining; i < n; ++i){\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        if (i + 7 < n) {\n            int16x8_t vec = vld1q_s16(&lst[i]);\n            int16x8_t odd_mask = vandq_s16(vec, vdupq_n_s16(1));\n            int16x8_t even_pos_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n            int16x8_t masked_vec = vandq_s16(odd_mask, even_pos_mask);\n\n            int32x4_t sum_low = vpaddlq_s16(vget_low_s16(masked_vec));\n            int32x4_t sum_high = vpaddlq_s16(vget_high_s16(masked_vec));\n            int32x4_t total_sum = vaddq_s32(sum_low, sum_high);\n\n            int64x2_t final_sum = vpaddlq_s32(total_sum);\n            sum += vgetq_lane_s64(final_sum, 0) + vgetq_lane_s64(final_sum, 1);\n\n        } else {\n            for (int j = i; j < n; ++j) {\n                if (j % 2 == 0 && lst[j] % 2 != 0) {\n                    sum += lst[j];\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        if (i + 7 < n) {\n            int16x8_t vec = vld1q_s16(&lst[i]);\n            int16x8_t odd_mask = vandq_s16(vec, vdupq_n_s16(1));\n            int64x2_t sum_vec = vdupq_n_s64(0);\n\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 0) & (i % 2 == 0 ? vgetq_lane_s16(odd_mask, 0) : 0)), sum_vec, 0);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 2) & ((i+2) % 2 == 0 ? vgetq_lane_s16(odd_mask, 2) : 0)), sum_vec, 0);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 4) & ((i+4) % 2 == 0 ? vgetq_lane_s16(odd_mask, 4) : 0)), sum_vec, 0);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 6) & ((i+6) % 2 == 0 ? vgetq_lane_s16(odd_mask, 6) : 0)), sum_vec, 0);\n\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 1) & ((i+1) % 2 == 0 ? vgetq_lane_s16(odd_mask, 1) : 0)), sum_vec, 1);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 3) & ((i+3) % 2 == 0 ? vgetq_lane_s16(odd_mask, 3) : 0)), sum_vec, 1);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 5) & ((i+5) % 2 == 0 ? vgetq_lane_s16(odd_mask, 5) : 0)), sum_vec, 1);\n            sum_vec = vsetq_lane_s64((int64_t)(vgetq_lane_s16(odd_mask, 7) & ((i+7) % 2 == 0 ? vgetq_lane_s16(odd_mask, 7) : 0)), sum_vec, 1);\n\n            sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n        } else {\n            for (int j = i; j < n; ++j) {\n                if (j % 2 == 0 && lst[j] % 2 != 0) {\n                    sum += lst[j];\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        if (i + 7 < n) {\n            int16x8_t vec = vld1q_s16(&lst[i]);\n            int16x8_t odd_mask = vandq_s16(vec, vdupq_n_s16(1));\n            int16x8_t even_pos_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n            int16x8_t masked_vec = vandq_s16(odd_mask, even_pos_mask);\n\n            int16_t temp_sum[8];\n            vst1q_s16(temp_sum, masked_vec);\n\n            for (int j = 0; j < 8; ++j) {\n                sum += temp_sum[j];\n            }\n        } else {\n            for (int j = i; j < n; ++j) {\n                if (j % 2 == 0 && lst[j] % 2 != 0) {\n                    sum += lst[j];\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        if (i + 7 < n) {\n            int16x8_t vec = vld1q_s16(&lst[i]);\n            int16x8_t odd_mask = vmovq_n_s16(1);\n            odd_mask = veorq_s16(odd_mask, vec);\n            odd_mask = vandq_s16(odd_mask, vmovq_n_s16(1));\n\n            int32x4_t sum_low = vmull_s16(vget_low_s16(vec), vget_low_s16(odd_mask));\n            int32x4_t sum_high = vmull_s16(vget_high_s16(vec), vget_high_s16(odd_mask));\n\n            sum += vaddvq_s32(sum_low);\n            sum += vaddvq_s32(sum_high);\n        } else {\n            for (int j = i; j < n; ++j) {\n                if (j % 2 == 0 && lst[j] % 2 != 0) {\n                    sum += lst[j];\n                }\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements using SIMD (Neon)\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]); // Load 4 integers into a vector\n        int32x4_t abs_vec = vabsq_s32(vec); // Absolute values\n\n        // Check if each element has at most two digits (abs(element) < 100)\n        int32x4_t mask = vcltq_s32(abs_vec, vdupq_n_s32(100));\n\n        // Extract the mask as an integer\n        uint32_t mask_int = vgetq_lane_u32(vreinterpretq_u32_s32(mask), 0) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 1) << 1) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 2) << 2) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 3) << 3);\n\n        // Add the elements that satisfy the condition\n        if (mask_int & 1) sum += arr[i];\n        if (mask_int & 2) sum += arr[i + 1];\n        if (mask_int & 4) sum += arr[i + 2];\n        if (mask_int & 8) sum += arr[i + 3];\n    }\n\n    // Process remaining elements sequentially\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SIMD\n    for (; i <= k - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        int32x4_t hundred = vdupq_n_s32(100);\n\n        int32x4_t less_than_100 = vcltq_s32(vec, hundred);\n        int32x4_t greater_than_9 = vcgeq_s32(vec, ten);\n        int32x4_t mask = vandq_s32(less_than_100, greater_than_9);\n\n        int32x4_t masked_vec = vandq_s32(vec, mask);\n\n        sum += vgetq_lane_s32(masked_vec, 0);\n        sum += vgetq_lane_s32(masked_vec, 1);\n        sum += vgetq_lane_s32(masked_vec, 2);\n        sum += vgetq_lane_s32(masked_vec, 3);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using SIMD\n    for (; i <= k - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        int32x4_t hundred = vdupq_n_s32(100);\n\n        int32x4_t lt_hundred = vcltq_s32(vec, hundred);\n\n        uint32x4_t mask = vmovn_u64(vreinterpretq_u64_s64(lt_hundred));\n\n        if (mask & 0x1) {\n            if (arr[i] < 100)\n                sum += arr[i];\n        }\n        if (mask & 0x2) {\n            if (arr[i+1] < 100)\n                sum += arr[i+1];\n        }\n        if (mask & 0x4) {\n            if (arr[i+2] < 100)\n                sum += arr[i+2];\n        }\n        if (mask & 0x8) {\n            if (arr[i+3] < 100)\n                sum += arr[i+3];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using SIMD\n    for (; i <= k - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]); // Load 4 integers into a vector\n        int32x4_t abs_vec = vabsq_s32(vec); // Take absolute value to handle negative numbers correctly\n\n        // Check if each element has at most two digits (abs(element) < 100)\n        int32x4_t cmp_vec = vcltq_s32(abs_vec, vdupq_n_s32(100)); // Compare with 100\n\n        // Extract the comparison results (1 if true, 0 if false)\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(cmp_vec), 0) |\n                        (vgetq_lane_u32(vreinterpretq_u32_s32(cmp_vec), 1) << 1) |\n                        (vgetq_lane_u32(vreinterpretq_u32_s32(cmp_vec), 2) << 2) |\n                        (vgetq_lane_u32(vreinterpretq_u32_s32(cmp_vec), 3) << 3);\n\n        // Add the elements that satisfy the condition\n        if (mask & 1) sum += arr[i];\n        if (mask & 2) sum += arr[i + 1];\n        if (mask & 4) sum += arr[i + 2];\n        if (mask & 8) sum += arr[i + 3];\n    }\n\n    // Process remaining elements sequentially\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SIMD\n    for (; i <= k - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]); // Load 4 integers into a vector\n        int32x4_t ten = vdupq_n_s32(10);\n        int32x4_t hundred = vdupq_n_s32(100);\n\n        // Check if elements are less than 100\n        uint32x4_t less_than_100 = vcltq_s32(vec, hundred);\n\n        // Extract elements less than 100\n        int32x4_t valid_elements = vandq_s32(vec, vreinterpretq_s32_u32(less_than_100));\n\n        // Add the valid elements to the sum\n        sum += vgetq_lane_s32(valid_elements, 0);\n        sum += vgetq_lane_s32(valid_elements, 1);\n        sum += vgetq_lane_s32(valid_elements, 2);\n        sum += vgetq_lane_s32(valid_elements, 3);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t current = vld1q_s32(&lst[i]);\n            int32x4_t next = vld1q_s32(&lst[i + 1]);\n            int32x4_t cmp = vcltq_s32(next, current);\n            if (vgetq_lane_s32(cmp, 0) || vgetq_lane_s32(cmp, 1) ||\n                vgetq_lane_s32(cmp, 2) || vgetq_lane_s32(cmp, 3)) {\n                return false;\n            }\n\n            // Check for duplicates\n            int32x4_t eq = vceqq_s32(current, next);\n            if (vgetq_lane_s32(eq, 0) || vgetq_lane_s32(eq, 1) ||\n                vgetq_lane_s32(eq, 2) || vgetq_lane_s32(eq, 3)) {\n                \n                if (i > 0 && lst[i-1] == lst[i]) return false;\n                if (i+4 < size && lst[i+3] == lst[i+4]) return false;\n                \n                for(int j = 0; j < 4; ++j){\n                    int count = 0;\n                    for(int k = 0; k < size; ++k){\n                        if(lst[i+j] == lst[k]) count++;\n                    }\n                    if(count > 1){\n                        \n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i+1]){\n            int count = 0;\n            for(int k = 0; k < size; ++k){\n                if(lst[i] == lst[k]) count++;\n            }\n            if(count > 2) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t current = vld1q_s32(&lst[i]);\n            int32x4_t next = vld1q_s32(&lst[i + 1]);\n            int32x4_t cmp = vcltq_s32(next, current);\n            if (vgetq_lane_s32(cmp, 0) != 0 || vgetq_lane_s32(cmp, 1) != 0 ||\n                vgetq_lane_s32(cmp, 2) != 0) {\n                return false;\n            }\n        }\n    }\n\n    for (; i < size - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    std::vector<int> counts(10000, 0);\n    for (int x : lst) {\n        counts[x]++;\n        if (counts[x] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next;\n        if (i + 4 < lst.size()) {\n             next = vld1q_s32(&lst[i]);\n        } else {\n            break;\n        }\n\n        int32x4_t shifted_current = vextq_s32(vdupq_n_s32(0), current, 1);\n        int32x4_t comparison = vcgtq_s32(shifted_current, current);\n        uint32x4_t result = vmvnq_u32(vceqq_s32(comparison, vdupq_n_s32(0)));\n\n        if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0 ||\n            vgetq_lane_u32(result, 2) == 0) {\n            return false;\n        }\n    }\n\n    for (; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n\n    std::vector<int> counts(1000, 0);\n    for (int x : lst) {\n        counts[x]++;\n    }\n\n    for (int count : counts) {\n        if (count > 1) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t current = vld1q_s32(&lst[i]);\n            int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n            int32x4_t cmp = vcltq_s32(next, current);\n\n            if (vgetq_lane_s32(cmp, 0) != 0 ||\n                vgetq_lane_s32(cmp, 1) != 0 ||\n                vgetq_lane_s32(cmp, 2) != 0) {\n                return false;\n            }\n\n            if (i > 0) {\n                if (lst[i] == lst[i-1]) return false;\n            }\n        }\n    }\n\n    for (; i < size - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (i > 0) {\n            if (lst[i] == lst[i-1]) return false;\n        }\n    }\n    if (size > 1 && lst[size-1] == lst[size-2]) return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            int32x4_t current = vld1q_s32(&lst[i]);\n            int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n            int32x4_t cmp = vcgtq_s32(current, next);\n\n            if (vmaxvq_s32(cmp) != 0) {\n                return false;\n            }\n\n            int dups = 0;\n            for (int j = 0; j < 4; ++j) {\n                for (int k = j + 1; k < 4; ++k) {\n                    if (lst[i + j] == lst[i + k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    for (; i < size - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (i > 0 && lst[i] == lst[i - 1]) {\n            int count = 0;\n            for(int j = 0; j < lst.size(); ++j){\n                if(lst[i] == lst[j]){\n                    count++;\n                }\n            }\n            if(count > 2){\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t size = arr.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        int16x8_t prod_signs_vec = vdupq_n_s16(1);\n        int32x4_t sum_magnitudes_vec = vdupq_n_s32(0);\n\n        for (; i <= size - 4; i += 4) {\n            int16x8_t data_vec = vld1q_s16((int16_t*)&arr[i]);\n\n            int16x8_t sign_vec = vcleq_s16(data_vec, vdupq_n_s16(-1)); // -1 if data < 0, 0 otherwise\n            int16x8_t zero_vec = vceqzq_s16(data_vec); // 1 if data == 0, 0 otherwise\n\n            int16x8_t neg_one_vec = vdupq_n_s16(-1);\n            int16x8_t one_vec = vdupq_n_s16(1);\n\n            int16x8_t signs = vbslq_s16(zero_vec, vdupq_n_s16(0), vbslq_s16(sign_vec, neg_one_vec, one_vec));\n\n            prod_signs_vec = vmulq_s16(prod_signs_vec, signs);\n\n            int32x4_t abs_vec = {abs(arr[i]), abs(arr[i+1]), abs(arr[i+2]), abs(arr[i+3])};\n            sum_magnitudes_vec = vaddq_s32(sum_magnitudes_vec, abs_vec);\n        }\n\n        int16_t prod_signs_arr[8];\n        vst1q_s16(prod_signs_arr, prod_signs_vec);\n\n        prod_signs = prod_signs_arr[0] * prod_signs_arr[1] * prod_signs_arr[2] * prod_signs_arr[3] * prod_signs_arr[4] * prod_signs_arr[5] * prod_signs_arr[6] * prod_signs_arr[7];\n\n        int32_t sum_magnitudes_arr[4];\n        vst1q_s32(sum_magnitudes_arr, sum_magnitudes_vec);\n\n        sum_magnitudes = sum_magnitudes_arr[0] + sum_magnitudes_arr[1] + sum_magnitudes_arr[2] + sum_magnitudes_arr[3];\n    }\n\n    for (; i < size; ++i) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n        sum_magnitudes += abs(arr[i]);\n    }\n\n    if (prod_signs == 0) {\n        return 0;\n    } else {\n        return sum_magnitudes * prod_signs;\n    }\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_size = arr.size();\n    size_t i = 0;\n\n    if (vector_size >= 4) {\n        int16x8_t prod_signs_vec = vdupq_n_s16(1);\n        int32x4_t sum_magnitudes_vec = vdupq_n_s32(0);\n\n        for (; i <= vector_size - 4; i += 4) {\n            int32x4_t data_vec = vld1q_s32(&arr[i]);\n\n            // Calculate signs\n            int32x4_t signs_vec = vcleq_s32(data_vec, vdupq_n_s32(-1)); // -1 if data <= -1\n            signs_vec = vbslq_s32(vceqq_s32(data_vec, vdupq_n_s32(0)), vdupq_n_s32(0), signs_vec); // 0 if data == 0\n            signs_vec = vbslq_s32(vcgtq_s32(data_vec, vdupq_n_s32(0)), vdupq_n_s32(1), signs_vec); // 1 if data > 0\n\n            // Convert to int16 for multiplication\n            int16x8_t signs_vec_int16 = vcombine_s16(vmovn_s32(vget_low_s32(signs_vec)), vmovn_s32(vget_high_s32(signs_vec)));\n\n            // Multiply signs\n            prod_signs_vec = vmulq_s16(prod_signs_vec, signs_vec_int16);\n\n            // Calculate magnitudes\n            int32x4_t abs_vec = vabsq_s32(data_vec);\n\n            // Accumulate magnitudes\n            sum_magnitudes_vec = vaddq_s32(sum_magnitudes_vec, abs_vec);\n        }\n\n        // Reduce prod_signs_vec\n        int16x4_t prod_signs_low = vmull_s8(vget_low_s8(vmovn_s16(vget_low_s16(prod_signs_vec))), vget_high_s8(vmovn_s16(vget_low_s16(prod_signs_vec))));\n        int16x4_t prod_signs_high = vmull_s8(vget_low_s8(vmovn_s16(vget_high_s16(prod_signs_vec))), vget_high_s8(vmovn_s16(vget_high_s16(prod_signs_vec))));\n        int16x2_t prod_signs_reduced = vmull_s8(vget_low_s8(vmovn_s16(vcombine_s16(vget_low_s16(prod_signs_low), vget_low_s16(prod_signs_high)))) , vget_high_s8(vmovn_s16(vcombine_s16(vget_low_s16(prod_signs_low), vget_low_s16(prod_signs_high)))));\n        prod_signs = vget_lane_s16(prod_signs_reduced, 0) * vget_lane_s16(prod_signs_reduced, 1);\n\n        // Reduce sum_magnitudes_vec\n        int32x2_t sum_magnitudes_low = vpadd_s32(vget_low_s32(sum_magnitudes_vec), vget_high_s32(sum_magnitudes_vec));\n        sum_magnitudes = vget_lane_s32(sum_magnitudes_low, 0) + vget_lane_s32(sum_magnitudes_low, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n        sum_magnitudes += abs(arr[i]);\n    }\n\n    if (prod_signs == 0) {\n        return 0;\n    } else {\n        return prod_signs * sum_magnitudes;\n    }\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_size = arr.size();\n    size_t i = 0;\n\n    if (vector_size >= 4) {\n        int16x8_t prod_signs_vec = vdupq_n_s16(1);\n        int32x4_t sum_magnitudes_vec = vdupq_n_s32(0);\n\n        for (; i <= vector_size - 4; i += 4) {\n            int32x4_t data_vec = vld1q_s32(&arr[i]);\n\n            // Calculate signs\n            int32x4_t signs_vec = vcleq_s32(data_vec, vdupq_n_s32(-1)); // -1 if data <= -1\n            signs_vec = vsubq_s32(signs_vec, vclgeq_s32(data_vec, vdupq_n_s32(1))); // 1 if data >= 1, 0 otherwise\n\n            // Convert signs to int16_t for multiplication\n            int16x8_t signs_vec_s16 = vcombine_s16(vmovn_s32(vget_low_s32(signs_vec)), vmovn_s32(vget_high_s32(signs_vec)));\n\n            // Multiply signs\n            prod_signs_vec = vmulq_s16(prod_signs_vec, signs_vec_s16);\n\n            // Calculate magnitudes\n            int32x4_t abs_data_vec = vabsq_s32(data_vec);\n\n            // Accumulate magnitudes\n            sum_magnitudes_vec = vaddq_s32(sum_magnitudes_vec, abs_data_vec);\n        }\n\n        // Reduce signs\n        int16x4_t prod_signs_low = vget_low_s16(prod_signs_vec);\n        int16x4_t prod_signs_high = vget_high_s16(prod_signs_vec);\n        int16x4_t prod_signs_reduced = vmul_s16(prod_signs_low, prod_signs_high);\n        int16x2_t prod_signs_reduced_low = vget_low_s16(prod_signs_reduced);\n        int16x2_t prod_signs_reduced_high = vget_high_s16(prod_signs_reduced);\n        int16x2_t prod_signs_final = vmul_s16(prod_signs_reduced_low, prod_signs_reduced_high);\n        int16_t temp_signs[2];\n        vst1_s16(temp_signs, prod_signs_final);\n        prod_signs = temp_signs[0] * temp_signs[1];\n\n        // Reduce magnitudes\n        int32_t temp_magnitudes[4];\n        vst1q_s32(temp_magnitudes, sum_magnitudes_vec);\n        sum_magnitudes = temp_magnitudes[0] + temp_magnitudes[1] + temp_magnitudes[2] + temp_magnitudes[3];\n    }\n\n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int sign = (arr[i] > 0) ? 1 : ((arr[i] < 0) ? -1 : 0);\n        prod_signs *= sign;\n        sum_magnitudes += std::abs(arr[i]);\n    }\n\n    return sum_magnitudes * prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n    size_t size = arr.size();\n\n    if (size >= 4) {\n        size_t i = 0;\n        int32x4_t prod_signs_vec = vdupq_n_s32(1);\n        int32x4_t sum_magnitudes_vec = vdupq_n_s32(0);\n\n        for (; i + 3 < size; i += 4) {\n            int32x4_t arr_vec = vld1q_s32(&arr[i]);\n\n            int32x4_t signs_vec = vcleq_s32(arr_vec, vdupq_n_s32(-1));\n            int32x4_t zero_vec = vceqq_s32(arr_vec, vdupq_n_s32(0));\n            int32x4_t pos_vec = vcleq_s32(vdupq_n_s32(1), arr_vec);\n\n            int32x4_t neg_one_vec = vdupq_n_s32(-1);\n            int32x4_t one_vec = vdupq_n_s32(1);\n            int32x4_t zero_fill = vdupq_n_s32(0);\n\n            int32x4_t sign_values = vbslq_s32(signs_vec, neg_one_vec, one_vec);\n            sign_values = vbslq_s32(zero_vec, zero_fill, sign_values);\n\n            prod_signs_vec = vmulq_s32(prod_signs_vec, sign_values);\n            sum_magnitudes_vec = vaddq_s32(sum_magnitudes_vec, vabalq_s32(vdupq_n_s32(0), arr_vec, vdupq_n_s32(1)));\n        }\n\n        int32_t temp_prod_signs[4];\n        int32_t temp_sum_magnitudes[4];\n\n        vst1q_s32(temp_prod_signs, prod_signs_vec);\n        vst1q_s32(temp_sum_magnitudes, sum_magnitudes_vec);\n\n        prod_signs = temp_prod_signs[0] * temp_prod_signs[1] * temp_prod_signs[2] * temp_prod_signs[3];\n        sum_magnitudes = temp_sum_magnitudes[0] + temp_sum_magnitudes[1] + temp_sum_magnitudes[2] + temp_sum_magnitudes[3];\n\n        for (; i < size; ++i) {\n            if (arr[i] < 0) {\n                prod_signs *= -1;\n            } else if (arr[i] == 0) {\n                prod_signs = 0;\n            }\n            sum_magnitudes += std::abs(arr[i]);\n        }\n    } else {\n        for (int x : arr) {\n            if (x < 0) {\n                prod_signs *= -1;\n            } else if (x == 0) {\n                prod_signs = 0;\n            }\n            sum_magnitudes += std::abs(x);\n        }\n    }\n\n    return sum_magnitudes * prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t i = 0;\n    if (arr.size() >= 4) {\n        for (; i <= arr.size() - 4; i += 4) {\n            int32x4_t vec = vld1q_s32(&arr[i]);\n            int32x4_t sign_vec = vcleq_s32(vec, vdupq_n_s32(-1));\n            int32x4_t zero_vec = vceqzq_s32(vec);\n            int32x4_t pos_vec = vandq_s32(vmvnq_s32(sign_vec), vmvnq_s32(zero_vec));\n\n            int32x4_t signs = vorrq_s32(sign_vec, vorrq_s32(zero_vec, pos_vec));\n\n            int signs_arr[4];\n            vst1q_s32(signs_arr, signs);\n\n            for (int j = 0; j < 4; ++j) {\n                if (signs_arr[j] < 0) {\n                    prod_signs *= -1;\n                } else if (signs_arr[j] == 0) {\n                    prod_signs = 0;\n                }\n                sum_magnitudes += std::abs(arr[i + j]);\n            }\n            if (prod_signs == 0) break;\n        }\n    }\n\n    for (; i < arr.size(); ++i) {\n        if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else if (arr[i] == 0) {\n            prod_signs = 0;\n        }\n        sum_magnitudes += std::abs(arr[i]);\n        if (prod_signs == 0) break;\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    if (!hasOdd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    if (!hasOdd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    if (!hasOdd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    if (!hasOdd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    if (n == 0) return 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    if (!hasOdd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        for (; i <= size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vrndpq_f32(float_vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n            int64x2_t int64_low = vmovl_s32(vget_low_s32(int_vec));\n            int64x2_t int64_high = vmovl_s32(vget_high_s32(int_vec));\n            uint64x2_t uint64_low = vreinterpretq_u64_s64(int64_low);\n            uint64x2_t uint64_high = vreinterpretq_u64_s64(int64_high);\n            uint64x2_t square_low = vmulq_u64(uint64_low, uint64_low);\n            uint64x2_t square_high = vmulq_u64(uint64_high, uint64_high);\n            sum_vec = vaddq_u64(sum_vec, square_low);\n            sum_vec = vaddq_u64(sum_vec, square_high);\n        }\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        for (; i <= size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vrndpq_f32(float_vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n            int64x2_t int64_low = vmovl_s32(vget_low_s32(int_vec));\n            int64x2_t int64_high = vmovl_s32(vget_high_s32(int_vec));\n            uint64x2_t uint64_low = vreinterpretq_u64_s64(int64_low);\n            uint64x2_t uint64_high = vreinterpretq_u64_s64(int64_high);\n            uint64x2_t square_low = vmulq_u64(uint64_low, uint64_low);\n            uint64x2_t square_high = vmulq_u64(uint64_high, uint64_high);\n            sum_vec = vaddq_u64(sum_vec, square_low);\n            sum_vec = vaddq_u64(sum_vec, square_high);\n        }\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    if (size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        for (; i <= size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vrndpq_f32(float_vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n            int64x2_t int64_low = vmovl_s32(vget_low_s32(int_vec));\n            int64x2_t int64_high = vmovl_s32(vget_high_s32(int_vec));\n            uint64x2_t uint64_low = vreinterpretq_u64_s64(int64_low);\n            uint64x2_t uint64_high = vreinterpretq_u64_s64(int64_high);\n            uint64x2_t square_low = vmulq_u64(uint64_low, uint64_low);\n            uint64x2_t square_high = vmulq_u64(uint64_high, uint64_high);\n            sum_vec = vaddq_u64(sum_vec, square_low);\n            sum_vec = vaddq_u64(sum_vec, square_high);\n        }\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        for (; i <= size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vrndpq_f32(float_vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n            int64x2_t int64_low = vmovl_s32(vget_low_s32(int_vec));\n            int64x2_t int64_high = vmovl_s32(vget_high_s32(int_vec));\n            uint64x2_t uint64_low = vreinterpretq_u64_s64(int64_low);\n            uint64x2_t uint64_high = vreinterpretq_u64_s64(int64_high);\n            uint64x2_t square_low = vmulq_u64(uint64_low, uint64_low);\n            uint64x2_t square_high = vmulq_u64(uint64_high, uint64_high);\n            sum_vec = vaddq_u64(sum_vec, square_low);\n            sum_vec = vaddq_u64(sum_vec, square_high);\n        }\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    if (size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        for (; i <= size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vrndpq_f32(float_vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n            int64x2_t int64_low = vmovl_s32(vget_low_s32(int_vec));\n            int64x2_t int64_high = vmovl_s32(vget_high_s32(int_vec));\n            uint64x2_t uint64_low = vreinterpretq_u64_s64(int64_low);\n            uint64x2_t uint64_high = vreinterpretq_u64_s64(int64_high);\n            uint64x2_t square_low = vmulq_u64(uint64_low, uint64_low);\n            uint64x2_t square_high = vmulq_u64(uint64_high, uint64_high);\n            sum_vec = vaddq_u64(sum_vec, square_low);\n            sum_vec = vaddq_u64(sum_vec, square_high);\n        }\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int max_index = -1;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int max_index = -1;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int max_index = -1;\n    int i = 1;\n\n    if (arr.size() >= 4) {\n        int num_vectors = (arr.size() - 1) / 4;\n        for (int j = 0; j < num_vectors; ++j) {\n            int32x4_t current = vld1q_s32(&arr[i]);\n            int32x4_t previous = vld1q_s32(&arr[i - 1]);\n\n            int32x4_t cmp = vcltq_s32(current, previous);\n\n            uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 0) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 1) << 1) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 2) << 2) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 3) << 3);\n\n            if (mask != 0) {\n                if (mask & 1) {\n                    max_index = i;\n                } else if (mask & 2) {\n                    max_index = i + 1;\n                } else if (mask & 4) {\n                    max_index = i + 2;\n                } else {\n                    max_index = i + 3;\n                }\n            }\n            i += 4;\n        }\n    }\n\n    for (; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int max_index = -1;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int max_index = -1;\n    int i = 1;\n\n    if (arr.size() >= 4) {\n        int num_vectors = (arr.size() - 1) / 4;\n        for (int j = 0; j < num_vectors; ++j) {\n            int32x4_t current = vld1q_s32(&arr[i]);\n            int32x4_t previous = vld1q_s32(&arr[i - 1]);\n\n            int32x4_t cmp = vcltq_s32(current, previous);\n\n            uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 0) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 1) << 1) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 2) << 2) |\n                            (vgetq_lane_u32(vreinterpretq_u32_s32(cmp), 3) << 3);\n\n            if (mask != 0) {\n                if (mask & 1) {\n                    max_index = i;\n                } else if (mask & 2) {\n                    max_index = i + 1;\n                } else if (mask & 4) {\n                    max_index = i + 2;\n                } else {\n                    max_index = i + 3;\n                }\n            }\n            i += 4;\n        }\n    }\n\n    for (; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        int32x4_t largest_negative_vec = vdupq_n_s32(0);\n        int32x4_t smallest_positive_vec = vdupq_n_s32(0x7FFFFFFF); \n\n        for (; i <= size - 4; i += 4) {\n            int32x4_t data = vld1q_s32(&lst[i]);\n            int32x4_t zero = vdupq_n_s32(0);\n\n            int32x4_t negative_mask = vcltq_s32(data, zero);\n            int32x4_t positive_mask = vcgtq_s32(data, zero);\n\n            int32x4_t negative_values = vandq_s32(data, negative_mask);\n            int32x4_t positive_values = vandq_s32(data, positive_mask);\n\n            largest_negative_vec = vmaxq_s32(largest_negative_vec, negative_values);\n            smallest_positive_vec = vminq_s32(smallest_positive_vec, positive_values);\n        }\n\n        int32_t temp_largest_negative[4];\n        int32_t temp_smallest_positive[4];\n        vst1q_s32(temp_largest_negative, largest_negative_vec);\n        vst1q_s32(temp_smallest_positive, smallest_positive_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp_largest_negative[j] < 0 && temp_largest_negative[j] > largest_negative) {\n                largest_negative = temp_largest_negative[j];\n            }\n            if (temp_smallest_positive[j] > 0 && temp_smallest_positive[j] < smallest_positive) {\n                smallest_positive = temp_smallest_positive[j];\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive == 0x7FFFFFFF ? 0 : smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool negative_found = false;\n    bool positive_found = false;\n\n    if (lst.size() >= 4) {\n        int num_vectors = lst.size() / 4;\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t vec = vld1q_s32(&lst[i * 4]);\n\n            int32x4_t zero = vdupq_n_s32(0);\n            int32x4_t negative_mask = vcgtq_s32(zero, vec);\n            int32x4_t positive_mask = vcgtq_s32(vec, zero);\n\n            int32x4_t negative_values = vandq_s32(vec, negative_mask);\n            int32x4_t positive_values = vandq_s32(vec, positive_mask);\n\n            int32_t temp_neg[4];\n            int32_t temp_pos[4];\n            vst1q_s32(temp_neg, negative_values);\n            vst1q_s32(temp_pos, positive_values);\n\n            for (int j = 0; j < 4; ++j) {\n                if (temp_neg[j] != 0) {\n                    if (!negative_found) {\n                        largest_negative = temp_neg[j];\n                        negative_found = true;\n                    } else {\n                        largest_negative = std::max(largest_negative, temp_neg[j]);\n                    }\n                }\n                if (temp_pos[j] != 0) {\n                    if (!positive_found) {\n                        smallest_positive = temp_pos[j];\n                        positive_found = true;\n                    } else {\n                        smallest_positive = std::min(smallest_positive, temp_pos[j]);\n                    }\n                }\n            }\n        }\n\n        for (size_t i = num_vectors * 4; i < lst.size(); ++i) {\n            if (lst[i] < 0) {\n                if (!negative_found) {\n                    largest_negative = lst[i];\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, lst[i]);\n                }\n            } else if (lst[i] > 0) {\n                if (!positive_found) {\n                    smallest_positive = lst[i];\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, lst[i]);\n                }\n            }\n        }\n    } else {\n        for (int val : lst) {\n            if (val < 0) {\n                if (!negative_found) {\n                    largest_negative = val;\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, val);\n                }\n            } else if (val > 0) {\n                if (!positive_found) {\n                    smallest_positive = val;\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, val);\n                }\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool negative_found = false;\n    bool positive_found = false;\n\n    if (lst.size() >= 4) {\n        int num_vectors = lst.size() / 4;\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t vec = vld1q_s32(&lst[i * 4]);\n\n            int32x4_t zero = vdupq_n_s32(0);\n            int32x4_t neg_mask = vcgtq_s32(zero, vec);\n            int32x4_t pos_mask = vcgtq_s32(vec, zero);\n\n            int32x4_t neg_values = vandq_s32(vec, neg_mask);\n            int32x4_t pos_values = vandq_s32(vec, pos_mask);\n\n            int32_t neg_arr[4];\n            int32_t pos_arr[4];\n\n            vst1q_s32(neg_arr, neg_values);\n            vst1q_s32(pos_arr, pos_values);\n\n            for (int j = 0; j < 4; ++j) {\n                if (neg_arr[j] != 0) {\n                    if (!negative_found) {\n                        largest_negative = neg_arr[j];\n                        negative_found = true;\n                    } else {\n                        largest_negative = std::max(largest_negative, neg_arr[j]);\n                    }\n                }\n\n                if (pos_arr[j] != 0) {\n                    if (!positive_found) {\n                        smallest_positive = pos_arr[j];\n                        positive_found = true;\n                    } else {\n                        smallest_positive = std::min(smallest_positive, pos_arr[j]);\n                    }\n                }\n            }\n        }\n\n        for (size_t i = num_vectors * 4; i < lst.size(); ++i) {\n            if (lst[i] < 0) {\n                if (!negative_found) {\n                    largest_negative = lst[i];\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, lst[i]);\n                }\n            } else if (lst[i] > 0) {\n                if (!positive_found) {\n                    smallest_positive = lst[i];\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, lst[i]);\n                }\n            }\n        }\n    } else {\n        for (int val : lst) {\n            if (val < 0) {\n                if (!negative_found) {\n                    largest_negative = val;\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, val);\n                }\n            } else if (val > 0) {\n                if (!positive_found) {\n                    smallest_positive = val;\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, val);\n                }\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool negative_found = false;\n    bool positive_found = false;\n\n    if (lst.size() >= 4) {\n        int num_vectors = lst.size() / 4;\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t vec = vld1q_s32(&lst[i * 4]);\n\n            int32x4_t zero = vdupq_n_s32(0);\n            int32x4_t negative_mask = vcgtq_s32(zero, vec);\n            int32x4_t positive_mask = vcgtq_s32(vec, zero);\n\n            int32x4_t negative_values = vandq_s32(vec, negative_mask);\n            int32x4_t positive_values = vandq_s32(vec, positive_mask);\n\n            int32_t temp_neg[4];\n            int32_t temp_pos[4];\n            vst1q_s32(temp_neg, negative_values);\n            vst1q_s32(temp_pos, positive_values);\n\n            for (int j = 0; j < 4; ++j) {\n                if (temp_neg[j] != 0) {\n                    if (!negative_found) {\n                        largest_negative = temp_neg[j];\n                        negative_found = true;\n                    } else {\n                        largest_negative = std::max(largest_negative, temp_neg[j]);\n                    }\n                }\n                if (temp_pos[j] != 0) {\n                    if (!positive_found) {\n                        smallest_positive = temp_pos[j];\n                        positive_found = true;\n                    } else {\n                        smallest_positive = std::min(smallest_positive, temp_pos[j]);\n                    }\n                }\n            }\n        }\n\n        for (size_t i = num_vectors * 4; i < lst.size(); ++i) {\n            if (lst[i] < 0) {\n                if (!negative_found) {\n                    largest_negative = lst[i];\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, lst[i]);\n                }\n            } else if (lst[i] > 0) {\n                if (!positive_found) {\n                    smallest_positive = lst[i];\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, lst[i]);\n                }\n            }\n        }\n    } else {\n        for (int val : lst) {\n            if (val < 0) {\n                if (!negative_found) {\n                    largest_negative = val;\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, val);\n                }\n            } else if (val > 0) {\n                if (!positive_found) {\n                    smallest_positive = val;\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, val);\n                }\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool negative_found = false;\n    bool positive_found = false;\n\n    if (lst.size() >= 4) {\n        int num_vectors = lst.size() / 4;\n        for (int i = 0; i < num_vectors; ++i) {\n            int32x4_t vec = vld1q_s32(&lst[i * 4]);\n\n            int32x4_t zero = vdupq_n_s32(0);\n            int32x4_t negative_mask = vcgtq_s32(zero, vec);\n            int32x4_t positive_mask = vcgtq_s32(vec, zero);\n\n            int32x4_t negative_values = vandq_s32(vec, negative_mask);\n            int32x4_t positive_values = vandq_s32(vec, positive_mask);\n\n            int32_t temp_neg[4];\n            int32_t temp_pos[4];\n            vst1q_s32(temp_neg, negative_values);\n            vst1q_s32(temp_pos, positive_values);\n\n            for (int j = 0; j < 4; ++j) {\n                if (temp_neg[j] != 0) {\n                    if (!negative_found) {\n                        largest_negative = temp_neg[j];\n                        negative_found = true;\n                    } else {\n                        largest_negative = std::max(largest_negative, temp_neg[j]);\n                    }\n                }\n                if (temp_pos[j] != 0) {\n                    if (!positive_found) {\n                        smallest_positive = temp_pos[j];\n                        positive_found = true;\n                    } else {\n                        smallest_positive = std::min(smallest_positive, temp_pos[j]);\n                    }\n                }\n            }\n        }\n\n        for (size_t i = num_vectors * 4; i < lst.size(); ++i) {\n            if (lst[i] < 0) {\n                if (!negative_found) {\n                    largest_negative = lst[i];\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, lst[i]);\n                }\n            } else if (lst[i] > 0) {\n                if (!positive_found) {\n                    smallest_positive = lst[i];\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, lst[i]);\n                }\n            }\n        }\n    } else {\n        for (int val : lst) {\n            if (val < 0) {\n                if (!negative_found) {\n                    largest_negative = val;\n                    negative_found = true;\n                } else {\n                    largest_negative = std::max(largest_negative, val);\n                }\n            } else if (val > 0) {\n                if (!positive_found) {\n                    smallest_positive = val;\n                    positive_found = true;\n                } else {\n                    smallest_positive = std::min(smallest_positive, val);\n                }\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    if (n <= 1) return 1;\n\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    if (n <= 1) return 1;\n\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n\n    if (size == 0) return 0;\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        int32x4_t result = vec;\n\n        for (int j = 0; j < 4; ++j) {\n            if ((i + j) % 3 == 0) {\n                result[j] = vec[j] * vec[j];\n            } else if ((i + j) % 4 == 0) {\n                result[j] = vec[j] * vec[j] * vec[j];\n            }\n        }\n\n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 1);\n        sum += vgetq_lane_s32(result, 2);\n        sum += vgetq_lane_s32(result, 3);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        int32x4_t result = v;\n\n        if (i % 3 == 0) {\n            result = vmulq_s32(v, v);\n        }\n        if ((i + 1) % 3 == 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(temp, 1);\n            result[1] = val * val;\n        }\n        if ((i + 2) % 3 == 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(temp, 2);\n            result[2] = val * val;\n        }\n        if ((i + 3) % 3 == 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(vget_high_s32(v), 0);\n            result[3] = val * val;\n        }\n\n        if (i % 4 == 0 && i % 3 != 0) {\n            result = vmulq_s32(vmulq_s32(v, v), v);\n        }\n        if ((i + 1) % 4 == 0 && (i + 1) % 3 != 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(temp, 1);\n            result[1] = val * val * val;\n        }\n        if ((i + 2) % 4 == 0 && (i + 2) % 3 != 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(temp, 2);\n            result[2] = val * val * val;\n        }\n        if ((i + 3) % 4 == 0 && (i + 3) % 3 != 0) {\n            int32x4_t temp = vget_low_s32(v);\n            int32_t val = vget_lane_s32(vget_high_s32(v), 0);\n            result[3] = val * val * val;\n        }\n\n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 1);\n        sum += vgetq_lane_s32(result, 2);\n        sum += vgetq_lane_s32(result, 3);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n\n        int32x4_t mask_mod3 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t mask_mod4 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0));\n        int32x4_t mask_mod3_not_mod4 = vandq_s32(mask_mod4, vmvnq_s32(mask_mod3));\n\n        int32x4_t squared = vmulq_s32(vec, vec);\n        int32x4_t cubed = vmulq_s32(vmulq_s32(vec, vec), vec);\n\n        vec = vbslq_s32(mask_mod3, squared, vec);\n        vec = vbslq_s32(mask_mod3_not_mod4, cubed, vec);\n\n        sum += vgetq_lane_s32(vec, 0) + vgetq_lane_s32(vec, 1) + vgetq_lane_s32(vec, 2) + vgetq_lane_s32(vec, 3);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n\n    if (size == 0) return 0;\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        int32x4_t result = vec;\n\n        for (int j = 0; j < 4; ++j) {\n            if ((i + j) % 3 == 0) {\n                result[j] = vec[j] * vec[j];\n            } else if ((i + j) % 4 == 0) {\n                result[j] = vec[j] * vec[j] * vec[j];\n            }\n        }\n        sum += vgetq_lane_s32(result, 0) + vgetq_lane_s32(result, 1) + vgetq_lane_s32(result, 2) + vgetq_lane_s32(result, 3);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    int i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        int32x4_t result = vec;\n\n        if ((i % 3) == 0) {\n            int32x4_t squared = vmulq_s32(vec, vec);\n            result = squared;\n        }\n        if (((i + 1) % 3) == 0) {\n            int temp = lst[i + 1] * lst[i + 1];\n            result = vsetq_lane_s32(temp * lst[i + 1], result, 1);\n        } else if (((i + 1) % 4) == 0) {\n            int temp = lst[i + 1] * lst[i + 1];\n            result = vsetq_lane_s32(temp * lst[i + 1], result, 1);\n        }\n        if (((i + 2) % 3) == 0) {\n            int temp = lst[i + 2] * lst[i + 2];\n            result = vsetq_lane_s32(temp, result, 2);\n        }\n        if (((i + 3) % 3) == 0) {\n            int temp = lst[i + 3] * lst[i + 3];\n            result = vsetq_lane_s32(temp, result, 3);\n        } else if (((i + 3) % 4) == 0) {\n            int temp = lst[i + 3] * lst[i + 3];\n            result = vsetq_lane_s32(temp * lst[i + 3], result, 3);\n        }\n        \n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 1);\n        sum += vgetq_lane_s32(result, 2);\n        sum += vgetq_lane_s32(result, 3);\n    }\n\n    for (; i < size; ++i) {\n        if ((i % 3) == 0) {\n            sum += lst[i] * lst[i];\n        } else if ((i % 4) == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n\n    for (int i = 0; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            firstDigit = temp;\n\n            if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n\n    for (int i = 0; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            firstDigit = temp;\n\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n\n    for (int i = 0; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            firstDigit = temp;\n\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n\n    for (int i = 0; i < size; ++i) {\n        if (nums[i] > 10) {\n            int temp = nums[i];\n            int lastDigit = temp % 10;\n            int firstDigit = 0;\n            \n            if (temp < 0)\n                temp = -temp;\n\n            if (temp < 10)\n                firstDigit = temp;\n            else {\n                while (temp >= 10) {\n                    temp /= 10;\n                }\n                firstDigit = temp;\n            }\n\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n\n    for (int i = 0; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            firstDigit = temp;\n\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstdint>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint64_t rem0 = 0, rem1 = 0, rem2 = 0;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        if (val == 0) rem0++;\n        else if (val == 1) rem1++;\n        else rem2++;\n    }\n\n    count += rem0 * (rem0 - 1) * (rem0 - 2) / 6;\n    count += rem1 * (rem1 - 1) * (rem1 - 2) / 6;\n    count += rem2 * (rem2 - 1) * (rem2 - 2) / 6;\n    count += rem0 * rem1 * rem2;\n    count += rem0 * (rem0 - 1) / 2 * (rem1 + rem2);\n    count += rem1 * (rem1 - 1) / 2 * (rem0 + rem2);\n    count += rem2 * (rem2 - 1) / 2 * (rem0 + rem1);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstdint>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint64_t rem[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        rem[val]++;\n    }\n\n    count += (rem[0] * (rem[0] - 1) * (rem[0] - 2)) / 6;\n    count += (rem[1] * (rem[1] - 1) * (rem[1] - 2)) / 6;\n    count += (rem[2] * (rem[2] - 1) * (rem[2] - 2)) / 6;\n    count += rem[0] * rem[1] * rem[2];\n    count += (rem[0] * (rem[0] - 1) / 2) * rem[1];\n    count += (rem[0] * (rem[0] - 1) / 2) * rem[2];\n    count += (rem[1] * (rem[1] - 1) / 2) * rem[0];\n    count += (rem[1] * (rem[1] - 1) / 2) * rem[2];\n    count += (rem[2] * (rem[2] - 1) / 2) * rem[0];\n    count += (rem[2] * (rem[2] - 1) / 2) * rem[1];\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstdint>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count[3] = {0};\n    uint64_t rem = 0;\n\n    uint64_t i = 1;\n    for (; i <= n; ++i) {\n        rem = (i * i - i + 1) % 3;\n        count[rem]++;\n    }\n\n    uint64_t triples = 0;\n    triples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    triples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    triples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    triples += count[0] * count[1] * count[2];\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n\n    uint64_t ans = 0;\n    ans += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    ans += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    ans += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    ans += count[0] * count[1] * count[2];\n    ans += (count[0] * (count[0] - 1) / 2) * count[0];\n    ans += (count[1] * (count[1] - 1) / 2) * count[1];\n    ans += (count[2] * (count[2] - 1) / 2) * count[2];\n    ans += (count[0] * (count[0] - 1) / 2) * count[0];\n    ans += count[0] * (count[1] * (count[1] - 1) / 2);\n    ans += count[0] * (count[2] * (count[2] - 1) / 2);\n    ans += count[1] * (count[0] * (count[0] - 1) / 2);\n    ans += count[1] * (count[1] * (count[1] - 1) / 2);\n    ans += count[1] * (count[2] * (count[2] - 1) / 2);\n    ans += count[2] * (count[0] * (count[0] - 1) / 2);\n    ans += count[2] * (count[1] * (count[1] - 1) / 2);\n    ans += count[2] * (count[2] * (count[2] - 1) / 2);\n    \n    return ans;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <iostream>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t rem0 = 0;\n    uint64_t rem1 = 0;\n    uint64_t rem2 = 0;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        if (val == 0) {\n            rem0++;\n        } else if (val == 1) {\n            rem1++;\n        } else {\n            rem2++;\n        }\n    }\n\n    count += (rem0 * (rem0 - 1) * (rem0 - 2)) / 6;\n    count += (rem1 * (rem1 - 1) * (rem1 - 2)) / 6;\n    count += (rem2 * (rem2 - 1) * (rem2 - 2)) / 6;\n    count += (rem0 * rem1 * rem2);\n    count += (rem0 * (rem0 - 1) / 2) * (rem1 + rem2);\n    count += (rem1 * (rem1 - 1) / 2) * (rem0 + rem2);\n    count += (rem2 * (rem2 - 1) / 2) * (rem0 + rem1);\n\n    uint64_t total_triples = (n * (n - 1) * (n - 2)) / 6;\n    \n    rem0 = 0;\n    rem1 = 0;\n    rem2 = 0;\n    uint64_t count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        if (val == 0) {\n            rem0++;\n        } else if (val == 1) {\n            rem1++;\n        } else {\n            rem2++;\n        }\n    }\n    count2 += (rem0 * (rem0 - 1) * (rem0 - 2)) / 6;\n    count2 += (rem1 * (rem1 - 1) * (rem1 - 2)) / 6;\n    count2 += (rem2 * (rem2 - 1) * (rem2 - 2)) / 6;\n    count2 += (rem0 * rem1 * rem2);\n    count2 += (rem0 * (rem0 - 1) / 2) * (rem1 + rem2);\n    count2 += (rem1 * (rem1 - 1) / 2) * (rem0 + rem2);\n    count2 += (rem2 * (rem2 - 1) / 2) * (rem0 + rem1);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n\n    if (n <= 3) {\n        return x;\n    }\n\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n\n    if (n <= 3) {\n        return x;\n    }\n\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n\n    if (n <= 3) {\n        return x;\n    }\n\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    if (n % 2 == 0 || n % 3 == 0) return y;\n\n    int is_prime = 1;\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    if (n % 2 == 0 || n % 3 == 0) return y;\n\n    int is_prime = 1;\n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    size_t i = 0;\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            float32x4_t vec = vld1q_f32(&lst[i]);\n            int32x4_t int_vec = vcvtq_s32_f32(vec);\n            float32x4_t converted_back = vcvtq_f32_s32(int_vec);\n            uint32x4_t eq_mask = vceqq_f32(vec, converted_back);\n            int32x4_t odd_mask = vandq_s32(int_vec, vdupq_n_s32(1));\n            uint32x4_t is_odd = vceqq_s32(odd_mask, vdupq_n_s32(1));\n            uint32x4_t combined_mask = vandq_u32(eq_mask, is_odd);\n            float32x4_t masked_vec = vbslq_f32(combined_mask, vec, vdupq_n_f32(0.0f));\n            float32x4_t squared_vec = vmulq_f32(masked_vec, masked_vec);\n            float sum_arr[4];\n            vst1q_f32(sum_arr, squared_vec);\n            for (int j = 0; j < 4; ++j) {\n                sum += static_cast<uint64_t>(sum_arr[j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && lst[i] == static_cast<int>(lst[i]) && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum_of_squares = 0;\n    size_t vector_size = lst.size();\n    size_t i = 0;\n\n    // Process the vector in chunks of 4 floats\n    for (; i + 3 < vector_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n\n        // Check if the original floats were integers\n        float32x4_t back_to_float = vcvtq_f32_s32(int_vec);\n        uint32x4_t is_integer = vceqq_f32(vec, back_to_float);\n\n        // Check if the integers are non-negative\n        uint32x4_t is_non_negative = vcgeq_s32(int_vec, vdupq_n_s32(0));\n\n        // Check if the integers are odd\n        int32x4_t and_result = vandq_s32(int_vec, vdupq_n_s32(1));\n        uint32x4_t is_odd = vceqq_s32(and_result, vdupq_n_s32(1));\n\n        // Combine all conditions\n        uint32x4_t mask = vandq_u32(vandq_u32(is_integer, is_non_negative), is_odd);\n\n        // Square the integers\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n\n        // Mask the squared values\n        int32x4_t masked_squared_vec = vbslq_s32(mask, squared_vec, vdupq_n_s32(0));\n\n        // Accumulate the sum of squares\n        int32x2_t sum1 = vpadd_s32(vget_low_s32(masked_squared_vec), vget_high_s32(masked_squared_vec));\n        int32_t sum2 = vget_lane_s32(vpadd_s32(sum1, sum1), 0);\n\n        sum_of_squares += (uint64_t)sum2;\n    }\n\n    // Process remaining elements\n    for (; i < vector_size; ++i) {\n        if (lst[i] >= 0 && lst[i] == (int)lst[i] && (int)lst[i] % 2 != 0) {\n            sum_of_squares += (uint64_t)((int)lst[i] * (int)lst[i]);\n        }\n    }\n\n    return sum_of_squares;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using Neon (Advanced SIMD) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) {\n        return 0;\n    }\n\n    size_t i = 0;\n    if (size >= 4) {\n        for (; i <= size - 4; i += 4) {\n            float32x4_t vec = vld1q_f32(&lst[i]);\n            int32x4_t int_vec = vcvtq_s32_f32(vec);\n            float32x4_t rounded_vec = vcvtq_f32_s32(int_vec);\n            uint32x4_t eq_mask = vceqq_f32(vec, rounded_vec);\n            int32x4_t and_vec = vandq_s32(vreinterpretq_s32_f32(vec), vreinterpretq_s32_u32(eq_mask));\n            int32x4_t abs_vec = vabsq_s32(and_vec);\n            int32x4_t mod_vec = vandq_s32(abs_vec, vdupq_n_s32(1));\n            uint32x4_t odd_mask = vceqq_s32(mod_vec, vdupq_n_s32(1));\n            float32x4_t masked_vec = vbslq_f32(odd_mask, vec, vdupq_n_f32(0.0f));\n            float32x4_t squared_vec = vmulq_f32(masked_vec, masked_vec);\n            float32x2_t sum_low = vpadd_f32(vget_low_f32(squared_vec), vget_high_f32(squared_vec));\n            float32_t final_sum = vget_lane_f32(vpadd_f32(sum_low, sum_low), 0);\n            sum += static_cast<uint64_t>(final_sum);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && lst[i] == static_cast<int>(lst[i]) && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t vector_size = lst.size();\n    size_t i = 0;\n\n    if (vector_size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n\n        for (; i <= vector_size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n            float32x4_t back_to_float = vcvtq_f32_s32(int_vec);\n            uint32x4_t eq_vec = vceqq_f32(float_vec, back_to_float);\n            int32x4_t mask_neg = vcltq_s32(int_vec, vdupq_n_s32(0));\n            uint32x4_t combined_mask = vandq_u32(eq_vec, vmvnq_u32(mask_neg));\n            int32x4_t and_result = vandq_s32(int_vec, vdupq_n_s32(1));\n            uint32x4_t is_odd = vceqq_s32(and_result, vdupq_n_s32(1));\n            uint32x4_t final_mask = vandq_u32(combined_mask, is_odd);\n            int32x4_t masked_int = vandq_s32(int_vec, vreinterpretq_s32_u32(final_mask));\n            int64x2_t square_long = vmull_s32(vget_low_s32(masked_int), vget_low_s32(masked_int));\n            int64x2_t square_high = vmull_s32(vget_high_s32(masked_int), vget_high_s32(masked_int));\n            sum_vec = vaddq_u64(sum_vec, vreinterpretq_u64_s64(vcombine_s64(square_long, square_high)));\n        }\n\n        uint64_t temp_sum[2];\n        vst1q_u64(temp_sum, sum_vec);\n        sum = temp_sum[0] + temp_sum[1];\n    }\n\n    for (; i < vector_size; ++i) {\n        if (lst[i] >= 0 && lst[i] == (int)lst[i] && ((int)lst[i] % 2 != 0)) {\n            sum += (uint64_t)lst[i] * (uint64_t)lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t vector_size = lst.size();\n    size_t i = 0;\n\n    if (vector_size >= 4) {\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n\n        for (; i <= vector_size - 4; i += 4) {\n            float32x4_t float_vec = vld1q_f32(&lst[i]);\n            int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n            float32x4_t back_to_float = vcvtq_f32_s32(int_vec);\n            uint32x4_t eq_vec = vceqq_f32(float_vec, back_to_float);\n            int32x4_t mask_neg = vcltq_s32(int_vec, vdupq_n_s32(0));\n            uint32x4_t combined_mask = vandq_u32(eq_vec, vmvnq_u32(mask_neg));\n            int32x4_t and_result = vandq_s32(int_vec, vdupq_n_s32(1));\n            uint32x4_t is_odd = vceqq_s32(and_result, vdupq_n_s32(1));\n            uint32x4_t final_mask = vandq_u32(combined_mask, is_odd);\n            int32x4_t squared_int = vmulq_s32(int_vec, int_vec);\n            uint64x2_t squared_long = vmovl_u32(vget_low_u32(vreinterpretq_u32_s32(vandq_s32(squared_int, vreinterpretq_s32_u32(final_mask)))));\n            uint64x2_t squared_long_high = vmovl_u32(vget_high_u32(vreinterpretq_u32_s32(vandq_s32(squared_int, vreinterpretq_s32_u32(final_mask)))));\n            sum_vec = vaddq_u64(sum_vec, squared_long);\n            sum_vec = vaddq_u64(sum_vec, squared_long_high);\n        }\n\n        uint64_t temp[2];\n        vst1q_u64(temp, sum_vec);\n        sum = temp[0] + temp[1];\n    }\n\n    for (; i < vector_size; ++i) {\n        if (lst[i] >= 0 && lst[i] == (int)lst[i] && ((int)lst[i] % 2 != 0)) {\n            sum += (uint64_t)((int)lst[i] * (int)lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    int size = game.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t abs_diff_vec;\n        int32x4_t diff_vec = vsubq_s32(guess_vec, game_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        int32x4_t mask = vcgtq_s32(diff_vec, zero_vec);\n        abs_diff_vec = vbslq_s32(mask, diff_vec, vnegq_s32(diff_vec));\n\n        int32x4_t cmp_vec = vceqzq_s32(diff_vec);\n        int32x4_t final_vec = vbslq_s32(cmp_vec, zero_vec, abs_diff_vec);\n\n        vst1q_s32(&result[i], final_vec);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int diff = std::abs(guess[i] - game[i]);\n        result[i] = (guess[i] == game[i]) ? 0 : diff;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    int size = game.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t abs_diff_vec;\n        int32x4_t diff_vec = vsubq_s32(guess_vec, game_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        int32x4_t mask = vcgtq_s32(diff_vec, zero_vec);\n        abs_diff_vec = vbslq_s32(mask, diff_vec, vnegq_s32(diff_vec));\n        int32x4_t eq_mask = vceqq_s32(game_vec, guess_vec);\n        int32x4_t res_vec = vbslq_s32(eq_mask, zero_vec, abs_diff_vec);\n        vst1q_s32(&result[i], res_vec);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < size; ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    int n = game.size();\n    std::vector<int> result(n);\n\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vsubq_s32(guess_vec, game_vec);\n        int32x4_t abs_diff_vec = vabsq_s32(diff_vec);\n        int32x4_t cmp_vec = vceqq_s32(game_vec, guess_vec);\n        int32x4_t res_vec = vbslq_s32(cmp_vec, vdupq_n_s32(0), abs_diff_vec);\n        vst1q_s32(&result[i], res_vec);\n    }\n\n    for (; i < n; ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    int size = game.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t abs_diff_vec;\n        int32x4_t diff_vec = vsubq_s32(guess_vec, game_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        int32x4_t mask_vec = vcgeq_s32(diff_vec, zero_vec);\n        abs_diff_vec = vbslq_s32(mask_vec, diff_vec, vnegq_s32(diff_vec));\n        vst1q_s32(&result[i], vandq_s32(abs_diff_vec,vcmeqq_s32(game_vec,guess_vec)));\n        int32x4_t equal_mask = vceqq_s32(game_vec, guess_vec);\n        int32x4_t zero = vdupq_n_s32(0);\n        int32x4_t res_vec = vbslq_s32(equal_mask, zero, abs_diff_vec);\n        vst1q_s32(&result[i], res_vec);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < size; ++i) {\n        result[i] = (game[i] == guess[i]) ? 0 : std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    int size = game.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t abs_diff_vec;\n        int32x4_t diff_vec = vsubq_s32(guess_vec, game_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        int32x4_t mask = vcgeq_s32(diff_vec, zero_vec);\n        abs_diff_vec = vbslq_s32(mask, diff_vec, vnegq_s32(diff_vec));\n        vst1q_s32(&result[i], abs_diff_vec);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < size; ++i) {\n        result[i] = std::abs(guess[i] - game[i]);\n    }\n\n    return result;\n}\n```"}

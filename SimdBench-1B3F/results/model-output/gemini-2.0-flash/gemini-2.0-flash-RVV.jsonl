{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vbool8_t v_mask = vle_v_b8_m8(mask + i, vl);\n        vint64m8_t v_src = vle_v_i64m8(src + i, vl);\n        vint64m8_t v_dst = vle_v_i64m8(dst + i, vl);\n        v_dst = vmerge_v_i64m8_m(v_mask, v_dst, v_src, vl);\n        vse_v_i64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e64m8(length - i);\n    vbool8_t v_mask = vle_v_b8_m8(mask + i, vl);\n    vint64m8_t v_src = vle_v_i64m8(src + i, vl);\n    vint64m8_t v_dst = vle_v_i64m8(dst + i, vl);\n    v_dst = vmerge_v_i64m8_m_i64m8(v_mask, v_src, v_dst, vl);\n    vse_v_i64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vbool8_t v_mask = vle_v_b8_m8(mask + i, vl);\n        vint64m8_t v_src = vle_v_i64m8(src + i, vl);\n        vint64m8_t v_dst = vle_v_i64m8(dst + i, vl);\n        v_dst = vmerge_v_i64m8_m(v_mask, v_dst, v_src, vl);\n        vse_v_i64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e64m8(length - i);\n    vbool8_t v_mask = vle1_v_b8_m8(mask + i, vl);\n    vint64m8_t v_src = vle_v_i64m8(src + i, vl);\n    vse_v_i64m8(dst + i, v_src, v_mask, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vbool8_t v_mask = vle1_v_b8m8(mask + i, vl);\n        vint64m8_t v_src = vle_v_i64m8(src + i, vl);\n        vse_v_i64m8(dst + i, v_src, v_mask, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m4(length - i);\n    vint32m4_t v_src = vle32_v_i32m4(&src[i], vl);\n    vint32m4_t v_scale = vmv_s_x_i32m4(scale, vl);\n    vint32m4_t v_scaled = vmul_vv_i32m4(v_src, v_scale, vl);\n    vint32m4_t v_tmp1 = vsra_vx_i32m4(v_scaled, 3, vl);\n    vint32m4_t v_tmp2 = vsll_vx_i32m4(v_scaled, 3, vl);\n    vint32m4_t v_tmp1_tmp2 = vmul_vv_i32m4(v_tmp1, v_tmp2, vl);\n    vint32m4_t v_scaled_tmp1_tmp2 = vadd_vv_i32m4(v_scaled, v_tmp1_tmp2, vl);\n    vint32m4_t v_result = vsdiv_vx_i32m4(v_scaled_tmp1_tmp2, 7, vl);\n    vse32_v_i32m4(&dst[i], v_result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m4(length - i);\n    vint32m4_t v_src = vle32_v_i32m4(&src[i], vl);\n    vint32m4_t v_scale = vmul_vx_i32m4(v_src, scale, vl);\n    vint32m4_t v_tmp1 = vsra_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_tmp2 = vsll_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_result = vdiv_vx_i32m4(vadd_vv_i32m4(v_scale, vmul_vv_i32m4(v_tmp1, v_tmp2, vl), vl), 7, vl);\n    vse32_v_i32m4(&dst[i], v_result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m4(length - i);\n    vint32m4_t v_src = vle32_v_i32m4(&src[i], vl);\n    vint32m4_t v_scale = vmul_vx_i32m4(v_src, scale, vl);\n    vint32m4_t v_tmp1 = vsra_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_tmp2 = vsll_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_result = vdiv_vx_i32m4(vadd_vv_i32m4(v_scale, vmul_vv_i32m4(v_tmp1, v_tmp2, vl), vl), 7, vl);\n    vse32_v_i32m4(&dst[i], v_result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m4(length - i);\n    vint32m4_t v_src = vle32_v_i32m4(&src[i], vl);\n    vint32m4_t v_scale = vmv_s_x_i32m4(scale, vl);\n    vint32m4_t v_scaled = vmul_vv_i32m4(v_src, v_scale, vl);\n    vint32m4_t v_tmp1 = vsra_vx_i32m4(v_scaled, 3, vl);\n    vint32m4_t v_tmp2 = vsll_vx_i32m4(v_scaled, 3, vl);\n    vint32m4_t v_tmp1_tmp2 = vmul_vv_i32m4(v_tmp1, v_tmp2, vl);\n    vint32m4_t v_scaled_tmp1_tmp2 = vadd_vv_i32m4(v_scaled, v_tmp1_tmp2, vl);\n    vint32m4_t v_result = vsra_vx_i32m4(v_scaled_tmp1_tmp2, 3, vl);\n    vse32_v_i32m4(&dst[i], v_result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m4(length - i);\n    vint32m4_t v_src = vle32_v_i32m4(&src[i], vl);\n    vint32m4_t v_scale = vmul_vx_i32m4(v_src, scale, vl);\n    vint32m4_t v_tmp1 = vsra_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_tmp2 = vsll_vx_i32m4(v_scale, 3, vl);\n    vint32m4_t v_result = vdiv_vx_i32m4(vadd_vv_i32m4(v_scale, vmul_vv_i32m4(v_tmp1, v_tmp2, vl), vl), 7, vl);\n    vse32_v_i32m4(&dst[i], v_result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n  size_t vl;\n  size_t loop = rows;\n  const double *source = src + stride;\n\n  for (; loop > 0; loop -= vl) {\n    vl = vsetvl_e64m8(loop);\n    vfloat64m8_t v_src = vle64_v_f64m8(source, vl);\n    vse64_v_f64m8(dst, v_src, vl);\n    source += cols * vl;\n    dst += vl;\n  }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    size_t loop = 0;\n\n    for (size_t i = 0; i < rows; i += vl) {\n        vl = vmin_zu(rows - i, vsetvlmax_e64m8());\n        vfloat64m8_t vs = vle64_v_f64m8(&src[i * cols + stride], vl);\n        vse64_v_f64m8(&dst[i], vs, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n  size_t vl;\n  size_t r = 0;\n\n  for (; r < rows; r += vl) {\n    vl = vsetvl_e64m8(rows - r);\n    vfloat64m8_t v_src = vle_v_f64m8((const double*)(src + r * cols + stride), vl);\n    vse_v_f64m8((double*)(dst + r), v_src, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n  size_t vl;\n  size_t loop = 0;\n  for (; loop < rows; loop += vl) {\n    vl = vsetvl_e64m8(rows - loop);\n    vfloat64m8_t v_src = vle_v_f64m8(src + loop * cols + stride, vl);\n    vse_v_f64m8(dst + loop, v_src, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    size_t loop = 0;\n\n    for (size_t r = 0; r < rows; r += vl) {\n        vl = vsetvl_e64m8(rows - r);\n        vfloat64m8_t vs = vle64_v_f64m8(&src[r * cols + stride], vl);\n        vse64_v_f64m8(&dst[r], vs, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t v_src = vgather_vv_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst + i, v_src, vl);\n        vsse32_v_f32m8(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n    vfloat32m8_t v_src = vgather_vv_f32m8(src, v_indices, vl);\n    vse32_v_f32m8(dst + i, v_src, vl);\n  }\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n    vfloat32m8_t v_src = vle32_v_f32m8(src + i, vl);\n    vsse32_v_f32m8(dst, v_indices, v_src, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t v_src = vgather_vv_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst + i, v_src, vl);\n        vsse32_v_f32m8(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t v_src = vgather_vv_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst + i, v_src, vl);\n        vsse32_v_f32m8(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t v_indices = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t v_src = vgather_vv_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst + i, v_src, vl);\n        vsse32_v_f32m8(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  size_t vl;\n  ptrdiff_t i = 0;\n\n  while (start < end) {\n    vl = vsetvl_e16m8(end - start);\n    vint16m8_t v_start = vle16_v_i16m8(&arr[start], vl);\n    vint16m8_t v_end = vle16_v_i16m8(&arr[end - vl + 1], vl);\n\n    vse16_v_i16m8(&arr[start], v_end, vl);\n    vse16_v_i16m8(&arr[end - vl + 1], v_start, vl);\n\n    start += vl;\n    end -= vl;\n  }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  size_t vl;\n  for (; start < end; start += vl, end -= vl) {\n    vl = vsetvl_e16m8(end - start + 1);\n    vint16m8_t v_start = vle16_v_i16m8(arr + start, vl);\n    vint16m8_t v_end = vle16_v_i16m8(arr + end - vl + 1, vl);\n\n    vse16_v_i16m8(arr + start, v_end, vl);\n    vse16_v_i16m8(arr + end - vl + 1, v_start, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  size_t vl;\n  for (; start < end; start += vl, end -= vl) {\n    vl = vsetvl_e16m8(end - start + 1);\n    vint16m8_t v_start = vle16_v_i16m8(arr + start, vl);\n    vint16m8_t v_end = vle16_v_i16m8(arr + end - vl + 1, vl);\n\n    vse16_v_i16m8(arr + start, v_end, vl);\n    vse16_v_i16m8(arr + end - vl + 1, v_start, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  size_t len = end - start + 1;\n  size_t vl;\n  \n  for (; len > 0; len -= vl, start += vl, end -= vl) {\n    vl = vsetvl_e16m8_i16(len);\n    vint16m8_t v_start = vle16_v_i16m8(arr + start, vl);\n    vint16m8_t v_end = vle16_v_i16m8(arr + end - vl + 1, vl);\n    \n    vse16_v_i16m8(arr + start, v_end, vl);\n    vse16_v_i16m8(arr + end - vl + 1, v_start, vl);\n  }\n  \n  uint64_t i = start;\n  uint64_t j = end;\n  while (i < j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n  }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  size_t len = end - start + 1;\n  size_t vl;\n  int16_t temp;\n\n  for (; start < end; start += vl, end -= vl) {\n    vl = vsetvl_e16m8_i16(end - start);\n    vint16m8_t v_start = vle16_v_i16m8(arr + start, vl);\n    vint16m8_t v_end = vle16_v_i16m8(arr + end - vl + 1, vl);\n\n    vse16_v_i16m8(arr + start, v_end, vl);\n    vse16_v_i16m8(arr + end - vl + 1, v_start, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < slice_size; i += vl) {\n        vl = vsetvl_e8m1(slice_size - i);\n        vuint8m1_t v_data = vle8_v_u8m1(slice_start + i, vl);\n        vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < slice_size; i += vl) {\n        vl = vsetvl_e8m1(slice_size - i);\n        vuint8m1_t v_data = vle8_v_u8m1(slice_start + i, vl);\n        vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < slice_size; i += vl) {\n        vl = vsetvl_e8m1(slice_size - i);\n        vuint8m1_t v_data = vle8_v_u8m1(slice_start + i, vl);\n        vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < slice_size; i += vl) {\n        vl = vsetvl_e8m1(slice_size - i);\n        vuint8m1_t v_data = vle8_v_u8m1(slice_start + i, vl);\n        vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < slice_size; i += vl) {\n        vl = vsetvl_e8m1(slice_size - i);\n        vuint8m1_t v_data = vle8_v_u8m1(slice_start + i, vl);\n        vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; ++y) {\n                    dst[(j + y) * rows + (i + x)] = src[(i + x) * cols + (j + y)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n  for (size_t i = 0; i < rows; i += block_size) {\n    for (size_t j = 0; j < cols; j += block_size) {\n      size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n      size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n      for (size_t x = 0; x < block_rows; ++x) {\n        for (size_t y = 0; y < block_cols; ++y) {\n          dst[(j + y) * rows + (i + x)] = src[(i + x) * cols + (j + y)];\n        }\n      }\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; ++y) {\n                    dst[(j + y) * rows + (i + x)] = src[(i + x) * cols + (j + y)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; ++y) {\n                    dst[(j + y) * rows + (i + x)] = src[(i + x) * cols + (j + y)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t x = 0; x < block_rows; ++x) {\n                for (size_t y = 0; y < block_cols; ++y) {\n                    dst[(j + y) * rows + (i + x)] = src[(i + x) * cols + (j + y)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n  float sum = 0.0f;\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < dim; ++i) {\n    sum += array[i * dim * dim + i * dim + i];\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n  float sum = 0.0f;\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < dim; ++i) {\n    sum += array[i * dim * dim + i * dim + i];\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n  size_t total_elements = rows * cols;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v_src = vle_v_f64m8(src + i, vl);\n    vfloat64m8_t v_dst = vle_v_f64m8(src + i, vl);\n    vbool8_t mask = vmgt_vf_f64m8_b8(v_src, threshold, vl);\n    vfloat64m8_t v_scaled = vfmuls_vf_f64m8(v_src, scale, vl);\n    v_dst = vmerge_v_f64m8(mask, v_scaled, v_src, vl);\n    vse_v_f64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_src = vle64_v_f64m8(src + i, vl);\n        vfloat64m8_t v_dst = v_src; \n\n        vbool8_t mask = vmgt_vf_f64m8_b8(v_src, threshold, vl);\n        vfloat64m8_t v_scaled = vfmv_v_f_f64m8(scale, vl);\n        v_dst = vfmul_vf_f64m8_m(mask, v_dst, v_src, scale, vl);\n\n        vse64_v_f64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n  size_t total_elements = rows * cols;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v_src = vle64_v_f64m8(src + i, vl);\n    vbool8_t mask = vmgt_vf_f64m8_b8(v_src, threshold, vl);\n    vfloat64m8_t v_scaled = vfmul_vf_f64m8_m(mask, v_src, v_src, scale, vl);\n    vse64_v_f64m8(dst + i, v_scaled, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n  size_t total_elements = rows * cols;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v_src = vle64_v_f64m8(src + i, vl);\n    vfloat64m8_t v_dst = v_src; \n\n    vbool8_t mask = vmgt_vf_f64m8_b8(v_src, threshold, vl);\n    vfloat64m8_t v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n    v_dst = vmerge_vvm_f64m8(v_dst, v_scaled, mask, vl);\n\n    vse64_v_f64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n  size_t total_elements = rows * cols;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n\n    vfloat64m8_t v_src = vle64_v_f64m8(src + i, vl);\n    vfloat64m8_t v_threshold = vfmv_s_f_f64m8(threshold, vl);\n    vfloat64m8_t v_scale = vfmv_s_f_f64m8(scale, vl);\n\n    vbool8_t mask = vmfgt_vv_f64m8_b8(v_src, v_threshold, vl);\n    vfloat64m8_t v_scaled = vfmul_vf_f64m8_m(mask, v_src, v_src, v_scale, vl);\n\n    vse64_v_f64m8(dst + i, v_scaled, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    size_t index = indices[i];\n    const double *src_row = src + index * cols;\n    double *dst_row = dst + i * cols;\n\n    size_t j = 0;\n    for (; j < cols; j += vl) {\n      vl = vsetvl_e64m8(cols - j);\n      vfloat64m8_t v_src = vle64_v_f64m8(src_row + j, vl);\n      vse64_v_f64m8(dst_row + j, v_src, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    size_t index = indices[i];\n    const double *src_row = src + index * cols;\n    double *dst_row = dst + i * cols;\n\n    size_t j = 0;\n    for (; j < cols; j += vl) {\n      vl = vsetvl_e64m8(cols - j);\n      vfloat64m8_t v_src = vle64_v_f64m8(src_row + j, vl);\n      vse64_v_f64m8(dst_row + j, v_src, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stddef.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    size_t index = indices[i];\n    const double *src_row = src + index * cols;\n    double *dst_row = dst + i * cols;\n\n    size_t j = 0;\n    for (; j < cols; j += vl) {\n      vl = vsetvl_e64m8(cols - j);\n      vfloat64m8_t v_src = vle64_v_f64m8(src_row + j, vl);\n      vse64_v_f64m8(dst_row + j, v_src, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length for double\n    for (size_t i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += vl) {\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[index * cols + j], vl);\n            vse64_v_f64m1(&dst[i * cols + j], src_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64m8(cols); // Set vector length for double type\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        // Load the row from src and store it in dst\n        for (size_t j = 0; j < cols; j += vl) {\n            vfloat64m8_t v_src = vle64_v_f64m8(src_row + j);\n            vse64_v_f64m8(dst_row + j, v_src);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t v_src1 = vle64_v_u64m1(&src1[i], vl);\n        vuint64m1_t v_src2 = vle64_v_u64m1(&src2[i], vl);\n        vuint64m1_t v_result = vadd_vv_u64m1(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m1(v_result, scalar, vl);\n        v_result = vssrl_vu_u64m1(v_result, 1, vl);\n        vse64_v_u64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t v_src1 = vle64_v_u64m1(&src1[i], vl);\n        vuint64m1_t v_src2 = vle64_v_u64m1(&src2[i], vl);\n        vuint64m1_t v_result = vadd_vv_u64m1(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m1(v_result, scalar, vl);\n        v_result = vssra_vi_u64m1(v_result, 1, vl);\n        vse64_v_u64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t vec_src1 = vle64_v_i64m8(src1 + i, vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(src2 + i, vl);\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar = vmv_s_x_i64m8(scalar, vl);\n        vec_sum = vadd_vv_i64m8(vec_sum, vec_scalar, vl);\n        vint64m8_t vec_half = vsra_vx_i64m8(vec_sum, 1, vl);\n        vse64_v_i64m8(dst + i, vec_half, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t vec_src1 = vle64_v_i64m8(src1 + i, vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(src2 + i, vl);\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar = vmv_s_x_i64m8(scalar, vl);\n        vec_sum = vadd_vv_i64m8(vec_sum, vec_scalar, vl);\n        vint64m8_t vec_half = vdiv_vx_i64m8(vec_sum, 2, vl);\n        vse64_v_i64m8(dst + i, vec_half, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t vec_src1 = vle64_v_i64m8(src1 + i, vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(src2 + i, vl);\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar = vmv_s_x_i64m8(scalar, vl);\n        vec_sum = vadd_vv_i64m8(vec_sum, vec_scalar, vl);\n        vint64m8_t vec_half = vsra_vx_i64m8(vec_sum, 1, vl);\n        vse64_v_i64m8(dst + i, vec_half, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v = vle32_v_i32m1(src + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vsub_vx_i32m1(v, i), 1), 0, vl);\n\n        int32_t scalar_min = min_val;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i32m1(v, j) < scalar_min && vget_v_i1(mask, j)) {\n                scalar_min = vget_v_i32m1(v, j);\n            }\n        }\n        min_val = scalar_min;\n    }\n\n    if (min_val == INT_MAX) {\n        return -1;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v = vle32_v_i32m1(src + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vsub_vx_i32m1(v, i), 1), 0, vl);\n\n        size_t active_elements = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i32m1(v, j) == vget_v_i32m1(v, j) && vget_v_i32m1(v, j) != 0) {\n                active_elements++;\n            }\n        }\n\n        if (active_elements > 0) {\n            for (size_t j = 0; j < vl; ++j) {\n                if (vget_v_i32m1(v, j) == vget_v_i32m1(v, j) && vget_v_i32m1(v, j) != 0 && i + j < length && (i + j) % 2 == 0) {\n                    int current_val = src[i + j];\n                    if (current_val < min_val) {\n                        min_val = current_val;\n                    }\n                }\n            }\n        }\n    }\n\n    if (min_val == INT_MAX) {\n        \n        min_val = INT_MAX;\n        for(size_t i = 0; i < length; ++i){\n            if(i % 2 == 0){\n                if(src[i] < min_val){\n                    min_val = src[i];\n                }\n            }\n        }\n        if(min_val == INT_MAX){\n            return -1;\n        }\n        else{\n            return min_val;\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v = vle32_v_i32m1(src + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vindex_range_i32m1(i, vl), 1), 0, vl);\n\n        int32_t scalar_min = min_val;\n        for (size_t j = 0; j < vl; ++j) {\n            if (mask[j]) {\n                if (src[i + j] < scalar_min) {\n                    scalar_min = src[i + j];\n                }\n            }\n        }\n        min_val = scalar_min;\n    }\n\n    if (min_val == INT_MAX)\n        return -1;\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v = vle32_v_i32m1(src + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vindex_seq_i32m1(0, vl), 1), 0, vl); // Check if even index\n\n        int32_t temp_min = min_val;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i32m1(v, j) < temp_min && vget_v_i1(mask, j)) {\n                temp_min = vget_v_i32m1(v, j);\n            }\n        }\n        min_val = temp_min;\n    }\n\n    if (min_val == INT_MAX)\n        return -1;\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = INT_MAX;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v = vle32_v_i32m1(src + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vindex_seq_i32m1(0, vl), 1), 0, vl);\n\n        int32_t temp_min = min_val;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i32m1(v, j) < temp_min && vget_v_i1(mask, j)) {\n                temp_min = vget_v_i32m1(v, j);\n            }\n        }\n        if (temp_min < min_val) {\n            min_val = temp_min;\n        }\n    }\n\n    if (min_val == INT_MAX)\n        return -1;\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t vs = vle32_v_i32m8(src + i, vl);\n        vint32m8_t arithmetic_shift = vsra_vx_i32m8(vs, shift, vl);\n        vuint32m8_t vus = vle32_v_u32m8((const uint32_t*)(src + i), vl);\n        vuint32m8_t logical_shift = vsrl_vx_u32m8(vus, shift, vl);\n        vint32m8_t logical_shift_int = vreinterpret_v_u32m8_i32m8(logical_shift);\n        vint32m8_t sum = vadd_vv_i32m8(arithmetic_shift, logical_shift_int, vl);\n        vse32_v_i32m8(dst + i, sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vint32m8_t vs = vle32_v_i32m8(src + i, vl);\n    vint32m8_t arith_shifted = vsra_vx_i32m8(vs, shift, vl);\n    vuint32m8_t vus = vreinterpret_v_i32m8_u32m8(vs);\n    vuint32m8_t logic_shifted = vsrl_vx_u32m8(vus, shift, vl);\n    vint32m8_t logic_shifted_int = vreinterpret_v_u32m8_i32m8(logic_shifted);\n    vint32m8_t sum = vadd_vv_i32m8(arith_shifted, logic_shifted_int, vl);\n    vse32_v_i32m8(dst + i, sum, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vint32m8_t vs = vle32_v_i32m8(src + i, vl);\n    vint32m8_t arith_shifted = vsra_vx_i32m8(vs, shift, vl);\n    vuint32m8_t vus = vreinterpret_v_i32m8_u32m8(vs);\n    vuint32m8_t logic_shifted = vsrl_vx_u32m8(vus, shift, vl);\n    vint32m8_t logic_shifted_int = vreinterpret_v_u32m8_i32m8(logic_shifted);\n    vint32m8_t sum = vadd_vv_i32m8(arith_shifted, logic_shifted_int, vl);\n    vse32_v_i32m8(dst + i, sum, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vint32m8_t vs = vle32_v_i32m8(src + i, vl);\n    vint32m8_t arithmetic_shift = vsra_vx_i32m8(vs, shift, vl);\n    vuint32m8_t vus = vreinterpret_v_u32m8_i32m8(vs);\n    vuint32m8_t logical_shift = vsrl_vx_u32m8(vus, shift, vl);\n    vint32m8_t logical_shift_int = vreinterpret_v_i32m8_u32m8(logical_shift);\n    vint32m8_t sum = vadd_vv_i32m8(arithmetic_shift, logical_shift_int, vl);\n    vse32_v_i32m8(dst + i, sum, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t vs = vle32_v_i32m8(src + i, vl);\n        vint32m8_t arith_shifted = vsra_vx_i32m8(vs, shift, vl);\n        vuint32m8_t vus = vreinterpret_v_u32m8_i32m8(vs);\n        vuint32m8_t logic_shifted = vsrl_vx_u32m8(vus, shift, vl);\n        vint32m8_t logic_shifted_int = vreinterpret_v_i32m8_u32m8(logic_shifted);\n        vint32m8_t sum = vadd_vv_i32m8(arith_shifted, logic_shifted_int, vl);\n        vse32_v_i32m8(dst + i, sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  int64_t sum = 0;\n\n  size_t vl;\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t v = vle32_v_i32m8(matrix + i, vl);\n    vint64m1_t sum_vec = vmv_v_x_i64m1(0, vl);\n    vint64m1_t widened_v = vwadd_wv_i64m1(sum_vec, v, vl);\n    sum += vretoi_i64m1_i64m1(vsum_i64m1(widened_v, vmv_s_x_i64m1(0, vl), vl), vl);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  int64_t sum = 0;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t v = vle32_v_i32m8(matrix + i, vl);\n    int64_t temp_sum = 0;\n    for (size_t j = 0; j < vl; ++j) {\n        temp_sum += vget_i32m8(v, j);\n    }\n    sum += temp_sum;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  int64_t sum = 0;\n\n  size_t vl;\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t v = vle32_v_i32m8(matrix + i, vl);\n    vint64m1_t sum_vec = vmv_v_x_i64m1(0, vl);\n    vint64m1_t widened_v = vwadd_wv_i64m1(sum_vec, v, vl);\n    sum += vretoi_i64m1_i64m1(vsum_i64m1(widened_v, vmv_s_x_i64m1(0, vl), vl), vl);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  int64_t sum = 0;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t v = vle32_v_i32m8(matrix + i, vl);\n    int64_t temp_sum = 0;\n    for (size_t j = 0; j < vl; ++j) {\n      temp_sum += vget_i32m8(v, j);\n    }\n    sum += temp_sum;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  int64_t sum = 0;\n\n  size_t vl;\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t v = vle32_v_i32m8(matrix + i, vl);\n    vint64m1_t sum_vec = vmv_v_x_i64m1(0, vl);\n    sum_vec = vwadd_reduc_i64m1(sum_vec, v);\n    sum += vget_i64(sum_vec, 0);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t v = vle8_v_i8m1(src + i, vl);\n    int8_t max_val_in_vector = vmv_x_s_i8m1_i8(v);\n    size_t index_of_max_in_vector = 0;\n\n    for (size_t j = 1; j < vl; ++j) {\n      int8_t current_val = vget_i8(v, j);\n      if (current_val > max_val_in_vector) {\n        max_val_in_vector = current_val;\n        index_of_max_in_vector = j;\n      }\n    }\n\n    if (max_val_in_vector > max_value) {\n      max_value = max_val_in_vector;\n      max_index = i + index_of_max_in_vector;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < length; i += vl) {\n        vl = vsetvl_e8_m8(length - i);\n        vint8m8_t v = vle8_v_i8m8(src + i, vl);\n        int8_t max_val_in_vector = vmv_x_s_i8m8_i8(v);\n        size_t index_of_max_in_vector = 0;\n\n        for (size_t j = 1; j < vl; ++j) {\n            int8_t current_val = vget_i8(v, j);\n            if (current_val > max_val_in_vector) {\n                max_val_in_vector = current_val;\n                index_of_max_in_vector = j;\n            }\n        }\n\n        if (max_val_in_vector > max_value) {\n            max_value = max_val_in_vector;\n            max_index = i + index_of_max_in_vector;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t v = vle8_v_i8m1(src + i, vl);\n    int8_t max_val_in_vector = vmv_x_s_i8m1_i8(v);\n    size_t max_index_in_vector = 0;\n\n    for (size_t j = 1; j < vl; ++j) {\n      int8_t current_val = vget_i8(v, j);\n      if (current_val > max_val_in_vector) {\n        max_val_in_vector = current_val;\n        max_index_in_vector = j;\n      }\n    }\n\n    if (max_val_in_vector > max_value) {\n      max_value = max_val_in_vector;\n      max_index = i + max_index_in_vector;\n    } else if (max_val_in_vector == max_value) {\n        if (i + max_index_in_vector < max_index)\n            max_index = i + max_index_in_vector;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t v = vle8_v_i8m1(src + i, vl);\n    int8_t max_val_in_vector = vmv_x_s_i8m1_i8(v);\n    size_t max_index_in_vector = 0;\n\n    for (size_t j = 1; j < vl; ++j) {\n      int8_t current_val = vget_i8(v, j);\n      if (current_val > max_val_in_vector) {\n        max_val_in_vector = current_val;\n        max_index_in_vector = j;\n      }\n    }\n\n    if (max_val_in_vector > max_value) {\n      max_value = max_val_in_vector;\n      max_index = i + max_index_in_vector;\n    } else if (max_val_in_vector == max_value) {\n        if (i + max_index_in_vector < max_index)\n            max_index = i + max_index_in_vector;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  size_t vl;\n  size_t i = 0;\n\n  for (; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t v = vle8_v_i8m1(src + i, vl);\n    int8_t max_val_vec = vmv_x_s_i8m1(v);\n    size_t current_max_index = 0;\n\n    for (size_t j = 0; j < vl; ++j) {\n      int8_t current_val = vget_i8(v, j);\n      if (current_val > max_value) {\n        max_value = current_val;\n        max_index = i + j;\n      }\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool2_t v_mask = vmseq_vx_i32m1_b2(vadd_vx_i32m1(vid_v_i32m1(vl), i, vl), mask, vl);\n        vuint16m8_t v_dst = vsel_v_u16m8(v_mask, v_src2, v_src1, vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool2_t v_mask = vmseq_vx_u32m8_b2(vid_v_u32m8(vl), 0, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) & mask){\n                v_mask[j] = 1;\n            } else {\n                v_mask[j] = 0;\n            }\n        }\n        \n        vuint16m8_t v_dst = vsel_v_u16m8(v_mask, v_src1, v_src2, vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool2_t v_mask = vmseq_vx_i32m1_b2(vand_vx_i32m1(vadd_vx_i32m1(vid_v_i32m1(vl), i, vl), mask, vl), 0, vl);\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_src1, v_src2, vnot_v_b2(v_mask), vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool2_t v_mask = vmseq_vx_i32m1_b2(vand_vx_i32m1(vadd_vx_i32m1(vid_v_i32m1(vl), i, vl), mask, vl), 0, vl);\n        vuint16m8_t v_dst = vsel_v_u16m8(v_mask, v_src2, v_src1, vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool2_t v_mask = vmseq_vx_i32m1_b2(vand_vx_i32m1(vadd_vx_i32m1(vid_v_i32m1(vl), i, vl), mask, vl), 0, vl);\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_src1, v_src2, vnot_v_b2(v_mask), vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m1(length - i);\n    vuint32m1_t v = vle32_v_u32m1(src + i, vl);\n    vuint32m1_t pop_count = vpopc_m_u32m1(v, vl);\n    vse32_v_u32m1(dst + i, pop_count, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint32m8_t pop_count = vpopc_m_u32m8(v, vl);\n    vse32_v_u32m8(dst + i, pop_count, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint32m8_t popc = vpopc_m_u32m8(v, vl);\n    vse32_v_u32m8(dst + i, popc, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint32m8_t pop_count = vpopc_m_u32m8(v, vl);\n    vse32_v_u32m8(dst + i, pop_count, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint32m8_t popc = vpopc_m_u32m8(v, vl);\n    vse32_v_u32m8(dst + i, popc, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e16m8(length - i);\n    vuint16m8_t vs1 = vle16_v_u16m8(src1 + i, vl);\n    vuint16m8_t vs2 = vle16_v_u16m8(src2 + i, vl);\n    vuint16m8_t vd = vsadd_vx_u16m8(vs1, 0, vl);\n    vd = vsadd_vv_u16m8(vs1, vs2, vl);\n    vse16_v_u16m8(dst + i, vd, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e16m8(length - i);\n    vuint16m8_t vs1 = vle16_v_u16m8(src1 + i, vl);\n    vuint16m8_t vs2 = vle16_v_u16m8(src2 + i, vl);\n    vuint16m8_t vd = vsadd_vx_u16m8(vs1, 0, vl);\n    vd = vsadd_vv_u16m8(vs1, vs2, vl);\n    vse16_v_u16m8(dst + i, vd, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t a = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t b = vle16_v_u16m8(src2 + i, vl);\n        vuint16m8_t result = vsadd_vx_u16m8(a, 0, vl);\n        result = vsadd_vv_u16m8(a, b, vl);\n        vse16_v_u16m8(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e16m8(length - i);\n    vuint16m8_t a = vle16_v_u16m8(src1 + i, vl);\n    vuint16m8_t b = vle16_v_u16m8(src2 + i, vl);\n    vuint16m8_t sum = vsadd_vx_u16m8(a, 0, vl);\n    sum = vsadd_vv_u16m8(a, b, vl);\n    vse16_v_u16m8(dst + i, sum, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t a = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t b = vle16_v_u16m8(src2 + i, vl);\n        vuint16m8_t result = vsadd_vx_u16m8(a, 0, vl);\n        result = vsadd_vv_u16m8(a, b, vl);\n        vse16_v_u16m8(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t k = 0; k < n; k += 4) {\n                vfloat64m4_t a_vec = vle64_v_f64m4(&A[i * n + k]);\n                vfloat64m4_t b_vec = vle64_v_f64m4(&B[k * p + j]);\n\n                // Create a mask for values in range [-100, 100]\n                vbool64_t mask_a = vmslt_v_f64m4(a_vec, 100.0);\n                mask_a = vmand_vb(mask_a, vmsgt_v_f64m4(a_vec, -100.0));\n                vbool64_t mask_b = vmslt_v_f64m4(b_vec, 100.0);\n                mask_b = vmand_vb(mask_b, vmsgt_v_f64m4(b_vec, -100.0));\n                vbool64_t mask = vmand_vb(mask_a, mask_b);\n\n                // Multiply and accumulate only where the mask is true\n                sum = vfadd_vv_f64m1(sum, vfmul_vv_f64m4(a_vec, b_vec, mask));\n            }\n            // Store the result\n            C[i * p + j] = vfmv_f_s_f64(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(A + i, vl);\n        vint64m8_t vb = vle64_v_i64m8(B + i, vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(A + i, vl);\n        vint64m8_t vb = vle64_v_i64m8(B + i, vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(A + i, vl);\n        vint64m8_t vb = vle64_v_i64m8(B + i, vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t c_vec = vadd_vv_u64m1(a_vec, b_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n\n    vuint64m1_t va = vle64_v_u64m1(A, vl);\n    vuint64m1_t vb = vle64_v_u64m1(B, vl);\n    vuint64m1_t vc = vadd_vv_u64m1(va, vb, vl);\n    vse64_v_u64m1(C, vc, vl);\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_result = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_result, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl); // Load src1\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl); // Load src2\n        vfloat32m1_t v_sum = vadd_vv_f32m1(v_src1, v_src2, vl); // Element-wise addition\n        vint32m1_t v_result = vrndne_v_f32m1(v_sum, vl); // Round to nearest integer\n        vse32_v_i32m1(&dst[i], v_result, vl); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_result = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_result, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_sum = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_sum, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_sum = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_sum, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i]);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i]);\n        \n        vfloat32m1_t v_diff = vsub_vv_f32m1(v_src1, v_src2);\n        vfloat32m1_t v_abs_diff = vfredusum_vs_f32m1(v_abs_diff, v_diff, vfmv_f_s_f32m1(0.0f));\n        \n        vbool32_t mask = vmslt_vv_f32m1(v_abs_diff, vfmv_f_s_f32m1(50.0f));\n        vbool32_t index_mask = vmslt_vx_i32m1(vsetvl_e32m1(i), 2);\n        vbool32_t final_mask = vand_vv_b32(mask, index_mask);\n        \n        vfloat32m1_t v_result = vmul_vv_f32m1(v_src1, v_src2);\n        v_result = vfnmacc_vv_f32m1(v_result, vfmv_f_s_f32m1(-1.0f), final_mask);\n        \n        v_result = vrndau_v_f32m1(v_result);\n        \n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i]);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i]);\n        \n        vfloat32m1_t v_diff = vsub_vv_f32m1(v_src1, v_src2);\n        vfloat32m1_t v_abs_diff = vfredusum_vs_f32m1(v_max_f32m1(v_diff, vneg_v_f32m1(v_diff)), vfmv_f_s_f32m1(0, vl), vl);\n        \n        vbool32_t mask = vmsltu_vv_f32m1(v_abs_diff, vfmv_f_s_f32m1(50, vl));\n        vbool32_t index_mask = vmsltu_vx_i32m1(vsetvl_e32m1(i), 2);\n        vbool32_t final_mask = vand_vv_b32(mask, index_mask);\n        \n        vfloat32m1_t v_result = vmul_vv_f32m1(v_src1, v_src2);\n        v_result = vrndau_v_f32m1(v_result);\n        \n        vfloat32m1_t v_neg_one = vfmv_f_s_f32m1(-1, vl);\n        v_result = vmerge_vv_f32m1(v_neg_one, v_result, final_mask);\n        \n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t v_src1 = vle32_v_f32m8(src1 + i, vl);\n        vfloat32m8_t v_src2 = vle32_v_f32m8(src2 + i, vl);\n\n        vfloat32m8_t v_diff = vfsub_vv_f32m8(v_src1, v_src2, vl);\n        vfloat32m8_t v_abs_diff = vfabs_v_f32m8(v_diff, vl);\n\n        vbool4_t v_condition1 = vmflt_vf_f32m8(v_abs_diff, 50.0f, vl);\n\n        vbool4_t v_index_condition = vmxor_mm_b4(v_condition1, v_condition1, vl);\n        for (int j = 0; j < vl; ++j) {\n            if ((i + j) % 2 == 0) {\n                v_index_condition = vsetbit_vx_b4(v_index_condition, j, 1, vl);\n            } else {\n                v_index_condition = vsetbit_vx_b4(v_index_condition, j, 0, vl);\n            }\n        }\n\n        vbool4_t v_final_condition = vand_mm_b4(v_condition1, v_index_condition, vl);\n\n        vfloat32m8_t v_result = vfmv_v_f_f32m8( -1.0f, vl);\n        vfloat32m8_t v_mul = vfmul_vv_f32m8(v_src1, v_src2, vl);\n        \n        for (int j = 0; j < vl; ++j) {\n            if (vget_v_i1(v_final_condition, j)) {\n                dst[i + j] = ceilf(src1[i + j] * src2[i + j]);\n            } else {\n                dst[i + j] = -1.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t v_src1 = vle32_v_f32m8(src1 + i, vl);\n        vfloat32m8_t v_src2 = vle32_v_f32m8(src2 + i, vl);\n\n        vfloat32m8_t v_diff = vfsub_vv_f32m8(v_src1, v_src2, vl);\n        vfloat32m8_t v_abs_diff = vfabs_v_f32m8(v_diff, vl);\n        vbool4_t v_mask = vmflt_vf_f32m8(v_abs_diff, 50.0f, vl);\n\n        size_t j;\n        for(j = 0; j < vl; j++){\n            if(i + j < length && (i + j) % 2 != 0){\n                v_mask[j] = 0;\n            }\n        }\n        \n        vfloat32m8_t v_mul = vfmul_vv_f32m8(v_src1, v_src2, vl);\n        \n        float results[vl];\n        for(j = 0; j < vl; j++){\n            if(v_mask[j]){\n                results[j] = ceilf(v_mul[j]);\n            } else {\n                results[j] = -1.0f;\n            }\n        }\n        \n        vfloat32m8_t v_results = vset_v_f32m8(results, vl);\n        vse32_v_f32m8(dst + i, v_results, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t v_src1 = vle32_v_f32m8(src1 + i, vl);\n        vfloat32m8_t v_src2 = vle32_v_f32m8(src2 + i, vl);\n\n        vfloat32m8_t v_diff = vfsub_vv_f32m8(v_src1, v_src2, vl);\n        vfloat32m8_t v_abs_diff = vfabs_v_f32m8(v_diff, vl);\n\n        vbool4_t v_condition1 = vmflt_vf_f32m8(v_abs_diff, 50.0f, vl);\n        \n        vbool4_t v_index_condition = vmxor_vi_i1(v_index_condition, v_index_condition, 0, vl);\n        for(int j = 0; j < vl; j++){\n            if((i + j) % 2 == 0){\n                v_index_condition = vse1_v_b4(vtrue_b4(), vtrue_b4(), v_index_condition, j, vl);\n            }\n        }\n\n        vbool4_t v_final_condition = vand_mm_b4(v_condition1, v_index_condition, vl);\n\n        vfloat32m8_t v_mul = vfmul_vv_f32m8(v_src1, v_src2, vl);\n        \n        vfloat32m8_t v_result = vfrsqrt_v_f32m8(v_mul, vl);\n        v_result = vfdiv_vf_f32m8(v_mul, v_result, vl);\n        \n        for(int j = 0; j < vl; j++){\n            if(vget_v_b1(v_final_condition, j)){\n                dst[i + j] = ceilf(vget_v_f32(v_result, j));\n            } else {\n                dst[i + j] = -1.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < m * n; i += vl) {\n        vl = vsetvl_e64m8(m * n - i);\n        vfloat64m8_t v_mat = vle_v_f64m8(mat + i, vl);\n        vfloat64m8_t v_dst = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse_v_f64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < m * n; i += vl) {\n        vl = vsetvl_e64m8(m * n - i);\n        vfloat64m8_t v_mat = vle_v_f64m8(mat + i, vl);\n        vfloat64m8_t v_dst = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse_v_f64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t vl;\n  size_t i = 0;\n  for (; i < m * n; i += vl) {\n    vl = vsetvl_e64m8(m * n - i);\n    vfloat64m8_t v_mat = vle64_v_f64m8(mat + i, vl);\n    vfloat64m8_t v_scalar = vfmv_s_f_f64m8(scalar, vl);\n    vfloat64m8_t v_dst = vfmul_vv_f64m8(v_mat, v_scalar, vl);\n    vse64_v_f64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t vl;\n  size_t i = 0;\n  for (; i < m * n; i += vl) {\n    vl = vsetvl_e64m8(m * n - i);\n    vfloat64m8_t v_mat = vle_v_f64m8(mat + i, vl);\n    vfloat64m8_t v_dst = vfmul_vf_f64m8(v_mat, scalar, vl);\n    vse_v_f64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t i = 0;\n    for (; i < m * n; i += vl) {\n        vl = vsetvl_e64m8(m * n - i);\n        vfloat64m8_t v_mat = vle_v_f64m8(mat + i, vl);\n        vfloat64m8_t v_dst = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse_v_f64m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t vl;\n        size_t j = 0;\n\n        for (; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n            vfloat32m8_t v_sq = vfmul_vv_f32m8(v, v, vl);\n            float sum_vec[8];\n            vse32_v_f32m8(sum_vec, v_sq, vl);\n\n            for(int k = 0; k < vl; k++){\n                sum_sq += sum_vec[k];\n            }\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        for (; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n            vfloat32m8_t v_norm = vfmv_s_f_f32m8(norm, vl);\n            vfloat32m8_t v_res = vfdiv_vf_f32m8(v, v_norm, vl);\n            vse32_v_f32m8(mat + i * n + j, v_res, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m; ++i) {\n    float sum_sq = 0.0f;\n    size_t j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_sq = vfmul_vv_f32m8(v, v, vl);\n      sum_sq += vfredusum_vs_f32m8_f32m1(v_sq, vdup_v_f32m1(0.0f, 1), v, vl);\n    }\n    float norm = sqrtf(sum_sq);\n    j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_norm = vfdiv_vf_f32m8(v, norm, vl);\n      vse32_v_f32m8(mat + i * n + j, v_norm, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    float row_norm = 0.0f;\n    size_t j = 0;\n\n    // Vectorized L^2 norm calculation\n    for (; j < n; j += vflen_wf32()) {\n      size_t vl = vmin_zu(n - j, vflen_wf32());\n      vfloat32m8_t v_row = vle32_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_sq = vfmul_vv_f32m8(v_row, v_row, vl);\n      row_norm += vfredusum_vs_f32m8_f32m1(v_sq, v_init_f32m1(0.0f), vl);\n    }\n\n    row_norm = sqrtf(row_norm);\n\n    // Vectorized normalization\n    j = 0;\n    for (; j < n; j += vflen_wf32()) {\n      size_t vl = vmin_zu(n - j, vflen_wf32());\n      vfloat32m8_t v_row = vle32_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_norm = vfmv_s_f_f32m8(row_norm, vl);\n      vfloat32m8_t v_normalized = vfdiv_vf_f32m8(v_row, v_norm, vl);\n      vse32_v_f32m8(mat + i * n + j, v_normalized, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    float sum_sq = 0.0f;\n    size_t vl;\n    size_t j = 0;\n\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      v = vfmul_vv_f32m8(v, v, vl);\n      sum_sq += vfredusum_vs_f32m8_f32m1(v, vinit_f32m1(0.0f), vl);\n    }\n\n    float norm = sqrtf(sum_sq);\n\n    j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      v = vfdiv_vf_f32m8(v, norm, vl);\n      vse32_v_f32m8(mat + i * n + j, v, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    float sum_sq = 0.0f;\n    size_t vl;\n    size_t j = 0;\n\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      v = vfmul_vv_f32m8(v, v, vl);\n      sum_sq += vfredusum_vs_f32m8_f32m1(v, vinit_f32m1(0.0f), vl);\n    }\n\n    float norm = sqrtf(sum_sq);\n\n    j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v = vle32_v_f32m8(mat + i * n + j, vl);\n      v = vfdiv_vf_f32m8(v, norm, vl);\n      vse32_v_f32m8(mat + i * n + j, v, vl);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n  size_t i, j, k;\n  for (i = 0; i < m; ++i) {\n    for (j = 0; j < p; ++j) {\n      double sum = 0.0;\n      size_t vl;\n      for (k = 0; k < n; k += vl) {\n        vl = vsetvl_e64m8(n - k);\n        vfloat64m8_t vec_a = vle64_v_f64m8(&mat1[i * n + k], vl);\n        vfloat64m8_t vec_b = vle64_v_f64m8(&mat2[k * p + j], vl);\n        vfloat64m8_t vec_mul = vfmul_vv_f64m8(vec_a, vec_b, vl);\n        double temp_sum[8];\n        vse64_v_f64m8(temp_sum, vec_mul, vl);\n        for(size_t l = 0; l < vl; l++){\n            sum += temp_sum[l];\n        }\n      }\n      dst[i * p + j] = round(sum);\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            vfloat32m8_t vec_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            vfloat32m8_t vec_rounded = vfadd_vf_f32m8(vfnmacc_vf_f32m8(vfmv_v_f_f32m8(0.25f, vl), vec_src, 4.0f), 0.5f, vl);\n            vfloat32m8_t vec_result = vfmul_vf_f32m8(vrnd_v_f32m8(vec_rounded, vl), 0.25f, vl);\n            for (size_t k = 0; k < vl; ++k) {\n                dst[(j + k) * rows + i] = vget_f32m8(vec_result, k);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            vfloat32m8_t vec_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            vfloat32m8_t rounded_vec = vfadd_vf_f32m8(vec_src, 0.125f, vl);\n            rounded_vec = vfmv_v_f_f32m8(truncf(rounded_vec * 4.0f) / 4.0f, vl);\n            for (size_t k = 0; k < vl; ++k) {\n                dst[(j + k) * rows + i] = vfmv_f_s_f32m8_f32(rounded_vec, k);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            vfloat32m8_t vec_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            vfloat32m8_t vec_rounded = vfadd_vf_f32m8(vfnmacc_vf_f32m8(vfmv_v_f_f32m8(0.25f, vl), vec_src, 4.0f, vl), 0.5f, vl);\n            vfloat32m8_t vec_quarter = vfmul_vf_f32m8(vfwcvt_f_f_v_f32m8_tu(vec_rounded, vec_rounded, vl), 0.25f, vl);\n\n            for (size_t k = 0; k < vl; ++k) {\n                dst[(j + k) * rows + i] = vfmv_f_s_f32m8_f32(vec_quarter, k);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            vfloat32m8_t v_rounded = vfadd_vf_f32m8(v_src, 0.125, vl);\n            v_rounded = vfmv_v_f_f32m8(floorf(vfmul_vf_f32m8(v_rounded, 4.0, vl)), vl);\n            v_rounded = vfdiv_vf_f32m8(v_rounded, 4.0, vl);\n\n            for (size_t k = 0; k < vl; ++k) {\n                dst[(j + k) * rows + i] = vfmv_f_s_f32m8(vget_v_f32m8(v_rounded, k), 0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i += 4) {\n        for (j = 0; j < cols; j += 4) {\n            vfloat32m4_t v0 = vle32_v_f32m4(&src[i * cols + j]);\n            vfloat32m4_t v1 = vle32_v_f32m4(&src[(i + 1) * cols + j]);\n            vfloat32m4_t v2 = vle32_v_f32m4(&src[(i + 2) * cols + j]);\n            vfloat32m4_t v3 = vle32_v_f32m4(&src[(i + 3) * cols + j]);\n\n            vfloat32m4_t v0_rounded = vfmv_v_f_f32m4(v0, 0.25f);\n            vfloat32m4_t v1_rounded = vfmv_v_f_f32m4(v1, 0.25f);\n            vfloat32m4_t v2_rounded = vfmv_v_f_f32m4(v2, 0.25f);\n            vfloat32m4_t v3_rounded = vfmv_v_f_f32m4(v3, 0.25f);\n\n            vse32_v_f32m4(&dst[j * rows + i], v0_rounded);\n            vse32_v_f32m4(&dst[j * rows + i + 1], v1_rounded);\n            vse32_v_f32m4(&dst[j * rows + i + 2], v2_rounded);\n            vse32_v_f32m4(&dst[j * rows + i + 3], v3_rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i); // Set vector length\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_zo_v_f32m1(v_result, vl); // Round towards zero\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i); // Set vector length\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl); // Round towards zero\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i); // Set vector length\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl); // Round towards zero\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i); // Set vector length\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl); // Round towards zero\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i);\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl);\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2);\n        vse64_v_f64m1(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i); // Set vector length\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]); // Load mat1\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]); // Load mat2\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2); // Element-wise multiplication\n        vse64_v_f64m1(&dst[i], v_dst); // Store result in dst\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2);\n        vse64_v_f64m1(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i); // Set vector length\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i], vl);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i], vl);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2, vl);\n        vse64_v_f64m1(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m * n; i += vl) {\n    vl = vsetvl_e64m8(m * n - i);\n    vfloat64m8_t v_mat1 = vle_v_f64m8(mat1 + i, vl);\n    vfloat64m8_t v_mat2 = vle_v_f64m8(mat2 + i, vl);\n    vfloat64m8_t v_dst = vfmul_vv_f64m8(v_mat1, v_mat2, vl);\n    vse_v_f64m8(dst + i, v_dst, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    size_t j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v_mat = vle_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_vec = vle_v_f32m8(vec + j, vl);\n      vfloat32m8_t v_mul = vfmul_vv_f32m8(v_mat, v_vec, vl);\n      float temp_sum[8];\n      vse_v_f32m8(temp_sum, v_mul, vl);\n      for(size_t k = 0; k < vl; ++k){\n        sum += temp_sum[k];\n      }\n    }\n    dst[i] = sum;\n  }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    size_t j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v_mat = vle_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_vec = vle_v_f32m8(vec + j, vl);\n      vfloat32m8_t v_mul = vfmul_vv_f32m8(v_mat, v_vec, vl);\n      float temp_sum[8];\n      vse_v_f32m8(temp_sum, v_mul, vl);\n      for(size_t k = 0; k < vl; ++k){\n        sum += temp_sum[k];\n      }\n    }\n    dst[i] = sum;\n  }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    size_t j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8_max_len();\n      if (j + vl > n) {\n        vl = n - j;\n      }\n      vfloat32m8_t v_mat = vle32_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_vec = vle32_v_f32m8(vec + j, vl);\n      vfloat32m8_t v_mul = vfmul_vv_f32m8(v_mat, v_vec, vl);\n      float temp_sum[8];\n      vse32_v_f32m8(temp_sum, v_mul, vl);\n      for(size_t k = 0; k < vl; k++){\n        sum += temp_sum[k];\n      }\n    }\n    dst[i] = sum;\n  }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n        for (; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t v_mat = vle_v_f32m8(mat + i * n + j, vl);\n            vfloat32m8_t v_vec = vle_v_f32m8(vec + j, vl);\n            vfloat32m8_t v_mul = vfmul_vv_f32m8(v_mat, v_vec, vl);\n            float temp_sum[8];\n            vse_v_f32m8(temp_sum, v_mul, vl);\n            for(size_t k = 0; k < vl; ++k){\n                sum += temp_sum[k];\n            }\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  size_t vl;\n  for (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    size_t j = 0;\n    for (; j < n; j += vl) {\n      vl = vsetvl_e32m8(n - j);\n      vfloat32m8_t v_mat = vle_v_f32m8(mat + i * n + j, vl);\n      vfloat32m8_t v_vec = vle_v_f32m8(vec + j, vl);\n      vfloat32m8_t v_mul = vfmul_vv_f32m8(v_mat, v_vec, vl);\n      float temp_sum[8];\n      vse_v_f32m8(temp_sum, v_mul, vl);\n      for(size_t k = 0; k < vl; ++k){\n        sum += temp_sum[k];\n      }\n    }\n    dst[i] = sum;\n  }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n  size_t vl;\n  double sum = 0.0;\n  size_t total_elements = m * n;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t vec = vle64_v_f64m8(mat + i, vl);\n    sum += vfmv_f_s_f64m8_f64(vfredosum_vs_f64m8_f64m1(vundefined_f64m1(), vec, vundefined_f64m1(), vl));\n  }\n\n  return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n  size_t vl;\n  double sum = 0.0;\n  size_t total_elements = m * n;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v = vle64_v_f64m8(mat + i, vl);\n    sum += vsum_f64m8_f64m1(v, vdup_v_f64m1(0.0, 1), vl);\n  }\n\n  return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n  size_t vl;\n  double sum = 0.0;\n  size_t total_elements = m * n;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v = vle64_v_f64m8(mat + i, vl);\n    sum += vsum_f64m8_f64m1(v, vdup_v_f64m1(0.0, 1), vl);\n  }\n\n  return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n  size_t vl;\n  double sum = 0.0;\n  size_t total_elements = m * n;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t vec = vle64_v_f64m8(mat + i, vl);\n    sum += vsum_f64m8_f64m1(vec, vfloat64m1_s_zero(), vl);\n  }\n\n  return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n  size_t vl;\n  double sum = 0.0;\n  size_t total_elements = m * n;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e64m8(total_elements - i);\n    vfloat64m8_t v = vle64_v_f64m8(mat + i, vl);\n    sum += vsum_f64m8_f64m1(v, vdup_v_f64m1(0.0, 1), vl);\n  }\n\n  return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    bool ascending = directions[i];\n    const int* row = matrix + i * cols;\n\n    for (size_t j = 0; j < cols - 1; j += vl) {\n      vl = vsetvl_e32m1(cols - 1 - j);\n      vint32m1_t current = vle32_v_i32m1(row + j, vl);\n      vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n      vbool32_t result;\n\n      if (ascending) {\n        result = vmleq_vv_i32m1_b32(current, next, vl);\n      } else {\n        result = vmgeq_vv_i32m1_b32(current, next, vl);\n      }\n\n      if (!vtest_all_e32(result, vl)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n    bool ascending = directions[i];\n\n    for (size_t j = 0; j < cols - 1; j += vl) {\n      vl = vsetvl_e32m1(cols - 1 - j);\n      vint32m1_t current = vle32_v_i32m1(row + j, vl);\n      vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n\n      vbool32_t result;\n      if (ascending) {\n        result = vmleq_vv_i32m1_b32(current, next, vl);\n      } else {\n        result = vmgeq_vv_i32m1_b32(current, next, vl);\n      }\n\n      size_t k = 0;\n      while (k < vl) {\n        if (!vget_v_i1(result, k)) {\n          return false;\n        }\n        k++;\n      }\n    }\n  }\n  return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        size_t vl;\n        size_t j = 0;\n        for (; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t current = vle32_v_i32m1(row + j, vl);\n            vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n\n            vbool32_t result;\n            if (ascending) {\n                result = vmleq_vv_i32m1_b32(current, next, vl);\n            } else {\n                result = vmgeq_vv_i32m1_b32(current, next, vl);\n            }\n\n            size_t k;\n            for (k = 0; k < vl; ++k) {\n                if (!vget_v_i1(result, k)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    bool ascending = directions[i];\n    const int* row = matrix + i * cols;\n\n    for (size_t j = 0; j < cols - 1; j += vl) {\n      vl = vsetvl_e32m1(cols - 1 - j);\n      vint32m1_t current = vle32_v_i32m1(row + j, vl);\n      vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n      vbool32_t result;\n\n      if (ascending) {\n        result = vmleq_vv_i32m1_b32(current, next, vl);\n      } else {\n        result = vmgeq_vv_i32m1_b32(current, next, vl);\n      }\n\n      if (!vtest_all_e32(result, vl)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        size_t vl;\n        size_t j = 0;\n        for (; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t current = vle32_v_i32m1(row + j, vl);\n            vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n\n            vbool32_t result;\n            if (ascending) {\n                result = vmleq_vv_i32m1_b32(current, next, vl);\n            } else {\n                result = vmgeq_vv_i32m1_b32(current, next, vl);\n            }\n\n            size_t k;\n            for (k = 0; k < vl; ++k) {\n                if (!vget_v_i1(result, k)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t vs = vle16_v_i16m8(src + i, vl);\n        vint16m8_t vb = vmv_v_x_i16m8((int16_t)base, vl);\n        vint16m8_t vd = vdiv_vv_i16m8(vs, vb, vl);\n        vd = vmul_vv_i16m8(vd, vb, vl);\n        vse16_v_i16m8(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t vs = vle16_v_i16m8(src + i, vl);\n        vint16m8_t vb = vmul_vx_i16m8(vs, 1.0/base, vl);\n        vint16m8_t vr = vtruncate_vx_i16m8(vb, vl);\n        vint16m8_t vd = vmul_vx_i16m8(vr, base, vl);\n        vse16_v_i16m8(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t vs = vle16_v_i16m8(src + i, vl);\n        vint16m8_t vb = vmul_vx_i16m8(vs, 1.0/base, vl);\n        vint16m8_t vr = vtruncate_vx_i16m8(vb, vl);\n        vint16m8_t vd = vmul_vx_i16m8(vr, base, vl);\n        vse16_v_i16m8(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t vs = vle16_v_i16m8(src + i, vl);\n        vint16m8_t vb = vmul_vx_i16m8(vs, 1.0/base, vl);\n        vint16m8_t vr = vtruncate_vx_i16m8(vb, vl);\n        vint16m8_t vd = vmul_vx_i16m8(vr, base, vl);\n        vse16_v_i16m8(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8_i16(length - i);\n        vint16m8_t vs = vle16_v_i16m8(src + i, vl);\n        vint16m8_t vb = vmul_vx_i16m8(vs, 1.0/base, vl);\n        vint16m8_t vr = vtruncate_vx_i16m8(vb, vl);\n        vint16m8_t vd = vmul_vx_i16m8(vr, base, vl);\n        vse16_v_i16m8(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n  size_t vl;\n  for (size_t i = 0; i < rows; ++i) {\n    bool row_matches = true;\n    size_t j = 0;\n    for (; j < cols; j += vl) {\n      vl = vsetvl_e64m8(cols - j);\n      vfloat64m8_t matrix_row_segment = vle64_v_f64m8(matrix + i * cols + j, vl);\n      vfloat64m8_t vector_segment = vle64_v_f64m8(vector + j, vl);\n      vbool8_t mask = vmfeq_vv_f64m8_b8(matrix_row_segment, vector_segment, vl);\n      size_t masked_elements = vpopc_m_b8(mask, vl);\n      if (masked_elements != vl) {\n        row_matches = false;\n        break;\n      }\n    }\n    if (row_matches) {\n      return true;\n    }\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vmslt_vv_f64m1(vle64_v_f64m1(matrix), vle64_v_f64m1(vector));\n    for (size_t i = 0; i < rows; i++) {\n        vdouble64m1_t mat_row = vle64_v_f64m1(matrix + i * cols);\n        vbool64_t cmp = vmfne_vv_f64m1(mat_row, vle64_v_f64m1(vector));\n        if (vfirst_m_b64(cmp) == -1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vundefined_b64();\n    for (size_t i = 0; i < rows; i++) {\n        vdouble64m8_t mat_row = vle64_v_d64m8(matrix + i * cols, vlux);\n        vdouble64m8_t vec = vle64_v_d64m8(vector, vlux);\n        vbool64_t cmp = vmfeq_vv_b64m8(mat_row, vec, vlux);\n        result = vorr_vv_b64(result, cmp, vlux);\n    }\n    return vredany_b64(result);\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t any_match = vundefined_b64();\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        vfloat64m8_t row_vec = vle64_v_f64m8(row);\n        vfloat64m8_t vec_vec = vle64_v_f64m8(vector);\n        vbool64_t match = vfcmp_eq_vv_f64m8(row_vec, vec_vec);\n        any_match = vorr_vb64(any_match, match);\n    }\n    return vredor_b64(any_match);\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t any_match = vundefined_b64();\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        vfloat64m8_t row_vec = vle64_v_f64m8(row, cols);\n        vfloat64m8_t vec = vle64_v_f64m8(vector, cols);\n        vbool64_t match = vfmv_f_f_b64m8(row_vec, vec);\n        any_match = vorr_b64(any_match, match);\n    }\n    return vredor_b64(any_match);\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a;\n    vuint8m1_t vec_b;\n    vbool1_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(&A[i], current_vl);\n        vec_b = vle8_v_u8m1(&B[i], current_vl);\n        \n        mask = vmseq_vv_u8m1(vec_a, vec_b, current_vl);\n        count += vpopc_m(mask, current_vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t va = vle8_v_u8m1(A, vl);\n    vuint8m1_t vb = vle8_v_u8m1(B, vl);\n    \n    vbool1_t mask = vmseq_vv_u8m1(va, vb, vl);\n    count += vpopc_m(mask, vl);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t a_vec, b_vec;\n    vbool1_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t n = vl > total_elements - i ? total_elements - i : vl;\n        a_vec = vle8_v_u8m1(&A[i]);\n        b_vec = vle8_v_u8m1(&B[i]);\n        mask = vmseq_vv_u8m1(a_vec, b_vec);\n        count += vpopc_m(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a = vle8_v_u8m1(A, vl);\n    vuint8m1_t vec_b = vle8_v_u8m1(B, vl);\n    \n    vbool8_t equal_mask = vmseq_vv_u8m1(vec_a, vec_b, vl);\n    count = vpopc_m(equal_mask, vl);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t va = vle8_v_u8m1(A, vl);\n    vuint8m1_t vb = vle8_v_u8m1(B, vl);\n    \n    vbool8_t mask = vmseq_vv_u8m1(va, vb, vl);\n    count = vpopc_m(mask, vl);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = __riscv_vsetvl_e64m8(length - i);\n    vint64m8_t vx = __riscv_vle64_v_i64m8(x + i, vl);\n    vint64m8_t vy = __riscv_vle64_v_i64m8(y + i, vl);\n    vint64m8_t vax = __riscv_vmul_vx_i64m8(vx, a, vl);\n    vint64m8_t vabsy = __riscv_vabs_v_i64m8(vy, vl);\n    vint64m8_t vresult = __riscv_vsub_vv_i64m8(vax, vabsy, vl);\n    __riscv_vse64_v_i64m8(y + i, vresult, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = __riscv_vsetvl_e64m8(length - i);\n    vint64m8_t vx = __riscv_vle64_v_i64m8(x + i, vl);\n    vint64m8_t vy = __riscv_vle64_v_i64m8(y + i, vl);\n    vint64m8_t v_a = __riscv_vmv_s_x_i64m8(a, vl);\n    vint64m8_t vmul = __riscv_vmul_vv_i64m8(v_a, vx, vl);\n    vint64m8_t vabs = __riscv_vabs_v_i64m8(vy, vl);\n    vint64m8_t vsub = __riscv_vsub_vv_i64m8(vmul, vabs, vl);\n    __riscv_vse64_v_i64m8(y + i, vsub, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = __riscv_vsetvl_e64m8(length - i);\n    vint64m8_t vx = __riscv_vle64_v_i64m8(x + i, vl);\n    vint64m8_t vy = __riscv_vle64_v_i64m8(y + i, vl);\n    vint64m8_t v_mult = __riscv_vmul_vx_i64m8(vx, a, vl);\n    vint64m8_t v_abs = __riscv_vabs_v_i64m8(vy, vl);\n    vint64m8_t v_res = __riscv_vsub_vv_i64m8(v_mult, v_abs, vl);\n    __riscv_vse64_v_i64m8(y + i, v_res, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = __riscv_vsetvl_e64m8(length - i);\n    vint64m8_t vx = __riscv_vle64_v_i64m8(x + i, vl);\n    vint64m8_t vy = __riscv_vle64_v_i64m8(y + i, vl);\n    vint64m8_t v_mult = __riscv_vmul_vx_i64m8(vx, a, vl);\n    vint64m8_t v_abs = __riscv_vabs_v_i64m8(vy, vl);\n    vint64m8_t v_res = __riscv_vsub_vv_i64m8(v_mult, v_abs, vl);\n    __riscv_vse64_v_i64m8(y + i, v_res, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = __riscv_vsetvl_e64m8(length - i);\n    vint64m8_t vx = __riscv_vle64_v_i64m8(x + i, vl);\n    vint64m8_t vy = __riscv_vle64_v_i64m8(y + i, vl);\n    vint64m8_t vax = __riscv_vmul_vx_i64m8(vx, a, vl);\n    vint64m8_t vabsy = __riscv_vabs_v_i64m8(vy, vl);\n    vint64m8_t vresult = __riscv_vsub_vv_i64m8(vax, vabsy, vl);\n    __riscv_vse64_v_i64m8(y + i, vresult, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16(length);\n    vuint16m1_t max_val = vundefined_u16m1();\n    vuint16m1_t min_val = vundefined_u16m1();\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t data = vle16_v_u16m1(&vec[i], vl);\n        \n        if (i == 0) {\n            max_val = data;\n            min_val = data;\n        } else {\n            max_val = vmaxu_vv_u16m1(max_val, data, vl);\n            min_val = vminu_vv_u16m1(min_val, data, vl);\n        }\n    }\n\n    MinMaxPair result;\n    result.max_num = vmax_u16m1(max_val);\n    result.min_num = vmin_u16m1(min_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = INT16_MAX;\n    result.max_num = INT16_MIN;\n\n    size_t vl;\n    vint16m8_t min_v = vmv_s_x_i16m8(INT16_MAX, vl);\n    vint16m8_t max_v = vmv_s_x_i16m8(INT16_MIN, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t v = vle16_v_i16m8(vec + i, vl);\n        min_v = vmin_vv_i16m8(min_v, v, vl);\n        max_v = vmax_vv_i16m8(max_v, v, vl);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vse16_v_i16m8(min_arr, min_v, 8);\n    vse16_v_i16m8(max_arr, max_v, 8);\n\n    for (int i = 0; i < 8; ++i) {\n        result.min_num = (min_arr[i] < result.min_num) ? min_arr[i] : result.min_num;\n        result.max_num = (max_arr[i] > result.max_num) ? max_arr[i] : result.max_num;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    size_t vl;\n    vint16m8_t min_v = vmv_s_x_i16m8(result.min_num, vl);\n    vint16m8_t max_v = vmv_s_x_i16m8(result.max_num, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t v = vle16_v_i16m8(vec + i, vl);\n        min_v = vmin_vv_i16m8(min_v, v, vl);\n        max_v = vmax_vv_i16m8(max_v, v, vl);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vse16_v_i16m8(min_arr, min_v, 8);\n    vse16_v_i16m8(max_arr, max_v, 8);\n\n    result.min_num = min_arr[0];\n    result.max_num = max_arr[0];\n\n    for(int i = 1; i < 8; ++i){\n        if(min_arr[i] < result.min_num){\n            result.min_num = min_arr[i];\n        }\n        if(max_arr[i] > result.max_num){\n            result.max_num = max_arr[i];\n        }\n    }\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    size_t vl;\n    vint16m8_t min_v = vmv_s_x_i16m8(result.min_num, vl);\n    vint16m8_t max_v = vmv_s_x_i16m8(result.max_num, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t v = vle16_v_i16m8(vec + i, vl);\n        min_v = vmin_vv_i16m8(min_v, v, vl);\n        max_v = vmax_vv_i16m8(max_v, v, vl);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vse16_v_i16m8(min_arr, min_v, 8);\n    vse16_v_i16m8(max_arr, max_v, 8);\n\n    result.min_num = min_arr[0];\n    result.max_num = max_arr[0];\n\n    for(int i = 1; i < 8; i++){\n        if(min_arr[i] < result.min_num){\n            result.min_num = min_arr[i];\n        }\n        if(max_arr[i] > result.max_num){\n            result.max_num = max_arr[i];\n        }\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    size_t vl;\n    vint16m8_t min_v = vmv_s_x_i16m8(result.min_num, vl);\n    vint16m8_t max_v = vmv_s_x_i16m8(result.max_num, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vint16m8_t v = vle16_v_i16m8(vec + i, vl);\n        min_v = vmin_vv_i16m8(min_v, v, vl);\n        max_v = vmax_vv_i16m8(max_v, v, vl);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vse16_v_i16m8(min_arr, min_v, 8);\n    vse16_v_i16m8(max_arr, max_v, 8);\n\n    result.min_num = min_arr[0];\n    result.max_num = max_arr[0];\n\n    for(int i = 1; i < 8; ++i){\n        if(min_arr[i] < result.min_num){\n            result.min_num = min_arr[i];\n        }\n        if(max_arr[i] > result.max_num){\n            result.max_num = max_arr[i];\n        }\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t vl = 0;\n        const int* row = matrix + i * cols;\n        \n        for (size_t j = 0; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t current = vle32_v_i32m1(row + j, vl);\n            vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n            vbool32_t result = vmgt_vv_i32m1_b32(next, current, vl);\n\n            if (!vtest_all_e32(result, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t vl = 0;\n        for (size_t j = 0; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t v_current = vle32_v_i32m1(row + j, vl);\n            vint32m1_t v_next = vle32_v_i32m1(row + j + 1, vl);\n            vbool32_t v_compare = vmleq_vv_i32m1_b32(v_next, v_current, vl);\n            if (vfirst_m_b32(v_compare, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t vl = 0;\n        for (size_t j = 0; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t current = vle32_v_i32m1(matrix + i * cols + j, vl);\n            vint32m1_t next = vle32_v_i32m1(matrix + i * cols + j + 1, vl);\n            vbool32_t result = vmleq_vv_i32m1_b32(next, current, vl);\n            if (vfirst_m_b32(result, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t vl = 0;\n        \n        for (size_t j = 0; j < cols - 1; j += vl) {\n            vl = vsetvl_e32m1(cols - 1 - j);\n            vint32m1_t current = vle32_v_i32m1(row + j, vl);\n            vint32m1_t next = vle32_v_i32m1(row + j + 1, vl);\n            vbool32_t result = vmleq_vv_i32m1_b32(next, current, vl);\n\n            if (vfirst_m_b32(result, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t vl = cols - 1;\n        const int* row = matrix + i * cols;\n        vint32m1_t prev = vle32_v_i32m1(row, vl);\n\n        for (size_t j = 1; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e32m1(cols - j);\n            vint32m1_t curr = vle32_v_i32m1(row + j, vl);\n            vbool32_t result = vmgt_vv_i32m1_b32(curr, prev, vl);\n\n            if (!vtest_all_e32m1(result, vl)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare other blocks with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t vl = vsetvl_e32m8(block_size);\n                const int *ptr_first = first_block + i * block_size;\n                const int *ptr_current = matrix + (block_row * block_size + i) * cols + (block_col * block_size);\n\n                vint32m8_t vec_first = vle32_v_i32m8(ptr_first, vl);\n                vint32m8_t vec_current = vle32_v_i32m8(ptr_current, vl);\n\n                vbool4_t mask = vmseq_vx_i32m8_b4(vec_first, vec_current, vl);\n                size_t all_equal = vmv_x_s_b4(mask);\n\n                if (all_equal != ((1UL << block_size) - 1)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare other blocks with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t vl = vsetvl_e32m8(block_size);\n                const int *row_ptr_first = first_block + i * block_size;\n                const int *row_ptr_current = matrix + (block_row * block_size + i) * cols + block_col * block_size;\n                \n                vint32m8_t vec_first = vle32_v_i32m8(row_ptr_first, vl);\n                vint32m8_t vec_current = vle32_v_i32m8(row_ptr_current, vl);\n                \n                vbool4_t mask = vme32_m_b4(vec_first, vec_current, vl);\n\n                if (!vtest_valid_mask(mask, vl)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t vl = vsetvl_e32m8(block_size);\n                const int *block_ptr = matrix + block_row * block_size * cols + block_col * block_size + i * cols;\n                int current_block_row[block_size];\n                for(size_t j = 0; j < block_size; j++){\n                    current_block_row[j] = block_ptr[j];\n                }\n                \n                vint32m8_t current_block_vec = vle32_v_i32m8(current_block_row, vl);\n                int first_block_row[block_size];\n                for(size_t j = 0; j < block_size; j++){\n                    first_block_row[j] = first_block[i * block_size + j];\n                }\n                vint32m8_t first_block_vec = vle32_v_i32m8(first_block_row, vl);\n                \n                vbool4_t mask = vmseq_vx_i32m8_b4(current_block_vec, first_block_vec, vl);\n                \n                if (!vtest_all_t_m_b4(mask, vl)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare other blocks with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = block_row * block_size + i;\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t col_offset = block_col * block_size + j;\n                    if (matrix[row_offset * cols + col_offset] != first_block[i * block_size + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Extract the first block\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t vl = vsetvl_e32m8(block_size);\n                const int *ptr_first = first_block + i * block_size;\n                const int *ptr_current = matrix + (block_row * block_size + i) * cols + block_col * block_size;\n\n                vint32m8_t vec_first = vle32_v_i32m8(ptr_first, vl);\n                vint32m8_t vec_current = vle32_v_i32m8(ptr_current, vl);\n\n                vbool4_t mask = vmseq_vx_i32m8_b4(vec_first, vec_current, vl);\n                size_t all_equal = vmv_x_s_b4(mask);\n\n                if (all_equal != ((1UL << block_size) - 1))\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    size_t vl = 0;\n    vfloat64m8_t first_block_v, current_block_v;\n    \n    // Load the first block\n    vl = vsetvl_e64m8(block_size);\n    first_block_v = vle64_v_f64m8(vec, vl);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        vl = vsetvl_e64m8(block_size);\n        current_block_v = vle64_v_f64m8(current_block_ptr, vl);\n\n        vfloat64m8_t diff_v = vfsub_vv_f64m8(first_block_v, current_block_v, vl);\n        vfloat64m8_t abs_diff_v = vfabs_v_f64m8(diff_v, vl);\n        vbool8_t compare_v = vmflt_vf_f64m8(abs_diff_v, tolerance, vl);\n\n        if (!vtest_all_e64m8(compare_v, vl)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    vfloat64m8_t first_block;\n    size_t vl = vsetvl_e64m8(block_size);\n    first_block = vle64_v_f64m8(vec, vl);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        vfloat64m8_t current_block = vle64_v_f64m8(current_block_ptr, vl);\n        vfloat64m8_t diff = vfsub_vv_f64m8(current_block, first_block, vl);\n        vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n        vbool8_t mask = vmflt_vf_f64m8(abs_diff, tolerance, vl);\n\n        if (!vtest_all_e64m8(mask, vl)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    size_t vl = vsetvl_e64m8(block_size);\n    vfloat64m8_t first_block = vle64_v_f64m8(vec, vl);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        vfloat64m8_t current_block = vle64_v_f64m8(current_block_ptr, vl);\n        vfloat64m8_t diff = vfsub_vv_f64m8(first_block, current_block, vl);\n        vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n        vbool8_t mask = vmflt_vf_f64m8(abs_diff, tolerance, vl);\n\n        size_t count = vpopc_m_b8(mask, vl);\n        if (count != block_size) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  size_t vl = 0;\n  vfloat64m8_t first_block_v, current_block_v;\n  \n  for (size_t i = 1; i < num_blocks; ++i) {\n    size_t offset = i * block_size;\n    size_t j = 0;\n    while (j < block_size) {\n      vl = vsetvl_e64m8(block_size - j);\n      if (i == 1 && j == 0) {\n        first_block_v = vle64_v_f64m8(vec + j, vl);\n      }\n      current_block_v = vle64_v_f64m8(vec + offset + j, vl);\n      vfloat64m8_t diff_v = vfsub_vv_f64m8(first_block_v, current_block_v, vl);\n      vfloat64m8_t abs_diff_v = vfabs_v_f64m8(diff_v, vl);\n      vbool8_t mask = vmflt_vf_f64m8_b8(abs_diff_v, tolerance, vl);\n      if (!vtest_all_e8(mask, vl)) {\n        return false;\n      }\n      j += vl;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    vfloat64m8_t first_block;\n    size_t vl = vsetvl_e64m8(block_size);\n    first_block = vle64_v_f64m8(vec, vl);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        vfloat64m8_t current_block = vle64_v_f64m8(current_block_ptr, vl);\n        vfloat64m8_t diff = vfsub_vv_f64m8(first_block, current_block, vl);\n        vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n        vbool8_t mask = vmflt_vf_f64m8(abs_diff, tolerance, vl);\n\n        if (!vtest_all_e8(mask, vl)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m8_t sum_vec = vfmv_v_f_f64m8(0.0, vl);\n        const double* row_ptr = matrix + i * cols;\n\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t data_vec = vle64_v_f64m8(row_ptr + j, vl);\n            sum_vec = vfmacc_vv_f64m8(sum_vec, data_vec, data_vec, vl);\n        }\n\n        double sum = vfmv_f_s_f64m8(sum_vec, 0);\n        for (int k = 1; k < vlen_in_bytes(vsetvlmax_e64m8()) / sizeof(double); ++k) {\n            sum += vfmv_f_s_f64m8(sum_vec, k);\n        }\n\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m8_t sum_vec = vfmv_s_f_f64m8(0.0, vl);\n        const double* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t row_vec = vle_v_f64m8(row_ptr + j, vl);\n            sum_vec = vfma_vv_f64m8(sum_vec, row_vec, row_vec, vl);\n        }\n        double sum = vfmv_f_s_f64m8(sum_vec);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m8_t sum_vec = vfmv_v_f_f64m8(0.0, vl);\n        const double* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vec = vle_v_f64m8(row_ptr + j, vl);\n            sum_vec = vfma_vv_f64m8(sum_vec, vec, vec, vl);\n        }\n        double sum = vfredusum_vs_f64m8_f64m1(sum_vec, vfmv_v_f_f64m1(0.0, vl), vl);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m8_t sum_vec = vfmv_v_f_f64m8(0.0, vl);\n        const double* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vec = vle_v_f64m8(row_ptr + j, vl);\n            sum_vec = vfma_vv_f64m8(sum_vec, vec, vec, vl);\n        }\n        double sum = vfmv_f_s_f64m8(vfredusum_vs_f64m8_f64m1(sum_vec, vfmv_v_f_f64m1(0.0, vl), vl),0);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m8_t sum_vec = vfmv_v_f_f64m8(0.0, vl);\n        const double* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t row_vec = vle64_v_f64m8(row_ptr + j, vl);\n            sum_vec = vfmacc_vv_f64m8(sum_vec, row_vec, row_vec, vl);\n        }\n        double sum = vfredusum_vs_f64m8_f64m1(sum_vec, vfmv_v_f_f64m1(0.0, vl), vl);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n    vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n    vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n    vse32_v_u32m8(C + i, vc, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n    vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n    vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n    vse32_v_u32m8(C + i, vc, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n    vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n    vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n    vse32_v_u32m8(C + i, vc, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  size_t vl;\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t va = vle8_v_i8m1(A + i, vl);\n    vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n    vint16m2_t va_i16 = vwmul_vv_i16m2(va, va, vl);\n    vint16m2_t vb_i16 = vwmul_vv_i16m2(va, vb, vl);\n\n    vint32m4_t va_i32 = vwadd_vx_i32m4(vwcvt_x_x_v_i16m2(va_i16, vl), 0, vl);\n    vint32m4_t vb_i32 = vwadd_vx_i32m4(vwcvt_x_x_v_i16m2(vb_i16, vl), 0, vl);\n\n    vint64m8_t va_i64 = vwadd_vx_i64m8(vwcvt_x_x_v_i32m4(va_i32, vl), 0, vl);\n    vint64m8_t vb_i64 = vwadd_vx_i64m8(vwcvt_x_x_v_i32m4(vb_i32, vl), 0, vl);\n\n    sum_sq += vsum_i64m8_i64_i64m1(0, va_i64, vl);\n    sum_prod += vsum_i64m8_i64_i64m1(0, vb_i64, vl);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  size_t vl;\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t va = vle8_v_i8m1(A + i, vl);\n    vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n    vint16m2_t va_i16 = vwmul_vv_i16m2(va, va, vl);\n    vint16m2_t vb_i16 = vwmul_vv_i16m2(va, vb, vl);\n\n    vint32m4_t va_i32 = vwadd_vx_i32m4(vwcvt_x_x_v_i16m2(va_i16, vl), 0, vl);\n    vint32m4_t vb_i32 = vwadd_vx_i32m4(vwcvt_x_x_v_i16m2(vb_i16, vl), 0, vl);\n\n    vint64m8_t va_i64 = vwadd_vx_i64m8(vwcvt_x_x_v_i32m4(va_i32, vl), 0, vl);\n    vint64m8_t vb_i64 = vwadd_vx_i64m8(vwcvt_x_x_v_i32m4(vb_i32, vl), 0, vl);\n    \n    sum_sq += vsum_i64m8_i64(sum_sq, va_i64, vl);\n    sum_prod += vsum_i64m8_i64(sum_prod, vb_i64, vl);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  size_t vl;\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e8_i8m1(length - i);\n    vint8m1_t va = vle8_v_i8m1(A + i, vl);\n    vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n    vint16m2_t va_i16 = vwmul_i8m1_i16m2(va, va, vl);\n    vint16m2_t vb_i16 = vwmul_i8m1_i16m2(va, vb, vl);\n\n    vint32m4_t va_i32 = vwadd_i16m2_i32m4(va_i16, vmv_v_x_i16m2(0, vl), vl);\n    vint32m4_t vb_i32 = vwadd_i16m2_i32m4(vb_i16, vmv_v_x_i16m2(0, vl), vl);\n    \n    vint64m8_t va_i64 = vwadd_i32m4_i64m8(va_i32, vmv_v_x_i32m4(0, vl), vl);\n    vint64m8_t vb_i64 = vwadd_i32m4_i64m8(vb_i32, vmv_v_x_i32m4(0, vl), vl);\n\n    sum_sq += vreduce_add_vs_i64m8_i64(sum_sq, va_i64, vmv_s_x_i64(0), vl);\n    sum_prod += vreduce_add_vs_i64m8_i64(sum_prod, vb_i64, vmv_s_x_i64(0), vl);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with RVV (RISC-V Vector Extension) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  size_t vl;\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e8m1(length - i);\n    vint8m1_t va = vle8_v_i8m1(A + i, vl);\n    vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n    vint16m2_t va_i16 = vwadd_vx_i16m2(va, 0, vl);\n    vint16m2_t vb_i16 = vwadd_vx_i16m2(vb, 0, vl);\n\n    vint32m4_t va_i32 = vwmul_vv_i32m4(va_i16, va_i16, vl);\n    vint32m4_t vb_i32 = vwmul_vv_i32m4(va_i16, vb_i16, vl);\n\n    vint64m8_t va_i64 = vwadd_vx_i64m8(va_i32, 0, vl);\n    vint64m8_t vb_i64 = vwadd_vx_i64m8(vb_i32, 0, vl);\n    \n    sum_sq += vreduce_add_i64m8_i64(0, va_i64, vl);\n    sum_prod += vreduce_add_i64m8_i64(0, vb_i64, vl);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  size_t vl;\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e8_i8m1(length - i);\n    vint8m1_t va = vle8_v_i8m1(A + i, vl);\n    vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n    vint16m2_t va_i16 = vwmul_vv_i16m2(va, va, vl);\n    vint16m2_t vb_i16 = vwmul_vv_i16m2(va, vb, vl);\n\n    vint32m4_t va_i32 = vwadd_vx_i32m4(vwiden_i16m2(va_i16, vl), 0, vl);\n    vint32m4_t vb_i32 = vwadd_vx_i32m4(vwiden_i16m2(vb_i16, vl), 0, vl);\n\n    vint64m8_t va_i64 = vwadd_vx_i64m8(vwiden_i32m4(va_i32, vl), 0, vl);\n    vint64m8_t vb_i64 = vwadd_vx_i64m8(vwiden_i32m4(vb_i32, vl), 0, vl);\n    \n    sum_sq += vreduce_add_vs_i64m8_i64(sum_sq, va_i64, vmv_s_x_i64(0), vl);\n    sum_prod += vreduce_add_vs_i64m8_i64(sum_prod, vb_i64, vmv_s_x_i64(0), vl);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vnotb = vmseq_vx_u64m8(vb, -1, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vnotb, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vnotb = vmseq_vx_u64m8(vb, -1, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vnotb, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vnotb = vmseq_vx_u64m8(vb, -1, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vnotb, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e64m8(length - i);\n    vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n    vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n    vuint64m8_t vc = vand_vx_u64m8(va, ~0UL, vl);\n    vc = vand_v_u64m8(vc,vmnot_m_u64m8(vmsne_vx_u64m8(vb,vb,vl),vb,vl),vl);\n    vse64_v_u64m8(C + i, vandn_v_u64m8(vb,va,vl), vl);\n  }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vnotb = vmseq_vx_u64m8(vb, -1, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vnotb, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vint8m1_t vc = vmv_v_x_i8m1(0, vl);\n\n        vbool8_t pos_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), 1, vl);\n        vbool8_t pos_mask_b = vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), 1, vl);\n        vbool8_t both_pos_mask = vand_mm_b8(pos_mask, pos_mask_b, vl);\n        vc = vmerge_vxm_i8m1(both_pos_mask, vc, 1, vl);\n\n        vbool8_t neg_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), -1, vl);\n        vbool8_t neg_mask_b = vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), -1, vl);\n        vbool8_t both_neg_mask = vand_mm_b8(neg_mask, neg_mask_b, vl);\n        vc = vmerge_vxm_i8m1(both_neg_mask, vc, -1, vl);\n\n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vint8m1_t vc = vmv_v_x_i8m1(0, vl);\n\n        vbool8_t pos_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), 1, vl);\n        vbool8_t pos_mask_b = vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), 1, vl);\n        vbool8_t both_pos_mask = vand_mm_b8(pos_mask, pos_mask_b, vl);\n        vc = vmerge_vxm_i8m1(both_pos_mask, vc, 1, vc, vl);\n\n        vbool8_t neg_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), -1, vl);\n        vbool8_t neg_mask_b = vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), -1, vl);\n        vbool8_t both_neg_mask = vand_mm_b8(neg_mask, neg_mask_b, vl);\n        vc = vmerge_vxm_i8m1(both_neg_mask, vc, -1, vc, vl);\n\n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n        \n        vbool8_t pos_mask = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t neg_mask = vmsltu_v_u8m1(b_vec, 0);\n        \n        vuint8m1_t c_vec = vdup_v_u8m1(0);\n        c_vec = vsel_v_u8m1(c_vec, pos_mask, vdup_v_u8m1(1));\n        c_vec = vsel_v_u8m1(c_vec, neg_mask, vdup_v_u8m1(255)); // -1 in 8-bit unsigned\n        \n        vse8_v_u8m1(&C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vint8m1_t vc = vmv_v_x_i8m1(0, vl); \n\n        vbool8_t pos_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), 1, vl) & vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), 1, vl);\n        vbool8_t neg_mask = vmseq_vx_i8m1(vsgnj_vx_i8m1(va, 0, vl), -1, vl) & vmseq_vx_i8m1(vsgnj_vx_i8m1(vb, 0, vl), -1, vl);\n\n        vc = vmerge_vxm_i8m1(pos_mask, vc, 1, vc, vl);\n        vc = vmerge_vxm_i8m1(neg_mask, vc, -1, vc, vl);\n\n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmseq_vx_i8m1_b8(va, 0, vl);\n        pos_a = vmnot_m_b8(pos_a, pos_a, vl);\n        vbool8_t pos_b = vmseq_vx_i8m1_b8(vb, 0, vl);\n        pos_b = vmnot_m_b8(pos_b, pos_b, vl);\n        vbool8_t both_pos = vand_mm_b8(pos_a, pos_b, vl);\n\n        vbool8_t neg_a = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmslt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t both_neg = vand_mm_b8(neg_a, neg_b, vl);\n\n        vint8m1_t result = vmul_vx_i8m1_m(both_pos, va, 1, vl);\n        vint8m1_t neg_one = vmul_vx_i8m1_m(both_neg, va, -1, vl);\n        result = vor_vx_i8m1_m(both_neg, result, 0, result, vl);\n        vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vxor = veor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vxor, vl);\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vand = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vxor = veor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vxor, vl);\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vand = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vxor = veor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vxor, vl);\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vand = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vxor = veor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vxor, vl);\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vand = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vxor = veor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vxor, vl);\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vand = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vbool4_t mask1 = vle1_v_b4m1(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4m1(cond2 + i, vl);\n\n        vfloat32m8_t vec_a = vle_v_f32m8(A + i, vl);\n        vfloat32m8_t vec_b = vle_v_f32m8(B + i, vl);\n        vfloat32m8_t vec_c = vle_v_f32m8(C + i, vl);\n        vfloat32m8_t vec_d = vle_v_f32m8(D + i, vl);\n        \n        vbool4_t both_true = vmand_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_true_cond2_false = vmandnot_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_false_cond2_true = vmandnot_mm_b4(mask2, mask1, vl);\n        vbool4_t both_false = vmnot_m_b4(vmoor_mm_b4(mask1, mask2, vl), vl);\n\n        vfloat32m8_t result = vmerge_vfm_f32m8(vec_b, vec_a, both_true, vl);\n        result = vmerge_vfm_f32m8(vec_c, result, cond1_true_cond2_false, vl);\n        result = vmerge_vfm_f32m8(vec_d, result, cond1_false_cond2_true, vl);\n        result = vmerge_vfm_f32m8(vec_d, result, both_false, vl);\n\n        vse_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vbool4_t mask1 = vle1_v_b4m1(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4m1(cond2 + i, vl);\n\n        vfloat32m8_t vec_a = vle_v_f32m8(A + i, vl);\n        vfloat32m8_t vec_b = vle_v_f32m8(B + i, vl);\n        vfloat32m8_t vec_c = vle_v_f32m8(C + i, vl);\n        vfloat32m8_t vec_d = vle_v_f32m8(D + i, vl);\n\n        vbool4_t both_true = vmand_mm_b4(mask1, mask2, vl);\n        vbool4_t first_true = vmandnot_mm_b4(mask1, mask2, vl);\n        vbool4_t second_true = vmandnot_mm_b4(mask2, mask1, vl);\n        vbool4_t both_false = vmnand_mm_b4(mask1, mask2, vl);\n\n        vfloat32m8_t result = vmerge_vvm_f32m8(vec_b, vec_a, both_true, vl);\n        result = vmerge_vvm_f32m8(vec_c, result, first_true, vl);\n        result = vmerge_vvm_f32m8(vec_d, result, second_true, vl);\n        \n        vse_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vbool4_t mask1 = vle1_v_b4m1(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4m1(cond2 + i, vl);\n\n        vfloat32m8_t vec_a = vle_v_f32m8(A + i, vl);\n        vfloat32m8_t vec_b = vle_v_f32m8(B + i, vl);\n        vfloat32m8_t vec_c = vle_v_f32m8(C + i, vl);\n        vfloat32m8_t vec_d = vle_v_f32m8(D + i, vl);\n\n        vbool4_t both_true = vmand_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_true_cond2_false = vmandnot_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_false_cond2_true = vmandnot_mm_b4(mask2, mask1, vl);\n        vbool4_t both_false = vmnot_m_b4(vmoor_mm_b4(mask1, mask2, vl), vl);\n\n        vfloat32m8_t result = vmerge_vfm_f32m8(vec_b, vec_a, both_true, vl);\n        result = vmerge_vfm_f32m8(vec_c, result, cond1_true_cond2_false, vl);\n        result = vmerge_vfm_f32m8(vec_d, result, cond1_false_cond2_true, vl);\n        \n        vse_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vbool4_t mask1 = vle1_v_b4m1(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4m1(cond2 + i, vl);\n\n        vfloat32m8_t vec_a = vle_v_f32m8(A + i, vl);\n        vfloat32m8_t vec_b = vle_v_f32m8(B + i, vl);\n        vfloat32m8_t vec_c = vle_v_f32m8(C + i, vl);\n        vfloat32m8_t vec_d = vle_v_f32m8(D + i, vl);\n        \n        vbool4_t both_true = vmand_mm_b4(mask1, mask2, vl);\n        vbool4_t first_true = vmandnot_mm_b4(mask1, mask2, vl);\n        vbool4_t second_true = vmandnot_mm_b4(mask2, mask1, vl);\n        vbool4_t both_false = vmnot_m_b4(vmoor_mm_b4(mask1, mask2, vl), vl);\n\n        vfloat32m8_t result = vmerge_vvm_f32m8(vec_b, vec_a, both_true, vl);\n        result = vmerge_vvm_f32m8(vec_c, result, first_true, vl);\n        result = vmerge_vvm_f32m8(vec_d, result, second_true, vl);\n        result = vmerge_vvm_f32m8(vec_d, result, both_false, vl);\n\n        vse_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vbool4_t mask1 = vle1_v_b4m1(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4m1(cond2 + i, vl);\n\n        vfloat32m8_t vec_a = vle_v_f32m8(A + i, vl);\n        vfloat32m8_t vec_b = vle_v_f32m8(B + i, vl);\n        vfloat32m8_t vec_c = vle_v_f32m8(C + i, vl);\n        vfloat32m8_t vec_d = vle_v_f32m8(D + i, vl);\n        \n        vbool4_t both_true = vmand_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_true_cond2_false = vmandnot_mm_b4(mask1, mask2, vl);\n        vbool4_t cond1_false_cond2_true = vmandnot_mm_b4(mask2, mask1, vl);\n        vbool4_t both_false = vmnot_m_b4(vmoor_mm_b4(mask1, mask2, vl), vl);\n\n        vfloat32m8_t result = vmerge_vfm_f32m8(vec_b, vec_a, both_true, vl);\n        result = vmerge_vfm_f32m8(vec_c, result, cond1_true_cond2_false, vl);\n        result = vmerge_vfm_f32m8(vec_d, result, cond1_false_cond2_true, vl);\n        \n        vse_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_a = vle32_v_u32m8(A + i, vl);\n        vuint8m8_t vec_out = vpopc_m_u32m8_u8m8(vec_a, vl);\n        vse8_v_u8m8(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_a = vle32_v_u32m8(A + i, vl);\n        vuint8m8_t vec_out = vpopc_m_u32m8_u8m8(vec_a, vl);\n        vse8_v_u8m8(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint8m1_t vcount = vpopc_m_u32m8_u8m1(va, vl);\n        vse8_v_u8m1(out + i, vcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint8m1_t vcount = vpopc_m_u32m8_u8m1(va, vl);\n        vse8_v_u8m1(out + i, vcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_a = vle32_v_u32m8(A + i, vl);\n        vuint8m8_t vec_out = vpopc_m_u32m8_u8m8(vec_a, vl);\n        vse8_v_u8m8(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t a = vle32_v_i32m8(A + i, vl);\n        vint32m8_t result;\n        \n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(a, 3, vl), 0, vl);\n        vint32m8_t abs_a = vabs_v_i32m8(a, vl);\n        result = vmerge_vvm_i32m8(a, abs_a, mask, vl);\n        \n        vse32_v_i32m8(B + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vint32m8_t a = vle32_v_i32m8(A + i, vl);\n        vint32m8_t remainder = vmseq_vx_i32m8(vrem_vx_i32m8(a, 3, vl), 0, vl);\n        vint32m8_t abs_a = vabs_v_i32m8(a, vl);\n        vint32m8_t result = vmerge_vvm_i32m8(a, abs_a, remainder, vl);\n\n        vse32_v_i32m8(B + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t a = vle32_v_i32m8(A + i, vl);\n        vint32m8_t b = vle32_v_i32m8(A + i, vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(a, 3, vl), 0, vl);\n        vint32m8_t abs_a = vabs_v_i32m8_m(mask, b, a, vl);\n        vse32_v_i32m8(B + i, abs_a, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t a = vle32_v_i32m8(A + i, vl);\n        vint32m8_t b = vle32_v_i32m8(A + i, vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(a, 3, vl), 0, vl);\n        vint32m8_t abs_a = vabs_v_i32m8_m(mask, b, a, vl);\n        vse32_v_i32m8(B + i, abs_a, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  size_t vl;\n\n  for (size_t i = 0; i < total_elements; i += vl) {\n    vl = vsetvl_e32m8(total_elements - i);\n    vint32m8_t a = vle32_v_i32m8(A + i, vl);\n    vint32m8_t mod_result = vmseq_vx_i32m8(vrem_vx_i32m8(a, 3, vl), 0, vl);\n    vint32m8_t abs_a = vabs_v_i32m8(a, vl);\n    vint32m8_t result = vmerge_vvm_i32m8(a, abs_a, mod_result, vl);\n    vse32_v_i32m8(B + i, result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    uint32_t rotate_mask = (1 << 4) - 1; // Mask for low 4 bits\n    vuint32m1_t src_vec, dst_vec;\n    vuint32m1_t mask_vec = vundefined_u32m1(); // Initialize mask vector\n\n    for (size_t i = 0; i < length; i += VSET) {\n        vl = vsetvl_e32m1(VSET);\n        src_vec = vle32_v_u32m1(&src[i]); // Load src vector\n\n        // Create a mask for the low 4 bits\n        vuint32m1_t low_bits = vand_vu32m1(src_vec, vundefined_u32m1());\n        vuint32m1_t condition_mask = vmseq_vu32m1(low_bits, vslide1down_u32m1(vundefined_u32m1(), 0));\n\n        // Perform rotation\n        vuint32m1_t rotated = vshf_vv_u32m1(src_vec, vundefined_u32m1(), rotate_bits);\n        dst_vec = vbsl_vu32m1(condition_mask, rotated, vnot_vu32m1(src_vec)); // Conditional selection\n\n        // Store result\n        vse32_v_u32m1(&dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t src_vec, dst_vec;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t negated_src;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        src_vec = vle32_v_u32m1(&src[i], vl);\n        \n        // Check if low 4 bits are all 1\n        mask = vandi_vx_u32m1(src_vec, 0xF);\n        vbool32_t condition = vmseq_vv_u32m1(mask, vmv_v_x_u32m1(0xF, vl));\n\n        // Rotate bits if condition is true, otherwise negate\n        dst_vec = vslid_vx_u32m1(src_vec, rotate_bits, vl);\n        negated_src = vnots_u32m1(src_vec, vl);\n        dst_vec = vmerge_vv_u32m1(dst_vec, negated_src, condition);\n\n        vse32_v_u32m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m1_t vsrc, vdst;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t negation_mask = vundefined_u32m1();\n    \n    // Create a mask for checking the low 4 bits\n    mask = vmv_v_x_u32m1(0xF, 1); // 0xF is 1111 in binary\n    negation_mask = vmv_v_x_u32m1(~0U, 1); // Bitwise negation mask\n\n    for (size_t i = 0; i < length; i += VEC_SIZE) {\n        vl = vsetvl_e32m1(length - i);\n        vsrc = vle32_v_u32m1(&src[i], vl);\n        \n        // Check if the low 4 bits are all 1\n        vuint32m1_t condition = vand_vv_u32m1(vand_vv_u32m1(vsrc, mask), mask);\n        vuint32m1_t result = vundefined_u32m1();\n\n        // Perform rotation if condition is true\n        result = vsrc;\n        result = vshf_vv_u32m1(result, result, vundefined_u32m1(), rotate_bits);\n        \n        // Select between rotated and negated based on condition\n        vdst = vbsl_vv_u32m1(condition, result, vnot_v_u32m1(vsrc));\n        \n        vse32_v_u32m1(&dst[i], vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m1_t src_vec, dst_vec;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t negated_mask = vundefined_u32m1();\n    vuint32m1_t rotated_mask = vundefined_u32m1();\n    \n    // Create masks\n    mask = vmv_v_x_u32m1(0x0F); // Low 4 bits mask\n    negated_mask = vnot_u32m1(mask);\n    \n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        src_vec = vle32_v_u32m1(&src[i], vl);\n        \n        // Check if low 4 bits are all 1\n        vuint32m1_t condition = vand_u32m1(src_vec, mask);\n        vuint32m1_t is_all_one = vmv_v_x_u32m1(0x0F);\n        vbool32_t mask_condition = vmseq_u32m1(condition, is_all_one);\n        \n        // Rotate right by rotate_bits\n        rotated_mask = vlsrdi_u32m1(src_vec, rotate_bits);\n        \n        // Conditional selection\n        dst_vec = vbsl_u32m1(mask_condition, rotated_mask, vnot_u32m1(src_vec));\n        \n        // Store result\n        vse32_v_u32m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m1_t src_vec, dst_vec;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t negated_src;\n\n    // Create a mask for the low 4 bits\n    vuint32m1_t low4_mask = vmv_v_x_u32m1(0xF, 1);\n    \n    for (size_t i = 0; i < length; i += VSET) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        src_vec = vle32_v_u32m1(&src[i]);\n\n        // Check if the low 4 bits are all 1\n        vuint32m1_t condition = vand_vv_u32m1(src_vec, low4_mask);\n        vbool32_t mask_condition = vmseq_vv_u32m1_b32(condition, low4_mask);\n\n        // Perform rotation\n        dst_vec = vsrl_vx_u32m1(src_vec, rotate_bits);\n        dst_vec = vshl_vx_u32m1(dst_vec, 32 - rotate_bits);\n\n        // Negate source vector\n        negated_src = vnot_v_u32m1(src_vec);\n\n        // Select based on condition\n        dst_vec = vbselect_vb_u32m1(mask_condition, dst_vec, negated_src);\n\n        // Store result\n        vse32_v_u32m1(&dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl_actual = vsetvl_e32m1(length - i);\n        \n        va = vle32_v_f32m1(&A[i], vl_actual);\n        vb = vle32_v_f32m1(&B[i], vl_actual);\n        vdiff = vsub_vv_f32m1(va, vb, vl_actual);\n        \n        vfloat32m1_t vepsilon = vfmv_v_f_f32m1(epsilon, vl_actual);\n        vfloat32m1_t vabs_diff = vfredosum_vs_f32m1(vabs_v_f32m1(vdiff, vl_actual), vl_actual);\n        \n        vout = vmv_v_x_i8m1(0, vl_actual);\n        vout = vmerge_vx_i8m1(vout, vmv_v_x_i8m1(1, vl_actual), vgt_vv_f32m1(vdiff, vepsilon, vl_actual));\n        vout = vmerge_vx_i8m1(vout, vmv_v_x_i8m1(-1, vl_actual), vlt_vv_f32m1(vdiff, vneg_v_f32m1(vepsilon, vl_actual), vl_actual));\n        \n        vse32_v_i8m1(&out[i], vout, vl_actual);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vepsilon = vfmv_v_f_f32m1(epsilon, vl);\n    vint8m1_t vout;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        vfloat32m1_t vdiff = vsub_vv_f32m1(va, vb, vl);\n        vfloat32m1_t vabs_diff = vfmv_v_f_f32m1(0.0f, vl);\n        vabs_diff = vfredosum_vs_f32m1(vabs_diff, vabs_v_f32m1(vdiff, vl), vl);\n\n        vout = vmv_v_x_i8m1(0, vl);\n        vout = vmslt_vv_f32m1(vdiff, vfmv_v_f_f32m1(-epsilon, vl), vl);\n        vout = vadd_vv_i8m1(vout, vmv_v_x_i8m1(-1, vl), vl);\n        vout = vmsgt_vv_f32m1(vdiff, vfmv_v_f_f32m1(epsilon, vl), vl);\n        vout = vadd_vv_i8m1(vout, vmv_v_x_i8m1(1, vl), vl);\n\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb;\n    vint32m1_t diff;\n    vfloat32m1_t vepsilon = vfmv_v_f_f32m1(epsilon, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        \n        diff = vsub_vv_f32m1(va, vb, vl);\n        vbool32_t mask1 = vmsgt_vv_f32m1(diff, vepsilon, vl);\n        vbool32_t mask2 = vmslt_vv_f32m1(diff, vneg_v_f32m1(vepsilon, vl), vl);\n        \n        vint8m1_t out_vec = vdup_v_i8m1(0, vl);\n        out_vec = vsel_v_i8m1(mask1, vdup_v_i8m1(1, vl), out_vec, vl);\n        out_vec = vsel_v_i8m1(mask2, vdup_v_i8m1(-1, vl), out_vec, vl);\n        \n        vse8_v_i8m1(&out[i], out_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8_max(length - i);\n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(va, vb, vl);\n        vfloat32m8_t veps = vfmv_s_f_f32m8(epsilon, vl);\n        veps = vfabs_v_f32m8(veps, vl);\n        \n        vbool4_t vgt = vmgt_vf_f32m8(vdiff, veps, vl);\n        vbool4_t vlt = vmlt_vf_f32m8(vdiff, veps, vl);\n        vbool4_t veq = vmleq_vf_f32m8(vfabs_v_f32m8(vdiff, vl), veps, vl);\n\n        vint8m1_t vout = vmv_v_x_i8m1(0, vl);\n        vout = vmerge_vvm_i8m1(vout, vmv_v_x_i8m1(1, vl), vgt, vl);\n        vout = vmerge_vvm_i8m1(vout, vmv_v_x_i8m1(-1, vl), vlt, vl);\n        \n        vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8_max(length - i);\n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(va, vb, vl);\n        vfloat32m8_t veps = vfmv_s_f_f32m8(epsilon, vl);\n        veps = vfabs_v_f32m8(veps, vl);\n        \n        vbool4_t vgt = vmgt_vf_f32m8(vdiff, veps, vl);\n        vbool4_t vlt = vmlt_vf_f32m8(vdiff, veps, vl);\n        vbool4_t veq = vmleq_vf_f32m8(vfabs_v_f32m8(vdiff, vl), veps, vl);\n\n        vint8m1_t vout = vmv_v_x_i8m1(0, vl);\n        vout = vmerge_vvm_i8m1(vout, vmv_v_x_i8m1(1, vl), vgt, vl);\n        vout = vmerge_vvm_i8m1(vout, vmv_v_x_i8m1(-1, vl), vlt, vl);\n        \n        vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vfloat32m8_t v_a = vle32_v_f32m8(A + i, vl);\n    vint32m8_t v_b = vfcvt_x_f_v_i32m8_m(v_a, vbool4_t_new_all(vl), vl, VSEW_32, VTA_TU, VMA_MU);\n    vse32_v_i32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t vf = vle32_v_f32m8(A + i, vl);\n        vint32m8_t vi = vfcvt_rtz_x_f_i32m8(vf, vl);\n        vint32m8_t vmax = vmv_v_x_i32m8(INT32_MAX, vl);\n        vint32m8_t vmin = vmv_v_x_i32m8(INT32_MIN, vl);\n        vbool4_t overflow_pos = vfgt_vf_f32m8_b4(vf, (float)INT32_MAX, vl);\n        vbool4_t overflow_neg = vfge_vf_f32m8_b4((float)INT32_MIN, vf, vl);\n\n        vi = vmerge_vvm_i32m8(vi, vmax, overflow_pos, vl);\n        vi = vmerge_vvm_i32m8(vi, vmin, overflow_neg, vl);\n\n        vse32_v_i32m8(B + i, vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vfloat32m8_t v_a = vle32_v_f32m8(A + i, vl);\n    vint32m8_t v_b = vfcvt_rtz_x_f_i32m8(v_a, vl);\n\n    vint32m8_t v_max = vmv_v_x_i32m8(INT32_MAX, vl);\n    vint32m8_t v_min = vmv_v_x_i32m8(INT32_MIN, vl);\n    \n    vbool4_t v_gt_max = vmgt_vf_f32m8_b4(v_a, (float)INT32_MAX, vl);\n    vbool4_t v_lt_min = vmlt_vf_f32m8_b4(v_a, (float)INT32_MIN, vl);\n\n    v_b = vmerge_v_v_i32m8(v_b, v_max, v_gt_max, vl);\n    v_b = vmerge_v_v_i32m8(v_b, v_min, v_lt_min, vl);\n    \n    vse32_v_i32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vfloat32m8_t v_a = vle32_v_f32m8(A + i, vl);\n    vint32m8_t v_b = vfcvt_x_f_v_i32m8_m(v_a, vbool4_t_new_all(vl), vl, VMF_S);\n    vse32_v_i32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t v_a = vle32_v_f32m8(A + i, vl);\n        vint32m8_t v_b = vfcvt_rtz_x_f_i32m8(v_a, vl);\n\n        vint32m8_t v_max = vmv_s_x_i32m8(INT32_MAX, vl);\n        vint32m8_t v_min = vmv_s_x_i32m8(INT32_MIN, vl);\n        vbool4_t mask_gt = vmflt_vf_f32m8_b4(v_a, INT32_MAX, vl);\n        vbool4_t mask_lt = vmfgt_vf_f32m8_b4(v_a, INT32_MIN, vl);\n\n        v_b = vmerge_vm_i32m8(v_b, v_max, mask_gt, vl);\n        v_b = vmerge_vm_i32m8(v_b, v_min, mask_lt, vl);\n\n        vse32_v_i32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t v_a = vle32_v_i32m8(A + i, vl);\n        vfloat32m8_t v_b = vcvt_f_i_v_f32m8(v_a, vl);\n        vfloat32m8_t v_scale = vfmv_s_f_f32m8(scale, vl);\n        v_b = vfmul_vf_f32m8(v_b, v_scale, vl);\n        vse32_v_f32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t v_a = vle32_v_i32m8(A + i, vl);\n        vfloat32m8_t v_b = vcvt_f_i_v_f32m8(v_a, vl);\n        vfloat32m8_t v_scale = vfmv_s_f_f32m8(scale, vl);\n        v_b = vfmul_vf_f32m8(v_b, v_scale, vl);\n        vse32_v_f32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t v_a = vle32_v_i32m8(A + i, vl);\n        vfloat32m8_t v_b = vcvt_f_i_v_f32m8(v_a, vl);\n        vfloat32m8_t v_scale = vfmv_s_f_f32m8(scale, vl);\n        v_b = vfmul_vf_f32m8(v_b, v_scale, vl);\n        vse32_v_f32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t v_a = vle32_v_i32m8(A + i, vl);\n        vfloat32m8_t v_b = vcvt_f_i_v_f32m8(v_a, vl);\n        vfloat32m8_t v_scale = vfmv_s_f_f32m8(scale, vl);\n        v_b = vfmul_vf_f32m8(v_b, v_scale, vl);\n        vse32_v_f32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t v_a = vle32_v_i32m8(A + i, vl);\n        vfloat32m8_t v_b = vcvt_f_i_v_f32m8(v_a, vl);\n        vfloat32m8_t v_scale = vfmv_s_f_f32m8(scale, vl);\n        v_b = vfmul_vf_f32m8(v_b, v_scale, vl);\n        vse32_v_f32m8(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t a = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t b = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t result = vfdiv_vv_f32m8(a, b, vl);\n        vint32m8_t rounded = vrgather_vx_i32m8(vundefined_i32m8(), result, 0, vl);\n        vse32_v_i32m8(C + i, rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t a = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t b = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t result = vfdiv_vv_f32m8(a, b, vl);\n        vint32m8_t rounded = vrgather_vx_i32m8(vundefined_i32m8(), result, 0, vl);\n        vse32_v_i32m8(C + i, rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t a = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t b = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t result = vfdiv_vv_f32m8(a, b, vl);\n        vint32m8_t rounded = vrgather_vx_i32m8(vundefined_i32m8(), result, 0, vl);\n        vse32_v_i32m8(C + i, rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t a = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t b = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t result = vfdiv_vv_f32m8(a, b, vl);\n        vint32m8_t rounded = vrgather_vx_i32m8(vundefined_i32m8(), result, 0, vl);\n        vse32_v_i32m8(C + i, rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vfloat32m8_t a = vle32_v_f32m8(A + i, vl);\n    vfloat32m8_t b = vle32_v_f32m8(B + i, vl);\n    vfloat32m8_t result = vfdiv_vv_f32m8(a, b, vl);\n    vint32m8_t rounded = vrgather_vx_i32m8(vundefined_i32m8(), result, 0, vl);\n    vse32_v_i32m8(C + i, rounded, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t v_double = vle_v_f64m8(A + i, vl);\n        vfloat32mf2_t v_float = vfcvt_f_f_v_f32mf2_e64m8(v_double, vl);\n\n        vfloat32mf2_t v_max = vfmv_s_f_f32mf2(FLT_MAX, vl);\n        vfloat32mf2_t v_min = vfmv_s_f_f32mf2(-FLT_MAX, vl);\n\n        vbool64_t v_greater = vfgt_vf_b64_m8(v_double, FLT_MAX, vl);\n        vbool64_t v_less = vfge_vf_b64_m8(-FLT_MAX, v_double, vl);\n\n        vfloat32mf2_t v_result = vmerge_v_f32mf2_b64(v_greater, v_max, v_float, vl);\n        v_result = vmerge_v_f32mf2_b64(v_less, v_min, v_result, vl);\n\n        vse_v_f32mf2(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e64m8(size - i);\n    vfloat64m8_t v_double = vle_v_f64m8(A + i, vl);\n    vfloat32mf2_t v_float = vfcvt_f_f_v_f32mf2(v_double, vl);\n    vfloat32mf2_t v_max = vfmv_s_f_f32mf2(FLT_MAX, vl);\n    vfloat32mf2_t v_min = vfmv_s_f_f32mf2(-FLT_MAX, vl);\n    vbool64_t v_greater = vfgt_vf_f64m8_b64(v_double, FLT_MAX, vl);\n    vbool64_t v_less = vflt_vf_f64m8_b64(v_double, -FLT_MAX, vl);\n\n    v_float = vmerge_v_f32mf2(v_float, v_max, v_greater, vl);\n    v_float = vmerge_v_f32mf2(v_float, v_min, v_less, vl);\n\n    vse_v_f32mf2(B + i, v_float, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t v_double = vle_v_f64m8(A + i, vl);\n        vfloat32mf2_t v_float = vfcvt_f_f_v_f32mf2_e64m8(v_double, vl);\n\n        vfloat32mf2_t v_max = vfmv_s_f_f32mf2(FLT_MAX, vl);\n        vfloat32mf2_t v_min = vfmv_s_f_f32mf2(-FLT_MAX, vl);\n\n        vbool64_t v_greater = vfgt_vf_b64_f32mf2(v_float, FLT_MAX, vl);\n        vbool64_t v_less = vfge_vf_b64_f32mf2(-FLT_MAX, v_float, vl);\n\n        v_float = vmerge_v_f32mf2_b64(v_max, v_float, v_greater, vl);\n        v_float = vmerge_v_f32mf2_b64(v_min, v_float, v_less, vl);\n\n        vse_v_f32mf2(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e64m8(size - i);\n    vfloat64m8_t v_double = vle_v_f64m8(A + i, vl);\n    vfloat32mf2_t v_float = vfcvt_f_f_v_f32mf2_f64m8(v_double, vl);\n    vfloat32mf2_t v_max = vfmv_s_f_f32mf2(FLT_MAX, vl);\n    vfloat32mf2_t v_min = vfmv_s_f_f32mf2(-FLT_MAX, vl);\n    vfloat32mf2_t v_res = vfmin_vv_f32mf2(v_float, v_max, vl);\n    v_res = vfmax_vv_f32mf2(v_res, v_min, vl);\n    vse_v_f32mf2(B + i, v_res, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t v_double = vle_v_f64m8(A + i, vl);\n        vfloat32mf2_t v_float = vfcvt_f_f_v_f32mf2_e64m8(v_double, vl);\n\n        vfloat32mf2_t v_max = vfmv_s_f_f32mf2(FLT_MAX, vl);\n        vfloat32mf2_t v_min = vfmv_s_f_f32mf2(-FLT_MAX, vl);\n\n        vbool64_t v_greater = vfgt_vf_b64_f32mf2(v_float, FLT_MAX, vl);\n        vbool64_t v_less = vfge_vf_b64_f32mf2(-FLT_MAX, v_float, vl);\n\n        v_float = vmerge_v_f32mf2_b64(v_max, v_float, v_greater, vl);\n        v_float = vmerge_v_f32mf2_b64(v_min, v_float, v_less, vl);\n\n        vse_v_f32mf2(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e16m2_i16(size - i);\n    vint16m2_t v_a = vle16_v_i16m2(A + i, vl);\n    vint32m4_t v_b = vsext_vf4_i32m4(v_a, vl);\n    vse32_v_i32m4(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e16m2_i16(size - i);\n    vint16m2_t v_a = vle16_v_i16m2(A + i, vl);\n    vint32m4_t v_b = vsext_vf4_i32m4(v_a, vl);\n    vse32_v_i32m4(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i); // Set vector length\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl); // Load int16_t values\n        vint32m1_t v_b = vmv_v_x_i32m1(0); // Initialize int32_t vector\n        v_b = vnsra_w_u16m1(v_a, 0); // Convert to int32_t\n        vse32_v_i32m1(&B[i], v_b, vl); // Store int32_t values\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i);\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl);\n        vint32m1_t v_b = vmv_v_x_i32m1(0);\n        v_b = vnsra_w_u16m1(v_a, 0);\n        vse32_v_i32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i); // Set vector length\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl); // Load 16-bit integers\n        vint32m1_t v_b = vmv_v_x_i32m1(0); // Initialize destination vector\n        v_b = vwadd_vv_i32m1(v_b, vmv_v_x_i32m1(0), v_a); // Convert to 32-bit integers\n        vse32_v_i32m1(&B[i], v_b, vl); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float v_min_val = min_val;\n    float v_max_val = max_val;\n    vfloat32m1_t v_min = vle32_v_f32m1(&v_min_val, 1);\n    vfloat32m1_t v_max = vle32_v_f32m1(&v_max_val, 1);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_control = vle32_v_i32m1(control + i, vl);\n        vfloat32m1_t v_A = vle32_v_f32m1(A + i, vl);\n        \n        vfloat32m1_t v_result = vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t v_one = vfmv_v_f_f32m1(1.0f, vl);\n        \n        // Check control values\n        vbool32_t mask = vmslt_v_i32m1(v_control, 0);\n        vfloat32m1_t v_normalized = vfmul_vf_f32m1(vfsub_vv_f32m1(v_A, v_min, vl), 1.0f / (v_max - v_min), vl);\n        \n        // Apply normalization and clamping\n        v_normalized = vfmin_v_f32m1(v_normalized, v_one, vl);\n        v_normalized = vfmax_v_f32m1(v_normalized, vfmv_v_f_f32m1(0.0f, vl), vl);\n        \n        // Select between normalized and original values based on control\n        v_result = vmerge_vvm(mask, v_A, v_normalized, vl);\n        \n        vse32_v_f32m1(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va;\n    vint32m1_t vcontrol;\n    vfloat32m1_t vresult;\n\n    float range = max_val - min_val;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        vfloat32m1_t vmin_val = vfmv_v_f_f32m1(min_val, vl);\n        vfloat32m1_t vmax_val = vfmv_v_f_f32m1(max_val, vl);\n        \n        vfloat32m1_t vnormalized = vdiv_vv_f32m1(vsub_vv_f32m1(va, vmin_val), vsub_vv_f32m1(vmax_val, vmin_val), vl);\n        vnormalized = vfmin_v_f32m1(vnormalized, vfmv_v_f_f32m1(1.0f, vl), vl);\n        vnormalized = vfmax_v_f32m1(vnormalized, vfmv_v_f_f32m1(0.0f, vl), vl);\n\n        vse32_v_f32m1(&B[i], vmerge_vv_f32m1(vnormalized, va, vmslt_vv_i32m1(vcontrol, vfmv_v_f_i32m1(1, vl), vl), vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va;\n    vint32m1_t vcontrol;\n    vfloat32m1_t vresult;\n    vfloat32m1_t vmin_val = vfmv_v_f_f32m1(min_val, 1);\n    vfloat32m1_t vmax_val = vfmv_v_f_f32m1(max_val, 1);\n    vfloat32m1_t vrange = vfmul_vf_f32m1(vmax_val, 1.0f) - vfmul_vf_f32m1(vmin_val, 1.0f);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n        \n        vresult = vfmul_vf_f32m1(vfsub_vv_f32m1(va, vmin_val, vl), 1.0f / vfmv_f_f32(vrange));\n        \n        vresult = vfmax_vf_f32m1(vresult, 0.0f, vl);\n        vresult = vfmin_vf_f32m1(vresult, 1.0f, vl);\n        \n        vfloat32m1_t vcopy = va;\n        vresult = vmerge_vv_f32m1(vresult, vcopy, vmslt_vx_i32m1(vcontrol, 1, vl), vl);\n        \n        vse32_v_f32m1(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va;\n    vint32m1_t vcontrol;\n    vfloat32m1_t vresult;\n    vfloat32m1_t vmin_val = vfmv_v_f_f32m1(min_val, 1);\n    vfloat32m1_t vmax_val = vfmv_v_f_f32m1(max_val, 1);\n    vfloat32m1_t vrange = vfmul_vf_f32m1(vsub_vv_f32m1(vmax_val, vmin_val), 1.0f / (max_val - min_val), 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        vresult = vfmax_vf_f32m1(vfmin_vv_f32m1(vfmul_vv_f32m1(vsub_vv_f32m1(va, vmin_val), vrange), 1.0f, 1), 0.0f, 1);\n\n        vse32_v_f32m1(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t a_vec, normalized, min_val_vec = vfmv_v_f_f32m1(min_val, 1), max_val_vec = vfmv_v_f_f32m1(max_val, 1);\n    vint32m1_t control_vec;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        a_vec = vle32_v_f32m1(&A[i], vl);\n        control_vec = vle32_v_i32m1(&control[i], vl);\n\n        vbool32_t mask = vmslt_v_i32m1(control_vec, 0);\n        vfloat32m1_t result = vfmv_v_f_f32m1(0.0f, vl);\n\n        vfloat32m1_t normalized_temp = vfmul_vv_f32m1(vfsub_vv_f32m1(a_vec, min_val_vec, vl), \n                                                       vfmv_v_f_f32m1(1.0f / (max_val - min_val), vl), vl);\n        normalized_temp = vfmin_vv_f32m1(normalized_temp, vfmv_v_f_f32m1(1.0f, vl), vl);\n        normalized_temp = vfmax_vv_f32m1(normalized_temp, vfmv_v_f_f32m1(0.0f, vl), vl);\n\n        result = vmerge_vvm(mask, a_vec, normalized_temp, vl);\n        vse32_v_f32m1(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i]);\n        vint32m1_t high_bits = vsrl_vx_u32m1(va, 16);\n        vfloat32m1_t vb = vcvt_f_f32_u32m1(high_bits);\n        vb = vsqrt_v_f32m1(vb);\n        vse32_v_f32m1(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i]);\n        vuint32m1_t high_bits = vsrl_vx_u32m1(va, 16);\n        vfloat32m1_t vb = vcvt_f_f32_u32m1(high_bits);\n        vb = vsqrt_v_f32m1(vb);\n        vse32_v_f32m1(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n        vuint16m4_t v_a_high = vshrdi_vx_u16m4(vreinterpret_v_u32m8_u16m4(v_a), 16, vl);\n        vfloat32m8_t v_float_a = vfcvt_f_u_v_f32m8(v_a_high, vl);\n        vfloat32m8_t v_sqrt_a = vfsqrt_v_f32m8(v_float_a, vl);\n        vse32_v_f32m8(B + i, v_sqrt_a, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n        vuint16m4_t v_a_high = vshr_n_u32m8_u16m4(v_a, 16, vl);\n        vfloat32m8_t v_f = vfcvt_f_u_v_f32m8(v_a_high, vl);\n        vfloat32m8_t v_sqrt = vfsqrt_v_f32m8(v_f, vl);\n        vse32_v_f32m8(B + i, v_sqrt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vuint16m4_t v_a_high = vshr_n_u16m4(vreinterpret_v_u16m4_u32m8(v_a), 0x10, vl);\n    vfloat32m8_t v_float_a = vfcvt_f_u_v_f32m8(v_a_high, vl);\n    vfloat32m8_t v_sqrt_a = vfsqrt_v_f32m8(v_float_a, vl);\n    vse32_v_f32m8(B + i, v_sqrt_a, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vfloat32m8_t v_b = vreinterpret_v_f32m8_u32m8(v_a);\n    vse32_v_f32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vfloat32m8_t v_b = vreinterpret_v_f32m8_u32m8(v_a);\n    vse32_v_f32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vfloat32m8_t v_b = vreinterpret_v_f32m8_u32m8(v_a);\n    vse32_v_f32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vfloat32m8_t v_b = vreinterpret_v_f32m8_u32m8(v_a);\n    vse32_v_f32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n  size_t vl;\n  for (size_t i = 0; i < size; i += vl) {\n    vl = vsetvl_e32m8(size - i);\n    vuint32m8_t v_a = vle32_v_u32m8(A + i, vl);\n    vfloat32m8_t v_b = vreinterpret_v_f32m8_u32m8(v_a);\n    vse32_v_f32m8(B + i, v_b, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    ptrdiff_t bstride = sizeof(bool);\n    ptrdiff_t istride = sizeof(int32_t);\n    ptrdiff_t fstride = sizeof(float);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m4(size - i);\n\n        vbool8_t v_cond = vle1_v_b8m1(cond + i, vl);\n\n        vint32m4_t v_current = vle32_v_i32m4(A + i, vl);\n        vint32m4_t v_previous = vle32_v_i32m4(A + i - 1, vl);\n\n        vint32m4_t v_diff = vsub_vv_i32m4_m(v_cond, v_current, v_previous, vl);\n\n        vfloat32m4_t v_float_diff = vcvt_f_x_v_f32m4_m(v_cond, v_diff, vl);\n\n        vse32_v_f32m4(diff + i, v_float_diff, vl);\n\n        // Handle elements where cond[i] is false by setting diff[i] to 0.0f\n        for (size_t j = 0; j < vl; ++j) {\n            if (!cond[i + j]) {\n                diff[i + j] = 0.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    ptrdiff_t bstride = sizeof(bool);\n    ptrdiff_t istride = sizeof(int32_t);\n    ptrdiff_t fstride = sizeof(float);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m4(size - i);\n\n        vbool8_t v_cond = vle1_v_b8m1(cond + i, vl);\n\n        vint32m4_t v_current = vle32_v_i32m4(A + i, vl);\n        vint32m4_t v_previous = vle32_v_i32m4(A + i - 1, vl);\n\n        vint32m4_t v_diff = vsub_vv_i32m4_m(v_cond, v_current, v_previous, vl);\n\n        vfloat32m4_t v_float_diff = vcvt_f_x_v_f32m4_m(v_cond, v_diff, vl);\n\n        vse32_v_f32m4(diff + i, v_float_diff, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    ptrdiff_t bstride = sizeof(bool);\n    ptrdiff_t istride = sizeof(int32_t);\n    ptrdiff_t fstride = sizeof(float);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m4(size - i);\n\n        vbool8_t v_cond = vle1_v_b8m1(cond + i, vl);\n\n        vint32m4_t v_current = vle32_v_i32m4(A + i, vl);\n        vint32m4_t v_previous = vle32_v_i32m4(A + i - 1, vl);\n\n        vint32m4_t v_diff = vsub_vv_i32m4_m(v_cond, v_current, v_previous, vl);\n\n        vfloat32m4_t v_float_diff = vcvt_f_x_v_f32m4_m(v_cond, v_diff, vl);\n\n        vse32_v_f32m4(diff + i, v_float_diff, vl);\n\n        // Handle elements where cond[i] is false by setting diff[i] to 0.0f\n        for (size_t j = 0; j < vl; ++j) {\n            if (!cond[i + j]) {\n                diff[i + j] = 0.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    ptrdiff_t bstride = sizeof(bool);\n    ptrdiff_t istride = sizeof(int32_t);\n    ptrdiff_t fstride = sizeof(float);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        vbool1_t mask = vle1_v_b1m1(cond + i, vl);\n        \n        vint32m1_t current = vle32_v_i32m1(A + i, vl);\n        vint32m1_t previous = vle32_v_i32m1(A + i - 1, vl);\n\n        vint32m1_t diff_int = vsub_vv_i32m1_m(mask, current, previous, current, vl);\n        vfloat32m1_t diff_float = vfcvt_f_i_v_f32m1_m(mask, diff_int, 0.0f, vl);\n\n        vse32_v_f32m1(diff + i, diff_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    ptrdiff_t bstride = sizeof(bool);\n    ptrdiff_t istride = sizeof(int32_t);\n    ptrdiff_t fstride = sizeof(float);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m4(size - i);\n\n        vbool8_t v_cond = vle1_v_b8m1(cond + i, vl);\n\n        vint32m4_t v_current = vle32_v_i32m4(A + i, vl);\n        vint32m4_t v_previous = vle32_v_i32m4(A + i - 1, vl);\n\n        vint32m4_t v_diff = vsub_vv_i32m4_m(v_cond, v_current, v_previous, vl);\n\n        vfloat32m4_t v_float_diff = vcvt_f_x_v_f32m4_m(v_cond, v_diff, vl);\n\n        vse32_v_f32m4(diff + i, v_float_diff, vl);\n\n        // Handle elements where cond[i] is false by setting diff[i] to 0.0f\n        for (size_t j = 0; j < vl; ++j) {\n            if (!cond[i + j]) {\n                diff[i + j] = 0.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint64m8_t wide_v = vwcvt_xu_x_v_u64m8(v, vl);\n    vuint64m8_t mask = vmv_s_x_u64m8(0xFFFFFFFF00000000, vl);\n    wide_v = vor_vx_u64m8(wide_v, 0xFFFFFFFF00000000, vl);\n    vse64_v_u64m8(dst + i, wide_v, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint64m8_t wide = zvzext_vf4_u64m8_u32m8(v, vl);\n    vuint64m8_t mask = vmv_v_x_u64m8(0xFFFFFFFF00000000, vl);\n    vuint64m8_t result = vor_vv_u64m8(wide, mask, vl);\n    vse64_v_u64m8(dst + i, result, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v_u32 = vle32_v_u32m8(src + i, vl);\n    vuint64m8_t v_u64 = vwcvtu_u_x_v_u64m8(v_u32, vl);\n    vuint64m8_t v_high = vmv_v_x_u64m8(0xFFFFFFFF00000000, vl);\n    v_u64 = vor_vv_u64m8(v_u64, v_high, vl);\n    vse64_v_u64m8(dst + i, v_u64, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint64m8_t wide_v = zext_vf4_u32m8_u64m8(v, vl);\n    vuint64m8_t mask = vmv_s_x_u64m8(0xFFFFFFFF00000000, vl);\n    wide_v = vor_vv_u64m8(wide_v, mask, vl);\n    vse64_v_u64m8(dst + i, wide_v, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e32m8(length - i);\n    vuint32m8_t v = vle32_v_u32m8(src + i, vl);\n    vuint64m8_t wide_v = zext_v_u64m8_u32m8(v, vl);\n    vuint64m8_t mask = vmv_v_x_u64m8(0xFFFFFFFF00000000, vl);\n    vuint64m8_t or_v = vor_vv_u64m8(wide_v, mask, vl);\n    vse64_v_u64m8(dst + i, or_v, vl);\n  }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl;\n  vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, vl);\n\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e16m2(length - i);\n    vint16m2_t v_index = vle16_v_i16m2(index + i, vl);\n    vbool8_t mask = vmseq_vx_i16m2_b8(v_index, -1, vl); \n    v_index = vmseq_vx_i16m2_i16m2(v_index, -1, v_index, vl);\n\n    vuint16m2_t v_index_u = vreinterpret_v_u16m2_i16m2(v_index);\n    vfloat64m8_t v_values = vluxseg1ei16_v_f64m8(vec, v_index_u, vl);\n    v_sum = vfmacc_vf_f64m8(v_sum, 1.0, v_values, vl);\n  }\n\n  double result[8];\n  vse64_v_f64m8(result, v_sum, 8);\n  for(int i = 0; i < 8; i++){\n      sum += result[i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vsetvl_e16m2(length - i);\n    vint16m2_t v_index = vle16_v_i16m2(index + i, vl);\n    vfloat64m8_t v_val = vfmv_v_f_f64m8(0.0, vl);\n    for (size_t j = 0; j < vl; j++) {\n      int16_t idx = vget_i16m2(v_index, j);\n      if (idx >= 0 && idx < length) {\n        v_val = vfadd_vf_f64m8(v_val, vec[idx], vl);\n      }\n    }\n    double temp_sum[4];\n    vse64_v_f64m8(temp_sum, v_val, vl);\n    for (size_t k = 0; k < vl; k++) {\n      sum += temp_sum[k];\n    }\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vmin_vl_z(length - i, vsetvlmax_e16m8());\n    vint16m8_t v_index = vle16_v_i16m8(index + i, vl);\n    vfloat64m8_t v_selected = vgather_vv_f64m8(vec, v_index, vl);\n    vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64m1(v_selected, vinit_f64m1(0.0), vl);\n    sum += vfmv_f_s_f64m1_f64(v_sum);\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl;\n  for (size_t i = 0; i < length; i += vl) {\n    vl = vmin_vl_z(length - i, vsetvlmax_e16m8());\n    vint16m8_t v_index = vle16_v_i16m8(index + i, vl);\n    vfloat64m8_t v_indexed_values = vfmv_v_f_f64m8(0.0, vl); \n\n    for (size_t j = 0; j < vl; ++j) {\n        int16_t idx = vget_v_i16m8(v_index, j);\n        if (idx >= 0 && (size_t)idx < length) {\n            v_indexed_values = vfadd_vf_f64m8(v_indexed_values, vec[idx], v_indexed_values, 1);\n        }\n    }\n    \n    double temp_sum[8];\n    vse64_v_f64m8(temp_sum, v_indexed_values, vl);\n    for(size_t k = 0; k < vl; k++){\n        sum += temp_sum[k];\n    }\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += VEC_NUM) {\n        vl = vsetvl_e64m1(length - i);\n        vint16m1_t idx = vle16_v_i16m1(&index[i], vl);\n        vfloat64m1_t vec_elements = vle64_v_f64m1(&vec[idx], vl);\n        sum_vec = vfredusum_vs_f64m1_f64m1(sum_vec, vec_elements, sum_vec, vl);\n    }\n\n    double result = vfmv_f_s_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_row * input_size + input_col]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[ki * kernel_size + kj]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, output_size * output_size);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[(i + ki) * input_size + (j + kj)]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[ki * kernel_size + kj]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[(i + ki) * input_size + (j + kj)], 1);\n                    vfloat64m1_t kernel_vec = vfmv_v_f_f64m1(kernel[ki * kernel_size + kj], 1);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[(i + ki) * input_size + (j + kj)]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[ki * kernel_size + kj]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64m1(sum);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = fmax(0.0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl;\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec_i = vfmv_s_f_f64m8(numbers[i], vl);\n            vfloat64m8_t vec_j = vld_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec_i, vec_j, vl);\n            vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n            vbool8_t close = vmflt_vf_f64m8(abs_diff, threshold, vl);\n\n            if (vfirst_m_b8(close, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl;\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec_i = vfmv_s_f_f64m8(numbers[i], vl);\n            vfloat64m8_t vec_j = vld_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec_i, vec_j, vl);\n            vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n            vbool8_t close = vmflt_vf_f64m8(abs_diff, threshold, vl);\n\n            if (vfirst_m_b8(close, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl;\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t v_num1 = vfmv_s_f_f64m8(numbers[i], vl);\n            vfloat64m8_t v_num2 = vle64_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t v_diff = vfsub_vv_f64m8(v_num1, v_num2, vl);\n            vfloat64m8_t v_abs_diff = vfabs_v_f64m8(v_diff, vl);\n            vbool8_t v_cmp = vmflt_vf_f64m8(v_abs_diff, threshold, vl);\n\n            if (vfirst_m_b8(v_cmp, vl)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl;\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec_i = vfmv_s_f_f64m8(numbers[i], vl);\n            vfloat64m8_t vec_j = vld_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec_i, vec_j, vl);\n            vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n            vbool8_t close = vmflt_vf_f64m8(abs_diff, threshold, vl);\n\n            if (vfirst_m_b8(close, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl;\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec_i = vfmv_s_f_f64m8(numbers[i], vl);\n            vfloat64m8_t vec_j = vld_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec_i, vec_j, vl);\n            vfloat64m8_t abs_diff = vfabs_v_f64m8(diff, vl);\n            vbool8_t close = vmflt_vf_f64m8(abs_diff, threshold, vl);\n\n            if (vfirst_m_b8(close, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n  size_t n = operations.size();\n  size_t vl;\n  int64_t balance = 0;\n\n  for (size_t i = 0; i < n; i += vl) {\n    vl = vsetvl_e32m1(n - i);\n    vint32m1_t v_ops = vle32_v_i32m1(&operations[i], vl);\n    \n    for (size_t j = 0; j < vl; ++j) {\n      balance += v_ops[j];\n      if (balance < 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    size_t vl;\n    int64_t balance = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t op_vec = vle32_v_i32m1(&operations[i], vl);\n        \n        int32_t op_arr[vl];\n        vse32_v_i32m1(op_arr, op_vec, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            balance += op_arr[j];\n            if (balance < 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    size_t vl;\n    int64_t balance = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_op = vle32_v_i32m1(&operations[i], vl);\n        \n        int32_t op_arr[vl];\n        vse32_v_i32m1(op_arr, v_op, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            balance += op_arr[j];\n            if(balance < 0){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    size_t vl;\n    int64_t balance = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_ops = vle32_v_i32m1(&operations[i], vl);\n        \n        int32_t ops_arr[vl];\n        vse32_v_i32m1(ops_arr, v_ops, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            balance += ops_arr[j];\n            if(balance < 0){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    size_t vl;\n    int64_t balance = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_op = vle32_v_i32m1(&operations[i], vl);\n        \n        int32_t op_array[vl];\n        vse32_v_i32m1(op_array, v_op, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            balance += op_array[j];\n            if (balance < 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <numeric>\n#include <cmath>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t vl;\n    const double *data = numbers.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vx = vle64_v_f64m8(data + i, vl);\n        vfloat64m8_t vmean = vfmv_s_f_f64m8(mean, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs_diff = vfabs_v_f64m8(vdiff, vl);\n        double temp_sum[8];\n        vse64_v_f64m8(temp_sum, vabs_diff, vl);\n\n        for(int j = 0; j < vl; ++j){\n            mad += temp_sum[j];\n        }\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <numeric>\n#include <cmath>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t vl;\n    const double *data = numbers.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8_tu(n - i, __RISCV_VXRM_RNU, __RISCV_VLEN);\n        vfloat64m8_t vx = vle_v_f64m8(data + i, vl);\n        vfloat64m8_t vmean = vfmv_v_s_f64m8(mean, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs = vfabs_v_f64m8(vdiff, vl);\n        double temp_sum[8];\n        vse_v_f64m8(temp_sum, vabs, vl);\n        for(size_t j = 0; j < vl; ++j){\n            mad += temp_sum[j];\n        }\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <numeric>\n#include <cmath>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t vl;\n    const double *data = numbers.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vx = vle64_v_f64m8(data + i, vl);\n        vfloat64m8_t vmean = vfmv_s_f_f64m8(mean, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs_diff = vfabs_v_f64m8(vdiff, vl);\n        double temp_sum[8];\n        vse64_v_f64m8(temp_sum, vabs_diff, vl);\n\n        for(int j = 0; j < vl; ++j){\n            mad += temp_sum[j];\n        }\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <numeric>\n#include <cmath>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t vl;\n    const double *data = numbers.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8_max_len();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        vfloat64m8_t vx = vle_v_f64m8(data + i, vl);\n        vfloat64m8_t vmean = vfmv_s_f_f64m8(mean, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs_diff = vfabs_v_f64m8(vdiff, vl);\n\n        double temp_sum[8];\n        vse_v_f64m8(temp_sum, vabs_diff, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            mad += temp_sum[j];\n        }\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <numeric>\n#include <cmath>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t vl;\n    const double *data = numbers.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vx = vle64_v_f64m8(data + i, vl);\n        vfloat64m8_t vmean = vfmv_s_f_f64m8(mean, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs = vfabs_v_f64m8(vdiff, vl);\n        double temp_sum[8];\n        vse64_v_f64m8(temp_sum, vabs, vl);\n        for(size_t j = 0; j < vl; ++j){\n            mad += temp_sum[j];\n        }\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.reserve(2 * n - 1);\n\n    for (size_t i = 0; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (size_t i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (size_t i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.reserve(2 * n - 1);\n\n    for (size_t i = 0; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = 2 * input_size - 1;\n    result.resize(output_size);\n\n    size_t vl = vsetvl_e32m1(input_size);\n    \n    for (size_t i = 0; i < input_size; ++i) {\n        result[2 * i] = numbers[i];\n        if (2 * i + 1 < output_size) {\n            result[2 * i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vl;\n    size_t num_elements = numbers.size();\n\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e16m2(num_elements - i);\n        vint16m2_t v = vle16_v_i16m2(&numbers[i], vl);\n\n        vint64m1_t v_sum = vmv_v_x_i64m1(0, vl);\n        v_sum = vredsum_vs_i16m2_i64m1(v_sum, v, v_sum, vl);\n        sum += vget_i64(v_sum, 0);\n\n        vint64m1_t v_prod = vmv_v_x_i64m1(1, vl);\n        v_prod = vredmul_vs_i16m2_i64m1(v_prod, v, v_prod, vl);\n        product *= vget_i64(v_prod, 0);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vl = numbers.size();\n    if (vl == 0) {\n        return {0, 1};\n    }\n\n    size_t num_vectors = vl / vsetvlmax_e16m1();\n    size_t remainder = vl % vsetvlmax_e16m1();\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t current_vl = vsetvlmax_e16m1();\n        vint16m1_t v = vle16_v_i16m1(&numbers[i * current_vl], current_vl);\n\n        int64_t temp_sum = 0;\n        int64_t temp_product = 1;\n\n        vint64m1_t v_int64 = vsext_vf2_i64m1(v, current_vl);\n        temp_sum = vmv_x_s_i64m1(vreduce_add_vs_i64m1_i64m1(temp_sum, v_int64, vinit_i64m1(0, current_vl), current_vl));\n        temp_product = vmv_x_s_i64m1(vreduce_mul_vs_i64m1_i64m1(temp_product, v_int64, vinit_i64m1(1, current_vl), current_vl));\n\n        sum += temp_sum;\n        product *= temp_product;\n    }\n\n    if (remainder > 0) {\n        size_t current_vl = vsetvl_e16m1(remainder);\n        vint16m1_t v = vle16_v_i16m1(&numbers[num_vectors * vsetvlmax_e16m1()], current_vl);\n\n        int64_t temp_sum = 0;\n        int64_t temp_product = 1;\n\n        vint64m1_t v_int64 = vsext_vf2_i64m1(v, current_vl);\n        temp_sum = vmv_x_s_i64m1(vreduce_add_vs_i64m1_i64m1(temp_sum, v_int64, vinit_i64m1(0, current_vl), current_vl));\n        temp_product = vmv_x_s_i64m1(vreduce_mul_vs_i64m1_i64m1(temp_product, v_int64, vinit_i64m1(1, current_vl), current_vl));\n\n        sum += temp_sum;\n        product *= temp_product;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vl = 0;\n    size_t num_elements = numbers.size();\n\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e16m2(num_elements - i);\n        vint16m2_t v = vle16_v_i16m2(&numbers[i], vl);\n\n        vint64m1_t v_sum = vmv_v_x_i64m1(0, vl);\n        vint64m1_t v_product = vmv_v_x_i64m1(1, vl);\n\n        v_sum = vredsum_vs_i16m2_i64m1(v_sum, v, v_sum, vl);\n        v_product = vredmul_vs_i16m2_i64m1(v_product, v, v_product, vl);\n\n        sum += vget_i64m1(v_sum, 0);\n        product *= vget_i64m1(v_product, 0);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vl;\n    size_t num_elements = numbers.size();\n\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e16m2(num_elements - i);\n        vint16m2_t v = vle16_v_i16m2(&numbers[i], vl);\n\n        vint64m1_t v_sum = vmv_v_x_i64m1(0, vl);\n        vint64m1_t v_product = vmv_v_x_i64m1(1, vl);\n\n        v_sum = vwredsum_vs_i16m2_i64m1(v_sum, v, v_sum, vl);\n        v_product = vwredprod_vs_i16m2_i64m1(v_product, v, v_product, vl);\n\n        sum += vget_i64m1(v_sum, 0);\n        product *= vget_i64m1(v_product, 0);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vl;\n    size_t num_elements = numbers.size();\n\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e16m2(num_elements - i);\n        vint16m2_t v = vle16_v_i16m2(&numbers[i], vl);\n\n        vint64m1_t v_sum = vmv_v_x_i64m1(0, vl);\n        vint64m1_t v_product = vmv_v_x_i64m1(1, vl);\n\n        v_sum = vwredsum_vs_i16m2_i64m1(v_sum, v, v_sum, vl);\n        v_product = vwredprod_vs_i16m2_i64m1(v_product, v, v_product, vl);\n\n        sum += vget_i64m1_i64(v_sum, 0);\n        product *= vget_i64m1_i64(v_product, 0);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    size_t vl = vsetvl_e8m1(len);\n    size_t i = 0;\n\n    for (; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t va = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vb = vmv_v_x_u8m1(0, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            if(i + j < len_a){\n                va = vse_v_u8m1(va, a[i+j] - '0', vl);\n            }\n            if(i + j < len_b){\n                vb = vse_v_u8m1(vb, b[i+j] - '0', vl);\n            }\n        }\n\n        vuint8m1_t vxor_result = vxor_vv_u8m1(va, vb, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            result[i+j] = vget_v_u8m1(vxor_result, j) + '0';\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n    std::string result(len, '0');\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < std::min(len_a, len_b); i += vl) {\n        vl = vsetvl_e8m1(std::min(len_a - i, len_b - i));\n\n        vuint8m1_t va = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vb = vmv_v_x_u8m1(0, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            va[j] = a[i + j] - '0';\n            vb[j] = b[i + j] - '0';\n        }\n\n        vuint8m1_t vxor_res = veor_vv_u8m1(va, vb, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            result[i + j] = (vxor_res[j] == 1) ? '1' : '0';\n        }\n    }\n\n    if (len_a > len_b) {\n        for (; i < len_a; ++i) {\n            result[i] = a[i];\n        }\n    } else if (len_b > len_a) {\n        for (; i < len_b; ++i) {\n            result[i] = b[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < std::min(len_a, len_b); i += vl) {\n        vl = vsetvl_e8m1(std::min(len_a - i, len_b - i));\n\n        vuint8m1_t va = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vb = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vr = vmv_v_x_u8m1(0, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            va[j] = a[i+j] - '0';\n            vb[j] = b[i+j] - '0';\n        }\n\n        vr = vxor_vv_u8m1(va, vb, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            result[i+j] = (vr[j] == 1) ? '1' : '0';\n        }\n    }\n\n    if (len_a > len_b) {\n        for (size_t j = len_b; j < len_a; ++j) {\n            result[j] = a[j];\n        }\n    } else if (len_b > len_a) {\n        for (size_t j = len_a; j < len_b; ++j) {\n            result[j] = b[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n    std::string result(len, '0');\n\n    size_t vl = vsetvl_e8m1(len);\n    size_t i = 0;\n\n    for (; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t va = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vb = vmv_v_x_u8m1(0, vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            if (i + j < len_a){\n                va = vse_v_u8m1((unsigned char*)(a.data() + i), va, vl);\n                break;\n            }\n        }\n\n        for(size_t j = 0; j < vl; ++j){\n            if (i + j < len_b){\n                vb = vse_v_u8m1((unsigned char*)(b.data() + i), vb, vl);\n                break;\n            }\n        }\n        \n        vuint8m1_t res_vec = veor_vv_u8m1(va, vb, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            unsigned char val_a = (i + j < len_a) ? a[i + j] - '0' : 0;\n            unsigned char val_b = (i + j < len_b) ? b[i + j] - '0' : 0;\n            result[i + j] = ((val_a ^ val_b) + '0');\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < len - len % vlenmax_v_u8m8(); i += vlenmax_v_u8m8()) {\n        vl = vlenmax_v_u8m8();\n\n        vuint8m8_t va = vmv_v_x_u8m8(0, vl);\n        vuint8m8_t vb = vmv_v_x_u8m8(0, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < len_a) {\n                va = vinsert_v_x_u8m8(va, a[i + j] - '0', j);\n            }\n            if (i + j < len_b) {\n                vb = vinsert_v_x_u8m8(vb, b[i + j] - '0', j);\n            }\n        }\n\n        vuint8m8_t vxor = veor_vv_u8m8(va, vb, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            result[i + j] = vextract_x_u8m8(vxor, j) + '0';\n        }\n    }\n\n    for (; i < len; ++i) {\n        int bit_a = (i < len_a) ? (a[i] - '0') : 0;\n        int bit_b = (i < len_b) ? (b[i] - '0') : 0;\n        result[i] = ((bit_a ^ bit_b) + '0');\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = strings[0].length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = strings[i].length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = strings[0].length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = strings[i].length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = strings[0].length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_len) {\n            longest_string = strings[i];\n            max_len = strings[i].length();\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_len) {\n            longest_string = strings[i];\n            max_len = strings[i].length();\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_len) {\n            longest_string = strings[i];\n            max_len = strings[i].length();\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n  while (b != 0) {\n    uint64_t temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n  while (b != 0) {\n    uint64_t temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n  while (b != 0) {\n    uint64_t temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n  while (b != 0) {\n    uint64_t temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n  while (b != 0) {\n    uint64_t temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    size_t vl = vsetvlmax_e32m1();\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    size_t vl = vsetvlmax_e32m1();\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        size_t j_start = i + 1;\n        for (size_t j = j_start; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n    \n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    size_t vl = vsetvlmax_e32m1();\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    size_t vl = vsetvlmax_e32m1();\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t vl = numbers.size();\n    std::vector<float> result(vl);\n\n    for (size_t i = 0; i < vl; i += vflen_vf32()) {\n        size_t current_vl = std::min(vflen_vf32(), vl - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], current_vl);\n        vfloat32m8_t v_min = vfmv_s_f_f32m8(v_min, min_val, current_vl);\n        vfloat32m8_t v_sub = vfsub_vv_f32m8(v, v_min, current_vl);\n        vfloat32m8_t v_range = vfmv_s_f_f32m8(v_range, range, current_vl);\n        vfloat32m8_t v_res = vfdiv_vf_f32m8(v_sub, range, current_vl);\n        vse32_v_f32m8(&result[i], v_res, current_vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t vl = numbers.size();\n    std::vector<float> result(vl);\n\n    for (size_t i = 0; i < vl; i += vflen_vf32()) {\n        size_t current_vl = std::min(vflen_vf32(), vl - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], current_vl);\n        vfloat32m8_t v_min = vfmv_s_f_f32m8(v_min, min_val, current_vl);\n        vfloat32m8_t v_sub = vfsub_vv_f32m8(v, v_min, current_vl);\n        vfloat32m8_t v_range = vfmv_s_f_f32m8(v_range, range, current_vl);\n        vfloat32m8_t v_res = vfdiv_vf_f32m8(v_sub, range, current_vl);\n        vse32_v_f32m8(&result[i], v_res, current_vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t vl = vsetvl_e32m8(numbers.size());\n    std::vector<float> result(numbers.size());\n\n    for (size_t i = 0; i < numbers.size(); i += vl) {\n        vl = vsetvl_e32m8(numbers.size() - i);\n        vfloat32m8_t v_numbers = vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_min = vfmv_s_f_f32m8(min_val, vl);\n        vfloat32m8_t v_range = vfmv_s_f_f32m8(range, vl);\n        vfloat32m8_t v_subtracted = vfsub_vf_f32m8(v_numbers, min_val, vl);\n        vfloat32m8_t v_rescaled = vfdiv_vf_f32m8(v_subtracted, range, vl);\n        vse32_v_f32m8(&result[i], v_rescaled, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t vl = numbers.size();\n    std::vector<float> result(vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t vl = numbers.size();\n    std::vector<float> result(vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  size_t vl = vsetvl_e64m8(8);\n  vuint64m8_t vn = vmv_s_x_u64m8(n, vl);\n  vuint64m8_t vi = vid_v_u64m8(vl);\n  vbool8_t mask = vmseq_vx_u64m8_b8(vi, vn, vl);\n  vi = vadd_vx_u64m8(vi, 1, vl);\n  mask = vmorn_mm_b8(mask, vmleq_vx_u64m8_b8(vi, vn, vl), vl);\n  vuint64m8_t vresult = vdiv_vx_u64m8(vn, vi, vl);\n  vbool8_t is_integer = vfmv_v_f_b8(mask, vl);\n  \n  uint64_t largest_divisor = 1;\n  for (size_t i = 1; i < n; ++i) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n  if(largest_divisor == n){\n      largest_divisor = 1;\n      for (size_t i = 1; i < n; ++i) {\n        if (n % i == 0) {\n            largest_divisor = i;\n        }\n    }\n  }\n  if(largest_divisor == n){\n      largest_divisor = 1;\n  }\n  return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  size_t vl = vsetvl_e64m8(8);\n  vuint64m8_t vn = vmv_s_x_u64m8(n, vl);\n  vuint64m8_t vi = vid_v_u64m8(vl);\n  vbool8_t mask = vmseq_vx_u64m8_b8(vi, vn, vl);\n  vi = vsub_vx_u64m8(vn, vi, vl);\n  mask = vmnot_m_b8(mask, vmseq_vx_u64m8_b8(vi, vn, vl), vl);\n  vuint64m8_t vresult = vdiv_vx_u64m8_m(mask, vn, vn, vi, vl);\n  vbool8_t mask2 = vmseq_vx_u64m8_b8(vresult, 0, vl);\n  vuint64m8_t vfinal = vsub_vx_u64m8(vi, 1, vl);\n  vuint64m8_t vfinal_masked = vmul_vx_u64m8_m(mask2, vfinal, vi, 0, vl);\n  uint64_t result = 0;\n  for (int i = 1; i < n; ++i) {\n    if (n % i == 0) {\n      result = i;\n    }\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  size_t vl = vsetvl_e64m8_i64(8);\n  vuint64m8_t vn = vmv_s_x_u64m8(n, vl);\n  vuint64m8_t vi = vid_v_u64m8(vl);\n  vbool8_t mask = vmseq_vx_u64m8_b8(vi, vn, vl);\n  vi = vsub_vx_u64m8(vn, vi, vl);\n  mask = vmorn_mm_b8(mask, vmseq_vx_u64m8_b8(vi, vn, vl), vl);\n  vi = vdiv_vx_u64m8(vn, vi, vl);\n  vbool8_t mask2 = vmseq_vx_u64m8_b8(vmul_vv_u64m8(vi, vdiv_vx_u64m8(vn, vi, vl), vl), vn, vl);\n  mask = vand_mm_b8(mask, mask2, vl);\n  uint64_t result = 0;\n  for (int i = vl - 1; i >= 1; --i) {\n    if (vget_v_u64(vi, i) < n && n % vget_v_u64(vi, i) == 0) {\n      result = vget_v_u64(vi, i);\n      break;\n    }\n  }\n  if (result == 0){\n      for (uint64_t i = n / 2; i >= 1; i--){\n          if (n % i == 0){\n              return i;\n          }\n      }\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  size_t vl = vsetvl_e64m8(8);\n  vuint64m8_t vn = vmv_s_x_u64m8(n, vl);\n  vuint64m8_t vi = vid_v_u64m8(vl);\n  vbool8_t mask = vmseq_vx_u64m8_b8(vi, vn, vl);\n  vi = vadd_vx_u64m8(vi, 1, vl);\n  mask = vmorn_mm_b8(mask, vmseq_vx_u64m8_b8(vi, vn, vl), vl);\n  vuint64m8_t vresult = vdiv_vx_u64m8_m(mask, vn, vn, vi, vl);\n  vbool8_t remainder_is_zero = vmeq_vx_u64m8_b8(vresult, 0, vl);\n  vuint64m8_t divisors = vdiv_vx_u64m8_m(remainder_is_zero, vn, vn, vi, vl);\n\n  uint64_t largest_divisor = 0;\n  for (size_t i = 0; i < vl; ++i) {\n    if (vget_v_u64m8(divisors, i) != n && vget_v_u64m8(divisors, i) != 0) {\n      if (n % (i + 1) == 0) {\n        largest_divisor = n / (i + 1);\n      }\n    }\n  }\n  if (largest_divisor == 0) {\n    for (uint64_t i = n / 2; i >= 1; --i) {\n      if (n % i == 0) {\n        largest_divisor = i;\n        break;\n      }\n    }\n  }\n\n  return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  size_t vl = vsetvl_e64m8(8);\n  vuint64m8_t vn = vmv_s_x_u64m8(n, vl);\n  vuint64m8_t vi = vid_v_u64m8(vl);\n  vbool8_t mask = vmseq_vx_u64m8_b8(vi, vn, vl);\n  vi = vadd_vx_u64m8(vi, 1, vl);\n  mask = vmorn_mm_b8(mask, vmseq_vx_u64m8_b8(vi, vn, vl), vl);\n  \n  vuint64m8_t vresult = vdiv_vx_u64m8(vn, vi, vl);\n  vbool8_t vdivisible = vmfne_vx_u64m8_b8(vmul_vx_u64m8(vresult, vi, vl), vn, vl);\n  vdivisible = vmorn_mm_b8(vdivisible, mask, vl);\n\n  uint64_t largest_divisor = 0;\n  for (size_t i = 1; i < n; ++i) {\n    if (n % i == 0) {\n      largest_divisor = i;\n    }\n  }\n  \n  return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl;\n    const float *input = l.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(input + i, vl);\n        vbool4_t mask = vmgt_vf_f32m8_b4(v, 0.0f, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b4(mask, j)) {\n                result.push_back(input[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl;\n    const float *input = l.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(input + i, vl);\n        vbool4_t mask = vmgt_vf_f32m8_b4(v, 0.0f, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b4(mask, j)) {\n                result.push_back(input[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl;\n    const float *input = l.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(input + i, vl);\n        vbool4_t mask = vmgt_vf_f32m8_b4(v, 0.0f, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b4(mask, j)) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl;\n    const float *src = l.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(src + i, vl);\n        vbool4_t mask = vmgt_vf_f32m8_b4(v, 0.0f, vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b4(mask, j)) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl;\n    const float *input = l.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(input + i, vl);\n        vbool4_t mask = vmgt_vf_f32m8_b4(v, 0.0f, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b4(mask, j)) {\n                result.push_back(input[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    size_t vl = vsetvl_e64m8(8);\n\n    for (int64_t i = 5; i <= sqrt_n; ) {\n        vint64m8_t vi = vseq_i64m8(vadd_v64m8(vle64_v_i64m8(&i, vl), vmul_vx_i64m8(viota_i64m8(vl, 0), 6, vl), vl), vmul_vx_i64m8(viota_i64m8(vl, 0), 1, vl), vl);\n        for(int j = 0; j < vl; j++){\n            if(i + 6 * j <= sqrt_n){\n                if (n % (i + 6 * j) == 0) return false;\n            }\n        }\n\n        vint64m8_t vi2 = vseq_i64m8(vadd_v64m8(vle64_v_i64m8(&i, vl), vadd_vx_i64m8(vmul_vx_i64m8(viota_i64m8(vl, 0), 6, vl), 1, vl), vl), vmul_vx_i64m8(viota_i64m8(vl, 0), 1, vl), vl);\n        for(int j = 0; j < vl; j++){\n            if(i + 6 * j + 1 <= sqrt_n){\n                if (n % (i + 6 * j + 1) == 0) return false;\n            }\n        }\n        i += vl * 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    size_t vl = vsetvl_e64m8(8);\n\n    for (int64_t i = 5; i <= sqrt_n; ) {\n        vint64m8_t vi = vseq_i64m8(vadd_v64m8(vle64_v_i64m8(&i, vl),vsub_vx_i64m8(vle64_v_i64m8(&i, vl),vle64_v_i64m8(&i, vl), vl), vl), vmul_vx_i64m8(vle64_v_i64m8(&i, vl),n, vl), vl);\n        if(n % i == 0) return false;\n        i += 2;\n        if(n % i == 0) return false;\n        i += 4;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    size_t vl = vsetvl_e64m8(8);\n\n    for (int64_t i = 5; i <= sqrt_n; ) {\n        vint64m8_t vi = vseq_i64m8(vadd_v64m8(vle64_v_i64m8(&i, vl), vmul_vx_i64m8(viota_i64m8(vl, 0), 6, vl), vl), n, vl);\n        if (vfirst_m_b1(vi, vl)) return false;\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    size_t vl = vsetvl_e64m8(8);\n\n    for (int64_t i = 5; i <= sqrt_n; ) {\n        vint64m8_t vi = vseq_i64m8(vadd_v64m8(vle64_v_i64m8(&i, vl), vmul_vx_i64m8(viota_i64m8(vl, 0), 6, vl), vl), n, vl);\n        if (vfirst_m_b1(vi, vl)) return false;\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n\n    size_t vl = vsetvl_e64m8(8);\n    \n    for (int64_t i = 5; i <= sqrt_n; ) {\n        vint64m8_t vi = vset_v_i64m8(i, vl);\n        vint64m8_t vn = vmv_s_x_i64m8(vn, n, vl);\n        vbool8_t mod_res1 = vmseq_vx_i64m8(vrem_vx_i64m8(vn, vi, vl), 0, vl);\n        if (vfirst_m_b8(mod_res1, vl) != -1) return false;\n        \n        i += 2;\n        vi = vset_v_i64m8(i, vl);\n        vn = vmv_s_x_i64m8(vn, n, vl);\n        vbool8_t mod_res2 = vmseq_vx_i64m8(vrem_vx_i64m8(vn, vi, vl), 0, vl);\n        if (vfirst_m_b8(mod_res2, vl) != -1) return false;\n        i += 4;\n        \n        if (i > sqrt_n) break;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t len = s.length();\n    std::string result = s;\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            vs[j] = s[i + j];\n        }\n        \n        vbool8_t is_lower = vmseq_vx_i8m1_b8(vs, 97, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1_b8(vs, 65, vl);\n        vbool8_t is_letter_mask = vmor_mm_b8(is_lower, is_upper, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (isalpha(vs[j])) {\n                if (islower(vs[j])) {\n                    result[i + j] = toupper(vs[j]);\n                } else {\n                    result[i + j] = tolower(vs[j]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t len = s.length();\n    std::string result = s;\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; j++){\n            vs[j] = s[i+j];\n        }\n        \n        vbool8_t is_lower = vmseq_vx_i8m1_b8(vs, 'a' - 1, vl);\n        is_lower = vand_mm_b8(is_lower, vmleq_vx_i8m1_b8(vs, 'z' + 1, vl), vl);\n\n        vbool8_t is_upper = vmseq_vx_i8m1_b8(vs, 'A' - 1, vl);\n        is_upper = vand_mm_b8(is_upper, vmleq_vx_i8m1_b8(vs, 'Z' + 1, vl), vl);\n\n        vint8m1_t lower_to_upper = vsub_vx_i8m1_m(is_lower, vs, 32, vs, vl);\n        vint8m1_t upper_to_lower = vadd_vx_i8m1_m(is_upper, vs, 32, vs, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if(is_lower[j]){\n                result[i+j] = lower_to_upper[j];\n            } else if (is_upper[j]){\n                result[i+j] = upper_to_lower[j];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t len = s.length();\n    std::string result = s;\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t vl = vsetvl_e8m1(len);\n    size_t current_index = 0;\n\n    while (current_index < len) {\n        vl = vsetvl_e8m1(len - current_index);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for (size_t i = 0; i < vl; ++i) {\n            vs = vse_v_i8m1(vs, &s[current_index + i], vl);\n        }\n        \n        for (size_t i = 0; i < vl; ++i) {\n            char c = s[current_index + i];\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    result[current_index + i] = toupper(c);\n                } else {\n                    result[current_index + i] = tolower(c);\n                }\n            }\n        }\n\n        current_index += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t len = s.length();\n    std::string result = s;\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; j++){\n            vs[j] = s[i+j];\n        }\n        \n        vbool8_t is_lower = vmseq_vx_i8m1_b8(vs, 97, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1_b8(vs, 65, vl);\n        \n        vbool8_t is_letter_vec = vmor_mm_b8(is_lower, is_upper, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if(isalpha(s[i+j])){\n                if (islower(s[i+j])) {\n                    result[i+j] = toupper(s[i+j]);\n                } else {\n                    result[i+j] = tolower(s[i+j]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t len = s.length();\n    std::string result = s;\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; j++){\n            vs[j] = s[i+j];\n        }\n        \n        vbool8_t is_lower = vmseq_vx_i8m1(vandi_vx_i8m1(vs, 0xDF, vl), vs, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1(vorandi_vx_i8m1(vs, 0x20, 0xDF, vl), vs, vl);\n\n        vint8m1_t lower_to_upper = vor_vx_i8m1(vs, 0x20, vl);\n        vint8m1_t upper_to_lower = vand_vx_i8m1(vs, 0xDF, vl);\n\n        vint8m1_t temp = vmerge_vvm_i8m1(lower_to_upper, vs, is_lower, vl);\n        vint8m1_t final_result = vmerge_vvm_i8m1(upper_to_lower, temp, is_upper, vl);\n        \n        for(size_t j = 0; j < vl; j++){\n            result[i+j] = final_result[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    std::vector<int> result = l;\n\n    for (size_t i = 0; i < vl; i += vsetvlmax_e32m1()) {\n        size_t current_vl = vsetvl_e32m1(vl - i);\n        vint32m1_t vec_l = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vadd_vx_i32m1(vdiv_vx_i32m1(vsub_vx_i32m1(vid_v_i32m1(current_vl), 1, current_vl), 3, current_vl), 1, current_vl), 1, current_vl), 1, current_vl);\n        \n        std::vector<int> temp_indices;\n        std::vector<int> temp_values;\n        std::vector<size_t> global_indices;\n\n        for (size_t j = 0; j < current_vl; ++j) {\n            if (mask[j]) {\n                temp_indices.push_back(j);\n                temp_values.push_back(l[i + j]);\n                global_indices.push_back(i + j);\n            }\n        }\n\n        std::sort(temp_values.begin(), temp_values.end());\n\n        for (size_t j = 0; j < temp_values.size(); ++j) {\n            result[global_indices[j]] = temp_values[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    std::vector<int> result = l;\n\n    for (size_t i = 0; i < vl; i += vsetvlmax_e32m1()) {\n        size_t current_vl = vsetvl_e32m1(vl - i);\n        vint32m1_t input_vector = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vadd_vx_i32m1(vsub_vx_i32m1(vid_v_i32m1(current_vl),1, current_vl), i, current_vl),3, current_vl),0, current_vl);\n        \n        std::vector<int> temp_indices;\n        std::vector<int> temp_values;\n\n        for (size_t j = 0; j < current_vl; ++j) {\n            if (mask[j]) {\n                temp_indices.push_back(i + j);\n                temp_values.push_back(l[i + j]);\n            }\n        }\n\n        std::sort(temp_values.begin(), temp_values.end());\n\n        for (size_t j = 0; j < temp_indices.size(); ++j) {\n            result[temp_indices[j]] = temp_values[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    std::vector<int> result = l;\n\n    for (size_t i = 0; i < vl; i += vsetvlmax_e32m1()) {\n        size_t current_vl = vsetvl_e32m1(vl - i);\n        vint32m1_t input_vector = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vadd_vx_i32m1(vsub_vx_i32m1(vid_v_i32m1(current_vl), 1, current_vl), 1, current_vl), 1, current_vl), 0, current_vl);\n\n        std::vector<int> temp_indices;\n        std::vector<int> temp_values;\n        std::vector<int> sorted_values;\n\n        for (size_t j = 0; j < current_vl; ++j) {\n            if ((i + j) % 3 == 0) {\n                temp_indices.push_back(i + j);\n                temp_values.push_back(l[i + j]);\n            }\n        }\n\n        sorted_values = temp_values;\n        std::sort(sorted_values.begin(), sorted_values.end());\n\n        for (size_t j = 0; j < temp_indices.size(); ++j) {\n            result[temp_indices[j]] = sorted_values[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    size_t num_groups = (vl + 2) / 3;\n\n    for (size_t i = 0; i < num_groups; ++i) {\n        size_t index = i * 3;\n        if (index + 2 < vl) {\n            std::vector<int> group = {l[index], l[index + 1], l[index + 2]};\n            std::sort(group.begin(), group.begin() + 1);\n            std::sort(group.begin() + 2, group.begin() + 3);\n            std::sort(group.begin(), group.begin() + 1);\n            l[index] = group[0];\n        } else if (index + 1 < vl) {\n            std::vector<int> group = {l[index], l[index + 1]};\n            std::sort(group.begin(), group.begin() + 1);\n            l[index] = group[0];\n        } else if (index < vl) {\n            // Only one element, no sorting needed\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    std::vector<int> result = l;\n\n    for (size_t i = 0; i < vl; i += vsetvlmax_e32m1()) {\n        size_t current_vl = vsetvl_e32m1(vl - i);\n        vint32m1_t vec_l = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vadd_vx_i32m1(vdiv_vx_i32m1(vsub_vx_i32m1(vid_v_i32m1(current_vl), 1, current_vl), 3, current_vl), 1, current_vl), 1, current_vl), 1, current_vl);\n        \n        std::vector<int> temp_indices;\n        std::vector<int> temp_values;\n\n        for (size_t j = 0; j < current_vl; ++j) {\n            if (mask[j]) {\n                temp_indices.push_back(i + j);\n                temp_values.push_back(l[i + j]);\n            }\n        }\n\n        std::sort(temp_values.begin(), temp_values.end());\n\n        for (size_t j = 0; j < temp_indices.size(); ++j) {\n            result[temp_indices[j]] = temp_values[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&l[i], vl);\n        float temp_max = l[i];\n        for(int j = 0; j < vl; j++){\n            float current_val = vget_v_f32m1(v, j);\n            if (current_val > max_val){\n                max_val = current_val;\n            }\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&l[i], vl);\n        float temp_max = l[i];\n        for(int j = 0; j < vl; j++){\n            float current_val = vget_v_f32m1(v, j);\n            if (current_val > max_val){\n                max_val = current_val;\n            }\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&l[i], vl);\n        float temp_max = l[i];\n        for(int j = 0; j < vl; ++j){\n            float current_val = vget_v_f32m1(v, j);\n            if (current_val > max_val){\n                max_val = current_val;\n            }\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle_v_f32m1(&l[i], vl);\n        float temp_max = l[i];\n        for(int j = 0; j < vl; j++){\n            float current_val = vget_v_f32m1(v, j);\n            if(current_val > max_val){\n                max_val = current_val;\n            }\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle_v_f32m1(&l[i], vl);\n        float temp_max = l[i];\n        for(int j = 0; j < vl; j++){\n            float current_val = vget_v_f32m1(v, j);\n            if (current_val > temp_max){\n                temp_max = current_val;\n            }\n        }\n        if (temp_max > max_val){\n            max_val = temp_max;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    if (n <= 1) {\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(n / 2);\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 0; i < n; i += 2) {\n        result[i] = even_elements[i / 2];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    if (n <= 1) {\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(n / 2);\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    std::sort(even_values.begin(), even_values.end());\n\n    size_t k = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        result[i] = even_values[k++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 3) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n - 2; ++i) {\n    for (size_t j = i + 1; j < n - 1; ++j) {\n      for (size_t k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 3) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n - 2; ++i) {\n    for (size_t j = i + 1; j < n - 1; ++j) {\n      for (size_t k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vl = l.size();\n    std::vector<int> result(vl);\n    size_t start = 0;\n    while (start < vl) {\n        size_t current_vl = vsetvl_e32m1(vl - start);\n        vint32m1_t v = vle32_v_i32m1(&l[start], current_vl);\n        vint32m1_t v_incr = vadd_vx_i32m1(v, 1, current_vl);\n        vse32_v_i32m1(&result[start], v_incr, current_vl);\n        start += current_vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vl = l.size();\n    std::vector<int> result(vl);\n    size_t avl;\n    size_t start = 0;\n\n    while (start < vl) {\n        avl = vsetvl_e32m8(vl - start);\n        vint32m8_t v = vle32_v_i32m8(&l[start], avl);\n        vint32m8_t v_incr = vadd_vx_i32m8(v, 1, avl);\n        vse32_v_i32m8(&result[start], v_incr, avl);\n        start += avl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t vl;\n    size_t i = 0;\n\n    while (n > 0) {\n        vl = vsetvl_e32m1(n);\n        vint32m1_t v = vle32_v_i32m1(&l[i], vl);\n        vint32m1_t v_incr = vadd_vx_i32m1(v, 1, vl);\n        vse32_v_i32m1(&result[i], v_incr, vl);\n        i += vl;\n        n -= vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vl = l.size();\n    std::vector<int> result(vl);\n    size_t start = 0;\n    while (start < vl) {\n        size_t current_vl = vsetvl_e32m1(vl - start);\n        vint32m1_t v = vle32_v_i32m1(&l[start], current_vl);\n        vint32m1_t v_incr = vadd_vx_i32m1(v, 1, current_vl);\n        vse32_v_i32m1(&result[start], v_incr, current_vl);\n        start += current_vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    size_t i = 0;\n    while (i < n) {\n        vl = vsetvl_e32m8_i32(n - i);\n        vint32m8_t v = vle32_v_i32m8(&l[i], vl);\n        vint32m8_t v_incr = vadd_vx_i32m8(v, 1, vl);\n        vse32_v_i32m8(&result[i], v_incr, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = i + 1; j < n; ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = i + 1; j < n; ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = i + 1; j < n; ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = i + 1; j < n; ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  size_t n = l.size();\n  if (n < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = i + 1; j < n; ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t l = 0;\n  size_t r = len - 1;\n\n  size_t vl;\n  while (l < r) {\n    vl = vsetvl_e8m1(r - l + 1);\n    size_t group_size = vl;\n\n    if (group_size > (r - l + 1)) {\n      group_size = r - l + 1;\n    }\n\n    for (size_t i = 0; i < group_size; ++i) {\n      if (text[l + i] != text[r - i]) {\n        return false;\n      }\n    }\n    l += group_size;\n    r -= group_size;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t l = 0;\n  size_t r = len - 1;\n\n  size_t vl;\n  while (l < r) {\n    vl = vsetvl_e8m1(r - l + 1);\n    size_t group_size = vl;\n\n    if (group_size > (r - l + 1)) {\n      group_size = r - l + 1;\n    }\n\n    for (size_t i = 0; i < group_size; ++i) {\n      if (text[l + i] != text[r - i]) {\n        return false;\n      }\n    }\n    l += group_size;\n    r -= group_size;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t l = 0;\n  size_t r = len - 1;\n\n  size_t vl;\n  while (l < r) {\n    vl = vsetvl_e8m1(r - l + 1);\n    size_t group_size = vl;\n\n    if (group_size > (r - l + 1)) {\n        group_size = r - l + 1;\n    }\n    \n    for (size_t i = 0; i < group_size; ++i) {\n        if (text[l + i] != text[r - i]) {\n            return false;\n        }\n    }\n    l += group_size;\n    r -= group_size;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t l = 0;\n  size_t r = len - 1;\n\n  size_t vl;\n  while (l < r) {\n    vl = vsetvl_e8m1(r - l + 1);\n    size_t group_size = vl;\n\n    if (group_size > (r - l + 1)) {\n      group_size = r - l + 1;\n    }\n\n    const char *left_ptr = text.data() + l;\n    const char *right_ptr = text.data() + r;\n\n    vint8m1_t left_vec = vle8_v_i8m1(left_ptr, vl);\n    vint8m1_t right_vec = vle8_v_i8m1(right_ptr - group_size + 1, vl);\n\n    right_vec = vredor_vs_i8m1_i8m1(right_vec, right_vec, vmv_v_x_i8m1(0, vl), vl);\n    \n    vbool8_t cmp = vmsne_vx_i8m1_b8(left_vec, text[r], vl);\n\n    if (vfirst_m_b8(cmp, vl) != -1)\n      return false;\n    \n    l += group_size;\n    r -= group_size;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t l = 0;\n  size_t r = len - 1;\n\n  while (l < r) {\n    size_t vl = vsetvl_e8m1(r - l + 1);\n    vint8m1_t left_vec = vlse8_v_i8m1(&text[l], 1, vl);\n    vint8m1_t right_vec = vlse8_v_i8m1(&text[r], -1, vl);\n\n    vbool8_t cmp = vme8_m_b8(left_vec, right_vec, vl);\n\n    if (!vtest_all_e8_m_b8(cmp, vl)) {\n      return false;\n    }\n\n    l += vl;\n    r -= vl;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    size_t len = s.length();\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(-5, vl);\n        vint8m1_t vin = vle8_v_i8m1(&s[i], vl);\n        vint8m1_t va = vadd_vv_i8m1(vin, vs, vl);\n        \n        vbool8_t mask_lower = vmseq_vx_i8m1_b8(va, (int8_t)('a' - 1), vl);\n        vint8m1_t vresult = vor_vx_i8m1(vand_vm_vx_i8m1(mask_lower, va, (int8_t)('z' - 'a' + 1), vl), vand_not_vm_vx_i8m1(mask_lower, va, 0, vl), vl);\n        \n        vbool8_t mask_upper = vmsge_vx_i8m1_b8(vresult, (int8_t)('a'), vl);\n        vint8m1_t vfinal = vor_vx_i8m1(vand_vm_vx_i8m1(mask_upper, vresult, 0, vl), vand_not_vm_vx_i8m1(mask_upper, vresult, (int8_t)('a' - 'a'), vl), vl);\n        \n        vse8_v_i8m1((int8_t*)&out[i], vfinal, vl);\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    size_t len = s.length();\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            vs[j] = s[i + j];\n        }\n        \n        vint8m1_t va = vsub_vx_i8m1(vs, 5, vl);\n        vint8m1_t vt = vsub_vx_i8m1(va, (int8_t)'a', vl);\n        vint8m1_t vm = vrem_vx_i8m1(vt, 26, vl);\n        vint8m1_t vf = vadd_vx_i8m1(vm, (int8_t)'a', vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            out += (char)vf[j];\n        }\n\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    size_t len = s.length();\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m8_i8(len - i);\n        vint8m8_t vs = vle8_v_i8m8(&s[i], vl);\n        vint8m8_t va = vsub_vx_i8m8(vs, 5, vl);\n        vint8m8_t vt = vsub_vx_i8m8(va, (int8_t)'a', vl);\n        vint8m8_t vm = vrem_vx_i8m8(vt, 26, vl);\n        vint8m8_t vf = vadd_vx_i8m8(vm, (int8_t)'a', vl);\n        \n        int8_t result[vl];\n        vse8_v_i8m8(result, vf, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            out += (char)result[j];\n        }\n\n        i += vl;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    size_t len = s.length();\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(-5, vl);\n        vint8m1_t vin = vle8_v_i8m1(&s[i], vl);\n        vint8m1_t va = vadd_vv_i8m1(vin, vs, vl);\n        \n        vbool8_t lower_than_a = vmblt_vx_i8m1_b8(vin, (int8_t)'a', vl);\n        vint8m1_t offset = vmerge_vxm_i8m1(lower_than_a, va, 26, vl);\n\n        vse8_v_i8m1((int8_t*)&out[i], offset, vl);\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    size_t len = s.length();\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            vs[j] = s[i+j];\n        }\n        \n        vint8m1_t va = vsub_vx_i8m1(vs, 5, vl);\n        vint8m1_t vt = vsub_vx_i8m1(va, (int8_t)'a', vl);\n        vint8m1_t vm = vmod_vx_i8m1(vt, 26, vl);\n        vint8m1_t vf = vadd_vx_i8m1(vm, (int8_t)'a', vl);\n\n        for(size_t j = 0; j < vl; ++j){\n            out += (char)vf[j];\n        }\n\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t vl = l.size();\n    size_t i = 0;\n    bool result = true;\n\n    while (i < vl) {\n        size_t current_vl = vmin_vl_xu(vl - i, vsetvlmax_e32m1());\n        vint32m1_t vx = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t vb = vmleq_vx_i32m1_b32(vx, t, current_vl);\n        if (!vtest_all_e32(vb, current_vl)) {\n            result = false;\n            break;\n        }\n        i += current_vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t vl = l.size();\n    size_t avl = 0;\n    size_t i = 0;\n    bool result = true;\n\n    while (vl > 0) {\n        size_t current_vl = vsetvl_e32m8_i32(vl);\n        vint32m8_t vec_l = vle32_v_i32m8(&l[i], current_vl);\n        vbool4_t mask = vmleq_vx_i32m8_b4(vec_l, t, current_vl);\n\n        if (!vtest_valid_mask(mask, current_vl)) {\n            result = false;\n            break;\n        }\n\n        vl -= current_vl;\n        i += current_vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t vl = l.size();\n    size_t avl = 0;\n    size_t i = 0;\n    bool result = true;\n\n    while (vl > 0) {\n        size_t current_vl = vsetvl_e32m8_i32(vl);\n        vint32m8_t vec_l = vle32_v_i32m8(&l[i], current_vl);\n        vbool4_t mask = vmblt_vi_i32m8_b4(vec_l, t, current_vl);\n\n        if (!vtest_all_e32(mask, current_vl)) {\n            result = false;\n            break;\n        }\n\n        vl -= current_vl;\n        i += current_vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t vl = vsetvl_max_e32m1();\n    size_t n = l.size();\n    size_t i = 0;\n    bool result = true;\n    while (n > 0) {\n        vl = vsetvl_e32m1(n);\n        vint32m1_t vx = vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = vmleq_vx_i32m1_b32(vx, t, vl);\n        if (!vtest_all_e32(mask, vl)) {\n            result = false;\n            break;\n        }\n        i += vl;\n        n -= vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t vl = l.size();\n    size_t i = 0;\n    bool result = true;\n\n    while (i < vl) {\n        size_t current_vl = vmin_vl_xu(vl - i, vsetvlmax_e32m1());\n        vint32m1_t vec_l = vle32_v_i32m1(&l[i], current_vl);\n        vbool32_t mask = vmleq_vx_i32m1_b32(vec_l, t, current_vl);\n\n        if (!vtest_all_e32(mask, current_vl)) {\n            result = false;\n            break;\n        }\n\n        i += current_vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  size_t len = brackets.length();\n  if (len == 0) return true;\n\n  int balance = 0;\n  size_t vl = vsetvl_e8m1(len);\n  size_t start = 0;\n\n  while (start < len) {\n    vl = vsetvl_e8m1(len - start);\n    vint8m1_t chars = vle8_v_i8m1(brackets.data() + start, vl);\n\n    for (size_t i = 0; i < vl; ++i) {\n      char c = (char)vget_i8(chars, i);\n      if (c == '<') {\n        balance++;\n      } else if (c == '>') {\n        balance--;\n      }\n      if (balance < 0) return false;\n    }\n    start += vl;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  size_t len = brackets.length();\n  if (len == 0) return true;\n\n  int balance = 0;\n  size_t vl = vsetvl_e8m8_max(len);\n  size_t start = 0;\n\n  while (start < len) {\n    vl = vsetvl_e8m8(len - start);\n    vint8m8_t v = vle8_v_i8m8(brackets.data() + start, vl);\n\n    for (size_t i = 0; i < vl; ++i) {\n      char c = (char)vget_i8(v, i);\n      if (c == '<') {\n        balance++;\n      } else if (c == '>') {\n        balance--;\n      }\n      if (balance < 0) {\n        return false;\n      }\n    }\n    start += vl;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  size_t len = brackets.length();\n  if (len == 0) return true;\n\n  int balance = 0;\n  size_t vl = vsetvl_e8m1(len);\n  vint8m1_t v = vmv_v_x_i8m1(0, vl);\n\n  for (size_t i = 0; i < len; i += vl) {\n    vl = vsetvl_e8m1(len - i);\n    for (size_t j = 0; j < vl; ++j) {\n      if (brackets[i + j] == '<') {\n        balance++;\n      } else if (brackets[i + j] == '>') {\n        balance--;\n      }\n      if (balance < 0) return false;\n    }\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  size_t len = brackets.length();\n  if (len == 0) return true;\n\n  int balance = 0;\n  size_t vl = vsetvl_e8m8_max(len);\n  size_t start = 0;\n\n  while (start < len) {\n    vl = vsetvl_e8m8(len - start);\n    vint8m8_t chars = vle8_v_i8m8(brackets.data() + start, vl);\n\n    vbool1_t opening = vmseq_vx_i8m8_b1(chars, '<', vl);\n    vbool1_t closing = vmseq_vx_i8m8_b1(chars, '>', vl);\n\n    size_t opening_count = vpopc_m_b1(opening, vl);\n    size_t closing_count = vpopc_m_b1(closing, vl);\n\n    balance += (int)opening_count - (int)closing_count;\n\n    if (balance < 0) return false;\n\n    start += vl;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  size_t len = brackets.length();\n  if (len == 0) return true;\n\n  int balance = 0;\n  size_t vl = vsetvl_e8m8_max(len);\n  size_t start = 0;\n\n  while (start < len) {\n    vl = vsetvl_e8m8(len - start);\n    vint8m8_t chars = vle8_v_i8m8(brackets.data() + start, vl);\n\n    for (size_t i = 0; i < vl; ++i) {\n      char c = (char)vget_i8(chars, i);\n      if (c == '<') {\n        balance++;\n      } else if (c == '>') {\n        balance--;\n      }\n      if (balance < 0) return false;\n    }\n    start += vl;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t len = brackets.length();\n    size_t vl = vsetvl_e32m1(len);\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m1(len - i);\n        vint32m1_t open_brackets = vmv_v_i32m1(0, vl);\n        vint32m1_t close_brackets = vmv_v_i32m1(0, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < len) {\n                if (brackets[i + j] == '(') {\n                    open_brackets = vse32_v_i32m1(open_brackets, 1, j);\n                } else if (brackets[i + j] == ')') {\n                    close_brackets = vse32_v_i32m1(close_brackets, 1, j);\n                }\n            }\n        }\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < len) {\n                if (brackets[i + j] == '(') {\n                    balance++;\n                } else if (brackets[i + j] == ')') {\n                    balance--;\n                }\n                if (balance < 0) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t len = brackets.length();\n    size_t vl = vsetvl_e32m1(len); \n\n    for (size_t i = 0; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t len = brackets.length();\n    size_t vl = vsetvl_e32m1(len); \n\n    for (size_t i = 0; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t len = brackets.length();\n    size_t vl = vsetvl_e32m1(len);\n    \n    for (size_t i = 0; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t len = brackets.length();\n    size_t vl = vsetvl_e32m1(len); \n\n    for (size_t i = 0; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n    size_t vl;\n    for (size_t i = 0; i < n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vfloat32m1_t v_xs = vle32_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t v_index = vfloat32m1_t(0);\n        \n        std::vector<float> index_vec(vl);\n        for(size_t j = 0; j < vl; ++j){\n            index_vec[j] = (float)(i + 1 + j);\n        }\n        v_index = vle32_v_f32m1(index_vec.data(), vl);\n        \n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_xs, v_index, vl);\n        vse32_v_f32m1(&result[i], v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n\n    size_t vl = vsetvl_e32m1(n - 1);\n    for (size_t i = 0; i < n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vfloat32m1_t v_indices = vfiota_m_f32m1(vbool32_t(1), 1.0f, vl);\n        vfloat32m1_t v_xs = vle_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_indices, v_xs, vl);\n        vse_v_f32m1(&result[i], v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n\n    size_t vl = vsetvl_e32m8_max(n - 1);\n    for (size_t i = 0; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n\n    size_t vl = vsetvl_e32m8_max(n - 1);\n    for (size_t i = 0; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n    std::vector<float> result(n - 1);\n    size_t vl;\n    for (size_t i = 0; i < n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vfloat32m1_t v_xs = vle32_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t v_indices = vfloat32m1_t(0);\n        for(int j = 0; j < vl; j++){\n            ((float*)&v_indices)[j] = (float)(i + j + 1);\n        }\n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_xs, v_indices, vl);\n        vse32_v_f32m1(&result[i], v_result, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n\n        vbool8_t mask_a = vmseq_vx_i8m1_b8(vs, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_i8m1_b8(vs, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_i8m1_b8(vs, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_i8m1_b8(vs, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_i8m1_b8(vs, 'u', vl);\n\n        vbool8_t mask_vowels = vmor_mm_b8(mask_a, mask_e, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_i, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_o, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_u, vl);\n\n        long temp_count = vpopc_m_b8(mask_vowels, mask_vowels, vl);\n        count += temp_count;\n\n        if (i + vl >= n && n > 0 && (s[n - 1] == 'y' || s[n - 1] == 'Y')) {\n            bool last_is_vowel = true;\n            for(size_t j = 0; j < vl; ++j){\n                if(i + j == n - 1){\n                    if(vget_v_i8m1(vs, j) != 'y' && vget_v_i8m1(vs, j) != 'Y'){\n                        last_is_vowel = false;\n                    }\n                    break;\n                }\n            }\n            if(last_is_vowel){\n                count++;\n            }\n            \n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; j++){\n            vs = vse_v_i8m1(vs, &s[i+j], vl);\n        }\n        \n        vbool8_t mask_a = vmseq_vx_i8m1_b8(vs, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_i8m1_b8(vs, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_i8m1_b8(vs, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_i8m1_b8(vs, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_i8m1_b8(vs, 'u', vl);\n\n        vbool8_t mask_y = vmseq_vx_i8m1_b8(vs, 'y', vl);\n        if (i + vl >= n && n > 0) {\n            if(s[n-1] == 'y'){\n                count++;\n            }\n        }\n        \n        count += vpopc_m_b8(mask_a, vl);\n        count += vpopc_m_b8(mask_e, vl);\n        count += vpopc_m_b8(mask_i, vl);\n        count += vpopc_m_b8(mask_o, vl);\n        count += vpopc_m_b8(mask_u, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n\n        vbool8_t mask_a = vmseq_vx_i8m1_b8(vs, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_i8m1_b8(vs, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_i8m1_b8(vs, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_i8m1_b8(vs, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_i8m1_b8(vs, 'u', vl);\n\n        vbool8_t mask_vowels = vmor_mm_b8(mask_a, mask_e, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_i, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_o, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_u, vl);\n\n        if (i + vl >= n && n > 0) {\n            vbool8_t mask_y = vmseq_vx_i8m1_b8(vs, 'y', vl);\n            mask_vowels = vmor_mm_b8(mask_vowels, mask_y, vl);\n        }\n\n        size_t local_count = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask_vowels, j)) {\n                local_count++;\n            }\n        }\n        count += local_count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n\n        vbool8_t mask_a = vmseq_vx_i8m1_b8(vs, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_i8m1_b8(vs, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_i8m1_b8(vs, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_i8m1_b8(vs, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_i8m1_b8(vs, 'u', vl);\n\n        vbool8_t mask_vowels = vmor_mm_b8(mask_a, mask_e, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_i, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_o, vl);\n        mask_vowels = vmor_mm_b8(mask_vowels, mask_u, vl);\n\n        if (i + vl >= n && n > 0) {\n            vbool8_t mask_y = vmseq_vx_i8m1_b8(vs, 'y', vl);\n            mask_vowels = vmor_mm_b8(mask_vowels, mask_y, vl);\n        }\n\n        size_t local_count = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask_vowels, j)) {\n                local_count++;\n            }\n        }\n        count += local_count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n        \n        vbool8_t mask_a = vmseq_vx_i8m1_b8(vs, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_i8m1_b8(vs, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_i8m1_b8(vs, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_i8m1_b8(vs, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_i8m1_b8(vs, 'u', vl);\n        vbool8_t mask_A = vmseq_vx_i8m1_b8(vs, 'A', vl);\n        vbool8_t mask_E = vmseq_vx_i8m1_b8(vs, 'E', vl);\n        vbool8_t mask_I = vmseq_vx_i8m1_b8(vs, 'I', vl);\n        vbool8_t mask_O = vmseq_vx_i8m1_b8(vs, 'O', vl);\n        vbool8_t mask_U = vmseq_vx_i8m1_b8(vs, 'U', vl);\n\n        vbool8_t mask = vmor_mm_b8(mask_a, mask_e, vl);\n        mask = vmor_mm_b8(mask, mask_i, vl);\n        mask = vmor_mm_b8(mask, mask_o, vl);\n        mask = vmor_mm_b8(mask, mask_u, vl);\n        mask = vmor_mm_b8(mask, mask_A, vl);\n        mask = vmor_mm_b8(mask, mask_E, vl);\n        mask = vmor_mm_b8(mask, mask_I, vl);\n        mask = vmor_mm_b8(mask, mask_O, vl);\n        mask = vmor_mm_b8(mask, mask_U, vl);\n\n        long count_v = vpopc_m_b8(mask, vl);\n        count += count_v;\n    }\n\n    if (n > 0 && (s[n - 1] == 'y' || s[n - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  size_t n = s.length();\n  int sum = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  size_t vl;\n  size_t i = 0;\n\n  while (i < n) {\n    vl = vsetvl_e8m1(n - i);\n    vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n    vbool8_t upper_mask = vmseq_vx_i8m1(vmsle_vx_i8m1(vs, 'Z', vl), true, vl);\n    upper_mask = vand_mm_b8(upper_mask, vmseq_vx_i8m1(vmsge_vx_i8m1(vs, 'A', vl), true, vl), vl);\n    \n    int8_t temp_sum[8] = {0};\n    vse8_v_i8m1(temp_sum, vs, vl);\n\n    for (size_t j = 0; j < vl; ++j) {\n      if (upper_mask[j]) {\n        sum += temp_sum[j];\n      }\n    }\n\n    i += vl;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  size_t n = s.length();\n  int sum = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  size_t vl;\n  size_t i = 0;\n  while (i < n) {\n    vl = vsetvl_e8m1(n - i);\n    vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n    vbool8_t upper_mask = vmseq_vx_i8m1(vmsle_vx_i8m1(vs, 'Z', vl), 1, vl);\n    vbool8_t lower_mask = vmseq_vx_i8m1(vmsge_vx_i8m1(vs, 'A', vl), 1, vl);\n    vbool8_t final_mask = vand_mm_b8(upper_mask, lower_mask, vl);\n\n    int8_t temp_sum[8];\n    vse8_v_i8m1(temp_sum, vs, vl);\n\n    for (size_t j = 0; j < vl; ++j) {\n      if (final_mask[j]) {\n        sum += temp_sum[j];\n      }\n    }\n\n    i += vl;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n        vbool8_t upper_mask = vmseq_vx_i8m1(vs, 64, vl);\n        upper_mask = vmand_mm_b8(upper_mask, vmsle_vx_i8m1(vs, 90, vl), vl);\n        vint8m1_t masked_vs = vmand_vx_i8m1(vs, 0, upper_mask, vl);\n        int8_t temp_sum[vl];\n        vse8_v_i8m1(temp_sum, masked_vs, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (s[i+j] >= 'A' && s[i+j] <= 'Z')\n                sum += s[i+j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  size_t n = s.length();\n  int sum = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  size_t vl;\n  size_t i = 0;\n\n  while (i < n) {\n    vl = vsetvl_e8m1(n - i);\n    vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n    vbool8_t upper_mask = vmseq_vx_i8m1(vmsle_vx_i8m1(vs, 'Z', vl), 1, vl);\n    vbool8_t lower_mask = vmseq_vx_i8m1(vmsge_vx_i8m1(vs, 'A', vl), 1, vl);\n    vbool8_t final_mask = vand_mm_b8(upper_mask, lower_mask, vl);\n    \n    int8_t temp_sum[8];\n    vse8_v_i8m1(temp_sum, vs, vl);\n\n    for (size_t j = 0; j < vl; ++j) {\n      if (final_mask[j]) {\n        sum += temp_sum[j];\n      }\n    }\n\n    i += vl;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  size_t n = s.length();\n  int sum = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  size_t vl;\n  size_t i = 0;\n\n  while (i < n) {\n    vl = vsetvl_e8m1(n - i);\n    vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n    vbool8_t upper_mask = vmseq_vx_i8m1(vmsle_vx_i8m1(vs, 'Z', vl), 1, vl);\n    vbool8_t lower_mask = vmseq_vx_i8m1(vmsge_vx_i8m1(vs, 'A', vl), 1, vl);\n    vbool8_t final_mask = vand_mm_b8(upper_mask, lower_mask, vl);\n\n    int8_t temp_array[vl];\n    vse8_v_i8m1(temp_array, vs, vl);\n\n    for (size_t j = 0; j < vl; ++j) {\n      if (final_mask[j]) {\n        sum += temp_array[j];\n      }\n    }\n\n    i += vl;\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, (int)smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, (int)smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, (int)smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, (int)smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, (int)smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    std::sort(lst.begin(), lst.end());\n    lst.erase(std::unique(lst.begin(), lst.end()), lst.end());\n\n    for (int val : lst) {\n        int count = 0;\n        size_t vl = vsetvl_max_e32m1();\n        std::vector<int> counts(vl, 0);\n\n        for (size_t i = 0; i < lst.size(); i += vl) {\n            vl = vsetvl_e32m1(lst.size() - i);\n            vint32m1_t vec_val = vmv_v_x_i32m1(val, vl);\n            vint32m1_t vec_lst = vle32_v_p_i32m1((int32_t*)&lst[i], __riscv_vmsne_vx_i32m1_b32(val, val, vl), vl);\n            vbool32_t mask = vmseq_vv_i32m1_b32(vec_val, vec_lst, vl);\n            \n            for (size_t j = 0; j < vl; ++j) {\n                if (vget_v_i32m1(vec_lst, j) == val) {\n                    count++;\n                }\n            }\n        }\n\n        if (count >= val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    for (int i = 1000; i >= 1; --i) {\n        int count = 0;\n        size_t vl = vsetvl_max_e32m1();\n        std::vector<int32_t> temp_vec(vl);\n        for (size_t j = 0; j < lst.size(); j += vl) {\n            vl = vsetvl_e32m1(lst.size() - j);\n            for (size_t k = 0; k < vl; ++k) {\n                temp_vec[k] = lst[j + k];\n            }\n            vint32m1_t vec = vle32_v_i32m1(temp_vec.data(), vl);\n            vbool32_t mask = vmseq_vx_i32m1_b32(vec, i, vl);\n            count += vpopc_m_b32(mask, vl);\n        }\n        if (count >= i) {\n            max_val = i;\n            break;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    std::sort(lst.begin(), lst.end());\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int current_val = lst[i];\n        if (current_val <= 0) continue;\n\n        size_t count = 0;\n        size_t j = i;\n        while (j < n && lst[j] == current_val) {\n            count++;\n            j++;\n        }\n\n        if (count >= (size_t)current_val) {\n            max_val = std::max(max_val, current_val);\n        }\n        i = j - 1; \n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    std::sort(lst.begin(), lst.end());\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int current_val = lst[i];\n        if (current_val <= 0) continue;\n\n        size_t count = 0;\n        for (size_t j = 0; j < n; ++j) {\n            if (lst[j] == current_val) {\n                count++;\n            }\n        }\n\n        if (count >= current_val && current_val > max_val) {\n            max_val = current_val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    std::sort(lst.begin(), lst.end());\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int current_val = lst[i];\n        if (current_val <= 0) continue;\n\n        size_t count = 0;\n        for (size_t j = 0; j < n; ++j) {\n            if (lst[j] == current_val) {\n                count++;\n            }\n        }\n\n        if (count >= current_val && current_val > max_val) {\n            max_val = current_val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  size_t len = q.size();\n  if (len == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (size_t i = 0; i < len / 2; ++i) {\n    if (q[i] != q[len - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using RVV intrinsics\n  int sum = 0;\n  size_t vl;\n  size_t i = 0;\n  while (i < len) {\n    vl = vsetvl_e32m8(len - i);\n    vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n    int32_t temp_sum = vreduce_add_vs_i32m8_i32(0, v, vmv_s_x_i32m1(0, vl), vl);\n    sum += temp_sum;\n    i += vl;\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  size_t len = q.size();\n  if (len == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (size_t i = 0; i < len / 2; ++i) {\n    if (q[i] != q[len - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate sum using RVV intrinsics\n  int sum = 0;\n  size_t vl = vsetvl_v_i32m1(len);\n  vint32m1_t vec_sum = vmv_v_i32m1(0, vl); \n\n  for (size_t i = 0; i < len; i += vl) {\n    vl = vsetvl_v_i32m1(len - i);\n    vint32m1_t vec_q = vle_v_i32m1(&q[i], vl);\n    vec_sum = vop_i32m1(vec_sum, vec_q, vl);\n  }\n\n  int32_t temp_sum[1];\n  vse_v_i32m1(temp_sum, vec_sum, 1);\n  sum = temp_sum[0];\n\n  // Check if sum is less than or equal to w\n  return (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  size_t len = q.size();\n  if (len == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (size_t i = 0; i < len / 2; ++i) {\n    if (q[i] != q[len - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using RVV intrinsics\n  int sum = 0;\n  size_t vl;\n  size_t i = 0;\n  while (i < len) {\n    vl = vsetvl_e32m8(len - i);\n    vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n    int32_t temp_sum = vmv_x_s_i32m8_i32(vreduce_add_vs_i32m8_i32m8(v, v, vl));\n    sum += temp_sum;\n    i += vl;\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  size_t len = q.size();\n  if (len == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (size_t i = 0; i < len / 2; ++i) {\n    if (q[i] != q[len - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using RVV intrinsics\n  int sum = 0;\n  size_t vl;\n  size_t i = 0;\n\n  while (i < len) {\n    vl = vsetvl_e32m8(len - i);\n    vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n    int32_t temp_sum = vreduce_add_vs_i32m8_i32(0, v, vl);\n    sum += temp_sum;\n    i += vl;\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  size_t len = q.size();\n  if (len == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (size_t i = 0; i < len / 2; ++i) {\n    if (q[i] != q[len - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using RVV intrinsics\n  int sum = 0;\n  size_t vl;\n  size_t i = 0;\n  while (i < len) {\n    vl = vsetvl_e32m8(len - i);\n    vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n    int32_t temp_sum = vmv_x_s_i32m8_i32(vreduce_add_vs_i32m8_i32m8(v, v, vl));\n    sum += temp_sum;\n    i += vl;\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n  if (n == 1) {\n    return x == 1;\n  }\n  if (x == 0) {\n    return false;\n  }\n  if (x == 1) {\n    return true;\n  }\n\n  uint64_t current_power = n;\n  while (current_power <= x) {\n    if (current_power == x) {\n      return true;\n    }\n    if (x / current_power < n) {\n        return false;\n    }\n    current_power *= n;\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n  if (n == 1) {\n    return x == 1;\n  }\n  if (n == 0) {\n    return x == 1;\n  }\n  if (x == 0) {\n      return false;\n  }\n\n  uint64_t current_power = 1;\n  while (current_power <= x) {\n    if (current_power == x) {\n      return true;\n    }\n    if (x / n < current_power) {\n        return false;\n    }\n    current_power *= n;\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n  if (n == 1) {\n    return x == 1;\n  }\n  if (n == 0) {\n    return x == 1;\n  }\n  if (x == 0) {\n      return false;\n  }\n\n  uint64_t current_power = 1;\n  while (current_power <= x) {\n    if (current_power == x) {\n      return true;\n    }\n    if (x / n < current_power) {\n        return false;\n    }\n    current_power *= n;\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n  if (n == 1) {\n    return x == 1;\n  }\n  if (x == 0) {\n    return false;\n  }\n  if (x == 1) {\n    return true;\n  }\n\n  uint64_t current_power = n;\n  while (current_power <= x) {\n    if (current_power == x) {\n      return true;\n    }\n    if (x / current_power < n) {\n        return false;\n    }\n    current_power *= n;\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current = n;\n    while (current <= x) {\n        if (current == x) {\n            return true;\n        }\n        if (x / current < n) {\n            return false;\n        }\n        current *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    size_t n = num.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vuint8m1_t hex_digits = vmv_v_x_u8m1(0, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            unsigned char c = num[i + j];\n            hex_digits = vse8_v_u8m1(&((unsigned char*)hex_digits)[j], c, vl);\n        }\n\n        vbool8_t prime_mask_2 = vmseq_vx_u8m1_b8(hex_digits, '2', vl);\n        vbool8_t prime_mask_3 = vmseq_vx_u8m1_b8(hex_digits, '3', vl);\n        vbool8_t prime_mask_5 = vmseq_vx_u8m1_b8(hex_digits, '5', vl);\n        vbool8_t prime_mask_7 = vmseq_vx_u8m1_b8(hex_digits, '7', vl);\n        vbool8_t prime_mask_B = vmseq_vx_u8m1_b8(hex_digits, 'B', vl);\n        vbool8_t prime_mask_D = vmseq_vx_u8m1_b8(hex_digits, 'D', vl);\n\n        vbool8_t prime_mask_23 = vor_mm_b8(prime_mask_2, prime_mask_3, vl);\n        vbool8_t prime_mask_57 = vor_mm_b8(prime_mask_5, prime_mask_7, vl);\n        vbool8_t prime_mask_BD = vor_mm_b8(prime_mask_B, prime_mask_D, vl);\n\n        vbool8_t prime_mask_2357 = vor_mm_b8(prime_mask_23, prime_mask_57, vl);\n        vbool8_t prime_mask = vor_mm_b8(prime_mask_2357, prime_mask_BD, vl);\n\n        size_t prime_count = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1_u8m1(prime_mask, j)) {\n                prime_count++;\n            }\n        }\n        count += prime_count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    size_t len = num.length();\n\n    if (len == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(len);\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t v = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            char c = num[i+j];\n            int digit;\n            if (c >= '0' && c <= '9') {\n                digit = c - '0';\n            } else {\n                digit = c - 'A' + 10;\n            }\n            \n            if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    size_t len = num.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    size_t n = num.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    size_t n = num.size();\n    int count = 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0 ? '0' : '1');\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0 ? '0' : '1');\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0 ? '0' : '1');\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0 ? '0' : '1');\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0 ? '0' : '1');\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n    for (size_t i = 1; i < n; i += vl * 2) {\n        vl = vsetvl_e32m1(n - i > 2 * vsetvlmax_e32m1() ? 2 * vsetvlmax_e32m1() : n - i);\n        vint32m1_t vec_i = vlse32_v_i32m1(&lst[i], 2 * sizeof(int), vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(vec_i, 1, vl), 0, vl);\n        int32_t temp_sum = vmv_x_s_i32m1(vreduce_add_vs_i32m1_i32m1(mask, vec_i, 0, vl));\n        sum += temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1), 0, vl);\n        int32_t temp_sum = vreduce_add_vs_i32m1_i32m1(0, v, mask, vl);\n        sum += temp_sum;\n        \n        vl = vsetvl_e32m1(n - i - 1);\n        i++;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1), 0, vl);\n        int32_t temp_sum = vmv_x_s_i32m1(vreduce_sum_vs_i32m1_i32m1(v, vmand_mm_b32(mask, mask, vl), vl));\n        sum += temp_sum;\n        \n        if (vl == 0) break;\n        \n        if (n - i <= vl) break;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1), 0, vl);\n        int32_t temp_sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vgetbit_b32(mask, j)) {\n                temp_sum += lst[i + j];\n            }\n        }\n        sum += temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1), 0, vl);\n        int32_t temp_sum = vreduce_add_vs_i32m1_i32m1(0, v, mask, vl);\n        sum += temp_sum;\n        \n        vl = vsetvl_e32m1(n - (i + vl));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl); \n\n        for(size_t j = 0; j < vl; ++j){\n            char c = s[i+j];\n            if (isalpha(c)) {\n                char base = isupper(c) ? 'A' : 'a';\n                result[i+j] = (c - base + 4) % 26 + base;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            char c = s[i+j];\n            if (isalpha(c)) {\n                char base = isupper(c) ? 'A' : 'a';\n                result[i+j] = (c - base + 4) % 26 + base;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            char c = s[i+j];\n            if (isalpha(c)) {\n                char base = isupper(c) ? 'A' : 'a';\n                result[i+j] = (c - base + 4) % 26 + base;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            char c = s[i+j];\n            if (isalpha(c)) {\n                char base = isupper(c) ? 'A' : 'a';\n                result[i+j] = (c - base + 4) % 26 + base;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n    size_t vl;\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vint8m1_t vs = vmv_v_x_i8m1(0, vl);\n        for(size_t j = 0; j < vl; ++j){\n            vs[j] = s[i+j];\n        }\n        vint8m1_t encrypted_chars = vs;\n        for (size_t j = 0; j < vl; ++j) {\n            char c = vs[j];\n            if (isalpha(c)) {\n                char base = isupper(c) ? 'A' : 'a';\n                encrypted_chars[j] = (char)(((c - base + 4) % 26) + base);\n            } else {\n                encrypted_chars[j] = c;\n            }\n        }\n        for(size_t j = 0; j < vl; ++j){\n            result[i+j] = encrypted_chars[j];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string encoded_message = message;\n    size_t length = message.length();\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        vint8m1_t src = vle8_v_i8m1(&encoded_message[i], vl);\n        vint8m1_t dest = src; \n\n        // Swap case\n        vbool8_t is_lower = vmseq_vx_i8m1(vand_vx_i8m1(src, 0xDF, vl), src, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1(vand_vx_i8m1(src, 0x5F, vl), src, vl);\n\n        vint8m1_t lower_to_upper = vsub_vx_i8m1(src, 32, vl);\n        vint8m1_t upper_to_lower = vadd_vx_i8m1(src, 32, vl);\n\n        dest = vsel_vm_i8m1(is_lower, lower_to_upper, dest, vl);\n        dest = vsel_vm_i8m1(is_upper, upper_to_lower, dest, vl);\n\n        // Replace vowels\n        vbool8_t is_a = vmseq_vx_i8m1(dest, 'A', vl);\n        vbool8_t is_e = vmseq_vx_i8m1(dest, 'E', vl);\n        vbool8_t is_i = vmseq_vx_i8m1(dest, 'I', vl);\n        vbool8_t is_o = vmseq_vx_i8m1(dest, 'O', vl);\n        vbool8_t is_u = vmseq_vx_i8m1(dest, 'U', vl);\n\n        vbool8_t is_vowel = vmor_mm(vmor_mm(is_a, is_e, vl), vmor_mm(is_i, vmor_mm(is_o, is_u, vl), vl), vl);\n\n        vint8m1_t replace_a = vmul_vx_i8m1(is_a, 'C', vl);\n        vint8m1_t replace_e = vmul_vx_i8m1(is_e, 'G', vl);\n        vint8m1_t replace_i = vmul_vx_i8m1(is_i, 'K', vl);\n        vint8m1_t replace_o = vmul_vx_i8m1(is_o, 'Q', vl);\n        vint8m1_t replace_u = vmul_vx_i8m1(is_u, 'W', vl);\n\n        dest = vsel_vm_i8m1(is_a, replace_a, dest, vl);\n        dest = vsel_vm_i8m1(is_e, replace_e, dest, vl);\n        dest = vsel_vm_i8m1(is_i, replace_i, dest, vl);\n        dest = vsel_vm_i8m1(is_o, replace_o, dest, vl);\n        dest = vsel_vm_i8m1(is_u, replace_u, dest, vl);\n\n        vse8_v_i8m1(&encoded_message[i], dest, vl);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string encoded_message = message;\n    size_t length = message.length();\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        vint8m1_t src = vle8_v_i8m1(&encoded_message[i], vl);\n        vint8m1_t dest = src; \n\n        // Swap case\n        vbool8_t is_lower = vmseq_vx_i8m1(vand_vx_i8m1(src, 0xDF, vl), src, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1(vand_vx_i8m1(src, 0xDF, vl), vsub_vx_i8m1(src, 32, vl), vl);\n        \n        dest = vselect_vmv_i8m1(is_lower, vsub_vx_i8m1(src, 32, vl), dest, vl);\n        dest = vselect_vmv_i8m1(is_upper, vadd_vx_i8m1(src, 32, vl), dest, vl);\n\n        // Replace vowels\n        vbool8_t is_a = vmseq_vx_i8m1(src, 'a', vl);\n        vbool8_t is_e = vmseq_vx_i8m1(src, 'e', vl);\n        vbool8_t is_i = vmseq_vx_i8m1(src, 'i', vl);\n        vbool8_t is_o = vmseq_vx_i8m1(src, 'o', vl);\n        vbool8_t is_u = vmseq_vx_i8m1(src, 'u', vl);\n        vbool8_t is_A = vmseq_vx_i8m1(src, 'A', vl);\n        vbool8_t is_E = vmseq_vx_i8m1(src, 'E', vl);\n        vbool8_t is_I = vmseq_vx_i8m1(src, 'I', vl);\n        vbool8_t is_O = vmseq_vx_i8m1(src, 'O', vl);\n        vbool8_t is_U = vmseq_vx_i8m1(src, 'U', vl);\n\n        dest = vselect_vmv_i8m1(is_a, 'c', dest, vl);\n        dest = vselect_vmv_i8m1(is_e, 'g', dest, vl);\n        dest = vselect_vmv_i8m1(is_i, 'k', dest, vl);\n        dest = vselect_vmv_i8m1(is_o, 'q', dest, vl);\n        dest = vselect_vmv_i8m1(is_u, 'w', dest, vl);\n        dest = vselect_vmv_i8m1(is_A, 'C', dest, vl);\n        dest = vselect_vmv_i8m1(is_E, 'G', dest, vl);\n        dest = vselect_vmv_i8m1(is_I, 'K', dest, vl);\n        dest = vselect_vmv_i8m1(is_O, 'Q', dest, vl);\n        dest = vselect_vmv_i8m1(is_U, 'W', dest, vl);\n\n        vse8_v_i8m1(&encoded_message[i], dest, vl);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    size_t len = message.length();\n\n    size_t vlmax = vsetvlmax_e8m1();\n    vint8m1_t vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vint8m1_t src = vle8_v_i8m1(&encoded_message[i], vl);\n        vint8m1_t dest = src;\n\n        for (size_t j = 0; j < vl; ++j) {\n            char c = encoded_message[i + j];\n            if (isalpha(c)) {\n                if (islower(c)) {\n                    dest[j] = toupper(c);\n                } else {\n                    dest[j] = tolower(c);\n                }\n            }\n        }\n\n        for (size_t j = 0; j < vl; ++j) {\n            char c = encoded_message[i + j];\n            switch (c) {\n                case 'a': dest[j] = 'c'; break;\n                case 'e': dest[j] = 'g'; break;\n                case 'i': dest[j] = 'k'; break;\n                case 'o': dest[j] = 'q'; break;\n                case 'u': dest[j] = 'w'; break;\n                case 'A': dest[j] = 'C'; break;\n                case 'E': dest[j] = 'G'; break;\n                case 'I': dest[j] = 'K'; break;\n                case 'O': dest[j] = 'Q'; break;\n                case 'U': dest[j] = 'W'; break;\n            }\n        }\n        \n        vse8_v_i8m1(&encoded_message[i], dest, vl);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string encoded_message = message;\n    size_t length = message.length();\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        vint8m1_t src = vle8_v_i8m1(&message[i], vl);\n        vint8m1_t dest = src; \n\n        // Swap case\n        vbool8_t is_lower = vmleq_vx_i8m1(src, 'z', vl) & vmgeq_vx_i8m1(src, 'a', vl);\n        vbool8_t is_upper = vmleq_vx_i8m1(src, 'Z', vl) & vmgeq_vx_i8m1(src, 'A', vl);\n\n        vint8m1_t lower_to_upper = vsub_vx_i8m1_m(is_lower, src, 32, vl);\n        vint8m1_t upper_to_lower = vadd_vx_i8m1_m(is_upper, src, 32, vl);\n\n        dest = vmerge_vvm_i8m1(is_lower, lower_to_upper, dest, vl);\n        dest = vmerge_vvm_i8m1(is_upper, upper_to_lower, dest, vl);\n\n        // Replace vowels\n        vbool8_t is_a = vmand_mm_e8m1(vmseq_vx_i8m1(dest, 'A', vl), vmseq_vx_i8m1(dest, 'a', vl), vl);\n        vbool8_t is_e = vmand_mm_e8m1(vmseq_vx_i8m1(dest, 'E', vl), vmseq_vx_i8m1(dest, 'e', vl), vl);\n        vbool8_t is_i = vmand_mm_e8m1(vmseq_vx_i8m1(dest, 'I', vl), vmseq_vx_i8m1(dest, 'i', vl), vl);\n        vbool8_t is_o = vmand_mm_e8m1(vmseq_vx_i8m1(dest, 'O', vl), vmseq_vx_i8m1(dest, 'o', vl), vl);\n        vbool8_t is_u = vmand_mm_e8m1(vmseq_vx_i8m1(dest, 'U', vl), vmseq_vx_i8m1(dest, 'u', vl), vl);\n\n        dest = vmerge_vxm_i8m1(is_a, vadd_vx_i8m1_m(is_a, dest, 2, vl), dest, vl);\n        dest = vmerge_vxm_i8m1(is_e, vadd_vx_i8m1_m(is_e, dest, 2, vl), dest, vl);\n        dest = vmerge_vxm_i8m1(is_i, vadd_vx_i8m1_m(is_i, dest, 2, vl), dest, vl);\n        dest = vmerge_vxm_i8m1(is_o, vadd_vx_i8m1_m(is_o, dest, 2, vl), dest, vl);\n        dest = vmerge_vxm_i8m1(is_u, vadd_vx_i8m1_m(is_u, dest, 2, vl), dest, vl);\n\n        vse8_v_i8m1(&encoded_message[i], dest, vl);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string encoded_message = message;\n    size_t length = message.length();\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        vint8m1_t src = vle8_v_i8m1(&encoded_message[i], vl);\n        vint8m1_t dest = src;\n        \n        // Swap case\n        vbool8_t is_lower = vmseq_vx_i8m1(vand_vx_i8m1(src, 0xDF, vl), src, vl);\n        vbool8_t is_upper = vmseq_vx_i8m1(vand_vx_i8m1(src, 0x5F, vl), src, vl);\n        \n        vint8m1_t lower_to_upper = vsub_vx_i8m1(src, 32, vl);\n        vint8m1_t upper_to_lower = vadd_vx_i8m1(src, 32, vl);\n        \n        dest = vmerge_vvm_i8m1(dest, lower_to_upper, is_lower, vl);\n        dest = vmerge_vvm_i8m1(dest, upper_to_lower, is_upper, vl);\n\n        // Replace vowels\n        const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        const char replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n\n        for (int j = 0; j < 10; ++j) {\n            vbool8_t is_vowel = vmseq_vx_i8m1(dest, vowels[j], vl);\n            dest = vmerge_vxm_i8m1(dest, replacements[j], is_vowel, vl);\n        }\n\n        vse8_v_i8m1(&encoded_message[i], dest, vl);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    size_t len = key.length();\n\n    if (len == 0) continue;\n\n    size_t vl = vsetvl_e8m1(len);\n    vbool64_t lower_mask = vmf_m_b64(true, vl);\n    vbool64_t upper_mask = vmf_m_b64(true, vl);\n\n    for (size_t i = 0; i < len; i += vl) {\n      vl = vsetvl_e8m1(len - i);\n      vint8m1_t chars = vmv_v_x_i8m1(0, vl);\n\n      for (size_t j = 0; j < vl; ++j) {\n        chars[j] = key[i + j];\n      }\n      \n      vbool64_t is_lower = vmseq_vx_i8m1_b64(chars, 0, vl);\n      vbool64_t is_upper = vmseq_vx_i8m1_b64(chars, 0, vl);\n\n      for (size_t j = 0; j < vl; ++j) {\n          if (std::islower(key[i+j])) {\n              is_lower[j] = true;\n          } else {\n              is_lower[j] = false;\n          }\n\n          if (std::isupper(key[i+j])) {\n              is_upper[j] = true;\n          } else {\n              is_upper[j] = false;\n          }\n      }\n\n      lower_mask = vand_mm_b64(lower_mask, is_lower, vl);\n      upper_mask = vand_mm_b64(upper_mask, is_upper, vl);\n    }\n\n    if (!vtest_mm_e64(lower_mask, vmf_m_b64(true, len))) {\n      all_lower = false;\n    }\n    if (!vtest_mm_e64(upper_mask, vmf_m_b64(true, len))) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <algorithm>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    size_t len = key.length();\n\n    if (len == 0) continue;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (char c : key) {\n      if (!std::islower(c)) {\n        key_all_lower = false;\n      }\n      if (!std::isupper(c)) {\n        key_all_upper = false;\n      }\n    }\n\n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    size_t len = key.length();\n\n    if (len == 0) continue;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (size_t i = 0; i < len; ++i) {\n      if (!islower(key[i])) {\n        key_all_lower = false;\n      }\n      if (!isupper(key[i])) {\n        key_all_upper = false;\n      }\n    }\n\n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    size_t len = key.length();\n\n    if (len == 0) continue;\n\n    size_t vl = vsetvl_e8m1(len);\n    vbool64_t lower_mask = vmf_m_b64(true, vl);\n    vbool64_t upper_mask = vmf_m_b64(true, vl);\n\n    for (size_t i = 0; i < len; i += vl) {\n      vl = vsetvl_e8m1(len - i);\n      vint8m1_t chars = vmv_v_i8m1(key[i], vl);\n      for (size_t j = 0; j < vl; ++j) {\n        chars[j] = key[i+j];\n      }\n\n      vbool64_t is_lower = vmseq_vx_i8m1_b64(chars, 0, vl);\n      vbool64_t is_upper = vmseq_vx_i8m1_b64(chars, 0, vl);\n      \n      for (size_t j = 0; j < vl; ++j) {\n        if (std::islower(key[i+j])) {\n            is_lower[j] = true;\n        } else {\n            is_lower[j] = false;\n        }\n        if (std::isupper(key[i+j])) {\n            is_upper[j] = true;\n        } else {\n            is_upper[j] = false;\n        }\n      }\n\n      lower_mask = vand_mm_b64(lower_mask, is_lower, vl);\n      upper_mask = vand_mm_b64(upper_mask, is_upper, vl);\n    }\n\n    if (!vtest_mm_e64(lower_mask, true)) {\n      all_lower = false;\n    }\n    if (!vtest_mm_e64(upper_mask, true)) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    size_t len = key.length();\n\n    if (len == 0) continue;\n\n    size_t vl = vsetvl_e8m1(len);\n    vbool64_t lower_mask = vmf_m_b64(true, vl);\n    vbool64_t upper_mask = vmf_m_b64(true, vl);\n\n    for (size_t i = 0; i < len; i += vl) {\n      vl = vsetvl_e8m1(len - i);\n      vint8m1_t chars = vmv_v_i8m1(key[i], vl);\n      for (size_t j = 0; j < vl; ++j) {\n        chars[j] = key[i+j];\n      }\n      \n      vbool64_t is_lower = vmseq_vx_i8m1_b64(chars, 0, vl);\n      vbool64_t is_upper = vmseq_vx_i8m1_b64(chars, 0, vl);\n      \n      for (size_t j = 0; j < vl; ++j) {\n        if (std::islower(key[i+j])) {\n          is_lower[j] = true;\n        } else {\n          is_lower[j] = false;\n        }\n        if (std::isupper(key[i+j])) {\n          is_upper[j] = true;\n        } else {\n          is_upper[j] = false;\n        }\n      }\n\n      lower_mask = vand_mm_b64(lower_mask, is_lower, vl);\n      upper_mask = vand_mm_b64(upper_mask, is_upper, vl);\n    }\n    \n    bool key_all_lower = true;\n    bool key_all_upper = true;\n    for (size_t i = 0; i < len; ++i) {\n      if (!std::islower(key[i])) {\n        key_all_lower = false;\n      }\n      if (!std::isupper(key[i])) {\n        key_all_upper = false;\n      }\n    }\n\n    all_lower &= key_all_lower;\n    all_upper &= key_all_upper;\n\n    if (!key_all_lower && !key_all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = 2 * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    size_t n = s.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; i += vlenb() ) {\n        size_t vl = vmin(vlenb(), n - i);\n        vint8m1_t vs = vle8_v_i8m1(&s[i], vl);\n        \n        vbool8_t upper = vmseq_vx_i8m1(vand_vx_i8m1(vs, 0xDF, vl), vs, vl);\n        \n        vbool8_t is_A = vmseq_vx_i8m1(vs, 'A', vl);\n        vbool8_t is_E = vmseq_vx_i8m1(vs, 'E', vl);\n        vbool8_t is_I = vmseq_vx_i8m1(vs, 'I', vl);\n        vbool8_t is_O = vmseq_vx_i8m1(vs, 'O', vl);\n        vbool8_t is_U = vmseq_vx_i8m1(vs, 'U', vl);\n\n        vbool8_t is_vowel = vmor_mm(vmor_mm(is_A, is_E, vl), vmor_mm(is_I, vmor_mm(is_O, is_U, vl), vl), vl);\n        vbool8_t upper_vowel = vand_mm(upper, is_vowel, vl);\n        \n        for(size_t j = 0; j < vl; ++j){\n            if((i+j) % 2 == 0 && vget_v_i1m1(upper_vowel, j)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    size_t n = s.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; i += vlen_char) {\n        size_t vl = vmin_zu(vlen_char, n - i);\n        vbool64_t mask = vmsif_m_b64(false, vl);\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) % 2 == 0){\n                mask = vbool_insert_value(mask, j, true);\n            } else {\n                mask = vbool_insert_value(mask, j, false);\n            }\n        }\n\n        vint8m1_t vs = vle8_v_i8m1(s.data() + i, vl);\n        vbool64_t upper_vowel = vmseq_vx_i8m1_b64(vs, 'A', vl);\n        upper_vowel = vor_mm_b64(upper_vowel, vmseq_vx_i8m1_b64(vs, 'E', vl), vl);\n        upper_vowel = vor_mm_b64(upper_vowel, vmseq_vx_i8m1_b64(vs, 'I', vl), vl);\n        upper_vowel = vor_mm_b64(upper_vowel, vmseq_vx_i8m1_b64(vs, 'O', vl), vl);\n        upper_vowel = vor_mm_b64(upper_vowel, vmseq_vx_i8m1_b64(vs, 'U', vl), vl);\n\n        upper_vowel = vand_mm_b64(upper_vowel, mask, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (vbool_extract_value(upper_vowel, j)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    size_t n = s.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    size_t n = s.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; i += vlen_char) {\n        size_t vl = vmin_zu(vlen_char, n - i);\n        vbool64_t mask = vmsif_m_b64(false, vl);\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) % 2 == 0){\n                mask = vbool_viu_m_b64(mask, j, true);\n            }\n        }\n\n        vint8m1_t vs = vle8_v_i8m1(s.data() + i, vl);\n        vbool64_t upper_vowels = vmseq_vx_i8m1_b64(vs, 'A', vl);\n        upper_vowels = vor_mm_b64(upper_vowels, vmseq_vx_i8m1_b64(vs, 'E', vl), vl);\n        upper_vowels = vor_mm_b64(upper_vowels, vmseq_vx_i8m1_b64(vs, 'I', vl), vl);\n        upper_vowels = vor_mm_b64(upper_vowels, vmseq_vx_i8m1_b64(vs, 'O', vl), vl);\n        upper_vowels = vor_mm_b64(upper_vowels, vmseq_vx_i8m1_b64(vs, 'U', vl), vl);\n\n        upper_vowels = vand_mm_b64(upper_vowels, mask, vl);\n\n        count += vpopc_m_b64(upper_vowels, upper_vowels, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    size_t n = s.length();\n    int count = 0;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    result[0] = start;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    for (int i = 1; i < n; ++i) {\n        start += increment;\n        result[i] = start;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int start = n;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    vint32m1_t v_start = vmv_s_x_i32m1(start, 1);\n    vint32m1_t v_increment = vmv_s_x_i32m1(increment, 1);\n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t v_index = vid_v_i32m1(vl);\n    vint32m1_t v_incr_mul = vmul_vx_i32m1(v_index, v_increment, vl);\n    vint32m1_t v_result = vadd_vv_i32m1(v_start, v_incr_mul, vl);\n\n    for (int i = 0; i < n; ++i) {\n        result[i] = vget_i32m1(v_result, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    result[0] = start;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    for (int i = 1; i < n; ++i) {\n        start += increment;\n        result[i] = start;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    result[0] = start;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    for (int i = 1; i < n; ++i) {\n        start += increment;\n        result[i] = start;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    result[0] = start;\n    int increment = (n % 2 == 0) ? 2 : 2;\n\n    for (int i = 1; i < n; ++i) {\n        start += increment;\n        result[i] = start;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    size_t vl = vsetvl_e64m8_i64(8);\n    int64_t vec_n[8];\n    int64_t vec_m[8];\n    for(int i = 0; i < 8; i++){\n        vec_n[i] = n;\n        vec_m[i] = m;\n    }\n    vint64m8_t vn = vle64_v_i64m8(vec_n, vl);\n    vint64m8_t vm = vle64_v_i64m8(vec_m, vl);\n    \n    int64_t total_elements = m - n + 1;\n    sum = (n + m) * total_elements / 2;\n    \n    int64_t avg = sum / total_elements;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    size_t vl = vsetvl_e64m8(1);\n    vint64m8_t vn = vmv_v_x_i64m8(n, vl);\n    vint64m8_t vm = vmv_v_x_i64m8(m, vl);\n\n    int64_t num_elements = m - n + 1;\n    sum = (n + m) * num_elements / 2;\n    if (((n + m) % 2 != 0) && (num_elements % 2 != 0))\n    {\n        sum++;\n    }\n\n    int64_t avg = sum / num_elements;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    size_t vl = vsetvl_e64m8(count);\n    vint64m8_t vn = vmv_s_x_i64m8(n, vl);\n    vint64m8_t vindex = vid_v_i64m8(vl);\n    vint64m8_t vdata = vadd_vv_i64m8(vn, vindex, vl);\n\n    int64_t temp_sum = 0;\n    for (size_t i = 0; i < count; ++i) {\n        temp_sum += vget_i64m8(vdata, i);\n    }\n\n    sum = temp_sum;\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    size_t vl = vsetvl_e64m8(8);\n    vint64m8_t vn = vmv_v_x_i64m8(n, vl);\n    vint64m8_t vm = vmv_v_x_i64m8(m, vl);\n    vint64m8_t vstep = vmv_v_x_i64m8(1, vl);\n    vint64m8_t vcurrent = vn;\n    vint64m8_t vsum = vmv_v_x_i64m8(0, vl);\n\n    while(true){\n        vbool8_t mask = vmseq_vx_i64m8_b8(vcurrent, vm, vl);\n        vint64m8_t vtemp_sum = vadd_vv_i64m8(vsum, vcurrent, vl);\n        vsum = vmerge_vvm_i64m8(vtemp_sum, vsum, mask, vl);\n        int64_t scalar_sum = 0;\n        for(int i = 0; i < vl; ++i){\n            if(i == 0){\n                scalar_sum = vsum[i];\n            }\n        }\n        sum += scalar_sum;\n        if(n == m){\n            sum = n;\n            break;\n        }\n        if(n < m){\n            int64_t count = m - n + 1;\n            sum = (n + m) * count / 2;\n            break;\n        }\n    }\n    \n    int64_t avg = (n + m) / 2;\n    if ((n + m) % 2 != 0) {\n        \n    }\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    size_t vl = vsetvl_e64m8(count);\n    vint64m8_t vn = vmv_s_x_i64m8(n, vl);\n    vint64m8_t vindex = vid_v_i64m8(vl);\n    vint64m8_t vdata = vadd_vv_i64m8(vn, vindex, vl);\n\n    for (size_t i = 0; i < count; ++i) {\n        sum += vget_i64m8(vdata, i);\n    }\n    \n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    size_t vl = vsetvl_max_e32m1();\n    std::vector<int32_t> temp_even(vl);\n    std::vector<int32_t> temp_odd(vl);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    size_t vl = vsetvl_max_e32m1();\n    std::vector<int32_t> temp_even(vl);\n    std::vector<int32_t> temp_odd(vl);\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t index = vid_v_i32m1(0, vl);\n    vint32m1_t base = vaddi_vx_i32m1(index, 1, vl);\n\n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= (i + 1); ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = vsetvl_max_e32m1();\n    \n    std::vector<int32_t> even_indices;\n    std::vector<int32_t> odd_indices;\n    \n    for (int i = 0; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            even_indices.push_back(i);\n        } else {\n            odd_indices.push_back(i);\n        }\n    }\n\n    // Process even indices (factorial modulo 10000)\n    size_t num_even = even_indices.size();\n    for (size_t i = 0; i < num_even; i += vl) {\n        size_t current_vl = std::min(vl, num_even - i);\n        vint32m1_t index_vec = vmv_v_x_i32m1(0, current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            index_vec[j] = even_indices[i+j] + 1;\n        }\n\n        std::vector<int32_t> factorial_vec_data(current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            int factorial = 1;\n            for(int k = 1; k <= index_vec[j]; ++k){\n                factorial = (factorial * k) % 10000;\n            }\n            factorial_vec_data[j] = factorial;\n        }\n        \n        vint32m1_t factorial_vec = vmv_v_x_i32m1(0, current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            factorial_vec[j] = factorial_vec_data[j];\n        }\n\n        for(size_t j = 0; j < current_vl; ++j){\n            result[even_indices[i+j]] = factorial_vec[j];\n        }\n    }\n\n    // Process odd indices (sum of numbers from 1 to i)\n    size_t num_odd = odd_indices.size();\n    for (size_t i = 0; i < num_odd; i += vl) {\n        size_t current_vl = std::min(vl, num_odd - i);\n        vint32m1_t index_vec = vmv_v_x_i32m1(0, current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            index_vec[j] = odd_indices[i+j] + 1;\n        }\n\n        std::vector<int32_t> sum_vec_data(current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            int sum = 0;\n            for(int k = 1; k <= index_vec[j]; ++k){\n                sum += k;\n            }\n            sum_vec_data[j] = sum;\n        }\n        \n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, current_vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            sum_vec[j] = sum_vec_data[j];\n        }\n\n        for(size_t j = 0; j < current_vl; ++j){\n            result[odd_indices[i+j]] = sum_vec[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    size_t vl = vsetvl_max_e32m1();\n    int32_t factorial_mod = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            factorial_mod = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial_mod = (factorial_mod * j) % 10000;\n            }\n            result[i - 1] = factorial_mod;\n        } else {\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n\n        if (s == reversed_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n\n        if (s == reversed_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n  size_t vl;\n  int count = 0;\n  size_t size = n.size();\n  size_t i = 0;\n\n  while (size > 0) {\n    vl = vsetvl_e32m1(size);\n    std::vector<int32_t> sub_vector(n.begin() + i, n.begin() + i + vl);\n    int32_t *input_ptr = sub_vector.data();\n    vint32m1_t vec_nums = vle32_v_i32m1(input_ptr, vl);\n    \n    for (int j = 0; j < vl; ++j) {\n        int num = sub_vector[j];\n        int sum = 0;\n        int temp = num;\n        \n        if (temp < 0) {\n            sum += temp % 10;\n            temp /= 10;\n            temp = -temp;\n            while (temp > 0) {\n                sum += temp % 10;\n                temp /= 10;\n            }\n        } else {\n            while (temp > 0) {\n                sum += temp % 10;\n                temp /= 10;\n            }\n        }\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    size -= vl;\n    i += vl;\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vl;\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    while (size > 0) {\n        vl = vsetvl_e32m8_max_len(size);\n        vint32m8_t vec_n = vle32_v_i32m8(&n[i], vl);\n        \n        vint32m8_t sum_digits = vmv_v_i32m8_i32(0, vl);\n        vint32m8_t abs_vec_n = vabs_v_i32m8(vec_n, vl);\n\n        vint32m8_t temp_n = abs_vec_n;\n        while(true){\n            vint32m8_t digits = vmod_vx_i32m8(temp_n, 10, vl);\n            sum_digits = vadd_vv_i32m8(sum_digits, digits, vl);\n            temp_n = vdiv_vx_i32m8(temp_n, 10, vl);\n            if(vtest_zero_mask(vmsne_vx_i32m8_b1(temp_n, 0, vl), vl)){\n                break;\n            }\n        }\n\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec_n, abs_vec_n, vl);\n        vint32m8_t neg_digits = vsub_vx_i32m8(vmv_v_i32m8_i32(0, vl), vdiv_vx_i32m8(abs_vec_n, (int32_t)pow(10, (int)log10(abs(n[i]))), vl), vl);\n        sum_digits = vmerge_vvm_i32m8(sum_digits, neg_digits, mask, vl);\n\n        vbool4_t positive_sum = vmgt_vx_i32m8_b4(sum_digits, 0, vl);\n        size_t num_positive = vpopc_m_b4(positive_sum, vl);\n        count += num_positive;\n\n        i += vl;\n        size -= vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vl;\n    int count = 0;\n    size_t num_elements = n.size();\n    size_t current_index = 0;\n\n    while (current_index < num_elements) {\n        vl = vsetvl_e32m8(num_elements - current_index);\n        vint32m8_t vec_n = vle32_v_i32m8(&n[current_index], vl);\n        \n        int32_t sum_digits[vl];\n        for (size_t i = 0; i < vl; ++i) {\n            int num = n[current_index + i];\n            int sum = 0;\n            int sign = 1;\n            if (num < 0) {\n                sign = -1;\n                num = -num;\n            }\n            \n            if (num == 0) {\n                sum = 0;\n            } else {\n                bool first_digit = true;\n                while (num > 0) {\n                    int digit = num % 10;\n                    num /= 10;\n                    if (first_digit && sign == -1) {\n                        sum += -digit;\n                        first_digit = false;\n                    } else {\n                        sum += digit;\n                    }\n                }\n            }\n            sum_digits[i] = sum;\n        }\n\n        vint32m8_t vec_sum = vle32_v_i32m8(sum_digits, vl);\n        vbool4_t mask = vmseqz_i32m8_b4(vec_sum, vl);\n\n        size_t count_local = 0;\n        for (size_t i = 0; i < vl; ++i) {\n            if (!vget_v_i1(mask, i)) {\n                count_local++;\n            }\n        }\n\n        count += count_local;\n        current_index += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vl;\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    while (size > 0) {\n        vl = vsetvl_e32m8_max_len(size);\n        vint32m8_t vec_n = vle32_v_i32m8(&n[i], vl);\n        \n        vint32m8_t sum_digits = vmv_v_i32m8_i32(0, vl);\n        vint32m8_t abs_n = vabs_v_i32m8(vec_n, vl);\n\n        vint32m8_t temp_n = abs_n;\n        while(true){\n            vint32m8_t digit = vdiv_vx_i32m8(temp_n, 10, vl);\n            digit = vmul_vx_i32m8(digit, 10, vl);\n            digit = vsub_vv_i32m8(temp_n, digit, vl);\n            sum_digits = vadd_vv_i32m8(sum_digits, digit, vl);\n            temp_n = vdiv_vx_i32m8(temp_n, 10, vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(temp_n, 0, vl);\n            if(vtest_any_mask(mask, vl)){\n                break;\n            }\n        }\n        \n        vbool4_t mask = vmfgt_vx_i32m8_b4(sum_digits, 0, vl);\n        size_t num_true = vpopc_m_b4(mask, vl);\n        count += num_true;\n\n        i += vl;\n        size -= vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vl;\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    while (size > 0) {\n        vl = vsetvl_e32m1(size);\n        \n        std::vector<int32_t> sub_vector(n.begin() + i, n.begin() + i + vl);\n        int32_t* data = sub_vector.data();\n        vint32m1_t vec_nums = vle32_v_i32m1(data, vl);\n\n        for (int j = 0; j < vl; ++j) {\n            int num = data[j];\n            int sum = 0;\n            int temp = num;\n\n            while (temp != 0) {\n                sum += temp % 10;\n                temp /= 10;\n            }\n            if (num < 0) {\n                temp = num;\n                int first_digit = 0;\n                while (temp <= -10) {\n                    temp /= 10;\n                }\n                sum = 0;\n                temp = num;\n                int sign = 1;\n                while (temp != 0) {\n                    sum += (temp % 10) * sign;\n                    temp /= 10;\n                    if (temp < 0 && sign == 1) {\n                        sign = -1;\n                    } else if (temp > 0 && sign == -1) {\n                        sign = 1;\n                    }\n                }\n            }\n\n            if (sum > 0) {\n                count++;\n            }\n        }\n\n        i += vl;\n        size -= vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n\n  size_t n = arr.size();\n  for (size_t shift = 0; shift < n; ++shift) {\n    std::vector<int> shifted_arr(n);\n    for (size_t i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n\n    bool sorted = true;\n    for (size_t i = 1; i < n; ++i) {\n      if (shifted_arr[i] < shifted_arr[i - 1]) {\n        sorted = false;\n        break;\n      }\n    }\n\n    if (sorted) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n\n  size_t n = arr.size();\n  for (size_t shift = 0; shift < n; ++shift) {\n    std::vector<int> shifted_arr(n);\n    for (size_t i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n\n    bool sorted = true;\n    for (size_t i = 1; i < n; ++i) {\n      if (shifted_arr[i] < shifted_arr[i - 1]) {\n        sorted = false;\n        break;\n      }\n    }\n\n    if (sorted) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n\n  size_t n = arr.size();\n  for (size_t shift = 0; shift < n; ++shift) {\n    std::vector<int> shifted_arr(n);\n    for (size_t i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n\n    bool sorted = true;\n    for (size_t i = 1; i < n; ++i) {\n      if (shifted_arr[i] < shifted_arr[i - 1]) {\n        sorted = false;\n        break;\n      }\n    }\n\n    if (sorted) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n  if (arr.empty()) {\n    return true;\n  }\n\n  size_t n = arr.size();\n  for (size_t shift = 0; shift < n; ++shift) {\n    std::vector<int> shifted_arr(n);\n    for (size_t i = 0; i < n; ++i) {\n      shifted_arr[i] = arr[(i - shift + n) % n];\n    }\n\n    bool sorted = true;\n    for (size_t i = 1; i < n; ++i) {\n      if (shifted_arr[i] < shifted_arr[i - 1]) {\n        sorted = false;\n        break;\n      }\n    }\n\n    if (sorted) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    int odd_count_lst1 = 0;\n    for (size_t i = 0; i < n1; ++i) {\n        if (lst1[i] % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    for (size_t i = 0; i < n2; ++i) {\n        if (lst2[i] % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    size_t odd_count1 = 0;\n    size_t odd_count2 = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m1(n1 - i);\n        vint32m1_t v = vle32_v_i32m1(&lst1[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 1, vl);\n        odd_count1 += vpopc_m_b32(mask, vl);\n    }\n\n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m1(n2 - i);\n        vint32m1_t v = vle32_v_i32m1(&lst2[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 1, vl);\n        odd_count2 += vpopc_m_b32(mask, vl);\n    }\n\n    if (odd_count1 <= odd_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    size_t odd_count1 = 0;\n    size_t odd_count2 = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m1(n1 - i);\n        vint32m1_t v = vle32_v_i32m1(&lst1[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 1, vl);\n        odd_count1 += vpopc_m_b32(mask, vl);\n    }\n\n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m1(n2 - i);\n        vint32m1_t v = vle32_v_i32m1(&lst2[i], vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 1, vl);\n        odd_count2 += vpopc_m_b32(mask, vl);\n    }\n\n    if (odd_count1 <= odd_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    int odd_count_lst1 = 0;\n    for (size_t i = 0; i < n1; ++i) {\n        if (lst1[i] % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    for (size_t i = 0; i < n2; ++i) {\n        if (lst2[i] % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t odd_count1 = 0;\n    size_t odd_count2 = 0;\n\n    size_t vl = vsetvl_e32m1(n1);\n    std::vector<int32_t> temp_lst1(lst1.begin(), lst1.end());\n    const int32_t *data1 = temp_lst1.data();\n    \n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m1(n1 - i);\n        vint32m1_t v = vle32_v_i32m1(data1 + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 0, vl);\n        size_t count = vpopc_m_b32(mask, vl);\n        odd_count1 += (vl - count);\n    }\n\n    vl = vsetvl_e32m1(n2);\n    std::vector<int32_t> temp_lst2(lst2.begin(), lst2.end());\n    const int32_t *data2 = temp_lst2.data();\n\n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m1(n2 - i);\n        vint32m1_t v = vle32_v_i32m1(data2 + i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 0, vl);\n        size_t count = vpopc_m_b32(mask, vl);\n        odd_count2 += (vl - count);\n    }\n    \n    if (odd_count1 <= n2 - (n2 - odd_count2)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t vl = vsetvl_e8m1(len);\n        \n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vint8m1_t v = vle8_v_i8m1(str.data() + i, vl);\n            vbool8_t mask = vmseq_vx_i8m1_b8(v & 1, 1, vl);\n            odd_count += vpopc_m_b8(mask, mask, vl);\n        }\n        \n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t vl = vsetvl_e8m1(len);\n        \n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vint8m1_t v = vle8_v_i8m1(str.data() + i, vl);\n            vbool8_t mask = vmseq_vx_i8m1_b8(v & 1, 1, vl);\n            odd_count += vpopc_m_b8(mask, mask, vl);\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t vl = vsetvl_e8m1(len);\n        \n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vint8m1_t v = vle8_v_i8m1(str.data() + i, vl);\n            vint8m1_t v_and = vand_vx_i8m1(v, 1, vl);\n            \n            size_t count = 0;\n            for (size_t j = 0; j < vl; ++j) {\n                if (v_and[j] == 1 && (str[i+j] - '0') % 2 != 0) {\n                    count++;\n                }\n            }\n            odd_count += count;\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t vl = vsetvl_e8m1(len);\n        \n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vint8m1_t v = vle8_v_i8m1(str.data() + i, vl);\n            vint8m1_t v_and = vand_vx_i8m1(v, 1, vl);\n            \n            size_t count = 0;\n            for(int j = 0; j < vl; ++j){\n                if( (str[i+j] - '0') % 2 != 0){\n                    count++;\n                }\n            }\n            odd_count += count;\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t vl = vsetvl_e8m1(len);\n        \n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vint8m1_t v = vle8_v_i8m1(str.data() + i, vl);\n            vbool8_t mask = vmseq_vx_i8m1_b8(v & 1, 1, vl);\n            odd_count += vpopc_m_b8(mask, mask, vl);\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vl = vsetvl_max_e64m1();\n    for (size_t i = 0; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vl = vsetvl_max_e64m1();\n    for (size_t i = 0; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (current_min < min_so_far) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int count = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int water_in_well = 0;\n        for (int j = 0; j < cols; ++j) {\n            water_in_well += grid[i][j];\n        }\n        count += (water_in_well + capacity - 1) / capacity;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_ops = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int current_row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            current_row_sum += grid[i][j];\n        }\n        total_ops += (current_row_sum + capacity - 1) / capacity;\n    }\n\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_ops = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int current_row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            current_row_sum += grid[i][j];\n        }\n        total_ops += (current_row_sum + capacity - 1) / capacity;\n    }\n\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_ops = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int current_row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            current_row_sum += grid[i][j];\n        }\n        total_ops += (current_row_sum + capacity - 1) / capacity;\n    }\n\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_ops = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int current_row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            current_row_sum += grid[i][j];\n        }\n        total_ops += (current_row_sum + capacity - 1) / capacity;\n    }\n\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m8(n - i);\n        vint16m8_t v = vle16_v_i16m8(&lst[i], vl);\n        vbool2_t mask = vmseq_vx_i16m8_b2(vrem_vx_i16m8(v, 2, vl), 0, vl);\n        \n        std::vector<int16_t> temp(vl);\n        vse16_v_i16m8(temp.data(), v, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) % 2 == 0 && temp[j] % 2 != 0){\n                sum += temp[j];\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m8(n - i);\n        vint16m8_t v = vle16_v_i16m8(&lst[i], vl);\n        vbool2_t mask = vmseq_vx_i16m8_b2(vrem_vx_i16m8(v, 2, vl), 0, vl);\n        \n        std::vector<int16_t> temp(vl);\n        vse16_v_i16m8(temp.data(), v, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) % 2 == 0 && temp[j] % 2 != 0){\n                sum += temp[j];\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m8(n - i);\n        vint16m8_t v = vle16_v_i16m8(&lst[i], vl);\n        vbool2_t mask = vmseq_vx_i16m8_b2(vrem_vx_i16m8(v, 2, vl), 0, vl);\n        \n        std::vector<int16_t> temp(vl);\n        vse16_v_i16m8(temp.data(), v, vl);\n\n        for(size_t j = 0; j < vl; j++){\n            if((i+j) % 2 == 0 && temp[j] % 2 != 0){\n                sum += temp[j];\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n  size_t n = lst.size();\n  int64_t sum = 0;\n\n  for (size_t i = 0; i < n; i += vlmax_e16m1()) {\n    size_t vl = std::min(vlmax_e16m1(), n - i);\n    vint16m1_t v = vle16_v_i16m1(&lst[i], vl);\n    vbool16_t mask = vmv_v_b_i16m1(v, vl); \n\n    for(size_t j = 0; j < vl; ++j){\n      if((i+j) % 2 == 0 && lst[i+j] % 2 != 0){\n        sum += lst[i+j];\n      }\n    }\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m8(n - i);\n        vint16m8_t v = vle16_v_i16m8(&lst[i], vl);\n\n        // Create a mask for even positions\n        vbool2_t even_mask = vmsif_m_b2(i % 2, vl);\n\n        // Create a mask for odd elements\n        vbool2_t odd_mask = vmseq_vx_i16m8_b2(vandi_vx_i16m8(v, 1, vl), 1, vl);\n\n        // Combine the masks\n        vbool2_t combined_mask = vand_mm_b2(even_mask, odd_mask, vl);\n\n        // Use the mask to select the elements to sum\n        vint16m8_t masked_v = vmul_vx_i16m8_m(combined_mask, v, 1, vl);\n\n        // Sum the elements\n        int16_t temp_sum[8];\n        vse16_v_i16m8(temp_sum, masked_v, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            sum += temp_sum[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n        vint32m8_t v = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmleq_vx_i32m8_b4(v, 99, vl);\n        vint32m8_t masked_v = vmand_vx_i32m8(v, 0, mask, vl);\n        int32_t temp_sum = vreduce_add_vs_i32m8_i32m1(0, masked_v, vl);\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < k; i += vl) {\n        vl = vsetvl_e32m4(k - i);\n        vint32m4_t v = vle32_v_i32m4(&arr[i], vl);\n        vbool8_t mask = vmleq_vx_i32m4_b8(v, 99, vl);\n        vint32m4_t masked_v = vmul_mask_i32m4(mask, v, v, vl);\n        sum += vreduce_add_vs_i32m4_i32m1(sum, masked_v, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n        vint32m8_t v = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmleq_vx_i32m8_b4(v, 99, vl);\n        vint32m8_t masked_v = vmand_vx_i32m8(v, 0, mask, vl);\n        int32_t temp_sum = 0;\n        for (int j = 0; j < vl; ++j) {\n            temp_sum += vget_v_i32m8(masked_v, j);\n        }\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n        vint32m8_t v = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmleq_vx_i32m8_b4(v, 99, vl);\n        vint32m8_t masked_v = vmand_vx_i32m8(v, 0, mask, vl);\n        sum += vreduce_add_vs_i32m8_i32m1(sum, masked_v, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n        vint32m8_t v = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmleq_vx_i32m8_b4(v, 99, vl);\n        vint32m8_t masked_v = vmand_vx_i32m8(v, 0, mask, vl);\n        int32_t temp_sum = vreduce_add_vs_i32m8_i32m1(0, masked_v, vl);\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  size_t n = lst.size();\n  if (n <= 1) {\n    return true;\n  }\n\n  size_t vl = vsetvl_max_e32m1();\n  \n  for (size_t i = 0; i < n - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n\n  std::vector<int> counts(10000, 0); \n  for (int x : lst) {\n    counts[x]++;\n    if (counts[x] > 1)\n    {\n        int count = 0;\n        for(int y : lst)\n        {\n            if(x == y)\n            {\n                count++;\n            }\n        }\n        if(count > 2)\n        {\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  size_t n = lst.size();\n  if (n <= 1) {\n    return true;\n  }\n\n  size_t vl = vsetvl_max_e32m1();\n  \n  for (size_t i = 0; i < n - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n\n  std::vector<int> counts(10000, 0);\n  for (int x : lst) {\n    counts[x]++;\n    if (counts[x] > 1)\n    {\n        int count = 0;\n        for(int y : lst)\n        {\n            if(y == x)\n            {\n                count++;\n            }\n        }\n        if(count > 2)\n        {\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  size_t n = lst.size();\n  if (n <= 1) {\n    return true;\n  }\n\n  size_t vl = vsetvl_max_e32m1();\n  std::vector<int32_t> prev_vec(vl);\n  std::vector<int32_t> curr_vec(vl);\n  \n  bool sorted = true;\n  size_t i = 0;\n\n  // Initialize the first element\n  prev_vec[0] = lst[0];\n\n  for (i = 1; i < n;) {\n    vl = vsetvl_e32m1(n - i);\n\n    for (size_t j = 0; j < vl; ++j) {\n      curr_vec[j] = lst[i + j];\n    }\n    \n    for (size_t j = 0; j < vl; ++j) {\n      if (curr_vec[j] < prev_vec[0]) {\n        return false;\n      }\n      if (j > 0 && curr_vec[j] < curr_vec[j-1]) {\n          return false;\n      }\n    }\n    \n    prev_vec[0] = curr_vec[vl - 1];\n    i += vl;\n  }\n\n  return sorted;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  size_t n = lst.size();\n  if (n <= 1) {\n    return true;\n  }\n\n  size_t vl = vsetvl_max_e32m1();\n  \n  for (size_t i = 0; i < n - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n\n  std::vector<int> counts(1000, 0); \n\n  for (int x : lst) {\n    counts[x]++;\n    if (counts[x] > 1)\n    {\n        int dupe_count = 0;\n        for(int y : lst)\n        {\n            if(x == y)\n            {\n                dupe_count++;\n            }\n        }\n        if(dupe_count > 2)\n        {\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  size_t n = lst.size();\n  if (n <= 1) {\n    return true;\n  }\n\n  size_t vl = vsetvl_max_e32m1();\n  \n  for (size_t i = 0; i < n - 1; ++i) {\n    if (lst[i] > lst[i + 1]) {\n      return false;\n    }\n  }\n\n  std::vector<int> counts(10000, 0);\n  for (int x : lst) {\n    counts[x]++;\n    if (counts[x] > 1)\n    {\n        int num_duplicates = 0;\n        for(int y : lst)\n        {\n            if(y == x)\n            {\n                num_duplicates++;\n            }\n        }\n        if(num_duplicates > 1)\n        {\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n    size_t vl;\n    size_t i = 0;\n    \n    for (; i < arr.size(); i += vl) {\n        vl = vsetvl_e32m1(arr.size() - i);\n        vint32m1_t vec_arr = vle32_v_i32m1(&arr[i], vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int val = vget_i32m1(vec_arr, j);\n            if (val > 0) {\n                prod_signs *= 1;\n                sum_magnitudes += val;\n            } else if (val < 0) {\n                prod_signs *= -1;\n                sum_magnitudes += -val;\n            } else {\n                prod_signs = 0;\n                sum_magnitudes += 0;\n            }\n        }\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&arr[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int val = arr[i+j];\n            if (val > 0) {\n                prod_signs *= 1;\n                sum_magnitudes += val;\n            } else if (val < 0) {\n                prod_signs *= -1;\n                sum_magnitudes += -val;\n            } else {\n                prod_signs = 0;\n                sum_magnitudes += 0;\n            }\n        }\n        if (prod_signs == 0) break;\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n    size_t vl;\n    size_t i = 0;\n    \n    for (; i < arr.size(); i++) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs = 0;\n            break;\n        }\n    }\n    \n    if(prod_signs == 0){\n        return 0;\n    }\n\n    i = 0;\n    for (; i < arr.size(); i++) {\n        sum_magnitudes += abs(arr[i]);\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    int prod_signs = 1;\n    long long sum_magnitudes = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&arr[i], vl);\n\n        // Calculate signs\n        vint32m1_t signs = vmslt_vx_i32m1(v, 0, vl); // signs = (v < 0) ? -1 : 0\n        vint32m1_t is_zero = vmseq_vx_i32m1(v, 0, vl); // is_zero = (v == 0) ? 1 : 0\n\n        // Update product of signs\n        for (size_t j = 0; j < vl; ++j) {\n            int val = arr[i + j];\n            if (val < 0) {\n                prod_signs *= -1;\n            } else if (val == 0) {\n                prod_signs = 0;\n            }\n        }\n\n        // Calculate magnitudes\n        vint32m1_t abs_v = vabs_v_i32m1(v, vl);\n\n        // Sum magnitudes\n        int32_t sum_vec[vl];\n        vse32_v_i32m1(sum_vec, abs_v, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            sum_magnitudes += sum_vec[j];\n        }\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n    size_t vl;\n    size_t i = 0;\n    \n    for (; i < arr.size(); i += vl) {\n        vl = vsetvl_e32m1(arr.size() - i);\n        vint32m1_t vec_arr = vle32_v_i32m1(&arr[i], vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int val = vget_i32m1(vec_arr, j);\n            if (val > 0) {\n                prod_signs *= 1;\n                sum_magnitudes += val;\n            } else if (val < 0) {\n                prod_signs *= -1;\n                sum_magnitudes += -val;\n            } else {\n                prod_signs = 0;\n                sum_magnitudes += 0;\n            }\n        }\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dx[] = {0, 0, 1, -1};\n            int dy[] = {1, -1, 0, 0};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dx[i];\n                int new_col = col + dy[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int vl = vsetvl_e32m1(n);\n        \n        // Possible moves: up, down, left, right\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int start_row = 0; start_row < n; ++start_row) {\n        for (int start_col = 0; start_col < n; ++start_col) {\n            solve(start_row, start_col, {});\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dx[] = {0, 0, 1, -1};\n            int dy[] = {1, -1, 0, 0};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dx[i];\n                int new_col = col + dy[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells to find the minimum path\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        int possible_moves[4][2] = {\n            {row - 1, col},\n            {row + 1, col},\n            {row, col - 1},\n            {row, col + 1}\n        };\n\n        for (int i = 0; i < 4; ++i) {\n            int next_row = possible_moves[i][0];\n            int next_col = possible_moves[i][1];\n\n            if (next_row >= 0 && next_row < n && next_col >= 0 && next_col < n) {\n                solve(next_row, next_col, current_path);\n            }\n        }\n    };\n\n    // Iterate through all starting cells\n    for (int start_row = 0; start_row < n; ++start_row) {\n        for (int start_col = 0; start_col < n; ++start_col) {\n            solve(start_row, start_col, {});\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(std::vector<int>, int, int)> solve = \n        [&](std::vector<int> current_path, int row, int col) {\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int current_val = grid[row][col];\n        current_path.push_back(current_val);\n\n        int vl = vsetvl_e32m1(4); \n\n        std::vector<std::pair<int, int>> neighbors;\n        if (row > 0) neighbors.push_back({row - 1, col});\n        if (row < n - 1) neighbors.push_back({row + 1, col});\n        if (col > 0) neighbors.push_back({row, col - 1});\n        if (col < n - 1) neighbors.push_back({row, col + 1});\n\n        for (auto& neighbor : neighbors) {\n            solve(current_path, neighbor.first, neighbor.second);\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(current_path, i, j);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    int found_odd = 0;\n\n    if (n == 0) return 0;\n\n    vuint64m1_t vn = vmv_s_x_u64m1(n, 1);\n    size_t vl = 1;\n\n    while (vn != 0) {\n        vuint64m1_t digit_vector = vn % 10;\n        uint64_t digit = vmv_x_s_u64m1_u64(digit_vector);\n\n        if (digit % 2 != 0) {\n            product *= digit;\n            found_odd = 1;\n        }\n        vn /= 10;\n    }\n\n    if (!found_odd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n  uint64_t product = 1;\n  int found_odd = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  while (n > 0) {\n    uint64_t digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      found_odd = 1;\n    }\n    n /= 10;\n  }\n\n  if (!found_odd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n  uint64_t product = 1;\n  int found_odd = 0;\n\n  if (n == 0) {\n    return 0;\n  }\n\n  while (n > 0) {\n    uint64_t digit = n % 10;\n    if (digit % 2 != 0) {\n      product *= digit;\n      found_odd = 1;\n    }\n    n /= 10;\n  }\n\n  if (!found_odd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n  uint64_t product = 1;\n  uint64_t temp = n;\n  vuint64m1_t ones = vmv_s_x_u64m1(1, 1);\n  vuint64m1_t zero = vmv_s_x_u64m1(0, 1);\n  int any_odd = 0;\n\n  while (temp > 0) {\n    uint64_t digit = temp % 10;\n    temp /= 10;\n\n    vuint64m1_t vd = vmv_s_x_u64m1(digit, 1);\n    vbool64_t is_odd = vmseq_vx_u64m1_b64(vrem_vx_u64m1(vd, vmv_s_x_u64m1(2, 1), 1), ones, 1);\n\n    if (vfirst_m_b64(is_odd, 1)) {\n      product *= digit;\n      any_odd = 1;\n    }\n  }\n\n  if (!any_odd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool has_odd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n\n    if (!has_odd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n    const float *data = lst.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(data + i, vl);\n        vfloat32m8_t v_ceil = vfceil_v_f32m8(v, vl);\n        vint32m8_t v_int = vfwcint_rtz_v_f32m8_i32m8(v_ceil, vl);\n        vint64m1_t v_int64 = vwcvtx_x_x_w_i64m1(v_int, vl);\n        vint64m1_t v_squared = vmul_vv_i64m1(v_int64, v_int64, vl);\n        sum += vreduce_add_vs_i64m1_i64m1(sum, v_squared, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t vl = vsetvl_e32m8_max(__riscv_vlen);\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8_max(n - i);\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n        vfloat32m8_t vceil = vfceil_v_f32m8(vf, vl);\n        vint32m8_t vi = vfcvtzx_rtz_v_i32m8_f32m8(vceil, vl);\n        vint64m1_t v_squares = vmul_vv_i64m1(vi, vi, vl);\n        sum += vreduce_add_vs_i64m1_i64m1(sum, v_squares, vl);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t vl = vsetvl_e32m8_max(__riscv_vlen);\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8_max(n - i);\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n        vfloat32m8_t vceil = vfceil_v_f32m8(vf, vl);\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vceil, vl);\n        vint64m1_t vsq = vmull_vx_i64m1(vi, vi, vl);\n        sum += vreduce_add_vs_i64m1_i64m1(vsq, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t vl = vsetvl_e32m1(lst.size());\n    size_t i = 0;\n    float float_sum = 0;\n    uint64_t sum = 0;\n\n    for (; i < lst.size(); i += vl) {\n        vl = vsetvl_e32m1(lst.size() - i);\n        vfloat32m1_t vf = vle_v_f32m1(&lst[i], vl);\n        vfloat32m1_t vceil = vfceil_v_f32m1(vf, vl);\n        vint32m1_t vi = vfwcint_rtz_v_f32m1_i32m1(vceil, vl);\n        vint32m1_t v_squared = vmul_vv_i32m1(vi, vi, vl);\n        sum += vmv_s_x_i32m1_i32(vreduce_add_vs_i32m1_i32m1(v_squared, v_squared, vl), 0);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t vl = vsetvl_e32m1(lst.size());\n    size_t i = 0;\n    float float_sum = 0;\n    for (; i < lst.size() - vl + 1; i += vl) {\n        vfloat32m1_t vf = vle32_v_f32m1(&lst[i], vl);\n        vfloat32m1_t v_ceil = vfceil_v_f32m1(vf, vl);\n        vint32m1_t vi = vfcvt_x_f_v_i32m1(v_ceil, vl);\n        vint32m1_t vi_sq = vmul_vv_i32m1(vi, vi, vl);\n        int32_t sum = vmv_x_s_i32m1_i32(vredsum_vs_i32m1_i32m1(vundefined_i32m1(), vi_sq, vi_sq, vl));\n        float_sum += sum;\n        vl = vsetvl_e32m1(lst.size() - i - vl);\n    }\n    for (; i < lst.size(); ++i) {\n        float_sum += pow(ceil(lst[i]), 2);\n    }\n    return (uint64_t)float_sum;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int result = -1;\n    size_t vl = 0;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t current = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t previous = vle32_v_i32m1(&arr[i - 1], vl);\n        vbool32_t mask = vmblt_vv_i32m1_b32(current, previous, vl);\n\n        size_t first_true = -1;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask, j)) {\n                first_true = j;\n                break;\n            }\n        }\n\n        if (first_true != -1) {\n            result = i + first_true;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int result = -1;\n    size_t vl;\n    size_t i = 1;\n\n    while (i < n) {\n        vl = vsetvl_e32m8_i32(n - i + 1);\n        vint32m8_t current = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t previous = vle32_v_i32m8(&arr[i - 1], vl);\n        vbool4_t mask = vmblt_vv_i32m8_b4(current, previous, vl);\n\n        size_t first_true = -1;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask, j)) {\n                first_true = j;\n                break;\n            }\n        }\n\n        if (first_true != -1) {\n            result = i + first_true;\n            break;\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int result = -1;\n    size_t vl = 0;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t current = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t previous = vle32_v_i32m1(&arr[i - 1], vl);\n        vbool32_t mask = vmblt_vv_i32m1_b32(current, previous, vl);\n\n        size_t active_elements = vcount_pop_m_b32(mask, vl);\n\n        if (active_elements > 0) {\n            for (size_t j = 0; j < vl; ++j) {\n                if (vget_v_i1(mask, j)) {\n                    result = i + j;\n                    return result;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int result = -1;\n    size_t vl;\n    size_t i = 1;\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i + 1);\n        \n        vint32m8_t current = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t previous = vle32_v_i32m8(&arr[i - 1], vl);\n        \n        vbool4_t mask = vmblt_vv_i32m8_b4(current, previous, vl);\n\n        size_t first_true = -1;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask, j)) {\n                first_true = j;\n                break;\n            }\n        }\n\n        if (first_true != -1) {\n            result = i + first_true;\n            break;\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int result = -1;\n    size_t vl = 0;\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t current = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t previous = vle32_v_i32m1(&arr[i - 1], vl);\n        vbool32_t mask = vmblt_vv_i32m1_b32(current, previous, vl);\n\n        size_t first_index = -1;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vget_v_i1(mask, j)) {\n                first_index = j;\n                break;\n            }\n        }\n\n        if (first_index != -1) {\n            result = i + first_index;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = lst.size();\n    vint32m1_t v = vle32_v_i32m1(lst.data(), vl);\n    \n    vbool32_t positive_mask = vmgtz_v_i32m1_b32(v, vl);\n    vbool32_t negative_mask = vmltz_v_i32m1_b32(v, vl);\n\n    bool has_positive = false;\n    bool has_negative = false;\n\n    for (size_t i = 0; i < vl; ++i) {\n        if (positive_mask[i]) {\n            if (!has_positive) {\n                smallest_positive = lst[i];\n                has_positive = true;\n            } else {\n                smallest_positive = std::min(smallest_positive, lst[i]);\n            }\n        }\n        if (negative_mask[i]) {\n            if (!has_negative) {\n                largest_negative = lst[i];\n                has_negative = true;\n            } else {\n                largest_negative = std::max(largest_negative, lst[i]);\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = lst.size();\n    vint32m1_t vec = vle32_v_i32m1(lst.data(), vl);\n    vbool32_t is_negative = vmblt_vi_i32m1_b32(vec, 0, vl);\n    vbool32_t is_positive = vmsgt_vi_i32m1_b32(vec, 0, vl);\n\n    int current_largest_negative = std::numeric_limits<int>::min();\n    int current_smallest_positive = std::numeric_limits<int>::max();\n\n    for (size_t i = 0; i < vl; ++i) {\n        if (vget_v_i32m1(vec, i) < 0) {\n            if (vget_v_i32m1(vec, i) > current_largest_negative) {\n                current_largest_negative = vget_v_i32m1(vec, i);\n                largest_negative = current_largest_negative;\n            }\n        } else if (vget_v_i32m1(vec, i) > 0) {\n            if (vget_v_i32m1(vec, i) < current_smallest_positive) {\n                current_smallest_positive = vget_v_i32m1(vec, i);\n                smallest_positive = current_smallest_positive;\n            }\n        }\n    }\n\n    if (current_largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (current_smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = lst.size();\n    vint32m1_t vec = vle32_v_i32m1(lst.data(), vl);\n    \n    vbool32_t negative_mask = vmblt_vi_i32m1_b32(vec, 0, vl);\n    vbool32_t positive_mask = vmsgt_vi_i32m1_b32(vec, 0, vl);\n\n    bool found_negative = false;\n    bool found_positive = false;\n\n    if (vfirst_m_b32(negative_mask, vl)) {\n        largest_negative = std::numeric_limits<int>::min();\n        for (size_t i = 0; i < vl; ++i) {\n            if (negative_mask[i]) {\n                if (lst[i] > largest_negative) {\n                    largest_negative = lst[i];\n                }\n                found_negative = true;\n            }\n        }\n    }\n\n    if (vfirst_m_b32(positive_mask, vl)) {\n        smallest_positive = std::numeric_limits<int>::max();\n        for (size_t i = 0; i < vl; ++i) {\n            if (positive_mask[i]) {\n                if (lst[i] < smallest_positive) {\n                    smallest_positive = lst[i];\n                }\n                found_positive = true;\n            }\n        }\n    }\n\n    if (!found_negative) {\n        largest_negative = 0;\n    }\n    if (!found_positive) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    \n    std::vector<int32_t> input_vec(lst.begin(), lst.end());\n    \n    vint32m1_t vec = vle32_v_i32m1(input_vec.data(), vl);\n    \n    vbool32_t negative_mask = vmblt_vi_i32m1_b32(vec, 0, vl);\n    vbool32_t positive_mask = vmsgt_vi_i32m1_b32(vec, 0, vl);\n\n    int current_largest_negative = std::numeric_limits<int>::min();\n    int current_smallest_positive = std::numeric_limits<int>::max();\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (vget_v_i32m1(vec, i) < 0) {\n            if (vget_v_i32m1(vec, i) > current_largest_negative) {\n                current_largest_negative = vget_v_i32m1(vec, i);\n            }\n        } else if (vget_v_i32m1(vec, i) > 0) {\n            if (vget_v_i32m1(vec, i) < current_smallest_positive) {\n                current_smallest_positive = vget_v_i32m1(vec, i);\n            }\n        }\n    }\n    \n    if (current_largest_negative != std::numeric_limits<int>::min()) {\n        largest_negative = current_largest_negative;\n    }\n    if (current_smallest_positive != std::numeric_limits<int>::max()) {\n        smallest_positive = current_smallest_positive;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = lst.size();\n    vint32m1_t v = vle32_v_i32m1(lst.data(), vl);\n    \n    vbool32_t positive_mask = vmgtz_v_i32m1_b32(v, vl);\n    vbool32_t negative_mask = vmltz_v_i32m1_b32(v, vl);\n\n    bool has_positive = false;\n    bool has_negative = false;\n\n    for (size_t i = 0; i < vl; ++i) {\n        if (positive_mask[i]) {\n            if (!has_positive) {\n                smallest_positive = lst[i];\n                has_positive = true;\n            } else {\n                smallest_positive = std::min(smallest_positive, lst[i]);\n            }\n        }\n        if (negative_mask[i]) {\n            if (!has_negative) {\n                largest_negative = lst[i];\n                has_negative = true;\n            } else {\n                largest_negative = std::max(largest_negative, lst[i]);\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    int sum = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t result = vec;\n\n        for (size_t j = 0; j < vl; ++j) {\n            size_t index = i + j;\n            if (index % 3 == 0) {\n                result[j] = lst[index] * lst[index];\n            } else if (index % 4 == 0) {\n                result[j] = lst[index] * lst[index] * lst[index];\n            } else {\n                result[j] = lst[index];\n            }\n        }\n        \n        for(size_t j = 0; j < vl; j++){\n            sum += result[j];\n        }\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    int sum = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t result = vec_data; \n\n        for (size_t j = 0; j < vl; ++j) {\n            size_t index = i + j;\n            int32_t val = lst[index];\n\n            if (index % 3 == 0) {\n                val = val * val;\n            } else if (index % 4 == 0) {\n                val = val * val * val;\n            }\n            result[j] = val;\n        }\n        \n        for(int k = 0; k < vl; k++){\n            sum += result[k];\n        }\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    int sum = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t result = vec_data;\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if ((i + j) % 3 == 0) {\n                result[j] = lst[i+j] * lst[i+j];\n            } else if ((i + j) % 4 == 0) {\n                result[j] = lst[i+j] * lst[i+j] * lst[i+j];\n            } else {\n                result[j] = lst[i+j];\n            }\n        }\n        \n        for (size_t j = 0; j < vl; ++j) {\n            sum += result[j];\n        }\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    int sum = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t result = vec_data;\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if ((i + j) % 3 == 0) {\n                result[j] = lst[i+j] * lst[i+j];\n            } else if ((i + j) % 4 == 0) {\n                result[j] = lst[i+j] * lst[i+j] * lst[i+j];\n            } else {\n                result[j] = lst[i+j];\n            }\n        }\n        \n        for(size_t j = 0; j < vl; ++j){\n            sum += result[j];\n        }\n        \n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    int sum = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t result = vec_data;\n        \n        for (size_t j = 0; j < vl; ++j) {\n            size_t index = i + j;\n            if (index % 3 == 0) {\n                int32_t val = vget_i32m1(vec_data, j);\n                vset_i32m1(&result, j, val * val);\n            } else if (index % 4 == 0) {\n                int32_t val = vget_i32m1(vec_data, j);\n                vset_i32m1(&result, j, val * val * val);\n            }\n        }\n\n        for (size_t j = 0; j < vl; ++j) {\n            sum += vget_i32m1(result, j);\n        }\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&nums[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = vget_i32m1(v, j);\n            if (num > 10) {\n                int lastDigit = num % 10;\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n\n                if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&nums[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = vget_i32m1(v, j);\n            if (num > 10) {\n                int lastDigit = num % 10;\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n\n                if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&nums[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = vget_i32m1(v, j);\n            if (num > 10) {\n                int lastDigit = num % 10;\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n\n                if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v = vle32_v_i32m8(&nums[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = nums[i + j];\n            if (num > 10) {\n                int lastDigit = num % 10;\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n\n                if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v = vle32_v_i32m8(&nums[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = nums[i + j];\n            if (num > 10) {\n                int lastDigit = num % 10;\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n\n                if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n  if (n < 3) {\n    return 0;\n  }\n\n  uint64_t count = 0;\n  size_t vl;\n\n  for (uint64_t i = 0; i < n - 2; ++i) {\n    for (uint64_t j = i + 1; j < n - 1; ++j) {\n      for (uint64_t k = j + 1; k < n; ++k) {\n        uint64_t ai = i * i - i + 1;\n        uint64_t aj = j * j - j + 1;\n        uint64_t ak = k * k - k + 1;\n\n        if ((ai + aj + ak) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n  if (n < 3) {\n    return 0;\n  }\n\n  uint64_t count = 0;\n  size_t vl;\n\n  for (uint64_t i = 0; i < n - 2; ++i) {\n    for (uint64_t j = i + 1; j < n - 1; ++j) {\n      for (uint64_t k = j + 1; k < n; ++k) {\n        uint64_t ai = i * i - i + 1;\n        uint64_t aj = j * j - j + 1;\n        uint64_t ak = k * k - k + 1;\n\n        if ((ai + aj + ak) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n  if (n < 3) {\n    return 0;\n  }\n\n  uint64_t count = 0;\n  size_t vl;\n\n  for (uint64_t i = 0; i < n - 2; ++i) {\n    for (uint64_t j = i + 1; j < n - 1; ++j) {\n      for (uint64_t k = j + 1; k < n; ++k) {\n        uint64_t ai = i * i - i + 1;\n        uint64_t aj = j * j - j + 1;\n        uint64_t ak = k * k - k + 1;\n\n        if ((ai + aj + ak) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n  if (n < 3) {\n    return 0;\n  }\n\n  uint64_t count = 0;\n  size_t vl;\n\n  for (uint64_t i = 1; i <= n - 2; ++i) {\n    uint64_t ai = i * i - i + 1;\n    for (uint64_t j = i + 1; j <= n - 1; ++j) {\n      uint64_t aj = j * j - j + 1;\n      for (uint64_t k = j + 1; k <= n; ++k) {\n        uint64_t ak = k * k - k + 1;\n        if ((ai + aj + ak) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n  if (n < 3) {\n    return 0;\n  }\n\n  uint64_t count = 0;\n  size_t vl;\n\n  for (uint64_t i = 0; i < n - 2; ++i) {\n    for (uint64_t j = i + 1; j < n - 1; ++j) {\n      for (uint64_t k = j + 1; k < n; ++k) {\n        uint64_t ai = i * i - i + 1;\n        uint64_t aj = j * j - j + 1;\n        uint64_t ak = k * k - k + 1;\n\n        if ((ai + aj + ak) % 3 == 0) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    \n    size_t vl = vsetvl_e32m1(n - 1);\n    vint32m1_t factors = vseq_i32m1(vindex_range_i32m1(1, n, vl), vmv_v_i32m1(1, vl), vl);\n    \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    size_t vl = vsetvl_e32m1(n - 1);\n    vint32m1_t factors = vseq_i32m1(vindex_range_i32m1(1, n, vl), vmv_v_x_i32m1(0, vl), vl);\n    \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    size_t vl = vsetvl_e32m1(n - 1);\n    vint32m1_t factors = vseq_i32m1(vindex_range_i32m1(1, n, vl), vmv_v_x_i32m1(0, vl), vl);\n    \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    \n    size_t vl = vsetvl_e32m1(n - 1);\n    vint32m1_t factors = vseq_i32m1(vindex_range_i32m1(1, n, vl), vmv_v_i32m1(1, vl), vl);\n    \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using RVV (RISC-V Vector Extension) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    size_t vl = vsetvl_e32m1(n - 1);\n    vint32m1_t factors = vseq_i32m1(vindex_range_i32m1(1, n, vl), vmv_v_i32m1(1, vl), vl);\n    \n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vf = vle32_v_f32m1(&lst[i], vl);\n        vint32m1_t vi = vfcvt_rtz_x_f32m1(vf, vl);\n        vfloat32m1_t vf_converted = vfcvt_f_x_v_i32m1(vi, vl);\n\n        vbool32_t mask = vmfeq_vf_f32m1(vf, vf_converted, vl);\n        \n        vint32m1_t v_odd = vand_vi_i32m1(vi, 1, vl);\n        vbool32_t odd_mask = vmseq_vx_i32m1(v_odd, 1, vl);\n\n        vbool32_t combined_mask = vand_mm_b32(mask, odd_mask, vl);\n\n        vint32m1_t masked_vi = vmv_v_x_i32m1(0, vl);\n        masked_vi = vmerge_vvm_i32m1(masked_vi, vi, combined_mask, vl);\n\n        vint64m1_t vi64 = vsext_vf4_i32m1_i64m1(masked_vi, vl);\n        vint64m1_t v_squared = vmul_vv_i64m1(vi64, vi64, vl);\n        sum += vreduce_add_vs_i64m1_i64m1(sum, v_squared, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    size_t vl;\n    const float *ptr = lst.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vf = vle32_v_f32m1(ptr + i, vl);\n        vint32m1_t vi = vfcvt_rtz_x_f32m1(vf, vl);\n        vfloat32m1_t vf_converted = vfcvt_f_x_v_f32m1(vi, vl);\n\n        vbool32_t mask = vmfeq_vv_f32m1_b32(vf, vf_converted, vl);\n        \n        vbool32_t positive_mask = vmflt_vf_f32m1_b32(vf, 0.0f, vl);\n        mask = vand_mm_b32(mask, positive_mask, vl);\n\n        vint32m1_t odd_mask = vand_vi_i32m1_b32(vi, 1, vl);\n        vbool32_t is_odd = vmseq_vx_i32m1_b32(odd_mask, 1, vl);\n        mask = vand_mm_b32(mask, is_odd, vl);\n\n        vint64m1_t vi64 = vwmul_vv_i64m1(vi, vi, vl);\n        sum += vreduce_add_vs_i64m1_i64m1(sum, vi64, vi64, mask, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    size_t vl;\n    const float *ptr = lst.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vf = vle32_v_f32m1(ptr + i, vl);\n        vint32m1_t vi = vfcvt_rtz_x_f32m1(vf, vl);\n        vfloat32m1_t vf_converted = vfcvt_f_x_v_f32m1(vi, vl);\n\n        vbool32_t mask = vmfeq_vv_f32m1_b32(vf, vf_converted, vl);\n        \n        vbool32_t positive_mask = vmflt_vf_f32m1_b32(vf, 0.0f, vl);\n        mask = vand_mm_b32(mask, positive_mask, vl);\n\n        vint32m1_t odd_mask = vand_vi_i32m1_b32(vi, 1, vl);\n        vbool32_t is_odd_mask = vmseq_vx_i32m1_b32(odd_mask, 1, vl);\n        mask = vand_mm_b32(mask, is_odd_mask, vl);\n\n        vint64m1_t vi64 = vwmul_vv_i64m1(vi, vi, vl);\n        sum += vreduce_add_m_i64m1_i64(mask, sum, vi64, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    size_t vl;\n    const float *data = lst.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vf = vle32_v_f32m1(data + i, vl);\n        vint32m1_t vi = vfcvt_rtz_x_f32m1(vf, vl);\n        vbool32_t vb_pos = vmgt_vx_i32m1(vi, 0, vl);\n        vbool32_t vb_odd = vand_mm_b32(vb_pos, vmseq_vx_i32m1(vand_vx_i32m1(vi, 1, vl), 1, vl), vl);\n        vint32m1_t vi_masked = vmand_mm_i32m1(vi, vb_odd, vi, vl);\n        vint64m1_t vli = vsext_vf4_i32m1_i64m1(vi_masked, vl);\n        vint64m1_t vsq = vmul_vv_i64m1(vli, vli, vl);\n        sum += vreduce_add_i64m1_i64m1(0, vsq, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    size_t vl;\n    const float *data = lst.data();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vf = vle32_v_f32m1(data + i, vl);\n        vint32m1_t vi = vfcvt_rtz_x_f32m1(vf, vl);\n        vbool32_t vb_pos = vmgt_vx_i32m1(vi, 0, vl);\n        vbool32_t vb_odd = vand_mm_b32(vb_pos, vmseq_vx_i32m1(vand_vx_i32m1(vi, 1, vl), 1, vl), vl);\n        vint32m1_t vi_masked = vmul_vx_i32m1_m(vb_odd, vi, vi, 1, vl);\n        vint64m1_t vi64 = vwmul_vv_i64m1(vi_masked, vi_masked, vl);\n        sum += vreduce_add_u64_i64m1(0, vi64, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    size_t i = 0;\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n        vint32m8_t v_diff = vsub_vv_i32m8(v_guess, v_game, vl);\n        vint32m8_t v_abs_diff = vabs_v_i32m8(v_diff, vl);\n        vint32m8_t v_mask = vmv_v_i32m8(0, vl);\n        vbool4_t v_cmp = vmeq_vv_i32m8_b4(v_game, v_guess, vl);\n        v_abs_diff = vmerge_vvm_i32m8(v_abs_diff, v_mask, v_cmp, vl);\n        vse32_v_i32m8(&result[i], v_abs_diff, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n\n        vint32m8_t v_diff = vsub_vv_i32m8(v_guess, v_game, vl);\n        vint32m8_t v_abs_diff = vabs_v_i32m8(v_diff, vl);\n        vint32m8_t v_cmp = vmseq_vx_i32m8(v_game, v_guess, vl);\n        vint32m8_t v_res = vmerge_vxm_i32m8(v_cmp, v_abs_diff, 0, vl);\n\n        vse32_v_i32m8(&result[i], v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_game = vle32_v_i32m1(&game[i], vl);\n        vint32m1_t v_guess = vle32_v_i32m1(&guess[i], vl);\n\n        vint32m1_t v_diff = vsub_vv_i32m1(v_guess, v_game, vl);\n        vint32m1_t v_abs_diff = vabs_v_i32m1(v_diff, vl);\n        vint32m1_t v_mask = vmv_v_i_i32m1(0, vl);\n        vbool32_t v_cmp = vmsne_vx_i32m1_b32(v_diff, 0, vl);\n        vint32m1_t v_res = vmerge_vvm_i32m1(v_mask, v_abs_diff, v_cmp, vl);\n\n        vse32_v_i32m1(&result[i], v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n\n        vint32m8_t v_diff = vsub_vv_i32m8(v_guess, v_game, vl);\n        vint32m8_t v_abs_diff = vabs_v_i32m8(v_diff, vl);\n        vint32m8_t v_cmp = vmseq_vx_i32m8(v_game, v_guess, vl);\n        vint32m8_t v_res = vmerge_vxm_i32m8(v_cmp, v_abs_diff, 0, vl);\n\n        vse32_v_i32m8(&result[i], v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t vl;\n    size_t i = 0;\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n        vint32m8_t v_diff = vsub_vv_i32m8(v_guess, v_game, vl);\n        vint32m8_t v_abs_diff = vabs_v_i32m8(v_diff, vl);\n        vint32m8_t v_mask = vmv_v_i32m8(0, vl);\n        vbool4_t v_cmp = vmseq_vv_i32m8_b4(v_game, v_guess, vl);\n        v_mask = vmerge_vmv_i32m8(v_cmp, v_mask, v_abs_diff, vl);\n        vse32_v_i32m8(&result[i], v_mask, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}

{"task_id": "SimdBench_0_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i dst_vec = _mm_loadu_si128((const __m128i*)&dst[i]);\n        \n        uint32_t mask_int = (mask[i] << 0) | (mask[i+1] << 1) | (mask[i+2] << 2) | (mask[i+3] << 3);\n        \n        __m128i mask_vec = _mm_set_epi64x((mask[i+3] ? -1LL : 0LL), (mask[i+2] ? -1LL : 0LL));\n        mask_vec = _mm_insert_epi64(mask_vec, (mask[i+1] ? -1LL : 0LL), 1);\n        mask_vec = _mm_insert_epi64(mask_vec, (mask[i] ? -1LL : 0LL), 0);\n\n        dst_vec = _mm_blendv_epi8(dst_vec, src_vec, mask_vec);\n        _mm_storeu_si128((__m128i*)&dst[i], dst_vec);\n    }\n    \n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i src_vec_low = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i src_vec_high = _mm_loadu_si128((const __m128i*)(src + i + 2));\n\n        __m128i mask_vec_low = _mm_cvtsi32_si128(*(int*)(mask + i));\n        __m128i mask_vec_high = _mm_cvtsi32_si128(*(int*)(mask + i + 4));\n\n        int mask_int_low = *(int*)(mask + i);\n        int mask_int_high = *(int*)(mask + i + 4);\n\n        __m128i dst_vec_low = _mm_loadu_si128((__m128i*)(dst + i));\n        __m128i dst_vec_high = _mm_loadu_si128((__m128i*)(dst + i + 2));\n\n        if ((mask_int_low & 0x1) != 0) dst[i] = src[i];\n        if ((mask_int_low & 0x2) != 0) dst[i+1] = src[i+1];\n        if ((mask_int_low & 0x4) != 0) dst[i+2] = src[i+2];\n        if ((mask_int_low & 0x8) != 0) dst[i+3] = src[i+3];\n        if ((mask_int_high & 0x1) != 0) dst[i+4] = src[i+4];\n        if ((mask_int_high & 0x2) != 0) dst[i+5] = src[i+5];\n        if ((mask_int_high & 0x4) != 0) dst[i+6] = src[i+6];\n        if ((mask_int_high & 0x8) != 0) dst[i+7] = src[i+7];\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i dst_vec = _mm_loadu_si128((const __m128i*)&dst[i]);\n        \n        uint32_t mask_int = (mask[i] << 0) | (mask[i+1] << 1) | (mask[i+2] << 2) | (mask[i+3] << 3);\n        \n        __m128i mask_vec = _mm_set_epi64x((mask[i+3] ? -1LL : 0LL), (mask[i+2] ? -1LL : 0LL));\n        mask_vec = _mm_shuffle_epi32(mask_vec, _MM_SHUFFLE(1,0,1,0));\n        __m128i mask_vec2 = _mm_set_epi64x((mask[i+1] ? -1LL : 0LL), (mask[i] ? -1LL : 0LL));\n        mask_vec2 = _mm_shuffle_epi32(mask_vec2, _MM_SHUFFLE(1,0,1,0));\n        mask_vec = _mm_unpacklo_epi64(mask_vec2, mask_vec);\n        \n        __m128i result_vec = _mm_blendv_epi8(dst_vec, src_vec, mask_vec);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((const __m128i*)(dst + i));\n\n        uint32_t mask_int = (mask[i] << 0) | (mask[i + 1] << 1) | (mask[i + 2] << 2) | (mask[i + 3] << 3);\n        __m128i mask_vec = _mm_set_epi64x(mask_int & 8 ? -1 : 0, mask_int & 4 ? -1 : 0);\n        mask_vec = _mm_shuffle_epi32(mask_vec, _MM_SHUFFLE(3, 1, 2, 0));\n        mask_vec = _mm_insert_epi32(mask_vec, mask_int & 2 ? -1 : 0, 2);\n        mask_vec = _mm_insert_epi32(mask_vec, mask_int & 1 ? -1 : 0, 0);\n\n        dst_vec = _mm_blendv_epi8(dst_vec, src_vec, mask_vec);\n\n        _mm_storeu_si128((__m128i*)(dst + i), dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((const __m128i*)(dst + i));\n\n        uint32_t mask_int = (mask[i] << 0) | (mask[i + 1] << 1) | (mask[i + 2] << 2) | (mask[i + 3] << 3);\n        __m128i mask_vec = _mm_set_epi64x(mask_int & 8 ? -1 : 0, mask_int & 4 ? -1 : 0);\n        mask_vec = _mm_shuffle_epi32(mask_vec, _MM_SHUFFLE(3, 1, 2, 0));\n        mask_vec = _mm_insert_epi32(mask_vec, mask_int & 2 ? -1 : 0, 2);\n        mask_vec = _mm_insert_epi32(mask_vec, mask_int & 1 ? -1 : 0, 0);\n\n        dst_vec = _mm_blendv_epi8(dst_vec, src_vec, mask_vec);\n        _mm_storeu_si128((__m128i*)(dst + i), dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    __m128i seven_vec = _mm_set1_epi32(7);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n        \n        __m128i tmp1_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i sum_vec = _mm_add_epi32(scaled_vec, tmp1_tmp2);\n\n        __m128i result_vec;\n        int temp_results[4];\n        _mm_storeu_si128((__m128i*)temp_results, sum_vec);\n        for(int j = 0; j < 4; ++j){\n            temp_results[j] = temp_results[j] / 7;\n        }\n        result_vec = _mm_loadu_si128((__m128i*)temp_results);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        int scaled_val = src[i] * scale;\n        int tmp1 = scaled_val >> 3;\n        int tmp2 = scaled_val << 3;\n        dst[i] = (scaled_val + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    __m128i seven_vec = _mm_set1_epi32(7);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n\n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n\n        __m128i mul_tmp1_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i add_scaled_mul = _mm_add_epi32(scaled_vec, mul_tmp1_tmp2);\n\n        __m128i result_vec = _mm_div_epi32(add_scaled_mul, seven_vec);\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    __m128i seven_vec = _mm_set1_epi32(7);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        \n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n\n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n\n        __m128i tmp1_mul_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i sum_vec = _mm_add_epi32(scaled_vec, tmp1_mul_tmp2);\n\n        __m128i result_vec = _mm_div_epi32(sum_vec, seven_vec);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n\n__m128i _mm_div_epi32(__m128i a, __m128i b) {\n    int quotient[4];\n    int divisor[4];\n    int dividend[4];\n\n    _mm_storeu_si128((__m128i*)divisor, b);\n    _mm_storeu_si128((__m128i*)dividend, a);\n\n    for (int i = 0; i < 4; ++i) {\n        quotient[i] = dividend[i] / divisor[i];\n    }\n\n    return _mm_loadu_si128((__m128i*)quotient);\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    __m128i seven_vec = _mm_set1_epi32(7);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        \n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n\n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n\n        __m128i tmp1_mul_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i sum = _mm_add_epi32(scaled_vec, tmp1_mul_tmp2);\n\n        __m128i result = _mm_div_epi32(sum, seven_vec);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    __m128i seven_vec = _mm_set1_epi32(7);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n\n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n\n        __m128i tmp1_mul_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i sum = _mm_add_epi32(scaled_vec, tmp1_mul_tmp2);\n\n        __m128i result = _mm_srai_epi32(_mm_add_epi32(sum, _mm_set1_epi32(3)), 3); // Divide by 7 (approx.)\n\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 3 < rows; i += 4) {\n        __m128d v1 = _mm_loadu_pd(src + (i * cols + stride));\n        __m128d v2 = _mm_loadu_pd(src + ((i + 2) * cols + stride));\n        _mm_storeu_pd(dst + i, v1);\n        _mm_storeu_pd(dst + i + 2, v2);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 3 < rows; i += 4) {\n        __m128d v1 = _mm_load_sd(&src[(i + 0) * cols + stride]);\n        __m128d v2 = _mm_load_sd(&src[(i + 1) * cols + stride]);\n        __m128d v3 = _mm_load_sd(&src[(i + 2) * cols + stride]);\n        __m128d v4 = _mm_load_sd(&src[(i + 3) * cols + stride]);\n\n        __m128d temp1 = _mm_unpacklo_pd(v1, v2);\n        __m128d temp2 = _mm_unpacklo_pd(v3, v4);\n        __m128d result = _mm_unpacklo_pd(temp1, temp2);\n\n        _mm_storeu_pd(&dst[i], result);\n\n        v1 = _mm_unpackhi_pd(v1, v2);\n        v2 = _mm_unpackhi_pd(v3, v4);\n        result = _mm_unpacklo_pd(v1, v2);\n        _mm_storeu_pd(&dst[i + 2], result);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 3 < rows; i += 4) {\n        __m128d v1 = _mm_loadu_pd(src + (i * cols + stride));\n        __m128d v2 = _mm_loadu_pd(src + ((i + 2) * cols + stride));\n\n        _mm_storeu_pd(dst + i, v1);\n        _mm_storeu_pd(dst + i + 2, v2);\n    }\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 3 < rows; i += 4) {\n        __m128d v1 = _mm_load_sd(&src[(i + 0) * cols + stride]);\n        __m128d v2 = _mm_load_sd(&src[(i + 1) * cols + stride]);\n        __m128d v3 = _mm_load_sd(&src[(i + 2) * cols + stride]);\n        __m128d v4 = _mm_load_sd(&src[(i + 3) * cols + stride]);\n\n        __m128d temp1 = _mm_unpacklo_pd(v1, v2);\n        __m128d temp2 = _mm_unpacklo_pd(v3, v4);\n        __m128d result = _mm_unpacklo_pd(temp1, temp2);\n\n        _mm_storeu_pd(&dst[i], result);\n\n        v1 = _mm_unpackhi_pd(v1, v2);\n        v2 = _mm_unpackhi_pd(v3, v4);\n        result = _mm_unpacklo_pd(v1, v2);\n\n        _mm_storeu_pd(&dst[i + 2], result);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i + 3 < rows; i += 4) {\n        __m128d v1 = _mm_load_sd(&src[(i + 0) * cols + stride]);\n        __m128d v2 = _mm_load_sd(&src[(i + 1) * cols + stride]);\n        __m128d v3 = _mm_load_sd(&src[(i + 2) * cols + stride]);\n        __m128d v4 = _mm_load_sd(&src[(i + 3) * cols + stride]);\n\n        __m128d temp1 = _mm_unpacklo_pd(v1, v2);\n        __m128d temp2 = _mm_unpacklo_pd(v3, v4);\n        __m128d result = _mm_unpacklo_pd(temp1, temp2);\n\n        _mm_storeu_pd(&dst[i], result);\n\n        v1 = _mm_unpackhi_pd(v1, v2);\n        v2 = _mm_unpackhi_pd(v3, v4);\n        result = _mm_unpacklo_pd(v1, v2);\n\n        _mm_storeu_pd(&dst[i + 2], result);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        \n        float gathered_values[4];\n        for (int j = 0; j < 4; ++j) {\n            gathered_values[j] = src[indices[i + j]];\n        }\n\n        __m128 gathered_vec = _mm_loadu_ps(gathered_values);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 src_vec = _mm_loadu_ps(src + i);\n        int idx0 = indices[i];\n        int idx1 = indices[i+1];\n        int idx2 = indices[i+2];\n        int idx3 = indices[i+3];\n        dst[idx0] = src[i];\n        dst[idx1] = src[i+1];\n        dst[idx2] = src[i+2];\n        dst[idx3] = src[i+3];\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        \n        float gathered_values[4];\n        for (int j = 0; j < 4; ++j) {\n            gathered_values[j] = src[indices[i + j]];\n        }\n        __m128 gathered_vec = _mm_loadu_ps(gathered_values);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        __m128 src_vec = _mm_loadu_ps(src + i);\n\n        float src_values[4];\n        _mm_storeu_ps(src_values, src_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            dst[indices[i + j]] = src_values[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i idx = _mm_loadu_si128((const __m128i *)&indices[i]);\n        \n        float gathered_values[4];\n        for (int j = 0; j < 4; ++j) {\n            gathered_values[j] = src[indices[i+j]];\n        }\n        __m128 gathered = _mm_loadu_ps(gathered_values);\n        _mm_storeu_ps(&dst[i], gathered);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n    \n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 values = _mm_loadu_ps(&src[i]);\n        \n        for (int j = 0; j < 4; ++j) {\n            dst[indices[i+j]] = src[i+j];\n        }\n    }\n    \n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        \n        float gathered_values[4];\n        for (int j = 0; j < 4; ++j) {\n            gathered_values[j] = src[indices[i + j]];\n        }\n\n        __m128 gathered_vec = _mm_loadu_ps(gathered_values);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 src_vec = _mm_loadu_ps(src + i);\n        int idx0 = indices[i];\n        int idx1 = indices[i+1];\n        int idx2 = indices[i+2];\n        int idx3 = indices[i+3];\n\n        dst[idx0] = src[i];\n        dst[idx1] = src[i+1];\n        dst[idx2] = src[i+2];\n        dst[idx3] = src[i+3];\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        \n        float gathered_values[4];\n        for (int j = 0; j < 4; ++j) {\n            gathered_values[j] = src[indices[i + j]];\n        }\n        __m128 gathered_vec = _mm_loadu_ps(gathered_values);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n    \n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i index_vec = _mm_loadu_si128((const __m128i*)(indices + i));\n        __m128 src_vec = _mm_loadu_ps(src + i);\n        float src_values[4];\n        _mm_storeu_ps(src_values, src_vec);\n        \n        for (int j = 0; j < 4; ++j) {\n            dst[indices[i + j]] = src_values[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t num_elements = (end - start + 1);\n    uint64_t num_iters = num_elements / 8;\n    uint64_t remainder = num_elements % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - (i * 8) - 7]);\n\n        __m128i temp = left;\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], right);\n        _mm_storeu_si128((__m128i*)&arr[end - (i * 8) - 7], temp);\n    }\n\n    uint64_t remaining_start = start + num_iters * 8;\n    uint64_t remaining_end = end - num_iters * 8;\n\n    for (uint64_t i = 0; i < remainder / 2; ++i) {\n        int16_t temp = arr[remaining_start + i];\n        arr[remaining_start + i] = arr[remaining_end - i];\n        arr[remaining_end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t num_elements = (end - start + 1);\n    uint64_t num_iters = num_elements / 8;\n    uint64_t remaining = num_elements % 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - (i * 8) - 7]);\n\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], right);\n        _mm_storeu_si128((__m128i*)&arr[end - (i * 8) - 7], left);\n    }\n\n    uint64_t remaining_start = start + num_iters * 8;\n    uint64_t remaining_end = end - num_iters * 8;\n\n    for (uint64_t i = 0; i < remaining / 2; ++i) {\n        int16_t temp = arr[remaining_start + i];\n        arr[remaining_start + i] = arr[remaining_end - i];\n        arr[remaining_end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t len = (end - start + 1);\n    uint64_t num_iters = len / 8;\n\n    for (uint64_t i = 0; i < num_iters; ++i) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - (i * 8) - 7]);\n\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], right);\n        _mm_storeu_si128((__m128i*)&arr[end - (i * 8) - 7], left);\n    }\n\n    uint64_t remaining = len % 8;\n    if (remaining > 0) {\n        uint64_t offset = num_iters * 8;\n        for (uint64_t i = 0; i < remaining / 2; ++i) {\n            int16_t temp = arr[start + offset + i];\n            arr[start + offset + i] = arr[end - offset - i];\n            arr[end - offset - i] = temp;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t num_to_reverse = end - start + 1;\n    uint64_t num_simd_iterations = num_to_reverse / 8;\n    uint64_t remaining_elements = num_to_reverse % 8;\n\n    for (uint64_t i = 0; i < num_simd_iterations; ++i) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - (i * 8) - 7]);\n\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], right);\n        _mm_storeu_si128((__m128i*)&arr[end - (i * 8) - 7], left);\n    }\n\n    uint64_t remaining_start = start + num_simd_iterations * 8;\n    uint64_t remaining_end = end - num_simd_iterations * 8;\n\n    for (uint64_t i = 0; i < remaining_elements / 2; ++i) {\n        int16_t temp = arr[remaining_start + i];\n        arr[remaining_start + i] = arr[remaining_end - i];\n        arr[remaining_end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n\n    uint64_t num_elements = end - start + 1;\n    uint64_t num_simd_iterations = num_elements / 8;\n    uint64_t remaining_elements = num_elements % 8;\n\n    for (uint64_t i = 0; i < num_simd_iterations; ++i) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - (i * 8) - 7]);\n\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], right);\n        _mm_storeu_si128((__m128i*)&arr[end - (i * 8) - 7], left);\n    }\n\n    uint64_t left_offset = start + num_simd_iterations * 8;\n    uint64_t right_offset = end - num_simd_iterations * 8 - remaining_elements + 1;\n\n    for (uint64_t i = 0; i < remaining_elements / 2; ++i) {\n        int16_t temp = arr[left_offset + i];\n        arr[left_offset + i] = arr[right_offset + remaining_elements / 2 - 1 - i];\n        arr[right_offset + remaining_elements / 2 - 1 - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx;\n\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[i * dim2 * dim3 + j * dim3 + offset];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx;\n\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[i * dim2 * dim3 + j * dim3 + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n    \n    // Handle remaining elements if total_elements is not a multiple of 16\n    for (size_t i = total_elements - (total_elements % 16); i < total_elements; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n\n    // Handle remaining elements if total_elements is not a multiple of 16\n    for (size_t i = total_elements - (total_elements % 16); i < total_elements; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; bj += 8) {\n                    __m128i row_data = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj)]);\n                    __m128i transposed_data = _mm_unpacklo_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj) * rows + (i + bi)], transposed_data);\n                    transposed_data = _mm_unpackhi_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj + 4) * rows + (i + bi)], transposed_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = block_row; i < block_row + block_size && i < rows; ++i) {\n                for (size_t j = block_col; j < block_col + block_size && j < cols; ++j) {\n                    size_t src_index = i * cols + j;\n                    size_t dst_index = j * rows + i;\n\n                    __m128i data = _mm_loadu_si128((__m128i*)&src[src_index]);\n                    _mm_storeu_si128((__m128i*)&dst[dst_index], data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = block_row; i < block_row + block_size && i < rows; ++i) {\n                for (size_t j = block_col; j < block_col + block_size && j < cols; j += 8) {\n                    __m128i row_data = _mm_loadu_si128((__m128i*)&src[i * cols + j]);\n                    __m128i transposed_data = _mm_unpacklo_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[j * rows + i], transposed_data);\n                    transposed_data = _mm_unpackhi_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[(j + 4) * rows + i], transposed_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- The block size (block_size).\n\nThe matrix src and dst are represented as 1D arrays in memory.\nYour goal is to transpose the matrix in a blocked manner.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < std::min(i + block_size, rows); ++x) {\n                for (size_t y = j; y < std::min(j + block_size, cols); ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- The block size (block_size).\n\nThe matrix src and dst are represented as 1D arrays in memory.\nYour goal is to transpose the matrix in a blocked manner.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < std::min(i + block_size, rows); ++x) {\n                for (size_t y = j; y < std::min(j + block_size, cols); ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i = 0;\n    __m128 sum_vec = _mm_setzero_ps();\n    float sum_scalar = 0.0f;\n\n    for (i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        __m128 val = _mm_set_ps1(array[index]);\n        sum_vec = _mm_add_ps(sum_vec, val);\n    }\n\n    float temp[4];\n    _mm_storeu_ps(temp, sum_vec);\n    sum_scalar = temp[0] + temp[1] + temp[2] + temp[3];\n\n    return sum_scalar;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i = 0;\n    __m128 sum_vec = _mm_setzero_ps();\n    float sum_scalar = 0.0f;\n\n    for (i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        __m128 val = _mm_load_ss(&array[index]);\n        sum_vec = _mm_add_ss(sum_vec, val);\n    }\n\n    // Extract the single float value from the SSE register\n    _mm_store_ss(&sum_scalar, sum_vec);\n\n    return sum_scalar;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i = 0;\n    __m128 sum_vec = _mm_setzero_ps();\n    float sum_scalar = 0.0f;\n\n    for (i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        __m128 val = _mm_load_ss(&array[index]);\n        sum_vec = _mm_add_ss(sum_vec, val);\n    }\n\n    // Extract the single float value from the SSE register\n    _mm_store_ss(&sum_scalar, sum_vec);\n\n    return sum_scalar;\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            __m128d data = _mm_loadu_pd(&src[i * cols + j]);\n            __m128d mask = _mm_cmpgt_pd(data, threshold_vec);\n            __m128d scaled_data = _mm_mul_pd(data, scale_vec);\n            __m128d result = _mm_blendv_pd(data, scaled_data, mask);\n            _mm_storeu_pd(&dst[i * cols + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            __m128d data = _mm_loadu_pd(&src[i * cols + j]);\n            __m128d mask = _mm_cmpgt_pd(data, threshold_vec);\n            __m128d scaled_data = _mm_mul_pd(data, scale_vec);\n            __m128d result = _mm_blendv_pd(data, scaled_data, mask);\n            _mm_storeu_pd(&dst[i * cols + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A threshold value (threshold);\n- A scale factor (scale).\n\nYour goal is to apply a conditional scaling operation on the source array.\nIf the value is greater than the threshold, scale it by the scale factor; otherwise, keep it unchanged.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A threshold value (threshold);\n- A scale factor (scale).\n\nYour goal is to apply a conditional scaling operation on the source array.\nIf the value is greater than the threshold, scale it by the scale factor; otherwise, keep it unchanged.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += 2) {\n            __m128d data = _mm_loadu_pd(&src[i * cols + j]);\n            __m128d mask = _mm_cmpgt_pd(data, threshold_vec);\n            __m128d scaled_data = _mm_mul_pd(data, scale_vec);\n            __m128d result = _mm_blendv_pd(data, scaled_data, mask);\n            _mm_storeu_pd(&dst[i * cols + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n    size_t num_iters = cols / cols_per_iter;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (j = 0; j < num_iters; ++j) {\n            __m128d src_data = _mm_loadu_pd(src_row + j * cols_per_iter);\n            _mm_storeu_pd(dst_row + j * cols_per_iter, src_data);\n        }\n\n        // Handle remaining columns if cols is not a multiple of 2\n        for (j = num_iters * cols_per_iter; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n    size_t num_iters = cols / cols_per_iter;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (j = 0; j < num_iters; ++j) {\n            __m128d src_data = _mm_loadu_pd(src_row + j * cols_per_iter);\n            _mm_storeu_pd(dst_row + j * cols_per_iter, src_data);\n        }\n\n        // Handle remaining columns if cols is not a multiple of 2\n        for (j = num_iters * cols_per_iter; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n    size_t num_iters = cols / cols_per_iter;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (j = 0; j < num_iters; ++j) {\n            __m128d src_data = _mm_loadu_pd(src_row + j * cols_per_iter);\n            _mm_storeu_pd(dst_row + j * cols_per_iter, src_data);\n        }\n\n        // Handle remaining columns if cols is not a multiple of 2\n        for (j = num_iters * cols_per_iter; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n    size_t num_iters = cols / cols_per_iter;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (j = 0; j < num_iters; ++j) {\n            __m128d src_data = _mm_loadu_pd(src_row + j * cols_per_iter);\n            _mm_storeu_pd(dst_row + j * cols_per_iter, src_data);\n        }\n\n        // Handle remaining columns if cols is not a multiple of 2\n        for (j = num_iters * cols_per_iter; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    size_t cols_per_iter = 2;\n    size_t num_iters = cols / cols_per_iter;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (j = 0; j < num_iters; ++j) {\n            __m128d src_vector = _mm_loadu_pd(src_row + j * cols_per_iter);\n            _mm_storeu_pd(dst_row + j * cols_per_iter, src_vector);\n        }\n\n        // Handle remaining columns if cols is not a multiple of cols_per_iter\n        for (j = num_iters * cols_per_iter; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n\n        __m128i sum_vec = _mm_add_epi64(src1_vec, src2_vec);\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n\n        __m128i result_vec = _mm_srai_epi64(sum_vec, 1);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i src1_vec = _mm_loadu_si128((const __m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((const __m128i*)&src2[i]);\n\n        __m128i sum_vec = _mm_add_epi64(src1_vec, src2_vec);\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n\n        __m128i shifted_vec = _mm_srai_epi64(sum_vec, 1);\n\n        _mm_storeu_si128((__m128i*)&dst[i], shifted_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i src1_vec = _mm_loadu_si128((const __m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((const __m128i*)&src2[i]);\n\n        __m128i sum_vec = _mm_add_epi64(src1_vec, src2_vec);\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n\n        __m128i shifted_vec = _mm_srai_epi64(sum_vec, 1);\n\n        _mm_storeu_si128((__m128i*)&dst[i], shifted_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n\n        __m128i sum_vec = _mm_add_epi64(src1_vec, src2_vec);\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n\n        __m128i result_vec = _mm_srai_epi64(sum_vec, 1);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i src1_vec = _mm_loadu_si128((const __m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((const __m128i*)&src2[i]);\n\n        __m128i sum_vec = _mm_add_epi64(src1_vec, src2_vec);\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n\n        __m128i shifted_vec = _mm_srai_epi64(sum_vec, 1);\n\n        _mm_storeu_si128((__m128i*)&dst[i], shifted_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n    \n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_result) {\n            min_result = min_array[j];\n        }\n    }\n\n    return min_result == INT_MAX ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_elements = _mm_and_si128(data, _mm_set1_epi32(0xFFFFFFFE));\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n\n    int result = min_array[0];\n    for (int j = 1; j < 4; j++) {\n        if (min_array[j] < result) {\n            result = min_array[j];\n        }\n    }\n\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n\n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_result) {\n            min_result = min_array[j];\n        }\n    }\n\n    return (min_result == INT_MAX) ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n\n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_result) {\n            min_result = min_array[j];\n        }\n    }\n\n    return (min_result == INT_MAX) ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 1);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_val = _mm_min_epi32(min_val, _mm_set1_epi32(src[i]));\n        }\n    }\n\n    int result[4];\n    _mm_storeu_si128((__m128i*)result, min_val);\n    int minimum = result[0];\n    for (int j = 1; j < 4; j++) {\n        minimum = minimum < result[j] ? minimum : result[j];\n    }\n\n    return minimum == INT_MAX ? -1 : minimum;\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n\n        // Arithmetic right shift\n        __m128i arith_shift_vec = _mm_srai_epi32(src_vec, shift);\n\n        // Logical right shift\n        __m128i uint_vec = _mm_cvtepi32_epi32(_mm_loadu_si128((const __m128i*)&src[i]));\n        __m128i logical_shift_vec = _mm_srli_epi32(uint_vec, shift);\n\n        // Add the results\n        __m128i sum_vec = _mm_add_epi32(arith_shift_vec, logical_shift_vec);\n\n        // Store the result\n        _mm_storeu_si128((__m128i*)&dst[i], sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n\n        // Arithmetic right shift\n        __m128i arith_shift_vec = _mm_srai_epi32(src_vec, shift);\n\n        // Logical right shift\n        __m128i uint_vec = _mm_cvtepi32_epi32(_mm_loadu_si128((const __m128i*)(src + i)));\n        __m128i logical_shift_vec = _mm_srli_epi32(uint_vec, shift);\n\n        // Add the results\n        __m128i sum_vec = _mm_add_epi32(arith_shift_vec, logical_shift_vec);\n\n        // Store the result\n        _mm_storeu_si128((__m128i*)(dst + i), sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n\n        // Arithmetic right shift\n        __m128i arith_shift_vec = _mm_srai_epi32(src_vec, shift);\n\n        // Logical right shift\n        __m128i uint_vec = _mm_cvtepi32_epi32(_mm_loadu_si128((const __m128i*)&src[i])); // Load as int\n        \n        // Convert to unsigned int by adding 2^31 if negative\n        __m128i mask = _mm_cmplt_epi32(src_vec, _mm_setzero_si128());\n        __m128i add_val = _mm_and_si128(mask, _mm_set1_epi32(0x80000000));\n        uint_vec = _mm_add_epi32(src_vec, add_val);\n\n        __m128i logical_shift_vec = _mm_srli_epi32(uint_vec, shift);\n\n        // Add the results\n        __m128i result_vec = _mm_add_epi32(arith_shift_vec, logical_shift_vec);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n\n        // Arithmetic right shift\n        __m128i arith_shift_vec = _mm_srai_epi32(src_vec, shift);\n\n        // Logical right shift\n        __m128i uint_vec = _mm_cvtepi32_epi32(_mm_loadu_si128((const __m128i*)(src + i)));\n        __m128i logical_shift_vec = _mm_srli_epi32(uint_vec, shift);\n\n        // Add the results\n        __m128i sum_vec = _mm_add_epi32(arith_shift_vec, logical_shift_vec);\n\n        // Store the result\n        _mm_storeu_si128((__m128i*)(dst + i), sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n\n        // Arithmetic right shift\n        __m128i arith_shift_vec = _mm_srai_epi32(src_vec, shift);\n\n        // Logical right shift\n        __m128i uint_vec = _mm_cvtepi32_epi32(_mm_loadu_si128((const __m128i*)(src + i)));\n        __m128i logical_shift_vec = _mm_srli_epi32(uint_vec, shift);\n\n        // Add the results\n        __m128i sum_vec = _mm_add_epi32(arith_shift_vec, logical_shift_vec);\n\n        // Store the result\n        _mm_storeu_si128((__m128i*)(dst + i), sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n\n    int64_t total_sum = (int64_t)sum_array[0] + (int64_t)sum_array[1] + (int64_t)sum_array[2] + (int64_t)sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n\n    int64_t total_sum = (int64_t)sum_array[0] + (int64_t)sum_array[1] + (int64_t)sum_array[2] + (int64_t)sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n    int64_t total_sum = (int64_t)sum_array[0] + (int64_t)sum_array[1] + (int64_t)sum_array[2] + (int64_t)sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n\n    int64_t total_sum = (int64_t)sum_array[0] + (int64_t)sum_array[1] + (int64_t)sum_array[2] + (int64_t)sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n\n    int64_t total_sum = (int64_t)sum_array[0] + (int64_t)sum_array[1] + (int64_t)sum_array[2] + (int64_t)sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        __m128i max_val_vec = _mm_set1_epi8(max_value);\n        __m128i index_vec = _mm_set_epi32(3, 2, 1, 0);\n        __m128i increment_vec = _mm_set1_epi32(4);\n        __m128i max_index_vec = _mm_set1_epi32(0);\n\n        for (; i <= length - 16; i += 16) {\n            __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n            __m128i cmp_vec = _mm_cmpgt_epi8(src_vec, max_val_vec);\n            int mask = _mm_movemask_epi8(cmp_vec);\n\n            if (mask != 0) {\n                for (int j = 0; j < 16; ++j) {\n                    if ((mask & (1 << j)) != 0) {\n                        max_value = src[i + j];\n                        max_index = i + j;\n                        max_val_vec = _mm_set1_epi8(max_value);\n                    }\n                }\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        __m128i max_val_vec = _mm_set1_epi8(max_value);\n        __m128i index_vec = _mm_set_epi32(3, 2, 1, 0);\n        __m128i increment_vec = _mm_set1_epi32(4);\n        __m128i max_index_vec = _mm_set1_epi32(0);\n\n        for (; i <= length - 16; i += 16) {\n            __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n            __m128i cmp_vec = _mm_cmpgt_epi8(src_vec, max_val_vec);\n            int mask = _mm_movemask_epi8(cmp_vec);\n\n            if (mask != 0) {\n                for (int j = 0; j < 16; ++j) {\n                    if ((mask & (1 << j)) != 0) {\n                        max_value = src[i + j];\n                        max_index = i + j;\n                        max_val_vec = _mm_set1_epi8(max_value);\n                    }\n                }\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    if (length >= 16) {\n        size_t i = 0;\n        __m128i max_val_vec = _mm_set1_epi8(max_value);\n        __m128i index_vec = _mm_set_epi32(3, 2, 1, 0);\n        __m128i increment_vec = _mm_set1_epi32(4);\n        __m128i max_index_vec = _mm_set1_epi32(0);\n\n        for (; i <= length - 16; i += 16) {\n            __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n            __m128i cmp_vec = _mm_cmpgt_epi8(src_vec, max_val_vec);\n            int mask = _mm_movemask_epi8(cmp_vec);\n\n            if (mask != 0) {\n                for (int j = 0; j < 16; ++j) {\n                    if ((mask & (1 << j)) != 0) {\n                        max_value = src[i + j];\n                        max_index = i + j;\n                    }\n                }\n                max_val_vec = _mm_set1_epi8(max_value);\n            }\n        }\n\n        for (; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    } else {\n        for (size_t i = 1; i < length; ++i) {\n            if (src[i] > max_value) {\n                max_value = src[i];\n                max_index = i;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t i = 0;\n    if (length >= 16) {\n        __m128i max_val_vec = _mm_set1_epi8(max_value);\n        __m128i index_vec = _mm_set_epi32(0, 0, 0, 0);\n        __m128i increment_vec = _mm_set_epi8(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);\n        __m128i current_index_vec = _mm_set_epi64x(i, i);\n\n        for (; i <= length - 16; i += 16) {\n            __m128i data_vec = _mm_loadu_si128((const __m128i *)(src + i));\n            __m128i cmp_result = _mm_cmpgt_epi8(data_vec, max_val_vec);\n\n            if (!_mm_testz_si128(cmp_result, cmp_result)) {\n                unsigned int mask = _mm_movemask_epi8(cmp_result);\n                int local_index = _tzcnt_u32(mask);\n\n                max_value = ((int8_t*) &data_vec)[local_index];\n                max_index = i + local_index;\n                max_val_vec = _mm_set1_epi8(max_value);\n            }\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t i = 0;\n    if (length >= 16) {\n        __m128i max_val_vec = _mm_set1_epi8(max_value);\n        __m128i index_vec = _mm_set_epi32(0, 0, 0, 0);\n        __m128i increment_vec = _mm_set_epi8(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);\n\n        for (; i <= length - 16; i += 16) {\n            __m128i data_vec = _mm_loadu_si128((const __m128i*)(src + i));\n            __m128i cmp_vec = _mm_cmpgt_epi8(data_vec, max_val_vec);\n\n            if (!_mm_testz_si128(cmp_vec, cmp_vec)) {\n                unsigned int mask = _mm_movemask_epi8(cmp_vec);\n                int first_set_bit = _tzcnt_u32(mask);\n\n                max_value = src[i + first_set_bit];\n                max_index = i + first_set_bit;\n                max_val_vec = _mm_set1_epi8(max_value);\n            }\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i idx = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i idx2 = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        uint32_t idx_arr[4];\n        _mm_storeu_si128((__m128i*)idx_arr, idx);\n\n        uint32_t idx_arr2[4];\n        _mm_storeu_si128((__m128i*)idx_arr2, idx2);\n\n        uint16_t blend_mask[8];\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[7-j] = (idx_arr[j] & mask) ? 0xFFFF : 0x0000;\n        }\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[3-j] = (idx_arr2[j] & mask) ? 0xFFFF : 0x0000;\n        }\n\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)blend_mask);\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n\n        __m128i blended_vec = _mm_blendv_epi8(src2_vec, src1_vec, mask_vec);\n\n        _mm_storeu_si128((__m128i*)(dst + i), blended_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i idx = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i idx2 = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        uint32_t idx_arr[4];\n        _mm_storeu_si128((__m128i*)idx_arr, idx);\n\n        uint32_t idx_arr2[4];\n        _mm_storeu_si128((__m128i*)idx_arr2, idx2);\n\n        uint16_t blend_mask[8];\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[j] = (idx_arr2[3-j] & mask) ? 0xFFFF : 0x0000;\n        }\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[j+4] = (idx_arr[3-j] & mask) ? 0xFFFF : 0x0000;\n        }\n\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)blend_mask);\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n\n        __m128i blended_vec = _mm_blendv_epi8(src2_vec, src1_vec, mask_vec);\n\n        _mm_storeu_si128((__m128i*)(dst + i), blended_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i idx = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i idx2 = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        uint32_t idx_arr[4];\n        _mm_storeu_si128((__m128i*)idx_arr, idx);\n\n        uint32_t idx_arr2[4];\n        _mm_storeu_si128((__m128i*)idx_arr2, idx2);\n\n        uint16_t blend_mask[8];\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[j] = (idx_arr2[3-j] & mask) ? 0xFFFF : 0x0000;\n            blend_mask[j+4] = (idx_arr[3-j] & mask) ? 0xFFFF : 0x0000;\n        }\n\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)blend_mask);\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n\n        __m128i blended = _mm_blendv_epi8(src2_vec, src1_vec, mask_vec);\n        _mm_storeu_si128((__m128i*)(dst + i), blended);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i idx = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i idx2 = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        uint32_t indices[4];\n        _mm_storeu_si128((__m128i*)indices, idx);\n        uint32_t indices2[4];\n        _mm_storeu_si128((__m128i*)indices2, idx2);\n\n        uint16_t blend_mask[8];\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[7-j] = (indices[j] & mask) ? 0xFFFF : 0x0000;\n            blend_mask[3-j] = (indices2[j] & mask) ? 0xFFFF : 0x0000;\n        }\n\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)blend_mask);\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n\n        __m128i blended_vec = _mm_blendv_epi8(src2_vec, src1_vec, mask_vec);\n\n        _mm_storeu_si128((__m128i*)(dst + i), blended_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i idx = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i idx2 = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        uint32_t indices[4];\n        _mm_storeu_si128((__m128i*)indices, idx);\n        uint32_t indices2[4];\n        _mm_storeu_si128((__m128i*)indices2, idx2);\n\n        uint16_t blend_mask[8];\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[j] = (indices2[j] & mask) ? 0xFFFF : 0x0000;\n        }\n        for (int j = 0; j < 4; ++j) {\n            blend_mask[j + 4] = (indices[j] & mask) ? 0xFFFF : 0x0000;\n        }\n\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)blend_mask);\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n\n        __m128i blended = _mm_blendv_epi8(src2_vec, src1_vec, mask_vec);\n\n        _mm_storeu_si128((__m128i*)(dst + i), blended);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint32_t source array (src);\n- A pointer to a non-empty uint32_t destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the population count (the number of 1 bits in the binary representation of an integer) \nfor each element in the array.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(src + i));\n        \n        __m128i low_mask = _mm_set1_epi32(0x0F0F0F0F);\n        __m128i high_mask = _mm_set1_epi32(0x00FF00FF);\n        __m128i byte_mask = _mm_set1_epi32(0x0000FFFF);\n\n        __m128i t1 = _mm_and_si128(data, low_mask);\n        __m128i t2 = _mm_srli_epi32(data, 4);\n        t1 = _mm_add_epi32(t1, _mm_and_si128(t2, low_mask));\n\n        __m128i t3 = _mm_and_si128(t1, high_mask);\n        __m128i t4 = _mm_srli_epi32(t1, 8);\n        t3 = _mm_add_epi32(t3, _mm_and_si128(t4, high_mask));\n\n        __m128i t5 = _mm_and_si128(t3, byte_mask);\n        __m128i t6 = _mm_srli_epi32(t3, 16);\n        t5 = _mm_add_epi32(t5, _mm_and_si128(t6, byte_mask));\n\n        _mm_storeu_si128((__m128i*)(dst + i), t5);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t val = src[i];\n        uint32_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF);\n    __m128i count_mask = _mm_set1_epi32(0x1);\n    \n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i popcount = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            __m128i bit = _mm_and_si128(data, mask);\n            popcount = _mm_add_epi32(popcount, _mm_and_si128(bit, count_mask));\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        _mm_storeu_si128((__m128i*)&dst[i], popcount);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint32_t source array (src);\n- A pointer to a non-empty uint32_t destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the population count (the number of 1 bits in the binary representation of an integer) \nfor each element in the array.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(src + i));\n        \n        __m128i low_nibble = _mm_and_si128(data, _mm_set1_epi32(0x0F0F0F0F));\n        __m128i high_nibble = _mm_and_si128(_mm_srli_epi32(data, 4), _mm_set1_epi32(0x0F0F0F0F));\n        __m128i byte_sum = _mm_add_epi32(low_nibble, high_nibble);\n\n        low_nibble = _mm_and_si128(byte_sum, _mm_set1_epi32(0x00FF00FF));\n        high_nibble = _mm_and_si128(_mm_srli_epi32(byte_sum, 8), _mm_set1_epi32(0x00FF00FF));\n        byte_sum = _mm_add_epi32(low_nibble, high_nibble);\n\n        low_nibble = _mm_and_si128(byte_sum, _mm_set1_epi32(0x0000FFFF));\n        high_nibble = _mm_srli_epi32(byte_sum, 16);\n        byte_sum = _mm_add_epi32(low_nibble, high_nibble);\n\n        _mm_storeu_si128((__m128i*)(dst + i), byte_sum);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = _mm_popcnt_u32(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        \n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF);\n    __m128i count_mask = _mm_set1_epi32(0x1);\n    \n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            __m128i bit = _mm_and_si128(data, count_mask);\n            count = _mm_add_epi32(count, bit);\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(src1 + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(src2 + i));\n        __m128i sum = _mm_adds_epu16(a, b);\n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(src1 + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(src2 + i));\n        __m128i sum = _mm_adds_epu16(a, b);\n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(src1 + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(src2 + i));\n        __m128i sum = _mm_adds_epu16(a, b);\n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(src1 + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(src2 + i));\n        __m128i sum = _mm_adds_epu16(a, b);\n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(src1 + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(src2 + i));\n        __m128i sum = _mm_adds_epu16(a, b);\n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    for (; i < length; ++i) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec, b_vec;\n                double a_val1, a_val2, b_val1, b_val2;\n\n                a_val1 = A[i * n + k];\n                if (k + 1 < n) {\n                    a_val2 = A[i * n + k + 1];\n                } else {\n                    a_val2 = 0.0;\n                }\n\n                b_val1 = B[k * p + j];\n                if (k + 1 < n) {\n                    b_val2 = B[(k + 1) * p + j];\n                } else {\n                    b_val2 = 0.0;\n                }\n\n                if (a_val1 >= -100.0 && a_val1 <= 100.0 && b_val1 >= -100.0 && b_val1 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val1 * b_val1));\n                }\n                if (k + 1 < n && a_val2 >= -100.0 && a_val2 <= 100.0 && b_val2 >= -100.0 && b_val2 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val2 * b_val2));\n                }\n            }\n            double temp[2];\n            _mm_storeu_pd(temp, sum_vec);\n            C[i * p + j] += temp[0] + temp[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec, b_vec;\n                double a_val1, a_val2, b_val1, b_val2;\n\n                a_val1 = A[i * n + k];\n                if (k + 1 < n) {\n                    a_val2 = A[i * n + k + 1];\n                } else {\n                    a_val2 = 0.0;\n                }\n\n                b_val1 = B[k * p + j];\n                if (k + 1 < n) {\n                    b_val2 = B[(k + 1) * p + j];\n                } else {\n                    b_val2 = 0.0;\n                }\n\n                if (a_val1 >= -100.0 && a_val1 <= 100.0 && b_val1 >= -100.0 && b_val1 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val1 * b_val1));\n                }\n                if (k + 1 < n && a_val2 >= -100.0 && a_val2 <= 100.0 && b_val2 >= -100.0 && b_val2 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val2 * b_val2));\n                }\n            }\n            double temp[2];\n            _mm_storeu_pd(temp, sum_vec);\n            C[i * p + j] += temp[0] + temp[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec, b_vec;\n                double a_val[2], b_val[2];\n\n                if (k < n) {\n                    a_val[0] = A[i * n + k];\n                    b_val[0] = B[k * p + j];\n                } else {\n                    a_val[0] = 0.0;\n                    b_val[0] = 0.0;\n                }\n\n                if (k + 1 < n) {\n                    a_val[1] = A[i * n + k + 1];\n                    b_val[1] = B[(k + 1) * p + j];\n                } else {\n                    a_val[1] = 0.0;\n                    b_val[1] = 0.0;\n                }\n\n                a_vec = _mm_loadu_pd(a_val);\n                b_vec = _mm_loadu_pd(b_val);\n\n                __m128d lower_bound = _mm_set1_pd(-100.0);\n                __m128d upper_bound = _mm_set1_pd(100.0);\n\n                __m128d a_mask_lower = _mm_cmpge_pd(a_vec, lower_bound);\n                __m128d a_mask_upper = _mm_cmple_pd(a_vec, upper_bound);\n                __m128d a_mask = _mm_and_pd(a_mask_lower, a_mask_upper);\n\n                __m128d b_mask_lower = _mm_cmpge_pd(b_vec, lower_bound);\n                __m128d b_mask_upper = _mm_cmple_pd(b_vec, upper_bound);\n                __m128d b_mask = _mm_and_pd(b_mask_lower, b_mask_upper);\n\n                __m128d combined_mask = _mm_and_pd(a_mask, b_mask);\n\n                __m128d mul_vec = _mm_mul_pd(a_vec, b_vec);\n                mul_vec = _mm_and_pd(mul_vec, combined_mask);\n\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n            }\n\n            double sum_arr[2];\n            _mm_storeu_pd(sum_arr, sum_vec);\n            C[i * p + j] = sum_arr[0] + sum_arr[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec, b_vec;\n                double a_val1, a_val2, b_val1, b_val2;\n\n                a_val1 = A[i * n + k];\n                if (k + 1 < n) {\n                    a_val2 = A[i * n + k + 1];\n                } else {\n                    a_val2 = 0.0;\n                }\n\n                b_val1 = B[k * p + j];\n                if (k + 1 < n) {\n                    b_val2 = B[(k + 1) * p + j];\n                } else {\n                    b_val2 = 0.0;\n                }\n\n                if (a_val1 >= -100.0 && a_val1 <= 100.0 && b_val1 >= -100.0 && b_val1 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val1 * b_val1));\n                }\n                if (k + 1 < n && a_val2 >= -100.0 && a_val2 <= 100.0 && b_val2 >= -100.0 && b_val2 <= 100.0) {\n                    sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(a_val2 * b_val2));\n                }\n            }\n            double temp[2];\n            _mm_storeu_pd(temp, sum_vec);\n            C[i * p + j] += temp[0] + temp[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec, b_vec;\n                double a_val[2], b_val[2];\n\n                if (k < n) {\n                    a_val[0] = A[i * n + k];\n                    b_val[0] = B[k * p + j];\n                } else {\n                    a_val[0] = 0.0;\n                    b_val[0] = 0.0;\n                }\n\n                if (k + 1 < n) {\n                    a_val[1] = A[i * n + k + 1];\n                    b_val[1] = B[(k + 1) * p + j];\n                } else {\n                    a_val[1] = 0.0;\n                    b_val[1] = 0.0;\n                }\n\n                a_vec = _mm_loadu_pd(a_val);\n                b_vec = _mm_loadu_pd(b_val);\n\n                __m128d within_range_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n\n                __m128d within_range_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n\n                __m128d within_range = _mm_and_pd(within_range_a, within_range_b);\n\n                __m128d mul_vec = _mm_mul_pd(a_vec, b_vec);\n                mul_vec = _mm_and_pd(mul_vec, within_range);\n\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n            }\n\n            double sum_arr[2];\n            _mm_storeu_pd(sum_arr, sum_vec);\n            C[i * p + j] = sum_arr[0] + sum_arr[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks of 2 (128 bits)\n    for (; i + 1 < total_elements; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), sum);\n    }\n\n    // Process remaining elements if the total number of elements is odd\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks of 2 (128 bits) using SSE2\n    for (; i + 1 < total_elements; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), sum);\n    }\n\n    // Handle remaining element if the total number of elements is odd\n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks of 2 (128 bits) using SSE2 intrinsics\n    for (; i + 1 < total_elements; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), sum);\n    }\n\n    // Handle remaining elements if the total number of elements is odd\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks of 2 (128 bits) using SSE2\n    for (; i + 1 < total_elements; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((const __m128i*)&B[i]);\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], sum);\n    }\n\n    // Handle remaining element if the total number of elements is odd\n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks of 2 (128 bits) using SSE2\n    for (; i + 1 < total_elements; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), sum);\n    }\n\n    // Handle remaining element if the total number of elements is odd\n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(&src1[i]);\n        __m128 b = _mm_loadu_ps(&src2[i]);\n        __m128 sum = _mm_add_ps(a, b);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(src1 + i);\n        __m128 b = _mm_loadu_ps(src2 + i);\n        __m128 sum = _mm_add_ps(a, b);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(src1 + i);\n        __m128 b = _mm_loadu_ps(src2 + i);\n        __m128 sum = _mm_add_ps(a, b);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(&src1[i]);\n        __m128 b = _mm_loadu_ps(&src2[i]);\n        __m128 sum = _mm_add_ps(a, b);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(src1 + i);\n        __m128 b = _mm_loadu_ps(src2 + i);\n        __m128 sum = _mm_add_ps(a, b);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise multiplication of src1 and src2\nfor elements that meet the following conditions:\n    1: the absolute value of the difference is within 50;\n    2: index is is a multiple of 2.\nand then round the result up toward positive infinity.\nFor elements that do not meet the above conditions, the results should be -1.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    __m128 diff_abs, mul, result, src1_vec, src2_vec, mask, neg_one;\n    __m128 threshold = _mm_set1_ps(50.0f);\n    neg_one = _mm_set1_ps(-1.0f);\n\n    for (; i + 4 <= length; i += 4) {\n        src1_vec = _mm_loadu_ps(&src1[i]);\n        src2_vec = _mm_loadu_ps(&src2[i]);\n\n        __m128 diff = _mm_sub_ps(src1_vec, src2_vec);\n        diff_abs = _mm_and_ps(diff, _mm_set1_ps(*(float*)&(int){0x7fffffff}));\n\n        mask = _mm_cmplt_ps(diff_abs, threshold);\n\n        if ((i % 2) != 0)\n        {\n            mask = _mm_and_ps(mask, _mm_set_ps(0.0f, 1.0f, 0.0f, 1.0f));\n        }\n        else\n        {\n            mask = _mm_and_ps(mask, _mm_set1_ps(1.0f));\n        }\n\n        mul = _mm_mul_ps(src1_vec, src2_vec);\n\n        int rounding_mode = _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC;\n        result = _mm_round_ps(mul, rounding_mode);\n\n        result = _mm_blendv_ps(neg_one, result, mask);\n\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise multiplication of src1 and src2\nfor elements that meet the following conditions:\n    1: the absolute value of the difference is within 50;\n    2: index is is a multiple of 2.\nand then round the result up toward positive infinity.\nFor elements that do not meet the above conditions, the results should be -1.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    __m128 diff_abs, mul, result, src1_vec, src2_vec, neg_one;\n    __m128 threshold = _mm_set1_ps(50.0f);\n\n    neg_one = _mm_set1_ps(-1.0f);\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        src1_vec = _mm_loadu_ps(&src1[i]);\n        src2_vec = _mm_loadu_ps(&src2[i]);\n\n        __m128 diff = _mm_sub_ps(src1_vec, src2_vec);\n        diff_abs = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7fffffff)));\n\n        __m128 mask = _mm_cmplt_ps(diff_abs, threshold);\n\n        // Check if the index is a multiple of 2\n        if ((i % 2) == 0) {\n            mul = _mm_mul_ps(src1_vec, src2_vec);\n\n            // Round towards positive infinity\n            _mm_setcsr(_mm_getcsr() | (1 << 13));\n            result = _mm_round_ps(mul, _MM_FROUND_CEIL);\n            _mm_setcsr(_mm_getcsr() & ~(1 << 13));\n\n            // Apply the mask\n            __m128 final_result = _mm_blendv_ps(neg_one, result, mask);\n            _mm_storeu_ps(&dst[i], final_result);\n        } else {\n            _mm_storeu_ps(&dst[i], neg_one);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if ((i % 2) == 0) {\n            float diff = src1[i] - src2[i];\n            float abs_diff = (diff > 0) ? diff : -diff;\n\n            if (abs_diff <= 50.0f) {\n                float mul_res = src1[i] * src2[i];\n                dst[i] = ceilf(mul_res);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        __m128 v_src1 = _mm_loadu_ps(&src1[i]);\n        __m128 v_src2 = _mm_loadu_ps(&src2[i]);\n\n        __m128 v_diff = _mm_sub_ps(v_src1, v_src2);\n        v_diff = _mm_and_ps(v_diff, _mm_set1_ps(-1.0f)); // Get absolute value\n        v_diff = _mm_max_ps(v_diff, _mm_set1_ps(50.0f)); // Compare with 50\n\n        __m128 v_mask = _mm_cmple_ps(v_diff, _mm_set1_ps(50.0f)); // Mask for condition 1\n        __m128 v_index_mask = _mm_set1_ps(0.0f);\n        if (i % 2 == 0) {\n            v_index_mask = _mm_set1_ps(1.0f); // Mask for condition 2\n        }\n\n        v_mask = _mm_and_ps(v_mask, v_index_mask); // Combine both conditions\n\n        __m128 v_result = _mm_mul_ps(v_src1, v_src2); // Element-wise multiplication\n        v_result = _mm_round_ps(v_result, _MM_FROUND_UP); // Round up\n\n        v_result = _mm_blendv_ps(_mm_set1_ps(-1.0f), v_result, v_mask); // Apply mask\n\n        _mm_storeu_ps(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        __m128 v_src1 = _mm_loadu_ps(&src1[i]);\n        __m128 v_src2 = _mm_loadu_ps(&src2[i]);\n        \n        __m128 v_diff = _mm_sub_ps(v_src1, v_src2);\n        v_diff = _mm_and_ps(v_diff, _mm_set1_ps(-1.0f)); // Get absolute value\n        v_diff = _mm_max_ps(v_diff, _mm_sub_ps(v_src2, v_src1)); // Absolute value\n        \n        __m128 v_mask = _mm_cmple_ps(v_diff, _mm_set1_ps(50.0f));\n        \n        __m128 v_result = _mm_mul_ps(v_src1, v_src2);\n        v_result = _mm_round_ps(v_result, _MM_FROUND_UP); // Round up\n        \n        __m128 v_neg_one = _mm_set1_ps(-1.0f);\n        v_result = _mm_blendv_ps(v_neg_one, v_result, v_mask);\n        \n        if (i % 2 == 0) {\n            _mm_storeu_ps(&dst[i], v_result);\n        } else {\n            _mm_storeu_ps(&dst[i], v_neg_one);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        __m128 v_src1 = _mm_loadu_ps(&src1[i]);\n        __m128 v_src2 = _mm_loadu_ps(&src2[i]);\n        \n        __m128 v_diff = _mm_sub_ps(v_src1, v_src2);\n        __m128 v_abs_diff = _mm_and_ps(v_diff, _mm_set1_ps(-0.0f)); // Absolute value\n        v_abs_diff = _mm_max_ps(v_abs_diff, _mm_sub_ps(v_diff, _mm_and_ps(v_diff, _mm_set1_ps(-0.0f)))); // Correcting for negative\n        \n        __m128 v_condition = _mm_cmple_ps(v_abs_diff, _mm_set1_ps(50.0f));\n        \n        __m128 v_result = _mm_mul_ps(v_src1, v_src2);\n        v_result = _mm_round_ps(v_result, _MM_FROUND_UP);\n        \n        __m128 v_neg_one = _mm_set1_ps(-1.0f);\n        v_result = _mm_blendv_ps(v_neg_one, v_result, v_condition);\n        \n        _mm_storeu_ps(&dst[i], v_result);\n    }\n    \n    for (; i < length; ++i) {\n        if (i % 2 == 0) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if (diff <= 50.0f) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n\n    size_t i;\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point source matrix (mat);\n- A scalar value in 64-bit floating-point (scalar);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nmat and dst are 2D matrices flattened into 1D arrays.\nYour goal is to calculate the result of the element-wise multiplication of mat and scalar,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            if (j + 1 < n) {\n                __m128d mat_vec = _mm_loadu_pd(mat + i * n + j);\n                __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n                _mm_storeu_pd(dst + i * n + j, result_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point source matrix (mat);\n- A scalar value in 64-bit floating-point (scalar);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nmat and dst are 2D matrices flattened into 1D arrays.\nYour goal is to calculate the result of the element-wise multiplication of mat and scalar,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            if (j + 1 < n) {\n                __m128d mat_vec = _mm_loadu_pd(mat + i * n + j);\n                __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n                _mm_storeu_pd(dst + i * n + j, result_vec);\n            } else {\n                dst[i * n + j] = mat[i * n + j] * scalar;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_sq = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n            sum_sq = _mm_add_ps(sum_sq, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float sum_sq_arr[4];\n        _mm_storeu_ps(sum_sq_arr, sum_sq);\n        float row_norm_sq = sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n\n        for (; j < n; ++j) {\n            row_norm_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float row_norm = sqrtf(row_norm_sq);\n\n        if (row_norm > 0.0f) {\n            __m128 norm_vec = _mm_set1_ps(row_norm);\n            j = 0;\n            for (; j + 4 <= n; j += 4) {\n                __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n                __m128 normalized_vec = _mm_div_ps(row_vec, norm_vec);\n                _mm_storeu_ps(mat + i * n + j, normalized_vec);\n            }\n\n            for (; j < n; ++j) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_sq = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n            sum_sq = _mm_add_ps(sum_sq, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float sum_sq_arr[4];\n        _mm_storeu_ps(sum_sq_arr, sum_sq);\n        float row_norm_sq = sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n\n        for (; j < n; ++j) {\n            row_norm_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float row_norm = sqrtf(row_norm_sq);\n\n        if (row_norm > 0.0f) {\n            j = 0;\n            for (; j + 4 <= n; j += 4) {\n                __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n                __m128 norm_vec = _mm_set1_ps(row_norm);\n                __m128 normalized_vec = _mm_div_ps(row_vec, norm_vec);\n                _mm_storeu_ps(mat + i * n + j, normalized_vec);\n            }\n\n            for (; j < n; ++j) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_sq = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n            sum_sq = _mm_add_ps(sum_sq, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float sum_sq_arr[4];\n        _mm_storeu_ps(sum_sq_arr, sum_sq);\n        float row_norm_sq = sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n\n        for (; j < n; ++j) {\n            row_norm_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float row_norm = sqrtf(row_norm_sq);\n\n        if (row_norm > 0.0f) {\n            __m128 norm_vec = _mm_set1_ps(row_norm);\n            j = 0;\n            for (; j + 4 <= n; j += 4) {\n                __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n                __m128 normalized_vec = _mm_div_ps(row_vec, norm_vec);\n                _mm_storeu_ps(mat + i * n + j, normalized_vec);\n            }\n\n            for (; j < n; ++j) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_sq = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n            sum_sq = _mm_add_ps(sum_sq, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float sum_sq_arr[4];\n        _mm_storeu_ps(sum_sq_arr, sum_sq);\n        float row_norm_sq = sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n\n        for (; j < n; ++j) {\n            row_norm_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float row_norm = sqrtf(row_norm_sq);\n\n        if (row_norm > 0.0f) {\n            j = 0;\n            for (; j + 4 <= n; j += 4) {\n                __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n                __m128 norm_vec = _mm_set1_ps(row_norm);\n                __m128 normalized_vec = _mm_div_ps(row_vec, norm_vec);\n                _mm_storeu_ps(mat + i * n + j, normalized_vec);\n            }\n            for (; j < n; ++j) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_sq = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n            sum_sq = _mm_add_ps(sum_sq, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float sum_sq_arr[4];\n        _mm_storeu_ps(sum_sq_arr, sum_sq);\n        float row_norm_sq = sum_sq_arr[0] + sum_sq_arr[1] + sum_sq_arr[2] + sum_sq_arr[3];\n\n        for (; j < n; ++j) {\n            row_norm_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float row_norm = sqrtf(row_norm_sq);\n\n        if (row_norm > 0.0f) {\n            __m128 norm_vec = _mm_set1_ps(row_norm);\n            j = 0;\n            for (; j + 4 <= n; j += 4) {\n                __m128 row_vec = _mm_loadu_ps(mat + i * n + j);\n                __m128 normalized_vec = _mm_div_ps(row_vec, norm_vec);\n                _mm_storeu_ps(mat + i * n + j, normalized_vec);\n            }\n            for (; j < n; ++j) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b;\n                if (k + 1 < n) {\n                    b = _mm_loadu_pd(&mat2[k * p + j]);\n                } else {\n                    b = _mm_set_pd(mat2[k * p + j], 0.0);\n                }\n\n                __m128d shuf = _mm_shuffle_pd(b, b, 1);\n                __m128d mul1 = _mm_mul_pd(a, b);\n                __m128d mul2 = _mm_mul_pd(a, shuf);\n\n                sum_vec = _mm_add_pd(sum_vec, mul1);\n                if (k + 1 < n) {\n                    sum_vec = _mm_add_pd(sum_vec, mul2);\n                }\n            }\n\n            double sum[2];\n            _mm_storeu_pd(sum, sum_vec);\n            double total_sum = sum[0] + sum[1];\n            dst[i * p + j] = round(total_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b;\n                if (k + 1 < n) {\n                    b = _mm_loadu_pd(&mat2[k * p + j]);\n                } else {\n                    b = _mm_set_pd(mat2[k * p + j], 0.0);\n                }\n\n                __m128d shuf = _mm_shuffle_pd(b, b, _MM_SHUFFLE2(0, 0, 0, 0));\n                __m128d mul1 = _mm_mul_pd(a, b);\n\n                if (k + 1 < n) {\n                    __m128d a_next;\n                    if (k + 1 < n) {\n                        a_next = _mm_shuffle_pd(a, a, _MM_SHUFFLE2(1, 1, 1, 1));\n                    } else {\n                        a_next = _mm_setzero_pd();\n                    }\n                    __m128d mul2 = _mm_mul_pd(a_next, shuf);\n                    sum_vec = _mm_add_pd(sum_vec, _mm_add_pd(mul1, mul2));\n                } else {\n                    sum_vec = _mm_add_pd(sum_vec, mul1);\n                }\n            }\n\n            double sum[2];\n            _mm_storeu_pd(sum, sum_vec);\n            double total_sum = sum[0] + sum[1];\n            dst[i * p + j] = round(total_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b;\n                if (k + 1 < n) {\n                    b = _mm_loadu_pd(&mat2[k * p + j]);\n                } else {\n                    b = _mm_set_pd(mat2[k * p + j], 0.0);\n                }\n\n                __m128d shuf = _mm_shuffle_pd(b, b, _MM_SHUFFLE2(0, 0, 0, 0));\n                __m128d mul = _mm_mul_pd(a, shuf);\n                sum_vec = _mm_add_pd(sum_vec, mul);\n\n                if (k + 1 < n) {\n                    __m128d a2 = _mm_set_pd(mat1[i * n + k + 1], 0.0);\n                    __m128d b2 = _mm_set_pd(mat2[(k + 1) * p + j], 0.0);\n                    __m128d mul2 = _mm_mul_pd(a2, b2);\n                    sum_vec = _mm_add_sd(sum_vec, mul2);\n                }\n            }\n\n            double sum[2];\n            _mm_storeu_pd(sum, sum_vec);\n            double total_sum = sum[0] + sum[1];\n            dst[i * p + j] = round(total_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b;\n                if (k + 1 < n) {\n                    b = _mm_loadu_pd(&mat2[k * p + j]);\n                } else {\n                    b = _mm_set_pd(mat2[k * p + j], 0.0);\n                }\n\n                __m128d shuf = _mm_shuffle_pd(b, b, 1);\n                __m128d mul1 = _mm_mul_pd(a, b);\n                __m128d mul2 = _mm_mul_pd(a, shuf);\n                sum_vec = _mm_add_pd(sum_vec, mul1);\n            }\n\n            double sum_arr[2];\n            _mm_storeu_pd(sum_arr, sum_vec);\n            double sum = sum_arr[0] + sum_arr[1];\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b;\n                if (k + 1 < n) {\n                    b = _mm_loadu_pd(&mat2[k * p + j]);\n                } else {\n                    b = _mm_set_pd(mat2[k * p + j], 0.0);\n                }\n\n                __m128d shuf = _mm_shuffle_pd(b, b, _MM_SHUFFLE2(0, 0, 0, 0));\n                __m128d mul1 = _mm_mul_pd(a, b);\n\n                if (k + 1 < n) {\n                    __m128d a2 = _mm_shuffle_pd(a, a, _MM_SHUFFLE2(1, 1, 1, 1));\n                    __m128d mul2 = _mm_mul_pd(a2, shuf);\n                    sum_vec = _mm_add_pd(sum_vec, _mm_add_pd(mul1, mul2));\n                } else {\n                    sum_vec = _mm_add_pd(sum_vec, mul1);\n                }\n            }\n\n            double sum[2];\n            _mm_storeu_pd(sum, sum_vec);\n            double total_sum = sum[0] + sum[1];\n            dst[i * p + j] = round(total_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += 4) {\n            __m128 row_values;\n            if (cols - j >= 4) {\n                row_values = _mm_loadu_ps(src + i * cols + j);\n            } else {\n                float temp[4] = {0.0f, 0.0f, 0.0f, 0.0f};\n                for (size_t k = 0; k < cols - j; ++k) {\n                    temp[k] = src[i * cols + j + k];\n                }\n                row_values = _mm_loadu_ps(temp);\n            }\n\n            __m128 col1 = _mm_set_ps(src[i * cols + j + 3], src[i * cols + j + 2], src[i * cols + j + 1], src[i * cols + j]);\n\n            float rounded_values[4];\n            rounded_values[0] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n            rounded_values[1] = roundf(src[i * cols + j + 1] * 4.0f) / 4.0f;\n            rounded_values[2] = roundf(src[i * cols + j + 2] * 4.0f) / 4.0f;\n            rounded_values[3] = roundf(src[i * cols + j + 3] * 4.0f) / 4.0f;\n\n            if (cols - j >= 4) {\n                dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n                dst[(j + 1) * rows + i] = roundf(src[i * cols + j + 1] * 4.0f) / 4.0f;\n                dst[(j + 2) * rows + i] = roundf(src[i * cols + j + 2] * 4.0f) / 4.0f;\n                dst[(j + 3) * rows + i] = roundf(src[i * cols + j + 3] * 4.0f) / 4.0f;\n            } else {\n                for (size_t k = 0; k < cols - j; ++k) {\n                    dst[(j + k) * rows + i] = roundf(src[i * cols + j + k] * 4.0f) / 4.0f;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += 4) {\n            __m128 row_values;\n            row_values = _mm_loadu_ps(src + i * cols + j);\n\n            float rounded_values[4];\n            rounded_values[0] = roundf(row_values[0] * 4.0f) / 4.0f;\n            rounded_values[1] = roundf(row_values[1] * 4.0f) / 4.0f;\n            rounded_values[2] = roundf(row_values[2] * 4.0f) / 4.0f;\n            rounded_values[3] = roundf(row_values[3] * 4.0f) / 4.0f;\n\n            dst[j * rows + i] = rounded_values[0];\n            if (j + 1 < cols) dst[(j + 1) * rows + i] = rounded_values[1];\n            if (j + 2 < cols) dst[(j + 2) * rows + i] = rounded_values[2];\n            if (j + 3 < cols) dst[(j + 3) * rows + i] = rounded_values[3];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += 4) {\n            __m128 row_values;\n            row_values = _mm_loadu_ps(src + i * cols + j);\n\n            float rounded_values[4];\n            rounded_values[0] = roundf(row_values[0] * 4.0f) / 4.0f;\n            rounded_values[1] = roundf(row_values[1] * 4.0f) / 4.0f;\n            rounded_values[2] = roundf(row_values[2] * 4.0f) / 4.0f;\n            rounded_values[3] = roundf(row_values[3] * 4.0f) / 4.0f;\n\n            dst[j * rows + i] = rounded_values[0];\n            if (j + 1 < cols) dst[(j + 1) * rows + i] = rounded_values[1];\n            if (j + 2 < cols) dst[(j + 2) * rows + i] = rounded_values[2];\n            if (j + 3 < cols) dst[(j + 3) * rows + i] = rounded_values[3];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += 4) {\n            __m128 row_values;\n            if (cols - j >= 4) {\n                row_values = _mm_loadu_ps(src + i * cols + j);\n            } else {\n                float temp[4] = {0.0f, 0.0f, 0.0f, 0.0f};\n                for (size_t k = 0; k < cols - j; ++k) {\n                    temp[k] = src[i * cols + j + k];\n                }\n                row_values = _mm_loadu_ps(temp);\n            }\n\n            __m128 col1 = _mm_set_ps(src[i * cols + j + 3], src[i * cols + j + 2], src[i * cols + j + 1], src[i * cols + j]);\n\n            float rounded_values[4];\n            rounded_values[0] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n            rounded_values[1] = roundf(src[i * cols + j + 1] * 4.0f) / 4.0f;\n            rounded_values[2] = roundf(src[i * cols + j + 2] * 4.0f) / 4.0f;\n            rounded_values[3] = roundf(src[i * cols + j + 3] * 4.0f) / 4.0f;\n\n            for (size_t k = 0; k < 4 && j + k < cols; ++k) {\n                dst[(j + k) * rows + i] = roundf(src[i * cols + j + k] * 4.0f) / 4.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    const size_t SIMD_SIZE = 4;\n\n    // Precompute constants for rounding\n    __m128 quarter = _mm_set1_ps(0.25f);\n    __m128 half = _mm_set1_ps(0.5f);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols; j += SIMD_SIZE) {\n            // Load 4 elements from the source matrix\n            __m128 row_values;\n            if (cols - j >= SIMD_SIZE) {\n                row_values = _mm_loadu_ps(src + i * cols + j);\n            } else {\n                float temp[SIMD_SIZE];\n                for (size_t k = 0; k < SIMD_SIZE; ++k) {\n                    if (j + k < cols) {\n                        temp[k] = src[i * cols + j + k];\n                    } else {\n                        temp[k] = 0.0f; // Pad with 0 if out of bounds\n                    }\n                }\n                row_values = _mm_loadu_ps(temp);\n            }\n\n            // Round to the nearest quarter\n            row_values = _mm_add_ps(row_values, half);\n            row_values = _mm_mul_ps(row_values, _mm_set1_ps(4.0f));\n            row_values = _mm_round_ps(row_values, _MM_FROUND_TO_NEAREST_INT);\n            row_values = _mm_mul_ps(row_values, quarter);\n\n            // Transpose and store in the destination matrix\n            float temp[SIMD_SIZE];\n            _mm_storeu_ps(temp, row_values);\n\n            for (size_t k = 0; k < SIMD_SIZE; ++k) {\n                if (j + k < cols) {\n                    dst[(j + k) * rows + i] = temp[k];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process the array in chunks of 4 floats using SSE intrinsics\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2 into SSE registers\n        __m128 t1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 t2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract tensor2 from tensor1\n        __m128 diff = _mm_sub_ps(t1, t2);\n\n        // Round towards zero\n        __m128 abs_val = _mm_fabs_ps(diff);\n        __m128 rounded = _mm_roundscale_ps(abs_val, _MM_FROUND_TO_ZERO);\n        __m128 sign_mask = _mm_cmpge_ps(diff, _mm_setzero_ps());\n        __m128 result = _mm_blendv_ps(_mm_sub_ps(_mm_setzero_ps(), rounded), rounded, sign_mask);\n\n        // Store the result in the destination tensor\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    // Process any remaining elements\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff > 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from each tensor into SSE registers\n        __m128 t1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 t2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract the two SSE registers\n        __m128 diff = _mm_sub_ps(t1, t2);\n\n        // Round towards zero\n        __m128 abs_val = _mm_and_ps(diff, _mm_set1_ps(0x7fffffff)); // Absolute value\n        __m128 rounded = _mm_cvttps_ps(_mm_cvttps_epi32(abs_val)); // Truncate towards zero\n        __m128 sign = _mm_and_ps(diff, _mm_set1_ps(0x80000000));    // Extract sign bit\n        rounded = _mm_or_ps(rounded, sign);                         // Apply sign\n\n        // Store the result in the destination tensor\n        _mm_storeu_ps(&dst[i], rounded);\n    }\n\n    // Process the remaining elements (less than 4)\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff > 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2 into SSE registers\n        __m128 t1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 t2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract tensor2 from tensor1\n        __m128 diff = _mm_sub_ps(t1, t2);\n\n        // Round towards zero\n        __m128 abs_val = _mm_and_ps(diff, _mm_set1_ps(0x7FFFFFFF)); // abs(x)\n        __m128 sign_mask = _mm_cmpge_ps(diff, _mm_setzero_ps()); // x >= 0 ? 0xFFFFFFFF : 0x00000000\n        __m128 rounded = _mm_cvttps_ps(diff); // Truncate towards zero\n\n        _mm_storeu_ps(&dst[i], rounded);\n    }\n\n    // Process the remaining elements one by one\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process the array in chunks of 4 floats using SSE intrinsics\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2 into SSE registers\n        __m128 t1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 t2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract tensor2 from tensor1\n        __m128 diff = _mm_sub_ps(t1, t2);\n\n        // Round towards zero using SSE4.1 intrinsics (if available)\n        // Otherwise, use a software implementation\n#ifdef __SSE4_1__\n        diff = _mm_round_ps(diff, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC);\n#else\n        // Software implementation of round towards zero\n        float temp[4];\n        _mm_storeu_ps(temp, diff);\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                temp[j] = floorf(temp[j]);\n            } else {\n                temp[j] = ceilf(temp[j]);\n            }\n        }\n        diff = _mm_loadu_ps(temp);\n#endif\n\n        // Store the result in the destination tensor\n        _mm_storeu_ps(&dst[i], diff);\n    }\n\n    // Process any remaining elements\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff > 0.0f) {\n            dst[i] = floorf(diff);\n        } else {\n            dst[i] = ceilf(diff);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2 into SSE registers\n        __m128 t1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 t2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract tensor2 from tensor1\n        __m128 sub_result = _mm_sub_ps(t1, t2);\n\n        // Round towards zero\n        __m128 abs_val = _mm_abs_ps(sub_result);\n        __m128 rounded = _mm_floor_ps(abs_val);\n        __m128 sign = _mm_cmpge_ps(sub_result, _mm_setzero_ps());\n        __m128 result = _mm_xor_ps(rounded, _mm_andnot_ps(sign, _mm_set1_ps(-0.0f)));\n\n        // Store the result in the destination tensor\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    // Process the remaining elements (less than 4)\n    for (; i < total_elements; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        dst[i] = (sub_result >= 0) ? floorf(sub_result) : ceilf(sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i + 3 < total_elements; i += 4) {\n        __m128d a1 = _mm_load_pd(&mat1[i]);\n        __m128d a2 = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a1, a2);\n        _mm_store_pd(&dst[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        __m128 sum_vec = _mm_setzero_ps();\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(mat + i * n + j);\n            __m128 vec_vec = _mm_loadu_ps(vec + j);\n            sum_vec = _mm_add_ps(sum_vec, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        float sum_arr[4];\n        _mm_storeu_ps(sum_arr, sum_vec);\n        float sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        __m128 sum_vec = _mm_setzero_ps();\n        size_t j_simd_end = n - (n % 4);\n        for (j = 0; j < j_simd_end; j += 4) {\n            __m128 mat_row_vec = _mm_loadu_ps(mat + i * n + j);\n            __m128 vec_elem_vec = _mm_loadu_ps(vec + j);\n            sum_vec = _mm_add_ps(sum_vec, _mm_mul_ps(mat_row_vec, vec_elem_vec));\n        }\n        float sum_arr[4];\n        _mm_storeu_ps(sum_arr, sum_vec);\n        float row_sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n\n        for (j = j_simd_end; j < n; ++j) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        __m128 sum_vec = _mm_setzero_ps();\n        size_t j_simd_end = n - (n % 4);\n        for (j = 0; j < j_simd_end; j += 4) {\n            __m128 mat_row_vec = _mm_loadu_ps(mat + i * n + j);\n            __m128 vec_elem_vec = _mm_loadu_ps(vec + j);\n            sum_vec = _mm_add_ps(sum_vec, _mm_mul_ps(mat_row_vec, vec_elem_vec));\n        }\n\n        float sum_arr[4];\n        _mm_storeu_ps(sum_arr, sum_vec);\n        float row_sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n\n        for (j = j_simd_end; j < n; ++j) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        __m128 sum_vec = _mm_setzero_ps();\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(mat + i * n + j);\n            __m128 vec_vec = _mm_loadu_ps(vec + j);\n            sum_vec = _mm_add_ps(sum_vec, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        float sum_arr[4];\n        _mm_storeu_ps(sum_arr, sum_vec);\n        float sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum_arr[2];\n    _mm_storeu_pd(sum_arr, sum_vec);\n    double total_sum = sum_arr[0] + sum_arr[1];\n\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum_arr[2];\n    _mm_storeu_pd(sum_arr, sum_vec);\n    double total_sum = sum_arr[0] + sum_arr[1];\n\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum_arr[2];\n    _mm_storeu_pd(sum_arr, sum_vec);\n    double total_sum = sum_arr[0] + sum_arr[1];\n\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum_arr[2];\n    _mm_storeu_pd(sum_arr, sum_vec);\n    double total_sum = sum_arr[0] + sum_arr[1];\n\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum_arr[2];\n    _mm_storeu_pd(sum_arr, sum_vec);\n    double total_sum = sum_arr[0] + sum_arr[1];\n\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i current = _mm_loadu_si128((const __m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((const __m128i*)(row + j + 1));\n\n            __m128i gt = _mm_cmpgt_epi32(current, next);\n\n            if (ascending) {\n                if (!_mm_testz_si128(gt, gt)) {\n                    return false;\n                }\n            } else {\n                __m128i lt = _mm_cmplt_epi32(current, next);\n                if (!_mm_testz_si128(lt, lt)) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i current = _mm_loadu_si128((const __m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((const __m128i*)(row + j + 1));\n\n            if (ascending) {\n                __m128i cmp = _mm_cmplt_epi32(next, current);\n                if (_mm_movemask_epi8(cmp) != 0) {\n                    return false;\n                }\n            } else {\n                __m128i cmp = _mm_cmpgt_epi32(next, current);\n                if (_mm_movemask_epi8(cmp) != 0) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i current = _mm_loadu_si128((const __m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((const __m128i*)(row + j + 1));\n\n            __m128i gt = _mm_cmpgt_epi32(current, next);\n\n            if (ascending) {\n                if (!_mm_testz_si128(gt, gt)) {\n                    return false;\n                }\n            } else {\n                __m128i lt = _mm_cmplt_epi32(current, next);\n                if (!_mm_testz_si128(lt, lt)) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i current = _mm_loadu_si128((const __m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((const __m128i*)(row + j + 1));\n\n            __m128i gt = _mm_cmpgt_epi32(current, next);\n            int mask = _mm_movemask_epi8(gt);\n\n            if (ascending) {\n                if (mask != 0) return false;\n            } else {\n                if (mask != 0xF) return false;\n            }\n        }\n\n        for (size_t j = cols - (cols % 4 == 0 ? 4 : cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) return false;\n            } else {\n                if (row[j] < row[j + 1]) return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i current = _mm_loadu_si128((const __m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((const __m128i*)(row + j + 1));\n\n            __m128i gt = _mm_cmpgt_epi32(current, next);\n            int mask = _mm_movemask_epi8(gt);\n\n            if (ascending) {\n                if (mask != 0) return false;\n            } else {\n                if (mask != 0xF) return false;\n            }\n        }\n\n        for (size_t j = cols - (cols % 4 == 0 ? 4 : cols % 4); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) return false;\n            } else {\n                if (row[j] < row[j + 1]) return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    __m128i base_vec = _mm_set1_epi16(base);\n\n    for (; i + 8 <= length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i temp_vec = _mm_srai_epi16(src_vec, 15);\n        __m128i base_signed_vec = _mm_or_si128(base_vec, _mm_and_si128(temp_vec, base_vec));\n        __m128i div_vec = _mm_div_epi16(src_vec, base_signed_vec);\n        __m128i mul_vec = _mm_mullo_epi16(div_vec, base_signed_vec);\n        _mm_storeu_si128((__m128i*)(dst + i), mul_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    __m128i base_vec = _mm_set1_epi16(base);\n\n    for (; i + 8 <= length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i temp_vec = _mm_srai_epi16(src_vec, 15);\n        __m128i base_signed = _mm_or_si128(base_vec, _mm_and_si128(temp_vec, base_vec));\n        __m128i div_vec = _mm_div_epi16(src_vec, base_signed);\n        __m128i mul_vec = _mm_mullo_epi16(div_vec, base_signed);\n        _mm_storeu_si128((__m128i*)(dst + i), mul_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    __m128i base_vec = _mm_set1_epi16(base);\n\n    for (; i + 8 <= length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i temp_vec = _mm_srai_epi16(src_vec, 15);\n        __m128i abs_src_vec = _mm_sub_epi16(_mm_xor_si128(src_vec, temp_vec), temp_vec);\n        __m128i quotient_vec = _mm_divhi_epu16(abs_src_vec, base_vec);\n        __m128i product_vec = _mm_mullo_epi16(quotient_vec, base_vec);\n        _mm_storeu_si128((__m128i*)(dst + i), product_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    __m128i base_vec = _mm_set1_epi16(base);\n\n    for (; i + 8 <= length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i temp_vec = _mm_srai_epi16(src_vec, 15);\n        __m128i abs_src_vec = _mm_sub_epi16(_mm_xor_si128(src_vec, temp_vec), temp_vec);\n        __m128i quotient_vec = _mm_divhi_epu16(abs_src_vec, base_vec);\n        quotient_vec = _mm_sub_epi16(abs_src_vec, _mm_mullo_epi16(quotient_vec, base_vec));\n        __m128i result_vec = _mm_sub_epi16(src_vec, quotient_vec);\n        _mm_storeu_si128((__m128i*)(dst + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[i] - (src[i] % base);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    __m128i base_vec = _mm_set1_epi16(base);\n\n    for (; i + 8 <= length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i temp_vec = _mm_srai_epi16(src_vec, 0); \n\n        __m128i quotient_vec = _mm_divhi_epi16(src_vec, base_vec);\n        __m128i quotient_vec2 = _mm_mullo_epi16(quotient_vec, base_vec);\n        \n        __m128i result_vec = quotient_vec2;\n\n        _mm_storeu_si128((__m128i*)(dst + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (vector);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if any row in the matrix matches the given vector.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + 2 <= cols; j += 2) {\n            __m128d row_chunk = _mm_loadu_pd(matrix + i * cols + j);\n            __m128d vec_chunk = _mm_loadu_pd(vector + j);\n            __m128d cmp_result = _mm_cmpeq_pd(row_chunk, vec_chunk);\n            if (_mm_movemask_pd(cmp_result) != 3) {\n                goto next_row;\n            }\n        }\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                goto next_row;\n            }\n        }\n        return true;\n\n    next_row:;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (vector);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if any row in the matrix matches the given vector.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + 2 <= cols; j += 2) {\n            __m128d row_chunk = _mm_loadu_pd(matrix + i * cols + j);\n            __m128d vec_chunk = _mm_loadu_pd(vector + j);\n            __m128d cmp_result = _mm_cmpeq_pd(row_chunk, vec_chunk);\n            if (_mm_movemask_pd(cmp_result) != 3) {\n                goto next_row;\n            }\n        }\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                goto next_row;\n            }\n        }\n        return true;\n\n    next_row:;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (vector);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if any row in the matrix matches the given vector.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols % 2 != 0) {\n        for (size_t i = 0; i < rows; ++i) {\n            bool match = true;\n            for (size_t j = 0; j < cols; ++j) {\n                if (matrix[i * cols + j] != vector[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_val = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d vec_val = _mm_loadu_pd(&vector[j]);\n            __m128d cmp_result = _mm_cmpeq_pd(row_val, vec_val);\n            if (_mm_movemask_pd(cmp_result) != 3) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec1, vec2, cmp;\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            vec1 = _mm_loadu_pd(&matrix[i * cols + j]);\n            vec2 = _mm_loadu_pd(&vector[j]);\n            cmp = _mm_cmpeq_pd(vec1, vec2);\n            if (_mm_movemask_pd(cmp) == 0x3) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec1, vec2, cmp;\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            vec1 = _mm_load_pd(&row[j]);\n            vec2 = _mm_load_pd(&vector[j]);\n            cmp = _mm_cmpeq_pd(vec1, vec2);\n            if (_mm_movemask_pd(cmp) == 0x3) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n\n    for (i = 0; i < total_elements / 16; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (i *= 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16; // 16 bytes in total for 16 uint8_t\n    size_t remaining = total_elements % 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (size_t j = 0; j < remaining; ++j) {\n        if (A[simd_iterations * 16 + j] == B[simd_iterations * 16 + j]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n\n    size_t simd_iterations = total_elements / 16;\n    size_t remaining_elements = total_elements % 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    for (size_t j = 0; j < remaining_elements; ++j) {\n        if (A[simd_iterations * 16 + j] == B[simd_iterations * 16 + j]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16; // 16 bytes per iteration\n    size_t remaining_elements = total_elements % 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i equal_mask = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(equal_mask));\n    }\n\n    // Handle remaining elements\n    for (size_t j = 0; j < remaining_elements; ++j) {\n        if (A[simd_iterations * 16 + j] == B[simd_iterations * 16 + j]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n\n    for (i = 0; i < total_elements / 16; i++) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (i *= 16; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    __m128i vec_a = _mm_set1_epi64x(a);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i vec_mul = _mm_mullo_epi64(vec_a, vec_x);\n\n        __m128i mask = _mm_srai_epi64(vec_mul, 63);\n        __m128i abs_val = _mm_xor_si128(vec_mul, mask);\n        abs_val = _mm_sub_epi64(abs_val, mask);\n\n        __m128i vec_y = _mm_loadu_si128((__m128i*)&y[i]);\n        __m128i result = _mm_sub_epi64(abs_val, vec_y);\n\n        _mm_storeu_si128((__m128i*)&y[i], result);\n    }\n\n    for (; i < length; ++i) {\n        int64_t mul = a * x[i];\n        int64_t abs_val = (mul >= 0) ? mul : -mul;\n        y[i] = abs_val - y[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    __m128i vec_a = _mm_set1_epi64x(a);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i vec_mul = _mm_mullo_epi64(vec_a, vec_x);\n\n        __m128i mask = _mm_srai_epi64(vec_mul, 63);\n        __m128i abs_val = _mm_xor_si128(vec_mul, mask);\n        abs_val = _mm_sub_epi64(abs_val, mask);\n\n        __m128i vec_y = _mm_loadu_si128((__m128i*)&y[i]);\n        __m128i result = _mm_sub_epi64(abs_val, vec_y);\n\n        _mm_storeu_si128((__m128i*)&y[i], result);\n    }\n\n    for (; i < length; ++i) {\n        int64_t mul = a * x[i];\n        int64_t abs_val = (mul >= 0) ? mul : -mul;\n        y[i] = abs_val - y[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    __m128i vec_a = _mm_set1_epi64x(a);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i vec_result = _mm_mullo_epi64(vec_a, vec_x);\n\n        // Compute absolute value\n        __m128i sign_mask = _mm_srai_epi64(vec_result, 63);\n        __m128i abs_val = _mm_xor_si128(vec_result, sign_mask);\n        abs_val = _mm_sub_epi64(abs_val, sign_mask);\n\n        __m128i vec_y = _mm_loadu_si128((__m128i*)&y[i]);\n        vec_y = _mm_sub_epi64(abs_val, vec_y);\n\n        _mm_storeu_si128((__m128i*)&y[i], vec_y);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int64_t temp = a * x[i];\n        if (temp < 0) temp = -temp;\n        y[i] = temp - y[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    __m128i vec_a = _mm_set1_epi64x(a);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i vec_result = _mm_mullo_epi64(vec_a, vec_x);\n\n        // Compute absolute value\n        __m128i sign_mask = _mm_srai_epi64(vec_result, 63);\n        __m128i abs_val = _mm_xor_si128(vec_result, sign_mask);\n        abs_val = _mm_sub_epi64(abs_val, sign_mask);\n\n        __m128i vec_y = _mm_loadu_si128((__m128i*)&y[i]);\n        vec_y = _mm_sub_epi64(abs_val, vec_y);\n\n        _mm_storeu_si128((__m128i*)&y[i], vec_y);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int64_t result = a * x[i];\n        y[i] = abs(result) - y[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    __m128i vec_a = _mm_set1_epi64x(a);\n\n    for (; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i vec_result = _mm_mullo_epi64(vec_a, vec_x);\n\n        // Compute absolute value\n        __m128i sign_mask = _mm_srai_epi64(vec_result, 63);\n        __m128i abs_val = _mm_xor_si128(vec_result, sign_mask);\n        abs_val = _mm_sub_epi64(abs_val, sign_mask);\n\n        __m128i vec_y = _mm_loadu_si128((__m128i*)&y[i]);\n        vec_y = _mm_sub_epi64(abs_val, vec_y);\n\n        _mm_storeu_si128((__m128i*)&y[i], vec_y);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int64_t temp = a * x[i];\n        if (temp < 0) temp = -temp;\n        y[i] = temp - y[i];\n    }\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer vector (vec);\n- The length of the given vector.\n\nYour goal is to return the the maximum and minimum values in the given vector.\nThe function should return a value of the defined `MinMaxPair` type:\n```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n```\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n\n    if (length <= 0) {\n        result.min_num = min_val;\n        result.max_num = max_val;\n        return result;\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        __m128i min_vec = _mm_loadu_si128((const __m128i*)vec);\n        __m128i max_vec = _mm_loadu_si128((const __m128i*)vec);\n        i = 8;\n\n        for (; i + 7 < length; i += 8) {\n            __m128i current_vec = _mm_loadu_si128((const __m128i*)(vec + i));\n            min_vec = _mm_min_epi16(min_vec, current_vec);\n            max_vec = _mm_max_epi16(max_vec, current_vec);\n        }\n\n        int16_t temp_min[8];\n        int16_t temp_max[8];\n        _mm_storeu_si128((__m128i*)temp_min, min_vec);\n        _mm_storeu_si128((__m128i*)temp_max, max_vec);\n\n        for (int j = 0; j < 8; ++j) {\n            min_val = (temp_min[j] < min_val) ? temp_min[j] : min_val;\n            max_val = (temp_max[j] > max_val) ? temp_max[j] : max_val;\n        }\n    }\n\n    for (; i < length; ++i) {\n        min_val = (vec[i] < min_val) ? vec[i] : min_val;\n        max_val = (vec[i] > max_val) ? vec[i] : max_val;\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer vector (vec);\n- The length of the given vector.\n\nYour goal is to return the the maximum and minimum values in the given vector.\nThe function should return a value of the defined `MinMaxPair` type:\n```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n```\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n\n    if (length <= 8) {\n        for (size_t i = 0; i < length; ++i) {\n            if (vec[i] < min_val) {\n                min_val = vec[i];\n            }\n            if (vec[i] > max_val) {\n                max_val = vec[i];\n            }\n        }\n        result.min_num = min_val;\n        result.max_num = max_val;\n        return result;\n    }\n\n    __m128i min_vec = _mm_set1_epi16(vec[0]);\n    __m128i max_vec = _mm_set1_epi16(vec[0]);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        __m128i data_vec = _mm_loadu_si128((const __m128i*)&vec[i]);\n        min_vec = _mm_min_epi16(min_vec, data_vec);\n        max_vec = _mm_max_epi16(max_vec, data_vec);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    _mm_storeu_si128((__m128i*)max_arr, max_vec);\n\n    for (int j = 0; j < 8; ++j) {\n        if (min_arr[j] < min_val) {\n            min_val = min_arr[j];\n        }\n        if (max_arr[j] > max_val) {\n            max_val = max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) {\n            min_val = vec[i];\n        }\n        if (vec[i] > max_val) {\n            max_val = vec[i];\n        }\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    if (length == 0) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n\n    __m128i min_val = _mm_loadu_si128((const __m128i*)vec);\n    __m128i max_val = _mm_loadu_si128((const __m128i*)vec);\n\n    size_t i = 8;\n    for (; i + 7 < length; i += 8) {\n        __m128i current_val = _mm_loadu_si128((const __m128i*)(vec + i));\n        min_val = _mm_min_epi16(min_val, current_val);\n        max_val = _mm_max_epi16(max_val, current_val);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    _mm_storeu_si128((__m128i*)min_arr, min_val);\n    _mm_storeu_si128((__m128i*)max_arr, max_val);\n\n    int16_t current_min = min_arr[0];\n    int16_t current_max = max_arr[0];\n\n    for (int j = 1; j < 8; ++j) {\n        if (min_arr[j] < current_min) {\n            current_min = min_arr[j];\n        }\n        if (max_arr[j] > current_max) {\n            current_max = max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < current_min) {\n            current_min = vec[i];\n        }\n        if (vec[i] > current_max) {\n            current_max = vec[i];\n        }\n    }\n\n    result.min_num = current_min;\n    result.max_num = current_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer vector (vec);\n- The length of the given vector.\n\nYour goal is to return the the maximum and minimum values in the given vector.\nThe function should return a value of the defined `MinMaxPair` type:\n```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n```\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n\n    if (length <= 8) {\n        for (size_t i = 0; i < length; ++i) {\n            if (vec[i] < min_val) {\n                min_val = vec[i];\n            }\n            if (vec[i] > max_val) {\n                max_val = vec[i];\n            }\n        }\n        result.min_num = min_val;\n        result.max_num = max_val;\n        return result;\n    }\n\n    __m128i min_vec = _mm_set1_epi16(vec[0]);\n    __m128i max_vec = _mm_set1_epi16(vec[0]);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        __m128i data_vec = _mm_loadu_si128((const __m128i*)&vec[i]);\n        min_vec = _mm_min_epi16(min_vec, data_vec);\n        max_vec = _mm_max_epi16(max_vec, data_vec);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    _mm_storeu_si128((__m128i*)max_arr, max_vec);\n\n    for (int j = 0; j < 8; ++j) {\n        if (min_arr[j] < min_val) {\n            min_val = min_arr[j];\n        }\n        if (max_arr[j] > max_val) {\n            max_val = max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) {\n            min_val = vec[i];\n        }\n        if (vec[i] > max_val) {\n            max_val = vec[i];\n        }\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    if (length == 0) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n\n    __m128i min_val = _mm_loadu_si128((const __m128i*)vec);\n    __m128i max_val = _mm_loadu_si128((const __m128i*)vec);\n\n    size_t i = 8;\n    for (; i + 7 < length; i += 8) {\n        __m128i current_val = _mm_loadu_si128((const __m128i*)(vec + i));\n        min_val = _mm_min_epi16(min_val, current_val);\n        max_val = _mm_max_epi16(max_val, current_val);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    _mm_storeu_si128((__m128i*)min_arr, min_val);\n    _mm_storeu_si128((__m128i*)max_arr, max_val);\n\n    int16_t current_min = min_arr[0];\n    int16_t current_max = max_arr[0];\n\n    for (int j = 1; j < 8; ++j) {\n        if (min_arr[j] < current_min) {\n            current_min = min_arr[j];\n        }\n        if (max_arr[j] > current_max) {\n            current_max = max_arr[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < current_min) {\n            current_min = vec[i];\n        }\n        if (vec[i] > current_max) {\n            current_max = vec[i];\n        }\n    }\n\n    result.min_num = current_min;\n    result.max_num = current_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; j += 4) {\n            if (cols - j < 4) {\n                for (size_t k = j; k < cols - 1; ++k) {\n                    if (matrix[i * cols + k] >= matrix[i * cols + k + 1]) {\n                        return false;\n                    }\n                }\n                break;\n            } else {\n                __m128i a = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j]);\n                __m128i b = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j + 1]);\n\n                __m128i cmp = _mm_cmpeq_epi32(_mm_cmpgt_epi32(a, b), _mm_setzero_si128());\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; j += 4) {\n            if (cols - j < 4) {\n                for (size_t k = j; k < cols - 1; ++k) {\n                    if (matrix[i * cols + k] >= matrix[i * cols + k + 1]) {\n                        return false;\n                    }\n                }\n                break;\n            } else {\n                __m128i a = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j]);\n                __m128i b = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j + 1]);\n\n                __m128i cmp = _mm_cmpeq_epi32(_mm_cmpgt_epi32(a, b), _mm_setzero_si128());\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; ) {\n            if (cols - j >= 4) {\n                __m128i current = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j]);\n                __m128i next = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j + 1]);\n\n                __m128i cmp = _mm_cmplt_epi32(current, next);\n                int mask = _mm_movemask_epi8(cmp);\n\n                if (mask != 0xFFFF) {\n                    return false;\n                }\n                j += 4;\n            } else {\n                if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                    return false;\n                }\n                ++j;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; ) {\n            if (cols - j >= 4) {\n                __m128i current = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j]);\n                __m128i next = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j + 1]);\n\n                __m128i cmp = _mm_cmplt_epi32(current, next);\n                int mask = _mm_movemask_epi8(cmp);\n\n                if (mask != 0xFFFF) {\n                    return false;\n                }\n                j += 4;\n            } else {\n                if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                    return false;\n                }\n                ++j;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; j += 4) {\n            if (cols - j < 4) {\n                for (size_t k = j; k < cols - 1; ++k) {\n                    if (matrix[i * cols + k] >= matrix[i * cols + k + 1]) {\n                        return false;\n                    }\n                }\n                break;\n            } else {\n                __m128i a = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j]);\n                __m128i b = _mm_loadu_si128((const __m128i*)&matrix[i * cols + j + 1]);\n\n                __m128i cmp = _mm_cmpeq_epi32(_mm_cmpgt_epi32(a, b), _mm_setzero_si128());\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_block_rows; ++i) {\n        for (size_t j = 0; j < num_block_cols; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t k = 0;\n                for (; k + 4 <= block_size; k += 4) {\n                    __m128i a = _mm_loadu_si128((const __m128i*)(first_block + row * cols + k));\n                    __m128i b = _mm_loadu_si128((const __m128i*)(current_block + row * cols + k));\n                    __m128i cmp = _mm_cmpeq_epi32(a, b);\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        return false;\n                    }\n                }\n                for (; k < block_size; ++k) {\n                    if (first_block[row * cols + k] != current_block[row * cols + k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_rows = rows / block_size;\n    size_t num_blocks_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_blocks_rows; ++i) {\n        for (size_t j = 0; j < num_blocks_cols; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t col = 0;\n                for (; col + 3 < block_size; col += 4) {\n                    __m128i first_block_vec = _mm_loadu_si128((const __m128i*)(first_block + row * cols + col));\n                    __m128i current_block_vec = _mm_loadu_si128((const __m128i*)(current_block + row * cols + col));\n\n                    __m128i cmp = _mm_cmpeq_epi32(first_block_vec, current_block_vec);\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_rows = rows / block_size;\n    size_t num_blocks_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_blocks_rows; ++i) {\n        for (size_t j = 0; j < num_blocks_cols; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t col = 0;\n                for (; col + 3 < block_size; col += 4) {\n                    __m128i first_vec = _mm_loadu_si128((const __m128i*)(first_block + row * cols + col));\n                    __m128i current_vec = _mm_loadu_si128((const __m128i*)(current_block + row * cols + col));\n\n                    __m128i cmp = _mm_cmpeq_epi32(first_vec, current_vec);\n                    int mask = _mm_movemask_epi8(cmp);\n\n                    if (mask != 0xFFFF) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_block_rows; ++i) {\n        for (size_t j = 0; j < num_block_cols; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t k = 0;\n                for (; k + 4 <= block_size; k += 4) {\n                    __m128i first_vec = _mm_loadu_si128((const __m128i*)(first_block + row * cols + k));\n                    __m128i current_vec = _mm_loadu_si128((const __m128i*)(current_block + row * cols + k));\n                    __m128i cmp = _mm_cmpeq_epi32(first_vec, current_vec);\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        return false;\n                    }\n                }\n                for (; k < block_size; ++k) {\n                    if (first_block[row * cols + k] != current_block[row * cols + k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_block_rows; ++i) {\n        for (size_t j = 0; j < num_block_cols; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + i * block_size * cols + j * block_size;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t k = 0;\n                for (; k + 4 <= block_size; k += 4) {\n                    __m128i a = _mm_loadu_si128((const __m128i*)(first_block + row * cols + k));\n                    __m128i b = _mm_loadu_si128((const __m128i*)(current_block + row * cols + k));\n                    __m128i result = _mm_cmpeq_epi32(a, b);\n                    if (_mm_movemask_epi8(result) != 0xFFFF) {\n                        return false;\n                    }\n                }\n                for (; k < block_size; ++k) {\n                    if (first_block[row * cols + k] != current_block[row * cols + k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 64-bit floating-point vector (vec);\n- A 64-bit floating-point tolerance;\n- The length of the given vector (length);\n- The size of each block (block_size).\n\nYour goal is to check whether all blocks (excluding tail elements that cannot form a complete block)\nof the vector are element-wise equal to the first block, within the specified tolerance.\nReturn false is the input is illegal or no complete blocks in block_size.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            __m128d block1_vec = _mm_loadu_pd(&vec[j]);\n            __m128d block2_vec = _mm_loadu_pd(&vec[i * block_size + j]);\n\n            __m128d diff_vec = _mm_sub_pd(block1_vec, block2_vec);\n            __m128d abs_diff_vec = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec);\n\n            __m128d cmp_vec = _mm_cmplt_pd(abs_diff_vec, tolerance_vec);\n            \n            if (_mm_movemask_pd(cmp_vec) != 0x3) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 64-bit floating-point vector (vec);\n- A 64-bit floating-point tolerance;\n- The length of the given vector (length);\n- The size of each block (block_size).\n\nYour goal is to check whether all blocks (excluding tail elements that cannot form a complete block)\nof the vector are element-wise equal to the first block, within the specified tolerance.\nReturn false is the input is illegal or no complete blocks in block_size.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; j += 2) {\n            __m128d block1_vec = _mm_loadu_pd(&vec[j]);\n            __m128d block2_vec = _mm_loadu_pd(&vec[i * block_size + j]);\n            __m128d diff_vec = _mm_sub_pd(block1_vec, block2_vec);\n            __m128d abs_diff_vec = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec); \n            __m128d cmp_vec = _mm_cmplt_pd(abs_diff_vec, tolerance_vec);\n\n            if (_mm_movemask_pd(cmp_vec) != 0x3) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    __m128d tol = _mm_set1_pd(tolerance);\n    \n    for (size_t i = 0; i < num_blocks; ++i) {\n        const double* block_start = vec + i * block_size;\n        __m128d first_elem = _mm_load_pd(block_start);\n        \n        for (size_t j = 1; j < block_size / 2; ++j) {\n            __m128d current_elem = _mm_load_pd(block_start + j * 2);\n            __m128d diff = _mm_sub_pd(first_elem, current_elem);\n            __m128d abs_diff = _mm_and_pd(diff, _mm_set1_pd(-0.0)); // Get absolute difference\n            abs_diff = _mm_max_pd(abs_diff, _mm_sub_pd(current_elem, first_elem));\n            \n            if (_mm_movemask_pd(_mm_cmpgt_pd(abs_diff, tol)) != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        __m128d first_block = _mm_loadu_pd(&vec[i]);\n        for (size_t j = 1; j < num_blocks; j++) {\n            __m128d current_block = _mm_loadu_pd(&vec[j * block_size + i]);\n            __m128d diff = _mm_sub_pd(first_block, current_block);\n            __m128d abs_diff = _mm_max_pd(diff, _mm_neg_pd(diff));\n            if (_mm_movemask_pd(_mm_cmpgt_pd(abs_diff, tolerance_vec)) != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    __m128d tol = _mm_set1_pd(tolerance);\n\n    for (size_t i = 0; i < num_blocks; ++i) {\n        __m128d first_block_0 = _mm_loadu_pd(&vec[i * block_size]);\n        __m128d first_block_1 = _mm_loadu_pd(&vec[i * block_size + 2]);\n\n        bool all_equal = true;\n\n        for (size_t j = 1; j < block_size / 2; ++j) {\n            __m128d current_block_0 = _mm_loadu_pd(&vec[j * block_size]);\n            __m128d current_block_1 = _mm_loadu_pd(&vec[j * block_size + 2]);\n\n            __m128d diff_0 = _mm_sub_pd(first_block_0, current_block_0);\n            __m128d diff_1 = _mm_sub_pd(first_block_1, current_block_1);\n\n            __m128d abs_diff_0 = _mm_max_pd(diff_0, _mm_neg_pd(diff_0));\n            __m128d abs_diff_1 = _mm_max_pd(diff_1, _mm_neg_pd(diff_1));\n\n            __m128d cmp_0 = _mm_cmp_pd(abs_diff_0, tol, _CMP_LE_OQ);\n            __m128d cmp_1 = _mm_cmp_pd(abs_diff_1, tol, _CMP_LE_OQ);\n\n            if (_mm_movemask_pd(cmp_0) != 0x3 || _mm_movemask_pd(cmp_1) != 0x3) {\n                all_equal = false;\n                break;\n            }\n        }\n\n        if (!all_equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d cmp_result = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(cmp_result) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d comparison = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(comparison) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, row_vec1, row_vec2, sum_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        sum_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            row_vec1 = _mm_load_pd(&matrix[i * cols + j]);\n            sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(row_vec1, row_vec1));\n        }\n        double sum[2];\n        _mm_store_pd(sum, sum_vec);\n        double norm = sqrt(sum[0] + sum[1]);\n        threshold_vec = _mm_load1_pd(&thresholds[i]);\n        result[i] = norm > threshold_vec[0];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (thresholds);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n- A pointer to a boolean result array (result).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to check if the Euclidean norm of each row in the matrix exceeds the corresponding threshold in the vector.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d sum_sq_vec = _mm_setzero_pd();\n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(matrix + i * cols + j);\n            sum_sq_vec = _mm_add_pd(sum_sq_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        double sum_sq = 0.0;\n        sum_sq += ((double*)&sum_sq_vec)[0];\n        sum_sq += ((double*)&sum_sq_vec)[1];\n\n        for (; j < cols; ++j) {\n            sum_sq += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum_sq > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (thresholds);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n- A pointer to a boolean result array (result).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to check if the Euclidean norm of each row in the matrix exceeds the corresponding threshold in the vector.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d sum_sq_vec = _mm_setzero_pd();\n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(matrix + i * cols + j);\n            sum_sq_vec = _mm_add_pd(sum_sq_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        double sum_sq = 0.0;\n        sum_sq += ((double*)&sum_sq_vec)[0];\n        sum_sq += ((double*)&sum_sq_vec)[1];\n\n        for (; j < cols; ++j) {\n            sum_sq += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = (sum_sq > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t i = 0;\n    __m128i sum_sq_lo = _mm_setzero_si128();\n    __m128i sum_sq_hi = _mm_setzero_si128();\n    __m128i sum_prod_lo = _mm_setzero_si128();\n    __m128i sum_prod_hi = _mm_setzero_si128();\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n\n        __m128i a_sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i a_sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n\n        sum_sq_lo = _mm_add_epi32(sum_sq_lo, _mm_sad_epu16(a_sq_lo, _mm_setzero_si128()));\n        sum_sq_hi = _mm_add_epi32(sum_sq_hi, _mm_sad_epu16(a_sq_hi, _mm_setzero_si128()));\n        sum_prod_lo = _mm_add_epi32(sum_prod_lo, _mm_sad_epu16(prod_lo, _mm_setzero_si128()));\n        sum_prod_hi = _mm_add_epi32(sum_prod_hi, _mm_sad_epu16(prod_hi, _mm_setzero_si128()));\n    }\n\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    int32_t temp_sq[4];\n    int32_t temp_prod[4];\n\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_lo);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_hi);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_lo);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_hi);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t i = 0;\n    __m128i sum_sq_lo = _mm_setzero_si128();\n    __m128i sum_sq_hi = _mm_setzero_si128();\n    __m128i sum_prod_lo = _mm_setzero_si128();\n    __m128i sum_prod_hi = _mm_setzero_si128();\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n\n        __m128i a_sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i a_sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n\n        sum_sq_lo = _mm_add_epi32(sum_sq_lo, _mm_sad_epu16(a_sq_lo, _mm_setzero_si128()));\n        sum_sq_hi = _mm_add_epi32(sum_sq_hi, _mm_sad_epu16(a_sq_hi, _mm_setzero_si128()));\n        sum_prod_lo = _mm_add_epi32(sum_prod_lo, _mm_sad_epu16(prod_lo, _mm_setzero_si128()));\n        sum_prod_hi = _mm_add_epi32(sum_prod_hi, _mm_sad_epu16(prod_hi, _mm_setzero_si128()));\n    }\n\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    int32_t temp_sq[4];\n    int32_t temp_prod[4];\n\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_lo);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_hi);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_lo);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_hi);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t i = 0;\n    __m128i sum_sq_lo = _mm_setzero_si128();\n    __m128i sum_sq_hi = _mm_setzero_si128();\n    __m128i sum_prod_lo = _mm_setzero_si128();\n    __m128i sum_prod_hi = _mm_setzero_si128();\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n\n        __m128i a_sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i a_sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n\n        sum_sq_lo = _mm_add_epi32(sum_sq_lo, _mm_sad_epu16(a_sq_lo, _mm_setzero_si128()));\n        sum_sq_hi = _mm_add_epi32(sum_sq_hi, _mm_sad_epu16(a_sq_hi, _mm_setzero_si128()));\n        sum_prod_lo = _mm_add_epi32(sum_prod_lo, _mm_sad_epu16(prod_lo, _mm_setzero_si128()));\n        sum_prod_hi = _mm_add_epi32(sum_prod_hi, _mm_sad_epu16(prod_hi, _mm_setzero_si128()));\n    }\n\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    int32_t temp_sq[4];\n    int32_t temp_prod[4];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_lo);\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_lo);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_hi);\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_hi);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t i = 0;\n    __m128i sum_sq_lo = _mm_setzero_si128();\n    __m128i sum_sq_hi = _mm_setzero_si128();\n    __m128i sum_prod_lo = _mm_setzero_si128();\n    __m128i sum_prod_hi = _mm_setzero_si128();\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i *)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i *)(B + i));\n\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n\n        __m128i a_sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i a_sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n\n        sum_sq_lo = _mm_add_epi32(sum_sq_lo, _mm_sad_epu16(a_sq_lo, _mm_setzero_si128()));\n        sum_sq_hi = _mm_add_epi32(sum_sq_hi, _mm_sad_epu16(a_sq_hi, _mm_setzero_si128()));\n        sum_prod_lo = _mm_add_epi32(sum_prod_lo, _mm_sad_epu16(prod_lo, _mm_setzero_si128()));\n        sum_prod_hi = _mm_add_epi32(sum_prod_hi, _mm_sad_epu16(prod_hi, _mm_setzero_si128()));\n    }\n\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    int32_t temp_sq[4];\n    int32_t temp_prod[4];\n\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_lo);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_hi);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_lo);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_hi);\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    for (; i < length; ++i) {\n        sum_sq += (int64_t)A[i] * A[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t i = 0;\n    __m128i sum_sq_lo = _mm_setzero_si128();\n    __m128i sum_sq_hi = _mm_setzero_si128();\n    __m128i sum_prod_lo = _mm_setzero_si128();\n    __m128i sum_prod_hi = _mm_setzero_si128();\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n\n        __m128i a_sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i a_sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n\n        sum_sq_lo = _mm_add_epi32(sum_sq_lo, _mm_sad_epu16(a_sq_lo, _mm_setzero_si128()));\n        sum_sq_hi = _mm_add_epi32(sum_sq_hi, _mm_sad_epu16(a_sq_hi, _mm_setzero_si128()));\n        sum_prod_lo = _mm_add_epi32(sum_prod_lo, _mm_sad_epu16(prod_lo, _mm_setzero_si128()));\n        sum_prod_hi = _mm_add_epi32(sum_prod_hi, _mm_sad_epu16(prod_hi, _mm_setzero_si128()));\n    }\n\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    int32_t temp_sq[4];\n    int32_t temp_prod[4];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_lo);\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_lo);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n    _mm_storeu_si128((__m128i*)temp_sq, sum_sq_hi);\n    _mm_storeu_si128((__m128i*)temp_prod, sum_prod_hi);\n    sum_sq += temp_sq[0] + temp_sq[1] + temp_sq[2] + temp_sq[3];\n    sum_prod += temp_prod[0] + temp_prod[1] + temp_prod[2] + temp_prod[3];\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i zero = _mm_setzero_si128();\n\n        __m128i a_pos = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg = _mm_cmplt_epi8(b, zero);\n\n        __m128i both_pos = _mm_and_si128(a_pos, b_pos);\n        __m128i both_neg = _mm_and_si128(a_neg, b_neg);\n\n        __m128i one = _mm_set1_epi8(1);\n        __m128i neg_one = _mm_set1_epi8(-1);\n\n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, one, both_pos);\n        result = _mm_blendv_epi8(result, neg_one, both_neg);\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i zero = _mm_setzero_si128();\n\n        __m128i a_pos_mask = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos_mask = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg_mask = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg_mask = _mm_cmplt_epi8(b, zero);\n\n        __m128i both_pos_mask = _mm_and_si128(a_pos_mask, b_pos_mask);\n        __m128i both_neg_mask = _mm_and_si128(a_neg_mask, b_neg_mask);\n\n        __m128i pos_val = _mm_set1_epi8(1);\n        __m128i neg_val = _mm_set1_epi8(-1);\n\n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, pos_val, both_pos_mask);\n        result = _mm_blendv_epi8(result, neg_val, both_neg_mask);\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i zero = _mm_setzero_si128();\n\n        __m128i a_pos_mask = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos_mask = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg_mask = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg_mask = _mm_cmplt_epi8(b, zero);\n\n        __m128i both_pos_mask = _mm_and_si128(a_pos_mask, b_pos_mask);\n        __m128i both_neg_mask = _mm_and_si128(a_neg_mask, b_neg_mask);\n\n        __m128i pos_val = _mm_set1_epi8(1);\n        __m128i neg_val = _mm_set1_epi8(-1);\n\n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, pos_val, both_pos_mask);\n        result = _mm_blendv_epi8(result, neg_val, both_neg_mask);\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i zero = _mm_setzero_si128();\n\n        __m128i a_pos_mask = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos_mask = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg_mask = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg_mask = _mm_cmplt_epi8(b, zero);\n\n        __m128i both_pos_mask = _mm_and_si128(a_pos_mask, b_pos_mask);\n        __m128i both_neg_mask = _mm_and_si128(a_neg_mask, b_neg_mask);\n\n        __m128i pos_ones = _mm_set1_epi8(1);\n        __m128i neg_ones = _mm_set1_epi8(-1);\n\n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, pos_ones, both_pos_mask);\n        result = _mm_blendv_epi8(result, neg_ones, both_neg_mask);\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((const __m128i*)(B + i));\n        __m128i zero = _mm_setzero_si128();\n\n        __m128i a_pos_mask = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos_mask = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg_mask = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg_mask = _mm_cmplt_epi8(b, zero);\n\n        __m128i both_pos_mask = _mm_and_si128(a_pos_mask, b_pos_mask);\n        __m128i both_neg_mask = _mm_and_si128(a_neg_mask, b_neg_mask);\n\n        __m128i ones = _mm_set1_epi8(1);\n        __m128i neg_ones = _mm_set1_epi8(-1);\n\n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, ones, both_pos_mask);\n        result = _mm_blendv_epi8(result, neg_ones, both_neg_mask);\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Keep the value at the midpoint\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Keep the value in A at the midpoint\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Keep the value in A at the midpoint\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Keep the midpoint value from A\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Keep the value in A at the midpoint\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        __m128i cond1_vec = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_vec = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i mask1 = _mm_cmpeq_epi32(cond1_vec, _mm_set1_epi32(1));\n        __m128i mask2 = _mm_cmpeq_epi32(cond2_vec, _mm_set1_epi32(1));\n\n        __m128i mask_a = _mm_and_si128(mask1, mask2);\n        __m128i mask_b = _mm_and_si128(mask1, _mm_andnot_si128(mask2, _mm_set1_epi32(-1)));\n        __m128i mask_c = _mm_andnot_si128(mask1, mask2);\n        __m128i mask_d = _mm_andnot_si128(mask1, _mm_andnot_si128(mask2, _mm_set1_epi32(-1)));\n\n        __m128 result = _mm_or_ps(\n            _mm_or_ps(_mm_and_ps(_mm_castsi128_ps(mask_a), a),\n                       _mm_and_ps(_mm_castsi128_ps(mask_b), b)),\n            _mm_or_ps(_mm_and_ps(_mm_castsi128_ps(mask_c), c),\n                       _mm_and_ps(_mm_castsi128_ps(mask_d), d))\n        );\n\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        int mask1 = (cond1[i] << 0) | (cond1[i + 1] << 1) | (cond1[i + 2] << 2) | (cond1[i + 3] << 3);\n        int mask2 = (cond2[i] << 0) | (cond2[i + 1] << 1) | (cond2[i + 2] << 2) | (cond2[i + 3] << 3);\n\n        __m128 result;\n\n        // cond1 && cond2: A\n        if ((mask1 & mask2) != 0) {\n            __m128 mask_a = _mm_cmpeq_ps(_mm_set_epi32( (mask1 & mask2 & 0x8) ? -1 : 0, (mask1 & mask2 & 0x4) ? -1 : 0, (mask1 & mask2 & 0x2) ? -1 : 0, (mask1 & mask2 & 0x1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, a, _mm_xor_ps(mask_a, _mm_set1_ps(-0.0f)));\n        } else {\n            result = _mm_setzero_ps();\n        }\n\n        // cond1 && !cond2: B\n        int mask1_and_not_mask2 = mask1 & (~mask2);\n        if (mask1_and_not_mask2 != 0) {\n            __m128 mask_b = _mm_cmpeq_ps(_mm_set_epi32( (mask1_and_not_mask2 & 0x8) ? -1 : 0, (mask1_and_not_mask2 & 0x4) ? -1 : 0, (mask1_and_not_mask2 & 0x2) ? -1 : 0, (mask1_and_not_mask2 & 0x1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, b, _mm_xor_ps(mask_b, _mm_set1_ps(-0.0f)));\n        }\n\n        // !cond1 && cond2: C\n        int not_mask1_and_mask2 = (~mask1) & mask2;\n        if (not_mask1_and_mask2 != 0) {\n            __m128 mask_c = _mm_cmpeq_ps(_mm_set_epi32( (not_mask1_and_mask2 & 0x8) ? -1 : 0, (not_mask1_and_mask2 & 0x4) ? -1 : 0, (not_mask1_and_mask2 & 0x2) ? -1 : 0, (not_mask1_and_mask2 & 0x1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, c, _mm_xor_ps(mask_c, _mm_set1_ps(-0.0f)));\n        }\n\n        // !cond1 && !cond2: D\n        int not_mask1_and_not_mask2 = (~mask1) & (~mask2);\n        if (not_mask1_and_not_mask2 != 0) {\n            __m128 mask_d = _mm_cmpeq_ps(_mm_set_epi32( (not_mask1_and_not_mask2 & 0x8) ? -1 : 0, (not_mask1_and_not_mask2 & 0x4) ? -1 : 0, (not_mask1_and_not_mask2 & 0x2) ? -1 : 0, (not_mask1_and_not_mask2 & 0x1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, d, _mm_xor_ps(mask_d, _mm_set1_ps(-0.0f)));\n        }\n\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        int mask1 = (cond1[i] << 0) | (cond1[i + 1] << 1) | (cond1[i + 2] << 2) | (cond1[i + 3] << 3);\n        int mask2 = (cond2[i] << 0) | (cond2[i + 1] << 1) | (cond2[i + 2] << 2) | (cond2[i + 3] << 3);\n\n        __m128 result;\n\n        // cond1 && cond2\n        int mask_and = mask1 & mask2;\n        __m128 temp_and = _mm_blend_ps(d, a, mask_and);\n\n        // cond1 && !cond2\n        int mask_and_not = mask1 & (~mask2);\n        __m128 temp_and_not = _mm_blend_ps(temp_and, b, mask_and_not);\n\n        // !cond1 && cond2\n        int mask_not_and = (~mask1) & mask2;\n        __m128 temp_not_and = _mm_blend_ps(temp_and_not, c, mask_not_and);\n\n        _mm_storeu_ps(&out[i], temp_not_and);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        __m128 cond1_mask = _mm_set_ps((cond1[i+3] ? -1.0f : 0.0f), (cond1[i+2] ? -1.0f : 0.0f), (cond1[i+1] ? -1.0f : 0.0f), (cond1[i] ? -1.0f : 0.0f));\n        __m128 cond2_mask = _mm_set_ps((cond2[i+3] ? -1.0f : 0.0f), (cond2[i+2] ? -1.0f : 0.0f), (cond2[i+1] ? -1.0f : 0.0f), (cond2[i] ? -1.0f : 0.0f));\n\n        __m128 result;\n\n        // cond1 && cond2: A\n        __m128 temp1 = _mm_and_ps(cond1_mask, cond2_mask);\n        result = _mm_and_ps(temp1, a);\n\n        // cond1 && !cond2: B\n        __m128 not_cond2_mask = _mm_xor_ps(cond2_mask, _mm_set1_ps(-1.0f));\n        __m128 temp2 = _mm_and_ps(cond1_mask, not_cond2_mask);\n        result = _mm_or_ps(result, _mm_and_ps(temp2, b));\n\n        // !cond1 && cond2: C\n        __m128 not_cond1_mask = _mm_xor_ps(cond1_mask, _mm_set1_ps(-1.0f));\n        __m128 temp3 = _mm_and_ps(not_cond1_mask, cond2_mask);\n        result = _mm_or_ps(result, _mm_and_ps(temp3, c));\n\n        // !cond1 && !cond2: D\n        __m128 temp4 = _mm_and_ps(not_cond1_mask, not_cond2_mask);\n        result = _mm_or_ps(result, _mm_and_ps(temp4, d));\n\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        int mask1 = (cond1[i] << 0) | (cond1[i + 1] << 1) | (cond1[i + 2] << 2) | (cond1[i + 3] << 3);\n        int mask2 = (cond2[i] << 0) | (cond2[i + 1] << 1) | (cond2[i + 2] << 2) | (cond2[i + 3] << 3);\n\n        __m128 result;\n\n        // cond1 && cond2: A\n        if ((mask1 & mask2) != 0) {\n            __m128 mask_a = _mm_cmpeq_ps(_mm_set_epi32( (mask1 & mask2 & 8) ? -1 : 0, (mask1 & mask2 & 4) ? -1 : 0, (mask1 & mask2 & 2) ? -1 : 0, (mask1 & mask2 & 1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, a, mask_a);\n        } else {\n            result = d;\n        }\n\n        // cond1 && !cond2: B\n        if ((mask1 & (~mask2)) != 0) {\n            __m128 mask_b = _mm_cmpeq_ps(_mm_set_epi32( ((mask1 & (~mask2)) & 8) ? -1 : 0, ((mask1 & (~mask2)) & 4) ? -1 : 0, ((mask1 & (~mask2)) & 2) ? -1 : 0, ((mask1 & (~mask2)) & 1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, b, mask_b);\n        }\n\n        // !cond1 && cond2: C\n        if (((~mask1) & mask2) != 0) {\n            __m128 mask_c = _mm_cmpeq_ps(_mm_set_epi32( (((~mask1) & mask2) & 8) ? -1 : 0, (((~mask1) & mask2) & 4) ? -1 : 0, (((~mask1) & mask2) & 2) ? -1 : 0, (((~mask1) & mask2) & 1) ? -1 : 0), _mm_setzero_ps());\n            result = _mm_blendv_ps(result, c, mask_c);\n        }\n\n        // !cond1 && !cond2: D (already assigned)\n\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i counts = _mm_setzero_si128();\n\n        // Count bits using a bitwise trick (summing bits)\n        __m128i tmp1, tmp2, tmp3, tmp4;\n\n        tmp1 = _mm_sub_epi32(data, _mm_srli_epi32(data, 1) & _mm_set1_epi32(0x55555555));\n        tmp2 = (tmp1 & _mm_set1_epi32(0x33333333)) + (_mm_srli_epi32(tmp1, 2) & _mm_set1_epi32(0x33333333));\n        tmp3 = (tmp2 + _mm_srli_epi32(tmp2, 4)) & _mm_set1_epi32(0x0F0F0F0F);\n        tmp4 = _mm_add_epi32(tmp3, _mm_srli_epi32(tmp3, 8));\n        counts = _mm_add_epi32(tmp4, _mm_srli_epi32(tmp4, 16));\n\n        // Extract the counts and store them in the output array\n        uint32_t temp_counts[4];\n        _mm_storeu_si128((__m128i*)temp_counts, counts);\n\n        out[i] = (uint8_t)temp_counts[0];\n        out[i + 1] = (uint8_t)temp_counts[1];\n        out[i + 2] = (uint8_t)temp_counts[2];\n        out[i + 3] = (uint8_t)temp_counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i counts = _mm_setzero_si128();\n\n        // Count bits using a series of shifts and adds\n        __m128i tmp1 = _mm_srli_epi32(data, 1);\n        __m128i tmp2 = _mm_and_si128(data, _mm_set1_epi32(0x55555555));\n        tmp1 = _mm_and_si128(tmp1, _mm_set1_epi32(0x55555555));\n        data = _mm_add_epi32(tmp1, tmp2);\n\n        tmp1 = _mm_srli_epi32(data, 2);\n        tmp2 = _mm_and_si128(data, _mm_set1_epi32(0x33333333));\n        tmp1 = _mm_and_si128(tmp1, _mm_set1_epi32(0x33333333));\n        data = _mm_add_epi32(tmp1, tmp2);\n\n        tmp1 = _mm_srli_epi32(data, 4);\n        tmp2 = _mm_and_si128(data, _mm_set1_epi32(0x0F0F0F0F));\n        tmp1 = _mm_and_si128(tmp1, _mm_set1_epi32(0x0F0F0F0F));\n        data = _mm_add_epi32(tmp1, tmp2);\n\n        tmp1 = _mm_srli_epi32(data, 8);\n        tmp2 = _mm_add_epi32(data, tmp1);\n\n        tmp1 = _mm_srli_epi32(tmp2, 16);\n        data = _mm_add_epi32(tmp2, tmp1);\n\n        // Extract the counts and store them\n        uint32_t temp_counts[4];\n        _mm_storeu_si128((__m128i*)temp_counts, data);\n\n        out[i + 0] = (uint8_t)temp_counts[0];\n        out[i + 1] = (uint8_t)temp_counts[1];\n        out[i + 2] = (uint8_t)temp_counts[2];\n        out[i + 3] = (uint8_t)temp_counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i counts = _mm_setzero_si128();\n\n        // Count bits using bit manipulation intrinsics\n        for (int j = 0; j < 32; ++j) {\n            __m128i shifted = _mm_srli_epi32(data, 1);\n            __m128i bit = _mm_and_si128(data, _mm_set1_epi32(1));\n            counts = _mm_add_epi32(counts, bit);\n            data = shifted;\n        }\n\n        // Move the counts to an array\n        uint32_t temp_counts[4];\n        _mm_storeu_si128((__m128i*)temp_counts, counts);\n\n        // Store the counts in the output array\n        out[i] = (uint8_t)temp_counts[0];\n        out[i + 1] = (uint8_t)temp_counts[1];\n        out[i + 2] = (uint8_t)temp_counts[2];\n        out[i + 3] = (uint8_t)temp_counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            count += (val & 1);\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i counts = _mm_setzero_si128();\n\n        // Count bits using a bitwise approach (can be optimized further with lookup tables)\n        for (int j = 0; j < 32; ++j) {\n            __m128i mask = _mm_set1_epi32(1 << j);\n            __m128i masked_data = _mm_and_si128(data, mask);\n            __m128i cmp_result = _mm_cmpeq_epi32(masked_data, mask);\n            __m128i increment = _mm_and_si128(cmp_result, _mm_set1_epi32(1));\n            counts = _mm_add_epi32(counts, increment);\n        }\n\n        // Extract the counts and store them in the output array\n        uint32_t temp_counts[4];\n        _mm_storeu_si128((__m128i*)temp_counts, counts);\n        out[i] = (uint8_t)temp_counts[0];\n        out[i + 1] = (uint8_t)temp_counts[1];\n        out[i + 2] = (uint8_t)temp_counts[2];\n        out[i + 3] = (uint8_t)temp_counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((const __m128i*)(A + i)); // Load 4 integers\n\n        // Use popcount intrinsic to count bits in each integer\n        uint8_t counts[4];\n        counts[0] = _mm_popcnt_u32(_mm_cvtsi128_si32(data));\n        counts[1] = _mm_popcnt_u32(_mm_cvtsi128_si32(_mm_srli_si128(data, 4)));\n        counts[2] = _mm_popcnt_u32(_mm_cvtsi128_si32(_mm_srli_si128(data, 8)));\n        counts[3] = _mm_popcnt_u32(_mm_cvtsi128_si32(_mm_srli_si128(data, 12)));\n\n        // Store the counts\n        out[i] = counts[0];\n        out[i + 1] = counts[1];\n        out[i + 2] = counts[2];\n        out[i + 3] = counts[3];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        out[i] = _mm_popcnt_u32(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t cols_simd = cols / 4 * 4;\n\n    __m128i divisor = _mm_set1_epi32(3);\n    __m128i zero = _mm_set1_epi32(0);\n    __m128i mask_sign = _mm_set1_epi32(0x7fffffff);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols_simd; j += 4) {\n            __m128i a = _mm_loadu_si128((const __m128i*)(A + i * cols + j));\n\n            __m128i remainder = _mm_sub_epi32(a, _mm_mullo_epi32(_mm_div_epi32(a, divisor), divisor));\n            __m128i condition = _mm_cmpeq_epi32(remainder, zero);\n\n            __m128i abs_a = _mm_and_si128(a, mask_sign);\n            __m128i result = _mm_blendv_epi8(a, abs_a, condition);\n\n            _mm_storeu_si128((__m128i*)(B + i * cols + j), result);\n        }\n\n        for (; j < cols; ++j) {\n            if (A[i * cols + j] % 3 == 0) {\n                B[i * cols + j] = abs(A[i * cols + j]);\n            } else {\n                B[i * cols + j] = A[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t cols_simd = cols / 4 * 4;\n\n    __m128i divisor = _mm_set1_epi32(3);\n    __m128i zero = _mm_set1_epi32(0);\n    __m128i sign_mask = _mm_set1_epi32(0x7fffffff);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols_simd; j += 4) {\n            __m128i a = _mm_loadu_si128((const __m128i*)(A + i * cols + j));\n\n            __m128i quotients = _mm_divrem_epi32(a, divisor).rem;\n            __m128i condition = _mm_cmpeq_epi32(quotients, zero);\n\n            __m128i abs_a = _mm_and_si128(a, sign_mask);\n            __m128i result = _mm_blendv_epi8(a, abs_a, condition);\n\n            _mm_storeu_si128((__m128i*)(B + i * cols + j), result);\n        }\n\n        for (; j < cols; ++j) {\n            if (A[i * cols + j] % 3 == 0) {\n                B[i * cols + j] = abs(A[i * cols + j]);\n            } else {\n                B[i * cols + j] = A[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t cols_simd = cols / 4 * 4;\n\n    __m128i divisor = _mm_set1_epi32(3);\n    __m128i zero = _mm_set1_epi32(0);\n    __m128i mask_sign = _mm_set1_epi32(0x7fffffff);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols_simd; j += 4) {\n            __m128i a = _mm_loadu_si128((const __m128i*)(A + i * cols + j));\n\n            __m128i remainder = _mm_sub_epi32(a, _mm_mullo_epi32(_mm_div_epi32(a, divisor), divisor));\n            __m128i condition = _mm_cmpeq_epi32(remainder, zero);\n\n            __m128i abs_a = _mm_and_si128(a, mask_sign);\n            __m128i result = _mm_blendv_epi8(a, abs_a, condition);\n\n            _mm_storeu_si128((__m128i*)(B + i * cols + j), result);\n        }\n\n        for (; j < cols; ++j) {\n            if (A[i * cols + j] % 3 == 0) {\n                B[i * cols + j] = abs(A[i * cols + j]);\n            } else {\n                B[i * cols + j] = A[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t cols_simd = cols / 4 * 4;\n\n    __m128i divisor = _mm_set1_epi32(3);\n    __m128i zero = _mm_set1_epi32(0);\n    __m128i mask_sign = _mm_set1_epi32(0x7fffffff);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols_simd; j += 4) {\n            __m128i a = _mm_loadu_si128((const __m128i*)(A + i * cols + j));\n\n            __m128i remainder = _mm_sub_epi32(a, _mm_mullo_epi32(_mm_div_epi32(a, divisor), divisor));\n            __m128i condition = _mm_cmpeq_epi32(remainder, zero);\n\n            __m128i abs_a = _mm_and_si128(a, mask_sign);\n            __m128i result = _mm_blendv_epi8(a, abs_a, condition);\n\n            _mm_storeu_si128((__m128i*)(B + i * cols + j), result);\n        }\n\n        for (; j < cols; ++j) {\n            if (A[i * cols + j] % 3 == 0) {\n                B[i * cols + j] = abs(A[i * cols + j]);\n            } else {\n                B[i * cols + j] = A[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t cols_simd = cols / 4 * 4;\n\n    __m128i divisor = _mm_set1_epi32(3);\n    __m128i zero = _mm_set1_epi32(0);\n    __m128i mask_sign = _mm_set1_epi32(0x7fffffff);\n\n    for (i = 0; i < rows; ++i) {\n        for (j = 0; j < cols_simd; j += 4) {\n            __m128i a = _mm_loadu_si128((const __m128i*)(A + i * cols + j));\n\n            __m128i remainder = _mm_sub_epi32(a, _mm_mullo_epi32(_mm_div_epi32(a, divisor), divisor));\n            __m128i condition = _mm_cmpeq_epi32(remainder, zero);\n\n            __m128i abs_a = _mm_and_si128(a, mask_sign);\n            __m128i result = _mm_blendv_epi8(a, abs_a, condition);\n\n            _mm_storeu_si128((__m128i*)(B + i * cols + j), result);\n        }\n\n        for (; j < cols; ++j) {\n            if (A[i * cols + j] % 3 == 0) {\n                B[i * cols + j] = abs(A[i * cols + j]);\n            } else {\n                B[i * cols + j] = A[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    __m128i rotate_mask = _mm_set1_epi32(0x0F);\n    __m128i all_ones = _mm_set1_epi32(0x0F);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n\n        uint32_t cond_mask = _mm_movemask_ps((__m128)condition);\n\n        uint32_t temp_dst[4];\n        for (int j = 0; j < 4; ++j) {\n            if (cond_mask & (1 << j)) {\n                temp_dst[j] = (src[i+j] >> rotate_bits) | (src[i+j] << (32 - rotate_bits));\n            } else {\n                temp_dst[j] = ~src[i+j];\n            }\n        }\n        _mm_storeu_si128((__m128i*)&dst[i], _mm_loadu_si128((const __m128i*)temp_dst));\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    __m128i rotate_mask = _mm_set1_epi32(0x0000000F);\n    __m128i all_ones = _mm_set1_epi32(0x0000000F);\n    __m128i rotate_bits_vec = _mm_set1_epi32(rotate_bits);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n\n        __m128i rotated_vec;\n        __m128i temp1, temp2;\n\n        // Rotate right using intrinsics\n        temp1 = _mm_srli_epi32(src_vec, rotate_bits);\n        temp2 = _mm_slli_epi32(src_vec, 32 - rotate_bits);\n        rotated_vec = _mm_or_si128(temp1, temp2);\n\n        __m128i negated_vec = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n\n        __m128i result_vec = _mm_blendv_epi8(negated_vec, rotated_vec, condition);\n\n        _mm_storeu_si128((__m128i*)(dst + i), result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    __m128i rotate_mask = _mm_set1_epi32(0x0F);\n    __m128i all_ones = _mm_set1_epi32(0x0F);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n\n        uint32_t cond_mask = _mm_movemask_epi8(condition);\n\n        uint32_t result[4];\n        for (int j = 0; j < 4; ++j) {\n            if ((cond_mask & (1 << (j * 4))) != 0) {\n                result[j] = (src[i + j] >> rotate_bits) | (src[i + j] << (32 - rotate_bits));\n            } else {\n                result[j] = ~src[i + j];\n            }\n        }\n        __m128i result_vec = _mm_loadu_si128((const __m128i*)result);\n        _mm_storeu_si128((__m128i*)(dst + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    __m128i rotate_mask = _mm_set1_epi32(0x0000000F);\n    __m128i all_ones = _mm_set1_epi32(0x0000000F);\n    __m128i rotate_bits_vec = _mm_set1_epi32(rotate_bits);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n\n        __m128i rotated_vec;\n        \n        // Rotate right using intrinsics\n        __m128i temp1 = _mm_srli_epi32(src_vec, _mm_cvtsi32_si128(rotate_bits));\n        __m128i temp2 = _mm_slli_epi32(src_vec, _mm_cvtsi32_si128(32 - rotate_bits));\n        rotated_vec = _mm_or_si128(temp1, temp2);\n\n        __m128i negated_vec = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n\n        __m128i result_vec = _mm_blendv_epi8(negated_vec, rotated_vec, condition);\n\n        _mm_storeu_si128((__m128i*)(dst + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    __m128i rotate_mask = _mm_set1_epi32(0x0000000F);\n    __m128i all_ones = _mm_set1_epi32(0x0000000F);\n    __m128i rotate_bits_vec = _mm_set1_epi32(rotate_bits);\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)&src[i]);\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n\n        __m128i rotated_vec;\n        \n        // Rotate right using intrinsics\n        __m128i temp1 = _mm_srli_epi32(src_vec, rotate_bits);\n        __m128i temp2 = _mm_slli_epi32(src_vec, 32 - rotate_bits);\n        rotated_vec = _mm_or_si128(temp1, temp2);\n\n        __m128i not_src_vec = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n\n        __m128i result_vec = _mm_blendv_epi8(not_src_vec, rotated_vec, condition);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (out);\n- A floating-point epsilon value (epsilon);\n- The common length of the tensors.\n\nYour goal is to perform element-wise comparison between tensors A and B.\nIf A[i] - B[i] > abs(epsilon), out[i] should be 1;\nif A[i] - B[i] < -abs(epsilon), out[i] should be -1;\nif abs(A[i] - B[i]) <= abs(epsilon), out[i] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_abs = _mm_set1_ps(fabsf(epsilon));\n    __m128 zero = _mm_set1_ps(0.0f);\n    __m128 one = _mm_set1_ps(1.0f);\n    __m128 neg_one = _mm_set1_ps(-1.0f);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff); // Absolute value\n\n        __m128 cmp_gt = _mm_cmpgt_ps(diff, epsilon_abs); // A - B > abs(epsilon)\n        __m128 cmp_lt = _mm_cmplt_ps(diff, _mm_sub_ps(zero, epsilon_abs)); // A - B < -abs(epsilon)\n        __m128 cmp_eq = _mm_cmple_ps(abs_diff, epsilon_abs); // abs(A - B) <= abs(epsilon)\n\n        // out[i] = (A[i] - B[i] > abs(epsilon)) ? 1 : ((A[i] - B[i] < -abs(epsilon)) ? -1 : 0);\n        __m128 result = _mm_blendv_ps(zero, one, cmp_gt); // If A - B > abs(epsilon), result = 1\n        result = _mm_blendv_ps(result, neg_one, cmp_lt); // If A - B < -abs(epsilon), result = -1\n        result = _mm_blendv_ps(result, zero, cmp_eq); // If abs(A - B) <= abs(epsilon), result = 0\n\n        // Convert float to int8_t\n        float temp[4];\n        _mm_storeu_ps(temp, result);\n        out[i + 0] = (int8_t)temp[0];\n        out[i + 1] = (int8_t)temp[1];\n        out[i + 2] = (int8_t)temp[2];\n        out[i + 3] = (int8_t)temp[3];\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (A[i] - B[i] > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (A[i] - B[i] < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (out);\n- A floating-point epsilon value (epsilon);\n- The common length of the tensors.\n\nYour goal is to perform element-wise comparison between tensors A and B.\nIf A[i] - B[i] > abs(epsilon), out[i] should be 1;\nif A[i] - B[i] < -abs(epsilon), out[i] should be -1;\nif abs(A[i] - B[i]) <= abs(epsilon), out[i] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_abs = _mm_set1_ps(fabsf(epsilon));\n    __m128 zero = _mm_setzero_ps();\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 diff = _mm_sub_ps(a, b);\n        __m128 cmp_gt = _mm_cmpgt_ps(diff, epsilon_abs);\n        __m128 cmp_lt = _mm_cmplt_ps(diff, _mm_sub_ps(zero, epsilon_abs));\n\n        int mask_gt = _mm_movemask_ps(cmp_gt);\n        int mask_lt = _mm_movemask_ps(cmp_lt);\n\n        for (int j = 0; j < 4; ++j) {\n            if (mask_gt & (1 << j)) {\n                out[i + j] = 1;\n            } else if (mask_lt & (1 << j)) {\n                out[i + j] = -1;\n            } else {\n                out[i + j] = 0;\n            }\n        }\n    }\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (out);\n- A floating-point epsilon value (epsilon);\n- The common length of the tensors.\n\nYour goal is to perform element-wise comparison between tensors A and B.\nIf A[i] - B[i] > abs(epsilon), out[i] should be 1;\nif A[i] - B[i] < -abs(epsilon), out[i] should be -1;\nif abs(A[i] - B[i]) <= abs(epsilon), out[i] should be 0.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_abs = _mm_set1_ps(fabsf(epsilon));\n    __m128 zero = _mm_set1_ps(0.0f);\n    __m128 one = _mm_set1_ps(1.0f);\n    __m128 neg_one = _mm_set1_ps(-1.0f);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff); // Absolute value\n\n        __m128 cmp_gt = _mm_cmpgt_ps(diff, epsilon_abs); // A - B > abs(epsilon)\n        __m128 cmp_lt = _mm_cmplt_ps(diff, _mm_sub_ps(zero, epsilon_abs)); // A - B < -abs(epsilon)\n        __m128 cmp_eq = _mm_cmple_ps(abs_diff, epsilon_abs); // abs(A - B) <= abs(epsilon)\n\n        // Create masks for each condition\n        __m128 result = _mm_and_ps(cmp_gt, one); // 1 if A - B > abs(epsilon)\n        result = _mm_or_ps(result, _mm_and_ps(cmp_lt, neg_one)); // -1 if A - B < -abs(epsilon)\n        result = _mm_or_ps(result, _mm_and_ps(cmp_eq, zero)); // 0 if abs(A - B) <= abs(epsilon)\n\n        // Convert float result to int8_t\n        float temp[4];\n        _mm_storeu_ps(temp, result);\n        out[i] = (int8_t)temp[0];\n        out[i + 1] = (int8_t)temp[1];\n        out[i + 2] = (int8_t)temp[2];\n        out[i + 3] = (int8_t)temp[3];\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n        __m128 cmp_gt_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 cmp_lt_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(cmp_gt_vec), _mm_set1_epi8(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(cmp_lt_vec), _mm_set1_epi8(-1)));\n        \n        __m128i zero_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_andnot_si128(_mm_or_si128(cmp_gt_vec, cmp_lt_vec), zero_vec));\n        \n        _mm_storeu_si128((__m128i*)&out[i], result_vec);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_abs_ps(diff_vec);\n        \n        __m128 greater_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128i result_vec = _mm_setzero_si128();\n        \n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(greater_vec), _mm_set1_epi8(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(less_vec), _mm_set1_epi8(-1)));\n        \n        __m128i zero_vec = _mm_set1_epi8(0);\n        result_vec = _mm_or_si128(result_vec, _mm_andnot_si128(_mm_or_si128(greater_vec, less_vec), zero_vec));\n        \n        _mm_storeu_si128((__m128i*)&out[i], result_vec);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const size_t vector_size = sizeof(__m128) / sizeof(float);\n    size_t i = 0;\n\n    // Define constants for INT32_MAX and INT32_MIN as SSE vectors\n    __m128 max_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::max()));\n    __m128 min_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::min()));\n\n    // Process the array in chunks of 4 floats\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load 4 floats from A into an SSE register\n        __m128 float_vector = _mm_loadu_ps(&A[i]);\n\n        // Compare the floats with INT32_MAX\n        __m128 greater_than_max = _mm_cmpgt_ps(float_vector, max_int);\n\n        // Compare the floats with INT32_MIN\n        __m128 less_than_min = _mm_cmplt_ps(float_vector, min_int);\n\n        // Clip the floats to the range [INT32_MIN, INT32_MAX]\n        float_vector = _mm_min_ps(float_vector, max_int);\n        float_vector = _mm_max_ps(float_vector, min_int);\n\n        // Convert the floats to integers\n        __m128i int_vector = _mm_cvttps_epi32(float_vector);\n\n        // Convert the SSE integer vector to an array of integers\n        int32_t int_array[vector_size];\n        _mm_storeu_si128((__m128i*)int_array, int_vector);\n\n        // Store the converted integers to B\n        for (size_t j = 0; j < vector_size; ++j) {\n            B[i + j] = int_array[j];\n        }\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        if (A[i] > std::numeric_limits<int32_t>::max()) {\n            B[i] = std::numeric_limits<int32_t>::max();\n        } else if (A[i] < std::numeric_limits<int32_t>::min()) {\n            B[i] = std::numeric_limits<int32_t>::min();\n        } else {\n            B[i] = static_cast<int32_t>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    __m128 max_float = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::max()));\n    __m128 min_float = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::min()));\n    __m128i max_int = _mm_set1_epi32(std::numeric_limits<int32_t>::max());\n    __m128i min_int = _mm_set1_epi32(std::numeric_limits<int32_t>::min());\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 float_values = _mm_loadu_ps(&A[i]);\n\n        __m128 clamped_values = _mm_max_ps(_mm_min_ps(float_values, max_float), min_float);\n\n        __m128i int_values = _mm_cvttps_epi32(clamped_values);\n\n        _mm_storeu_si128((__m128i*)&B[i], int_values);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > std::numeric_limits<int32_t>::max()) {\n            B[i] = std::numeric_limits<int32_t>::max();\n        } else if (val < std::numeric_limits<int32_t>::min()) {\n            B[i] = std::numeric_limits<int32_t>::min();\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const size_t vector_size = sizeof(__m128) / sizeof(float);\n    size_t i = 0;\n\n    // Define constants for INT32_MAX and INT32_MIN as SSE vectors\n    __m128 max_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::max()));\n    __m128 min_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::min()));\n\n    // Process the array in chunks of 4 floats\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load 4 floats from A into an SSE register\n        __m128 float_vector = _mm_loadu_ps(&A[i]);\n\n        // Compare the floats with INT32_MAX\n        __m128 greater_than_max = _mm_cmpgt_ps(float_vector, max_int);\n\n        // Compare the floats with INT32_MIN\n        __m128 less_than_min = _mm_cmplt_ps(float_vector, min_int);\n\n        // Use blendvps to select INT32_MAX if greater than max, otherwise keep the original float\n        float_vector = _mm_blendv_ps(float_vector, max_int, greater_than_max);\n\n        // Use blendvps to select INT32_MIN if less than min, otherwise keep the float from the previous step\n        float_vector = _mm_blendv_ps(float_vector, min_int, less_than_min);\n\n        // Convert the floats to integers with truncation\n        __m128i int_vector = _mm_cvttps_epi32(float_vector);\n\n        // Store the 4 integers to B\n        _mm_storeu_si128((__m128i*)&B[i], int_vector);\n    }\n\n    // Process the remaining elements one by one\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > std::numeric_limits<int32_t>::max()) {\n            B[i] = std::numeric_limits<int32_t>::max();\n        } else if (val < std::numeric_limits<int32_t>::min()) {\n            B[i] = std::numeric_limits<int32_t>::min();\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const size_t vector_size = sizeof(__m128) / sizeof(float);\n    size_t i = 0;\n\n    // Define constants for INT32_MAX and INT32_MIN as SSE vectors\n    __m128 max_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::max()));\n    __m128 min_int = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::min()));\n\n    // Process the array in chunks of 4 floats\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load 4 floats from A into an SSE vector\n        __m128 float_vector = _mm_loadu_ps(&A[i]);\n\n        // Compare the floats with INT32_MAX\n        __m128 greater_than_max = _mm_cmpgt_ps(float_vector, max_int);\n\n        // Compare the floats with INT32_MIN\n        __m128 less_than_min = _mm_cmplt_ps(float_vector, min_int);\n\n        // Use blendvps to replace values greater than INT32_MAX with INT32_MAX\n        float_vector = _mm_blendv_ps(float_vector, max_int, greater_than_max);\n\n        // Use blendvps to replace values less than INT32_MIN with INT32_MIN\n        float_vector = _mm_blendv_ps(float_vector, min_int, less_than_min);\n\n        // Convert the floats to integers\n        __m128i int_vector = _mm_cvttps_epi32(float_vector);\n\n        // Store the integers into B\n        _mm_storeu_si128((__m128i*)&B[i], int_vector);\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > std::numeric_limits<int32_t>::max()) {\n            B[i] = std::numeric_limits<int32_t>::max();\n        } else if (val < std::numeric_limits<int32_t>::min()) {\n            B[i] = std::numeric_limits<int32_t>::min();\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    __m128 max_float = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::max()));\n    __m128 min_float = _mm_set1_ps(static_cast<float>(std::numeric_limits<int32_t>::min()));\n    __m128i max_int = _mm_set1_epi32(std::numeric_limits<int32_t>::max());\n    __m128i min_int = _mm_set1_epi32(std::numeric_limits<int32_t>::min());\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 clamped = _mm_min_ps(_mm_max_ps(a, min_float), max_float);\n        __m128i result = _mm_cvttps_epi32(clamped);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > std::numeric_limits<int32_t>::max()) {\n            B[i] = std::numeric_limits<int32_t>::max();\n        } else if (val < std::numeric_limits<int32_t>::min()) {\n            B[i] = std::numeric_limits<int32_t>::min();\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 div_result = _mm_div_ps(a, b);\n        __m128 rounded_result = _mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128i int_result = _mm_cvttps_epi32(rounded_result);\n        _mm_storeu_si128((__m128i*)&C[i], int_result);\n    }\n    for (; i < size; ++i) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 div_result = _mm_div_ps(a, b);\n        __m128 rounded_result = _mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128i int_result = _mm_cvttps_epi32(rounded_result);\n        _mm_storeu_si128((__m128i*)&C[i], int_result);\n    }\n    for (; i < size; ++i) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 div_result = _mm_div_ps(a, b);\n        __m128 rounded_result = _mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128i int_result = _mm_cvttps_epi32(rounded_result);\n        _mm_storeu_si128((__m128i*)&C[i], int_result);\n    }\n    for (; i < size; ++i) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 div_result = _mm_div_ps(a, b);\n        __m128 rounded_result = _mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128i int_result = _mm_cvttps_epi32(rounded_result);\n        _mm_storeu_si128((__m128i*)&C[i], int_result);\n    }\n    for (; i < size; ++i) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 div_result = _mm_div_ps(a, b);\n        __m128 rounded_result = _mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128i int_result = _mm_cvttps_epi32(rounded_result);\n        _mm_storeu_si128((__m128i*)&C[i], int_result);\n    }\n    for (; i < size; ++i) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <float.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val_double = _mm_set1_pd(FLT_MAX);\n    __m128d min_val_double = _mm_set1_pd(-FLT_MAX);\n    __m128 max_val_float = _mm_set1_ps(FLT_MAX);\n    __m128 min_val_float = _mm_set1_ps(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        __m128d a = _mm_loadu_pd(A + i);\n\n        __m128d clamped_a = _mm_max_pd(_mm_min_pd(a, max_val_double), min_val_double);\n\n        __m128 low = _mm_cvtpd_ps(clamped_a);\n\n        _mm_storeu_ps(B + i, low);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <float.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val_double = _mm_set1_pd(FLT_MAX);\n    __m128d min_val_double = _mm_set1_pd(-FLT_MAX);\n    __m128 max_val_float = _mm_set1_ps(FLT_MAX);\n    __m128 min_val_float = _mm_set1_ps(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        __m128d a = _mm_loadu_pd(A + i);\n\n        __m128d clamped_a = _mm_max_pd(_mm_min_pd(a, max_val_double), min_val_double);\n\n        __m128 low = _mm_cvtpd_ps(clamped_a);\n\n        _mm_storeu_ps(B + i, low);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <float.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    __m128 max_float = _mm_set1_ps(FLT_MAX);\n    __m128 min_float = _mm_set1_ps(-FLT_MAX);\n\n    for (; i + 1 < size; i += 2) {\n        __m128d a = _mm_loadu_pd(A + i);\n        __m128  b = _mm_cvtpd_ps(a);\n\n        __m128 cmp_gt = _mm_cmpgt_ps(b, max_float);\n        __m128 cmp_lt = _mm_cmplt_ps(b, min_float);\n\n        b = _mm_blendv_ps(b, max_float, cmp_gt);\n        b = _mm_blendv_ps(b, min_float, cmp_lt);\n\n        _mm_storel_pi((__m64*)(B + i), b);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <float.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val_double = _mm_set1_pd(FLT_MAX);\n    __m128d min_val_double = _mm_set1_pd(-FLT_MAX);\n    __m128 max_val_float = _mm_set1_ps(FLT_MAX);\n    __m128 min_val_float = _mm_set1_ps(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        __m128d a = _mm_loadu_pd(A + i);\n\n        __m128d clamped_a = _mm_max_pd(_mm_min_pd(a, max_val_double), min_val_double);\n\n        __m128 low = _mm_cvtpd_ps(clamped_a);\n        _mm_storeu_ps(B + i, low);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <float.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128d max_float_double = _mm_set1_pd(FLT_MAX);\n    const __m128d min_float_double = _mm_set1_pd(-FLT_MAX);\n    const __m128 max_float = _mm_set1_ps(FLT_MAX);\n    const __m128 min_float = _mm_set1_ps(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        __m128d a_vec = _mm_loadu_pd(A + i);\n\n        __m128d cmp_gt = _mm_cmpgt_pd(a_vec, max_float_double);\n        __m128d cmp_lt = _mm_cmplt_pd(a_vec, min_float_double);\n\n        __m128d clamped_max = _mm_and_pd(cmp_gt, max_float_double);\n        __m128d clamped_min = _mm_and_pd(cmp_lt, min_float_double);\n        __m128d not_clamped = _mm_andnot_pd(cmp_gt, a_vec);\n        not_clamped = _mm_andnot_pd(cmp_lt, not_clamped);\n\n        __m128d result_double = _mm_or_pd(clamped_max, not_clamped);\n        result_double = _mm_or_pd(result_double, clamped_min);\n\n        __m128 result_float = _mm_cvtpd_ps(result_double);\n        _mm_storel_pi((__m64*)(B + i), result_float);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i]);\n        __m128i data2 = _mm_loadu_si128(&src[i + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 2], result1);\n        _mm_storeu_si128(&dst[i * 2 + 1], result2);\n        _mm_storeu_si128(&dst[i * 2 + 2], result3);\n        _mm_storeu_si128(&dst[i * 2 + 3], result4);\n    }\n\n    for (; i < size / 2; i++) {\n        B[i] = (int32_t)A[i * 2];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n\n        __m128i low = _mm_cvtepi16_epi32(a);\n        __m128i high = _mm_cvtepi16_epi32(_mm_srli_si128(a, 8));\n\n        _mm_storeu_si128((__m128i*)(B + i), low);\n        _mm_storeu_si128((__m128i*)(B + i + 4), high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        __m128i a = _mm_loadu_si128((const __m128i*)(A + i));\n\n        __m128i low = _mm_cvtepi16_epi32(a);\n        __m128i high = _mm_cvtepi16_epi32(_mm_srli_si128(a, 8));\n\n        _mm_storeu_si128((__m128i*)(B + i), low);\n        _mm_storeu_si128((__m128i*)(B + i + 4), high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i * 2]);\n        __m128i data2 = _mm_loadu_si128(&src[i * 2 + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 4], result1);\n        _mm_storeu_si128(&dst[i * 4 + 1], result2);\n        _mm_storeu_si128(&dst[i * 4 + 2], result3);\n        _mm_storeu_si128(&dst[i * 4 + 3], result4);\n    }\n\n    for (; i < size / 2; i++) {\n        B[i] = (int32_t)A[i * 2];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i]);\n        __m128i data2 = _mm_loadu_si128(&src[i + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 2], result1);\n        _mm_storeu_si128(&dst[i * 2 + 1], result2);\n        _mm_storeu_si128(&dst[i * 2 + 2], result3);\n        _mm_storeu_si128(&dst[i * 2 + 3], result4);\n    }\n\n    for (; i < size / 2; i++) {\n        B[i] = (int32_t)A[i * 2];\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_set1_ps(max_val - min_val);\n    __m128 zero_vec = _mm_set1_ps(0.0f);\n    __m128 one_vec = _mm_set1_ps(1.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec_int = _mm_cvtsi32_si128(control[i]);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+1], 1);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+2], 2);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+3], 3);\n        __m128 control_vec = _mm_cvtepi32_ps(control_vec_int);\n\n        __m128 cmp_vec = _mm_cmpgt_ps(control_vec, zero_vec);\n\n        __m128 result_vec = a_vec;\n        __m128 normalized_vec = _mm_div_ps(_mm_sub_ps(a_vec, min_vec), range_vec);\n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n\n        result_vec = _mm_blendv_ps(result_vec, normalized_vec, cmp_vec);\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_set1_ps(max_val - min_val);\n    __m128 zero_vec = _mm_set1_ps(0.0f);\n    __m128 one_vec = _mm_set1_ps(1.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_cvtepi32_ps(_mm_loadu_si128((const __m128i*)&control[i]));\n\n        __m128 cmp_vec = _mm_cmpgt_ps(control_vec, zero_vec);\n\n        __m128 result_vec = a_vec;\n        __m128 diff_vec = _mm_sub_ps(a_vec, min_vec);\n        __m128 normalized_vec = _mm_div_ps(diff_vec, range_vec);\n        \n        __m128 clamped_vec = _mm_max_ps(_mm_min_ps(normalized_vec, one_vec), zero_vec);\n\n        result_vec = _mm_blendv_ps(result_vec, clamped_vec, cmp_vec);\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_cvtepi32_ps(_mm_loadu_si128((const __m128i*)&control[i]));\n\n        __m128 mask = _mm_cmpgt_ps(control_vec, zero_vec);\n\n        __m128 result_vec = _mm_loadu_ps(&A[i]);\n\n        __m128 diff_vec = _mm_sub_ps(a_vec, min_vec);\n        __m128 normalized_vec = _mm_div_ps(diff_vec, range_vec);\n\n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n\n        result_vec = _mm_blendv_ps(result_vec, normalized_vec, mask);\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_set1_ps(max_val - min_val);\n    __m128 zero_vec = _mm_set1_ps(0.0f);\n    __m128 one_vec = _mm_set1_ps(1.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_cvtepi32_ps(_mm_loadu_si128((const __m128i*)&control[i]));\n\n        __m128 cmp_vec = _mm_cmpgt_ps(control_vec, zero_vec);\n\n        __m128 result_vec = a_vec;\n        __m128 diff_vec = _mm_sub_ps(a_vec, min_vec);\n        __m128 normalized_vec = _mm_div_ps(diff_vec, range_vec);\n\n        __m128 clamped_vec = _mm_max_ps(_mm_min_ps(normalized_vec, one_vec), zero_vec);\n\n        result_vec = _mm_blendv_ps(result_vec, clamped_vec, cmp_vec);\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_set1_ps(max_val - min_val);\n    __m128 zero_vec = _mm_set1_ps(0.0f);\n    __m128 one_vec = _mm_set1_ps(1.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec_int = _mm_cvtsi32_si128(control[i]);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+1], 1);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+2], 2);\n        control_vec_int = _mm_insert_epi32(control_vec_int, control[i+3], 3);\n        __m128 control_vec = _mm_cvtepi32_ps(control_vec_int);\n\n        __m128 cmp_vec = _mm_cmpgt_ps(control_vec, zero_vec);\n\n        __m128 result_vec = a_vec;\n\n        __m128 diff_vec = _mm_sub_ps(a_vec, min_vec);\n        __m128 normalized_vec = _mm_div_ps(diff_vec, range_vec);\n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n\n        result_vec = _mm_blendv_ps(result_vec, normalized_vec, cmp_vec);\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        _mm_storeu_ps(B + i, sqrt_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        uint32_t high_bits = val >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        _mm_storeu_ps(B + i, sqrt_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        uint32_t high_bits = val >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i source = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(source, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        uint32_t high_bits = val >> 16;\n        float converted = (float)high_bits;\n        float result = sqrtf(converted);\n        B[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        _mm_storeu_ps(B + i, sqrt_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        uint32_t high_bits = val >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        _mm_storeu_ps(B + i, sqrt_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        uint32_t high_bits = val >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Interpret the bit pattern of each uint32_t value in A as an IEEE 754 floating-point representation\n2. Store the resulting float value in B without any numerical conversion\n3. This is effectively a type-punning operation that reinterprets the bits directly\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_data = _mm_castsi128_ps(int_data);\n        _mm_storeu_ps(B + i, float_data);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        B[i] = *((float*)&int_val);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_data = _mm_castsi128_ps(int_data);\n        _mm_storeu_ps(B + i, float_data);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_data = _mm_castsi128_ps(int_data);\n        _mm_storeu_ps(B + i, float_data);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_data = _mm_castsi128_ps(int_data);\n        _mm_storeu_ps(B + i, float_data);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_data = _mm_loadu_si128((const __m128i*)(A + i));\n        __m128 float_data = _mm_castsi128_ps(int_data);\n        _mm_storeu_ps(B + i, float_data);\n    }\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (src);\n- A pointer to a non-empty 64-bit unsigned integer (uint64_t) destination array (dst);\n- The common length of the arrays (length).\n\nYour goal is to:\n1. Convert each element in src to a 64-bit unsigned integer;\n2. Set all the high 32 bits of each value to 1 and store the results in dst.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    // Process the array in chunks of 4 elements using SSE/SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit integers from src into an XMM register\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n\n        // Convert the 4 32-bit integers to 4 64-bit integers\n        // using _mm_cvtepu32_epi64. This intrinsic is not directly available,\n        // so we need to emulate it using other SSE2 intrinsics.\n\n        // Unpack the 4 32-bit integers into two XMM registers, each containing 2 64-bit integers\n        __m128i dst_vec1 = _mm_cvtepu32_epi64(src_vec);\n        __m128i src_vec_shifted = _mm_srli_si128(src_vec, 8);\n        __m128i dst_vec2 = _mm_cvtepu32_epi64(src_vec_shifted);\n\n        // Set the high 32 bits of each 64-bit integer to 1\n        __m128i mask = _mm_set1_epi64x(0xFFFFFFFF00000000ULL);\n        dst_vec1 = _mm_or_si128(dst_vec1, mask);\n        dst_vec2 = _mm_or_si128(dst_vec2, mask);\n\n        // Store the 2 64-bit integers from each XMM register into the destination array\n        _mm_storeu_si128((__m128i*)(dst + i), dst_vec1);\n        _mm_storeu_si128((__m128i*)(dst + i + 2), dst_vec2);\n    }\n\n    // Process the remaining elements one by one\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (src);\n- A pointer to a non-empty 64-bit unsigned integer (uint64_t) destination array (dst);\n- The common length of the arrays (length).\n\nYour goal is to:\n1. Convert each element in src to a 64-bit unsigned integer;\n2. Set all the high 32 bits of each value to 1 and store the results in dst.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    // Process the array in chunks of 4 elements\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit integers from src\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n\n        // Convert 4 32-bit integers to 4 64-bit integers\n        __m128i dst_low = _mm_cvtepu32_epi64(src_vec);\n\n        // Create a vector with all high 32 bits set to 1 (0xFFFFFFFF00000000)\n        __m128i high_bits = _mm_set1_epi64x(0xFFFFFFFF00000000);\n\n        // OR the high bits with the converted values\n        __m128i result_vec = _mm_or_si128(dst_low, high_bits);\n\n        // Store the 2 64-bit integers to dst\n        _mm_storeu_si128((__m128i*)(dst + 2 * i), result_vec);\n    }\n\n    // Process the remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i src_data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi32(0xFFFFFFFF);\n        __m128i low_bits = _mm_unpacklo_epi32(src_data, _mm_setzero_si128());\n        __m128i high_low_bits = _mm_unpacklo_epi64(low_bits, high_bits);\n        _mm_storeu_si128(&dst_ptr[i], high_low_bits);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] & 0xFFFFFFFF) | ((uint64_t)0xFFFFFFFF << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi64x(0xFFFFFFFF00000000);\n        __m128i low_bits = _mm_unpacklo_epi32(data, _mm_setzero_si128());\n        __m128i high_low_bits = _mm_unpackhi_epi32(data, _mm_setzero_si128());\n        \n        __m128i result_low = _mm_or_si128(low_bits, high_bits);\n        __m128i result_high = _mm_or_si128(high_low_bits, high_bits);\n        \n        _mm_storeu_si128(&dst_ptr[i * 2], result_low);\n        _mm_storeu_si128(&dst_ptr[i * 2 + 1], result_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i src_data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi64x(0xFFFFFFFF00000000);\n        __m128i low_bits = _mm_unpacklo_epi32(src_data, _mm_setzero_si128());\n        __m128i high_low_bits = _mm_unpackhi_epi32(src_data, _mm_setzero_si128());\n        \n        __m128i result_low = _mm_or_si128(low_bits, high_bits);\n        __m128i result_high = _mm_or_si128(high_low_bits, high_bits);\n        \n        _mm_storeu_si128(&dst_ptr[i * 2], result_low);\n        _mm_storeu_si128(&dst_ptr[i * 2 + 1], result_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(idx)]);\n        __m128d val2 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(_mm_srli_si128(idx, 2))]);\n        sum = _mm_add_pd(sum, val1);\n        sum = _mm_add_pd(sum, val2);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d v0 = _mm_cvtepi32_pd(_mm_unpacklo_epi16(idx, _mm_setzero_si128()));\n        __m128d v1 = _mm_cvtepi32_pd(_mm_unpackhi_epi16(idx, _mm_setzero_si128()));\n        \n        __m128d val0 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v0)]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v1)]);\n        \n        sum = _mm_add_pd(sum, val0);\n        sum = _mm_add_pd(sum, val1);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_extract_epi16(idx, 0)]);\n        __m128d val2 = _mm_loadu_pd(&vec[_mm_extract_epi16(idx, 1)]);\n        sum = _mm_add_pd(sum, val1);\n        sum = _mm_add_pd(sum, val2);\n    }\n\n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point source array (vec);\n- A pointer to a non-empty 16-bit integer (int16_t) index array (index);\n- The common length of the arrays (length).\n\nYour goal is to:\nFor all legal indices `index[i]` (i.e., within the range [0, length)), sum the elements `vec[index[i]]`, \nand return the result.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point source array (vec);\n- A pointer to a non-empty 16-bit integer (int16_t) index array (index);\n- The common length of the arrays (length).\n\nYour goal is to:\nFor all legal indices `index[i]` (i.e., within the range [0, length)), sum the elements `vec[index[i]]`, \nand return the result.\n\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            double sum = 0.0;\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_row = i + m;\n                    size_t input_col = j + n;\n                    size_t kernel_index = m * kernel_size + n;\n                    double input_val = input[input_row * input_size + input_col];\n                    double kernel_val = kernel[kernel_index];\n                    sum += input_val * kernel_val;\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            double sum = 0.0;\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_row = i + m;\n                    size_t input_col = j + n;\n                    size_t kernel_index = m * kernel_size + n;\n\n                    sum += input[input_row * input_size + input_col] * kernel[kernel_index];\n                }\n            }\n\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SSE/SSE2 (Streaming SIMD Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        __m128d num_i_vec = _mm_set1_pd(numbers[i]);\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            __m128d num_j_vec = _mm_set1_pd(numbers[j]);\n            __m128d diff_vec = _mm_sub_pd(num_i_vec, num_j_vec);\n            diff_vec = _mm_abs_pd(diff_vec);\n\n            if (_mm_comilt_sd(diff_vec, threshold_vec)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        __m128d num_i_vec = _mm_set1_pd(numbers[i]);\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            __m128d num_j_vec = _mm_set1_pd(numbers[j]);\n            __m128d diff_vec = _mm_sub_pd(num_i_vec, num_j_vec);\n            diff_vec = _mm_abs_pd(diff_vec);\n\n            if (_mm_comilt_sd(diff_vec, threshold_vec)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        __m128d num_i_vec = _mm_set1_pd(numbers[i]);\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            __m128d num_j_vec = _mm_set1_pd(numbers[j]);\n            __m128d diff_vec = _mm_sub_pd(num_i_vec, num_j_vec);\n            diff_vec = _mm_fabs_pd(diff_vec);\n\n            __m128d cmp_vec = _mm_cmplt_pd(diff_vec, threshold_vec);\n            if (_mm_movemask_pd(cmp_vec)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        __m128d num_i_vec = _mm_set1_pd(numbers[i]);\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            __m128d num_j_vec = _mm_set1_pd(numbers[j]);\n            __m128d diff_vec = _mm_sub_pd(num_i_vec, num_j_vec);\n            diff_vec = _mm_abs_pd(diff_vec);\n\n            if (_mm_comilt_sd(diff_vec, threshold_vec)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        __m128d num_i_vec = _mm_set1_pd(numbers[i]);\n\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            __m128d num_j_vec = _mm_set1_pd(numbers[j]);\n            __m128d diff_vec = _mm_sub_pd(num_i_vec, num_j_vec);\n            __m128d abs_diff_vec = _mm_abs_pd(diff_vec);\n            __m128d cmp_vec = _mm_cmplt_pd(abs_diff_vec, threshold_vec);\n\n            if (_mm_movemask_pd(cmp_vec) != 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (int i = 0; i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (int i = 0; i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (int i = 0; i + 3 < operations.size(); i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        int op0 = operations[i];\n        int op1 = operations[i+1];\n        int op2 = operations[i+2];\n        int op3 = operations[i+3];\n\n        if (balance + op0 < 0) return true;\n        balance += op0;\n        if (balance + op1 < 0) return true;\n        balance += op1;\n        if (balance + op2 < 0) return true;\n        balance += op2;\n        if (balance + op3 < 0) return true;\n        balance += op3;\n    }\n    for (int i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (int i = 0; i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    for (int i = 0; i + 3 < operations.size(); i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        int op0 = operations[i];\n        int op1 = operations[i+1];\n        int op2 = operations[i+2];\n        int op3 = operations[i+3];\n\n        if (balance + op0 < 0 || balance + op0 + op1 < 0 || balance + op0 + op1 + op2 < 0 || balance + op0 + op1 + op2 + op3 < 0) {\n            return true;\n        }\n        balance += op0 + op1 + op2 + op3;\n    }\n    for (int i = operations.size() - (operations.size() % 4); i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad = 0.0;\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        __m128d mad_sum = _mm_setzero_pd();\n        __m128d mean_vec = _mm_set1_pd(mean);\n\n        for (; i + 3 < size; i += 4) {\n            __m128d num_vec1 = _mm_loadu_pd(&numbers[i]);\n            __m128d num_vec2 = _mm_loadu_pd(&numbers[i + 2]);\n\n            __m128d diff1 = _mm_sub_pd(num_vec1, mean_vec);\n            __m128d diff2 = _mm_sub_pd(num_vec2, mean_vec);\n\n            __m128d abs_diff1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff1);\n            __m128d abs_diff2 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff2);\n\n            mad_sum = _mm_add_pd(mad_sum, abs_diff1);\n            mad_sum = _mm_add_pd(mad_sum, abs_diff2);\n        }\n\n        double temp[2];\n        _mm_storeu_pd(temp, mad_sum);\n        mad = temp[0] + temp[1];\n    }\n\n    for (; i < size; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad = 0.0;\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d mad_vec = _mm_setzero_pd();\n\n        for (; i + 3 < size; i += 4) {\n            __m128d num_vec1 = _mm_loadu_pd(&numbers[i]);\n            __m128d num_vec2 = _mm_loadu_pd(&numbers[i + 2]);\n\n            __m128d diff_vec1 = _mm_sub_pd(num_vec1, mean_vec);\n            __m128d diff_vec2 = _mm_sub_pd(num_vec2, mean_vec);\n\n            __m128d abs_diff_vec1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec1);\n            __m128d abs_diff_vec2 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec2);\n\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec1);\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec2);\n        }\n\n        double temp_mad[2];\n        _mm_storeu_pd(temp_mad, mad_vec);\n        mad = temp_mad[0] + temp_mad[1];\n    }\n\n    for (; i < size; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad = 0.0;\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d mad_vec = _mm_setzero_pd();\n\n        for (; i + 3 < size; i += 4) {\n            __m128d num_vec1 = _mm_loadu_pd(&numbers[i]);\n            __m128d num_vec2 = _mm_loadu_pd(&numbers[i + 2]);\n\n            __m128d diff_vec1 = _mm_sub_pd(num_vec1, mean_vec);\n            __m128d diff_vec2 = _mm_sub_pd(num_vec2, mean_vec);\n\n            __m128d abs_diff_vec1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec1);\n            __m128d abs_diff_vec2 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec2);\n\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec1);\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec2);\n        }\n\n        double temp_mad[2];\n        _mm_storeu_pd(temp_mad, mad_vec);\n        mad = temp_mad[0] + temp_mad[1];\n    }\n\n    for (; i < size; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad = 0.0;\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size >= 4) {\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d mad_vec = _mm_setzero_pd();\n\n        for (; i + 3 < size; i += 4) {\n            __m128d num_vec1 = _mm_loadu_pd(&numbers[i]);\n            __m128d num_vec2 = _mm_loadu_pd(&numbers[i + 2]);\n\n            __m128d diff_vec1 = _mm_sub_pd(num_vec1, mean_vec);\n            __m128d diff_vec2 = _mm_sub_pd(num_vec2, mean_vec);\n\n            __m128d abs_diff_vec1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec1);\n            __m128d abs_diff_vec2 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec2);\n\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec1);\n            mad_vec = _mm_add_pd(mad_vec, abs_diff_vec2);\n        }\n\n        double temp_mad[2];\n        _mm_storeu_pd(temp_mad, mad_vec);\n        mad = temp_mad[0] + temp_mad[1];\n    }\n\n    for (; i < size; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    size_t i = 0;\n\n    if (numbers.size() >= 4) {\n        for (; i <= numbers.size() - 4; i += 4) {\n            __m128d vec = _mm_loadu_pd(&numbers[i]);\n            __m128d mean_vec = _mm_set1_pd(mean);\n            __m128d diff = _mm_sub_pd(vec, mean_vec);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff); \n\n            double temp[2];\n            _mm_storeu_pd(temp, abs_diff);\n            mad_sum += temp[0] + temp[1];\n        }\n    }\n\n    for (; i < numbers.size(); ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        for (; i <= size - 8; i += 8) {\n            __m128i vec = _mm_loadu_si128((const __m128i*)&numbers[i]);\n\n            // Convert int16_t to int32_t for sum\n            __m128i sum_low = _mm_cvtepi16_epi32(vec);\n            __m128i sum_high = _mm_cvtepi16_epi32(_mm_srli_si128(vec, 8));\n\n            // Horizontal add for sum_low\n            __m128i sum_temp_low = _mm_add_epi32(sum_low, _mm_shuffle_epi32(sum_low, _MM_SHUFFLE(1, 0, 3, 2)));\n            __m128i sum_result_low = _mm_add_epi32(sum_temp_low, _mm_shuffle_epi32(sum_temp_low, _MM_SHUFFLE(2, 3, 0, 1)));\n\n            // Horizontal add for sum_high\n            __m128i sum_temp_high = _mm_add_epi32(sum_high, _mm_shuffle_epi32(sum_high, _MM_SHUFFLE(1, 0, 3, 2)));\n            __m128i sum_result_high = _mm_add_epi32(sum_temp_high, _mm_shuffle_epi32(sum_temp_high, _MM_SHUFFLE(2, 3, 0, 1)));\n\n            // Extract the sum from the SSE register\n            int32_t sum_val_low = _mm_cvtsi128_si32(sum_result_low);\n            int32_t sum_val_high = _mm_cvtsi128_si32(sum_result_high);\n\n            sum += (int64_t)sum_val_low + (int64_t)sum_val_high;\n\n            // Product calculation (cannot be fully vectorized due to overflow risk and need for multiplication)\n            product *= (int64_t)numbers[i] * (int64_t)numbers[i+1] * (int64_t)numbers[i+2] * (int64_t)numbers[i+3] * (int64_t)numbers[i+4] * (int64_t)numbers[i+5] * (int64_t)numbers[i+6] * (int64_t)numbers[i+7];\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        for (; i <= size - 8; i += 8) {\n            __m128i vec = _mm_loadu_si128((const __m128i*)&numbers[i]);\n\n            // Convert int16_t to int32_t\n            __m128i vec_lo = _mm_cvtepi16_epi32(vec);\n            __m128i vec_hi = _mm_cvtepi16_epi32(_mm_srli_si128(vec, 8));\n\n            // Sum\n            int32_t sum_arr_lo[4];\n            int32_t sum_arr_hi[4];\n            _mm_storeu_si128((__m128i*)sum_arr_lo, vec_lo);\n            _mm_storeu_si128((__m128i*)sum_arr_hi, vec_hi);\n\n            sum += sum_arr_lo[0] + sum_arr_lo[1] + sum_arr_lo[2] + sum_arr_lo[3];\n            sum += sum_arr_hi[0] + sum_arr_hi[1] + sum_arr_hi[2] + sum_arr_hi[3];\n\n            // Product\n            product *= sum_arr_lo[0];\n            product *= sum_arr_lo[1];\n            product *= sum_arr_lo[2];\n            product *= sum_arr_lo[3];\n            product *= sum_arr_hi[0];\n            product *= sum_arr_hi[1];\n            product *= sum_arr_hi[2];\n            product *= sum_arr_hi[3];\n        }\n    }\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        for (; i <= size - 8; i += 8) {\n            __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n\n            // Sum\n            __m128i sum_vec = _mm_cvtepi16_epi32(vec);\n            __m128i sum_vec_hi = _mm_cvtepi16_epi32(_mm_srli_si128(vec, 8));\n\n            int32_t sum_arr[4];\n            int32_t sum_arr_hi[4];\n            _mm_storeu_si128((__m128i*)sum_arr, sum_vec);\n            _mm_storeu_si128((__m128i*)sum_arr_hi, sum_vec_hi);\n\n            sum += sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n            sum += sum_arr_hi[0] + sum_arr_hi[1] + sum_arr_hi[2] + sum_arr_hi[3];\n\n            // Product\n            int16_t prod_arr[8];\n            _mm_storeu_si128((__m128i*)prod_arr, vec);\n            product *= (int64_t)prod_arr[0] * prod_arr[1] * prod_arr[2] * prod_arr[3] * prod_arr[4] * prod_arr[5] * prod_arr[6] * prod_arr[7];\n        }\n    }\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        for (; i <= size - 8; i += 8) {\n            __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n\n            // Sum\n            __m128i sum_vec = _mm_cvtepi16_epi32(vec);\n            __m128i sum_vec_high = _mm_cvtepi16_epi32(_mm_srli_si128(vec, 8));\n            \n            int32_t sum_arr[4];\n            int32_t sum_arr_high[4];\n            _mm_storeu_si128((__m128i*)sum_arr, sum_vec);\n            _mm_storeu_si128((__m128i*)sum_arr_high, sum_vec_high);\n\n            sum += sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n            sum += sum_arr_high[0] + sum_arr_high[1] + sum_arr_high[2] + sum_arr_high[3];\n\n            // Product\n            int16_t prod_arr[8];\n            _mm_storeu_si128((__m128i*)prod_arr, vec);\n            product *= (int64_t)prod_arr[0] * (int64_t)prod_arr[1] * (int64_t)prod_arr[2] * (int64_t)prod_arr[3];\n            product *= (int64_t)prod_arr[4] * (int64_t)prod_arr[5] * (int64_t)prod_arr[6] * (int64_t)prod_arr[7];\n        }\n    }\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    if (size >= 8) {\n        for (; i <= size - 8; i += 8) {\n            __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n\n            // Sum\n            __m128i sum_vec = _mm_cvtepi16_epi32(vec);\n            __m128i sum_vec_high = _mm_cvtepi16_epi32(_mm_srli_si128(vec, 8));\n            \n            int32_t sum_arr[4];\n            int32_t sum_arr_high[4];\n            _mm_storeu_si128((__m128i*)sum_arr, sum_vec);\n            _mm_storeu_si128((__m128i*)sum_arr_high, sum_vec_high);\n\n            sum += sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n            sum += sum_arr_high[0] + sum_arr_high[1] + sum_arr_high[2] + sum_arr_high[3];\n\n            // Product\n            int16_t prod_arr[8];\n            _mm_storeu_si128((__m128i*)prod_arr, vec);\n            product *= (int64_t)prod_arr[0] * (int64_t)prod_arr[1] * (int64_t)prod_arr[2] * (int64_t)prod_arr[3];\n            product *= (int64_t)prod_arr[4] * (int64_t)prod_arr[5] * (int64_t)prod_arr[6] * (int64_t)prod_arr[7];\n        }\n    }\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int size = numbers.size();\n    int i = 1;\n    for (; i < size; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result = numbers;\n    if (numbers.size() == 0) {\n        return result;\n    }\n    int max_so_far = numbers[0];\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result = numbers;\n    if (numbers.size() == 0) {\n        return result;\n    }\n    int max_so_far = numbers[0];\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result = numbers;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    int size = numbers.size();\n    int i = 1;\n    for (; i < size; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result = numbers;\n    if (numbers.size() == 0) {\n        return result;\n    }\n    int max_so_far = numbers[0];\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    std::string result = \"\";\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string padded_a = a;\n    std::string padded_b = b;\n\n    while (padded_a.length() < len) {\n        padded_a = \"0\" + padded_a;\n    }\n    while (padded_b.length() < len) {\n        padded_b = \"0\" + padded_b;\n    }\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((const __m128i*)(padded_a.c_str() + i));\n        __m128i vec_b = _mm_loadu_si128((const __m128i*)(padded_b.c_str() + i));\n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n\n        char temp_result[16];\n        _mm_storeu_si128((__m128i*)temp_result, vec_result);\n\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] == '0' + '0') ? '0' : '1';\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((padded_a[i] - '0') ^ (padded_b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    std::string result = \"\";\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::min(len_a, len_b);\n\n    size_t i = 0;\n    for (; i + 15 < len; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((const __m128i*)(a.data() + i));\n        __m128i vec_b = _mm_loadu_si128((const __m128i*)(b.data() + i));\n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        char temp_result[16];\n        _mm_storeu_si128((__m128i*)temp_result, vec_result);\n\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] - '0') ? '1' : '0';\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int len_a = a.length();\n    int len_b = b.length();\n    int len = std::min(len_a, len_b);\n\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)(a.data() + i));\n        __m128i b_vec = _mm_loadu_si128((__m128i*)(b.data() + i));\n        __m128i xor_vec = _mm_xor_si128(a_vec, b_vec);\n        \n        char temp_res[16];\n        _mm_storeu_si128((__m128i*)temp_res, xor_vec);\n\n        for(int j = 0; j < 16; ++j){\n            result += temp_res[j];\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    std::string result = \"\";\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string padded_a = a;\n    std::string padded_b = b;\n\n    while (padded_a.length() < len) {\n        padded_a = \"0\" + padded_a;\n    }\n    while (padded_b.length() < len) {\n        padded_b = \"0\" + padded_b;\n    }\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((const __m128i*)(padded_a.c_str() + i));\n        __m128i vec_b = _mm_loadu_si128((const __m128i*)(padded_b.c_str() + i));\n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n\n        char temp_result[16];\n        _mm_storeu_si128((__m128i*)temp_result, vec_result);\n\n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] == '0' + '0') ? '0' : '1';\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((padded_a[i] - '0') ^ (padded_b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    std::string result = \"\";\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::min(len_a, len_b);\n\n    size_t i = 0;\n    for (; i + 15 < len; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((const __m128i*)(a.data() + i));\n        __m128i vec_b = _mm_loadu_si128((const __m128i*)(b.data() + i));\n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        char temp_result[16];\n        _mm_storeu_si128((__m128i*)temp_result, vec_result);\n        \n        for (int j = 0; j < 16; ++j) {\n            result += (temp_result[j] == '0' ? '0' : '1');\n        }\n    }\n\n    for (; i < len; ++i) {\n        result += ((a[i] == b[i]) ? '0' : '1');\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        size_t current_len = strings[i].length();\n        if (current_len > max_len) {\n            max_len = current_len;\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        size_t current_len = strings[i].length();\n        if (current_len > max_len) {\n            max_len = current_len;\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        size_t current_len = strings[i].length();\n        if (current_len > max_len) {\n            max_len = current_len;\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_len) {\n            longest_string = strings[i];\n            max_len = strings[i].length();\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    size_t max_len = longest_string.length();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        size_t current_len = strings[i].length();\n        if (current_len > max_len) {\n            max_len = current_len;\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = numbers[0];\n    float closest2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest1 = numbers[i];\n                closest2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest1 > closest2) {\n        std::swap(closest1, closest2);\n    }\n\n    return {closest1, closest2};\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] < min_val) {\n            min_val = numbers[i];\n        }\n        if (numbers[i] > max_val) {\n            max_val = numbers[i];\n        }\n    }\n\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    std::vector<float> result(numbers.size());\n\n    size_t i = 0;\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 min_vec = _mm_set1_ps(min_val);\n        __m128 range_vec = _mm_set1_ps(range);\n\n        __m128 sub_vec = _mm_sub_ps(vec, min_vec);\n        __m128 res_vec = _mm_div_ps(sub_vec, range_vec);\n\n        _mm_storeu_ps(&result[i], res_vec);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    std::vector<float> result(numbers.size());\n\n    size_t i = 0;\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 min_vec = _mm_set1_ps(min_val);\n        __m128 range_vec = _mm_set1_ps(range);\n\n        vec = _mm_sub_ps(vec, min_vec);\n        vec = _mm_div_ps(vec, range_vec);\n\n        _mm_storeu_ps(&result[i], vec);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] < min_val) {\n            min_val = numbers[i];\n        }\n        if (numbers[i] > max_val) {\n            max_val = numbers[i];\n        }\n    }\n\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    std::vector<float> result(numbers.size());\n\n    size_t i = 0;\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 min_vec = _mm_set1_ps(min_val);\n        __m128 range_vec = _mm_set1_ps(range);\n\n        __m128 sub_vec = _mm_sub_ps(vec, min_vec);\n        __m128 res_vec = _mm_div_ps(sub_vec, range_vec);\n\n        _mm_storeu_ps(&result[i], res_vec);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] < min_val) {\n            min_val = numbers[i];\n        }\n        if (numbers[i] > max_val) {\n            max_val = numbers[i];\n        }\n    }\n\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    std::vector<float> result(numbers.size());\n    size_t i = 0;\n\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 min_vec = _mm_set1_ps(min_val);\n        __m128 range_vec = _mm_set1_ps(range);\n\n        vec = _mm_sub_ps(vec, min_vec);\n        vec = _mm_div_ps(vec, range_vec);\n\n        _mm_storeu_ps(&result[i], vec);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    std::vector<float> result(numbers.size());\n\n    size_t i = 0;\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 min_vec = _mm_set1_ps(min_val);\n        __m128 range_vec = _mm_set1_ps(range);\n\n        vec = _mm_sub_ps(vec, min_vec);\n        vec = _mm_div_ps(vec, range_vec);\n\n        _mm_storeu_ps(&result[i], vec);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    if (n % 2 == 0) return n / 2;\n\n    for (uint64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    if (n % 2 == 0) return n / 2;\n\n    for (uint64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    if (n % 2 == 0) return n / 2;\n\n    for (uint64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    if (n % 2 == 0) return n / 2;\n\n    for (uint64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    if (n % 2 == 0) return n / 2;\n\n    for (uint64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int i = 0;\n    int size = l.size();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n\n        float temp[4];\n        _mm_storeu_ps(temp, mask);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int i = 0;\n    int size = l.size();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n\n        float temp[4];\n        _mm_storeu_ps(temp, mask);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int i = 0;\n    int size = l.size();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n\n        float temp[4];\n        _mm_storeu_ps(temp, mask);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int i = 0;\n    int size = l.size();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n\n        float temp[4];\n        _mm_storeu_ps(temp, mask);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    int i = 0;\n    int size = l.size();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n\n        float temp[4];\n        _mm_storeu_ps(temp, mask);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int n = s.length();\n    bool has_letter = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(result[i])) {\n            if (islower(result[i])) {\n                result[i] = toupper(result[i]);\n            } else {\n                result[i] = tolower(result[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int n = s.length();\n    bool hasLetters = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(s[i])) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i + 15 < n; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i lower = _mm_set1_epi8('a');\n        __m128i upper = _mm_set1_epi8('z');\n        __m128i isLower = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_sub_epi8(lower, _mm_set1_epi8(1))), _mm_cmpgt_epi8(upper, chars));\n\n        lower = _mm_set1_epi8('A');\n        upper = _mm_set1_epi8('Z');\n        __m128i isUpper = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_sub_epi8(lower, _mm_set1_epi8(1))), _mm_cmpgt_epi8(upper, chars));\n\n        __m128i mask = _mm_or_si128(isLower, isUpper);\n        __m128i diff = _mm_set1_epi8(32);\n        __m128i change = _mm_xor_si128(chars, _mm_and_si128(mask, diff));\n\n        _mm_storeu_si128((__m128i*)(result.data() + i), change);\n    }\n\n    for (; i < n; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int n = s.length();\n    bool has_letter = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(result[i])) {\n            if (islower(result[i])) {\n                result[i] = toupper(result[i]);\n            } else {\n                result[i] = tolower(result[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int n = s.length();\n    bool hasLetters = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(s[i])) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i + 15 < n; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i lower = _mm_and_si128(chars, _mm_set1_epi8(0x20)); \n        __m128i alpha = _mm_cmpeq_epi8(_mm_and_si128(chars, _mm_set1_epi8(0xDF)), chars);\n        alpha = _mm_and_si128(alpha, _mm_cmpeq_epi8(_mm_and_si128(chars, _mm_set1_epi8(0xBF)), chars));\n        __m128i change = _mm_and_si128(alpha, _mm_set1_epi8(0x20));\n        chars = _mm_xor_si128(chars, change);\n        _mm_storeu_si128((__m128i*)(result.data() + i), chars);\n    }\n\n    for (; i < n; ++i) {\n        if (isalpha(result[i])) {\n            if (islower(result[i])) {\n                result[i] = toupper(result[i]);\n            } else {\n                result[i] = tolower(result[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int n = s.length();\n    bool hasLetters = false;\n\n    for (int i = 0; i < n; ++i) {\n        if (isalpha(s[i])) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i + 15 < n; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i lower = _mm_set1_epi8('a');\n        __m128i upper = _mm_set1_epi8('z');\n        __m128i isLower = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_sub_epi8(lower, _mm_set1_epi8(1))), _mm_cmpgt_epi8(upper, chars));\n\n        lower = _mm_set1_epi8('A');\n        upper = _mm_set1_epi8('Z');\n        __m128i isUpper = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_sub_epi8(lower, _mm_set1_epi8(1))), _mm_cmpgt_epi8(upper, chars));\n\n        __m128i mask = _mm_or_si128(isLower, isUpper);\n        __m128i diff = _mm_set1_epi8(32);\n        __m128i change = _mm_xor_si128(chars, _mm_and_si128(mask, diff));\n\n        _mm_storeu_si128((__m128i*)(result.data() + i), change);\n    }\n\n    for (; i < n; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n\n            if (a > c) std::swap(a, c);\n            if (b > c) std::swap(b, c);\n            if (a > b) std::swap(a, b);\n\n            result[i] = a;\n        } else if (i < n) {\n            // Handle the case where there are not enough elements for a full group of three\n            // For simplicity, we just leave the last one or two elements as they are.\n            // If needed, you can add more sophisticated handling here.\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n\n            if (a > c) std::swap(a, c);\n            if (b > c) std::swap(b, c);\n            if (a > b) std::swap(a, b);\n\n            result[i] = a;\n        } else if (i < n) {\n            // Handle cases where there are fewer than 3 elements remaining\n            // For simplicity, we'll just leave them as they are.\n            // A more complete implementation might handle the remaining elements differently.\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n\n            if (a > c) std::swap(a, c);\n            if (b > c) std::swap(b, c);\n            if (a > b) std::swap(a, b);\n\n            result[i] = a;\n        } else if (i < n) {\n            // Handle the case where there are fewer than 3 elements remaining\n            // No sorting needed if fewer than 3 elements\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            int a = l[i];\n            int b = l[i + 1];\n            int c = l[i + 2];\n\n            if (a > c) std::swap(a, c);\n            if (b > c) std::swap(b, c);\n            if (a > b) std::swap(a, b);\n\n            result[i] = a;\n        } else if (i < n) {\n            // Handle the case where there are fewer than 3 elements remaining\n            // For simplicity, we'll just leave them as they are.\n            // You can add more sophisticated handling if needed.\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    std::vector<int> result = l;\n    int n = l.size();\n\n    for (int i = 0; i < n; i += 12) {\n        if (i + 2 < n) {\n            std::vector<int> sub_array;\n            for (int j = i; j < n && j < i + 12; j += 3) {\n                sub_array.push_back(l[j]);\n            }\n\n            std::sort(sub_array.begin(), sub_array.end());\n\n            int k = 0;\n            for (int j = i; j < n && j < i + 12; j += 3) {\n                result[j] = sub_array[k++];\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    int n = l.size();\n    float max_val = l[0];\n\n    if (n <= 4) {\n        for (int i = 1; i < n; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n        return max_val;\n    }\n\n    __m128 max_vector = _mm_loadu_ps(&l[0]);\n\n    for (int i = 4; i + 3 < n; i += 4) {\n        __m128 current_vector = _mm_loadu_ps(&l[i]);\n        max_vector = _mm_max_ps(max_vector, current_vector);\n    }\n\n    float temp_max[4];\n    _mm_storeu_ps(temp_max, max_vector);\n\n    for (int i = 0; i < 4; ++i) {\n        if (temp_max[i] > max_val) {\n            max_val = temp_max[i];\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    int n = l.size();\n    float max_val = l[0];\n\n    if (n <= 4) {\n        for (int i = 1; i < n; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n        return max_val;\n    }\n\n    __m128 max_vec = _mm_loadu_ps(&l[0]);\n\n    for (int i = 4; i + 3 < n; i += 4) {\n        __m128 current_vec = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, current_vec);\n    }\n\n    float temp_max[4];\n    _mm_storeu_ps(temp_max, max_vec);\n\n    for (int i = 0; i < 4; ++i) {\n        if (temp_max[i] > max_val) {\n            max_val = temp_max[i];\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    if (size == 0) return std::numeric_limits<float>::quiet_NaN();\n    \n    __m128 max_val = _mm_set1_ps(l[0]);\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128 current = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, current);\n    }\n    \n    float result[4];\n    _mm_storeu_ps(result, max_val);\n    \n    float max_result = result[0];\n    for (int i = 1; i < 4; ++i) {\n        max_result = std::max(max_result, result[i]);\n    }\n    \n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    int n = l.size();\n    float max_val = l[0];\n\n    if (n <= 4) {\n        for (int i = 1; i < n; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n        return max_val;\n    }\n\n    __m128 max_vector = _mm_loadu_ps(&l[0]);\n\n    for (int i = 4; i + 3 < n; i += 4) {\n        __m128 current_vector = _mm_loadu_ps(&l[i]);\n        max_vector = _mm_max_ps(max_vector, current_vector);\n    }\n\n    float temp_max[4];\n    _mm_storeu_ps(temp_max, max_vector);\n\n    for (int i = 0; i < 4; ++i) {\n        if (temp_max[i] > max_val) {\n            max_val = temp_max[i];\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    int n = l.size();\n    float max_val = l[0];\n\n    if (n <= 4) {\n        for (int i = 1; i < n; ++i) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n        return max_val;\n    }\n\n    __m128 max_vector = _mm_loadu_ps(&l[0]);\n\n    for (int i = 4; i <= n - 4; i += 4) {\n        __m128 current_vector = _mm_loadu_ps(&l[i]);\n        max_vector = _mm_max_ps(max_vector, current_vector);\n    }\n\n    float temp_max[4];\n    _mm_storeu_ps(temp_max, max_vector);\n\n    for (int i = 0; i < 4; ++i) {\n        if (temp_max[i] > max_val) {\n            max_val = temp_max[i];\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    int n = l.size();\n    if (n <= 1) return l;\n    std::vector<float> result = l;\n\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n / 2 - 1 - i; ++j) {\n            if (result[2 * j] > result[2 * (j + 1)]) {\n                std::swap(result[2 * j], result[2 * (j + 1)]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    int n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> result = l;\n\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n / 2 - 1 - i; ++j) {\n            if (result[2 * j] > result[2 * (j + 1)]) {\n                std::swap(result[2 * j], result[2 * (j + 1)]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    int n = l.size();\n    if (n <= 1) return l;\n    std::vector<float> result = l;\n\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n / 2 - i - 1; ++j) {\n            if (result[2 * j] > result[2 * (j + 1)]) {\n                std::swap(result[2 * j], result[2 * (j + 1)]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    int n = l.size();\n    if (n <= 1) return l;\n    std::vector<float> result = l;\n\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n / 2 - i - 1; ++j) {\n            if (result[2 * j] > result[2 * (j + 1)]) {\n                std::swap(result[2 * j], result[2 * (j + 1)]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    int n = l.size();\n    if (n <= 1) return l;\n    std::vector<float> result = l;\n\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = 0; j < n / 2 - 1 - i; ++j) {\n            if (result[2 * j] > result[2 * (j + 1)]) {\n                std::swap(result[2 * j], result[2 * (j + 1)]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        for (size_t j = i + 1; j < l.size() - 1; ++j) {\n            for (size_t k = j + 1; k < l.size(); ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    int aligned_size = size - (size % 4);\n    std::vector<int> result(size);\n\n    __m128i increment = _mm_set1_epi32(1);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i sum = _mm_add_epi32(data, increment);\n        _mm_storeu_si128((__m128i*)&result[i], sum);\n    }\n\n    for (int i = aligned_size; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    int aligned_size = size - (size % 4);\n    std::vector<int> result(size);\n\n    __m128i increment = _mm_set1_epi32(1);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i sum = _mm_add_epi32(data, increment);\n        _mm_storeu_si128((__m128i*)&result[i], sum);\n    }\n\n    for (int i = aligned_size; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    std::vector<int> result(size);\n\n    int i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i increment = _mm_set1_epi32(1);\n        __m128i sum = _mm_add_epi32(vec, increment);\n        _mm_storeu_si128((__m128i*)&result[i], sum);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    std::vector<int> result(size);\n\n    int i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i increment = _mm_set1_epi32(1);\n        __m128i res_vec = _mm_add_epi32(vec, increment);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    int size = l.size();\n    int aligned_size = size - (size % 4);\n    std::vector<int> result(size);\n\n    __m128i increment = _mm_set1_epi32(1);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i incremented_data = _mm_add_epi32(data, increment);\n        _mm_storeu_si128((__m128i*)&result[i], incremented_data);\n    }\n\n    for (int i = aligned_size; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\npairs_sum_to_zero takes a vector of integers as an input.\nit returns true if there are two distinct elements in the vector that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero_simd({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\npairs_sum_to_zero takes a vector of integers as an input.\nit returns true if there are two distinct elements in the vector that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero_simd({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n    for (int i = 0; i < l.size(); ++i) {\n        for (int j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nChange numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> change_base_simd(8, 3)\n\"22\"\n>>> change_base_simd(8, 2)\n\"1000\"\n>>> change_base_simd(7, 2)\n\"111\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n    int n = text.length();\n    if (n <= 1) return true;\n\n    int i = 0;\n    int j = n - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n    int n = text.length();\n    if (n <= 1) return true;\n\n    int i = 0;\n    int j = n - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n    int n = text.length();\n    if (n <= 1) return true;\n\n    int i = 0;\n    int j = n - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n    int n = text.length();\n    if (n <= 1) return true;\n\n    int i = 0;\n    int j = n - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n    int n = text.length();\n    if (n <= 1) return true;\n\n    int i = 0;\n    int j = n - 1;\n\n    while (i < j) {\n        if (text[i] != text[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i a = _mm_set1_epi8('a');\n        __m128i z = _mm_set1_epi8('z');\n        __m128i five = _mm_set1_epi8(5);\n        __m128i shift = _mm_sub_epi8(input, five);\n        __m128i cmp_a = _mm_cmpgt_epi8(a, shift);\n        __m128i add_26 = _mm_add_epi8(shift, _mm_set1_epi8(26));\n        __m128i result = _mm_blendv_epi8(shift, add_26, cmp_a);\n        _mm_storeu_si128((__m128i*)&out[i], result);\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i a = _mm_set1_epi8('a');\n        __m128i five = _mm_set1_epi8(5);\n        __m128i z = _mm_set1_epi8('z');\n\n        __m128i shifted = _mm_sub_epi8(input, five);\n        __m128i cmp = _mm_cmpgt_epi8(a, shifted);\n        __m128i add_26 = _mm_add_epi8(shifted, _mm_set1_epi8(26));\n        __m128i blend = _mm_blendv_epi8(shifted, add_26, cmp);\n\n        _mm_storeu_si128((__m128i*)&out[i], blend);\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) {\n            w += 26;\n        }\n        w = w % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using SSE/SSE2 intrinsics\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n\n        // Add 26 - 5 = 21 to each character. This is equivalent to subtracting 5 modulo 26.\n        __m128i shift = _mm_set1_epi8(21);\n        __m128i shifted = _mm_add_epi8(input, shift);\n\n        // Check if the shifted value is greater than 'z'. If so, subtract 26.\n        __m128i a_vec = _mm_set1_epi8('a');\n        __m128i z_vec = _mm_set1_epi8('z');\n        __m128i mask_lower = _mm_cmpgt_epi8(a_vec, input);\n        __m128i mask_upper = _mm_cmpgt_epi8(shifted, z_vec);\n        __m128i mask = _mm_andnot_si128(mask_lower, mask_upper);\n        \n        __m128i sub26 = _mm_set1_epi8(-26);\n        shifted = _mm_add_epi8(shifted, _mm_and_si128(mask, sub26));\n\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n\n    // Process remaining characters sequentially\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - (int)'a' + 21) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        __m128i a_vec = _mm_set1_epi8('a');\n        __m128i z_vec = _mm_set1_epi8('z');\n        __m128i five_vec = _mm_set1_epi8(5);\n        __m128i twenty_six_vec = _mm_set1_epi8(26);\n\n        __m128i temp = _mm_sub_epi8(input, five_vec);\n        __m128i cmp_a = _mm_cmpgt_epi8(a_vec, input);\n        __m128i mask = _mm_cmpeq_epi8(cmp_a, _mm_setzero_si128());\n\n        __m128i add_result = _mm_add_epi8(temp, twenty_six_vec);\n        __m128i result = _mm_blendv_epi8(temp, add_result, mask);\n\n        _mm_storeu_si128((__m128i*)&out[i], result);\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n    std::string out = s;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 bytes at a time using SSE/SSE2 intrinsics\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n\n        // Add 26 - 5 = 21 to each character. This is equivalent to subtracting 5 and wrapping around.\n        __m128i add_val = _mm_set1_epi8(21);\n        __m128i shifted = _mm_add_epi8(input, add_val);\n\n        // Check if the shifted value is greater than 'z'. If so, subtract 26 to wrap around.\n        __m128i a_val = _mm_set1_epi8('a');\n        __m128i z_val = _mm_set1_epi8('z');\n        __m128i less_than_a = _mm_cmplt_epi8(shifted, a_val);\n        __m128i greater_than_z = _mm_cmpgt_epi8(shifted, z_val);\n        __m128i mask = _mm_andnot_si128(less_than_a, greater_than_z);\n\n        // Subtract 26 if the character is outside the 'a' to 'z' range.\n        __m128i sub_val = _mm_set1_epi8(26);\n        __m128i sub_mask = _mm_and_si128(mask, sub_val);\n        shifted = _mm_sub_epi8(shifted, sub_mask);\n\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n\n    // Process remaining characters sequentially\n    for (; i < len; i++) {\n        int w = ((int)s[i] + 21 - (int)'a') % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    int i = 0;\n    __m128i threshold = _mm_set1_epi32(t);\n    for (; i + 4 <= n; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(data, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0xFFFF) {\n            return false;\n        }\n    }\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    int i = 0;\n    __m128i threshold = _mm_set1_epi32(t);\n    for (; i + 4 <= n; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(data, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0xFFFF) {\n            return false;\n        }\n    }\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    int i = 0;\n    __m128i threshold = _mm_set1_epi32(t);\n    for (; i + 4 <= n; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(data, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0xFFFF) {\n            return false;\n        }\n    }\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    int size = l.size();\n    int i = 0;\n    __m128i threshold = _mm_set1_epi32(t);\n    for (; i + 4 <= size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(data, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0xFFFF) {\n            return false;\n        }\n    }\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    int i = 0;\n    __m128i threshold = _mm_set1_epi32(t);\n    for (; i + 4 <= n; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(data, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0xFFFF) {\n            return false;\n        }\n    }\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    for (int i = 0; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    for (int i = 0; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    for (int i = 0; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    for (int i = 0; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    for (int i = 0; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int n = brackets.length();\n\n    if (n == 0) return true;\n\n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int n = brackets.length();\n\n    if (n == 0) return true;\n\n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int n = brackets.length();\n\n    if (n == 0) return true;\n\n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int n = brackets.length();\n\n    if (n == 0) return true;\n\n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int n = brackets.length();\n    if (n == 0) return true;\n\n    for (int i = 0; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    for (int i = 1; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    __m128i vowels_aeiou = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    \n    int i = 0;\n    for (; i <= n - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i cmp = _mm_cmpeq_epi8(chars, vowels_aeiou);\n        __m128i mask = _mm_movemask_epi8(cmp);\n        count += _mm_popcnt_u32(_mm_cvtsi128_si32(mask));\n    }\n\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    if (s[n - 1] == 'y' || s[n - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n    int count = 0;\n    int n = s.length();\n\n    if (n == 0) return 0;\n\n    for (int i = 0; i < n; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == n - 1 && c == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    __m128i vowels_aeiou = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    \n    int i = 0;\n    for (; i + 15 < n; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i cmp = _mm_cmpeq_epi8(chars, vowels_aeiou);\n        __m128i mask = _mm_movemask_epi8(cmp);\n        count += _mm_popcnt_u32(_mm_cvtsi128_si32(mask));\n    }\n\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    if (s[n - 1] == 'y' || s[n - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    for (int i = 0; i < n; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == n - 1 && c == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    for (int i = 0; i < n; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == n - 1 && c == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process the string in chunks of 16 characters\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n\n        // Create a mask for uppercase letters (A-Z)\n        __m128i mask_lower = _mm_set1_epi8('A');\n        __m128i mask_upper = _mm_set1_epi8('Z');\n\n        __m128i cmp_lower = _mm_cmpgt_epi8(chars, _mm_sub_epi8(mask_lower, _mm_set1_epi8(1)));\n        __m128i cmp_upper = _mm_cmplt_epi8(chars, _mm_add_epi8(mask_upper, _mm_set1_epi8(1)));\n\n        __m128i and_mask = _mm_and_si128(cmp_lower, cmp_upper);\n\n        // Extract the mask as an integer\n        int mask = _mm_movemask_epi8(and_mask);\n\n        // Sum the ASCII values of the uppercase letters\n        for (int j = 0; j < 16; ++j) {\n            if ((mask >> j) & 1) {\n                sum += s[i + j];\n            }\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process the string in chunks of 16 characters\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n\n        // Create a mask for uppercase letters (A-Z)\n        __m128i mask_lower = _mm_set1_epi8('A');\n        __m128i mask_upper = _mm_set1_epi8('Z');\n\n        __m128i cmp_lower = _mm_cmpgt_epi8(chars, _mm_sub_epi8(mask_lower, _mm_set1_epi8(1)));\n        __m128i cmp_upper = _mm_cmplt_epi8(chars, _mm_add_epi8(mask_upper, _mm_set1_epi8(1)));\n\n        __m128i and_mask = _mm_and_si128(cmp_lower, cmp_upper);\n\n        // Extract the mask as an integer\n        int mask = _mm_movemask_epi8(and_mask);\n\n        // Sum the ASCII values of uppercase letters\n        for (int j = 0; j < 16; ++j) {\n            if ((mask >> j) & 1) {\n                sum += s[i + j];\n            }\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process the string in chunks of 16 characters\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n\n        // Create a mask for uppercase letters (A-Z)\n        __m128i mask_lower = _mm_set1_epi8('A');\n        __m128i mask_upper = _mm_set1_epi8('Z');\n\n        __m128i cmp_lower = _mm_cmpgt_epi8(chars, _mm_sub_epi8(mask_lower, _mm_set1_epi8(1)));\n        __m128i cmp_upper = _mm_cmplt_epi8(chars, _mm_add_epi8(mask_upper, _mm_set1_epi8(1)));\n        __m128i and_mask = _mm_and_si128(cmp_lower, cmp_upper);\n\n        // Extract the uppercase characters and sum their ASCII values\n        unsigned int mask = _mm_movemask_epi8(and_mask);\n        for (int j = 0; j < 16; ++j) {\n            if ((mask >> j) & 1) {\n                sum += s[i + j];\n            }\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process the string in chunks of 16 characters\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n\n        // Create a mask for uppercase letters (A-Z)\n        __m128i mask_lower = _mm_set1_epi8('A');\n        __m128i mask_upper = _mm_set1_epi8('Z');\n\n        __m128i cmp_lower = _mm_cmpgt_epi8(chars, _mm_sub_epi8(mask_lower, _mm_set1_epi8(1)));\n        __m128i cmp_upper = _mm_cmplt_epi8(chars, _mm_add_epi8(mask_upper, _mm_set1_epi8(1)));\n\n        __m128i and_mask = _mm_and_si128(cmp_lower, cmp_upper);\n\n        // Extract the mask as an integer\n        int mask = _mm_movemask_epi8(and_mask);\n\n        // Sum the ASCII values of uppercase letters\n        for (int j = 0; j < 16; ++j) {\n            if ((mask >> j) & 1) {\n                sum += s[i + j];\n            }\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process the string in chunks of 16 characters\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n\n        // Create a mask for uppercase letters (A-Z)\n        __m128i mask_lower = _mm_set1_epi8('A');\n        __m128i mask_upper = _mm_set1_epi8('Z');\n\n        __m128i cmp_lower = _mm_cmpgt_epi8(chars, _mm_sub_epi8(mask_lower, _mm_set1_epi8(1)));\n        __m128i cmp_upper = _mm_cmplt_epi8(chars, _mm_add_epi8(mask_upper, _mm_set1_epi8(1)));\n\n        __m128i and_mask = _mm_and_si128(cmp_lower, cmp_upper);\n\n        // Extract the mask as an integer\n        int mask = _mm_movemask_epi8(and_mask);\n\n        // Sum the ASCII values of the uppercase letters\n        for (int j = 0; j < 16; ++j) {\n            if ((mask >> j) & 1) {\n                sum += s[i + j];\n            }\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = -1;\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_even == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = -1;\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_even == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = -1;\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_even == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    std::sort(lst.begin(), lst.end(), std::greater<int>());\n    int max_val = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == lst[i]) {\n                count++;\n            }\n        }\n        if (count >= lst[i] && lst[i] > max_val) {\n            max_val = lst[i];\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    std::sort(lst.begin(), lst.end(), std::greater<int>());\n    int max_val = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == lst[i]) {\n                count++;\n            }\n        }\n        if (count >= lst[i] && lst[i] > max_val) {\n            max_val = lst[i];\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n#include <vector>\n#include <algorithm>\n#include <map>\n\nint search_simd(std::vector<int> lst){\n    std::map<int, int> counts;\n    for (int x : lst) {\n        counts[x]++;\n    }\n\n    int result = -1;\n    for (auto const& [key, val] : counts) {\n        if (key <= val && key > result) {\n            result = key;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    std::sort(lst.begin(), lst.end(), std::greater<int>());\n    int max_val = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        int count = 0;\n        for (int j = 0; j < lst.size(); ++j) {\n            if (lst[j] == lst[i]) {\n                count++;\n            }\n        }\n        if (count >= lst[i] && lst[i] > max_val) {\n            max_val = lst[i];\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> counts(max_val + 1, 0);\n\n    for (int val : lst) {\n        counts[val]++;\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (counts[i] >= i) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindrome)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using SSE if possible\n    int sum = 0;\n    if (n >= 4) {\n        __m128i vec_sum = _mm_setzero_si128();\n        int i = 0;\n        for (; i <= n - 4; i += 4) {\n            __m128i vec_q = _mm_loadu_si128((__m128i*)&q[i]);\n            vec_sum = _mm_add_epi32(vec_sum, vec_q);\n        }\n\n        // Horizontal add to sum the 4 elements in vec_sum\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, vec_sum);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        // Add remaining elements\n        for (; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        // If n < 4, calculate sum sequentially\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    // Check if sum is less than or equal to w\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using SSE if possible\n    if (n >= 4) {\n        int sum = 0;\n        int i = 0;\n        __m128i sum_vec = _mm_setzero_si128();\n        for (; i <= n - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((__m128i*)&q[i]);\n            sum_vec = _mm_add_epi32(sum_vec, data);\n        }\n\n        // Horizontal add to get the sum of the vector\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, sum_vec);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        // Add remaining elements\n        for (; i < n; ++i) {\n            sum += q[i];\n        }\n\n        return sum <= w;\n    } else {\n        int sum = 0;\n        for (int x : q) {\n            sum += x;\n        }\n        return sum <= w;\n    }\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced (palindrome)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements using SSE\n    int sum = 0;\n    if (n >= 4) {\n        int i = 0;\n        __m128i sum_vec = _mm_setzero_si128();\n        for (; i <= n - 4; i += 4) {\n            __m128i data_vec = _mm_loadu_si128((__m128i*)&q[i]);\n            sum_vec = _mm_add_epi32(sum_vec, data_vec);\n        }\n        int temp_sum[4];\n        _mm_storeu_si128((__m128i*)temp_sum, sum_vec);\n        sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n\n        for (; i < n; ++i) {\n            sum += q[i];\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            sum += q[i];\n        }\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using SSE if possible\n    if (n >= 4) {\n        int sum = 0;\n        int i = 0;\n        __m128i sum_vec = _mm_setzero_si128();\n        for (; i <= n - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((__m128i*)&q[i]);\n            sum_vec = _mm_add_epi32(sum_vec, data);\n        }\n\n        // Horizontal add to get the sum of the vector\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, sum_vec);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        // Add remaining elements\n        for (; i < n; ++i) {\n            sum += q[i];\n        }\n\n        return sum <= w;\n    } else {\n        int sum = 0;\n        for (int x : q) {\n            sum += x;\n        }\n        return sum <= w;\n    }\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if balanced\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate sum using SSE if possible\n    if (n >= 4) {\n        int sum = 0;\n        int i = 0;\n        __m128i sum_vec = _mm_setzero_si128();\n        for (; i <= n - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((__m128i*)&q[i]);\n            sum_vec = _mm_add_epi32(sum_vec, data);\n        }\n\n        // Horizontal add to get the sum of the vector\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, sum_vec);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        // Add remaining elements\n        for (; i < n; ++i) {\n            sum += q[i];\n        }\n\n        return sum <= w;\n    } else {\n        int sum = 0;\n        for (int x : q) {\n            sum += x;\n        }\n        return sum <= w;\n    }\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n#include <vector>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <string>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for (const auto& str : lst1) {\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for (const auto& str : lst2) {\n        sum2 += str.length();\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    for(const auto& str : lst1){\n        sum1 += str.length();\n    }\n\n    size_t sum2 = 0;\n    for(const auto& str : lst2){\n        sum2 += str.length();\n    }\n\n    if(sum1 <= sum2){\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double log_x = log(x);\n    double log_n = log(n);\n    double result = log_x / log_n;\n    return (fabs(result - round(result)) < 1e-10);\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double log_x = log(x);\n    double log_n = log(n);\n    double result = log_x / log_n;\n    return (fabs(result - round(result)) < 1e-10);\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double dx = (double)x;\n    double dn = (double)n;\n\n    double power = log(dx) / log(dn);\n\n    return fabs(power - round(power)) < 1e-10;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double dx = (double)x;\n    double dn = (double)n;\n\n    double power = log(dx) / log(dn);\n\n    return fabs(power - round(power)) < 1e-10;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    double log_x = log(x);\n    double log_n = log(n);\n    double result = log_x / log_n;\n    return (fabs(result - round(result)) < 1e-10);\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    int len = num.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128((const __m128i*)(num.data() + i));\n\n        // Create masks for each prime hex digit\n        __m128i mask2 = _mm_set1_epi8('2');\n        __m128i mask3 = _mm_set1_epi8('3');\n        __m128i mask5 = _mm_set1_epi8('5');\n        __m128i mask7 = _mm_set1_epi8('7');\n        __m128i maskB = _mm_set1_epi8('B');\n        __m128i maskD = _mm_set1_epi8('D');\n\n        // Compare input with each mask\n        __m128i cmp2 = _mm_cmpeq_epi8(input, mask2);\n        __m128i cmp3 = _mm_cmpeq_epi8(input, mask3);\n        __m128i cmp5 = _mm_cmpeq_epi8(input, mask5);\n        __m128i cmp7 = _mm_cmpeq_epi8(input, mask7);\n        __m128i cmpB = _mm_cmpeq_epi8(input, maskB);\n        __m128i cmpD = _mm_cmpeq_epi8(input, maskD);\n\n        // Combine the comparison results\n        __m128i combined = _mm_or_si128(cmp2, cmp3);\n        combined = _mm_or_si128(combined, cmp5);\n        combined = _mm_or_si128(combined, cmp7);\n        combined = _mm_or_si128(combined, cmpB);\n        combined = _mm_or_si128(combined, cmpD);\n\n        // Move the result to a 128-bit mask\n        int mask = _mm_movemask_epi8(combined);\n\n        // Count the number of set bits in the mask\n        count += _mm_popcnt_u32(mask);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int len = num.length();\n\n    if (len == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    int len = num.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    int len = num.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0) return false;\n\n    for (int i = 3; i * i <= n; i = i + 2){\n        if (n % i == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary += (sum % 2 == 0) ? '0' : '1';\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i+=2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i+=2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i+=2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i+=2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = 'a' + (s[i] - 'a' + 4) % 26;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            encrypted_string[i] = 'A' + (s[i] - 'A' + 4) % 26;\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = 'a' + (s[i] - 'a' + 4) % 26;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            encrypted_string[i] = 'A' + (s[i] - 'A' + 4) % 26;\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = 'a' + (s[i] - 'a' + 4) % 26;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            encrypted_string[i] = 'A' + (s[i] - 'A' + 4) % 26;\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = 'a' + (s[i] - 'a' + 4) % 26;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            encrypted_string[i] = 'A' + (s[i] - 'A' + 4) % 26;\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    int len = s.length();\n\n    for (int i = 0; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            encrypted_string[i] = 'a' + (s[i] - 'a' + 4) % 26;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            encrypted_string[i] = 'A' + (s[i] - 'A' + 4) % 26;\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            encoded_message[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            encoded_message[i] = c + 32;\n        }\n\n        // Replace vowels\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n            default: break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            encoded_message[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            encoded_message[i] = c + 32;\n        }\n\n        // Replace vowels\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n            default: break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            encoded_message[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            encoded_message[i] = c + 32;\n        }\n\n        // Replace vowels\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n            default: break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n    int i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)&message[i]);\n\n        // Swap case\n        __m128i case_mask = _mm_set1_epi8(0x20);\n        __m128i upper_lower = _mm_xor_si128(chars, case_mask);\n        __m128i is_letter_mask = _mm_and_si128(chars, _mm_set1_epi8(0xE0)); // Check if it's a letter\n        __m128i swapped_chars = _mm_blendv_epi8(chars, upper_lower, is_letter_mask);\n\n        // Vowel replacement\n        __m128i a_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('a'));\n        __m128i e_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('e'));\n        __m128i i_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('i'));\n        __m128i o_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('o'));\n        __m128i u_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('u'));\n        __m128i A_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('A'));\n        __m128i E_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('E'));\n        __m128i I_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('I'));\n        __m128i O_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('O'));\n        __m128i U_mask = _mm_cmpeq_epi8(swapped_chars, _mm_set1_epi8('U'));\n\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('c'), a_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('g'), e_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('k'), i_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('q'), o_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('w'), u_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('C'), A_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('G'), E_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('K'), I_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('Q'), O_mask);\n        swapped_chars = _mm_blendv_epi8(swapped_chars, _mm_set1_epi8('W'), U_mask);\n\n        _mm_storeu_si128((__m128i*)&encoded_message[i], swapped_chars);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (isalpha(c)) {\n            if (islower(c)) {\n                encoded_message[i] = toupper(c);\n            } else {\n                encoded_message[i] = tolower(c);\n            }\n        }\n\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int len = message.length();\n\n    for (int i = 0; i < len; ++i) {\n        char c = encoded_message[i];\n\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            encoded_message[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            encoded_message[i] = c + 32;\n        }\n\n        // Replace vowels\n        c = encoded_message[i];\n        switch (c) {\n            case 'a': encoded_message[i] = 'c'; break;\n            case 'e': encoded_message[i] = 'g'; break;\n            case 'i': encoded_message[i] = 'k'; break;\n            case 'o': encoded_message[i] = 'q'; break;\n            case 'u': encoded_message[i] = 'w'; break;\n            case 'A': encoded_message[i] = 'C'; break;\n            case 'E': encoded_message[i] = 'G'; break;\n            case 'I': encoded_message[i] = 'K'; break;\n            case 'O': encoded_message[i] = 'Q'; break;\n            case 'U': encoded_message[i] = 'W'; break;\n            default: break;\n        }\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        if (len == 0) continue;\n\n        bool key_all_lower = true;\n        bool key_all_upper = true;\n\n        size_t i = 0;\n        for (; i + 16 <= len; i += 16) {\n            __m128i chars = _mm_loadu_si128((const __m128i*)(str + i));\n            __m128i lower_mask = _mm_cmplt_epi8(chars, _mm_set1_epi8('a'));\n            __m128i upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('z'));\n            __m128i not_lower = _mm_or_si128(lower_mask, upper_mask);\n            if (_mm_movemask_epi8(not_lower) != 0) {\n                key_all_lower = false;\n            }\n\n            lower_mask = _mm_cmplt_epi8(_mm_sub_epi8(chars, _mm_set1_epi8('A' - 'a')), _mm_set1_epi8('a'));\n            upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('Z'));\n            not_lower = _mm_or_si128(lower_mask, upper_mask);\n            if (_mm_movemask_epi8(not_lower) != 0) {\n                key_all_upper = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            if (!((str[i] >= 'a' && str[i] <= 'z'))) {\n                key_all_lower = false;\n            }\n            if (!((str[i] >= 'A' && str[i] <= 'Z'))) {\n                key_all_upper = false;\n            }\n        }\n\n        all_lower &= key_all_lower;\n        all_upper &= key_all_upper;\n\n        if (!key_all_lower && !key_all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cctype>\n\n/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        const char* str = key.c_str();\n        int len = key.length();\n\n        if (len == 0) continue;\n\n        bool key_all_lower = true;\n        bool key_all_upper = true;\n\n        for (int i = 0; i < len; ++i) {\n            if (std::isalpha(str[i])) {\n                if (!std::islower(str[i])) {\n                    key_all_lower = false;\n                }\n                if (!std::isupper(str[i])) {\n                    key_all_upper = false;\n                }\n            }\n            else {\n                key_all_lower = false;\n                key_all_upper = false;\n            }\n        }\n\n        if (!key_all_lower) {\n            all_lower = false;\n        }\n        if (!key_all_upper) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        if (len == 0) continue;\n\n        bool key_all_lower = true;\n        bool key_all_upper = true;\n\n        size_t i = 0;\n        for (; i + 16 <= len; i += 16) {\n            __m128i chars = _mm_loadu_si128((const __m128i*)(str + i));\n            __m128i lower_mask = _mm_cmplt_epi8(chars, _mm_set1_epi8('a'));\n            __m128i upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('z'));\n            __m128i not_lower = _mm_or_si128(lower_mask, upper_mask);\n\n            if (!_mm_testz_si128(not_lower, _mm_set1_epi8(-1))) {\n                key_all_lower = false;\n            }\n\n            lower_mask = _mm_cmplt_epi8(_mm_sub_epi8(chars, _mm_set1_epi8('A')), _mm_set1_epi8(0));\n            upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('Z'));\n            not_lower = _mm_or_si128(lower_mask, upper_mask);\n\n            if (!_mm_testz_si128(not_lower, _mm_set1_epi8(-1))) {\n                key_all_upper = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            if (str[i] < 'a' || str[i] > 'z') {\n                key_all_lower = false;\n            }\n            if (str[i] < 'A' || str[i] > 'Z') {\n                key_all_upper = false;\n            }\n        }\n\n        if (!key_all_lower) {\n            all_lower = false;\n        }\n        if (!key_all_upper) {\n            all_upper = false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cctype>\n\n/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (auto const& [key, val] : dict) {\n        const std::string& k = key;\n        const char* str = k.c_str();\n        size_t len = k.length();\n\n        if (len == 0) continue;\n\n        bool key_all_lower = true;\n        bool key_all_upper = true;\n\n        for (size_t i = 0; i < len; ++i) {\n            if (!std::islower(str[i])) {\n                key_all_lower = false;\n            }\n            if (!std::isupper(str[i])) {\n                key_all_upper = false;\n            }\n        }\n\n        if (!key_all_lower) {\n            all_lower = false;\n        }\n        if (!key_all_upper) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cctype>\n\n/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        const char* str = key.c_str();\n        int len = key.length();\n\n        if (len == 0) continue;\n\n        bool key_all_lower = true;\n        bool key_all_upper = true;\n\n        for (int i = 0; i < len; ++i) {\n            if (std::isalpha(str[i])) {\n                if (!std::islower(str[i])) {\n                    key_all_lower = false;\n                }\n                if (!std::isupper(str[i])) {\n                    key_all_upper = false;\n                }\n            }\n            else {\n                key_all_lower = false;\n                key_all_upper = false;\n            }\n        }\n\n        if (!key_all_lower) {\n            all_lower = false;\n        }\n        if (!key_all_upper) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    if (n == 3) {\n        primes.push_back(2);\n        return primes;\n    }\n\n    primes.push_back(2);\n    if (n > 3) {\n        primes.push_back(3);\n    }\n\n    for (int i = 5; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n            if (primes[j] * primes[j] > i)\n                break;\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    if (n == 3) {\n        primes.push_back(2);\n        return primes;\n    }\n\n    primes.push_back(2);\n\n    for (int i = 3; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    if (n == 3) {\n        primes.push_back(2);\n        return primes;\n    }\n\n    primes.push_back(2);\n    if (n > 3) {\n        primes.push_back(3);\n    }\n\n    for (int i = 5; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    if (n > 2) primes.push_back(2);\n    if (n > 3) primes.push_back(3);\n\n    for (int i = 5; i < n; ++i) {\n        bool is_prime = true;\n        if (i % 2 == 0 || i % 3 == 0) {\n            continue;\n        }\n        for (int j = 5; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n\n    if (n > 2) primes.push_back(2);\n    if (n > 3) primes.push_back(3);\n\n    for (int i = 5; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (primes[j] * primes[j] > i) break;\n            if (i % primes[j] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i += 8) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i mask_even = _mm_set_epi8(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_chars = _mm_and_si128(chars, mask_even);\n\n        __m128i A = _mm_set1_epi8('A');\n        __m128i E = _mm_set1_epi8('E');\n        __m128i I = _mm_set1_epi8('I');\n        __m128i O = _mm_set1_epi8('O');\n        __m128i U = _mm_set1_epi8('U');\n\n        __m128i is_A = _mm_cmpeq_epi8(even_chars, A);\n        __m128i is_E = _mm_cmpeq_epi8(even_chars, E);\n        __m128i is_I = _mm_cmpeq_epi8(even_chars, I);\n        __m128i is_O = _mm_cmpeq_epi8(even_chars, O);\n        __m128i is_U = _mm_cmpeq_epi8(even_chars, U);\n\n        __m128i vowels = _mm_or_si128(is_A, is_E);\n        vowels = _mm_or_si128(vowels, is_I);\n        vowels = _mm_or_si128(vowels, is_O);\n        vowels = _mm_or_si128(vowels, is_U);\n\n        unsigned int mask = _mm_movemask_epi8(vowels);\n\n        for (int j = 0; j < 8 && i + 2 * j < n; ++j) {\n            if ((mask >> (2 * j)) & 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i += 8) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i mask_even = _mm_set_epi8(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_chars = _mm_and_si128(chars, mask_even);\n\n        __m128i A = _mm_set1_epi8('A');\n        __m128i E = _mm_set1_epi8('E');\n        __m128i I = _mm_set1_epi8('I');\n        __m128i O = _mm_set1_epi8('O');\n        __m128i U = _mm_set1_epi8('U');\n\n        __m128i is_A = _mm_cmpeq_epi8(even_chars, A);\n        __m128i is_E = _mm_cmpeq_epi8(even_chars, E);\n        __m128i is_I = _mm_cmpeq_epi8(even_chars, I);\n        __m128i is_O = _mm_cmpeq_epi8(even_chars, O);\n        __m128i is_U = _mm_cmpeq_epi8(even_chars, U);\n\n        __m128i vowels = _mm_or_si128(is_A, is_E);\n        vowels = _mm_or_si128(vowels, is_I);\n        vowels = _mm_or_si128(vowels, is_O);\n        vowels = _mm_or_si128(vowels, is_U);\n\n        unsigned int mask = _mm_movemask_epi8(vowels);\n\n        count += _mm_popcnt_u32(mask);\n    }\n    int remainder = n % 8;\n    for (int i = n - remainder; i < n; ++i) {\n        if (i % 2 == 0) {\n            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i += 8) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i mask_even = _mm_set_epi8(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_chars = _mm_and_si128(chars, mask_even);\n\n        __m128i A = _mm_set1_epi8('A');\n        __m128i E = _mm_set1_epi8('E');\n        __m128i I = _mm_set1_epi8('I');\n        __m128i O = _mm_set1_epi8('O');\n        __m128i U = _mm_set1_epi8('U');\n\n        __m128i isA = _mm_cmpeq_epi8(even_chars, A);\n        __m128i isE = _mm_cmpeq_epi8(even_chars, E);\n        __m128i isI = _mm_cmpeq_epi8(even_chars, I);\n        __m128i isO = _mm_cmpeq_epi8(even_chars, O);\n        __m128i isU = _mm_cmpeq_epi8(even_chars, U);\n\n        __m128i vowels = _mm_or_si128(isA, isE);\n        vowels = _mm_or_si128(vowels, isI);\n        vowels = _mm_or_si128(vowels, isO);\n        vowels = _mm_or_si128(vowels, isU);\n\n        unsigned int mask = _mm_movemask_epi8(vowels);\n\n        count += _mm_popcnt_u32(mask);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i += 8) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i mask = _mm_set_epi8(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_chars = _mm_and_si128(chars, mask);\n\n        unsigned int temp[4];\n        temp[0] = 0;\n        temp[1] = 0;\n        temp[2] = 0;\n        temp[3] = 0;\n\n        for (int j = 0; j < 8 && i + j < n; j += 2) {\n            char c = s[i + j];\n            if (c >= 'A' && c <= 'Z' && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i += 8) {\n        __m128i chars = _mm_loadu_si128((const __m128i*)(s.data() + i));\n        __m128i mask_even = _mm_set_epi8(0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_chars = _mm_and_si128(chars, mask_even);\n\n        __m128i A = _mm_set1_epi8('A');\n        __m128i E = _mm_set1_epi8('E');\n        __m128i I = _mm_set1_epi8('I');\n        __m128i O = _mm_set1_epi8('O');\n        __m128i U = _mm_set1_epi8('U');\n\n        __m128i isA = _mm_cmpeq_epi8(even_chars, A);\n        __m128i isE = _mm_cmpeq_epi8(even_chars, E);\n        __m128i isI = _mm_cmpeq_epi8(even_chars, I);\n        __m128i isO = _mm_cmpeq_epi8(even_chars, O);\n        __m128i isU = _mm_cmpeq_epi8(even_chars, U);\n\n        __m128i vowels = _mm_or_si128(isA, isE);\n        vowels = _mm_or_si128(vowels, isI);\n        vowels = _mm_or_si128(vowels, isO);\n        vowels = _mm_or_si128(vowels, isU);\n\n        unsigned int mask = _mm_movemask_epi8(vowels);\n\n        count += _mm_popcnt_u32(mask);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int start = n;\n    if (n % 2 == 0) {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            result[i] = start + 2 * i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result;\n    result.push_back(n);\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n    for(int i = 1; i < n; ++i){\n        result.push_back(next_val);\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a vector, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile_simd(3)\n{3, 5, 7}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    result[0] = n;\n    int next;\n    if (n % 2 == 0) {\n        next = n + 2;\n    } else {\n        next = n + 2;\n    }\n    for (int i = 1; i < n; ++i) {\n        result[i] = next;\n        next += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result;\n    result.push_back(n);\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n    for(int i = 1; i < n; ++i){\n        result.push_back(next_val);\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result;\n    result.push_back(n);\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n    for(int i = 1; i < n; ++i){\n        result.push_back(next_val);\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    double sum = 0.0;\n    int64_t count = m - n + 1;\n\n    if (count >= 4) {\n        int64_t i = n;\n        __m128d sum_vec = _mm_setzero_pd();\n        for (; i <= m - 3; i += 4) {\n            __m128d vec1 = _mm_set_pd((double)i + 1, (double)i);\n            __m128d vec2 = _mm_set_pd((double)i + 3, (double)i + 2);\n            sum_vec = _mm_add_pd(sum_vec, vec1);\n            sum_vec = _mm_add_pd(sum_vec, vec2);\n        }\n        double temp[2];\n        _mm_storeu_pd(temp, sum_vec);\n        sum = temp[0] + temp[1];\n        for (; i <= m; ++i) {\n            sum += (double)i;\n        }\n    } else {\n        for (int64_t i = n; i <= m; ++i) {\n            sum += (double)i;\n        }\n    }\n\n    int64_t avg = (int64_t)(sum / count);\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    // Use SSE to sum the numbers from n to m in chunks of 4\n    int64_t i = n;\n    if ((m - n + 1) >= 4) {\n        int64_t aligned_m = m - (m - n + 1) % 4;\n        for (; i <= aligned_m; i += 4) {\n            __m128i vec_n = _mm_set_epi64x(i + 3, i);\n            __m128i vec_inc = _mm_set_epi64x(1, 1);\n            __m128i vec_1 = _mm_set_epi64x(1, 1);\n            __m128i vec_2 = _mm_set_epi64x(2, 2);\n            __m128i vec_3 = _mm_set_epi64x(3, 3);\n\n            __m128i vec_i1 = _mm_add_epi64(vec_n, _mm_set_epi64x(0,0));\n            __m128i vec_i2 = _mm_add_epi64(vec_n, vec_1);\n            __m128i vec_i3 = _mm_add_epi64(vec_n, vec_2);\n            __m128i vec_i4 = _mm_add_epi64(vec_n, vec_3);\n            \n            sum += _mm_extract_epi64(vec_i1, 0);\n            sum += _mm_extract_epi64(vec_i2, 0);\n            sum += _mm_extract_epi64(vec_i3, 0);\n            sum += _mm_extract_epi64(vec_i4, 0);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i <= m; ++i) {\n        sum += i;\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    // Use SSE to sum the numbers from n to m in chunks of 4\n    int64_t i = n;\n    if ((m - n + 1) >= 4) {\n        int64_t aligned_end = m - ((m - n + 1) % 4);\n        for (; i <= aligned_end; i += 4) {\n            __m128i vec_n = _mm_set_epi64x(i + 3, i + 2);\n            __m128i vec_n2 = _mm_set_epi64x(i + 1, i);\n            \n            int64_t temp_sum[2];\n            _mm_storeu_si128((__m128i*)temp_sum, vec_n);\n            sum += temp_sum[0] + temp_sum[1];\n            \n            int64_t temp_sum2[2];\n            _mm_storeu_si128((__m128i*)temp_sum2, vec_n2);\n            sum += temp_sum2[0] + temp_sum2[1];\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i <= m; ++i) {\n        sum += i;\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    if (count < 4) {\n        for (int64_t i = n; i <= m; ++i) {\n            sum += i;\n        }\n    } else {\n        int64_t i = n;\n        for (; i <= m - 3; i += 4) {\n            __m128i vec = _mm_set_epi64x(i + 3, i + 2);\n            vec = _mm_insert_epi64(vec, i + 1, 1);\n            vec = _mm_insert_epi64(vec, i, 0);\n\n            int64_t temp[2];\n            _mm_storeu_si128((__m128i*)temp, vec);\n            sum += temp[0] + temp[1];\n        }\n        for (; i <= m; ++i) {\n            sum += i;\n        }\n    }\n    \n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    // Use SSE to sum the numbers from n to m in chunks of 4\n    if (count >= 4) {\n        int64_t i = n;\n        __m128i sum_vec = _mm_setzero_si128();\n        for (; i <= m - 3; i += 4) {\n            __m128i values = _mm_set_epi64x(i + 3, i + 2);\n            __m128i values2 = _mm_set_epi64x(i + 1, i);\n            __m128i values_combined = _mm_unpacklo_epi64(values2, values);\n            sum_vec = _mm_add_epi64(sum_vec, values_combined);\n        }\n\n        // Extract the sums from the SSE vector\n        int64_t temp_sum[2];\n        _mm_storeu_si128((__m128i*)temp_sum, sum_vec);\n        sum = temp_sum[0] + temp_sum[1];\n\n        // Add the remaining numbers\n        for (; i <= m; ++i) {\n            sum += i;\n        }\n    } else {\n        for (int64_t i = n; i <= m; ++i) {\n            sum += i;\n        }\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    __m128i even_indices = _mm_set_epi32(0, 2, 4, 6);\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i factorial = _mm_set_epi32(1, 1, 1, 1);\n    __m128i mod_val = _mm_set1_epi32(10000);\n    __m128i one = _mm_set1_epi32(1);\n\n    int i = 0;\n    for (; i + 3 < n && i < n; i += 4) {\n        __m128i current_indices = _mm_add_epi32(even_indices, _mm_set1_epi32(i));\n        __m128i temp_indices = current_indices;\n        __m128i odd_results = _mm_setzero_si128();\n        __m128i current_sum = _mm_setzero_si128();\n\n        for (int j = 0; j < 4; ++j) {\n            int index = i + j;\n            if ((index + 1) % 2 == 0) {\n                int sum = 0;\n                for (int k = 1; k <= index + 1; ++k) {\n                    sum += k;\n                }\n                result[index] = sum;\n            }\n        }\n\n        __m128i temp_factorial = factorial;\n        for (int j = 0; j < 4; ++j) {\n            int index = i + j;\n            if ((index + 1) % 2 != 0) {\n                temp_factorial = _mm_mullo_epi32(temp_factorial, _mm_add_epi32(one, _mm_set1_epi32(index)));\n                __m128i modded_factorial = _mm_rem_epu32(temp_factorial, mod_val);\n                int modded_factorial_val = _mm_extract_epi32(modded_factorial, 0);\n                result[index] = modded_factorial_val;\n                temp_factorial = _mm_srli_si128(temp_factorial, 4);\n            }\n        }\n\n        even_indices = _mm_add_epi32(even_indices, increment);\n    }\n\n    for (; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            int sum = 0;\n            for (int k = 1; k <= i + 1; ++k) {\n                sum += k;\n            }\n            result[i] = sum;\n        } else {\n            long long fact = 1;\n            for (int k = 1; k <= i + 1; ++k) {\n                fact = (fact * k) % 10000;\n            }\n            result[i] = (int)fact;\n        }\n    }\n\n    return result;\n}\n\n__m128i _mm_rem_epu32(__m128i dividend, __m128i divisor) {\n    __m128i quotient = _mm_div_epu32(dividend, divisor);\n    __m128i product = _mm_mullo_epi32(quotient, divisor);\n    return _mm_sub_epi32(dividend, product);\n}\n\n__m128i _mm_div_epu32(__m128i dividend, __m128i divisor) {\n    __m128i quotient = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi32(1);\n\n    while (_mm_movemask_epi8(_mm_cmpgt_epi32(dividend, divisor)) != 0) {\n        __m128i shift = _mm_slli_epi32(one, 31);\n        __m128i temp_divisor = divisor;\n\n        while (_mm_movemask_epi8(_mm_cmpgt_epi32(dividend, temp_divisor)) != 0) {\n            temp_divisor = _mm_slli_epi32(temp_divisor, 1);\n            shift = _mm_srli_epi32(shift, 1);\n        }\n\n        temp_divisor = _mm_srli_epi32(temp_divisor, 1);\n        shift = _mm_slli_epi32(shift, 1);\n\n        quotient = _mm_add_epi32(quotient, shift);\n        dividend = _mm_sub_epi32(dividend, temp_divisor);\n    }\n\n    return quotient;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    __m128i even_indices_mask = _mm_set_epi32(0, -1, 0, -1); \n    \n    std::vector<int> factorials(4);\n    factorials[0] = 1;\n    factorials[1] = 1;\n    factorials[2] = 1;\n    factorials[3] = 1;\n\n    std::vector<int> sums(4);\n    sums[0] = 0;\n    sums[1] = 0;\n    sums[2] = 0;\n    sums[3] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        int index = i - 1;\n        if (i % 2 == 0) {\n            factorials[index % 4] = (1LL * factorials[index % 4] * i) % 10000;\n            result[index] = factorials[index % 4];\n        } else {\n            sums[index % 4] = (sums[index % 4] + i) % 10000;\n            result[index] = sums[index % 4];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    __m128i even_indices = _mm_set_epi32(0, 2, 4, 6);\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i factorial_values = _mm_set_epi32(1, 1, 1, 1);\n    __m128i mod_value = _mm_set1_epi32(10000);\n    __m128i one = _mm_set1_epi32(1);\n\n    int i = 0;\n    for (; i < n - 3; i += 4) {\n        __m128i current_indices = _mm_add_epi32(even_indices, one);\n        even_indices = _mm_add_epi32(even_indices, increment);\n\n        int indices[4];\n        _mm_storeu_si128((__m128i*)indices, current_indices);\n\n        int factorials[4];\n        _mm_storeu_si128((__m128i*)factorials, factorial_values);\n\n        for (int j = 0; j < 4; ++j) {\n            if (indices[j] % 2 == 0) {\n                long long temp_factorial = 1;\n                for (int k = 1; k <= indices[j]; ++k) {\n                    temp_factorial = (temp_factorial * k) % 10000;\n                }\n                result[i + j] = (int)temp_factorial;\n            } else {\n                long long sum = 0;\n                for (int k = 1; k <= indices[j]; ++k) {\n                    sum += k;\n                }\n                result[i + j] = (int)sum;\n            }\n        }\n\n        __m128i indices_vec = _mm_loadu_si128((__m128i*)indices);\n        __m128i temp_factorial_values = factorial_values;\n\n        for (int k = 0; k < 4; ++k) {\n            __m128i k_vec = _mm_set1_epi32(indices[k] + 1);\n            factorial_values = _mm_mullo_epi32(factorial_values, k_vec);\n            factorial_values = _mm_rem_epu32(factorial_values, mod_value);\n        }\n    }\n\n    for (; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            long long temp_factorial = 1;\n            for (int k = 1; k <= (i + 1); ++k) {\n                temp_factorial = (temp_factorial * k) % 10000;\n            }\n            result[i] = (int)temp_factorial;\n        } else {\n            long long sum = 0;\n            for (int k = 1; k <= (i + 1); ++k) {\n                sum += k;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    __m128i even_indices = _mm_set_epi32(0, 2, 4, 6);\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i factorial = _mm_set_epi32(1, 1, 1, 1);\n    __m128i mod_val = _mm_set1_epi32(10000);\n    __m128i one = _mm_set1_epi32(1);\n\n    int i = 0;\n    for (; i < n - 3; i += 4) {\n        __m128i current_indices = _mm_add_epi32(even_indices, _mm_set1_epi32(i));\n        __m128i temp_factorial = factorial;\n\n        for (int j = 0; j < 4; ++j) {\n            int index = i + j;\n            if ((index + 1) % 2 == 0) {\n                int sum = 0;\n                for (int k = 1; k <= index + 1; ++k) {\n                    sum += k;\n                }\n                result[index] = sum;\n            } else {\n                int fact = 1;\n                for (int k = 1; k <= index + 1; ++k) {\n                    fact = (fact * k) % 10000;\n                }\n                result[index] = fact;\n            }\n        }\n        \n        for (int j = 0; j < 4; ++j) {\n            int index_val = i + j + 1;\n            int fact_val = 1;\n            for(int k = 1; k <= index_val; ++k){\n                fact_val = (fact_val * k) % 10000;\n            }\n        }\n        \n        for (int j = 0; j < 4; ++j) {\n            int index_val = i + j + 1;\n            int sum_val = 0;\n            for(int k = 1; k <= index_val; ++k){\n                sum_val += k;\n            }\n        }\n        \n        factorial = _mm_mullo_epi32(factorial, _mm_add_epi32(current_indices, one));\n        factorial = _mm_mod_epu32(factorial, mod_val);\n        \n        even_indices = _mm_add_epi32(even_indices, increment);\n    }\n\n    for (; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            int sum = 0;\n            for (int k = 1; k <= i + 1; ++k) {\n                sum += k;\n            }\n            result[i] = sum;\n        } else {\n            int fact = 1;\n            for (int k = 1; k <= i + 1; ++k) {\n                fact = (fact * k) % 10000;\n            }\n            result[i] = fact;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    __m128i even_indices = _mm_set_epi32(0, 2, 4, 6);\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i factorial_values = _mm_set_epi32(1, 1, 1, 1);\n    __m128i mod_value = _mm_set1_epi32(10000);\n    __m128i current_even = _mm_set_epi32(6, 4, 2, 0);\n\n    int i = 0;\n    for (; i < n && i < 4; ++i) {\n        if ((i + 1) % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n\n    for (; i <= n - 4; i += 4) {\n        current_even = _mm_add_epi32(current_even, increment);\n        __m128i temp_even = current_even;\n        __m128i fact_temp = factorial_values;\n\n        int temp_arr[4];\n        _mm_storeu_si128((__m128i*)temp_arr, current_even);\n\n        for (int j = 0; j < 4; ++j) {\n            int fact = 1;\n            for (int k = 1; k <= (temp_arr[j] + 1); ++k) {\n                fact = (fact * k) % 10000;\n                \n            }\n            result[i + j] = fact;\n        }\n        \n        factorial_values = _mm_set_epi32(result[i+3], result[i+2], result[i+1], result[i]);\n\n        for(int j = 0; j < 4; j++){\n            result[i+j+1] = (i+j+2) * (i+j+3) / 2;\n        }\n    }\n\n    for (; i < n; ++i) {\n        if ((i + 1) % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= (i + 1); ++j) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n\n        if (s == rs) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n        if (num < 0) {\n            sign = -1;\n            num = -num;\n        }\n        \n        if (num == 0) continue;\n\n        sum += (num % 10) * sign;\n        num /= 10;\n        sign = 1;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n        if (num < 0) {\n            sign = -1;\n            num = -num;\n        }\n        \n        if (num == 0) continue;\n\n        sum += sign * (num % 10);\n        num /= 10;\n        sign = 1;\n\n        while (num > 0) {\n            sum += (num % 10);\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n\n        if (num < 0) {\n            sign = -1;\n            num = -num;\n        }\n\n        if (num == 0) continue;\n\n        sum += sign * (num % 10);\n        num /= 10;\n        sign = 1;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n        if (num < 0) {\n            sign = -1;\n            num = -num;\n        }\n        \n        if (num == 0) continue;\n\n        sum += sign * (num % 10);\n        num /= 10;\n        sign = 1;\n\n        while (num > 0) {\n            sum += (num % 10);\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = 1;\n        if (num < 0) {\n            sign = -1;\n            num = -num;\n        }\n        \n        if (num == 0) continue;\n\n        sum += (num % 10) * sign;\n        num /= 10;\n        sign = 1;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n    int n = arr.size();\n    if (n == 0) {\n        return true;\n    }\n\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int x : lst1) {\n        if (x % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int x : lst2) {\n        if (x % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int x : lst1) {\n        if (x % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int x : lst2) {\n        if (x % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between the lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int i = 0; i < lst1.size(); ++i) {\n        if (lst1[i] % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int i = 0; i < lst2.size(); ++i) {\n        if (lst2[i] % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    int even_count2 = 0;\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int x : lst1) {\n        if (x % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int x : lst2) {\n        if (x % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        for (int i = 0; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        for (int i = 0; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        // Process in chunks of 16 characters using SSE2\n        for (; i + 15 < len; i += 16) {\n            __m128i chars = _mm_loadu_si128((const __m128i*)(str.data() + i));\n\n            // Convert characters to integers by subtracting '0'\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i digits = _mm_sub_epi8(chars, zero);\n\n            // Check if the digits are odd by performing a bitwise AND with 1\n            __m128i one = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_and_si128(digits, one);\n\n            // Compare the odd_mask with 1 to get a mask of odd digits\n            __m128i cmp_result = _mm_cmpeq_epi8(odd_mask, one);\n\n            // Move the mask to a regular integer\n            int mask = _mm_movemask_epi8(cmp_result);\n\n            // Count the number of set bits (odd digits) in the mask\n            count += _mm_popcnt_u32(mask);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time using SSE2\n        for (; i + 15 < len; i += 16) {\n            __m128i chars = _mm_loadu_si128((const __m128i*)(str.data() + i));\n\n            // Convert characters to integers by subtracting '0'\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i digits = _mm_sub_epi8(chars, zero);\n\n            // Check if the digits are odd by performing a bitwise AND with 1\n            __m128i odd_mask = _mm_set1_epi8(1);\n            __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n\n            // Compare the odd digits with 1 to get a mask of odd digits\n            __m128i cmp_result = _mm_cmpeq_epi8(odd_digits, odd_mask);\n\n            // Move the mask to a 128-bit integer\n            int mask = _mm_movemask_epi8(cmp_result);\n\n            // Count the number of set bits (odd digits) in the mask\n            count += _mm_popcnt_u32(mask);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        int len = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time using SSE2\n        for (; i + 15 < len; i += 16) {\n            __m128i chars = _mm_loadu_si128((const __m128i*)(str.data() + i));\n\n            // Convert characters to integers by subtracting '0'\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i digits = _mm_sub_epi8(chars, zero);\n\n            // Check if the digits are odd by performing a bitwise AND with 1\n            __m128i odd_mask = _mm_set1_epi8(1);\n            __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n\n            // Compare the odd digits with 1 to get a mask of odd digits\n            __m128i cmp_result = _mm_cmpeq_epi8(odd_digits, odd_mask);\n\n            // Move the comparison result to a general-purpose register\n            int mask = _mm_movemask_epi8(cmp_result);\n\n            // Count the number of set bits (odd digits) in the mask\n            count += _mm_popcnt_u32(mask);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int count = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int count = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int lowers = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int water_count = 0;\n        for (int j = 0; j < cols; ++j) {\n            water_count += grid[i][j];\n        }\n        lowers += (water_count + capacity - 1) / capacity;\n    }\n\n    return lowers;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int lowers = 0;\n\n    for (int i = 0; i < rows; ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < cols; ++j) {\n            row_sum += grid[i][j];\n        }\n        lowers += (row_sum + capacity - 1) / capacity;\n    }\n\n    return lowers;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    if (cols == 0) return 0;\n\n    int total_wells = rows * cols;\n    int num_iterations = 0;\n\n    std::vector<int> current_grid;\n    for(int i = 0; i < rows; ++i){\n        current_grid.insert(current_grid.end(), grid[i].begin(), grid[i].end());\n    }\n\n    while(true){\n        int sum = 0;\n        for(int i = 0; i < total_wells; ++i){\n            sum += current_grid[i];\n        }\n        if(sum == 0) break;\n\n        num_iterations++;\n\n        int i = 0;\n        for (; i + 3 < total_wells; i += 4) {\n            __m128i water = _mm_loadu_si128((__m128i*)&current_grid[i]);\n            __m128i bucket = _mm_set1_epi32(capacity);\n            __m128i sub = _mm_min_epi32(water, bucket);\n            _mm_storeu_si128((__m128i*)&current_grid[i], _mm_sub_epi32(water, sub));\n        }\n\n        for (; i < total_wells; ++i) {\n            if (current_grid[i] > 0) {\n                int sub = std::min(current_grid[i], capacity);\n                current_grid[i] -= sub;\n            }\n        }\n    }\n\n    return num_iterations;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i odd_mask = _mm_set1_epi16(1);\n        __m128i and_result = _mm_and_si128(vec, odd_mask);\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_result = _mm_cmpeq_epi16(and_result, odd_mask);\n\n        int16_t odd_elements[8];\n        _mm_storeu_si128((__m128i*)odd_elements, cmp_result);\n\n        for (int j = 0; j < 8 && i + j < n; ++j) {\n            if (j % 2 == 0 && odd_elements[j] == -1) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i even_mask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_vec = _mm_and_si128(vec, even_mask);\n\n        __m128i one = _mm_set1_epi16(1);\n        __m128i odd_mask = _mm_and_si128(even_vec, one);\n\n        int16_t temp_arr[8];\n        _mm_storeu_si128((__m128i*)temp_arr, odd_mask);\n\n        for (int j = 0; j < 8 && i + j < n; ++j) {\n            if (j % 2 == 0 && (lst[i+j] % 2 != 0)) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i even_mask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        __m128i even_vec = _mm_and_si128(vec, even_mask);\n\n        __m128i one = _mm_set1_epi16(1);\n        __m128i odd_mask = _mm_and_si128(even_vec, one);\n\n        int16_t temp_arr[8];\n        _mm_storeu_si128((__m128i*)temp_arr, odd_mask);\n\n        for (int j = 0; j < 8 && i + j < n; ++j) {\n            if (j % 2 == 0 && (lst[i+j] % 2 != 0)) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i odd_mask = _mm_set1_epi16(1);\n        __m128i and_result = _mm_and_si128(vec, odd_mask);\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_result = _mm_cmpeq_epi16(and_result, odd_mask);\n\n        int16_t odd_elements[8];\n        _mm_storeu_si128((__m128i*)odd_elements, cmp_result);\n\n        for (int j = 0; j < 8 && i + j < n; ++j) {\n            if (j % 2 == 0 && odd_elements[j] == -1) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i odd_mask = _mm_set1_epi16(1);\n        __m128i and_result = _mm_and_si128(vec, odd_mask);\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_result = _mm_cmpeq_epi16(and_result, odd_mask);\n\n        int16_t odd_elements[8];\n        _mm_storeu_si128((__m128i*)odd_elements, cmp_result);\n\n        for (int j = 0; j < 8 && i + j < n; ++j) {\n            if (j % 2 == 0 && odd_elements[j] == -1) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SSE\n    for (; i <= k - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Check if each element has at most two digits (i.e., is less than 100)\n        __m128i cmp = _mm_cmplt_epi32(vec, _mm_set1_epi32(100));\n        \n        // Create a mask from the comparison result\n        int mask = _mm_movemask_epi8(cmp);\n\n        // Extract the elements based on the mask\n        if (mask & 0x1) {\n            sum += arr[i];\n        }\n        if (mask & 0x2) {\n            sum += arr[i + 1];\n        }\n        if (mask & 0x4) {\n            sum += arr[i + 2];\n        }\n        if (mask & 0x8) {\n            sum += arr[i + 3];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SSE intrinsics\n    for (; i <= k - 4; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&arr[i]);\n\n        // Check if each element has at most two digits (i.e., is less than 100)\n        __m128i mask = _mm_cmplt_epi32(v, _mm_set1_epi32(100));\n\n        // Create a mask where 0xFFFFFFFF indicates the element should be added, and 0x0 indicates it should not\n        int mask_int = _mm_movemask_epi8(mask);\n\n        // Extract the elements based on the mask and add them to the sum\n        if ((mask_int & 0xF) == 0xF) sum += arr[i];\n        if ((mask_int & 0xF0) == 0xF0) sum += arr[i + 1];\n        if ((mask_int & 0xF00) == 0xF00) sum += arr[i + 2];\n        if ((mask_int & 0xF000) == 0xF000) sum += arr[i + 3];\n    }\n\n    // Process remaining elements individually\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SSE\n    for (; i <= k - 4; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i abs_v = _mm_abs_epi32(v); // Use absolute value to handle negative numbers correctly\n\n        // Check if each element has at most two digits (abs(element) < 100)\n        __m128i cmp_mask = _mm_cmplt_epi32(abs_v, _mm_set1_epi32(100));\n\n        // Create a mask where 0xFFFFFFFF indicates the element should be added, and 0 otherwise\n        int mask = _mm_movemask_epi8(cmp_mask);\n\n        // Extract the elements based on the mask and add them to the sum\n        if (mask & 0x1) sum += arr[i];\n        if (mask & 0x2) sum += arr[i + 1];\n        if (mask & 0x4) sum += arr[i + 2];\n        if (mask & 0x8) sum += arr[i + 3];\n    }\n\n    // Process remaining elements individually\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SSE\n    for (; i <= k - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Check if each element has at most two digits (i.e., is less than 100)\n        __m128i cmp_vec = _mm_cmplt_epi32(vec, _mm_set1_epi32(100));\n        \n        // Create a mask based on the comparison result\n        int mask = _mm_movemask_epi8(cmp_vec);\n\n        // Iterate through the elements and add to the sum if they have at most two digits\n        if (mask & 0x1) {\n            sum += arr[i];\n        }\n        if (mask & 0x2) {\n            sum += arr[i+1];\n        }\n        if (mask & 0x4) {\n            sum += arr[i+2];\n        }\n        if (mask & 0x8) {\n            sum += arr[i+3];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4 using SSE\n    for (; i <= k - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Check if each element has at most two digits (i.e., is less than 100)\n        __m128i cmp_vec = _mm_cmplt_epi32(vec, _mm_set1_epi32(100));\n        \n        // Create a mask based on the comparison result\n        int mask = _mm_movemask_epi8(cmp_vec);\n        \n        // Iterate through the 4 elements and add to the sum if the corresponding bit in the mask is set\n        if (mask & 0x1) {\n            sum += arr[i];\n        }\n        if (mask & 0x2) {\n            sum += arr[i + 1];\n        }\n        if (mask & 0x4) {\n            sum += arr[i + 2];\n        }\n        if (mask & 0x8) {\n            sum += arr[i + 3];\n        }\n    }\n\n    // Process remaining elements one by one\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int n = lst.size();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            sorted = false;\n            break;\n        }\n    }\n\n    if (!sorted) return false;\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (lst[i] == lst[i + 1]) {\n            int count = 0;\n            for(int j = 0; j < n; ++j){\n                if(lst[i] == lst[j]){\n                    count++;\n                }\n            }\n            if(count > 2){\n                duplicate = true;\n                break;\n            }\n        }\n    }\n    \n    if(duplicate) return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        __m128i current = _mm_loadu_si128((const __m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((const __m128i*)&lst[i + 1]);\n\n        __m128i cmp = _mm_cmplt_epi32(next, current);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n\n        __m128i eq = _mm_cmpeq_epi32(current, next);\n        int mask = _mm_movemask_epi8(eq);\n        if (mask) {\n            for (int j = 0; j < 4; ++j) {\n                if ((mask & (0xF << (j * 4))) == (0xF << (j * 4))) {\n                    if (i + j + 2 < n && lst[i + j] == lst[i + j + 2]) return false;\n                    if (i + j + 3 < n && lst[i + j] == lst[i + j + 3]) return false;\n                }\n            }\n        }\n    }\n\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i + 1]) {\n            int count = 0;\n            for(int j = 0; j < lst.size(); j++){\n                if(lst[j] == lst[i]) count++;\n            }\n            if(count > 2) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int n = lst.size();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)&lst[i]);\n        __m128i b = _mm_loadu_si128((const __m128i*)&lst[i + 1]);\n\n        __m128i cmp = _mm_cmplt_epi32(a, b);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask != 0xFFFF) {\n            return false;\n        }\n\n        if (lst[i] == lst[i+1] || lst[i+1] == lst[i+2] || lst[i+2] == lst[i+3]) {\n            \n            std::map<int, int> counts;\n            for(int j = i; j < i + 4; ++j) {\n                counts[lst[j]]++;\n            }\n            for(auto const& [key, val] : counts) {\n                if (val > 1) return false;\n            }\n        }\n    }\n\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n    }\n    \n    std::map<int, int> counts;\n    for(int j = 0; j < n; ++j) {\n        counts[lst[j]]++;\n    }\n    for(auto const& [key, val] : counts) {\n        if (val > 1) {\n            int count = 0;\n            for(int j = 0; j < n; ++j) {\n                if (lst[j] == key) count++;\n            }\n            if (count > 1) {\n                bool first = true;\n                int prev = -1;\n                for(int j = 0; j < n; ++j) {\n                    if (lst[j] == key) {\n                        if (first) {\n                            first = false;\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int n = lst.size();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        __m128i a = _mm_loadu_si128((const __m128i*)&lst[i]);\n        __m128i b = _mm_loadu_si128((const __m128i*)&lst[i + 1]);\n\n        __m128i cmp = _mm_cmplt_epi32(a, b);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask != 0xFFFF) {\n            return false;\n        }\n\n        __m128i eq = _mm_cmpeq_epi32(a, b);\n        int eq_mask = _mm_movemask_epi8(eq);\n        if (eq_mask != 0) {\n            int arr[4];\n            _mm_storeu_si128((__m128i*)arr, a);\n            int arr2[4];\n            _mm_storeu_si128((__m128i*)arr2, b);\n\n            for(int j = 0; j < 4; j++){\n                if(arr[j] == arr2[0] || arr[j] == arr2[1] || arr[j] == arr2[2] || arr[j] == arr2[3]){\n                    int count = 0;\n                    for(int k = 0; k < n; k++){\n                        if(lst[k] == arr[j]){\n                            count++;\n                        }\n                    }\n                    if(count > 2){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i+1]){\n            int count = 0;\n            for(int k = 0; k < n; k++){\n                if(lst[k] == lst[i]){\n                    count++;\n                }\n            }\n            if(count > 2){\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    int n = lst.size();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            sorted = false;\n            break;\n        }\n    }\n\n    if (!sorted) return false;\n\n    for (int i = 0; i < n - 1; ++i) {\n        if (lst[i] == lst[i + 1]) {\n            int count = 0;\n            for (int j = 0; j < n; ++j) {\n                if (lst[i] == lst[j]) {\n                    count++;\n                }\n            }\n            if (count > 2) {\n                duplicate = true;\n                break;\n            }\n        }\n    }\n\n    if (duplicate) return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_prod = 1;\n    int sum_abs = 0;\n\n    int i = 0;\n    int size = arr.size();\n\n    if (size >= 4) {\n        __m128i sign_prod_vec = _mm_set1_epi32(1);\n        __m128i zero_vec = _mm_set1_epi32(0);\n\n        for (; i <= size - 4; i += 4) {\n            __m128i data_vec = _mm_loadu_si128((const __m128i*)&arr[i]);\n            __m128i signs_vec = _mm_cmpgt_epi32(data_vec, zero_vec);\n            __m128i neg_vec = _mm_cmplt_epi32(data_vec, zero_vec);\n            __m128i zero_mask = _mm_cmpeq_epi32(data_vec, zero_vec);\n\n            int signs[4];\n            _mm_storeu_si128((__m128i*)signs, signs_vec);\n\n            int negs[4];\n            _mm_storeu_si128((__m128i*)negs, neg_vec);\n\n            int zeros[4];\n            _mm_storeu_si128((__m128i*)zeros, zero_mask);\n\n            for(int j = 0; j < 4; ++j){\n                if(zeros[j]){\n                    sign_prod = 0;\n                    goto end_loop;\n                } else if(negs[j]){\n                    sign_prod *= -1;\n                }\n            }\n        }\n    }\n\n    end_loop:\n    for (; i < size; ++i) {\n        if (arr[i] == 0) {\n            sign_prod = 0;\n            break;\n        } else if (arr[i] < 0) {\n            sign_prod *= -1;\n        }\n    }\n\n    for (int val : arr) {\n        sum_abs += abs(val);\n    }\n\n    return sum_abs * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_prod = 1;\n    int sum_magnitudes = 0;\n\n    int i = 0;\n    int size = arr.size();\n\n    if (size >= 4) {\n        __m128i sign_prod_vec = _mm_set1_epi32(1);\n        __m128i sum_magnitudes_vec = _mm_set1_epi32(0);\n\n        for (; i <= size - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&arr[i]);\n\n            __m128i signs = _mm_cmpgt_epi32(data, _mm_set1_epi32(0));\n            __m128i neg_signs = _mm_cmplt_epi32(data, _mm_set1_epi32(0));\n            __m128i zero_signs = _mm_cmpeq_epi32(data, _mm_set1_epi32(0));\n\n            __m128i current_signs = _mm_set1_epi32(1);\n            current_signs = _mm_blendv_epi8(current_signs, _mm_set1_epi32(-1), neg_signs);\n            current_signs = _mm_blendv_epi8(current_signs, _mm_set1_epi32(0), zero_signs);\n\n            int signs_arr[4];\n            _mm_storeu_si128((__m128i*)signs_arr, current_signs);\n\n            sign_prod *= signs_arr[0];\n            sign_prod *= signs_arr[1];\n            sign_prod *= signs_arr[2];\n            sign_prod *= signs_arr[3];\n\n            if (sign_prod == 0) return 0;\n\n            __m128i abs_data = _mm_abs_epi32(data);\n            sum_magnitudes_vec = _mm_add_epi32(sum_magnitudes_vec, abs_data);\n        }\n\n        int sum_arr[4];\n        _mm_storeu_si128((__m128i*)sum_arr, sum_magnitudes_vec);\n        sum_magnitudes = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n    }\n\n    for (; i < size; ++i) {\n        if (arr[i] > 0) {\n            sign_prod *= 1;\n        } else if (arr[i] < 0) {\n            sign_prod *= -1;\n        } else {\n            sign_prod = 0;\n            break;\n        }\n        sum_magnitudes += std::abs(arr[i]);\n    }\n\n    return sign_prod * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_prod = 1;\n    int sum_abs = 0;\n\n    int i = 0;\n    int size = arr.size();\n\n    if (size >= 4) {\n        __m128i sign_prod_vec = _mm_set1_epi32(1);\n        __m128i sum_abs_vec = _mm_set1_epi32(0);\n        \n        for (; i <= size - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&arr[i]);\n\n            __m128i signs = _mm_cmpgt_epi32(data, _mm_set1_epi32(0));\n            __m128i neg_signs = _mm_cmplt_epi32(data, _mm_set1_epi32(0));\n            __m128i zero_signs = _mm_cmpeq_epi32(data, _mm_set1_epi32(0));\n\n            __m128i ones = _mm_set1_epi32(1);\n            __m128i minus_ones = _mm_set1_epi32(-1);\n            __m128i zeros = _mm_set1_epi32(0);\n\n            __m128i current_signs = _mm_blendv_epi8(zeros, ones, signs);\n            current_signs = _mm_blendv_epi8(current_signs, minus_ones, neg_signs);\n\n            __m128i abs_values = _mm_abs_epi32(data);\n            \n            int temp_signs[4];\n            _mm_storeu_si128((__m128i*)temp_signs, current_signs);\n\n            int temp_abs[4];\n            _mm_storeu_si128((__m128i*)temp_abs, abs_values);\n\n            sign_prod *= (temp_signs[0] * temp_signs[1] * temp_signs[2] * temp_signs[3]);\n            if (sign_prod > 1 || sign_prod < -1) {\n                sign_prod = (sign_prod > 0) ? 1 : -1;\n            }\n            sum_abs += temp_abs[0] + temp_abs[1] + temp_abs[2] + temp_abs[3];\n            \n            if (sign_prod == 0) break;\n        }\n    }\n\n    for (; i < size; ++i) {\n        int num = arr[i];\n        if (num > 0) {\n            sign_prod *= 1;\n        } else if (num < 0) {\n            sign_prod *= -1;\n        } else {\n            sign_prod *= 0;\n        }\n        if (sign_prod > 1 || sign_prod < -1) {\n            sign_prod = (sign_prod > 0) ? 1 : -1;\n        }\n        sum_abs += std::abs(num);\n        if (sign_prod == 0) break;\n    }\n\n    return sum_abs * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_prod = 1;\n    int sum_magnitudes = 0;\n\n    int i = 0;\n    int size = arr.size();\n\n    // Process elements in chunks of 4 using SSE\n    for (; i + 3 < size; i += 4) {\n        __m128i vec = _mm_loadu_si128((const __m128i*)&arr[i]);\n\n        // Extract signs: 1 if positive, -1 if negative, 0 if zero\n        __m128i signs = _mm_sign_epi32(\n            _mm_set1_epi32(1), // Sign mask (all 1s)\n            vec\n        );\n\n        // Compute absolute values\n        __m128i abs_vec = _mm_abs_epi32(vec);\n\n        // Extract individual signs and magnitudes\n        int signs_arr[4];\n        int abs_arr[4];\n        _mm_storeu_si128((__m128i*)signs_arr, signs);\n        _mm_storeu_si128((__m128i*)abs_arr, abs_vec);\n\n        // Update product of signs and sum of magnitudes\n        sign_prod *= signs_arr[0] == 0 ? 0 : (signs_arr[0] > 0 ? 1 : -1);\n        sign_prod *= signs_arr[1] == 0 ? 0 : (signs_arr[1] > 0 ? 1 : -1);\n        sign_prod *= signs_arr[2] == 0 ? 0 : (signs_arr[2] > 0 ? 1 : -1);\n        sign_prod *= signs_arr[3] == 0 ? 0 : (signs_arr[3] > 0 ? 1 : -1);\n\n        sum_magnitudes += abs_arr[0];\n        sum_magnitudes += abs_arr[1];\n        sum_magnitudes += abs_arr[2];\n        sum_magnitudes += abs_arr[3];\n\n        if (sign_prod == 0) break;\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = arr[i];\n        int sign = (num == 0) ? 0 : (num > 0 ? 1 : -1);\n        sign_prod *= sign;\n        sum_magnitudes += abs(num);\n        if (sign_prod == 0) break;\n    }\n\n    return sum_magnitudes * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sign_prod = 1;\n    int sum_abs = 0;\n\n    int i = 0;\n    int size = arr.size();\n\n    if (size >= 4) {\n        __m128i sign_prod_vec = _mm_set1_epi32(1);\n        __m128i sum_abs_vec = _mm_set1_epi32(0);\n\n        for (; i <= size - 4; i += 4) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&arr[i]);\n            \n            __m128i signs = _mm_cmpgt_epi32(data, _mm_set1_epi32(0));\n            __m128i neg_signs = _mm_cmplt_epi32(data, _mm_set1_epi32(0));\n            __m128i zero_signs = _mm_cmpeq_epi32(data, _mm_set1_epi32(0));\n\n            __m128i current_signs = _mm_set1_epi32(1);\n            current_signs = _mm_blendv_epi8(current_signs, _mm_set1_epi32(-1), neg_signs);\n            current_signs = _mm_blendv_epi8(current_signs, _mm_set1_epi32(0), zero_signs);\n\n            __m128i abs_values = _mm_abs_epi32(data);\n            sum_abs_vec = _mm_add_epi32(sum_abs_vec, abs_values);\n\n            __m128i prod1 = _mm_mullo_epi32(sign_prod_vec, current_signs);\n            sign_prod_vec = prod1;\n        }\n\n        int temp_signs[4];\n        _mm_storeu_si128((__m128i*)temp_signs, sign_prod_vec);\n        sign_prod = temp_signs[0] * temp_signs[1] * temp_signs[2] * temp_signs[3];\n\n        int temp_abs[4];\n        _mm_storeu_si128((__m128i*)temp_abs, sum_abs_vec);\n        sum_abs = temp_abs[0] + temp_abs[1] + temp_abs[2] + temp_abs[3];\n    }\n\n    for (; i < size; ++i) {\n        if (arr[i] > 0) {\n            sign_prod *= 1;\n        } else if (arr[i] < 0) {\n            sign_prod *= -1;\n        } else {\n            sign_prod *= 0;\n        }\n        sum_abs += abs(arr[i]);\n    }\n\n    return sum_abs * sign_prod;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dx[] = {0, 0, 1, -1};\n            int dy[] = {1, -1, 0, 0};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dx[i];\n                int new_col = col + dy[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n            if (k == 1) return {grid[i][j]};\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> min_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (min_path.empty() || current_path < min_path) {\n                min_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n            if (k == 1) return {grid[i][j]};\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n        } else {\n            // Explore neighbors\n            int dr[] = {-1, 1, 0, 0};\n            int dc[] = {0, 0, -1, 1};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    // Iterate through all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n            if (current_path.size() > 0)\n                current_path.clear();\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path;\n\n    // Initialize path with the first k elements from the grid\n    for (int i = 0; i < k; ++i) {\n        path.push_back(grid[i / N][i % N]);\n    }\n\n    // Use SIMD to explore paths\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath;\n            int x = i, y = j;\n\n            // Collect values for the path of length k\n            for (int step = 0; step < k; ++step) {\n                if (x >= 0 && x < N && y >= 0 && y < N) {\n                    currentPath.push_back(grid[x][y]);\n                }\n                // Move to the next cell (example: right)\n                y++;\n                if (y >= N) {\n                    y = 0;\n                    x++;\n                }\n            }\n\n            // Compare lexicographically\n            if (currentPath < path) {\n                path = currentPath;\n            }\n        }\n    }\n\n    // Return the minimum path found\n    return path;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    __m128i result = zero;\n\n    while (n > 0) {\n        __m128i digits = _mm_set_epi8(\n            (n % 10) & 0xFF,\n            (n / 10 % 10) & 0xFF,\n            (n / 100 % 10) & 0xFF,\n            (n / 1000 % 10) & 0xFF,\n            (n / 10000 % 10) & 0xFF,\n            (n / 100000 % 10) & 0xFF,\n            (n / 1000000 % 10) & 0xFF,\n            (n / 10000000 % 10) & 0xFF,\n            (n / 100000000 % 10) & 0xFF,\n            (n / 1000000000 % 10) & 0xFF,\n            (n / 10000000000 % 10) & 0xFF,\n            (n / 100000000000 % 10) & 0xFF,\n            (n / 1000000000000 % 10) & 0xFF,\n            (n / 10000000000000 % 10) & 0xFF,\n            (n / 100000000000000 % 10) & 0xFF,\n            (n / 1000000000000000 % 10) & 0xFF\n        );\n\n        __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n        __m128i non_zero = _mm_cmpeq_epi8(odd_digits, zero);\n        __m128i mask = _mm_cmpeq_epi8(non_zero, zero);\n        \n        product = _mm_mullo_epi8(product, odd_digits);\n        result = _mm_or_si128(result, mask);\n        \n        n /= 1000000000000000; // Reduce n for the next iteration\n    }\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; i++) {\n        final_product *= _mm_extract_epi8(product, i);\n    }\n\n    return (final_product == 1 && _mm_movemask_epi8(result) == 0) ? 0 : final_product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 3 < size; i += 4) {\n        __m128 v = _mm_loadu_ps(&lst[i]);\n\n        // Round each float to the ceiling integer value\n        __m128 rounded = _mm_ceil_ps(v);\n\n        // Convert floats to integers\n        __m128i integers = _mm_cvttps_epi32(rounded);\n\n        // Square the integers\n        __m128i squared = _mm_mullo_epi32(integers, integers);\n\n        // Extract the integers from the SSE register and sum them\n        int temp_sum[4];\n        _mm_storeu_si128((__m128i*)temp_sum, squared);\n        sum += temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        sum += (uint64_t)ceil(lst[i]) * (uint64_t)ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        __m128 x = _mm_loadu_ps(&lst[i]);\n        __m128 rounded = _mm_ceil_ps(x);\n        __m128 rounded_int = _mm_cvttps_epi32(rounded);\n        \n        int rounded_arr[4];\n        _mm_storeu_si128((__m128i*)rounded_arr, rounded_int);\n\n        sum += (uint64_t)rounded_arr[0] * rounded_arr[0];\n        sum += (uint64_t)rounded_arr[1] * rounded_arr[1];\n        sum += (uint64_t)rounded_arr[2] * rounded_arr[2];\n        sum += (uint64_t)rounded_arr[3] * rounded_arr[3];\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += (uint64_t)ceil(lst[i]) * ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 3 < size; i += 4) {\n        __m128 v = _mm_loadu_ps(&lst[i]);\n        // Round each float to the ceiling integer value\n        __m128 rounded = _mm_ceil_ps(v);\n\n        // Convert the rounded floats to integers\n        __m128i integers = _mm_cvttps_epi32(rounded);\n\n        // Square the integers\n        __m128i squared = _mm_mullo_epi32(integers, integers);\n\n        // Extract the squared integers and add them to the sum\n        int squared_values[4];\n        _mm_storeu_si128((__m128i*)squared_values, squared);\n\n        sum += squared_values[0] + squared_values[1] + squared_values[2] + squared_values[3];\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        sum += (uint64_t)ceil(lst[i]) * (uint64_t)ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 3 < size; i += 4) {\n        __m128 v = _mm_loadu_ps(&lst[i]);\n\n        // Round each float to the ceiling integer value\n        __m128 rounded = _mm_ceil_ps(v);\n\n        // Convert the rounded floats to integers\n        __m128i integers = _mm_cvttps_epi32(rounded);\n\n        // Square the integers\n        __m128i squared = _mm_mullo_epi32(integers, integers);\n\n        // Extract the squared integers and add them to the sum\n        int squared_values[4];\n        _mm_storeu_si128((__m128i*)squared_values, squared);\n\n        sum += squared_values[0] + squared_values[1] + squared_values[2] + squared_values[3];\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        sum += (uint64_t)ceil(lst[i]) * (uint64_t)ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process the array in chunks of 4 floats\n    for (; i + 3 < size; i += 4) {\n        __m128 v = _mm_loadu_ps(&lst[i]);\n        // Round each float to the ceiling integer value\n        __m128 rounded = _mm_ceil_ps(v);\n\n        // Convert the rounded floats to integers\n        __m128i integers = _mm_cvttps_epi32(rounded);\n\n        // Square each integer\n        __m128i squared = _mm_mullo_epi32(integers, integers);\n\n        // Extract the squared integers and add them to the sum\n        int squared_values[4];\n        _mm_storeu_si128((__m128i*)squared_values, squared);\n\n        sum += squared_values[0] + squared_values[1] + squared_values[2] + squared_values[3];\n    }\n\n    // Process the remaining elements\n    for (; i < size; ++i) {\n        sum += (uint64_t)ceil(lst[i]) * (uint64_t)ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    const int n = lst.size();\n    const int simd_width = 4;\n    int i = 0;\n\n    if (n >= simd_width) {\n        __m128i largest_neg_vec = _mm_set1_epi32(0);\n        __m128i smallest_pos_vec = _mm_set1_epi32(INT_MAX);\n        __m128i zero = _mm_set1_epi32(0);\n\n        for (; i <= n - simd_width; i += simd_width) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&lst[i]);\n\n            __m128i neg_mask = _mm_cmplt_epi32(data, zero);\n            __m128i pos_mask = _mm_cmpgt_epi32(data, zero);\n\n            __m128i masked_neg = _mm_and_si128(data, neg_mask);\n            __m128i masked_pos = _mm_and_si128(data, pos_mask);\n\n            largest_neg_vec = _mm_max_epi32(largest_neg_vec, masked_neg);\n            smallest_pos_vec = _mm_min_epi32(smallest_pos_vec, masked_pos);\n        }\n\n        int temp_largest_neg[4];\n        int temp_smallest_pos[4];\n        _mm_storeu_si128((__m128i*)temp_largest_neg, largest_neg_vec);\n        _mm_storeu_si128((__m128i*)temp_smallest_pos, smallest_pos_vec);\n\n        for (int j = 0; j < simd_width; ++j) {\n            if (temp_largest_neg[j] > largest_negative) {\n                largest_negative = temp_largest_neg[j];\n            }\n            if (temp_smallest_pos[j] != INT_MAX && (smallest_positive == 0 || temp_smallest_pos[j] < smallest_positive)) {\n                smallest_positive = temp_smallest_pos[j];\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    const int n = lst.size();\n    const int simd_width = 4;\n    int i = 0;\n\n    if (n >= simd_width) {\n        __m128i largest_neg_vec = _mm_set1_epi32(0);\n        __m128i smallest_pos_vec = _mm_set1_epi32(INT_MAX);\n        __m128i zero = _mm_set1_epi32(0);\n\n        for (; i <= n - simd_width; i += simd_width) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&lst[i]);\n\n            __m128i neg_mask = _mm_cmplt_epi32(data, zero);\n            __m128i pos_mask = _mm_cmpgt_epi32(data, zero);\n\n            __m128i masked_neg = _mm_and_si128(data, neg_mask);\n            __m128i masked_pos = _mm_and_si128(data, pos_mask);\n\n            largest_neg_vec = _mm_max_epi32(largest_neg_vec, masked_neg);\n            smallest_pos_vec = _mm_min_epi32(smallest_pos_vec, masked_pos);\n        }\n\n        int temp_largest_neg[4];\n        int temp_smallest_pos[4];\n        _mm_storeu_si128((__m128i*)temp_largest_neg, largest_neg_vec);\n        _mm_storeu_si128((__m128i*)temp_smallest_pos, smallest_pos_vec);\n\n        for (int j = 0; j < simd_width; ++j) {\n            if (temp_largest_neg[j] > largest_negative) {\n                largest_negative = temp_largest_neg[j];\n            }\n            if (temp_smallest_pos[j] != INT_MAX && (smallest_positive == 0 || temp_smallest_pos[j] < smallest_positive)) {\n                smallest_positive = temp_smallest_pos[j];\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    const int n = lst.size();\n    const int simd_width = 4;\n    int i = 0;\n\n    if (n >= simd_width) {\n        __m128i largest_neg_vec = _mm_set1_epi32(0);\n        __m128i smallest_pos_vec = _mm_set1_epi32(INT_MAX);\n        __m128i zero = _mm_set1_epi32(0);\n\n        for (; i <= n - simd_width; i += simd_width) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&lst[i]);\n            __m128i sign_mask = _mm_cmpgt_epi32(zero, data); \n\n            __m128i negative_values = _mm_and_si128(data, sign_mask);\n            largest_neg_vec = _mm_max_epi32(largest_neg_vec, negative_values);\n\n            __m128i positive_mask = _mm_cmpgt_epi32(data, zero);\n            __m128i positive_values = _mm_and_si128(data, positive_mask);\n            smallest_pos_vec = _mm_min_epi32(smallest_pos_vec, positive_values);\n        }\n\n        int temp_largest[4];\n        int temp_smallest[4];\n        _mm_storeu_si128((__m128i*)temp_largest, largest_neg_vec);\n        _mm_storeu_si128((__m128i*)temp_smallest, smallest_pos_vec);\n\n        largest_negative = std::max({temp_largest[0], temp_largest[1], temp_largest[2], temp_largest[3]});\n\n        int min_val = INT_MAX;\n        for (int j = 0; j < 4; ++j) {\n            if (temp_smallest[j] > 0 && temp_smallest[j] < min_val) {\n                min_val = temp_smallest[j];\n            }\n        }\n        if (min_val != INT_MAX) {\n            smallest_positive = min_val;\n        } else {\n            smallest_positive = 0;\n        }\n        if (largest_negative > 0) largest_negative = 0;\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < 0) {\n            largest_negative = std::max(largest_negative, lst[i]);\n        } else if (lst[i] > 0) {\n            if (smallest_positive == 0) {\n                smallest_positive = lst[i];\n            } else {\n                smallest_positive = std::min(smallest_positive, lst[i]);\n            }\n        }\n    }\n    \n    if (largest_negative > 0) largest_negative = 0;\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    const int n = lst.size();\n    const int simd_width = 4;\n    int i = 0;\n\n    if (n >= simd_width) {\n        __m128i largest_neg_vec = _mm_set1_epi32(0);\n        __m128i smallest_pos_vec = _mm_set1_epi32(INT_MAX);\n        __m128i zero = _mm_set1_epi32(0);\n\n        for (; i <= n - simd_width; i += simd_width) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&lst[i]);\n\n            __m128i neg_mask = _mm_cmplt_epi32(data, zero);\n            __m128i pos_mask = _mm_cmpgt_epi32(data, zero);\n\n            __m128i masked_neg = _mm_and_si128(data, neg_mask);\n            __m128i masked_pos = _mm_and_si128(data, pos_mask);\n\n            largest_neg_vec = _mm_max_epi32(largest_neg_vec, masked_neg);\n            smallest_pos_vec = _mm_min_epi32(smallest_pos_vec, masked_pos);\n        }\n\n        int temp_largest_neg[4];\n        int temp_smallest_pos[4];\n        _mm_storeu_si128((__m128i*)temp_largest_neg, largest_neg_vec);\n        _mm_storeu_si128((__m128i*)temp_smallest_pos, smallest_pos_vec);\n\n        for (int j = 0; j < simd_width; ++j) {\n            if (temp_largest_neg[j] > largest_negative) {\n                largest_negative = temp_largest_neg[j];\n            }\n            if (temp_smallest_pos[j] != INT_MAX && (smallest_positive == 0 || temp_smallest_pos[j] < smallest_positive)) {\n                smallest_positive = temp_smallest_pos[j];\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    const int n = lst.size();\n    const int simd_width = 4;\n    int i = 0;\n\n    if (n >= simd_width) {\n        __m128i largest_neg_vec = _mm_set1_epi32(0);\n        __m128i smallest_pos_vec = _mm_set1_epi32(INT_MAX);\n        __m128i zero = _mm_set1_epi32(0);\n\n        for (; i <= n - simd_width; i += simd_width) {\n            __m128i data = _mm_loadu_si128((const __m128i*)&lst[i]);\n\n            __m128i neg_mask = _mm_cmplt_epi32(data, zero);\n            __m128i pos_mask = _mm_cmpgt_epi32(data, zero);\n\n            __m128i masked_neg = _mm_and_si128(data, neg_mask);\n            __m128i masked_pos = _mm_and_si128(data, pos_mask);\n\n            largest_neg_vec = _mm_max_epi32(largest_neg_vec, masked_neg);\n            smallest_pos_vec = _mm_min_epi32(smallest_pos_vec, masked_pos);\n        }\n\n        int temp_largest_neg[4];\n        int temp_smallest_pos[4];\n        _mm_storeu_si128((__m128i*)temp_largest_neg, largest_neg_vec);\n        _mm_storeu_si128((__m128i*)temp_smallest_pos, smallest_pos_vec);\n\n        for (int j = 0; j < simd_width; ++j) {\n            if (temp_largest_neg[j] > largest_negative) {\n                largest_negative = temp_largest_neg[j];\n            }\n            if (temp_smallest_pos[j] != INT_MAX && (smallest_positive == 0 || temp_smallest_pos[j] < smallest_positive)) {\n                smallest_positive = temp_smallest_pos[j];\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int n = lst.size();\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int n = lst.size();\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int lastDigit = num % 10;\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; ++i) {\n        if (nums[i] > 10) {\n            int temp = nums[i];\n            int lastDigit = temp % 10;\n            int firstDigit = 0;\n            \n            if (temp < 0)\n                temp = -temp;\n\n            if (temp < 10)\n                firstDigit = temp;\n            else {\n                int numDigits = 0;\n                int temp2 = temp;\n                while (temp2 > 0) {\n                    temp2 /= 10;\n                    numDigits++;\n                }\n                int divisor = 1;\n                for (int j = 1; j < numDigits; ++j) {\n                    divisor *= 10;\n                }\n                firstDigit = temp / divisor;\n            }\n\n            if (lastDigit % 2 != 0 && firstDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; ++i) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            if (lastDigit % 2 != 0) {\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n                if (firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; ++i) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            int firstDigit = 0;\n            int temp = num;\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if ((firstDigit % 2 != 0) && (lastDigit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int size = nums.size();\n    for (int i = 0; i < size; ++i) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            if (lastDigit % 2 != 0) {\n                int firstDigit = num;\n                while (firstDigit >= 10) {\n                    firstDigit /= 10;\n                }\n                if (firstDigit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    return count[0] * (count[0] - 1) * (count[0] - 2) / 6 +\n           count[1] * (count[1] - 1) * (count[1] - 2) / 6 +\n           count[2] * (count[2] - 1) * (count[2] - 2) / 6 +\n           count[0] * count[1] * count[2];\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    return count[0] * (count[0] - 1) * (count[0] - 2) / 6 +\n           count[1] * (count[1] - 1) * (count[1] - 2) / 6 +\n           count[2] * (count[2] - 1) * (count[2] - 2) / 6 +\n           count[0] * count[1] * count[2];\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cstdint>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    return count[0] * (count[0] - 1) * (count[0] - 2) / 6 +\n           count[0] * count[1] * count[2] +\n           count[0] * (count[1] * (count[1] - 1) / 2) +\n           count[0] * (count[2] * (count[2] - 1) / 2) +\n           count[1] * (count[1] - 1) * (count[1] - 2) / 6 +\n           count[2] * (count[2] - 1) * (count[2] - 2) / 6 +\n           count[1] * (count[2] * (count[2] - 1) / 2) +\n           count[2] * (count[1] * (count[1] - 1) / 2);\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    return count[0] * (count[0] - 1) * (count[0] - 2) / 6 +\n           count[1] * (count[1] - 1) * (count[1] - 2) / 6 +\n           count[2] * (count[2] - 1) * (count[2] - 2) / 6 +\n           count[0] * count[1] * count[2];\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    return count[0] * (count[0] - 1) * (count[0] - 2) / 6 +\n           count[1] * (count[1] - 1) * (count[1] - 2) / 6 +\n           count[2] * (count[2] - 1) * (count[2] - 2) / 6 +\n           count[0] * count[1] * count[2];\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    if (n % 2 == 0 || n % 3 == 0) return y;\n\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    __m128i i_vec = _mm_set_epi32(0, 0, 0, 5);\n    __m128i inc_vec = _mm_set1_epi32(6);\n    __m128i one_vec = _mm_set1_epi32(1);\n    \n    int i = 5;\n    while (i * i <= n) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return y;\n        i += 6;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    if (n <= 3) {\n        return x;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i i_vec = _mm_set_epi32(0, 0, 0, 5);\n    __m128i inc_vec = _mm_set1_epi32(6);\n    __m128i one_vec = _mm_set1_epi32(1);\n\n    int i = 5;\n    while (i * i <= n) {\n        __m128i i_sqr_vec = _mm_mullo_epi32(i_vec, i_vec);\n        int i_sqr = i * i;\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return y;\n        }\n        i += 6;\n        i_vec = _mm_add_epi32(i_vec, inc_vec);\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    if (n % 2 == 0 || n % 3 == 0) return y;\n\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i i_vec = _mm_set_epi32(0, 0, 0, 5);\n    __m128i inc_vec = _mm_set1_epi32(6);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    __m128i zero_vec = _mm_setzero_si128();\n\n    int result = x;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    if (n <= 3) {\n        return x;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i i_vec = _mm_set_epi32(0, 0, 0, 5); \n    __m128i inc_vec = _mm_set1_epi32(6);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    __m128i result_vec = x_vec;\n    int is_prime = 1;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    if(is_prime){\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    if (n <= 3) {\n        return x;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return y;\n    }\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i i_vec = _mm_set_epi32(0, 0, 0, 5);\n    __m128i inc = _mm_set1_epi32(6);\n    __m128i sqrt_n = _mm_set1_epi32((int)sqrt(n) + 1);\n\n    while (_mm_cvtsi128_si32(_mm_cmplt_epi32(i_vec, sqrt_n))) {\n        __m128i rem1 = _mm_sub_epi32(num, _mm_mullo_epi32(_mm_div_epi32(num, i_vec), i_vec));\n        if (_mm_cvtsi128_si32(rem1) == 0) {\n            return y;\n        }\n\n        __m128i i_plus_2 = _mm_add_epi32(i_vec, _mm_set1_epi32(2));\n        __m128i rem2 = _mm_sub_epi32(num, _mm_mullo_epi32(_mm_div_epi32(num, i_plus_2), i_plus_2));\n        if (_mm_cvtsi128_si32(rem2) == 0) {\n            return y;\n        }\n        \n        i_vec = _mm_add_epi32(i_vec, inc);\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    if (size == 0) return 0;\n\n    int i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        __m128 abs_vec = _mm_and_ps(vec, _mm_set1_ps(std::numeric_limits<float>::max()));\n        __m128 floor_vec = _mm_floor_ps(abs_vec);\n        __m128 eq_vec = _mm_cmpeq_ps(abs_vec, floor_vec);\n        __m128 is_odd_vec = _mm_and_ps(eq_vec, _mm_cmpeq_ps(_mm_and_ps(floor_vec, _mm_set1_ps(1.0f)), _mm_set1_ps(1.0f)));\n        __m128 non_neg_vec = _mm_cmpge_ps(vec, _mm_set1_ps(0.0f));\n        __m128 valid_vec = _mm_and_ps(is_odd_vec, non_neg_vec);\n        __m128 squared_vec = _mm_mul_ps(vec, vec);\n        __m128 masked_squared_vec = _mm_and_ps(squared_vec, valid_vec);\n\n        float temp_sum[4];\n        _mm_storeu_ps(temp_sum, masked_squared_vec);\n        sum += (uint64_t)temp_sum[0] + (uint64_t)temp_sum[1] + (uint64_t)temp_sum[2] + (uint64_t)temp_sum[3];\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && lst[i] == floorf(lst[i]) && fmod(lst[i], 2) != 0 && fmod(lst[i], 2) == 1) {\n            sum += (uint64_t)(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    if (size == 0) return 0;\n\n    int i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        __m128 rounded = _mm_round_ps(vec, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        __m128 diff = _mm_sub_ps(vec, rounded);\n        __m128 absDiff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        __m128 isInteger = _mm_cmpeq_ps(absDiff, _mm_setzero_ps());\n        __m128 isPositive = _mm_cmpge_ps(vec, _mm_setzero_ps());\n        __m128 isOdd = _mm_and_ps(isInteger, _mm_and_ps(isPositive, _mm_and_ps(vec, _mm_set1_ps(1.0f))));\n        __m128 squared = _mm_mul_ps(vec, vec);\n        __m128 maskedSquared = _mm_and_ps(squared, isOdd);\n\n        float temp[4];\n        _mm_storeu_ps(temp, maskedSquared);\n\n        sum += (uint64_t)temp[0] + (uint64_t)temp[1] + (uint64_t)temp[2] + (uint64_t)temp[3];\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && lst[i] == (int)lst[i] && ((int)lst[i] % 2 != 0)) {\n            sum += (uint64_t)(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        float val = lst[i];\n        if (val >= 0 && (int)val == val && ((int)val % 2) != 0) {\n            sum += (uint64_t)val * (uint64_t)val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        float val = lst[i];\n        if (val >= 0 && (int)val == val && ((int)val % 2 != 0)) {\n            sum += (uint64_t)val * (uint64_t)val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int size = lst.size();\n    if (size == 0) return 0;\n\n    int i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        __m128 abs_vec = _mm_and_ps(vec, _mm_set1_ps(std::numeric_limits<float>::max()));\n        __m128 floor_vec = _mm_floor_ps(vec);\n        __m128 eq_vec = _mm_cmpeq_ps(vec, floor_vec);\n        __m128 and_vec = _mm_and_ps(eq_vec, _mm_cmpge_ps(vec, _mm_setzero_ps()));\n        __m128 mod_vec = _mm_and_ps(and_vec, _mm_castsi128_ps(_mm_set_epi32(1, 1, 1, 1)));\n        __m128 mod_result = _mm_and_ps(mod_vec, _mm_set1_ps(1.0f));\n        __m128 odd_vec = _mm_cmpeq_ps(mod_result, _mm_set1_ps(1.0f));\n        __m128 sq_vec = _mm_mul_ps(vec, vec);\n        __m128 result_vec = _mm_and_ps(odd_vec, sq_vec);\n\n        float temp_arr[4];\n        _mm_storeu_ps(temp_arr, result_vec);\n        sum += (uint64_t)temp_arr[0] + (uint64_t)temp_arr[1] + (uint64_t)temp_arr[2] + (uint64_t)temp_arr[3];\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && lst[i] == floor(lst[i]) && (int)lst[i] % 2 != 0) {\n            sum += (uint64_t)(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two vectors of scores and guesses of equal length, where each index shows a match. \nReturn a vector of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nExample:\ncompare_simd({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare_simd({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result(game.size());\n    int i = 0;\n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((const __m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((const __m128i*)&guess[i]);\n        __m128i cmp_vec = _mm_cmpeq_epi32(game_vec, guess_vec);\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_vec = _mm_abs_epi32(diff_vec);\n        __m128i res_vec = _mm_blendv_epi8(abs_vec, _mm_setzero_si128(), cmp_vec);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n    for (; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    for (; i + 3 < game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((const __m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((const __m128i*)&guess[i]);\n        __m128i cmp_vec = _mm_cmpeq_epi32(game_vec, guess_vec);\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_vec = _mm_abs_epi32(diff_vec);\n        __m128i res_vec = _mm_blendv_epi8(abs_vec, _mm_setzero_si128(), cmp_vec);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n    for (; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    for (; i + 3 < game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((const __m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((const __m128i*)&guess[i]);\n        __m128i cmp_vec = _mm_cmpeq_epi32(game_vec, guess_vec);\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n\n        __m128i abs_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), diff_vec);\n        diff_vec = _mm_sub_epi32(_mm_xor_si128(diff_vec, abs_mask), abs_mask);\n\n        __m128i res_vec = _mm_blendv_epi8(diff_vec, _mm_setzero_si128(), cmp_vec);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n    for (; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result(game.size());\n    int i = 0;\n    for (; i + 3 < game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((const __m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((const __m128i*)&guess[i]);\n        __m128i cmp_eq = _mm_cmpeq_epi32(game_vec, guess_vec);\n        __m128i diff = _mm_sub_epi32(guess_vec, game_vec);\n        __m128i abs_diff = _mm_abs_epi32(diff);\n        __m128i res_vec = _mm_blendv_epi8(abs_diff, _mm_setzero_si128(), cmp_eq);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n    for (; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(guess[i] - game[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\n/*\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two vectors of scores and guesses of equal length, where each index shows a match. \nReturn a vector of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nExample:\ncompare_simd({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare_simd({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n\nThe requirement is to implement the function using SSE/SSE2 (Streaming SIMD Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result(game.size());\n    int i = 0;\n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((const __m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((const __m128i*)&guess[i]);\n        __m128i cmp_vec = _mm_cmpeq_epi32(game_vec, guess_vec);\n        __m128i diff_vec = _mm_sub_epi32(guess_vec, game_vec);\n        __m128i abs_vec = _mm_abs_epi32(diff_vec);\n        __m128i res_vec = _mm_blendv_epi8(abs_vec, _mm_setzero_si128(), cmp_vec);\n        _mm_storeu_si128((__m128i*)&result[i], res_vec);\n    }\n    for (; i < game.size(); ++i) {\n        result[i] = (game[i] == guess[i]) ? 0 : std::abs(game[i] - guess[i]);\n    }\n    return result;\n}\n```"}

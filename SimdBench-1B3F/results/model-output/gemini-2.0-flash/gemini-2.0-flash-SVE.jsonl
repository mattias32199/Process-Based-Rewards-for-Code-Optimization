{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svbool_t mask_sv = svld1_b1((svbool_t)pred, &mask[i]);\n        svint64_t src_sv = svld1_s64((svbool_t)pred, &src[i]);\n        svint64_t dst_sv = svld1_s64((svbool_t)pred, &dst[i]);\n        svint64_t res_sv = svsel_s64(mask_sv, src_sv, dst_sv);\n        svst1_s64((svbool_t)pred, &dst[i], res_sv);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svbool_t mask_vec = svld1(pred, &mask[i]);\n        svint64_t src_vec = svld1(pred, &src[i]);\n        svint64_t dst_vec = svld1(pred, &dst[i]);\n        dst_vec = svsel(mask_vec, src_vec, dst_vec);\n        svst1(pred, &dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svbool_t mask_vec = svld1(pred, &mask[i]);\n        svint64_t src_vec = svld1(pred, &src[i]);\n        svint64_t dst_vec = svld1(pred, &dst[i]);\n        dst_vec = svsel(mask_vec, src_vec, dst_vec);\n        svst1(pred, &dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svbool_t mask_vec = svld1_b1(pred, &mask[i]);\n        svint64_t src_vec = svld1_s64(pred, &src[i]);\n        svint64_t dst_vec = svld1_s64(pred, &dst[i]);\n        dst_vec = svsel_s64(mask_vec, src_vec, dst_vec);\n        svst1_s64(pred, &dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svbool_t mask_vec = svld1_b1(pred, &mask[i]);\n        svint64_t src_vec = svld1_s64(pred, &src[i]);\n        svint64_t dst_vec = svld1_s64(pred, &dst[i]);\n        dst_vec = svsel_s64(mask_vec, src_vec, dst_vec);\n        svst1_s64(pred, &dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svint32_t s = svld1_s32(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32(s, scale);\n        svint32_t tmp1 = svlsr_n_s32(scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32(scaled, 3);\n        svint32_t result = svdiv_n_s32(svadd_s32(scaled, svmul_s32(tmp1, tmp2)), 7);\n        svst1_s32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t s = svld1(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32(s, scale);\n        svint32_t tmp1 = svrshl_n_s32(scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32(scaled, 3);\n        svint32_t result = svdiv_n_s32(svadd_s32(scaled, svmul_s32(tmp1, tmp2)), 7);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t s = svld1(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32(s, scale);\n        svint32_t tmp1 = svlsr_n_s32(scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32(scaled, 3);\n        svint32_t result = svdiv_n_s32(svadd_s32(scaled, svmul_s32(tmp1, tmp2)), 7);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svint32_t s = svld1(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32_x(pg, s, scale);\n        svint32_t tmp1 = svlsr_n_s32_x(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled, 3);\n        svint32_t result = svadd_x(pg, scaled, svmul_x(pg, tmp1, tmp2));\n        result = svdiv_n_s32_x(pg, result, 7);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t s = svld1(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32(s, scale);\n        svint32_t tmp1 = svlsr_n_s32(scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32(scaled, 3);\n        svint32_t result = svdiv_n_s32(svadd_s32(scaled, svmul_s32(tmp1, tmp2)), 7);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; ++r) {\n        size_t offset = r * cols + stride;\n        svfloat64_t val = svld1_f64(svptrue_b64(), &src[offset]);\n        dst[r] = svgetelement_f64(val, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; ++r) {\n        size_t offset = r * cols + stride;\n        svfloat64_t val = svld1_f64(svptrue_b64(), &src[offset]);\n        dst[r] = svgetelement_f64(val, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; ++r) {\n        size_t index = r * cols + stride;\n        dst[r] = src[index];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; ++r) {\n        size_t offset = r * cols + stride;\n        svfloat64_t val = svld1_f64(svptrue_b64(), &src[offset]);\n        dst[r] = svgetelement_f64(val, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; ++r) {\n        size_t offset = r * cols + stride;\n        svfloat64_t val = svld1_f64(svptrue_b64(), &src[offset]);\n        dst[r] = svgetelement_f64(val, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_data = svgather_f32(pg, src, index_vec);\n        svst1_f32(pg, &dst[i], gathered_data);\n\n        svst1_f32(pg, svoffset_f32(dst, index_vec), svld1_f32(pg, &src[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_vec = svgather_f32(pg, src, index_vec);\n        svst1_f32(pg, &dst[i], gathered_vec);\n\n        svst1_f32(pg, svadd_f32_x(pg, (float32_t)0.0, dst, svcvt_f32_s32(index_vec)), svld1_f32(pg, &src[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_vec = svgather_f32(pg, src, index_vec);\n        svst1_f32(pg, &dst[i], gathered_vec);\n\n        svst1_f32(pg, svoffset_f32(dst, index_vec), svld1_f32(pg, &src[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_vec = svgather_f32(pg, src, index_vec);\n        svst1_f32(pg, &dst[i], gathered_vec);\n    }\n\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svscatter_f32(pg, dst, index_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_vec = svgather_f32(pg, src, index_vec);\n        svst1_f32(pg, &dst[i], gathered_vec);\n    }\n\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t index_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svscatter_f32(pg, dst, index_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n  uint64_t vl = svcntw();\n\n  for (uint64_t i = 0; i < len / 2; i++) {\n    int16_t temp = arr[start + i];\n    arr[start + i] = arr[end - i];\n    arr[end - i] = temp;\n  }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  svbool_t pg = svwhilelt_b16((int64_t)0, (int64_t)(end - start + 1));\n  uint64_t i = start;\n  uint64_t j = end;\n\n  while (i < j) {\n    int16_t temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n  uint64_t vl = svcntw();\n\n  for (uint64_t i = 0; i < len / 2; i++) {\n    int16_t temp = arr[start + i];\n    arr[start + i] = arr[end - i];\n    arr[end - i] = temp;\n  }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n  uint64_t vl = svcntw();\n\n  for (uint64_t i = 0; i < len / 2; i += vl) {\n    svbool_t pg = svwhilelt_b16(i, len / 2);\n\n    svint16_t sv_left = svld1_s16(pg, arr + start + i);\n    svint16_t sv_right = svld1_s16(pg, arr + end - i);\n\n    svst1_s16(pg, arr + start + i, sv_right);\n    svst1_s16(pg, arr + end - i, sv_left);\n  }\n\n  if ((len % 2 != 0) && ((len / 2) % vl != 0)) {\n      uint64_t remaining = (len / 2) % vl;\n      int16_t temp;\n      for(uint64_t i = len / 2 - remaining; i < len / 2; ++i){\n          temp = arr[start + i];\n          arr[start + i] = arr[end - i];\n          arr[end - i] = temp;\n      }\n  }\n  else if (len % 2 != 0){\n      uint64_t i = len / 2;\n      int16_t temp = arr[start + i];\n      arr[start + i] = arr[end - i];\n      arr[end - i] = temp;\n  }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n  if (start >= end) {\n    return;\n  }\n\n  svbool_t pg = svwhilelt_b16((int64_t)0, (int64_t)(end - start + 1));\n  uint64_t i = start;\n  uint64_t j = end;\n\n  while (i < j) {\n    int16_t temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice_ptr = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i < slice_size - vl + 1; i += vl) {\n        svuint8_t vec = svld1_u8(svptrue_b8(), tensor_slice_ptr + i);\n        svst1_u8(svptrue_b8(), slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = tensor_slice_ptr[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i < slice_size - (slice_size % vl); i += vl) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, slice_start + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i < slice_size - vl + 1; i += vl) {\n        svuint8_t vec = svld1_u8(svptrue_b8(), slice_start + i);\n        svst1_u8(svptrue_b8(), slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i < slice_size - (slice_size % vl); i += vl) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, slice_start + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_idx * dim1 * dim2;\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i < slice_size - (slice_size % vl); i += vl) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, slice_start + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n\n    for (; i < slice_size; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t block_rows = (row_block + block_size > rows) ? (rows - row_block) : block_size;\n            size_t block_cols = (col_block + block_size > cols) ? (cols - col_block) : block_size;\n\n            for (size_t i = 0; i < block_rows; ++i) {\n                for (size_t j = 0; j < block_cols; ++j) {\n                    dst[(col_block + j) * rows + (row_block + i)] = src[(row_block + i) * cols + (col_block + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t block_rows = (row_block + block_size > rows) ? (rows - row_block) : block_size;\n            size_t block_cols = (col_block + block_size > cols) ? (cols - col_block) : block_size;\n\n            for (size_t i = 0; i < block_rows; ++i) {\n                for (size_t j = 0; j < block_cols; ++j) {\n                    dst[(col_block + j) * rows + (row_block + i)] = src[(row_block + i) * cols + (col_block + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t block_rows = (row_block + block_size > rows) ? (rows - row_block) : block_size;\n            size_t block_cols = (col_block + block_size > cols) ? (cols - col_block) : block_size;\n\n            for (size_t i = 0; i < block_rows; ++i) {\n                for (size_t j = 0; j < block_cols; ++j) {\n                    dst[(col_block + j) * rows + (row_block + i)] = src[(row_block + i) * cols + (col_block + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t block_rows = (row_block + block_size > rows) ? (rows - row_block) : block_size;\n            size_t block_cols = (col_block + block_size > cols) ? (cols - col_block) : block_size;\n\n            for (size_t i = 0; i < block_rows; ++i) {\n                for (size_t j = 0; j < block_cols; ++j) {\n                    dst[(col_block + j) * rows + (row_block + i)] = src[(row_block + i) * cols + (col_block + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t block_rows = (row_block + block_size > rows) ? (rows - row_block) : block_size;\n            size_t block_cols = (col_block + block_size > cols) ? (cols - col_block) : block_size;\n\n            for (size_t i = 0; i < block_rows; ++i) {\n                for (size_t j = 0; j < block_cols; ++j) {\n                    dst[(col_block + j) * rows + (row_block + i)] = src[(row_block + i) * cols + (col_block + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    size_t vectorizable_loop_count = dim / svcntw();\n    size_t remainder_loop_start = vectorizable_loop_count * svcntw();\n\n    for (size_t i = 0; i < vectorizable_loop_count; ++i) {\n        svbool_t pg = svwhilelt_b32(i * svcntw(), dim);\n        svfloat32_t array_vec = svld1_f32(pg, &array[i * svcntw() * stride]);\n        sum_vec = svadd_f32(sum_vec, array_vec);\n    }\n\n    sum += svaddv_f32(svptrue_b32(), sum_vec);\n\n    for (size_t i = remainder_loop_start; i < dim; ++i) {\n        sum += array[i * stride];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    size_t vectorizable_loop_count = dim / svcntf32();\n    size_t remainder_loop_count = dim % svcntf32();\n\n    for (size_t i = 0; i < vectorizable_loop_count; ++i) {\n        svbool_t pg = svwhilelt_b32(i * svcntf32(), (i + 1) * svcntf32());\n        svfloat32_t array_vec = svld1_f32(pg, &array[i * svcntf32() * stride]);\n        sum_vec = svadd_f32(sum_vec, array_vec);\n    }\n\n    for (size_t i = 0; i < svcntf32(); ++i) {\n        if (vectorizable_loop_count * svcntf32() + i < dim) {\n            sum += svgetelem_f32(sum_vec, i);\n        }\n    }\n    \n    for (size_t i = vectorizable_loop_count * svcntf32(); i < dim; ++i) {\n        sum += array[i * stride];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    size_t vectorizable_loop_count = dim / svcntw();\n    size_t remainder_loop_start = vectorizable_loop_count * svcntw();\n\n    for (size_t i = 0; i < vectorizable_loop_count; ++i) {\n        svbool_t pg = svwhilelt_b32(i * svcntw(), dim);\n        sum_vec = svadd_f32_m(pg, sum_vec, svld1_f32(pg, &array[i * svcntw() * stride]));\n    }\n\n    for (size_t i = remainder_loop_start; i < dim; ++i) {\n        sum += array[i * stride];\n    }\n\n    sum += svaddv_f32(svptrue_b32(), sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    size_t vectorizable_loop_count = dim / svcntw();\n    size_t remainder_loop_start = vectorizable_loop_count * svcntw();\n\n    for (size_t i = 0; i < vectorizable_loop_count; ++i) {\n        svbool_t pg = svwhilelt_b32(i * svcntw(), dim);\n        sum_vec = svadd_f32_m(pg, sum_vec, svld1_f32(pg, &array[i * svcntw() * stride]));\n    }\n\n    for (size_t i = remainder_loop_start; i < dim; ++i) {\n        sum += array[i * stride];\n    }\n\n    sum += svaddv_f32(svptrue_b32(), sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vector_length = svcntw();\n    size_t loop_iterations = dim / vector_length;\n    size_t remainder = dim % vector_length;\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svfloat32_t vec_sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < vector_length; ++j) {\n            size_t index = (i * vector_length + j) * (dim * dim + dim + 1);\n            svfloat32_t vec_val = svld1(pg, &array[index]);\n            vec_sum = svadd_f32(vec_sum, vec_val);\n        }\n        sum += svaddv_f32(pg, vec_sum);\n    }\n\n    if (remainder > 0) {\n        svbool_t pg = svwhilelt_b32(0, remainder);\n        svfloat32_t vec_sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < remainder; ++j) {\n            size_t index = (loop_iterations * vector_length + j) * (dim * dim + dim + 1);\n            svfloat32_t vec_val = svld1(pg, &array[index]);\n            vec_sum = svadd_f32(vec_sum, vec_val);\n        }\n        sum += svaddv_f32(pg, vec_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t src_vec = svld1(pg, &src[i]);\n        svfloat64_t threshold_vec = svdup_f64(threshold);\n        svbool_t cmp_vec = svcmpgt_f64(pg, src_vec, threshold_vec);\n        svfloat64_t scale_vec = svdup_f64(scale);\n        svfloat64_t scaled_vec = svmul_f64(src_vec, scale_vec);\n        svfloat64_t res_vec = svsel_f64(cmp_vec, scaled_vec, src_vec);\n        svst1(pg, &dst[i], res_vec);\n    }\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t loop_iterations = total_elements;\n\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n    svfloat64_t scale_vec = svdup_f64(scale);\n\n    for (size_t i = 0; i < loop_iterations; ) {\n        svbool_t pg = svwhilelt_b64(i, loop_iterations);\n        svfloat64_t src_vec = svld1_f64(pg, &src[i]);\n        svbool_t cmp_vec = svcmpgt_f64(pg, src_vec, threshold_vec);\n        svfloat64_t result_vec = svsel_f64(cmp_vec, svmul_f64_x(pg, src_vec, scale_vec), src_vec);\n        svst1_f64(pg, &dst[i], result_vec);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t sv_src = svld1(pg, &src[i * cols + j]);\n            svfloat64_t sv_threshold = svdup_f64(threshold);\n            svbool_t cmp = svcmpgt_f64(pg, sv_src, sv_threshold);\n            svfloat64_t sv_scale = svdup_f64(scale);\n            svfloat64_t sv_scaled = svmul_f64(sv_src, sv_scale);\n            svfloat64_t sv_res = svsel_f64(cmp, sv_scaled, sv_src);\n            svst1(pg, &dst[i * cols + j], sv_res);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t src_vec = svld1(pg, &src[i]);\n        svfloat64_t threshold_vec = svdup_f64(threshold);\n        svbool_t cmp_vec = svcmpgt_f64(pg, src_vec, threshold_vec);\n        svfloat64_t scale_vec = svdup_f64(scale);\n        svfloat64_t scaled_vec = svmul_f64(src_vec, scale_vec);\n        svfloat64_t res_vec = svsel_f64(cmp_vec, scaled_vec, src_vec);\n        svst1(pg, &dst[i], res_vec);\n    }\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t sv_src = svld1(pg, &src[i * cols + j]);\n            svfloat64_t sv_threshold = svdup_f64(threshold);\n            svbool_t cmp = svcmpgt_f64(pg, sv_src, sv_threshold);\n            svfloat64_t sv_scale = svdup_f64(scale);\n            svfloat64_t sv_scaled = svmul_f64(sv_src, sv_scale);\n            svfloat64_t sv_res = svsel_f64(cmp, sv_scaled, sv_src);\n            svst1(pg, &dst[i * cols + j], sv_res);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_loop = cols;\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j < col_loop - svcntd(); j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, col_loop);\n            svfloat64_t src_vec = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, src_vec);\n        }\n\n        for (; j < col_loop; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_loop = cols;\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j < col_loop - svcntd(); j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, col_loop);\n            svfloat64_t src_vec = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, src_vec);\n        }\n        for (; j < col_loop; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_cnt = cols;\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * col_cnt;\n        double *dst_row = dst + i * col_cnt;\n\n        size_t j = 0;\n        for (; j < col_cnt - 3; j += 4) {\n            svbool_t pg = svwhilelt_b64(j, col_cnt);\n            svfloat64_t src_vec = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, src_vec);\n        }\n        for (; j < col_cnt; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j < cols - vl + 1; j += vl) {\n            svfloat64_t src_vec = svld1_f64(svptrue_b64(), src_row + j);\n            svst1_f64(svptrue_b64(), dst_row + j, src_vec);\n        }\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_loop = cols;\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j < col_loop - svcntd(); j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, col_loop);\n            svfloat64_t src_vec = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, src_vec);\n        }\n        for (; j < col_loop; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    for (; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n\n        svint64_t sv_src1 = svld1(pg, src1 + i);\n        svint64_t sv_src2 = svld1(pg, src2 + i);\n\n        svint64_t sum = svadd_s64_z(pg, sv_src1, sv_src2);\n        svint64_t scaled_sum = svadd_s64_z(pg, sum, scalar);\n        svint64_t result = svdiv_s64_z(pg, scaled_sum, 2);\n\n        svst1(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    for (; svptest_any(pg, pg); i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n\n        svint64_t vec1 = svld1(pg, src1 + i);\n        svint64_t vec2 = svld1(pg, src2 + i);\n\n        svint64_t sum = svadd_s64_x(pg, vec1, vec2);\n        svint64_t scaled_sum = svadd_s64_x(pg, sum, scalar);\n        svint64_t result = svdiv_s64_x(pg, scaled_sum, 2);\n\n        svst1(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd()) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_s64(vec1, vec2);\n        result = svadd_s64(result, svdup_s64(scalar));\n        result = svshl_n_s64(result, -1); // Divide by 2 (round-toward-zero)\n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b64(i + svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd() ) {\n        svint64_t v_src1 = svld1(pg, &src1[i]);\n        svint64_t v_src2 = svld1(pg, &src2[i]);\n        svint64_t v_result = svadd_s64(v_src1, v_src2);\n        v_result = svadd_s64(v_result, svdup_n_s64(scalar));\n        v_result = svshl_n_s64(v_result, -1); // Divide by 2 (right shift)\n        svst1(pg, &dst[i], v_result);\n        pg = svwhilelt_b64(i + svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd() ) {\n        svint64_t v_src1 = svld1(pg, &src1[i]);\n        svint64_t v_src2 = svld1(pg, &src2[i]);\n        svint64_t v_result = svadd_s64(v_src1, v_src2);\n        v_result = svadd_s64(v_result, svdup_n_s64(scalar));\n        v_result = svshl_n_s64(v_result, -1); // Divide by 2 (round-toward-zero)\n        svst1(pg, &dst[i], v_result);\n        pg = svwhilelt_b64(i + svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = src[0]; \n\n    if (length <= 1)\n        return min_val;\n\n    size_t vector_length = svcntw();\n    size_t loop_iterations = length / (2 * vector_length);\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1_s32(pg, src + 2 * i * vector_length);\n        \n        for (size_t j = 0; j < vector_length; ++j) {\n            if (svgetelem_s32(vec, j) < min_val) {\n                min_val = svgetelem_s32(vec, j);\n            }\n        }\n    }\n\n    size_t remaining_elements = length % (2 * vector_length);\n    size_t base_index = length - remaining_elements;\n\n    for (size_t i = 0; i < remaining_elements; i += 2) {\n        if (base_index + i < length) {\n            if (src[base_index + i] < min_val) {\n                min_val = src[base_index + i];\n            }\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = src[0]; \n\n    if (length <= 1) {\n        return min_val;\n    }\n\n    size_t vector_length = svcntw();\n    size_t loop_iterations = (length / 2) / vector_length;\n    size_t remainder = (length / 2) % vector_length;\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1_s32(pg, &src[2 * i * vector_length * 2 + 2]);\n        svint32_t min_vec = svdup_n_s32(min_val);\n        svint32_t cmp_vec = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(cmp_vec, vec, min_vec);\n        min_val = svgetfirst_s32(pg, min_vec);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            int current_val = svgetelem_s32(vec, j);\n            if (current_val < min_val) {\n                min_val = current_val;\n            }\n        }\n    }\n\n    for (size_t i = loop_iterations * vector_length; i < length / 2; ++i) {\n        if (src[2 * i + 2] < min_val) {\n            min_val = src[2 * i + 2];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = src[0]; \n\n    if (length <= 1) {\n        return min_val;\n    }\n\n    size_t vector_length = svcntw();\n    size_t loop_iterations = (length / 2) / vector_length;\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1_s32(pg, &src[2 * i * vector_length * 2]);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            if (2 * (2 * i * vector_length + j) < length) {\n                if (svgetelem_s32(vec, j) < min_val) {\n                    min_val = svgetelem_s32(vec, j);\n                }\n            }\n        }\n    }\n\n    size_t remaining_elements = (length / 2) % vector_length;\n    size_t base_index = 2 * loop_iterations * vector_length * 2;\n\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        if (base_index + 2 * i < length) {\n            if (src[base_index + 2 * i] < min_val) {\n                min_val = src[base_index + 2 * i];\n            }\n        }\n    }\n    \n    if (length % 2 == 0 && length > 0){\n        if (src[length-2] < min_val){\n            min_val = src[length-2];\n        }\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = src[0]; \n\n    if (length <= 1) {\n        return min_val;\n    }\n\n    size_t vector_length = svcntw();\n    size_t loop_iterations = (length / 2) / vector_length;\n    size_t remainder = (length / 2) % vector_length;\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1_s32(pg, &src[2 * i * vector_length * 2 + 2]);\n        svint32_t min_vec = svdup_n_s32(min_val);\n        svint32_t cmp_vec = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(cmp_vec, vec, min_vec);\n        min_val = svgetfirst_s32(pg, min_vec);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            int current_val = svgetelem_s32(vec, j);\n            if (current_val < min_val) {\n                min_val = current_val;\n            }\n        }\n    }\n\n    for (size_t i = loop_iterations * vector_length; i < (length / 2); ++i) {\n        if (src[2 * i + 2] < min_val) {\n            min_val = src[2 * i + 2];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = src[0]; \n\n    for (size_t i = 2; i < length; i += 2) {\n        min_val = (src[i] < min_val) ? src[i] : min_val;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i < length - vl + 1; i += vl) {\n        svint32_t s = svld1_s32(svptr_u32((uint32_t *)(src + i)));\n\n        svint32_t arith_shift = svasr_n_s32(s, shift);\n\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shift = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n\n        svint32_t sum = svadd_s32_z(svptrue_b32(), arith_shift, logic_shift);\n\n        svst1_s32(svptr_u32((uint32_t *)(dst + i)), sum);\n    }\n\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i < length - vl + 1; i += vl) {\n        svint32_t s = svld1_s32(svptr_u32((uint32_t *)(src + i)));\n\n        svint32_t arith_shift = svasr_n_s32(s, shift);\n\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shift = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n\n        svint32_t sum = svadd_s32_z(svptrue_b32(), arith_shift, logic_shift);\n\n        svst1_s32(svptr_u32((uint32_t *)(dst + i)), sum);\n    }\n\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    size_t loops = length / vl;\n    size_t tail = length % vl;\n\n    for (size_t i = 0; i < loops; ++i) {\n        svint32_t s = svld1w(svptrue_b32(), &src[i * vl]);\n        svint32_t arith_shifted = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shifted = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_z(svptrue_b32(), arith_shifted, logic_shifted);\n        svst1w(svptrue_b32(), &dst[i * vl], sum);\n    }\n\n    if (tail > 0) {\n        svbool_t p = svwhilelt_b32(0, tail);\n        svint32_t s = svld1w(p, &src[loops * vl]);\n        svint32_t arith_shifted = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shifted = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_z(p, arith_shifted, logic_shifted);\n        svst1w(p, &dst[loops * vl], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    size_t loops = length / vl;\n    size_t tail = length % vl;\n\n    for (size_t i = 0; i < loops; ++i) {\n        svint32_t s = svld1_s32(svptrue_b32(), src + i * vl);\n        svint32_t arith_shift = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shift = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_x(svptrue_b32(), arith_shift, logic_shift);\n        svst1_s32(svptrue_b32(), dst + i * vl, sum);\n    }\n\n    if (tail > 0) {\n        svbool_t p = svwhilelt_b32(0, tail);\n        svint32_t s = svld1_s32(p, src + loops * vl);\n        svint32_t arith_shift = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shift = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_x(p, arith_shift, logic_shift);\n        svst1_s32(p, dst + loops * vl, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    size_t loops = length / vl;\n    size_t tail = length % vl;\n\n    for (size_t i = 0; i < loops; ++i) {\n        svint32_t s = svld1w(svptrue_b32(), src + i * vl);\n        svint32_t arith_shifted = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shifted = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_z(svptrue_b32(), arith_shifted, logic_shifted);\n        svst1w(svptrue_b32(), dst + i * vl, sum);\n    }\n\n    if (tail > 0) {\n        svbool_t p = svwhilelt_b32(0, tail);\n        svint32_t s = svld1w(p, src + loops * vl);\n        svint32_t arith_shifted = svasr_n_s32(s, shift);\n        svuint32_t unsigned_s = svcvt_u32_s32(s);\n        svint32_t logic_shifted = svreinterpret_s32_u32(svlsr_n_u32(unsigned_s, shift));\n        svint32_t sum = svadd_s32_z(p, arith_shifted, logic_shifted);\n        svst1w(p, dst + loops * vl, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  size_t total_elements = rows * cols;\n  size_t loop_count = total_elements;\n\n  svbool_t pg = svptrue_b32();\n  for (size_t i = 0; i < loop_count; i += svcntw()) {\n    svint32_t vec = svld1_s32(pg, &matrix[i]);\n    sum += svaddv_s64(pg, svcvt_s64_s32(vec));\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  size_t total_elements = rows * cols;\n  size_t vector_length = svcntw();\n\n  for (size_t i = 0; i < total_elements; i += vector_length) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svint32_t vec = svld1_s32(pg, &matrix[i]);\n    svint64_t vec_long = svcvt_s64_s32(vec);\n    sum += svaddv_s64(pg, vec_long);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i < total_elements - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        sum += svaddv_s32(pg, vec);\n    }\n\n    // Handle remaining elements serially\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  size_t total_elements = rows * cols;\n  size_t loop_count = total_elements;\n\n  svbool_t pg = svwhilelt_b32(0, loop_count);\n  int const *current_matrix = matrix;\n\n  while (svptest_any(pg, pg)) {\n    svint32_t vec = svld1_s32(pg, current_matrix);\n    sum += svaddv_s32(pg, vec);\n\n    current_matrix += svcntw();\n    loop_count -= svcntw();\n    pg = svwhilelt_b32(0, loop_count);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  size_t total_elements = rows * cols;\n  size_t vector_length = svcntw();\n\n  for (size_t i = 0; i < total_elements; i += vector_length) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svint32_t sv_elements = svld1_s32(pg, &matrix[i]);\n    svint64_t sv_elements_wide = svcvt_s64_s32(sv_elements);\n    sum += svaddv_s64(pg, sv_elements_wide);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n\n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t current_values = svld1_s8(pg, &src[i]);\n        svint8_t max_vector = svdup_s8(max_value);\n        svbool_t gt = svcmpgt_s8(pg, current_values, max_vector);\n\n        if (svptest_any(pg, gt)) {\n            int8_t current_array[svcntb()];\n            svst1_s8(pg, current_array, current_values);\n\n            for (size_t j = 0; j < svcntb(); ++j) {\n                if (svptrue_b8()[j] && current_array[j] > max_value) {\n                    max_value = current_array[j];\n                    max_index = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n\n    for (; i < svcntb() && i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    for (; i < length; i += svcntb()) {\n        pg = svwhilelt_b8(i, length);\n        svint8_t current_values = svld1_s8(pg, &src[i]);\n\n        svbool_t gt_max = svcmpgt_s8(pg, current_values, max_value);\n\n        if (svptest_any(pg, gt_max)) {\n            int8_t current_max = max_value;\n            size_t current_max_index = max_index;\n\n            for (size_t j = 0; j < svcntb(); ++j) {\n                if (i + j < length && svptrue_b8()[j] && gt_max[j]) {\n                    if (svgetelement_s8(current_values, j) > current_max) {\n                        current_max = svgetelement_s8(current_values, j);\n                        current_max_index = i + j;\n                    }\n                }\n            }\n            max_value = current_max;\n            max_index = current_max_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntb()) {\n        svint8_t current_values = svld1_s8(pg, &src[i]);\n        int8_t current_max = max_value;\n        svint8_t max_vector = svdup_s8(current_max);\n        svbool_t greater_than_max = svcmpgt_s8(pg, current_values, max_vector);\n\n        if (svptest_any(greater_than_max, greater_than_max)) {\n            int8_t temp_array[svcntb()];\n            svst1_s8(pg, temp_array, current_values);\n\n            for (size_t j = 0; j < svcntb(); ++j) {\n                if (svptrue_b8()[j] && greater_than_max[j]) {\n                    if (temp_array[j] > max_value) {\n                        max_value = temp_array[j];\n                        max_index = i + j;\n                    }\n                }\n            }\n        }\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    // Handle remaining elements serially\n    for (; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntb()) {\n        svint8_t current_values = svld1_s8(pg, &src[i]);\n        int8_t current_max = max_value;\n        svint8_t max_vector = svdup_s8(current_max);\n\n        svbool_t greater_than_max = svcmpgt_s8(pg, current_values, max_vector);\n\n        if (svptest_any(greater_than_max, greater_than_max)) {\n            int8_t temp_array[svcntb()];\n            svst1_s8(greater_than_max, temp_array, current_values);\n\n            for (size_t j = 0; j < svcntb(); ++j) {\n                if (svptest_lane(greater_than_max, j)) {\n                    if (temp_array[j] > max_value) {\n                        max_value = temp_array[j];\n                        max_index = i + j;\n                    }\n                }\n            }\n        }\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    // Handle remaining elements without SVE\n    for (; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t index = 0;\n\n    for (; svptest_any(pg, pg); index += svcntb(), pg = svwhilelt_b8(index, length)) {\n        svint8_t current_values = svld1_s8(pg, &src[index]);\n        svbool_t greater_than_max = svcmpgt_s8(pg, current_values, max_value);\n\n        if (svptest_any(greater_than_max, greater_than_max)) {\n            int8_t current_max = svmax_s8(pg, current_values, max_value);\n            if (current_max > max_value) {\n                max_value = current_max;\n                size_t lane_index = svfirst_s8(greater_than_max);\n                max_index = index + lane_index;\n            } else if (current_max == max_value) {\n                svbool_t equal_to_max = sveq_s8(pg, current_values, max_value);\n                size_t lane_index = svfirst_s8(equal_to_max);\n                if (index + lane_index < max_index)\n                    max_index = index + lane_index;\n            }\n        }\n    }\n\n    // Handle remaining elements if length is not a multiple of the vector length\n    for (; index < length; ++index) {\n        if (src[index] > max_value) {\n            max_value = src[index];\n            max_index = index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), length);\n        uint64_t current_index = i;\n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n        \n        svuint32_t index_vec = svadd_n_u32_x(pg, svindex_u32(i, 1), i);\n        svuint32_t mask_vec = svdup_n_u32(mask);\n        svbool_t blend_mask = svcmpne(pg, svand_u32(index_vec, mask_vec), svdup_n_u32(0));\n\n        svuint16_t blended_vec = svsel(blend_mask, src1_vec, src2_vec);\n        svst1_u16(pg, dst + i, blended_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n\n        uint32_t index_arr[svcntw()];\n        for (size_t j = 0; j < svcntw(); ++j) {\n            index_arr[j] = i + j;\n        }\n\n        svuint32_t index_vec = svld1_u32(pg, index_arr);\n        svuint32_t mask_vec = svdup_u32(mask);\n        svbool_t blend_mask = svcmpne(pg, sveand_u32(index_vec, mask_vec), svdup_u32(0));\n\n        svuint16_t blended_vec = svsel_u16(blend_mask, src1_vec, src2_vec);\n        svst1_u16(pg, dst + i, blended_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), length);\n        uint64_t current_index = i;\n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n        svuint16_t dst_vec;\n\n        size_t lane_count = svcntw();\n        for (size_t j = 0; j < lane_count; ++j) {\n            if (svptest_any(pg, svptrue_b16())) {\n                uint32_t index = current_index + j;\n                if ((index & mask) != 0) {\n                    svsel_u16(svptrue_b16(), &dst_vec, src1_vec);\n                } else {\n                    svsel_u16(svptrue_b16(), &dst_vec, src2_vec);\n                }\n            }\n        }\n        \n        svbool_t blend_pg = svwhilelt_b32(svindex_u32(i, 1), length);\n        svuint32_t index_vec = svindex_u32(i, 1);\n        svbool_t select_pg = svcmpne_u32(blend_pg, sveor_u32(index_vec, svlsr_u32(index_vec, 32)), svdup_u32(0));\n        svuint16_t blended_vec = svsel_u16(select_pg, src1_vec, src2_vec);\n        svst1_u16(pg, dst + i, blended_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), length);\n        uint64_t current_index = i;\n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n        svuint16_t dst_vec = svdup_u16(0);\n\n        size_t lane_count = svcntw();\n        for (size_t j = 0; j < lane_count && i + j < length; ++j) {\n            if ((current_index & mask) != 0) {\n                dst_vec = svsel_u16(svptrue_b16(), svlsr_u16(src1_vec,0), dst_vec);\n            } else {\n                dst_vec = svsel_u16(svptrue_b16(), svlsr_u16(src2_vec,0), dst_vec);\n            }\n            current_index++;\n        }\n        svst1_u16(pg, dst + i, dst_vec);\n        i += lane_count;\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t src1_vec = svld1_u16(pg, &src1[i]);\n        svuint16_t src2_vec = svld1_u16(pg, &src2[i]);\n\n        uint32_t indices[svcntw()];\n        for (size_t j = 0; j < svcntw(); ++j) {\n            indices[j] = i + j;\n        }\n\n        svuint32_t index_vec = svld1_u32(pg, indices);\n        svuint32_t mask_vec = svdup_u32(mask);\n        svbool_t blend_mask = svcmpne(pg, sveand_u32(index_vec, mask_vec), svdup_u32(0));\n\n        svuint16_t blended_vec = svsel_u16(blend_mask, src1_vec, src2_vec);\n        svst1_u16(pg, &dst[i], blended_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t sv_src = svld1_u32(pg, &src[i]);\n        svuint32_t sv_dst = svcnt_u32_m(pg, sv_src);\n        svst1_u32(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t sv_src = svld1_u32(pg, &src[i]);\n        svuint32_t sv_dst = svcnt_u32_m(pg, sv_src);\n        svst1_u32(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint32_t source array (src);\n- A pointer to a non-empty uint32_t destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the population count (the number of 1 bits in the binary representation of an integer) \nfor each element in the array.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; svptest_first(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, length)) {\n        svuint32_t v_src = svld1_u32(pg, &src[i]);\n        svuint32_t v_dst = svcnt_u32(v_src);\n        svst1_u32(pg, &dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t sv_src = svld1_u32(pg, &src[i]);\n        svuint32_t sv_dst = svcnt_u32_m(pg, sv_src);\n        svst1_u32(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t sv_src = svld1_u32(pg, &src[i]);\n        svuint32_t sv_dst = svcnt_u32_z(pg, sv_src);\n        svst1_u32(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t sum = svqadd_u16(vec1, vec2);\n        svst1_u16(pg, dst + i, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any_first(pg, pg); i += svcntw()) {\n        svuint16_t a = svld1_u16(pg, src1 + i);\n        svuint16_t b = svld1_u16(pg, src2 + i);\n        svuint16_t sum = svqadd_u16(a, b);\n        svst1_u16(pg, dst + i, sum);\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n        svuint16_t sv_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t sv_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t sum = svqadd_u16(sv_src1, sv_src2);\n        svst1_u16(pg, &dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n        svuint16_t sv_src1 = svld1_u16(pg, src1 + i);\n        svuint16_t sv_src2 = svld1_u16(pg, src2 + i);\n        svuint16_t sum = svqadd_u16(sv_src1, sv_src2);\n        svst1_u16(pg, dst + i, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(pg, pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t sum = svqadd_u16(vec1, vec2);\n        svst1_u16(pg, dst + i, sum);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, &A[i]);\n        svint64_t b_vec = svld1(pg, &B[i]);\n        svint64_t c_vec = svadd_s64(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_count = total_elements;\n\n  const int64_t *a_ptr = A;\n  const int64_t *b_ptr = B;\n  int64_t *c_ptr = C;\n\n  while (loop_count > 0) {\n    svbool_t pg = svwhilelt_b64(0, loop_count);\n    svint64_t a = svld1_s64(pg, a_ptr);\n    svint64_t b = svld1_s64(pg, b_ptr);\n    svint64_t c = svadd_s64(a, b);\n    svst1_s64(pg, c_ptr, c);\n\n    size_t vl = svcntd();\n    a_ptr += vl;\n    b_ptr += vl;\n    c_ptr += vl;\n    loop_count -= vl;\n  }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_iterations = total_elements;\n  const int64_t *ptr_a = A;\n  const int64_t *ptr_b = B;\n  int64_t *ptr_c = C;\n\n  while (loop_iterations > 0) {\n    svbool_t pg = svwhilelt_b64(0, loop_iterations);\n    svint64_t a = svld1(pg, ptr_a);\n    svint64_t b = svld1(pg, ptr_b);\n    svint64_t c = svadd_s64(a, b);\n    svst1(pg, ptr_c, c);\n\n    size_t VL = svcntd();\n    loop_iterations -= VL;\n    ptr_a += VL;\n    ptr_b += VL;\n    ptr_c += VL;\n  }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint64_t a_vec = svld1_u64(svptrue_b64(), &A[i]);\n        svuint64_t b_vec = svld1_u64(svptrue_b64(), &B[i]);\n        svuint64_t c_vec = svadd_u64(a_vec, b_vec);\n        svst1_u64(svptrue_b64(), &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint64_t a_vec = svld1_u64(svptrue_b64(), &A[i]);\n        svuint64_t b_vec = svld1_u64(svptrue_b64(), &B[i]);\n        svuint64_t c_vec = svadd_u64(a_vec, b_vec);\n        svst1_u64(svptrue_b64(), &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svroundn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t vec1, vec2, result;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svmin_u(size_t, svcntw(), length - i);\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t vec1, vec2, result;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svmin_u(size_t, svcntw(), length - i);\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_u32(svptrue_b32(), (const float*)&src1[i]);\n        vec2 = svld1_u32(svptrue_b32(), (const float*)&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_u32(svptrue_b32(), (float*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t vsrc1, vsrc2, vresult;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        vsrc1 = svld1(pg, &src1[i]);\n        vsrc2 = svld1(pg, &src2[i]);\n\n        svfloat32_t vdiff = svabs_f32(svsub_f32(vsrc1, vsrc2));\n        svbool_t cond1 = svcmplt_f32(vdiff, svdup_f32(50.0f));\n        svbool_t cond2 = svindex_b32(i, 2);\n        svbool_t final_cond = svand_b(cond1, cond2);\n\n        vresult = svmul_f32(vsrc1, vsrc2);\n        vresult = svceil_f32(vresult);\n        vresult = svsel(final_cond, vresult, svdup_f32(-1.0f));\n\n        svst1(pg, &dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        svbool_t condition = svcmple_f32(pg, v_diff, svdup_f32(50.0f));\n\n        svfloat32_t v_mul = svmul_f32(v_src1, v_src2);\n        v_result = svifthen(condition, v_mul, svdup_f32(-1.0f));\n\n        v_result = svceil_f32(v_result);\n        \n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        // Load vectors from source arrays\n        v_src1 = svld1_f32(pg, &src1[i]);\n        v_src2 = svld1_f32(pg, &src2[i]);\n\n        // Calculate the absolute difference\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n\n        // Create a mask for the conditions\n        pg = svcmplt_f32(v_diff, svdup_f32(50.0f));\n\n        // Create a mask for even indices\n        svbool_t even_pg = svindex(svcntw(), 0, 2);\n\n        // Combine masks\n        pg = svand(pg, even_pg);\n\n        // Perform element-wise multiplication where conditions are met\n        v_result = svmul_f32(v_src1, v_src2);\n        v_result = svifthen_f32(pg, v_result, svdup_f32(-1.0f));\n\n        // Round up towards positive infinity\n        v_result = svceil_f32(v_result);\n\n        // Store results back to destination array\n        svst1_f32(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t sv_src1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t sv_src2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t diff = svfabs_f32_z(pg, svsub_f32(sv_src1, sv_src2));\n        svbool_t cond_mask = svand_b32(pg, svcmpge_f32(pg, diff, 0.0), svcmple_f32(pg, diff, 50.0));\n\n        svbool_t index_mask = svand_b32(pg, cond_mask, sveor_b32(pg, svptrue_b32(), svlsr_b32(pg, svptrue_b32(), 1)));\n\n        svfloat32_t result = svmul_f32(sv_src1, sv_src2);\n        svfloat32_t rounded_result = svceil_f32(result);\n        svfloat32_t final_result = svsel_f32(index_mask, rounded_result, -1.0f);\n\n        svst1_f32(pg, &dst[i], final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t sv_src1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t sv_src2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t diff = svfabs_f32_z(pg, svsub_f32(sv_src1, sv_src2));\n        svbool_t cond_mask = svand_b32(pg, svcmpge_f32(pg, diff, 0.0), svcmple_f32(pg, diff, 50.0));\n\n        svbool_t index_mask = svand_b32(pg, cond_mask, sveor_b32(pg, svptrue_b32(), svlsr_b32(pg, svptrue_b32(), 1)));\n\n        svfloat32_t result = svmul_f32_m(index_mask, sv_src1, sv_src2);\n        result = svceil_f32_m(index_mask, result);\n\n        svfloat32_t default_value = svdup_f32(-1.0f);\n        svfloat32_t final_result = svsel_f32(cond_mask, result, default_value);\n\n        svst1_f32(pg, &dst[i], final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t total_elements = m * n;\n  size_t loop_count = total_elements;\n  const double* current_mat = mat;\n  double* current_dst = dst;\n\n  svfloat64_t scalar_vec = svdup_f64(scalar);\n\n  while (loop_count > 0) {\n    svbool_t pg = svwhilelt_b64((uint64_t)0, loop_count);\n    svfloat64_t mat_vec = svld1_f64(pg, current_mat);\n    svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n    svst1_f64(pg, current_dst, result_vec);\n\n    size_t vec_len = svcntd();\n    current_mat += vec_len;\n    current_dst += vec_len;\n    loop_count -= vec_len;\n  }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t total_elements = m * n;\n  size_t loop_count = total_elements;\n\n  const double* src_ptr = mat;\n  double* dst_ptr = dst;\n\n  svfloat64_t scalar_vec = svdup_f64(scalar);\n\n  while (loop_count > 0) {\n    svbool_t pg = svwhilelt_b64((uint64_t)0, loop_count);\n    svfloat64_t src_vec = svld1(pg, src_ptr);\n    svfloat64_t dst_vec = svmul_f64_x(pg, src_vec, scalar_vec);\n    svst1(pg, dst_ptr, dst_vec);\n\n    size_t vec_len = svcntd();\n    src_ptr += vec_len;\n    dst_ptr += vec_len;\n    loop_count -= vec_len;\n  }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t size = m * n;\n  size_t i = 0;\n  svfloat64_t scalar_vec = svdup_f64(scalar);\n\n  for (; i < size; i += svcntd()) {\n    svbool_t pg = svwhilelt_b64(i, size);\n    svfloat64_t mat_vec = svld1(pg, &mat[i]);\n    svfloat64_t res_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n    svst1(pg, &dst[i], res_vec);\n  }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t total_elements = m * n;\n  size_t loop_count = total_elements;\n  const double* current_mat = mat;\n  double* current_dst = dst;\n\n  svfloat64_t scalar_vec = svdup_f64(scalar);\n\n  while (loop_count > 0) {\n    svbool_t pg = svwhilelt_b64((uint64_t)0, loop_count);\n    svfloat64_t mat_vec = svld1_f64(pg, current_mat);\n    svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n    svst1_f64(pg, current_dst, result_vec);\n\n    size_t vector_length = svcntd();\n    current_mat += vector_length;\n    current_dst += vector_length;\n    loop_count -= vector_length;\n  }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t size = m * n;\n  size_t i = 0;\n\n  svfloat64_t scalar_vec = svdup_f64(scalar);\n\n  for (; i < size - svcntd(); i += svcntd()) {\n    svbool_t pg = svwhilelt_b64(i, size);\n    svfloat64_t mat_vec = svld1(pg, &mat[i]);\n    svfloat64_t res_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n    svst1(pg, &dst[i], res_vec);\n  }\n\n  for (; i < size; ++i) {\n    dst[i] = mat[i] * scalar;\n  }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t j = 0;\n\n        // Vector loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1_f32(svptrue_b32(), &mat[i * n + j]);\n            sum_sq += svaddv_f32(svptrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            sum_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        // Vector loop for normalization\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1_f32(svptrue_b32(), &mat[i * n + j]);\n            svst1_f32(svptrue_b32(), &mat[i * n + j], svdiv_f32(vec, norm));\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t j = 0;\n\n        // Vector loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t sq = svmul_f32(vec, vec);\n            sum_sq += svaddv_f32(svptrue_b32(), sq);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            sum_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        // Vector loop for normalization\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t normalized_vec = svdiv_f32(vec, svdup_n_f32(norm));\n            svst1(svptrue_b32(), &mat[i * n + j], normalized_vec);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t j = 0;\n\n        // Vector loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1_f32(svptrue_b32(), &mat[i * n + j]);\n            sum_sq += svaddv_f32(svptrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            sum_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        // Vector loop for normalization\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1_f32(svptrue_b32(), &mat[i * n + j]);\n            svst1_f32(svptrue_b32(), &mat[i * n + j], svdiv_f32(vec, norm));\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t j = 0;\n\n        // Vector loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t sq = svmul_f32(vec, vec);\n            sum_sq += svaddv_f32(svptrue_b32(), sq);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            sum_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        // Vector loop for normalization\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t normalized_vec = svdiv_f32(vec, svdup_n_f32(norm));\n            svst1(svptrue_b32(), &mat[i * n + j], normalized_vec);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_sq = 0.0f;\n        size_t j = 0;\n\n        // Vector loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t sq = svmul_f32(vec, vec);\n            sum_sq += svaddv_f32(svptrue_b32(), sq);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            sum_sq += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum_sq);\n\n        j = 0;\n        // Vector loop for normalization\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t normalized_vec = svdiv_f32(vec, svdup_n_f32(norm));\n            svst1(svptrue_b32(), &mat[i * n + j], normalized_vec);\n        }\n\n        // Scalar loop for remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            double sum = 0.0;\n            size_t k = 0;\n\n            for (; k < n - svcntd(); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[j + k * p]);\n                sum_vec = svfma_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            double sum = 0.0;\n            size_t k = 0;\n\n            for (; k < n - svcntd(); k += svcntd()) {\n                svbool_t pg = svptrue_b64();\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[j + k * p]);\n\n                sum_vec = svfma_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            double sum = 0.0;\n            size_t k = 0;\n\n            for (; k < n - svcntd(); k += svcntd()) {\n                svbool_t pg = svptrue_b64();\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec;\n\n                double temp_mat2[svcntd()];\n                for (size_t l = 0; l < svcntd(); ++l) {\n                    temp_mat2[l] = mat2[k * p + j + l*p/svcntd()];\n                }\n                mat2_vec = svld1(pg, temp_mat2);\n                sum_vec = svfma_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            double sum = 0.0;\n            size_t k = 0;\n\n            for (; k < n - svcntd(); k += svcntd()) {\n                svbool_t pg = svptrue_b64();\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec;\n\n                double temp_mat2[svcntd()];\n                for (size_t l = 0; l < svcntd(); ++l) {\n                    temp_mat2[l] = mat2[k * p + j + l * p / p];\n                }\n                mat2_vec = svld1(pg, temp_mat2);\n\n                sum_vec = svfma_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            double sum = 0.0;\n            size_t k = 0;\n\n            for (; k < n - svcntd(); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[j + k * p]);\n\n                sum_vec = svfma_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; ++j) {\n            float val = src[j * cols + i];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[i * rows + j] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; ++j) {\n            float val = src[j * cols + i];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[i * rows + j] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; ++j) {\n            float val = src[j * cols + i];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[i * rows + j] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; ++j) {\n            float val = src[j * cols + i];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[i * rows + j] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t vec1 = svld1_f32(svptrue_b32(), &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(svptrue_b32(), &tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        svfloat32_t rounded_result = svfloor_f32(result);\n        svst1_f32(svptrue_b32(), &dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svfloat32_t vec1 = svld1_u32(svptrue_b32(), (const float*)&tensor1[i]);\n        svfloat32_t vec2 = svld1_u32(svptrue_b32(), (const float*)&tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        svfloat32_t rounded_result = svtrunc_f32(result);\n        svst1_u32(svptrue_b32(), &dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t vec1 = svld1_f32(svptrue_b32(), &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(svptrue_b32(), &tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svtrunc_f32(result);\n        svst1_f32(svptrue_b32(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svfloat32_t vec1 = svld1_f32(&tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(&tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svtrunc_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t vec1 = svld1_f32(&tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(&tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svtrunc_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64_m(svptrue_b64(), vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t v1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t v2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(v1, v2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t v_vec = svld1_f32(svptrue_b32(), vec);\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t v_mat = svld1_f32(svptrue_b32(), &mat[i * n + j]);\n            sum = svmla_f32(sum, v_mat, v_vec);\n        }\n        dst[i] = svaddv_f32(svget_f32(sum));\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t mat_vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1(svptrue_b32(), &vec[j]);\n            sum += svaddv(svptrue_b32(), svmul_f32(mat_vec, vec_vec));\n        }\n\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        // Vectorized part\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t mat_vec = svld1(svptrue_b32(), &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1(svptrue_b32(), &vec[j]);\n            sum += svaddv(svptrue_b32(), svmul_f32(mat_vec, vec_vec));\n        }\n\n        // Scalar part for remaining elements\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        // SVE Vector Loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec_sv = svld1(svptrue_b32(), &vec[j]);\n            svfloat32_t mat_sv = svld1(svptrue_b32(), &mat[i * n + j]);\n            sum += svsum_f32_s(svptrue_b32(), svmul_f32_x(svptrue_b32(), mat_sv, vec_sv));\n        }\n\n        // Scalar Loop for Remaining Elements\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        size_t j = 0;\n\n        // SVE Vector Loop\n        for (; j < n - svcntf() + 1; j += svcntf()) {\n            svfloat32_t vec_sv = svld1(svptrue_b32(), &vec[j]);\n            svfloat32_t mat_sv = svld1(svptrue_b32(), &mat[i * n + j]);\n            sum += svsum_f32_s(svptrue_b32(), svmul_f32_x(svptrue_b32(), mat_sv, vec_sv));\n        }\n\n        // Scalar Loop for Remaining Elements\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, vectorizable_elements);\n        svfloat64_t data_vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_f64(sum_vec, data_vec);\n    }\n\n    sum += svaddv_f64(svptrue_b64(), sum_vec);\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, vectorizable_elements);\n        svfloat64_t data_vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_f64(sum_vec, data_vec);\n    }\n\n    sum += svaddv_f64(svptrue_b64(), sum_vec);\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, vectorizable_elements);\n        svfloat64_t data_vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_f64_x(pg, sum_vec, data_vec);\n    }\n\n    sum += svaddv_f64(sum_vec);\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t vectorizable_elements = total_elements - (total_elements % svcntd());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, vectorizable_elements);\n        svfloat64_t data_vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_f64(sum_vec, data_vec);\n    }\n\n    sum += svaddv_f64(svptrue_b64(), sum_vec);\n\n    for (size_t i = vectorizable_elements; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    size_t i = 0;\n    for (; i < total_elements - (total_elements % svcntd()); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        vec_sum = svadd_f64_x(pg, vec_sum, vec);\n    }\n\n    sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        svbool_t pg = svptrue_b32();\n        for (size_t j = 0; j < cols - 1; ++j) {\n            svint32_t current = svld1(pg, row + j);\n            svint32_t next = svld1(pg, row + j + 1);\n\n            if (ascending) {\n                svbool_t lt = svcmpgt_s32(pg, current, next);\n                if (svptest_any(pg, lt)) {\n                    return false;\n                }\n            } else {\n                svbool_t gt = svcmplt_s32(pg, current, next);\n                if (svptest_any(pg, gt)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        svbool_t pg = svptrue_b32();\n        for (size_t j = 1; j < cols; ++j) {\n            svint32_t current = svld1_s32(pg, row + j);\n            svint32_t previous = svld1_s32(pg, row + j - 1);\n\n            if (ascending) {\n                svbool_t compare = svcmpgt_s32(pg, previous, current);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            } else {\n                svbool_t compare = svcmplt_s32(pg, previous, current);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        for (size_t j = 0; j < cols - 1; j += svcntw()) {\n            svint32_t current = svld1_s32(pg, row + j);\n            svint32_t next = svld1_s32(pg, row + j + 1);\n\n            if (ascending) {\n                svbool_t compare = svcmplt_s32(pg, next, current);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            } else {\n                svbool_t compare = svcmplt_s32(pg, current, next);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            }\n            pg = svwhilelt_b32(j + svcntw(), cols - 1);\n        }\n        // Handle the last few elements if cols is not a multiple of svcntw()\n        for (size_t j = (cols - 1) - ((cols - 1) % svcntw()); j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j + 1] < row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        svbool_t pg = svptrue_b32();\n        for (size_t j = 1; j < cols; ++j) {\n            svint32_t current = svld1_s32(pg, row + j);\n            svint32_t previous = svld1_s32(pg, row + j - 1);\n\n            if (ascending) {\n                svbool_t compare = svcmpgt_s32(pg, previous, current);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            } else {\n                svbool_t compare = svcmplt_s32(pg, previous, current);\n                if (svptest_any(pg, compare)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n\n        svbool_t pg = svptrue_b32();\n        for (size_t j = 0; j < cols - 1; ++j) {\n            svint32_t current = svld1(pg, row + j);\n            svint32_t next = svld1(pg, row + j + 1);\n\n            if (ascending) {\n                svbool_t lt = svcmpgt_s32(pg, current, next);\n                if (svptest_any(pg, lt)) {\n                    return false;\n                }\n            } else {\n                svbool_t gt = svcmplt_s32(pg, current, next);\n                if (svptest_any(pg, gt)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svint16_t base_vec = svdup_n_s16((int16_t)base);\n        svint16_t rem_vec = src_vec % base_vec;\n        svint16_t result_vec = src_vec - rem_vec;\n        svst1_s16(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svint16_t base_vec = svdup_n_s16((int16_t)base);\n        svint16_t rem_vec = svmod_s16_z(pg, src_vec, base_vec);\n        svint16_t res_vec = svsub_s16_z(pg, src_vec, rem_vec);\n        svst1_s16(pg, dst + i, res_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svint16_t base_vec = svdup_n_s16((int16_t)base);\n        svint16_t rem_vec = svmod_s16(pg, src_vec, base_vec);\n        svint16_t result_vec = svsub_s16(pg, src_vec, rem_vec);\n        svst1_s16(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svint16_t base_vec = svdup_n_s16((int16_t)base);\n        svint16_t rem_vec = svmod_s16(pg, src_vec, base_vec);\n        svint16_t result_vec = svsub_s16(pg, src_vec, rem_vec);\n        svst1_s16(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svint16_t base_vec = svdup_n_s16((int16_t)base);\n        svint16_t rem_vec = svmod_s16(pg, src_vec, base_vec);\n        svint16_t result_vec = svsub_s16(pg, src_vec, rem_vec);\n        svst1_s16(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t active_elements = svwhilelt_b64(j, cols);\n            svfloat64_t row_vec = svld1(active_elements, row + j);\n            svfloat64_t vec_vec = svld1(active_elements, vector + j);\n            svbool_t eq = sveq_f64(active_elements, row_vec, vec_vec);\n            if (svptest_any(active_elements, eq) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        svbool_t row_matches = svptrue_b64(); \n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t matrix_values = svld1(pg, row + j);\n            svfloat64_t vector_values = svld1(pg, vector + j);\n            svbool_t matches = sveceq_f64(pg, matrix_values, vector_values);\n            row_matches = svand_b64(row_matches, matches);\n        }\n\n        if (svptest_any(svptrue_b64(), row_matches)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t active_elements = svwhilelt_b64(j, cols);\n            svfloat64_t row_vec = svld1(active_elements, row + j);\n            svfloat64_t vec_vec = svld1(active_elements, vector + j);\n            svbool_t cmp = sveq_f64(active_elements, row_vec, vec_vec);\n\n            if (!svptest_any(active_elements, cmp)) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        svfloat64_t row_vec = svld1(pg, row);\n        svfloat64_t vec = svld1(pg, vector);\n        svbool_t cmp = svcmpeq(pg, row_vec, vec);\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_vec = svld1(pg, row);\n        svfloat64_t vec_vec = svld1(pg, vector);\n        svfloat64_t cmp = svcmpeq_f64(row_vec, vec_vec);\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u32(svreinterpret_u32(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u32(svcntb(), svreinterpret_u32(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u32(svreinterpret_u32(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u32(svreinterpret_u32(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u8(svreinterpret_u8(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl = svcntq();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_b64(i, length);\n    svint64_t vx = svld1(pg, &x[i]);\n    svint64_t vax = svmul_x(pg, vx, a);\n    svint64_t vabs_ax = svabs_x(pg, vax);\n    svst1(pg, &y[i], vabs_ax);\n  }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl = svcntq();\n  size_t i = 0;\n  for (; i < length - vl + 1; i += vl) {\n    svint64_t vx = svld1q(svptrue_b64(), &x[i]);\n    svint64_t vax = svmulq_s64(svptrue_b64(), vx, a);\n    svint64_t vabs_ax = svabsq_s64(svptrue_b64(), vax);\n    svst1q(svptrue_b64(), &y[i], vabs_ax);\n  }\n  for (; i < length; ++i) {\n    y[i] = llabs(a * x[i]);\n  }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl = svcntq();\n  size_t i = 0;\n  for (; i < length - vl + 1; i += vl) {\n    svint64_t vx = svld1q(svptrue_b64(), &x[i]);\n    svint64_t vxa = svmulq_s64(vx, a);\n    svint64_t vabs = svabsq_s64(svld1q(svptrue_b64(), &y[i]));\n    svint64_t vresult = svsubq_s64(vxa, vabs);\n    svst1q(svptrue_b64(), &y[i], vresult);\n  }\n  for (; i < length; ++i) {\n    y[i] = a * x[i] - llabs(y[i]);\n  }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl = svcntq();\n  size_t i = 0;\n  for (; i < length - vl + 1; i += vl) {\n    svint64_t vx = svld1q(svptrue_b64(), &x[i]);\n    svint64_t vxa = svmulq_s64(vx, a);\n    svint64_t vabs = svabsq_s64(svld1q(svptrue_b64(), &y[i]));\n    svint64_t vresult = svsubq_s64(vxa, vabs);\n    svst1q(svptrue_b64(), &y[i], vresult);\n  }\n  for (; i < length; ++i) {\n    y[i] = a * x[i] - llabs(y[i]);\n  }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  size_t vl = svcntq();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_b64(i, length);\n    svint64_t vx = svld1(pg, &x[i]);\n    svint64_t vax = svmul_x(pg, vx, a);\n    svint64_t vabs_ax = svabs_x(pg, vax);\n    svst1(pg, &y[i], vabs_ax);\n  }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_val = svmin_s16(min_val, data);\n        max_val = svmax_s16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        if (value < svget1_s16(min_val)) {\n            min_val = svdup_n_s16(value);\n        }\n        if (value > svget1_s16(max_val)) {\n            max_val = svdup_n_s16(value);\n        }\n    }\n\n    MinMaxPair result;\n    result.min_num = svget1_s16(min_val);\n    result.max_num = svget1_s16(max_val);\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_val = svmin_s16(min_val, data);\n        max_val = svmax_s16(max_val, data);\n    }\n\n    int16_t min_result = INT16_MAX;\n    int16_t max_result = INT16_MIN;\n\n    for (; i < length; i++) {\n        min_result = (vec[i] < min_result) ? vec[i] : min_result;\n        max_result = (vec[i] > max_result) ? vec[i] : max_result;\n    }\n\n    MinMaxPair result;\n    result.min_num = svmin_s16(min_val, svdup_n_s16(min_result));\n    result.max_num = svmax_s16(max_val, svdup_n_s16(max_result));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    if (length <= 0) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(vec[0]);\n    svint16_t max_val = svdup_n_s16(vec[0]);\n\n    size_t i = 0;\n    for (; i < length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t current_vec = svld1_s16(pg, &vec[i]);\n\n        min_val = svmin_s16(pg, min_val, current_vec);\n        max_val = svmax_s16(pg, max_val, current_vec);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    svst1_s16(pg, min_arr, min_val);\n    svst1_s16(pg, max_arr, max_val);\n\n    int16_t final_min = min_arr[0];\n    int16_t final_max = max_arr[0];\n\n    for (size_t j = 0; j < svcntw() && (i + j) < length; ++j) {\n        if ((i + j) < length) {\n            if (min_arr[j] < final_min) {\n                final_min = min_arr[j];\n            }\n            if (max_arr[j] > final_max) {\n                final_max = max_arr[j];\n            }\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < final_min) {\n            final_min = vec[i];\n        }\n        if (vec[i] > final_max) {\n            final_max = vec[i];\n        }\n    }\n\n    result.min_num = final_min;\n    result.max_num = final_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    if (length <= 0) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(vec[0]);\n    svint16_t max_val = svdup_n_s16(vec[0]);\n\n    size_t i = 0;\n    for (; i < length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t current_vec = svld1_s16(pg, &vec[i]);\n\n        min_val = svmin_s16(pg, min_val, current_vec);\n        max_val = svmax_s16(pg, max_val, current_vec);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    svst1_s16(pg, min_arr, min_val);\n    svst1_s16(pg, max_arr, max_val);\n\n    int16_t final_min = min_arr[0];\n    int16_t final_max = max_arr[0];\n\n    for (size_t j = 0; j < svcntw(); ++j)\n    {\n        if (i + j < length)\n        {\n            if (min_arr[j] < final_min)\n            {\n                final_min = min_arr[j];\n            }\n            if (max_arr[j] > final_max)\n            {\n                final_max = max_arr[j];\n            }\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < final_min) {\n            final_min = vec[i];\n        }\n        if (vec[i] > final_max) {\n            final_max = vec[i];\n        }\n    }\n\n    result.min_num = final_min;\n    result.max_num = final_max;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    if (length <= 0) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(vec[0]);\n    svint16_t max_val = svdup_n_s16(vec[0]);\n\n    size_t i = 0;\n    for (; i < length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t current_vec = svld1_s16(pg, &vec[i]);\n\n        min_val = svmin_s16(pg, min_val, current_vec);\n        max_val = svmax_s16(pg, max_val, current_vec);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    svst1_s16(pg, min_arr, min_val);\n    svst1_s16(pg, max_arr, max_val);\n\n    result.min_num = min_arr[0];\n    result.max_num = max_arr[0];\n\n    for(size_t j = 0; j < svcntw() && (i + j) < length; ++j) {\n        if(vec[i+j] < result.min_num) {\n            result.min_num = vec[i+j];\n        }\n        if(vec[i+j] > result.max_num) {\n            result.max_num = vec[i+j];\n        }\n    }\n    \n    for (size_t j = 0; j < svcntw(); ++j) {\n        if ((i + j) < length) {\n            if (min_arr[j] < result.min_num) {\n                result.min_num = min_arr[j];\n            }\n            if (max_arr[j] > result.max_num) {\n                result.max_num = max_arr[j];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, row);\n\n    for (size_t j = 1; j < cols; ++j) {\n      svint32_t curr = svld1_s32(pg, row + j);\n      svbool_t lt = svcmpgt_s32(pg, prev, curr);\n\n      if (svptest_any(pg, lt)) {\n        return false;\n      }\n      prev = curr;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n    svbool_t pg = svptrue_b32();\n\n    for (size_t j = 1; j < cols; ++j) {\n      svint32_t current = svld1(pg, row + j);\n      svint32_t previous = svld1(pg, row + j - 1);\n      pg = svcmplt_s32(pg, previous, current);\n      if (!svptest_any(pg, pg)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n\n    svbool_t pg = svptrue_b32();\n    int32_t prev = row[0];\n\n    for (size_t j = 1; j < cols; j += svcntw()) {\n      svint32_t current = svld1_s32(pg, row + j);\n      svint32_t previous_vec = svdup_n_s32(prev);\n      svbool_t lt = svcmpgt_s32(pg, previous_vec, current);\n\n      if (svptest_any(pg, lt)) {\n        return false;\n      }\n\n      prev = row[j + svcntw() -1 ];\n      if (j + svcntw() > cols){\n          prev = row[cols-1];\n      }\n    }\n    for(size_t j = 1; j < cols; ++j){\n        if(row[j] <= row[j-1]){\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n\n    svbool_t pg = svptrue_b32();\n    int32_t prev = row[0];\n\n    for (size_t j = 1; j < cols; j += svcntw()) {\n      svint32_t current_vec = svld1_s32(pg, row + j);\n      svint32_t prev_vec = svdup_n_s32(prev);\n      svbool_t lt = svcmpgt_s32(pg, prev_vec, current_vec);\n\n      if (svptest_any(pg, lt)) {\n        return false;\n      }\n\n      prev = row[j + svcntw() -1 ];\n      if (j + svcntw() > cols){\n          prev = row[cols-1];\n      }\n    }\n    for (size_t j = 1; j < cols; ++j) {\n        if (row[j] <= row[j-1])\n            return false;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    const int* row = matrix + i * cols;\n\n    svbool_t pg = svptrue_b32();\n    int32_t prev = row[0];\n\n    for (size_t j = 1; j < cols; j += svcntw()) {\n      svint32_t current = svld1_s32(pg, row + j);\n      svint32_t previous_vec = svdup_n_s32(prev);\n      svbool_t lt = svcmpgt_s32(pg, previous_vec, current);\n\n      if (svptest_any(pg, lt)) {\n        return false;\n      }\n\n      prev = row[j + svcntw() -1];\n      if (j + svcntw() > cols){\n          prev = row[cols-1];\n      }\n    }\n    for(size_t j = 1; j < cols; ++j){\n        if(row[j] <= row[j-1]){\n            return false;\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block\n    int* first_block = (int*)matrix;\n\n    // Compare other blocks with the first block\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            int* current_block = (int*)(matrix + i * block_size * cols + j * block_size);\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t vl = svcntw();\n                size_t col = 0;\n                for (; col < block_size - vl + 1; col += vl) {\n                    svbool_t pg = svwhilelt_b32(col, block_size);\n                    svint32_t first_vec = svld1_s32(pg, first_block + row * cols + col);\n                    svint32_t current_vec = svld1_s32(pg, current_block + row * cols + col);\n                    svbool_t neq = svcmpne_s32(pg, first_vec, current_vec);\n                    if (svptest_any(pg, neq)) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block\n    int* first_block = (int*)matrix;\n\n    // Compare other blocks with the first block\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            int* current_block = (int*)(matrix + i * block_size * cols + j * block_size);\n\n            // Compare the current block with the first block\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t vl = svcntw();\n                for (size_t col = 0; col < block_size; col += vl) {\n                    svbool_t pg = svwhilelt_b32(col, block_size);\n                    svint32_t first_vec = svld1_s32(pg, first_block + row * cols + col);\n                    svint32_t current_vec = svld1_s32(pg, current_block + row * cols + col);\n\n                    svbool_t neq = svcmpne_s32(pg, first_vec, current_vec);\n                    if (svptest_any(pg, neq)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block\n    int* first_block = (int*)matrix;\n\n    // Compare other blocks with the first block\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            int* current_block = (int*)(matrix + i * block_size * cols + j * block_size);\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t vl = svcntw();\n                size_t col = 0;\n                for (; col < block_size - vl + 1; col += vl) {\n                    svbool_t pg = svwhilelt_b32(col, block_size);\n                    svint32_t first_vec = svld1_s32(pg, first_block + row * cols + col);\n                    svint32_t current_vec = svld1_s32(pg, current_block + row * cols + col);\n                    svbool_t neq = svcmpne_s32(pg, first_vec, current_vec);\n                    if (svptest_any(pg, neq)) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block\n    int* first_block = (int*)matrix;\n\n    // Compare other blocks with the first block\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            int* current_block = (int*)(matrix + i * block_size * cols + j * block_size);\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t vl = svcntw();\n                size_t col = 0;\n                for (; col < block_size - vl + 1; col += vl) {\n                    svbool_t pg = svwhilelt_b32(col, block_size);\n                    svint32_t first_vec = svld1_s32(pg, first_block + row * cols + col);\n                    svint32_t current_vec = svld1_s32(pg, current_block + row * cols + col);\n                    svbool_t neq = svcmpne_s32(pg, first_vec, current_vec);\n                    if (svptest_any(pg, neq)) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block\n    int* first_block = (int*)matrix;\n\n    // Compare other blocks with the first block\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            int* current_block = (int*)(matrix + i * block_size * cols + j * block_size);\n\n            for (size_t row = 0; row < block_size; ++row) {\n                size_t vl = svcntw();\n                size_t col = 0;\n                for (; col < block_size - vl + 1; col += vl) {\n                    svbool_t pg = svwhilelt_b32(col, block_size);\n                    svint32_t first_vec = svld1_s32(pg, first_block + row * cols + col);\n                    svint32_t current_vec = svld1_s32(pg, current_block + row * cols + col);\n                    svbool_t neq = svcmpne_s32(pg, first_vec, current_vec);\n                    if (svptest_any(pg, neq)) {\n                        return false;\n                    }\n                }\n                for (; col < block_size; ++col) {\n                    if (first_block[row * cols + col] != current_block[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdio.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || tolerance < 0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    \n    double first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = vec[i];\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        svfloat64_t sv_first_block = svld1(pg, first_block);\n        svfloat64_t sv_current_block = svld1(pg, current_block);\n        svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, sv_first_block, sv_current_block));\n        svfloat64_t sv_tolerance = svdup_f64(tolerance);\n        svbool_t cmp = svcmplt_f64(pg, diff, sv_tolerance);\n\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdio.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n        svfloat64_t diff = svfabs(svsub(pg, current_block, first_block));\n        svbool_t compare = svcmplt_f64(pg, diff, tolerance);\n\n        if (!svptest_any(pg, compare)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdio.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n        svfloat64_t diff = svfabs(svsub(pg, current_block, first_block));\n        svbool_t compare = svcmplt_f64(pg, diff, tolerance);\n\n        if (!svptest_any(pg, compare)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdio.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n        svfloat64_t diff = svfabs(svsub(pg, current_block, first_block));\n        svbool_t compare = svcmplt_f64(pg, diff, tolerance);\n\n        if (!svptest_any(pg, compare)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdio.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n\n    if (block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n        svfloat64_t diff = svfabs(svsub(pg, current_block, first_block));\n        svbool_t compare = svcmplt_f64(pg, diff, tolerance);\n\n        if (!svptest_any(pg, compare)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; ++i) {\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j = 0;\n        for (; j < cols - (cols % vl); j += vl) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svfma_f64(sum, vec, vec);\n        }\n        for (; j < cols; ++j) {\n            sum = svfma_f64(sum, svdup_n_f64(matrix[i * cols + j]), svdup_n_f64(matrix[i * cols + j]));\n        }\n        double sum_scalar = svaddv_f64(svptrue_b64(), sum);\n        result[i] = (sum_scalar > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        size_t j = 0;\n\n        for (; j < cols - (svcntd() - 1); j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t matrix_vec = svld1(pg, &matrix[i * cols + j]);\n            sum_vec = svfma_f64(sum_vec, matrix_vec, matrix_vec);\n        }\n\n        double sum = svaddv_f64(sum_vec);\n\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; ++i) {\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j = 0;\n        for (; j < cols - (cols % vl); j += vl) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svfma_f64(sum, vec, vec);\n        }\n        for (; j < cols; ++j) {\n            sum = svfma_f64(sum, svdup_f64(matrix[i * cols + j]), svdup_f64(matrix[i * cols + j]));\n        }\n        double sum_scalar = svaddv_f64(svptrue_b64(), sum);\n        result[i] = (sum_scalar > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        size_t j = 0;\n\n        for (; j < cols - (svcntd() - 1); j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t matrix_vec = svld1(pg, &matrix[i * cols + j]);\n            sum_vec = svfma_f64(sum_vec, matrix_vec, matrix_vec);\n        }\n\n        double sum = svaddv_f64(sum_vec);\n\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; ++i) {\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j = 0;\n        for (; j < cols - (cols % vl); j += vl) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svfma_f64(sum, vec, vec);\n        }\n        for (; j < cols; ++j) {\n            sum = svfma_f64(sum, svdup_n_f64(matrix[i * cols + j]), svdup_n_f64(matrix[i * cols + j]));\n        }\n        double sum_scalar = svaddv_f64(svptrue_b64(), sum);\n        result[i] = (sum_scalar > (thresholds[i] * thresholds[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, length);\n\n  for (; i < length - svcntw(); i += svcntw()) {\n    pg = svwhilelt_b32(i, length);\n    svuint32_t a = svld1_u32(pg, A + i);\n    svuint32_t b = svld1_u32(pg, B + i);\n    svuint32_t result = sveor_u32(a, b);\n    svst1_u32(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    C[i] = A[i] | B[i];\n  }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, length);\n\n  for (; i < length - svcntw(); i += svcntw()) {\n    pg = svwhilelt_b32(i, length);\n    svuint32_t a = svld1_u32(pg, A + i);\n    svuint32_t b = svld1_u32(pg, B + i);\n    svuint32_t result = sveor_u32(a, b);\n    svst1_u32(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    C[i] = A[i] | B[i];\n  }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t a = svld1_u32(pg, &A[i]);\n        svuint32_t b = svld1_u32(pg, &B[i]);\n        svuint32_t result = sveor_u32(a, b);\n        svst1_u32(pg, &C[i], result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t a = svld1_u32(pg, &A[i]);\n        svuint32_t b = svld1_u32(pg, &B[i]);\n        svuint32_t result = sveor_u32(a, b);\n        svst1_u32(pg, &C[i], result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, length);\n\n  for (; i < length - svcntw(); i += svcntw()) {\n    pg = svwhilelt_b32(i, length);\n    svuint32_t a = svld1_u32(pg, A + i);\n    svuint32_t b = svld1_u32(pg, B + i);\n    svuint32_t result = sveor_u32(a, b);\n    svst1_u32(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    C[i] = A[i] | B[i];\n  }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  svbool_t pg = svwhilelt_b8(0, length);\n\n  const int8_t *a = A;\n  const int8_t *b = B;\n\n  while (svptest_any(pg, pg)) {\n    svint8_t va = svld1_s8(pg, a);\n    svint8_t vb = svld1_s8(pg, b);\n\n    svint16_t va16 = svwiden_s8_s16(va);\n    svint16_t vb16 = svwiden_s8_s16(vb);\n\n    svint32_t va32 = svwiden_s16_s32(va16);\n    svint32_t vb32 = svwiden_s16_s32(vb16);\n    \n    svint64_t va64 = svwiden_s32_s64(va32);\n    svint64_t vb64 = svwiden_s32_s64(vb32);\n\n    sum_sq += svsum_s64_x(svptrue_b64(), svmul_s64_x(svptrue_b64(), va64, va64));\n    sum_prod += svsum_s64_x(svptrue_b64(), svmul_s64_x(svptrue_b64(), va64, vb64));\n\n    a += svcntb();\n    b += svcntb();\n    length -= svcntb();\n    pg = svwhilelt_b8(0, length);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  svbool_t pg = svwhilelt_b8(0, length);\n  size_t i = 0;\n\n  for (; svptest_any(pg, pg); i += svcntb(), pg = svwhilelt_b8(i, length)) {\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint16_t a16 = svwiden_s8_s16(a);\n    svint16_t b16 = svwiden_s8_s16(b);\n\n    svint32_t a32 = svwiden_s16_s32(a16);\n    svint32_t b32 = svwiden_s16_s32(b16);\n    \n    svint64_t a64 = svwiden_s32_s64(a32);\n    svint64_t b64 = svwiden_s32_s64(b32);\n\n    sum_sq += svsum_s64_x(svptrue_b64(), svemul_s64(a64, a64), 0);\n    sum_prod += svsum_s64_x(svptrue_b64(), svemul_s64(a64, b64), 0);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  svbool_t pg = svwhilelt_b8((int8_t)0, (int8_t)length);\n  size_t i = 0;\n\n  while (svptest_any(pg, pg)) {\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint16_t a_wide = svwiden_s8_s16(a);\n    svint16_t b_wide = svwiden_s8_s16(b);\n\n    svint32_t a_wide2 = svwiden_s16_s32(a_wide);\n    svint32_t b_wide2 = svwiden_s16_s32(b_wide);\n\n    svint64_t a_wide3 = svwiden_s32_s64(a_wide2);\n    svint64_t b_wide3 = svwiden_s32_s64(b_wide2);\n    \n    sum_sq += svaddv_s64(pg, svemul_s64(a_wide3, a_wide3));\n    sum_prod += svaddv_s64(pg, svemul_s64(a_wide3, b_wide3));\n\n    i += svcntb();\n    pg = svwhilelt_b8((int8_t)i, (int8_t)length);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  svbool_t pg = svwhilelt_b8(0, length);\n  size_t i = 0;\n\n  while (svptest_any(pg, pg)) {\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint16_t a16 = svwiden_s8_s16(a);\n    svint16_t b16 = svwiden_s8_s16(b);\n\n    svint32_t a32 = svwiden_s16_s32(a16);\n    svint32_t b32 = svwiden_s16_s32(b16);\n\n    svint64_t a64 = svwiden_s32_s64(a32);\n    svint64_t b64 = svwiden_s32_s64(b32);\n    \n    svint64_t a_sq = svemul_s64(a64, a64);\n    svint64_t a_b = svemul_s64(a64, b64);\n\n    sum_sq += svaddv_s64(pg, a_sq);\n    sum_prod += svaddv_s64(pg, a_b);\n\n    i += svcntb();\n    pg = svwhilelt_b8(i, length);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n  int64_t sum_sq = 0;\n  int64_t sum_prod = 0;\n\n  svbool_t pg = svwhilelt_b8(0, length);\n\n  const int8_t *a = A;\n  const int8_t *b = B;\n\n  while (svptest_any(pg, pg)) {\n    svint8_t va = svld1_s8(pg, a);\n    svint8_t vb = svld1_s8(pg, b);\n\n    svint16_t va16 = svwiden_s8_s16(va);\n    svint16_t vb16 = svwiden_s8_s16(vb);\n\n    svint32_t va32 = svwiden_s16_s32(va16);\n    svint32_t vb32 = svwiden_s16_s32(vb16);\n    \n    svint64_t va64 = svwiden_s32_s64(va32);\n    svint64_t vb64 = svwiden_s32_s64(vb32);\n\n    sum_sq += svsum_s64_x(svptrue_b64(), svmul_s64_x(svptrue_b64(), va64, va64));\n    sum_prod += svsum_s64_x(svptrue_b64(), svmul_s64_x(svptrue_b64(), va64, vb64));\n\n    a += svcntb();\n    b += svcntb();\n    length -= svcntb();\n    pg = svwhilelt_b8(0, length);\n  }\n\n  return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b64(i, length);\n\n  for (; svptest_any(pg, pg); i += svcntd(), pg = svwhilelt_b64(i, length)) {\n    svuint64_t a = svld1_u64(pg, A + i);\n    svuint64_t b = svld1_u64(pg, B + i);\n    svuint64_t result = sveor_u64(a, svnot_u64(b));\n    svst1_u64(pg, C + i, result);\n  }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b64(i, length);\n\n  for (; svptest_first(pg, pg); i += svcntd()) {\n    pg = svwhilelt_b64(i, length);\n    svuint64_t a = svld1(pg, &A[i]);\n    svuint64_t b = svld1(pg, &B[i]);\n    svuint64_t result = sveor_u64(a, svnot_u64_x(pg, b));\n    svst1(pg, &C[i], result);\n  }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b64(i, length);\n\n  for (; svptest_first(pg, pg); i += svcntd()) {\n    pg = svwhilelt_b64(i, length);\n    svuint64_t a = svld1(pg, &A[i]);\n    svuint64_t b = svld1(pg, &B[i]);\n    svuint64_t result = sveor_u64(a, svnot_u64_x(pg, b));\n    svst1(pg, &C[i], result);\n  }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_u64(i, length);\n    svuint64_t a = svld1(pg, &A[i]);\n    svuint64_t b = svld1(pg, &B[i]);\n    svuint64_t not_b = svnot_u64(pg, b);\n    svuint64_t result = sveand_u64(pg, a, not_b);\n    svst1(pg, &C[i], result);\n  }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_u64(i, length);\n    svuint64_t a = svld1(pg, &A[i]);\n    svuint64_t b = svld1(pg, &B[i]);\n    svuint64_t not_b = svnot_u64(pg, b);\n    svuint64_t result = sveand_u64(pg, a, not_b);\n    svst1(pg, &C[i], result);\n  }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b8(i, length);\n\n  for (; i < length - svcntb() + 1; i += svcntb()) {\n    pg = svwhilelt_b8(i, length);\n\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint8_t pos_mask_a = svcmgt_s8(pg, a, 0);\n    svint8_t pos_mask_b = svcmgt_s8(pg, b, 0);\n    svint8_t neg_mask_a = svcmplt_s8(pg, a, 0);\n    svint8_t neg_mask_b = svcmplt_s8(pg, b, 0);\n\n    svint8_t result = svdup_s8(0);\n    result = svsel_s8(svand_z(pg, pos_mask_a, pos_mask_b, pg), svdup_s8(1), result);\n    result = svsel_s8(svand_z(pg, neg_mask_a, neg_mask_b, pg), svdup_s8(-1), result);\n\n    svst1_s8(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b8(i, length);\n\n  for (; i < length - svcntb(); i += svcntb()) {\n    pg = svwhilelt_b8(i, length);\n\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint8_t result = svdup_s8(0);\n\n    svbool_t both_positive = svand_b8(svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n    svbool_t both_negative = svand_b8(svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n\n    result = svsel_s8(both_positive, svdup_s8(1), result);\n    result = svsel_s8(both_negative, svdup_s8(-1), result);\n\n    svst1_s8(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b8(i, length);\n\n  for (; i < length - svcntb(); i += svcntb()) {\n    pg = svwhilelt_b8(i, length);\n\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint8_t pos_mask_a = svcmgt_s8(pg, a, 0);\n    svint8_t pos_mask_b = svcmgt_s8(pg, b, 0);\n    svint8_t neg_mask_a = svcmplt_s8(pg, a, 0);\n    svint8_t neg_mask_b = svcmplt_s8(pg, b, 0);\n\n    svint8_t result = svdup_s8(0);\n    result = svsel_s8(svand_b8(pos_mask_a, pos_mask_b), svdup_s8(1), result);\n    result = svsel_s8(svand_b8(neg_mask_a, neg_mask_b), svdup_s8(-1), result);\n\n    svst1_s8(pg, C + i, result);\n  }\n\n  for (; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b8(i, length);\n\n  for (; svptest_any(pg, pg); i += svcntb(), pg = svwhilelt_b8(i, length)) {\n    svint8_t a = svld1_s8(pg, A + i);\n    svint8_t b = svld1_s8(pg, B + i);\n\n    svint8_t pos_mask_a = svcmpgt_s8(pg, a, 0);\n    svint8_t pos_mask_b = svcmpgt_s8(pg, b, 0);\n    svint8_t neg_mask_a = svcmplt_s8(pg, a, 0);\n    svint8_t neg_mask_b = svcmplt_s8(pg, b, 0);\n\n    svint8_t result = svdup_s8(0);\n    result = svsel_s8(svand_z(pg, pos_mask_a, pos_mask_b), svdup_s8(1), result);\n    result = svsel_s8(svand_z(pg, neg_mask_a, neg_mask_b), svdup_s8(-1), result);\n\n    svst1_s8(pg, C + i, result);\n  }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t a = svld1_u8(pg, A + i);\n        svint8_t b = svld1_u8(pg, B + i);\n\n        svbool_t pos_a = svcmpeq_b8(a, svdup_n_u8(1)); // Check if A is positive\n        svbool_t pos_b = svcmpeq_b8(b, svdup_n_u8(1)); // Check if B is positive\n        svbool_t neg_a = svcmpeq_b8(a, svdup_n_u8(-1)); // Check if A is negative\n        svbool_t neg_b = svcmpeq_b8(b, svdup_n_u8(-1)); // Check if B is negative\n\n        svint8_t result = svdup_n_u8(0); // Default result is 0\n        result = svsel(pg, svdup_n_u8(1), svand_b8(pg, pos_a, pos_b)); // Set to 1 where both are positive\n        result = svsel(pg, svdup_n_u8(-1), svand_b8(pg, neg_a, neg_b)); // Set to -1 where both are negative\n\n        svst1_u8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b16(i, midpoint);\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, midpoint)) {\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = sveor_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    i = midpoint + 1;\n    if (i < length) {\n        pg = svwhilelt_b16(i, length);\n        for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n            svuint16_t a = svld1_u16(pg, A + i);\n            svuint16_t b = svld1_u16(pg, B + i);\n            svuint16_t result = svand_u16(pg, a, b);\n            svst1_u16(pg, C + i, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = svcntw();\n    size_t i = 0;\n\n    // Process elements before the midpoint using SVE\n    for (; i < midpoint - (midpoint % vector_length); i += vector_length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), svdup_u32(midpoint));\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = sveor_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    // Process remaining elements before the midpoint (if any)\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Copy the element at the midpoint\n    if (length > 0){\n        C[midpoint] = A[midpoint];\n    }\n    \n\n    // Process elements after the midpoint using SVE\n    i = midpoint + 1;\n    for (; i < length - ((length - midpoint - 1) % vector_length); i += vector_length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), svdup_u32(length));\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = svand_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    // Process remaining elements after the midpoint (if any)\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = svcntw();\n    size_t i = 0;\n\n    // Process elements before the midpoint using SVE\n    for (; i < midpoint - (midpoint % vector_length); i += vector_length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), svdup_u32(midpoint));\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = sveor_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    // Process remaining elements before the midpoint (if any)\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Process the element at the midpoint\n    if (length > 0){\n        C[midpoint] = A[midpoint];\n    }\n    \n\n    // Process elements after the midpoint using SVE\n    i = midpoint + 1;\n    for (; i < length - ((length - midpoint - 1) % vector_length); i += vector_length) {\n        svbool_t pg = svwhilelt_b16(svindex_u32(i, 1), svdup_u32(length));\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = svand_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    // Process remaining elements after the midpoint (if any)\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b16(i, midpoint);\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, midpoint)) {\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = sveor_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    i = midpoint + 1;\n    if (i < length) {\n        pg = svwhilelt_b16(i, length);\n        for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n            svuint16_t a = svld1_u16(pg, A + i);\n            svuint16_t b = svld1_u16(pg, B + i);\n            svuint16_t result = svand_u16(pg, a, b);\n            svst1_u16(pg, C + i, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b16(i, midpoint);\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, midpoint)) {\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result = sveor_u16(pg, a, b);\n        svst1_u16(pg, C + i, result);\n    }\n\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    i = midpoint + 1;\n    if (i < length) {\n        pg = svwhilelt_b16(i, length);\n        for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b16(i, length)) {\n            svuint16_t a = svld1_u16(pg, A + i);\n            svuint16_t b = svld1_u16(pg, B + i);\n            svuint16_t result = svand_u16(pg, a, b);\n            svst1_u16(pg, C + i, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        svbool_t cond1_vec = svld1_b8(pg, cond1 + i);\n        svbool_t cond2_vec = svld1_b8(pg, cond2 + i);\n\n        svbool_t select_a_mask = svand_z(pg, cond1_vec, cond2_vec);\n        svbool_t select_b_mask = svand_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t select_c_mask = svand_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t select_d_mask = svand_z(pg, svnot_b_z(pg, cond1_vec), svnot_b_z(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(select_a_mask, a, svsel_f32(select_b_mask, b, svsel_f32(select_c_mask, c, d)));\n\n        svst1_f32(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        svbool_t cond1_vec = svld1_b8(pg, cond1 + i);\n        svbool_t cond2_vec = svld1_b8(pg, cond2 + i);\n\n        svbool_t select_a_mask = svand_z(pg, cond1_vec, cond2_vec);\n        svbool_t select_b_mask = svand_z(pg, cond1_vec, svnot_b(pg, cond2_vec));\n        svbool_t select_c_mask = svand_z(pg, svnot_b(pg, cond1_vec), cond2_vec);\n        svbool_t select_d_mask = svand_z(pg, svnot_b(pg, cond1_vec), svnot_b(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(select_a_mask, a, svsel_f32(select_b_mask, b, svsel_f32(select_c_mask, c, d)));\n\n        svst1_f32(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        svbool_t c1 = svld1_b8(pg, cond1 + i);\n        svbool_t c2 = svld1_b8(pg, cond2 + i);\n\n        svbool_t select_a = svand_b8(c1, c2);\n        svbool_t select_b = svand_b8(c1, svnot_b8(c2));\n        svbool_t select_c = svand_b8(svnot_b8(c1), c2);\n        svbool_t select_d = svand_b8(svnot_b8(c1), svnot_b8(c2));\n\n        svfloat32_t result = svsel_f32(select_a, a, svsel_f32(select_b, b, svsel_f32(select_c, c, d)));\n\n        svst1_f32(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        svbool_t c1 = svld1_b8(pg, cond1 + i);\n        svbool_t c2 = svld1_b8(pg, cond2 + i);\n\n        svbool_t and_mask = svand_b8(c1, c2);\n        svfloat32_t res = svsel_f32(and_mask, a, d);\n\n        svbool_t c1_and_not_c2 = svand_b8(c1, svnot_b8(c2));\n        res = svsel_f32(c1_and_not_c2, b, res);\n\n        svbool_t not_c1_and_c2 = svand_b8(svnot_b8(c1), c2);\n        res = svsel_f32(not_c1_and_c2, c, res);\n\n        svst1_f32(pg, out + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        svbool_t c1 = svld1_b8(pg, cond1 + i);\n        svbool_t c2 = svld1_b8(pg, cond2 + i);\n\n        svbool_t select_a = svand_z(pg, c1, c2);\n        svbool_t select_b = svand_z(pg, c1, svnot_b_z(pg, c2));\n        svbool_t select_c = svand_z(pg, svnot_b_z(pg, c1), c2);\n        svbool_t select_d = svand_z(pg, svnot_b_z(pg, c1), svnot_b_z(pg, c2));\n\n        svfloat32_t result = svsel_f32(select_a, a, svsel_f32(select_b, b, svsel_f32(select_c, c, d)));\n\n        svst1_f32(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_iterations = total_elements;\n\n  svuint32_t ones = svdup_u32(1);\n\n  for (size_t i = 0; i < loop_iterations; ) {\n    svbool_t pg = svwhilelt_b32(i, loop_iterations);\n    svuint32_t a = svld1_u32(pg, &A[i]);\n    svuint8_t cnt = svcntb_u8(a);\n    svst1_u8(pg, &out[i], cnt);\n    i += svcntw();\n  }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_iterations = total_elements;\n\n  svuint32_t ones = svdup_u32(1);\n\n  for (size_t i = 0; i < loop_iterations; ) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svuint32_t a = svld1_u32(pg, &A[i]);\n    svuint8_t cnt = svcntb_u8(a);\n    svst1_u8(pg, &out[i], cnt);\n    i += svcntw();\n  }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t vector_length = svcntw();\n\n  for (size_t i = 0; i < total_elements; i += vector_length) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svuint32_t sv_a = svld1_u32(pg, &A[i]);\n    svuint64_t sv_count = svdup_u64(0);\n\n    for (int j = 0; j < 32; ++j) {\n      svuint32_t shifted = svlsr_n_u32(sv_a, 1);\n      svuint32_t bit = sveor_u32(sv_a, svmul_n_u32(shifted, 2));\n      sv_count = svadd_u64(sv_count, svcvt_u64_u32(bit));\n      sv_a = shifted;\n    }\n\n    svst1_u8(pg, &out[i], svcvt_u8_u64(sv_count));\n  }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_iterations = total_elements;\n\n  svuint32_t ones = svdup_u32(1);\n\n  for (size_t i = 0; i < loop_iterations; ) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svuint32_t a = svld1_z(pg, &A[i]);\n    svuint8_t cnt = svcntb_u8(a);\n    svst1_z(pg, &out[i], cnt);\n\n    size_t vl = svcntw();\n    i += vl;\n  }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n  size_t total_elements = dim1 * dim2 * dim3;\n  size_t loop_iterations = total_elements;\n\n  svuint32_t ones = svdup_u32(1);\n\n  for (size_t i = 0; i < loop_iterations; ) {\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svuint32_t a = svld1_u32(pg, &A[i]);\n    svuint8_t cnt = svcntb_u32(a);\n    svst1_u8(pg, &out[i], cnt);\n    i += svcntw();\n  }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n  size_t total_elements = rows * cols;\n  size_t loop_iterations = total_elements;\n  size_t current_element = 0;\n\n  while (loop_iterations > 0) {\n    svbool_t pg = svwhilelt_b32(current_element, total_elements);\n    svint32_t a = svld1_s32(pg, &A[current_element]);\n\n    svint32_t remainder = svand_n_s32_m(pg, a, 2);\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 4));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 8));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 16));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 32));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 64));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 128));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 256));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 512));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 1024));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 2048));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 4096));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 8192));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 16384));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 32768));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 65536));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 131072));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 262144));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 524288));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 1048576));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 2097152));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 4194304));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 8388608));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 16777216));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 33554432));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 67108864));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 134217728));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 268435456));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 536870912));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, 1073741824));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n    remainder = svadd_n_s32_m(pg, remainder, svand_n_s32_m(pg, a, -2147483648));\n    remainder = svand_n_s32_m(pg, remainder, 1);\n\n    svbool_t divisible_by_3 = svcmpeq_n_s32(pg, remainder, 0);\n\n    svint32_t abs_a = svabs_s32_m(divisible_by_3, a);\n\n    svint32_t result = svsel_s32(divisible_by_3, abs_a, a);\n\n    svst1_s32(pg, &B[current_element], result);\n\n    current_element += svcntw();\n    loop_iterations -= svcntw();\n  }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t loop_iterations = total_elements / svcntw();\n    size_t remainder = total_elements % svcntw();\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t a = svld1_s32(pg, A + i * svcntw());\n        svint32_t mod = svand_n_s32_x(pg, a, 2);\n        svint32_t cmp = sveq_n_s32(pg, mod, 0);\n        svint32_t abs_a = svabs_s32_x(cmp, a);\n        svst1_s32(pg, B + i * svcntw(), abs_a);\n    }\n\n    if (remainder > 0) {\n        svbool_t pg = svwhilelt_b32(0, remainder);\n        svint32_t a = svld1_s32(pg, A + loop_iterations * svcntw());\n        svint32_t mod = svand_n_s32_x(pg, a, 2);\n        svint32_t cmp = sveq_n_s32(pg, mod, 0);\n        svint32_t abs_a = svabs_s32_x(cmp, a);\n        svst1_s32(pg, B + loop_iterations * svcntw(), abs_a);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t loop_iterations = total_elements / svcntw();\n    size_t remaining_elements = total_elements % svcntw();\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t a = svld1_s32(pg, A + i * svcntw());\n        svint32_t mod = svand_n_s32_x(pg, a, 3 - 1);\n        svbool_t divisible_by_3 = sveq_n_s32(pg, mod, 0);\n        svint32_t abs_a = svabs_s32_x(divisible_by_3, a);\n        svsel_s32_x(pg, divisible_by_3, abs_a, a);\n        svst1_s32(pg, B + i * svcntw(), svsel_s32_x(pg, divisible_by_3, abs_a, a));\n    }\n\n    if (remaining_elements > 0) {\n        svbool_t pg = svwhilelt_b32(0, remaining_elements);\n        svint32_t a = svld1_s32(pg, A + loop_iterations * svcntw());\n        svint32_t mod = svand_n_s32_x(pg, a, 3 - 1);\n        svbool_t divisible_by_3 = sveq_n_s32(pg, mod, 0);\n        svint32_t abs_a = svabs_s32_x(divisible_by_3, a);\n        svst1_s32(pg, B + loop_iterations * svcntw(), svsel_s32_x(pg, divisible_by_3, abs_a, a));\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t loop_iterations = total_elements / svcntw();\n    size_t remainder = total_elements % svcntw();\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t a = svld1_s32(pg, A + i * svcntw());\n        svint32_t divisible = svand_n_s32_x(pg, a, 2);\n        svbool_t condition = sveq_n_s32(pg, divisible, 0);\n        svint32_t abs_a = svabs_s32_x(condition, a);\n        svsel_s32(condition, abs_a, a);\n        svst1_s32(pg, B + i * svcntw(), svsel_s32(condition, abs_a, a));\n    }\n\n    if (remainder > 0) {\n        svbool_t pg = svptrue_b32();\n        if(loop_iterations > 0){\n            pg = svwhilelt_b32((uint32_t)(total_elements - remainder), (uint32_t)total_elements);\n        } else {\n            pg = svwhilelt_b32((uint32_t)0, (uint32_t)remainder);\n        }\n        svint32_t a = svld1_s32(pg, A + loop_iterations * svcntw());\n        svint32_t divisible = svand_n_s32_x(pg, a, 2);\n        svbool_t condition = sveq_n_s32(pg, divisible, 0);\n        svint32_t abs_a = svabs_s32_x(condition, a);\n        svst1_s32(pg, B + loop_iterations * svcntw(), svsel_s32(condition, abs_a, a));\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t loop_iterations = total_elements / svcntw();\n    size_t remainder = total_elements % svcntw();\n\n    for (size_t i = 0; i < loop_iterations; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t a = svld1_s32(pg, A + i * svcntw());\n        svint32_t divisible = svand_n_s32_x(pg, a, 2);\n        svbool_t condition = sveq_n_s32(pg, divisible, 0);\n        svint32_t abs_a = svabs_s32_x(condition, a);\n        svsel_s32(condition, abs_a, a);\n        svst1_s32(pg, B + i * svcntw(), svsel_s32(condition, abs_a, a));\n    }\n\n    if (remainder > 0) {\n        svbool_t pg = svptrue_b32();\n        if (loop_iterations > 0) {\n            pg = svwhilelt_b32((uint32_t)(total_elements - remainder), (uint32_t)total_elements);\n        } else {\n            pg = svwhilelt_b32((uint32_t)0, (uint32_t)remainder);\n        }\n        svint32_t a = svld1_s32(pg, A + loop_iterations * svcntw());\n        svint32_t divisible = svand_n_s32_x(pg, a, 2);\n        svbool_t condition = sveq_n_s32(pg, divisible, 0);\n        svint32_t abs_a = svabs_s32_x(condition, a);\n        svst1_s32(pg, B + loop_iterations * svcntw(), svsel_s32(condition, abs_a, a));\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        svuint32_t low_bits = svand_u32_x(pg, src_vec, svdup_u32(15));\n        svbool_t condition = sveq_u32_x(pg, low_bits, svdup_u32(15));\n\n        svuint32_t rotated_vec = svror_n_u32_x(condition, src_vec, rotate_bits);\n        svuint32_t negated_vec = sveor_n_u32_x(svnot_b_z(pg, condition), src_vec, -1);\n\n        svst1_u32(pg, &dst[i], svsel_u32(condition, rotated_vec, negated_vec));\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        svuint32_t low_bits = svand_u32_x(pg, src_vec, svdup_u32(15));\n        svbool_t condition = sveq_u32(pg, low_bits, svdup_u32(15));\n\n        svuint32_t rotated_vec = svrta_u32_x(pg, src_vec, rotate_bits);\n        svuint32_t negated_vec = sveor_n_u32_x(pg, src_vec, -1);\n\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n\n        svst1_u32(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svuint32_t mask = svdup_u32(0x0F); // Mask for low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Mask for rotation\n\n    for (i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb(); // Vector length\n        vec_src = svld1_u32(&src[i]); // Load source vector\n\n        // Check if low 4 bits are all 1\n        svbool_t cond = svcmpeq_u32(svand_u32(vec_src, mask), mask);\n\n        // Perform rotation or negation based on condition\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, svdup_n_u32(rotate_bits)), svshl_u32(vec_src, svdup_n_u32(32 - rotate_bits)));\n        vec_dst = svsel_u32(cond, rotated, svnot_u32(vec_src));\n\n        svst1_u32(&dst[i], vec_dst); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svuint32_t mask = svdup_u32(0x0F); // Mask for low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Rotate mask\n    svuint32_t rotate_amount = svdup_u32(32 - rotate_bits); // Amount to rotate\n\n    for (i = 0; i < length; i += svcntb()) {\n        // Load source vector\n        vec_src = svld1_u32(&src[i]);\n\n        // Check if low 4 bits are all 1\n        svbool_t cond = svand_u32(svcmpeq_u32(vec_src, svdup_u32(0xFFFFFFFF)), mask);\n        \n        // Perform rotation or negation based on condition\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, rotate_amount), svand_u32(vec_src, rotate_mask));\n        vec_dst = svsel_u32(cond, rotated, svnot_u32(vec_src));\n\n        // Store result\n        svst1_u32(&dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svuint32_t mask = svdup_u32(0xF); // Mask for low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Mask for rotation\n    svuint32_t rotate_amount = svdup_u32(32 - rotate_bits); // Amount to rotate\n\n    for (i = 0; i < length; i += svcntw()) {\n        // Load source vector\n        vec_src = svld1_u32(&src[i]);\n\n        // Check if low 4 bits are all 1\n        svbool_t cond = svcmpeq_u32(svand_u32(vec_src, mask), mask);\n\n        // Perform rotation or negation based on condition\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, rotate_amount), svand_u32(vec_src, rotate_mask));\n        vec_dst = svsel(cond, rotated, svnot_u32(vec_src));\n\n        // Store result\n        svst1_u32(&dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32_t epsilon_vec = svdup_f32(epsilon);\n    float32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        float32_t a_vec = svld1_f32(&A[i]);\n        float32_t b_vec = svld1_f32(&B[i]);\n        \n        float32_t diff_vec = svsub_f32(a_vec, b_vec);\n        float32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        uint32_t cmp_gt_vec = svcmpeq_f32(abs_diff_vec, epsilon_vec);\n        uint32_t cmp_lt_vec = svcmpeq_f32(abs_diff_vec, neg_epsilon_vec);\n        \n        int8_t result_vec = svdup_n_s8(0);\n        result_vec = svorr_s8(result_vec, svand_s8(svdup_n_s8(1), cmp_gt_vec));\n        result_vec = svorr_s8(result_vec, svand_s8(svdup_n_s8(-1), cmp_lt_vec));\n        \n        svst1_s8(&out[i], result_vec);\n    }\n    \n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        \n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        svint32_t result = svdup_n_s32(0);\n        result = svorr_s32(result, svcmpeq_f32(diff_vec, svdup_f32(0)), svdup_n_s32(0)); // abs(A[i] - B[i]) <= abs(epsilon)\n        result = svorr_s32(result, svcmplt_f32(diff_vec, neg_epsilon_vec), svdup_n_s32(-1)); // A[i] - B[i] < -abs(epsilon)\n        result = svorr_s32(result, svcmpgt_f32(diff_vec, epsilon_vec), svdup_n_s32(1)); // A[i] - B[i] > abs(epsilon)\n\n        svint8_t out_vec = svreinterpret_s8_s32(result);\n        svst1_s8(&out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        \n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        svint8_t result = svdup_n_s8(0);\n        \n        svbool_t gt_vec = svcmpeq_f32(svabs_f32(diff_vec), epsilon_vec);\n        svbool_t lt_vec = svcmpeq_f32(svabs_f32(diff_vec), neg_epsilon_vec);\n        \n        result = svsel(gt_vec, svdup_n_s8(1), result);\n        result = svsel(lt_vec, svdup_n_s8(-1), result);\n        \n        svst1_s8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32_t epsilon_vec = svdup_f32(epsilon);\n    float32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        unsigned int vl = svcntw();\n        float32_t a_vec = svld1_f32(&A[i]);\n        float32_t b_vec = svld1_f32(&B[i]);\n        \n        float32_t diff_vec = svsub_f32(a_vec, b_vec);\n        float32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        uint32_t greater_vec = svwhilelt_b32(0, svcmpgt_f32(diff_vec, epsilon_vec));\n        uint32_t less_vec = svwhilelt_b32(0, svcmplt_f32(diff_vec, neg_epsilon_vec));\n        \n        int8_t result_vec = svdup_n_s8(0);\n        result_vec = svorr_s8(result_vec, svreinterpret_s8(greater_vec), svdup_n_s8(1));\n        result_vec = svorr_s8(result_vec, svreinterpret_s8(less_vec), svdup_n_s8(-1));\n        \n        svst1_f8(&out[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32_t epsilon_vec = svdup_f32(epsilon);\n    float32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        unsigned int vl = svcntw();\n        float32_t a_vec = svld1_f32(&A[i]);\n        float32_t b_vec = svld1_f32(&B[i]);\n        \n        float32_t diff_vec = svsub_f32(a_vec, b_vec);\n        float32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        uint32_t greater_vec = svcmpeq_f32(abs_diff_vec, epsilon_vec);\n        uint32_t less_vec = svcmpeq_f32(abs_diff_vec, neg_epsilon_vec);\n        \n        int8_t result_vec = svdup_n_s8(0);\n        result_vec = svorr_s8(result_vec, svand_s8(svdup_n_s8(1), svdup_n_u8(greater_vec)));\n        result_vec = svorr_s8(result_vec, svand_s8(svdup_n_s8(-1), svdup_n_u8(less_vec)));\n        \n        svst1_s8(&out[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (; svptest_any(pg, pg); A += svcntw(), B += svcntw(), size -= svcntw()) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t result = svcvt_s32_f32_sat(pg, a);\n        svst1_s32(pg, B, result);\n        pg = svwhilelt_b32(0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        svfloat32_t sv_a = svld1_f32(pg, &A[i]);\n\n        svint32_t sv_int_max = svdupq_n_s32(INT32_MAX);\n        svint32_t sv_int_min = svdupq_n_s32(INT32_MIN);\n\n        svint32_t sv_b = svcvt_s32_f32_x(pg, sv_a);\n\n        svbool_t pg_gt_max = svcmpgt_f32(pg, sv_a, (float)INT32_MAX);\n        svbool_t pg_lt_min = svcmplt_f32(pg, sv_a, (float)INT32_MIN);\n\n        sv_b = svsel_s32(pg_gt_max, sv_int_max, sv_b);\n        sv_b = svsel_s32(pg_lt_min, sv_int_min, sv_b);\n\n        svst1_s32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (; svptest_any(pg, pg); A += svcntw(), B += svcntw(), size -= svcntw()) {\n        svfloat32_t a = svld1(pg, A);\n        svint32_t b = svcvt_s32_f32(a);\n\n        svint32_t max_val = svdup_n_s32(INT32_MAX);\n        svint32_t min_val = svdup_n_s32(INT32_MIN);\n\n        svbool_t overflow_mask = svcmpgt_f32(pg, a, svcvt_f32_s32(max_val));\n        svbool_t underflow_mask = svcmplt_f32(pg, a, svcvt_f32_s32(min_val));\n\n        b = svsel(overflow_mask, max_val, b);\n        b = svsel(underflow_mask, min_val, b);\n\n        svst1(pg, B, b);\n\n        pg = svwhilelt_b32(0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, size);\n    svfloat32_t a = svld1_f32(pg, &A[i]);\n    svint32_t b = svcvt_s32_f32_sat(pg, a);\n    svst1_s32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (; svptest_first(pg, pg); A += svcntw(), B += svcntw(), size -= svcntw()) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t b = svcvt_s32_f32_sat(pg, a);\n        svst1_s32(pg, B, b);\n        pg = svwhilelt_b32(0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    int64_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svint32_t sv_a = svld1_s32(pg, &A[i]);\n        svfloat32_t sv_b = svcvt_f32_s32(sv_a);\n        sv_b = svmul_n_f32(pg, sv_b, (float)scale);\n        svst1_f32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    int64_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svint32_t sv_a = svld1_s32(pg, &A[i]);\n        svfloat32_t sv_b = svcvt_f32_s32(sv_a);\n        sv_b = svmul_n_f32(pg, sv_b, (float)scale);\n        svst1_f32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    int64_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svint32_t sv_a = svld1_s32(pg, &A[i]);\n        svfloat32_t sv_b = svcvt_f32_s32(sv_a);\n        sv_b = svmul_n_f32(pg, sv_b, (float)scale);\n        svst1_f32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    int64_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svint32_t sv_a = svld1_s32(pg, &A[i]);\n        svfloat32_t sv_b = svcvt_f32_s32(sv_a);\n        sv_b = svmul_n_f32(pg, sv_b, (float)scale);\n        svst1_f32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    int64_t i = 0;\n\n    for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svint32_t sv_a = svld1_s32(pg, &A[i]);\n        svfloat32_t sv_b = svcvt_f32_s32(sv_a);\n        sv_b = svmul_n_f32(pg, sv_b, (float)scale);\n        svst1_f32(pg, &B[i], sv_b);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, size);\n\n  while (svptest_first(pg)) {\n    svfloat32_t a = svld1(pg, &A[i]);\n    svfloat32_t b = svld1(pg, &B[i]);\n    svfloat32_t div_result = svdiv_f32(pg, a, b);\n    svint32_t rounded_result = svrintn_s32_f32(pg, div_result);\n    svst1(pg, &C[i], rounded_result);\n\n    i += svcntw();\n    pg = svwhilelt_b32(i, size);\n  }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(pg, pg)) {\n        svfloat32_t a = svld1(pg, &A[i]);\n        svfloat32_t b = svld1(pg, &B[i]);\n        svfloat32_t div_result = svdiv_f32(a, b);\n        svint32_t rounded_result = svrinta_s32_f32(pg, div_result);\n        svst1(pg, &C[i], rounded_result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, size);\n\n  while (svptest_first(pg)) {\n    svfloat32_t a = svld1(pg, &A[i]);\n    svfloat32_t b = svld1(pg, &B[i]);\n    svfloat32_t div_result = svdiv_f32(a, b);\n    svint32_t rounded_result = svrinta_s32_f32(pg, div_result);\n    svst1(pg, &C[i], rounded_result);\n\n    i += svcntw();\n    pg = svwhilelt_b32(i, size);\n  }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, size);\n\n  while (svptest_first(pg)) {\n    svfloat32_t a = svld1(pg, &A[i]);\n    svfloat32_t b = svld1(pg, &B[i]);\n    svfloat32_t div_result = svdiv_f32(a, b);\n    svint32_t rounded_result = svrinta_s32_f32(pg, div_result);\n    svst1(pg, &C[i], rounded_result);\n\n    i += svcntw();\n    pg = svwhilelt_b32(i, size);\n  }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n  size_t i = 0;\n  svbool_t pg = svwhilelt_b32(i, size);\n\n  while (svptest_any(pg, pg)) {\n    svfloat32_t a = svld1(pg, &A[i]);\n    svfloat32_t b = svld1(pg, &B[i]);\n    svfloat32_t div_result = svdiv_f32(pg, a, b);\n    svint32_t rounded_result = svrintn_s32_f32(pg, div_result);\n    svst1(pg, &C[i], rounded_result);\n\n    i += svcntw();\n    pg = svwhilelt_b32(i, size);\n  }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b64((int64_t)i, (int64_t)size);\n    svfloat64_t a = svld1_f64(pg, &A[i]);\n    svfloat32_t b = svcvt_f32_f64(a);\n    svfloat32_t max_val = svdup_f32(FLT_MAX);\n    svfloat32_t min_val = svdup_f32(-FLT_MAX);\n    svbool_t greater_than_max = svcmpgt_f64(pg, a, svdup_f64((double)FLT_MAX));\n    svbool_t less_than_min = svcmplt_f64(pg, a, svdup_f64((double)-FLT_MAX));\n    b = svsel_f32(greater_than_max, max_val, b);\n    b = svsel_f32(less_than_min, min_val, b);\n    svst1_f32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b64((int64_t)i, (int64_t)size);\n    svfloat64_t a = svld1_f64(pg, &A[i]);\n    svfloat32_t b = svcvt_f32_f64(a);\n    svfloat32_t max_val = svdup_f32(FLT_MAX);\n    svfloat32_t min_val = svdup_f32(-FLT_MAX);\n    svbool_t greater_than_max = svcmpgt_f64(pg, a, svdup_f64((double)FLT_MAX));\n    svbool_t less_than_min = svcmplt_f64(pg, a, svdup_f64((double)-FLT_MAX));\n    b = svsel_f32(greater_than_max, max_val, b);\n    b = svsel_f32(less_than_min, min_val, b);\n    svst1_f32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b64((int64_t)i, (int64_t)size);\n    svfloat64_t a = svld1_f64(pg, &A[i]);\n    svfloat32_t b = svcvt_f32_f64(a);\n    svfloat32_t max_val = svdup_f32(FLT_MAX);\n    svfloat32_t min_val = svdup_f32(-FLT_MAX);\n    svbool_t greater_than_max = svcmpgt_f64(pg, a, svdup_f64((double)FLT_MAX));\n    svbool_t less_than_min = svcmplt_f64(pg, a, svdup_f64((double)-FLT_MAX));\n    b = svsel_f32(greater_than_max, max_val, b);\n    b = svsel_f32(less_than_min, min_val, b);\n    svst1_f32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b64((int64_t)i, (int64_t)size);\n    svfloat64_t a = svld1_f64(pg, &A[i]);\n    svfloat32_t b = svcvt_f32_f64(a);\n    svfloat32_t max_val = svdup_f32(FLT_MAX);\n    svfloat32_t min_val = svdup_f32(-FLT_MAX);\n    svbool_t greater_than_max = svcmpgt_f64(pg, a, svdup_f64((double)FLT_MAX));\n    svbool_t less_than_min = svcmplt_f64(pg, a, svdup_f64((double)-FLT_MAX));\n    b = svsel_f32(greater_than_max, max_val, b);\n    b = svsel_f32(less_than_min, min_val, b);\n    svst1_f32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n  size_t vl = svcntd();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b64((int64_t)i, (int64_t)size);\n    svfloat64_t a = svld1_f64(pg, &A[i]);\n    svfloat32_t b = svcvt_f32_f64(a);\n    svfloat32_t max_val = svdup_f32(FLT_MAX);\n    svfloat32_t min_val = svdup_f32(-FLT_MAX);\n    svbool_t greater_than_max = svcmpgt_f64(pg, a, svdup_f64((double)FLT_MAX));\n    svbool_t less_than_min = svcmplt_f64(pg, a, svdup_f64((double)-FLT_MAX));\n    b = svsel_f32(greater_than_max, max_val, b);\n    b = svsel_f32(less_than_min, min_val, b);\n    svst1_f32(pg, &B[i], b);\n  }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b16(i, size);\n    svint16_t a = svld1_s16(pg, A + i);\n    svint32_t b = svcvt_s32_s16(a);\n    svst1_s32(pg, B + i, b);\n  }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b16(i, size);\n    svint16_t a = svld1_s16(pg, A + i);\n    svint32_t b = svcvt_s32_s16(a);\n    svst1_s32(pg, B + i, b);\n  }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b16(i, size);\n    svint16_t a = svld1_s16(pg, A + i);\n    svint32_t b = svcvt_s32_s16(a);\n    svst1_s32(pg, B + i, b);\n  }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < size; i += vl) {\n    svbool_t pg = svwhilelt_b16(i, size);\n    svint16_t a = svld1_s16(pg, A + i);\n    svint32_t b = svcvt_s32_s16(a);\n    svst1_s32(pg, B + i, b);\n  }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n  size_t i = 0;\n  while (i < size) {\n    svbool_t pg = svwhilelt_b16(i, size);\n    svint16_t a = svld1_s16(pg, A + i);\n    svint32_t b = svcvt_s32_s16(a);\n    svst1_s32(pg, B + i, b);\n    i += svcntw();\n  }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t range = max_val - min_val;\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n        svfloat32_t A_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t B_vec;\n\n        svbool_t cond_pos = svcmpgt_s32(pg, control_vec, 0);\n\n        if (svptest_any(pg, cond_pos)) {\n            svfloat32_t temp_vec = svsub_f32(A_vec, min_vec);\n            temp_vec = svdiv_f32(temp_vec, range_vec);\n            temp_vec = svmax_f32(temp_vec, zero_vec);\n            temp_vec = svmin_f32(temp_vec, one_vec);\n            B_vec = svsel_f32(cond_pos, temp_vec, A_vec);\n        } else {\n            B_vec = A_vec;\n        }\n        \n        svst1_f32(pg, &B[i], B_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t range = max_val - min_val;\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svint32_t c = svld1_s32(pg, &control[i]);\n\n        svbool_t pg_gt_zero = svgt_s32(pg, c, 0);\n\n        if (svptest_any(pg, pg_gt_zero)) {\n            svfloat32_t normalized_val = svsub_f32(a, min_val);\n            normalized_val = svdiv_f32(normalized_val, range);\n\n            normalized_val = svmax_f32(normalized_val, 0.0f);\n            normalized_val = svmin_f32(normalized_val, 1.0f);\n\n            svst1_f32(pg_gt_zero, &B[i], normalized_val);\n\n            svbool_t pg_lte_zero = svcmpne(pg, pg_gt_zero, pg);\n            if (svptest_any(pg, pg_lte_zero)) {\n                svst1_f32(pg_lte_zero, &B[i], svsel(pg_lte_zero, a, svundef_f32()));\n            }\n        } else {\n            svst1_f32(pg, &B[i], a);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t range = max_val - min_val;\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svint32_t c = svld1_s32(pg, &control[i]);\n\n        svbool_t pg_gt_zero = svgt_s32(pg, c, 0);\n\n        if (svptest_any(pg, pg_gt_zero)) {\n            svfloat32_t normalized_val = svsub_f32(a, min_val);\n            normalized_val = svdiv_f32(normalized_val, range);\n\n            normalized_val = svmax_f32(normalized_val, 0.0f);\n            normalized_val = svmin_f32(normalized_val, 1.0f);\n\n            svst1_f32(pg_gt_zero, &B[i], normalized_val);\n\n            svbool_t pg_lte_zero = svcmpne(pg, pg_gt_zero, pg_gt_zero);\n            if (svptest_any(pg, pg_lte_zero)) {\n                svst1_f32(pg_lte_zero, &B[i], svsel(pg_lte_zero, a, svdup_f32(0.0f)));\n            }\n        } else {\n            svst1_f32(pg, &B[i], a);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t range = max_val - min_val;\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svint32_t c = svld1_s32(pg, &control[i]);\n\n        svbool_t pg_gt_zero = svcmpgt_s32(pg, c, 0);\n\n        if (svptest_any(pg, pg_gt_zero)) {\n            svfloat32_t normalized_val = svdiv_f32(pg_gt_zero, svsub_f32(a, min_val), range);\n            normalized_val = svmax_f32(pg_gt_zero, normalized_val, 0.0f);\n            normalized_val = svmin_f32(pg_gt_zero, normalized_val, 1.0f);\n            svst1_f32(pg_gt_zero, &B[i], normalized_val);\n\n            svbool_t pg_lte_zero = svcmpge_s32(pg, c, 1);\n            svst1_f32(pg_lte_zero, &B[i], svsel_f32(pg_lte_zero, a, svld1_f32(pg_lte_zero, &B[i])));\n        } else {\n            svst1_f32(pg, &B[i], a);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t range = max_val - min_val;\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n        svfloat32_t A_vec = svld1_f32(pg, &A[i]);\n\n        svbool_t cond_pos = svcmpgt_s32(pg, control_vec, 0);\n\n        svfloat32_t val_vec = svdup_f32(0.0f);\n\n        if (svptest_any(pg, cond_pos)) {\n            val_vec = svdiv_f32(pg, svsub_f32(pg, A_vec, min_vec), range_vec);\n            val_vec = svmax_f32(pg, val_vec, zero_vec);\n            val_vec = svmin_f32(pg, val_vec, one_vec);\n        }\n\n        svfloat32_t result_vec = svsel_f32(cond_pos, val_vec, A_vec);\n\n        svst1_f32(pg, &B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    for (; svptest_first(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svuint32_t a = svld1_u32(pg, &A[i]);\n        svuint32_t a_high = svlsr_n_u32(a, 16);\n        svfloat32_t float_a = svcvt_f32_u32(pg, a_high);\n        svfloat32_t sqrt_a = svsqrt_f32(pg, float_a);\n        svst1_f32(pg, &B[i], sqrt_a);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_first(pg, pg)) {\n        svuint32_t a = svld1(pg, &A[i]);\n        svuint32_t a_high = svlsr_n_u32(a, 16);\n        svfloat32_t float_a = svcvt_f32_u32(pg, a_high);\n        svfloat32_t sqrt_a = svsqrt_f32(pg, float_a);\n        svst1(pg, &B[i], sqrt_a);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec_a = svld1_u32(A + i);\n        vec_b = svsqrt_f32(svuzp1_f32(svshl_n_u32(vec_a, 16), svdup_n_u32(0)));\n        svst1_f32(B + i, vec_b);\n    }\n\n    for (; i < size; i++) {\n        B[i] = sqrtf((A[i] >> 16) & 0xFFFF);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n    \n    for (i = 0; i < size; i += svcntw()) {\n        size_t vl = svcntw(); // Vector length\n        vec_a = svld1_u32(&A[i]); // Load 32-bit unsigned integers\n        vec_a = svshl_n_u32(vec_a, 16); // Shift left to get high 16 bits\n        vec_b = svcvt_f32_u32(vec_a); // Convert to float\n        vec_b = svsqrt_f32(vec_b); // Calculate square root\n        svst1_f32(&B[i], vec_b); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (i = 0; i < size; i += svcntw()) {\n        size_t vl = svcntw();\n        vec_a = svld1_u32(&A[i]);\n        vec_b = svsqrt_f32(svuzp1_f32(svshl_n_u32(vec_a, 16)));\n        svst1_f32(&B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec_a = svld1_u32(A + i);\n        vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(B + i, vec_b);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Initialize the first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks\n    size_t i;\n    for (i = 1; i < size; i += svcntb()) {\n        // Load condition and source arrays\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1(pg, &A[i]);\n        svint32_t a_prev = svld1(pg, &A[i - 1]);\n        svbool_t cond_pg = svld1(pg, &cond[i]);\n\n        // Compute differences\n        svint32_t diff_int = svsub_s32(a_curr, a_prev);\n        \n        // Convert to float\n        svfloat32_t diff_float = svcvt_f32_s32(diff_int);\n\n        // Set output based on condition\n        svfloat32_t result = svsel(cond_pg, diff_float, svdup_f32(0.0f));\n\n        // Store results\n        svst1(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    diff[0] = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svdup_n_s32(A[0]);\n\n    for (size_t i = 1; i < size; ++i) {\n        pg = svptrue_b8();\n        size_t vl = svcntb();\n        size_t remaining = size - i;\n        if (remaining < vl) {\n            pg = svwhilelt_b8((int64_t)i, (int64_t)size);\n        }\n\n        svbool_t cond_vec = svld1(pg, &cond[i]);\n        svint32_t curr = svdup_n_s32(A[i]);\n        svint32_t diff_vec = svsub_s32(curr, prev);\n        svfloat32_t float_diff = svcvt_f32_s32(diff_vec);\n        svfloat32_t zero = svdup_n_f32(0.0f);\n        svfloat32_t result = svsel_f32(cond_vec, float_diff, zero);\n        svst1(pg, &diff[i], result);\n        prev = curr;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    diff[0] = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svdup_n_s32(A[0]);\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        svbool_t cond_vec = svld1(pg, &cond[i]);\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t diff_vec = svsub_s32_z(cond_vec, curr, prev);\n        svfloat32_t float_diff = svcvt_f32_s32_z(cond_vec, diff_vec);\n        svst1(pg, &diff[i], float_diff);\n\n        prev = curr;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size <= 0) {\n        return;\n    }\n\n    diff[0] = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svdup_n_s32(A[0]);\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        svbool_t cond_vec = svld1(pg, &cond[i]);\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t diff_vec = svsub_s32_z(cond_vec, curr, prev);\n        svfloat32_t diff_float = svcvt_f32_s32(diff_vec);\n        svst1(pg, &diff[i], diff_float);\n\n        prev = curr;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    diff[0] = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        svbool_t cond_vec = svld1(pg, &cond[i]);\n        svint32_t current_vec = svld1(pg, &A[i]);\n        svint32_t previous_vec = svld1(pg, &A[i - 1]);\n\n        svint32_t diff_int_vec = svsub_s32_z(svnot_b32(cond_vec), current_vec, previous_vec);\n        svfloat32_t diff_float_vec = svcvt_f32_s32(diff_int_vec);\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        svfloat32_t result_vec = svsel_f32(cond_vec, diff_float_vec, zero_vec);\n\n        svst1(pg, &diff[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vsrc = svld1_u32(pg, &src[i]);\n        svuint64_t vdst = svcvt_u64_u32(vsrc);\n        vdst = svorr_n_u64(vdst, 0xFFFFFFFF00000000);\n        svst1_u64(pg, &dst[i], vdst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, length);\n    svuint32_t vsrc = svld1_u32(pg, &src[i]);\n    svuint64_t vdst = svcvt_u64_u32(vsrc);\n    vdst = svorr_n_u64(vdst, 0xFFFFFFFF00000000);\n    svst1_u64(pg, &dst[i], vdst);\n  }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, length);\n    svuint32_t src_vec = svld1_u32(pg, &src[i]);\n    svuint64_t dst_vec = svcvt_u64_u32(src_vec);\n    dst_vec = svorr_n_u64(dst_vec, 0xFFFFFFFF00000000);\n    svst1_u64(pg, &dst[i], dst_vec);\n  }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n  size_t vl = svcntw();\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, length);\n    svuint32_t v = svld1_u32(pg, &src[i]);\n    svuint64_t wv = svcvt_u64_u32(v);\n    wv = svorr_n_u64(wv, 0xFFFFFFFF00000000);\n    svst1_u64(pg, &dst[i], wv);\n  }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svcvt_u64_u32(src_vec);\n        dst_vec = svorr_n_u64(dst_vec, 0xFFFFFFFF00000000);\n        svst1_u64(pg, &dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point source array (vec);\n- A pointer to a non-empty 16-bit integer (int16_t) index array (index);\n- The common length of the arrays (length).\n\nYour goal is to:\nFor all legal indices `index[i]` (i.e., within the range [0, length)), sum the elements `vec[index[i]]`, \nand return the result.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(svindex_s16(i, 1), length);\n        svint16_t index_vec = svld1_s16(pg, &index[i]);\n        svuint64_t index_vec_u64 = svzut_u64_s16(pg, index_vec);\n        svfloat64_t vec_val = svgather_index_f64(svptrue_b64(), vec, index_vec_u64);\n        sum_vec = svadd_f64(sum_vec, vec_val);\n    }\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl = svcntd();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b16(svindex_s16(i, 1), length);\n        svint16_t index_vec = svld1_s16(pg, &index[i]);\n        svuint64_t index_u64 = svcvt_u64_s16(index_vec);\n        svfloat64_t vec_val = svgather_index_f64(pg, vec, index_u64);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec_val);\n    }\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl = svcntd();\n  svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t current_pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n    svint16_t sv_index = svld1_s16(current_pg, &index[i]);\n    svfloat64_t sv_values = svgather_f64(current_pg, sv_index, vec);\n    sum += svaddv_f64(current_pg, sv_values);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  size_t vl = svcntd();\n  svbool_t pg = svwhilelt_b16((int16_t)0, (int16_t)length);\n\n  for (size_t i = 0; i < length; i += vl) {\n    svbool_t current_pg = svwhilelt_b16((int16_t)i, (int16_t)length);\n    svint16_t sv_index = svld1_s16(current_pg, &index[i]);\n    svuint64_t sv_index_u64 = svcvt_u64_s16(sv_index);\n    svfloat64_t sv_vec = svgather_f64(current_pg, vec, sv_index_u64);\n    sum += svaddv_f64(current_pg, sv_vec);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n  double sum = 0.0;\n  svbool_t pg = svwhilelt_b16(0, length);\n\n  for (size_t i = 0; i < length; i += svcntd()) {\n    svint16_t indices = svld1_s16(pg, index + i);\n    svfloat64_t values = svgather_f64(pg, vec, indices);\n    sum += svaddv_f64(pg, values);\n    pg = svwhilelt_b16(i, length);\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t row = 0; row < output_size; ++row) {\n        for (size_t col = 0; col < output_size; ++col) {\n            double sum = 0.0;\n            for (size_t kernel_row = 0; kernel_row < kernel_size; ++kernel_row) {\n                for (size_t kernel_col = 0; kernel_col < kernel_size; ++kernel_col) {\n                    size_t input_row = row + kernel_row;\n                    size_t input_col = col + kernel_col;\n\n                    sum += input[input_row * input_size + input_col] * kernel[kernel_row * kernel_size + kernel_col];\n                }\n            }\n            output[row * output_size + col] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += kernel[m * kernel_size + n] * input[(i + m) * input_size + (j + n)];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t val = svdup_f64(numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, n);\n            svfloat64_t vec = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svfabs_f64_x(pg, svsub_f64_x(pg, val, vec));\n            svbool_t close = svcmplt_f64(pg, diff, threshold);\n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t val = svdup_f64(numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, n);\n            svfloat64_t vec = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svfabs_f64_x(pg, svsub_f64_x(pg, val, vec));\n            svbool_t close = svcmplt_f64(pg, diff, threshold);\n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t val = svdup_f64(numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, n);\n            svfloat64_t vec = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svfabs_f64_x(pg, svsub_f64_x(pg, val, vec));\n            svbool_t close = svcmplt_f64_x(pg, diff, svdup_f64(threshold));\n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    size_t n = operations.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_ops = svld1_s32(pg, &operations[i]);\n        \n        int32_t op_array[vl];\n        svst1_s32(pg, op_array, current_ops);\n\n        for(size_t j = 0; j < vl; ++j) {\n            if (i + j < n) {\n                balance += op_array[j];\n                if (balance < 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    size_t n = operations.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_ops = svld1_s32(pg, &operations[i]);\n        \n        int32_t op_array[vl];\n        svst1_s32(pg, op_array, current_ops);\n\n        for(size_t j = 0; j < vl; ++j){\n            if(i + j < n){\n                balance += op_array[j];\n                if (balance < 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    size_t n = operations.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_ops = svld1_s32(pg, &operations[i]);\n        \n        int32_t op_array[vl];\n        svst1_s32(pg, op_array, sv_ops);\n\n        for(size_t j = 0; j < vl && i + j < n; ++j){\n            balance += op_array[j];\n            if (balance < 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    size_t n = operations.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_ops = svld1_s32(pg, &operations[i]);\n        \n        int32_t op_array[vl];\n        svst1_s32(pg, op_array, current_ops);\n\n        for(size_t j = 0; j < vl; ++j){\n            if(i + j < n){\n                balance += op_array[j];\n                if(balance < 0){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    size_t n = operations.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_ops = svld1_s32(pg, &operations[i]);\n        \n        int32_t op_array[vl];\n        svst1_s32(pg, op_array, sv_ops);\n\n        for(size_t j = 0; j < vl; ++j) {\n            if(i + j < n) {\n                balance += op_array[j];\n                if (balance < 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    size_t n = numbers.size();\n    double mad = 0.0;\n\n    svfloat64_t sum_abs_diff = svdup_f64(0.0);\n\n    size_t i = 0;\n    for (; i < n - n % svcntd(); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t vec_mean = svdup_f64(mean);\n        svfloat64_t diff = svsub_f64(pg, vec, vec_mean);\n        svfloat64_t abs_diff = svabs_f64(pg, diff);\n        sum_abs_diff = svadd_f64(sum_abs_diff, abs_diff);\n    }\n\n    double temp_sum_abs_diff[svcntd()];\n    svst1(svptrue_b64(), temp_sum_abs_diff, sum_abs_diff);\n    for (int j = 0; j < svcntd(); ++j) {\n        mad += temp_sum_abs_diff[j];\n    }\n\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    size_t n = numbers.size();\n    double absolute_deviations_sum = 0.0;\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t sv_numbers = svld1(pg, &numbers[i]);\n        svfloat64_t sv_mean = svdup_f64(mean);\n        svfloat64_t sv_diff = svsub_f64(pg, sv_numbers, sv_mean);\n        svfloat64_t sv_abs_diff = svfabs_f64(pg, sv_diff);\n        absolute_deviations_sum += svaddv_f64(pg, sv_abs_diff);\n    }\n\n    return absolute_deviations_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    size_t n = numbers.size();\n    double absolute_deviations_sum = 0.0;\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t sv_numbers = svld1(pg, &numbers[i]);\n        svfloat64_t sv_mean = svdup_f64(mean);\n        svfloat64_t sv_diff = svsub_f64(pg, sv_numbers, sv_mean);\n        svfloat64_t sv_abs_diff = svfabs_f64(pg, sv_diff);\n        absolute_deviations_sum += svaddv_f64(pg, sv_abs_diff);\n    }\n\n    return absolute_deviations_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    size_t n = numbers.size();\n    double mad = 0.0;\n\n    svfloat64_t sum_abs_diff = svdup_f64(0.0);\n\n    size_t i = 0;\n    for (; i < n - n % svcntd(); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t vec_mean = svdup_f64(mean);\n        svfloat64_t diff = svsub_f64(pg, vec, vec_mean);\n        svfloat64_t abs_diff = svabs_f64(pg, diff);\n        sum_abs_diff = svadd_f64(sum_abs_diff, abs_diff);\n    }\n\n    double temp_sum_abs_diff[svcntd()];\n    svst1(svptrue_b64(), temp_sum_abs_diff, sum_abs_diff);\n    for (int j = 0; j < svcntd(); ++j) {\n        mad += temp_sum_abs_diff[j];\n    }\n    \n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    size_t n = numbers.size();\n    double absolute_deviations_sum = 0.0;\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t sv_numbers = svld1(pg, &numbers[i]);\n        svfloat64_t sv_mean = svdup_f64(mean);\n        svfloat64_t sv_diff = svsub_f64(pg, sv_numbers, sv_mean);\n        svfloat64_t sv_abs_diff = svfabs_f64(pg, sv_diff);\n        absolute_deviations_sum += svaddv_f64(pg, sv_abs_diff);\n    }\n\n    return absolute_deviations_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (size_t i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    result.push_back(numbers[0]);\n\n    for (size_t i = 1; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n    for (; i < num_elements - num_elements % svcntw(); i += svcntw()) {\n        svint16_t sv_numbers = svld1_s16(pg, &numbers[i]);\n        sum += svaddv_s16(pg, sv_numbers);\n        \n        int16_t temp_product = 1;\n        for(int j = 0; j < svcntw(); ++j){\n            temp_product *= numbers[i+j];\n        }\n        product *= temp_product;\n    }\n\n    for (; i < num_elements; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, num_elements);\n    int64_t sum_vector = 0;\n    int64_t product_vector = 1;\n\n    for (size_t i = 0; i < num_elements; i += svcntw()) {\n        pg = svwhilelt_b16(i, num_elements);\n        svint16_t current_vector = svld1_s16(pg, &numbers[i]);\n\n        svint64_t wide_vector = svcvt_s64_s16(current_vector);\n\n        sum_vector = svaddv_s64(pg, wide_vector);\n        sum += sum_vector;\n\n        product_vector = svmulpv_s64(pg, wide_vector);\n        if (i == 0)\n            product = product_vector;\n        else\n            product *= product_vector;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, num_elements);\n    int16_t *data = numbers.data();\n\n    svint16_t sve_numbers;\n    svint64_t sve_sum = svdup_s64(0);\n    svint64_t sve_product = svdup_s64(1);\n\n    size_t i = 0;\n    for (; i < num_elements - svcntw() + 1; i += svcntw()) {\n        pg = svwhilelt_b16(i, num_elements);\n        sve_numbers = svld1_s16(pg, data + i);\n        sve_sum = svadd_s64_x(pg, sve_sum, svcvt_s64_s16(sve_numbers));\n        sve_product = svmul_s64_x(pg, sve_product, svcvt_s64_s16(sve_numbers));\n    }\n\n    sum = svaddv_s64(svptrue_b64(), sve_sum);\n    product = svmulp_s64(svptrue_b64(), sve_product);\n\n    for (; i < num_elements; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, num_elements);\n    int64_t sum_vector = 0;\n    int64_t product_vector = 1;\n    size_t i = 0;\n    for (; i < num_elements; i += svcntw()) {\n        pg = svwhilelt_b16(i, num_elements);\n        svint16_t current_vector = svld1_s16(pg, &numbers[i]);\n\n        svint64_t wide_vector = svcvt_s64_s16(current_vector);\n        sum_vector = svaddv_s64(pg, sum_vector, wide_vector);\n        product_vector = svmulpv_s64(pg, product_vector, wide_vector);\n    }\n    sum = sum_vector;\n    product = product_vector;\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n    for (; i < num_elements - num_elements % svcntw(); i += svcntw()) {\n        svint16_t sv_numbers = svld1_s16(pg, &numbers[i]);\n        sum += svaddv_s16(pg, sv_numbers);\n        \n        int16_t temp_product = 1;\n        for(int j = 0; j < svcntw(); ++j){\n            temp_product *= numbers[i+j];\n        }\n        product *= temp_product;\n    }\n\n    for (; i < num_elements; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; ++i) {\n        svint32_t current_value = svdup_n_s32(numbers[i]);\n        current_max = svmax_s32_x(pg, current_max, current_value);\n        result[i] = svgetfirst_s32(pg, current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; ++i) {\n        svint32_t current_value = svdup_n_s32(numbers[i]);\n        current_max = svmax_s32_x(pg, current_max, current_value);\n        result[i] = svgetfirst_s32(pg, current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    int n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; ++i) {\n        svint32_t current_val = svdup_n_s32(numbers[i]);\n        current_max = svmax_s32_x(pg, current_max, current_val);\n        result[i] = svgetfirst_s32(current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; ++i) {\n        svint32_t current_value = svdup_n_s32(numbers[i]);\n        current_max = svmax_s32_x(pg, current_max, current_value);\n        result[i] = svgetfirst_s32(pg, current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; ++i) {\n        svint32_t current_value = svdup_n_s32(numbers[i]);\n        current_max = svmax_s32_x(pg, current_max, current_value);\n        result[i] = svgetfirst_s32(pg, current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len_a; ++i) {\n        if (a[i] != '0' && a[i] != '1') return \"\";\n    }\n    for (size_t i = 0; i < len_b; ++i) {\n        if (b[i] != '0' && b[i] != '1') return \"\";\n    }\n\n    size_t vector_length = svcntb();\n    size_t i = 0;\n\n    for (; i + vector_length <= len; i += vector_length) {\n        svbool_t pg = svptrue_b8();\n\n        char a_vec[vector_length];\n        char b_vec[vector_length];\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            if (i + j < len_a) {\n                a_vec[j] = a[i + j];\n            } else {\n                a_vec[j] = '0';\n            }\n\n            if (i + j < len_b) {\n                b_vec[j] = b[i + j];\n            } else {\n                b_vec[j] = '0';\n            }\n        }\n\n        svint8_t a_sve = svld1_s8(pg, a_vec);\n        svint8_t b_sve = svld1_s8(pg, b_vec);\n\n        svint8_t result_sve = sveor_s8(a_sve, b_sve);\n\n        char result_vec[vector_length];\n        svst1_s8(pg, result_vec, result_sve);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            result[i + j] = (result_vec[j] == '0' ^ result_vec[j] == '0') ? '0' : '1';\n        }\n    }\n\n    for (; i < len; ++i) {\n        char char_a = (i < len_a) ? a[i] : '0';\n        char char_b = (i < len_b) ? b[i] : '0';\n\n        result[i] = (char_a == char_b) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    size_t vector_length = svcntb();\n    size_t num_vectors = (len + vector_length - 1) / vector_length;\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t current_len = std::min(vector_length, len - start);\n\n        svbool_t pg = svwhilelt_b8(start, start + current_len);\n\n        svuint8_t a_vec = svdup_u8(0);\n        svuint8_t b_vec = svdup_u8(0);\n\n        for (size_t j = 0; j < current_len; ++j) {\n            if (start + j < len_a && a[start + j] == '1') {\n                a_vec = svpoke_u8(pg, a_vec, j, 1);\n            }\n            if (start + j < len_b && b[start + j] == '1') {\n                b_vec = svpoke_u8(pg, b_vec, j, 1);\n            }\n        }\n\n        svuint8_t result_vec = sveor_u8(pg, a_vec, b_vec);\n\n        for (size_t j = 0; j < current_len; ++j) {\n            if (svptrue_b8()) {\n                uint8_t val = svgetelement_u8(result_vec, j);\n                result[start + j] = (val == 1) ? '1' : '0';\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    size_t vector_length = svcntb();\n    size_t num_vectors = (len + vector_length - 1) / vector_length;\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t current_len = std::min(vector_length, len - start);\n\n        svbool_t pg = svwhilelt_b8(start, start + current_len);\n\n        svuint8_t a_vec = svdup_u8(0);\n        svuint8_t b_vec = svdup_u8(0);\n\n        for (size_t j = 0; j < current_len; ++j) {\n            if (start + j < len_a && a[start + j] == '1') {\n                a_vec = svpoke_u8(pg, a_vec, j, 1);\n            }\n            if (start + j < len_b && b[start + j] == '1') {\n                b_vec = svpoke_u8(pg, b_vec, j, 1);\n            }\n        }\n\n        svuint8_t result_vec = sveor_u8(pg, a_vec, b_vec);\n\n        for (size_t j = 0; j < current_len; ++j) {\n            if (svptest_any(pg, svcmpne(pg, svdup_u8(0), svindex_u8(start + j, 1)))) {\n                uint8_t val = svgetelement_u8(result_vec, j);\n                result[start + j] = (val == 1) ? '1' : '0';\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len_a = a.length();\n    size_t len_b = b.length();\n    size_t len = std::max(len_a, len_b);\n\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len_a; ++i) {\n        if (a[i] != '0' && a[i] != '1') return \"\";\n    }\n    for (size_t i = 0; i < len_b; ++i) {\n        if (b[i] != '0' && b[i] != '1') return \"\";\n    }\n\n    size_t vector_length = svcntb();\n    size_t i = 0;\n\n    for (; i + vector_length <= len; i += vector_length) {\n        svbool_t pg = svptrue_b8();\n\n        char a_vec[vector_length];\n        char b_vec[vector_length];\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            if (i + j < len_a) {\n                a_vec[j] = a[len_a - 1 - (i + j)];\n            } else {\n                a_vec[j] = '0';\n            }\n\n            if (i + j < len_b) {\n                b_vec[j] = b[len_b - 1 - (i + j)];\n            } else {\n                b_vec[j] = '0';\n            }\n        }\n\n        svint8_t a_sve = svld1_s8(pg, a_vec);\n        svint8_t b_sve = svld1_s8(pg, b_vec);\n\n        svint8_t result_sve = sveor_s8(a_sve, b_sve);\n\n        char result_vec[vector_length];\n        svst1_s8(pg, result_vec, result_sve);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            if (result_vec[j] == '0' ^ '0') {\n                result[len - 1 - (i + j)] = '0';\n            } else {\n                result[len - 1 - (i + j)] = '1';\n            }\n        }\n    }\n\n    for (; i < len; ++i) {\n        char a_val = (i < len_a) ? a[len_a - 1 - i] : '0';\n        char b_val = (i < len_b) ? b[len_b - 1 - i] : '0';\n\n        if ((a_val == '0' && b_val == '0') || (a_val == '1' && b_val == '1')) {\n            result[len - 1 - i] = '0';\n        } else {\n            result[len - 1 - i] = '1';\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = std::max(a.length(), b.length());\n    std::string result(n, '0');\n\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    for (; i + vl <= n; i += vl) {\n        svbool_t pg = svptrue_b8();\n\n        std::string a_slice = a.substr(i, vl);\n        std::string b_slice = b.substr(i, vl);\n\n        svuint8_t a_vec = svdup_u8(0);\n        svuint8_t b_vec = svdup_u8(0);\n        svuint8_t res_vec = svdup_u8(0);\n\n        for (size_t j = 0; j < std::min(vl, a.length() - i); ++j) {\n            a_vec = svpoke_u8(a_vec, j, a_slice[j] - '0');\n        }\n\n        for (size_t j = 0; j < std::min(vl, b.length() - i); ++j) {\n            b_vec = svpoke_u8(b_vec, j, b_slice[j] - '0');\n        }\n\n        res_vec = sveor_u8(pg, a_vec, b_vec);\n\n        for (size_t j = 0; j < vl; ++j) {\n            result[i + j] = svget_u8(res_vec, j) + '0';\n        }\n    }\n\n    for (; i < n; ++i) {\n        int a_val = (i < a.length()) ? (a[i] - '0') : 0;\n        int b_val = (i < b.length()) ? (b[i] - '0') : 0;\n        result[i] = ((a_val ^ b_val) + '0');\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = longest_string.length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = longest_string.length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = longest_string.length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = longest_string.length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = longest_string.length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = longest_string.length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = longest_string.length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = longest_string.length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n  if (strings.empty()) {\n    return \"\";\n  }\n\n  std::string longest_string = strings[0];\n  size_t max_len = longest_string.length();\n\n  for (size_t i = 1; i < strings.size(); ++i) {\n    if (strings[i].length() > max_len) {\n      longest_string = strings[i];\n      max_len = longest_string.length();\n    }\n  }\n\n  return longest_string;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n    float closest_2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_1 = numbers[i];\n                closest_2 = numbers[j];\n            }\n        }\n    }\n\n    if (closest_1 > closest_2) {\n        std::swap(closest_1, closest_2);\n    }\n\n    return {closest_1, closest_2};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t i = 0;\n\n    for (; i < n - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n        svfloat32_t diff_vec = svsub_f32(pg, vec, min_vec);\n        svfloat32_t res_vec = svdiv_f32(pg, diff_vec, range_vec);\n        svst1(pg, &result[i], res_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n\n    size_t num_elements = numbers.size();\n    size_t vector_length = svcntw();\n    size_t num_full_vectors = num_elements / vector_length;\n    size_t remaining_elements = num_elements % vector_length;\n\n    std::vector<float> result(num_elements);\n\n    for (size_t i = 0; i < num_full_vectors; ++i) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i * vector_length]);\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n\n        svfloat32_t sub_vec = svsub_f32(svptrue_b32(), vec, min_vec);\n        svfloat32_t div_vec = svdiv_f32(svptrue_b32(), sub_vec, range_vec);\n\n        svst1_f32(svptrue_b32(), &result[i * vector_length], div_vec);\n    }\n\n    if (remaining_elements > 0) {\n        svbool_t pg = svwhilelt_b32(0, remaining_elements);\n        svfloat32_t vec = svld1_f32(pg, &numbers[num_full_vectors * vector_length]);\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n\n        svfloat32_t sub_vec = svsub_f32(pg, vec, min_vec);\n        svfloat32_t div_vec = svdiv_f32(pg, sub_vec, range_vec);\n\n        svst1_f32(pg, &result[num_full_vectors * vector_length], div_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t num_elements = numbers.size();\n    std::vector<float> result(num_elements);\n\n    size_t vector_length = svcntf32();\n    size_t i = 0;\n\n    for (; i < num_elements - (num_elements % vector_length); i += vector_length) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n\n        svfloat32_t sub_vec = svsub_f32(svptrue_b32(), vec, min_vec);\n        svfloat32_t div_vec = svdiv_f32(svptrue_b32(), sub_vec, range_vec);\n\n        svst1_f32(svptrue_b32(), &result[i], div_vec);\n    }\n\n    for (; i < num_elements; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t num_elements = numbers.size();\n    std::vector<float> result(num_elements);\n\n    size_t vectorizable_elements = num_elements - (num_elements % svcntf());\n\n    for (size_t i = 0; i < vectorizable_elements; i += svcntf()) {\n        svfloat32_t vec = svld1(svptrue_f32(), &numbers[i]);\n        svfloat32_t min_vec = svdup_n_f32(min_val);\n        svfloat32_t range_vec = svdup_n_f32(range);\n        svfloat32_t res_vec = svdiv_f32_x(svptrue_f32(), svsub_f32_x(svptrue_f32(), vec, min_vec), range_vec);\n        svst1(svptrue_f32(), &result[i], res_vec);\n    }\n\n    for (size_t i = vectorizable_elements; i < num_elements; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float range = max_val - min_val;\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i < n - (n % vl); i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n        svfloat32_t res_vec = svdiv_f32(svsub_f32(vec, min_vec), range_vec);\n        svst1_f32(svptrue_b32(), &result[i], res_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) return 0;\n\n  svuint64_t vn = svdup_u64(n);\n  uint64_t divisor = 1;\n  uint64_t largest_divisor = 1;\n\n  for (uint64_t i = 1; i * i <= n; ++i) {\n    svuint64_t vi = svdup_u64(i);\n    svbool_t pg = svwhilelt_b64(vi, vn);\n\n    if (svptest_any(pg, pg)) {\n      if (n % i == 0) {\n        largest_divisor = i;\n        if (n / i < n) {\n          divisor = n / i;\n          if (divisor > largest_divisor && n % divisor == 0)\n            largest_divisor = divisor;\n        }\n      }\n    }\n  }\n\n  if (largest_divisor == n)\n      return 1;\n\n  return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    uint64_t largest_divisor = 1;\n    svbool_t pg = svwhilelt_u64(1, n);\n    uint64_t divisor = 1;\n\n    while (svptest_any(pg, pg)) {\n        svuint64_t divisors = svincr_u64(svptrue_u64(), divisor);\n        svbool_t divisible = svcmpeq_u64(pg, divisors % n, 0);\n\n        if (svptest_any(divisible, divisible)) {\n            uint64_t temp_divisor = svlasta_u64(divisible, divisors);\n            if (temp_divisor > largest_divisor && n % temp_divisor == 0) {\n                largest_divisor = temp_divisor;\n            }\n        }\n        divisor += svcntw();\n        pg = svwhilelt_u64(divisor, n);\n    }\n    \n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n  if (n <= 1) {\n    return 0;\n  }\n\n  svuint64_t vec = svdup_u64(n);\n  uint64_t divisor = 1;\n  uint64_t result = 1;\n\n  for (divisor = 1; divisor <= n / 2; ++divisor) {\n    svbool_t pg = svwhilelt_u64(svdup_u64(divisor), svdup_u64(n / 2 + 1));\n    svuint64_t divisor_vec = svdup_u64(divisor);\n    svuint64_t remainder_vec = svfmod_u64_x(pg, vec, divisor_vec);\n\n    if (svptest_any(pg, sveceq_u64(remainder_vec, svdup_u64(0)))) {\n      result = divisor;\n    }\n  }\n  \n  return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    uint64_t largest_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    uint64_t divisor = 2;\n    svuint64_t vec_divisor = svdup_u64(divisor);\n    svbool_t pg = svwhilelt_b64(vec_divisor, vec_n);\n\n    while (svptest_any(pg, pg)) {\n        svbool_t divisible = svcmpeq(pg, svemul_u64_x(pg, vec_n, svdiv_u64(pg, vec_n, vec_divisor)), vec_n);\n        uint64_t temp_divisor = svlasta_u64(pg, vec_divisor);\n        if (svptest_any(divisible, divisible)) {\n            largest_divisor = temp_divisor;\n        }\n        divisor++;\n        vec_divisor = svdup_u64(divisor);\n        pg = svwhilelt_b64(vec_divisor, vec_n);\n    }\n    \n    if (largest_divisor == 1) return 1;\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 1;\n    uint64_t largest_divisor = 1;\n    svbool_t pg = svwhilelt_u64(1, n);\n    uint64_t divisor = 1;\n    uint64_t inc = svcntd();\n\n    while (svptest_any(pg)) {\n        svuint64_t divisors = svincr_u64(svptrue_u64(), divisor);\n        svbool_t divisible = svcmpeq_u64(pg, n % divisors, 0);\n\n        if (svptest_any(divisible)) {\n            uint64_t tmp_divisor = svlasta_u64(divisible, divisors);\n            if (tmp_divisor > largest_divisor && tmp_divisor < n) {\n                largest_divisor = tmp_divisor;\n            }\n        }\n        divisor += inc;\n        pg = svwhilelt_u64(divisor, n);\n    }\n    if (largest_divisor == 1){\n        for (uint64_t i = n/2; i >= 1; i--){\n            if (n % i == 0){\n                largest_divisor = i;\n                break;\n            }\n        }\n    }\n\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n  std::vector<int> factors;\n  if (n <= 1) {\n    return factors;\n  }\n\n  // Factor out 2\n  while (n % 2 == 0) {\n    factors.push_back(2);\n    n /= 2;\n  }\n\n  // Factor out odd numbers starting from 3\n  for (int i = 3; i * i <= n; i += 2) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n\n  // If n is still greater than 1, it must be a prime number\n  if (n > 1) {\n    factors.push_back(n);\n  }\n\n  return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Factor out 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Iterate from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 1, it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Factor out 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Iterate from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is still greater than 1, it is a prime factor\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Handle even numbers\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Iterate from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n  std::vector<int> factors;\n  if (n <= 1) {\n    return factors;\n  }\n\n  while (n % 2 == 0) {\n    factors.push_back(2);\n    n /= 2;\n  }\n\n  for (int i = 3; i * i <= n; i += 2) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n\n  if (n > 2) {\n    factors.push_back(n);\n  }\n\n  return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t sv_in = svld1(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, sv_in, svdup_f32(0.0f));\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n && svptest_b_z(pg, positive_mask, j)) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl = svcntw();\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t sv_in = svld1(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, sv_in, svdup_n_f32(0.0));\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n && svptest_b_z(pg, positive_mask, j)) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl = svcntw();\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t sv_in = svld1(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, sv_in, svdup_n_f32(0.0f));\n        \n        float buffer[vl];\n        svst1(positive_mask, buffer, sv_in);\n\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            if (positive_mask[j]) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl = svcntw();\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t sv_in = svld1(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, sv_in, svdup_n_f32(0.0f));\n        \n        float buffer[vl];\n        svst1(positive_mask, buffer, sv_in);\n\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            if (positive_mask[j]) {\n                result.push_back(buffer[j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t vl = svcntw();\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t sv_in = svld1(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, sv_in, svdup_n_f32(0.0f));\n        \n        float buffer[vl];\n        svst1(positive_mask, buffer, sv_in);\n\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            if (positive_mask[j]) {\n                result.push_back(buffer[j]);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <math.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n);\n\n    for (int64_t i = 5; i <= sqrt_n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <math.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n){\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n\n  svbool_t pg = svwhilelt_b64(3, n);\n  for (int64_t i = 5; i * i <= n; i = i + 6) {\n    svint64_t svi = svdup_n_s64(i);\n    svint64_t svn = svdup_n_s64(n);\n    svbool_t pg1 = svwhilelt_b64(svi, svn);\n\n    if (n % i == 0 || n % (i + 2) == 0)\n      return false;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(3, n);\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <math.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    for (int64_t i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int64_t length = s.length();\n    bool has_letters = false;\n\n    for (int64_t i = 0; i < length; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int64_t vl = svcntb();\n    int64_t i = 0;\n    for (; i < length - vl + 1; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svint8_t sv_chars = svld1_s8(pg, s.data() + i);\n        svbool_t sv_is_lower = svcmpge_s8(pg, sv_chars, 'a');\n        svbool_t sv_is_upper = svcmpge_s8(pg, sv_chars, 'A');\n        sv_is_lower = svand_z(pg, sv_is_lower, svcmple_s8(pg, sv_chars, 'z'));\n        sv_is_upper = svand_z(pg, sv_is_upper, svcmple_s8(pg, sv_chars, 'Z'));\n\n        svint8_t sv_lower_to_upper = svsub_s8(pg, sv_chars, 32);\n        svint8_t sv_upper_to_lower = svadd_s8(pg, sv_chars, 32);\n\n        sv_chars = svsel_s8(sv_is_lower, sv_lower_to_upper, sv_chars);\n        sv_chars = svsel_s8(sv_is_upper, sv_upper_to_lower, sv_chars);\n\n        svst1_s8(pg, result.data() + i, sv_chars);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int64_t len = s.length();\n    bool has_letters = false;\n\n    for (int64_t i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    for (int64_t i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int64_t length = s.length();\n    bool has_letters = false;\n\n    for (int64_t i = 0; i < length; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int64_t vl = svcntb();\n    int64_t i = 0;\n    for (; i < length - vl + 1; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svint8_t sv_chars = svld1_s8(pg, s.data() + i);\n        svbool_t sv_is_lower = svislower_s8(pg, sv_chars);\n        svbool_t sv_is_upper = svisupper_s8(pg, sv_chars);\n        svint8_t sv_lower_to_upper = svsub_s8(sv_chars, svdup_s8('a' - 'A'));\n        svint8_t sv_upper_to_lower = svadd_s8(sv_chars, svdup_s8('a' - 'A'));\n        svint8_t sv_changed_chars = svsel_s8(sv_is_lower, sv_lower_to_upper, sv_chars);\n        sv_changed_chars = svsel_s8(sv_is_upper, sv_upper_to_lower, sv_changed_chars);\n        svst1_s8(pg, result.data() + i, sv_changed_chars);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int64_t length = s.length();\n    bool has_letters = false;\n\n    for (int64_t i = 0; i < length; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int64_t vl = svcntb();\n    int64_t i = 0;\n    for (; i < length - vl + 1; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svint8_t sv_chars = svld1_s8(pg, s.data() + i);\n        svbool_t sv_is_lower = svislower_s8(pg, sv_chars);\n        svbool_t sv_is_upper = svisupper_s8(pg, sv_chars);\n        svint8_t sv_lower_to_upper = svsub_s8(sv_chars, svdup_s8('a' - 'A'));\n        svint8_t sv_upper_to_lower = svadd_s8(sv_chars, svdup_s8('a' - 'A'));\n        sv_chars = svsel_s8(sv_is_lower, sv_lower_to_upper, sv_chars);\n        sv_chars = svsel_s8(sv_is_upper, sv_upper_to_lower, sv_chars);\n        svst1_s8(pg, result.data() + i, sv_chars);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    int64_t length = s.length();\n    bool has_letters = false;\n\n    for (int64_t i = 0; i < length; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int64_t vl = svcntb();\n    int64_t i = 0;\n    for (; i < length - vl + 1; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svint8_t sv_chars = svld1_s8(pg, s.data() + i);\n        svbool_t sv_is_lower = svcmpge_s8(pg, sv_chars, 'a');\n        svbool_t sv_is_upper = svcmpge_s8(pg, sv_chars, 'A');\n        sv_is_lower = svand_z(pg, sv_is_lower, svcmple_s8(pg, sv_chars, 'z'));\n        sv_is_upper = svand_z(pg, sv_is_upper, svcmple_s8(pg, sv_chars, 'Z'));\n\n        svint8_t sv_lower_to_upper = svsub_s8(pg, sv_chars, 32);\n        svint8_t sv_upper_to_lower = svadd_s8(pg, sv_chars, 32);\n\n        sv_chars = svsel_s8(sv_is_lower, sv_lower_to_upper, sv_chars);\n        sv_chars = svsel_s8(sv_is_upper, sv_upper_to_lower, sv_chars);\n\n        svst1_s8(pg, result.data() + i, sv_chars);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            if (islower(s[i])) {\n                result[i] = toupper(s[i]);\n            } else {\n                result[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n\n        int size = std::min((int)svcntw(), n - i);\n        std::vector<int> temp;\n        std::vector<int> indices;\n\n        for (int j = 0; j < size; ++j) {\n            if ((i + j) % 3 == 0) {\n                temp.push_back(l[i + j]);\n                indices.push_back(j);\n            }\n        }\n\n        std::sort(temp.begin(), temp.end());\n\n        for (size_t j = 0; j < temp.size(); ++j) {\n            result[i + indices[j]] = temp[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, l.data());\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_vec = svld1_s32(pg, l.data() + i);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            size_t index = i + j;\n            if (index < n && index % 3 == 0) {\n                std::vector<int> temp;\n                temp.push_back(l[index]);\n                \n                size_t k = index;\n                while(k + 3 < n){\n                    k += 3;\n                    temp.push_back(l[k]);\n                }\n                \n                std::sort(temp.begin(), temp.end());\n                \n                size_t temp_index = 0;\n                l[index] = temp[temp_index++];\n                \n                k = index;\n                while(k + 3 < n && temp_index < temp.size()){\n                    k += 3;\n                    l[k] = temp[temp_index++];\n                }\n            }\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, l.data());\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            size_t index = i + j;\n            if (index < n && index % 3 == 0) {\n                std::vector<int> temp;\n                temp.push_back(l[index]);\n                \n                for(size_t k = index + 3; k < n && k < index + svcntw(); k += 3){\n                    temp.push_back(l[k]);\n                }\n                \n                std::sort(temp.begin(), temp.end());\n                \n                l[index] = temp[0];\n                int temp_index = 1;\n                for(size_t k = index + 3; k < n && k < index + svcntw(); k += 3){\n                    l[k] = temp[temp_index];\n                    temp_index++;\n                }\n            }\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n\n        int size = std::min((int)svcntw(), n - i);\n        std::vector<int> temp;\n        std::vector<int> indices;\n\n        for (int j = 0; j < size; ++j) {\n            if ((i + j) % 3 == 0) {\n                temp.push_back(l[i + j]);\n                indices.push_back(j);\n            }\n        }\n\n        std::sort(temp.begin(), temp.end());\n\n        for (size_t j = 0; j < temp.size(); ++j) {\n            result[i + indices[j]] = temp[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int n = l.size();\n    std::vector<int> result = l;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n\n        int size = std::min((int)svcntw(), n - i);\n        std::vector<int> temp;\n        std::vector<int> indices;\n\n        for (int j = 0; j < size; ++j) {\n            if ((i + j) % 3 == 0) {\n                temp.push_back(l[i + j]);\n                indices.push_back(j);\n            }\n        }\n\n        std::sort(temp.begin(), temp.end());\n\n        for (size_t j = 0; j < temp.size(); ++j) {\n            result[i + indices[j]] = temp[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t vl = svcntf32();\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svdup_f32(max_val);\n        svbool_t cmp = svcmpgt(pg, vec, max_vec);\n        max_vec = svsel(cmp, vec, max_vec);\n        max_val = svlast_f32(pg, max_vec);\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    for (size_t i = 0; i < n; i += svcntf()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svdup_f32(max_val);\n        svbool_t cmp = svcmpgt(pg, vec, max_vec);\n        max_vec = svsel(cmp, vec, max_vec);\n        max_val = svlast_f32(pg, max_vec);\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    for (size_t i = 0; i < n; i += svcntf()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svdup_f32(max_val);\n        svbool_t cmp = svcmpgt(pg, vec, max_vec);\n        max_vec = svsel(cmp, vec, max_vec);\n        max_val = svlast_f32(pg, max_vec);\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    for (size_t i = 0; i < n; i += svcntf()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svdup_f32(max_val);\n        svbool_t cmp = svcmpgt(pg, vec, max_vec);\n        max_vec = svsel(cmp, vec, max_vec);\n        max_val = svlast_f32(pg, max_vec);\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    float max_val = l[0];\n    for (size_t i = 0; i < n; i += svcntf()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svdup_f32(max_val);\n        svbool_t cmp = svcmpgt(pg, vec, max_vec);\n        max_vec = svsel(cmp, vec, max_vec);\n        max_val = svlast_f32(pg, max_vec);\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n  int count = 0;\n  for (int i = 0; i < n; ++i) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      int temp = i;\n      while (temp > 0) {\n        if (temp % 10 == 7) {\n          count++;\n        }\n        temp /= 10;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0) || (i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((i % 11 == 0) || (i % 13 == 0)) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < n; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n\n    std::sort(even_vals.begin(), even_vals.end());\n\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_vals[even_idx++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n  size_t n = l.size();\n  if (n <= 1) return l;\n\n  std::vector<float> even_values;\n  for (size_t i = 0; i < n; i += 2) {\n    even_values.push_back(l[i]);\n  }\n\n  std::sort(even_values.begin(), even_values.end());\n\n  size_t even_index = 0;\n  for (size_t i = 0; i < n; i += 2) {\n    l[i] = even_values[even_index++];\n  }\n\n  return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  int n = l.size();\n  if (n < 3) {\n    return false;\n  }\n\n  for (int i = 0; i < n - 2; ++i) {\n    for (int j = i + 1; j < n - 1; ++j) {\n      for (int k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  int n = l.size();\n  if (n < 3) return false;\n\n  for (int i = 0; i < n - 2; ++i) {\n    for (int j = i + 1; j < n - 1; ++j) {\n      for (int k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  int n = l.size();\n  if (n < 3) return false;\n\n  for (int i = 0; i < n - 2; ++i) {\n    for (int j = i + 1; j < n - 1; ++j) {\n      for (int k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n  int n = l.size();\n  if (n < 3) return false;\n\n  for (int i = 0; i < n - 2; ++i) {\n    for (int j = i + 1; j < n - 1; ++j) {\n      for (int k = j + 1; k < n; ++k) {\n        if (l[i] + l[j] + l[k] == 0) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_in = svld1_s32(pg, &l[i]);\n        svint32_t sv_out = svadd_s32_x(pg, sv_in, 1);\n        svst1_s32(pg, &result[i], sv_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_in = svld1_s32(pg, &l[i]);\n        svint32_t sv_out = svadd_s32_x(pg, sv_in, 1);\n        svst1_s32(pg, &result[i], sv_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_in = svld1_s32(pg, &l[i]);\n        svint32_t sv_out = svadd_n_s32_x(pg, sv_in, 1);\n        svst1_s32(pg, &result[i], sv_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_in = svld1_s32(pg, &l[i]);\n        svint32_t sv_out = svadd_s32_x(pg, sv_in, 1);\n        svst1_s32(pg, &result[i], sv_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_in = svld1_s32(pg, &l[i]);\n        svint32_t sv_out = svadd_s32_x(pg, sv_in, 1);\n        svst1_s32(pg, &result[i], sv_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  if (l.size() < 2)\n    return false;\n\n  for (size_t i = 0; i < l.size(); ++i) {\n    for (size_t j = i + 1; j < l.size(); ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  if (l.size() < 2)\n    return false;\n\n  for (size_t i = 0; i < l.size(); ++i) {\n    for (size_t j = i + 1; j < l.size(); ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  if (l.size() < 2) {\n    return false;\n  }\n\n  for (size_t i = 0; i < l.size(); ++i) {\n    for (size_t j = i + 1; j < l.size(); ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  if (l.size() < 2)\n    return false;\n\n  for (size_t i = 0; i < l.size(); ++i) {\n    for (size_t j = i + 1; j < l.size(); ++j) {\n      if (l[i] + l[j] == 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n  if (l.size() < 2)\n    return false;\n\n  for (size_t i = 0; i < l.size(); ++i) {\n    for (size_t j = i + 1; j < l.size(); ++j) {\n      if (l[i] + l[j] == 0)\n        return true;\n    }\n  }\n\n  return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n  if (x == 0) {\n    return \"0\";\n  }\n\n  std::string result = \"\";\n  while (x > 0) {\n    int8_t remainder = x % base;\n    result += std::to_string(remainder);\n    x /= base;\n  }\n\n  std::reverse(result.begin(), result.end());\n  return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t i = 0;\n  size_t j = len - 1;\n\n  while (i < j) {\n    if (text[i] != text[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t n = text.length();\n  if (n <= 1) return true;\n\n  size_t l = 0;\n  size_t r = n - 1;\n\n  while (l < r) {\n    svbool_t pg = svwhilelt_b8(l, r);\n    if (svptest_any(pg, pg)) {\n      if (text[l] != text[r]) {\n        return false;\n      }\n      l++;\n      r--;\n    } else {\n      break;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t n = text.length();\n  if (n <= 1) return true;\n\n  size_t l = 0;\n  size_t r = n - 1;\n\n  while (l < r) {\n    svbool_t pg = svwhilelt_b8(l, r);\n    if (svptest_any(pg, pg)) {\n      if (text[l] != text[r]) {\n        return false;\n      }\n      l++;\n      r--;\n    } else {\n      break;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t n = text.length();\n  if (n <= 1) return true;\n\n  size_t l = 0;\n  size_t r = n - 1;\n\n  while (l < r) {\n    svbool_t pg = svwhilelt_b8(l, r);\n    if (svptest_any(pg, pg)) {\n      if (text[l] != text[r]) {\n        return false;\n      }\n      l++;\n      r--;\n    } else {\n      break;\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n  size_t len = text.length();\n  if (len <= 1) {\n    return true;\n  }\n\n  size_t head = 0;\n  size_t tail = len - 1;\n\n  while (head < tail) {\n    if (text[head] != text[tail]) {\n      return false;\n    }\n    head++;\n    tail--;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    size_t len = s.length();\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, (int64_t)len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8((int64_t)i, (int64_t)len);\n        svuint8_t sv_str = svld1_u8(pg, s.data() + i);\n        svint8_t sv_int = svreinterpret_s8_u8(sv_str);\n        svint8_t sv_a = svdup_s8((int8_t)'a');\n        svint8_t sv_z = svdup_s8((int8_t)'z');\n        svint8_t sv_26 = svdup_s8((int8_t)26);\n        svint8_t sv_5 = svdup_s8((int8_t)5);\n\n        svint8_t shifted = svsub_s8(sv_int, sv_5);\n        svint8_t diff = svsub_s8(shifted, sv_a);\n        svbool_t lower = svcmpge_s8(pg, shifted, sv_a);\n        svbool_t upper = svcmple_s8(pg, shifted, sv_z);\n        svbool_t alpha = svand_b8(lower, upper);\n\n        svint8_t result = svsel_s8(alpha, svadd_s8(svmod_s8(diff, sv_26), sv_a), shifted);\n        svuint8_t sv_out = svreinterpret_u8_s8(result);\n        svst1_u8(pg, (unsigned char*)out.data() + i, sv_out);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int64_t length = s.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t sv_chars = svld1_s8(pg, &s[i]);\n        svint8_t sv_a = svdup_s8('a');\n        svint8_t sv_26 = svdup_s8(26);\n        svint8_t sv_5 = svdup_s8(5);\n\n        svint8_t shifted = svsub_s8(sv_chars, sv_5);\n        svint8_t diff = svsub_s8(shifted, sv_a);\n        svint8_t mod = svmod_s8(diff, sv_26);\n        svint8_t decoded = svadd_s8(mod, sv_a);\n\n        svst1_s8(pg, &out[i], decoded);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    size_t len = s.length();\n    size_t vector_length = svcntb();\n\n    for (size_t i = 0; i < len; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svint8_t sv_chars = svld1_s8(pg, &s[i]);\n        svint8_t sv_ints = svadd_s8_x(pg, sv_chars, -5);\n        svint8_t sv_a = svdup_s8('a');\n        svint8_t sv_z = svdup_s8('z');\n        svint8_t sv_26 = svdup_s8(26);\n\n        svbool_t lower_than_a = svcmpge_s8(pg, sv_ints, sv_a);\n        svint8_t shifted_ints = svsel_s8(lower_than_a, svadd_s8_x(pg, sv_ints, sv_26), sv_ints);\n\n        svbool_t greater_than_z = svcmple_s8(pg, shifted_ints, sv_z);\n        svint8_t final_ints = svsel_s8(greater_than_z, shifted_ints, sv_ints);\n\n        svst1_s8(pg, &out[i], final_ints);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    size_t len = s.length();\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, (int64_t)len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8((int64_t)i, (int64_t)len);\n        svuint8_t sv_str = svld1_u8(pg, s.data() + i);\n        svint8_t sv_int = svreinterpret_s8_u8(sv_str);\n        svint8_t sv_a = svdup_s8((int8_t)'a');\n        svint8_t sv_26 = svdup_s8((int8_t)26);\n        svint8_t sv_5 = svdup_s8((int8_t)5);\n\n        svint8_t sv_shifted = svsub_s8(sv_int, sv_5);\n        svint8_t sv_diff = svsub_s8(sv_shifted, sv_a);\n        svint8_t sv_mod = svmod_s8(sv_diff, sv_26);\n        svint8_t sv_res = svadd_s8(sv_mod, sv_a);\n\n        svuint8_t sv_out = svreinterpret_u8_s8(sv_res);\n        svst1_u8(pg, (unsigned char*)out.data() + i, sv_out);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    size_t len = s.length();\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, (int64_t)len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8((int64_t)i, (int64_t)len);\n        svuint8_t sv_str = svld1_u8(pg, s.data() + i);\n        svint8_t sv_int = svreinterpret_s8_u8(sv_str);\n        svint8_t sv_a = svdup_s8((int8_t)'a');\n        svint8_t sv_z = svdup_s8((int8_t)'z');\n        svint8_t sv_26 = svdup_s8((int8_t)26);\n        svint8_t sv_5 = svdup_s8((int8_t)5);\n\n        svint8_t shifted = svsub_s8(sv_int, sv_5);\n        svint8_t diff = svsub_s8(shifted, sv_a);\n        svbool_t lower = svcmpge_s8(pg, shifted, sv_a);\n        svbool_t upper = svcmple_s8(pg, shifted, sv_z);\n        svbool_t alpha = svand_b8(lower, upper);\n\n        svint8_t result = svsel_s8(alpha, svadd_s8(svmod_s8(diff, sv_26), sv_a), shifted);\n\n        svuint8_t sv_out = svreinterpret_u8_s8(result);\n        svst1_u8(pg, (unsigned char*)out.data() + i, sv_out);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    bool result = true;\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n        svbool_t lt = svcmplt_s32(pg, sv_l, t);\n        if (!svptest_any(pg, lt)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    bool result = true;\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n        svbool_t lt = svcmplt_s32(pg, sv_l, t);\n        if (!svptest_any(pg, lt)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    bool result = true;\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n        svbool_t lt = svcmplt_s32(pg, sv_l, t);\n        if (!svptest_any(pg, lt)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    bool result = true;\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n        svbool_t lt = svcmplt_s32(pg, sv_l, t);\n        if (!svptest_any(pg, lt)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    bool result = true;\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_l = svld1_s32(pg, &l[i]);\n        svbool_t lt = svcmplt_s32(pg, sv_l, t);\n        if (!svptest_any(pg, lt)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    size_t n = brackets.length();\n    for (size_t i = 0; i < n; ++i) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        char current_char = brackets[i];\n        if (current_char == '<') {\n            balance++;\n        } else if (current_char == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  int balance = 0;\n  size_t n = brackets.length();\n  size_t vl = svcntb();\n\n  for (size_t i = 0; i < n; i += vl) {\n    svbool_t pg = svwhilelt_b8(i, n);\n    svint8_t str = svld1_s8(pg, brackets.data() + i);\n\n    svbool_t open_mask = svcmpeq(pg, str, '<');\n    svbool_t close_mask = svcmpeq(pg, str, '>');\n\n    int open_count = svcntp_b8(pg, open_mask);\n    int close_count = svcntp_b8(pg, close_mask);\n\n    balance += open_count - close_count;\n\n    if (balance < 0) {\n      return false;\n    }\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  int balance = 0;\n  size_t n = brackets.length();\n\n  if (n == 0) return true;\n\n  for (size_t i = 0; i < n; ++i) {\n    if (brackets[i] == '<') {\n      balance++;\n    } else if (brackets[i] == '>') {\n      balance--;\n    }\n    if (balance < 0) return false;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n  int balance = 0;\n  size_t n = brackets.length();\n\n  if (n == 0) return true;\n\n  for (size_t i = 0; i < n; ++i) {\n    if (brackets[i] == '<') {\n      balance++;\n    } else if (brackets[i] == '>') {\n      balance--;\n    }\n    if (balance < 0) return false;\n  }\n\n  return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    size_t n = brackets.length();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svint8_t str = svld1_s8(pg, brackets.data() + i);\n\n        svbool_t open_mask = svcmpne_s8(pg, str, svdup_s8('<'));\n        svbool_t close_mask = svcmpne_s8(pg, str, svdup_s8('>'));\n\n        int opens = svcntp_s8(open_mask, pg);\n        int closes = svcntp_s8(close_mask, pg);\n\n        balance += opens;\n        balance -= closes;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (int i = 0; i < len; i += vl) {\n        int count = std::min((size_t)len - i, vl);\n        char current_chars[vl];\n        for (int j = 0; j < count; ++j) {\n            current_chars[j] = brackets[i + j];\n        }\n        for (int j = count; j < vl; ++j) {\n            current_chars[j] = '\\0'; \n        }\n\n        svint8_t chars = svld1_s8(pg, current_chars);\n\n        svbool_t open_mask = svcmpeq(pg, chars, svdup_s8((int8_t)'('));\n        svbool_t close_mask = svcmpeq(pg, chars, svdup_s8((int8_t)')'));\n\n        int open_count = svcntp_b8(pg, open_mask);\n        int close_count = svcntp_b8(pg, close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n    int i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8((int64_t)i, (int64_t)len);\n        int8_t sv_brackets = svld1_s8(pg, brackets.data() + i);\n\n        svbool_t open_mask = svcmpeq(pg, sv_brackets, (int8_t)'(');\n        svbool_t close_mask = svcmpeq(pg, sv_brackets, (int8_t)')');\n\n        int open_count = svcntp_b8(open_mask);\n        int close_count = svcntp_b8(close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n\n        i += svcntw();\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n    int i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8((int64_t)i, (int64_t)len);\n        int8_t sv_brackets = svld1_s8(pg, brackets.data() + i);\n\n        svbool_t open_mask = svcmpne_s8(pg, sv_brackets, '(');\n        svbool_t close_mask = svcmpne_s8(pg, sv_brackets, ')');\n\n        int open_count = svcntp_b8(pg, open_mask);\n        int close_count = svcntp_b8(pg, close_mask);\n\n        balance += close_count - open_count;\n\n        if (balance < 0) {\n            return false;\n        }\n\n        i += svcntw();\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    svbool_t pg = svwhilelt_b8((int8_t)0, len);\n    for (int i = 0; i < len; i += svcntb()) {\n        int size = std::min((int)svcntb(), len - i);\n        svint8_t sv_brackets = svld1_s8(pg, brackets.data() + i);\n        for (int j = 0; j < size; ++j) {\n            if (brackets[i+j] == '(') {\n                balance++;\n            } else if (brackets[i+j] == ')') {\n                balance--;\n            }\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int len = brackets.length();\n\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    for (int i = 0; i < len; i += svcntb()) {\n        int count = std::min((int)svcntb(), len - i);\n        svint8_t sv_brackets = svld1_s8(pg, brackets.data() + i);\n\n        for (int j = 0; j < count; ++j) {\n            if (brackets[i+j] == '(') {\n                balance++;\n            } else if (brackets[i+j] == ')') {\n                balance--;\n            }\n            if (balance < 0) return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i < n - 1 - (n - 1) % vl; i += vl) {\n        svfloat32_t x = svld1_f32(svptrue_b32(), &xs[i + 1]);\n        svfloat32_t indices = svindex_f32(0, 1);\n        svfloat32_t derivative_vec = svmul_f32_x(svptrue_b32(), x, indices);\n        svst1_f32(svptrue_b32(), &result[i], derivative_vec);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n  size_t n = xs.size();\n  if (n <= 1) {\n    return {};\n  }\n\n  std::vector<float> result(n - 1);\n\n  size_t vl = svcntw();\n  size_t i = 0;\n\n  for (; i < n - 1 - (n - 1) % vl; i += vl) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t x = svld1(pg, &xs[i + 1]);\n    svfloat32_t indices = svfloat32_n(i + 1);\n    svfloat32_t res = svmul_f32_x(pg, x, indices);\n    svst1(pg, &result[i], res);\n  }\n\n  for (; i < n - 1; ++i) {\n    result[i] = xs[i + 1] * (i + 1);\n  }\n\n  return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<float> result(n - 1);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, n);\n    for (int i = 0; i < n; i += svcntb()) {\n        svint8_t str = svld1_s8(pg, s.data() + i);\n        svint8_t a = svdup_s8('a');\n        svint8_t e = svdup_s8('e');\n        svint8_t ii = svdup_s8('i');\n        svint8_t o = svdup_s8('o');\n        svint8_t u = svdup_s8('u');\n\n        svbool_t eq_a = sveq_s8(str, a);\n        svbool_t eq_e = sveq_s8(str, e);\n        svbool_t eq_i = sveq_s8(str, ii);\n        svbool_t eq_o = sveq_s8(str, o);\n        svbool_t eq_u = sveq_s8(str, u);\n\n        svbool_t vowels = svorr_z(pg, eq_a, eq_e);\n        vowels = svorr_z(pg, vowels, eq_i);\n        vowels = svorr_z(pg, vowels, eq_o);\n        vowels = svorr_z(pg, vowels, eq_u);\n        \n        count += svcntp_b8(pg, vowels);\n        pg = svwhilelt_b8((int64_t)(i + svcntb()), n);\n    }\n    if (s[n-1] == 'y' || s[n-1] == 'Y') count++;\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    for (int i = 0; i < n; i += svcntb()) {\n        svint8_t str = svld1_s8(pg, s.data() + i);\n        svint8_t a = svdup_n_s8('a');\n        svint8_t e = svdup_n_s8('e');\n        svint8_t ii = svdup_n_s8('i');\n        svint8_t o = svdup_n_s8('o');\n        svint8_t u = svdup_n_s8('u');\n\n        svbool_t eq_a = sveq_s8(str, a);\n        svbool_t eq_e = sveq_s8(str, e);\n        svbool_t eq_i = sveq_s8(str, ii);\n        svbool_t eq_o = sveq_s8(str, o);\n        svbool_t eq_u = sveq_s8(str, u);\n\n        svint8_t A = svdup_n_s8('A');\n        svint8_t E = svdup_n_s8('E');\n        svint8_t I = svdup_n_s8('I');\n        svint8_t O = svdup_n_s8('O');\n        svint8_t U = svdup_n_s8('U');\n\n        svbool_t eq_A = sveq_s8(str, A);\n        svbool_t eq_E = sveq_s8(str, E);\n        svbool_t eq_I = sveq_s8(str, I);\n        svbool_t eq_O = sveq_s8(str, O);\n        svbool_t eq_U = sveq_s8(str, U);\n\n        svbool_t is_vowel = svorr_z(pg, eq_a, eq_e);\n        is_vowel = svorr_z(pg, is_vowel, eq_i);\n        is_vowel = svorr_z(pg, is_vowel, eq_o);\n        is_vowel = svorr_z(pg, is_vowel, eq_u);\n        is_vowel = svorr_z(pg, is_vowel, eq_A);\n        is_vowel = svorr_z(pg, is_vowel, eq_E);\n        is_vowel = svorr_z(pg, is_vowel, eq_I);\n        is_vowel = svorr_z(pg, is_vowel, eq_O);\n        is_vowel = svorr_z(pg, is_vowel, eq_U);\n\n        int cnt = svcntb();\n        for (int j = 0; j < cnt && i + j < n; ++j) {\n            if (svptest_first(pg, svindex_b_s8(0, 1), svext_n_s8(str, str, j), is_vowel)) {\n                count++;\n            }\n        }\n    }\n\n    if (s[n - 1] == 'y' || s[n - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, n);\n    for (int i = 0; i < n; i += svcntb()) {\n        svint8_t str = svld1_s8(pg, s.data() + i);\n        svint8_t a = svdup_n_s8('a');\n        svint8_t e = svdup_n_s8('e');\n        svint8_t ii = svdup_n_s8('i');\n        svint8_t o = svdup_n_s8('o');\n        svint8_t u = svdup_n_s8('u');\n\n        svbool_t eq_a = sveq_s8(str, a);\n        svbool_t eq_e = sveq_s8(str, e);\n        svbool_t eq_i = sveq_s8(str, ii);\n        svbool_t eq_o = sveq_s8(str, o);\n        svbool_t eq_u = sveq_s8(str, u);\n\n        svint8_t A = svdup_n_s8('A');\n        svint8_t E = svdup_n_s8('E');\n        svint8_t I = svdup_n_s8('I');\n        svint8_t O = svdup_n_s8('O');\n        svint8_t U = svdup_n_s8('U');\n\n        svbool_t eq_A = sveq_s8(str, A);\n        svbool_t eq_E = sveq_s8(str, E);\n        svbool_t eq_I = sveq_s8(str, I);\n        svbool_t eq_O = sveq_s8(str, O);\n        svbool_t eq_U = sveq_s8(str, U);\n\n        count += svcntp_b8(pg, eq_a);\n        count += svcntp_b8(pg, eq_e);\n        count += svcntp_b8(pg, eq_i);\n        count += svcntp_b8(pg, eq_o);\n        count += svcntp_b8(pg, eq_u);\n        count += svcntp_b8(pg, eq_A);\n        count += svcntp_b8(pg, eq_E);\n        count += svcntp_b8(pg, eq_I);\n        count += svcntp_b8(pg, eq_O);\n        count += svcntp_b8(pg, eq_U);\n\n        pg = svwhilelt_b8((int64_t)(i + svcntb()), n);\n    }\n    if (s[n - 1] == 'y' || s[n - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    for (int i = 0; i < n; i += svcntb()) {\n        svint8_t str = svld1_s8(pg, s.data() + i);\n\n        svbool_t a_mask = sveceq_s8(str, 'a');\n        svbool_t e_mask = sveceq_s8(str, 'e');\n        svbool_t i_mask = sveceq_s8(str, 'i');\n        svbool_t o_mask = sveceq_s8(str, 'o');\n        svbool_t u_mask = sveceq_s8(str, 'u');\n\n        svbool_t vowel_mask = svorr_z(pg, a_mask, e_mask);\n        vowel_mask = svorr_z(pg, vowel_mask, i_mask);\n        vowel_mask = svorr_z(pg, vowel_mask, o_mask);\n        vowel_mask = svorr_z(pg, vowel_mask, u_mask);\n\n        int num_vowels = svcntp_b8(pg, vowel_mask);\n        count += num_vowels;\n\n        int current_length = std::min((int)svcntb(), n - i);\n        if (i + current_length == n) {\n            if (s[n - 1] == 'y') {\n                count++;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        s[i] = tolower(s[i]);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int n = s.length();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8((int64_t)0, n);\n    for (int i = 0; i < n; i += svcntb()) {\n        svint8_t str = svld1_s8(pg, s.data() + i);\n        svint8_t a = svdup_n_s8('a');\n        svint8_t e = svdup_n_s8('e');\n        svint8_t ii = svdup_n_s8('i');\n        svint8_t o = svdup_n_s8('o');\n        svint8_t u = svdup_n_s8('u');\n\n        svbool_t eq_a = sveq_s8(str, a);\n        svbool_t eq_e = sveq_s8(str, e);\n        svbool_t eq_i = sveq_s8(str, ii);\n        svbool_t eq_o = sveq_s8(str, o);\n        svbool_t eq_u = sveq_s8(str, u);\n\n        svint8_t A = svdup_n_s8('A');\n        svint8_t E = svdup_n_s8('E');\n        svint8_t I = svdup_n_s8('I');\n        svint8_t O = svdup_n_s8('O');\n        svint8_t U = svdup_n_s8('U');\n\n        svbool_t eq_A = sveq_s8(str, A);\n        svbool_t eq_E = sveq_s8(str, E);\n        svbool_t eq_I = sveq_s8(str, I);\n        svbool_t eq_O = sveq_s8(str, O);\n        svbool_t eq_U = sveq_s8(str, U);\n\n        count += svcntp_b8(pg, eq_a);\n        count += svcntp_b8(pg, eq_e);\n        count += svcntp_b8(pg, eq_i);\n        count += svcntp_b8(pg, eq_o);\n        count += svcntp_b8(pg, eq_u);\n        count += svcntp_b8(pg, eq_A);\n        count += svcntp_b8(pg, eq_E);\n        count += svcntp_b8(pg, eq_I);\n        count += svcntp_b8(pg, eq_O);\n        count += svcntp_b8(pg, eq_U);\n\n        pg = svincb_b8(pg, svcntb());\n        if (!svptest_any(svptrue_b8(), pg))\n            break;\n    }\n\n    if (s[n - 1] == 'y' || s[n - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  int sum = 0;\n  int len = s.length();\n\n  if (len == 0) {\n    return 0;\n  }\n\n  for (int i = 0; i < len; ++i) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      sum += s[i];\n    }\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  int sum = 0;\n  int n = s.length();\n  for (int i = 0; i < n; ++i) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      sum += s[i];\n    }\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  int sum = 0;\n  int n = s.length();\n\n  if (n == 0) {\n    return 0;\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      sum += s[i];\n    }\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  int sum = 0;\n  int64_t length = s.length();\n\n  if (length == 0) {\n    return 0;\n  }\n\n  svbool_t pg = svwhilelt_b8(0, length);\n  int64_t i = 0;\n\n  for (; i < length - svcntb(); i += svcntb()) {\n    pg = svwhilelt_b8(i, length);\n    svint8_t str_vec = svld1_s8(pg, s.data() + i);\n    svbool_t upper_mask = svand_b8(pg, svele_b8(svcmpge_s8(pg, str_vec, 'A'), 0));\n    upper_mask = svand_b8(upper_mask, svele_b8(svcmple_s8(pg, str_vec, 'Z'), 0));\n    svint8_t masked_vec = svsel_s8(upper_mask, str_vec, 0);\n    sum += svaddv_s8(pg, masked_vec);\n  }\n\n  for (; i < length; ++i) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      sum += s[i];\n    }\n  }\n\n  return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n  int sum = 0;\n  int n = s.length();\n  for (int i = 0; i < n; ++i) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      sum += s[i];\n    }\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n  if (arr.empty()) {\n    return {};\n  }\n\n  int smallest_even = -1;\n  int smallest_index = -1;\n\n  for (int i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0) {\n      if (smallest_even == -1 || arr[i] < smallest_even) {\n        smallest_even = arr[i];\n        smallest_index = i;\n      }\n    }\n  }\n\n  if (smallest_even == -1) {\n    return {};\n  }\n\n  return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    }\n\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (val <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < n; ++j) {\n            if (lst[j] == val) {\n                count++;\n            }\n        }\n\n        if (count >= val && val > max_val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int freq = 0;\n        for (int j = 0; j < n; ++j) {\n            if (lst[j] == num) {\n                freq++;\n            }\n        }\n\n        if (freq >= num && num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < n; ++j) {\n            if (lst[j] == num) {\n                count++;\n            }\n        }\n\n        if (count >= num && num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int num = lst[i];\n        if (num <= 0) continue;\n\n        int freq = 0;\n        for (int j = 0; j < n; ++j) {\n            if (lst[j] == num) {\n                freq++;\n            }\n        }\n\n        if (freq >= num && num > max_val) {\n            max_val = num;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int n = lst.size();\n\n    for (int i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (val <= 0) continue;\n\n        int count = 0;\n        for (int j = 0; j < n; ++j) {\n            if (lst[j] == val) {\n                count++;\n            }\n        }\n\n        if (count >= val && val > max_val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  int n = q.size();\n  if (n == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (int i = 0; i < n / 2; ++i) {\n    if (q[i] != q[n - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using SVE\n  int sum = 0;\n  int i = 0;\n\n  svbool_t pg = svwhilelt_b32(i, n);\n  for (; svptest_any(pg, pg); i += svcntw(), pg = svwhilelt_b32(i, n)) {\n    svint32_t vec = svld1_s32(pg, &q[i]);\n    sum += svaddv_s32(pg, vec);\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  int n = q.size();\n  if (n == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (int i = 0; i < n / 2; ++i) {\n    if (q[i] != q[n - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements\n  int sum = 0;\n  svbool_t pg = svptrue_b32();\n  int i = 0;\n  for (; i < n - n % svcntw(); i += svcntw()) {\n    svint32_t vec = svld1_s32(pg, &q[i]);\n    sum += svaddv_s32(pg, vec);\n  }\n  for (; i < n; ++i) {\n    sum += q[i];\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  int n = q.size();\n  if (n == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (int i = 0; i < n / 2; ++i) {\n    if (q[i] != q[n - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate sum using SVE\n  int sum = 0;\n  int vl = svcntw();\n  int num_vectors = (n + vl - 1) / vl;\n\n  for (int i = 0; i < num_vectors; ++i) {\n    svbool_t pg = svwhilelt_b32(i * vl, n);\n    svint32_t vec = svld1_s32(pg, &q[std::min(i * vl, n - 1)]); \n    sum += svaddv_s32(pg, vec);\n  }\n\n  // Check if sum is less than or equal to w\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  int n = q.size();\n  if (n == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (int i = 0; i < n / 2; ++i) {\n    if (q[i] != q[n - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements\n  int sum = 0;\n  svbool_t pg = svptrue_b32();\n  int i = 0;\n\n  for (; i < n - n % svcntw(); i += svcntw()) {\n    svint32_t vec = svld1_s32(pg, &q[i]);\n    sum += svaddv_s32(pg, vec);\n  }\n    \n  for (; i < n; ++i) {\n        sum += q[i];\n  }\n\n  // Check if the sum is within the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n  int n = q.size();\n  if (n == 0) return false;\n\n  // Check if balanced (palindromic)\n  for (int i = 0; i < n / 2; ++i) {\n    if (q[i] != q[n - 1 - i]) {\n      return false;\n    }\n  }\n\n  // Calculate the sum of elements using SVE\n  svbool_t pg = svptrue_b32();\n  svint32_t sum_vec = svdup_n_s32(0);\n  \n  int i = 0;\n  for (; i < n - n % svcntw(); i += svcntw()) {\n      svint32_t data_vec = svld1(pg, &q[i]);\n      sum_vec = svadd_s32_z(pg, sum_vec, data_vec);\n  }\n\n  int sum = svaddv_s32(pg, sum_vec);\n  for(; i < n; ++i){\n      sum += q[i];\n  }\n\n  // Check if the sum is less than or equal to the maximum weight\n  return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n  int n = arr.size();\n  int changes = 0;\n\n  for (int i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n\n  return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n  int n = arr.size();\n  int changes = 0;\n\n  for (int i = 0; i < n / 2; ++i) {\n    if (arr[i] != arr[n - 1 - i]) {\n      changes++;\n    }\n  }\n\n  return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    size_t total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    size_t total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    size_t total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    size_t total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    size_t total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_u64(0, svcntd());\n    uint64_t current_power = 1;\n\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n\n        if (x / n < current_power) {\n            return false;\n        }\n        \n        if (__builtin_umull_overflow(current_power, n, &current_power)) {\n            return false;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_u64(0, svcntw());\n    uint64_t current_power = 1;\n\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power)\n        {\n            return false;\n        }\n        current_power *= n;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_u64(0, svcntd());\n    uint64_t current_power = 1;\n\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power) {\n            return false;\n        }\n        current_power *= n;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_u64(0, svcntd());\n    uint64_t current_power = 1;\n\n    while (current_power <= x) {\n        if (current_power == x) {\n            return true;\n        }\n        if (x / n < current_power)\n        {\n            return false;\n        }\n        current_power *= n;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    int count = 0;\n    int64_t length = num.length();\n\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b8();\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        int64_t remaining = length - i;\n        pg = svwhilelt_b8(i, length);\n\n        svint8_t sv_digits = svld1_s8(pg, num.data() + i);\n        svint8_t sv_prime_mask = svdup_s8(0);\n\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('2')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('3')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('5')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('7')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('B')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq(pg, sv_digits, svdup_s8('D')), svdup_s8(1), sv_prime_mask);\n\n        count += svcntp_b8(pg, sv_prime_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int64_t length = num.length();\n\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svint8_t sv_hex_digits = svld1_s8(pg, num.data() + i);\n\n        svbool_t prime_mask_2 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('2'));\n        svbool_t prime_mask_3 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('3'));\n        svbool_t prime_mask_5 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('5'));\n        svbool_t prime_mask_7 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('7'));\n        svbool_t prime_mask_b = svcmpeq(pg, sv_hex_digits, svdup_n_s8('B'));\n        svbool_t prime_mask_d = svcmpeq(pg, sv_hex_digits, svdup_n_s8('D'));\n\n        count += svcntp_b8(pg, prime_mask_2);\n        count += svcntp_b8(pg, prime_mask_3);\n        count += svcntp_b8(pg, prime_mask_5);\n        count += svcntp_b8(pg, prime_mask_7);\n        count += svcntp_b8(pg, prime_mask_b);\n        count += svcntp_b8(pg, prime_mask_d);\n\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int64_t length = num.length();\n\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svint8_t sv_hex_digits = svld1_s8(pg, num.data() + i);\n\n        svbool_t prime_mask_2 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('2'));\n        svbool_t prime_mask_3 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('3'));\n        svbool_t prime_mask_5 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('5'));\n        svbool_t prime_mask_7 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('7'));\n        svbool_t prime_mask_b = svcmpeq(pg, sv_hex_digits, svdup_n_s8('B'));\n        svbool_t prime_mask_d = svcmpeq(pg, sv_hex_digits, svdup_n_s8('D'));\n\n        count += svcntp_b8(pg, prime_mask_2);\n        count += svcntp_b8(pg, prime_mask_3);\n        count += svcntp_b8(pg, prime_mask_5);\n        count += svcntp_b8(pg, prime_mask_7);\n        count += svcntp_b8(pg, prime_mask_b);\n        count += svcntp_b8(pg, prime_mask_d);\n\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int64_t length = num.length();\n\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svint8_t sv_hex_digits = svld1_s8(pg, num.data() + i);\n        svint8_t sv_prime_mask = svdup_s8(0);\n\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('2')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('3')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('5')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('7')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('B')), svdup_s8(1), sv_prime_mask);\n        sv_prime_mask = svsel_s8(svcmpeq_s8(pg, sv_hex_digits, svdup_s8('D')), svdup_s8(1), sv_prime_mask);\n\n        count += svcntp_b8(pg, sv_prime_mask);\n\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int64_t length = num.length();\n\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svint8_t sv_hex_digits = svld1_s8(pg, num.data() + i);\n\n        svbool_t prime_mask_2 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('2'));\n        svbool_t prime_mask_3 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('3'));\n        svbool_t prime_mask_5 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('5'));\n        svbool_t prime_mask_7 = svcmpeq(pg, sv_hex_digits, svdup_n_s8('7'));\n        svbool_t prime_mask_b = svcmpeq(pg, sv_hex_digits, svdup_n_s8('B'));\n        svbool_t prime_mask_d = svcmpeq(pg, sv_hex_digits, svdup_n_s8('D'));\n\n        count += svcntp_b8(pg, prime_mask_2);\n        count += svcntp_b8(pg, prime_mask_3);\n        count += svcntp_b8(pg, prime_mask_5);\n        count += svcntp_b8(pg, prime_mask_7);\n        count += svcntp_b8(pg, prime_mask_b);\n        count += svcntp_b8(pg, prime_mask_d);\n\n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    int n = s.length();\n    if (n < 3) return false;\n\n    for (int i = 0; i <= n - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    svbool_t pg = svwhilelt_b32(0, (int32_t)sqrt(n));\n    \n    for (int i = 5; i * i <= n; i = i + 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n  int n = str.length();\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n\n  for (int i = 5; i * i <= n; i = i + 6) {\n    if (n % i == 0 || n % (i + 2) == 0)\n      return false;\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n    int n = str.length();\n\n    if (n <= 1) return false;\n\n    if (n <= 3) return true;\n\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    size_t n = lst.size();\n    for (size_t i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int n = lst.size();\n    int sum = 0;\n    for (int i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    size_t n = lst.size();\n    for (size_t i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    size_t n = lst.size();\n    for (size_t i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result[i] = (char)(((c - base + 4) % 26) + base);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            encrypted_string[i] = (char)(((c - base + 4) % 26) + base);\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string encrypted_string = s;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            encrypted_string[i] = (char)(((c - base + 4) % 26) + base);\n        }\n    }\n\n    return encrypted_string;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result[i] = (char)(((c - base + 4) % 26) + base);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result[i] = (char)(((c - base + 4) % 26) + base);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int64_t length = message.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t str = svld1_s8(pg, message.data() + i);\n\n        svint8_t lower = svtolower_s8(str);\n        svint8_t upper = svtoupper_s8(str);\n\n        svbool_t is_lower = svcmpeq(pg, str, lower);\n        svbool_t is_upper = svcmpeq(pg, str, upper);\n\n        str = svsel(is_lower, upper, str);\n        str = svsel(is_upper, lower, str);\n\n        svbool_t is_vowel_a = svcmpeq(pg, str, 'a');\n        svbool_t is_vowel_e = svcmpeq(pg, str, 'e');\n        svbool_t is_vowel_i = svcmpeq(pg, str, 'i');\n        svbool_t is_vowel_o = svcmpeq(pg, str, 'o');\n        svbool_t is_vowel_u = svcmpeq(pg, str, 'u');\n        svbool_t is_vowel_A = svcmpeq(pg, str, 'A');\n        svbool_t is_vowel_E = svcmpeq(pg, str, 'E');\n        svbool_t is_vowel_I = svcmpeq(pg, str, 'I');\n        svbool_t is_vowel_O = svcmpeq(pg, str, 'O');\n        svbool_t is_vowel_U = svcmpeq(pg, str, 'U');\n\n        str = svsel(is_vowel_a, 'c', str);\n        str = svsel(is_vowel_e, 'g', str);\n        str = svsel(is_vowel_i, 'k', str);\n        str = svsel(is_vowel_o, 'q', str);\n        str = svsel(is_vowel_u, 'w', str);\n        str = svsel(is_vowel_A, 'C', str);\n        str = svsel(is_vowel_E, 'G', str);\n        str = svsel(is_vowel_I, 'K', str);\n        str = svsel(is_vowel_O, 'Q', str);\n        str = svsel(is_vowel_U, 'W', str);\n\n        svst1_s8(pg, encoded_message.data() + i, str);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int64_t length = message.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t sv_message = svld1_s8(pg, message.data() + i);\n\n        // Swap case\n        svint8_t upper_mask = svand_n_s8(sv_message, 0b11011111);\n        svint8_t lower_mask = svorr_n_s8(sv_message, 0b00100000);\n        svint8_t is_lower = svcmplt_n_s8(sv_message, 'a');\n        svint8_t is_upper = svcmplt_n_s8(sv_message, 'A');\n        is_lower = sveor_n_b8(is_lower, 1);\n        is_upper = sveor_n_b8(is_upper, 1);\n        svint8_t case_swapped = svsel_s8(svand_s8(is_lower, is_upper), sv_message, svsel_s8(is_lower, upper_mask, lower_mask));\n\n        // Replace vowels\n        svint8_t a_mask = svcmpeq_n_s8(case_swapped, 'a');\n        svint8_t e_mask = svcmpeq_n_s8(case_swapped, 'e');\n        svint8_t i_mask = svcmpeq_n_s8(case_swapped, 'i');\n        svint8_t o_mask = svcmpeq_n_s8(case_swapped, 'o');\n        svint8_t u_mask = svcmpeq_n_s8(case_swapped, 'u');\n\n        case_swapped = svsel_s8(a_mask, svdup_n_s8('c'), case_swapped);\n        case_swapped = svsel_s8(e_mask, svdup_n_s8('g'), case_swapped);\n        case_swapped = svsel_s8(i_mask, svdup_n_s8('k'), case_swapped);\n        case_swapped = svsel_s8(o_mask, svdup_n_s8('q'), case_swapped);\n        case_swapped = svsel_s8(u_mask, svdup_n_s8('w'), case_swapped);\n        \n        a_mask = svcmpeq_n_s8(case_swapped, 'A');\n        e_mask = svcmpeq_n_s8(case_swapped, 'E');\n        i_mask = svcmpeq_n_s8(case_swapped, 'I');\n        o_mask = svcmpeq_n_s8(case_swapped, 'O');\n        u_mask = svcmpeq_n_s8(case_swapped, 'U');\n\n        case_swapped = svsel_s8(a_mask, svdup_n_s8('C'), case_swapped);\n        case_swapped = svsel_s8(e_mask, svdup_n_s8('G'), case_swapped);\n        case_swapped = svsel_s8(i_mask, svdup_n_s8('K'), case_swapped);\n        case_swapped = svsel_s8(o_mask, svdup_n_s8('Q'), case_swapped);\n        case_swapped = svsel_s8(u_mask, svdup_n_s8('W'), case_swapped);\n\n        svst1_s8(pg, encoded_message.data() + i, case_swapped);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int64_t length = message.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t sv_message = svld1_s8(pg, message.data() + i);\n\n        // Swap case\n        svint8_t upper_mask = svdup_s8(65 - 1); \n        svint8_t lower_mask = svdup_s8(97 - 1);\n        svint8_t case_diff = svdup_s8(32);\n\n        svbool_t is_upper = svcmpge_s8(pg, sv_message, upper_mask);\n        is_upper = svand_b8(is_upper, svcmple_s8(pg, sv_message, svdup_s8(90)));\n\n        svbool_t is_lower = svcmpge_s8(pg, sv_message, lower_mask);\n        is_lower = svand_b8(is_lower, svcmple_s8(pg, sv_message, svdup_s8(122)));\n\n        sv_message = svsel_s8(is_upper, sveor_s8(sv_message, case_diff), sv_message);\n        sv_message = svsel_s8(is_lower, sveor_s8(sv_message, case_diff), sv_message);\n\n        // Replace vowels\n        svint8_t a_val = svdup_s8('a');\n        svint8_t e_val = svdup_s8('e');\n        svint8_t i_val = svdup_s8('i');\n        svint8_t o_val = svdup_s8('o');\n        svint8_t u_val = svdup_s8('u');\n\n        svint8_t A_val = svdup_s8('A');\n        svint8_t E_val = svdup_s8('E');\n        svint8_t I_val = svdup_s8('I');\n        svint8_t O_val = svdup_s8('O');\n        svint8_t U_val = svdup_s8('U');\n        \n        svint8_t c_val = svdup_s8('c');\n        svint8_t g_val = svdup_s8('g');\n        svint8_t k_val = svdup_s8('k');\n        svint8_t q_val = svdup_s8('q');\n        svint8_t w_val = svdup_s8('w');\n\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, a_val), c_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, e_val), g_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, i_val), k_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, o_val), q_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, u_val), w_val, sv_message);\n\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, A_val), c_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, E_val), g_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, I_val), k_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, O_val), q_val, sv_message);\n        sv_message = svsel_s8(svcmpeq_s8(pg, sv_message, U_val), w_val, sv_message);\n\n        svst1_s8(pg, encoded_message.data() + i, sv_message);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int64_t length = message.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t sv_message = svld1_s8(pg, message.data() + i);\n\n        // Swap case\n        svint8_t upper_mask = svand_n_s8(sv_message, 0xDF); // Clear bit 5 to make uppercase\n        svint8_t lower_mask = svorr_n_s8(sv_message, 0x20); // Set bit 5 to make lowercase\n        svint8_t is_upper = svcmplt_n_s8(sv_message, 'a');\n        svint8_t is_lower = svcmpgt_n_s8(sv_message, 'Z');\n        svint8_t swapped_case = svsel_s8(is_upper & is_lower, lower_mask, upper_mask);\n        \n        //Vowel replacement\n        svint8_t a_mask = svcmpne_n_s8(swapped_case, 'a');\n        svint8_t e_mask = svcmpne_n_s8(swapped_case, 'e');\n        svint8_t i_mask = svcmpne_n_s8(swapped_case, 'i');\n        svint8_t o_mask = svcmpne_n_s8(swapped_case, 'o');\n        svint8_t u_mask = svcmpne_n_s8(swapped_case, 'u');\n\n        svint8_t replaced_vowels = swapped_case;\n        replaced_vowels = svsel_s8(a_mask, replaced_vowels, 'c');\n        replaced_vowels = svsel_s8(e_mask, replaced_vowels, 'g');\n        replaced_vowels = svsel_s8(i_mask, replaced_vowels, 'k');\n        replaced_vowels = svsel_s8(o_mask, replaced_vowels, 'q');\n        replaced_vowels = svsel_s8(u_mask, replaced_vowels, 'w');\n\n        svst1_s8(pg, encoded_message.data() + i, replaced_vowels);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string encoded_message = message;\n    int64_t length = message.length();\n\n    for (int64_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t sv_message = svld1_s8(pg, message.data() + i);\n\n        // Swap case\n        svint8_t upper_mask = svand_n_s8(sv_message, 0b11011111);\n        svint8_t lower_mask = svorr_n_s8(sv_message, 0b00100000);\n        svint8_t is_upper = svcmpeq_n_s8(svand_n_s8(sv_message, 0b00100000), 0);\n        svint8_t swapped_case = svsel_s8(is_upper, lower_mask, upper_mask);\n\n        // Replace vowels\n        svint8_t a_mask = svcmpeq_n_s8(swapped_case, 'a');\n        svint8_t e_mask = svcmpeq_n_s8(swapped_case, 'e');\n        svint8_t i_mask = svcmpeq_n_s8(swapped_case, 'i');\n        svint8_t o_mask = svcmpeq_n_s8(swapped_case, 'o');\n        svint8_t u_mask = svcmpeq_n_s8(swapped_case, 'u');\n\n        swapped_case = svsel_s8(a_mask, 'c', swapped_case);\n        swapped_case = svsel_s8(e_mask, 'g', swapped_case);\n        swapped_case = svsel_s8(i_mask, 'k', swapped_case);\n        swapped_case = svsel_s8(o_mask, 'q', swapped_case);\n        swapped_case = svsel_s8(u_mask, 'w', swapped_case);\n        \n        svst1_s8(pg, encoded_message.data() + i, swapped_case);\n    }\n\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    if (key.empty()) return false;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (char c : key) {\n      if (!std::isalpha(c)) {\n        all_lower = false;\n        all_upper = false;\n        key_all_lower = false;\n        key_all_upper = false;\n        break;\n      }\n      if (std::isupper(c)) {\n        key_all_lower = false;\n      } else {\n        key_all_upper = false;\n      }\n    }\n    if (!key_all_lower) all_lower = false;\n    if (!key_all_upper) all_upper = false;\n    if (!all_lower && !all_upper) return false;\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    const char* key_ptr = key.c_str();\n    size_t key_len = key.length();\n\n    if (key_len == 0) {\n        all_lower = false;\n        all_upper = false;\n        break;\n    }\n\n    svbool_t all_chars = svptrue();\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (size_t i = 0; i < key_len; ++i) {\n      svbool_t pg = svwhilelt_b8(i, key_len);\n      svint8_t chars = svld1_s8(pg, key_ptr + i);\n      svbool_t is_lower = svcmpge(pg, chars, 'a');\n      is_lower = svand_b8(is_lower, svcmple(pg, chars, 'z'));\n      svbool_t is_upper = svcmpge(pg, chars, 'A');\n      is_upper = svand_b8(is_upper, svcmple(pg, chars, 'Z'));\n\n      if (!std::islower(key[i])) {\n        key_all_lower = false;\n      }\n      if (!std::isupper(key[i])) {\n        key_all_upper = false;\n      }\n    }\n\n    all_lower &= key_all_lower;\n    all_upper &= key_all_upper;\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    if (key.empty()) return false;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (char c : key) {\n      if (!std::isalpha(c)) {\n        all_lower = false;\n        all_upper = false;\n        key_all_lower = false;\n        key_all_upper = false;\n        break;\n      } else {\n        if (!std::islower(c)) {\n          key_all_lower = false;\n        }\n        if (!std::isupper(c)) {\n          key_all_upper = false;\n        }\n      }\n    }\n    if (!key_all_lower) all_lower = false;\n    if (!key_all_upper) all_upper = false;\n    if (!all_lower && !all_upper) return false;\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    if (key.empty()) return false;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (char c : key) {\n      if (!std::isalpha(c)) {\n        all_lower = false;\n        all_upper = false;\n        key_all_lower = false;\n        key_all_upper = false;\n        break;\n      }\n      if (std::isupper(c)) {\n        key_all_lower = false;\n      } else {\n        key_all_upper = false;\n      }\n    }\n\n    if (!key_all_lower) {\n      all_lower = false;\n    }\n    if (!key_all_upper) {\n      all_upper = false;\n    }\n\n    if (!all_lower && !all_upper) {\n      return false;\n    }\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n  if (dict.empty()) {\n    return false;\n  }\n\n  bool all_lower = true;\n  bool all_upper = true;\n\n  for (const auto& pair : dict) {\n    const std::string& key = pair.first;\n    if (key.empty()) return false;\n\n    bool key_all_lower = true;\n    bool key_all_upper = true;\n\n    for (char c : key) {\n      if (!std::isalpha(c)) {\n        all_lower = false;\n        all_upper = false;\n        key_all_lower = false;\n        key_all_upper = false;\n        break;\n      }\n      if (std::isupper(c)) {\n        key_all_lower = false;\n      } else {\n        key_all_upper = false;\n      }\n    }\n    if (!key_all_lower) all_lower = false;\n    if (!key_all_upper) all_upper = false;\n    if (!all_lower && !all_upper) return false;\n  }\n\n  return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            for (int i = p * p; i < n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n\n    for (int p = 2; p < n; ++p) {\n        if (is_prime[p]) {\n            result.push_back(p);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 1) {\n        return result;\n    }\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n\n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svint8_t sv_chars = svld1_s8(pg, &s[i]);\n\n        svbool_t upper_vowel_mask = svand_b8(pg,pg); \n        \n        svbool_t is_A = sveceq_s8(sv_chars, 'A');\n        svbool_t is_E = sveceq_s8(sv_chars, 'E');\n        svbool_t is_I = sveceq_s8(sv_chars, 'I');\n        svbool_t is_O = sveceq_s8(sv_chars, 'O');\n        svbool_t is_U = sveceq_s8(sv_chars, 'U');\n\n        upper_vowel_mask = svorr_b8(upper_vowel_mask, is_A);\n        upper_vowel_mask = svorr_b8(upper_vowel_mask, is_E);\n        upper_vowel_mask = svorr_b8(upper_vowel_mask, is_I);\n        upper_vowel_mask = svorr_b8(upper_vowel_mask, is_O);\n        upper_vowel_mask = svorr_b8(upper_vowel_mask, is_U);\n\n        for(int j = 0; j < svcntb(); ++j){\n            if(i + j < n && (i + j) % 2 == 0 && svptest_first(pg, upper_vowel_mask, j)){\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t sv_index = svindex_u8(i, 1);\n        svuint8_t sv_char = svld1_s8(pg, &s[i]);\n\n        svbool_t even_indices = svand_b8(pg, sveor_b8(svptrue_b8(), svlsr_b8(sv_index, 1)));\n\n        svbool_t is_upper = svand_b8(even_indices, svcmpge_s8(pg, sv_char, 'A'));\n        is_upper = svand_b8(is_upper, svcmple_s8(pg, sv_char, 'Z'));\n\n        svbool_t is_vowel = svand_b8(is_upper,\n                                     svor_b8(svor_b8(svor_b8(svcmpeq_s8(pg, sv_char, 'A'),\n                                                              svcmpeq_s8(pg, sv_char, 'E')),\n                                                      svcmpeq_s8(pg, sv_char, 'I')),\n                                             svor_b8(svcmpeq_s8(pg, sv_char, 'O'),\n                                                      svcmpeq_s8(pg, sv_char, 'U'))));\n\n        count += svcntp_b8(pg, is_vowel);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n\n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svint8_t sv_chars = svld1_s8(pg, &s[i]);\n\n        svbool_t upper_vowel_mask = svand_b8(pg, svand_b8(svcmpge_s8(pg, sv_chars, 'A'), svcmple_s8(pg, sv_chars, 'Z')));\n\n        svbool_t is_A = svcmpeq_s8(upper_vowel_mask, sv_chars, 'A');\n        svbool_t is_E = svcmpeq_s8(upper_vowel_mask, sv_chars, 'E');\n        svbool_t is_I = svcmpeq_s8(upper_vowel_mask, sv_chars, 'I');\n        svbool_t is_O = svcmpeq_s8(upper_vowel_mask, sv_chars, 'O');\n        svbool_t is_U = svcmpeq_s8(upper_vowel_mask, sv_chars, 'U');\n\n        svbool_t vowel_mask = svorr_b8(svorr_b8(is_A, is_E), svorr_b8(is_I, is_O), is_U);\n\n        for (int j = 0; j < svcntb(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && svptest_first(pg, vowel_mask, j)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int n = s.length();\n\n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svint8_t str = svld1_s8(pg, &s[i]);\n        svint8_t even_indices = svindex_s8(i, 1);\n        svbool_t even_mask = svand_b8(pg, sveor_b8(svcmpne_s8(even_indices & 1, 0), pg));\n\n        svint8_t uppercase_vowels = svdup_s8(0);\n        svbool_t is_A = svcmpeq_s8(pg, str, svdup_s8('A'));\n        svbool_t is_E = svcmpeq_s8(pg, str, svdup_s8('E'));\n        svbool_t is_I = svcmpeq_s8(pg, str, svdup_s8('I'));\n        svbool_t is_O = svcmpeq_s8(pg, str, svdup_s8('O'));\n        svbool_t is_U = svcmpeq_s8(pg, str, svdup_s8('U'));\n\n        svbool_t is_vowel = svorr_b8(svorr_b8(is_A, is_E), svorr_b8(is_I, is_O));\n        is_vowel = svorr_b8(is_vowel, is_U);\n\n        svbool_t final_mask = svand_b8(even_mask, is_vowel);\n\n        count += svcntp_b8(pg, final_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svint8_t sv_chars = svld1_s8(pg, s.data() + i);\n\n        svbool_t upper_vowel_mask = svand_b8(pg, svand_b8(pg, svand_b8(pg, svand_b8(pg, svcmpeq(pg, sv_chars, 'A'), svcmpeq(pg, sv_chars, 'E')), svcmpeq(pg, sv_chars, 'I')), svcmpeq(pg, sv_chars, 'O')), svcmpeq(pg, sv_chars, 'U'));\n\n        if (svptest_any(pg, upper_vowel_mask)) {\n            for (int j = 0; j < svcntb(); ++j) {\n                if (i + j < len && (i + j) % 2 == 0) {\n                    if (svptrue_b8(upper_vowel_mask)[j]) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    result[0] = n;\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = next_val;\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    result[0] = n;\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = next_val;\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n  std::vector<int> result;\n  result.push_back(n);\n  int next_stone = (n % 2 == 0) ? n + 2 : n + 2;\n\n  for (int i = 1; i < n; ++i) {\n    result.push_back(next_stone);\n    next_stone += 2;\n  }\n\n  return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    result[0] = n;\n    int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = next_val;\n        next_val += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n  std::vector<int> result(n);\n  result[0] = n;\n  int next_val = (n % 2 == 0) ? n + 2 : n + 2;\n\n  for (int i = 1; i < n; ++i) {\n    result[i] = next_val;\n    next_val += 2;\n  }\n\n  return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n  if (n > m) {\n    return \"-1\";\n  }\n\n  int64_t sum = 0;\n  int64_t count = 0;\n\n  svbool_t pg = svwhilelt_s64(n, m + 1);\n  int64_t vec_size = svcntd();\n\n  for (int64_t i = n; i <= m; i += vec_size) {\n    svint64_t vec = svindex_s64(i, 1);\n    svint64_t masked_vec = svsel_s64(pg, vec, 0);\n\n    int64_t temp_sum[vec_size];\n    svst1_s64(pg, temp_sum, masked_vec);\n\n    for (int j = 0; j < vec_size; ++j) {\n      if (i + j <= m) {\n        sum += temp_sum[j];\n        count++;\n      }\n    }\n    pg = svwhilelt_s64(i + vec_size, m + 1);\n  }\n\n  int64_t avg = sum / count;\n\n  std::string binary = \"\";\n  if (avg == 0) {\n      return \"0\";\n  }\n  while (avg > 0) {\n    binary = ((avg % 2 == 0) ? \"0\" : \"1\") + binary;\n    avg /= 2;\n  }\n\n  return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n  if (n > m) {\n    return \"-1\";\n  }\n\n  int64_t sum = 0;\n  int64_t count = 0;\n\n  svbool_t pg = svptrue_b64();\n  int64_t vec_size = svcntd();\n\n  int64_t start = n;\n  int64_t end = m;\n\n  while (start + vec_size <= end + 1) {\n    svint64_t vec = svindexd(start, 1, pg, SV_VL_CONT);\n    sum += svaddv_s64(pg, vec);\n    count += vec_size;\n    start += vec_size;\n  }\n\n  for (int64_t i = start; i <= end; ++i) {\n    sum += i;\n    count++;\n  }\n\n  int64_t avg = sum / count;\n\n  std::string binary = \"\";\n  if (avg == 0) {\n    return \"0\";\n  }\n\n  while (avg > 0) {\n    binary = ((avg % 2 == 0) ? \"0\" : \"1\") + binary;\n    avg /= 2;\n  }\n\n  return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n  if (n > m) {\n    return \"-1\";\n  }\n\n  int64_t sum = 0;\n  int64_t count = 0;\n\n  svbool_t pg = svwhilelt_s64(n, m + 1);\n  int64_t vec_size = svcntd();\n\n  for (int64_t i = n; i <= m; i += vec_size) {\n    svint64_t vec = svindex_s64(i, 1);\n    svint64_t vec_active = svsel_s64(pg, vec, 0);\n\n    int64_t first = i;\n    int64_t last = std::min(i + vec_size - 1, m);\n\n    for (int64_t j = first; j <= last; ++j) {\n      sum += j;\n      count++;\n    }\n    pg = svwhilelt_s64(i + vec_size, m + 1);\n  }\n\n  int64_t avg = sum / count;\n\n  std::string binary = \"\";\n  if (avg == 0) {\n    return \"0\";\n  }\n\n  while (avg > 0) {\n    binary = ((avg % 2 == 0) ? \"0\" : \"1\") + binary;\n    avg /= 2;\n  }\n\n  return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    svbool_t pg = svwhilelt_b64(0, m - n + 1);\n    int64_t vec_size = svcntd();\n\n    for (int64_t i = 0; i < m - n + 1; i += vec_size) {\n        svint64_t vec_i = svadd_n_s64(svindex_s64(n + i, 1), 0);\n        svint64_t vec_vals = svmul_n_s64(vec_i, 1);\n\n        int64_t temp_sum[vec_size];\n        svst1_s64(pg, temp_sum, vec_vals);\n\n        for (int j = 0; j < vec_size && i + j <= m - n; ++j) {\n            sum += n + i + j;\n            count++;\n        }\n    }\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    svbool_t pg = svwhilelt_s64(n, m + 1);\n    int64_t vec_size = svcntd();\n\n    for (int64_t i = n; i <= m; i += vec_size) {\n        svint64_t vec = svindex_s64(i, 1);\n        svint64_t masked_vec = svsel_s64(pg, vec, 0);\n\n        int64_t temp_sum = 0;\n        int64_t temp_count = 0;\n\n        for (int j = 0; j < vec_size; ++j) {\n            if (i + j <= m) {\n                temp_sum += i + j;\n                temp_count++;\n            }\n        }\n\n        sum += temp_sum;\n        count += temp_count;\n\n        pg = svwhilelt_s64(i + vec_size, m + 1);\n    }\n\n    int64_t avg = (sum + count / 2) / count;\n\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= i + 1; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= i + 1; ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(svindex_u32(1, 1), n + 1);\n\n    for (i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            // Calculate factorial modulo 10000\n            long long factorial = 1;\n            for (int j = 1; j <= i + 1; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            // Calculate sum from 1 to i\n            long long sum = 0;\n            for (int j = 1; j <= i + 1; ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 1;\n    for (; i <= n; ++i) {\n        if (i % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result[i - 1] = (int)sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            long long factorial = 1;\n            for (int j = 1; j <= i + 1; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            long long sum = 0;\n            for (int j = 1; j <= i + 1; ++j) {\n                sum += j;\n            }\n            result[i] = (int)sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n\n        if (s == reversed_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n  int even_count = 0;\n  int odd_count = 0;\n\n  for (int i = 1; i <= n; ++i) {\n    std::string s = std::to_string(i);\n    std::string rs = s;\n    std::reverse(rs.begin(), rs.end());\n\n    if (s == rs) {\n      if (i % 2 == 0) {\n        even_count++;\n      } else {\n        odd_count++;\n      }\n    }\n  }\n\n  return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t sv_nums = svld1(pg, &n[i]);\n        \n        int32_t nums[vl];\n        svst1(pg, nums, sv_nums);\n\n        for (size_t j = 0; j < vl && i + j < len; ++j) {\n            int num = nums[j];\n            int sum = 0;\n            int temp = num;\n\n            while (temp != 0) {\n                sum += temp % 10;\n                temp /= 10;\n            }\n\n            if (sum > 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n  int count = 0;\n  size_t len = n.size();\n  size_t vl = svcntw();\n\n  for (size_t i = 0; i < len; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t sv_nums = svld1(pg, &n[i]);\n    svint32_t sv_abs_nums = svabs_s32_x(pg, sv_nums);\n\n    int32_t nums_arr[vl];\n    svst1(pg, nums_arr, sv_nums);\n\n    for (size_t j = 0; j < vl && i + j < len; ++j) {\n      int num = nums_arr[j];\n      int sum = 0;\n      int temp = num;\n\n      while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n      }\n\n      if (sum > 0) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t sv_nums = svld1(pg, &n[i]);\n        \n        int32_t nums[vl];\n        svst1(pg, nums, sv_nums);\n\n        for (size_t j = 0; j < vl && i + j < len; ++j) {\n            int num = nums[j];\n            int sum = 0;\n            int sign = 1;\n\n            if (num < 0) {\n                sign = -1;\n                num = -num;\n            }\n\n            if (num == 0) continue;\n\n            while (num > 0) {\n                int digit = num % 10;\n                sum += sign * digit;\n                num /= 10;\n                sign = 1;\n            }\n\n            if (sum > 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n  int count = 0;\n  size_t len = n.size();\n  size_t vl = svcntw();\n\n  for (size_t i = 0; i < len; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t sv_nums = svld1(pg, &n[i]);\n    svint32_t sv_abs_nums = svabs_s32_x(pg, sv_nums);\n\n    int32_t nums_arr[vl];\n    svst1(pg, nums_arr, sv_nums);\n\n    for (size_t j = 0; j < vl && i + j < len; ++j) {\n      int num = nums_arr[j];\n      int sum = 0;\n      int temp = num;\n\n      while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n      }\n\n      if (sum > 0) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n  int count = 0;\n  size_t len = n.size();\n  size_t vl = svcntw();\n\n  for (size_t i = 0; i < len; i += vl) {\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t sv_nums = svld1(pg, &n[i]);\n    svint32_t sv_abs_nums = svabs_s32_x(pg, sv_nums);\n\n    int32_t nums_arr[vl];\n    svst1(pg, nums_arr, sv_nums);\n\n    for (size_t j = 0; j < vl && i + j < len; ++j) {\n      int num = nums_arr[j];\n      int sum = 0;\n      int temp = num;\n\n      while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n      }\n\n      if (sum > 0) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    for (int shift = 0; shift < n; ++shift) {\n        std::vector<int> shifted_arr(n);\n        for (int i = 0; i < n; ++i) {\n            shifted_arr[i] = arr[(i - shift + n) % n];\n        }\n\n        bool sorted = true;\n        for (int i = 1; i < n; ++i) {\n            if (shifted_arr[i] < shifted_arr[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0;\n    int even_count2 = 0;\n\n    for (int val : lst1) {\n        if (val % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    for (int val : lst2) {\n        if (val % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        for (size_t i = 0; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        for (size_t i = 0; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n  std::vector<std::string> result;\n  for (const auto& str : lst) {\n    int count = 0;\n    for (char c : str) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    result.push_back(\"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\");\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t sv_digits = svld1_u8(pg, str.data() + i);\n            svuint8_t sv_odd_mask = svand_u8(sv_digits, svdup_u8(1));\n            svuint64_t sv_count = svcntp_u64(pg, svextend_u64(sv_odd_mask));\n            odd_count += svaddv_u64(pg, sv_count);\n            i += svcntw();\n        }\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    size_t n = nums.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int64_t current_sum = 0;\n        for (size_t j = i; j < n; ++j) {\n            current_sum += nums[j];\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <limits>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t vector_length = svcntd();\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        current_min += nums[i];\n        if (current_min > nums[i]) {\n            current_min = nums[i];\n        }\n        if (min_so_far > current_min) {\n            min_so_far = current_min;\n        }\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_sum = INT64_MAX;\n    size_t n = nums.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int64_t current_sum = 0;\n        for (size_t j = i; j < n; ++j) {\n            current_sum += nums[j];\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_sum = nums[0];\n    size_t n = nums.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        int64_t current_sum = 0;\n        for (size_t j = i; j < n; ++j) {\n            current_sum += nums[j];\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64_t min_so_far = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_so_far = std::min(min_so_far, current_min);\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < grid[i].size(); ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < grid[i].size(); ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < grid[i].size(); ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < grid[i].size(); ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        int row_sum = 0;\n        for (int j = 0; j < grid[i].size(); ++j) {\n            row_sum += grid[i][j];\n        }\n        count += (row_sum + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t sv_vals = svld1_s16(pg, &lst[i]);\n\n        for (size_t j = 0; j < svcntw(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && lst[i + j] % 2 != 0) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t sv_vals = svld1_s16(pg, &lst[i]);\n\n        for (size_t j = 0; j < svcntw(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && lst[i + j] % 2 != 0) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t sv_vals = svld1_s16(pg, &lst[i]);\n\n        for (size_t j = 0; j < svcntw(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && lst[i + j] % 2 != 0) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t sv_vals = svld1_s16(pg, &lst[i]);\n\n        for (size_t j = 0; j < svcntw(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && lst[i + j] % 2 != 0) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t sv_vals = svld1_s16(pg, &lst[i]);\n\n        for (size_t j = 0; j < svcntw(); ++j) {\n            if (i + j < n && (i + j) % 2 == 0 && lst[i + j] % 2 != 0) {\n                sum += lst[i + j];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min((int)arr.size(), k);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t pred = svand_b32(pg, svcmpge_s32(pg, vec, 10));\n        pred = svand_b32(pred, svcmple_s32(pg, vec, 99));\n        svint32_t masked_vec = svsel_s32(pred, vec, 0);\n        sum += svaddv_s32(pg, masked_vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min((int)arr.size(), k);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t less_than_100 = svcmpge_s32(pg, vec, 100);\n        svint32_t masked_vec = svsel_s32(less_than_100, 0, vec);\n        sum += svaddv_s32(pg, masked_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min((int)arr.size(), k);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t pred = svand_b32(pg, svcmpge_s32(pg, vec, 1));\n        pred = svand_b32(pred, svcmple_s32(pred, vec, 99));\n        sum += svaddv_s32(pred, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min((int)arr.size(), k);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t is_valid = svand_b32(pg, svand_b32(pg, svcmpge_n_s32(pg, vec, 1), svcmple_n_s32(pg, vec, 99)));\n        sum += svaddv_s32(is_valid, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min((int)arr.size(), k);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t less_than_100 = svcmpge_s32(pg, vec, 100);\n        svint32_t masked_vec = svsel_s32(less_than_100, 0, vec);\n        sum += svaddv_s32(pg, masked_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n\n  size_t n = lst.size();\n  svbool_t pg = svwhilelt_b32(0, n - 1);\n  bool sorted = true;\n\n  for (size_t i = 0; i < n - 1; i += svcntw()) {\n    pg = svwhilelt_b32(i, n - 1);\n\n    svint32_t current = svld1_s32(pg, &lst[i]);\n    svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n    svbool_t cmp = svcmplt_s32(pg, next, current);\n\n    if (svptest_any(pg, cmp)) {\n      sorted = false;\n      break;\n    }\n\n    svint32_t eq = sveq_s32(current, next);\n    if (svptest_any(pg, eq)) {\n        svbool_t eq_pg = svptrue_b32();\n        for(size_t j = 0; j < n - 1; ++j){\n            int count = 0;\n            for(size_t k = 0; k < n; ++k){\n                if(lst[j] == lst[k]){\n                    count++;\n                }\n            }\n            if(count > 1){\n                return false;\n            }\n        }\n        return true;\n    }\n  }\n\n  return sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n\n  size_t n = lst.size();\n  svbool_t pg = svwhilelt_b32(0, n - 1);\n  for (size_t i = 0; i < n - 1; i += svcntw()) {\n    svint32_t current = svld1_s32(pg, &lst[i]);\n    svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n    svbool_t lt = svcmplt_s32(pg, current, next);\n    svbool_t eq = svcmpeq_s32(pg, current, next);\n\n    if (!svptest_any(pg, lt | eq)) {\n      return false;\n    }\n    \n    svint32_t dup_check = svdupq_n_s32(0);\n    for(size_t j = 0; j < n; ++j){\n        if(j != i){\n            svint32_t val = svdupq_n_s32(lst[i]);\n            svbool_t check_eq = svcmpeq_s32(pg, current, val);\n            if(svptest_any(pg, check_eq)){\n                return false;\n            }\n        }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n\n  size_t n = lst.size();\n  svbool_t pg = svwhilelt_b32(0, n - 1);\n  bool sorted = true;\n\n  for (size_t i = 0; i < n - 1; i += svcntw()) {\n    pg = svwhilelt_b32(i, n - 1);\n\n    svint32_t current = svld1_s32(pg, &lst[i]);\n    svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n    svbool_t lt = svcmplt_s32(pg, current, next);\n    svbool_t eq = svcmpeq_s32(pg, current, next);\n\n    if (!svptest_any(pg, lt | eq)) {\n      sorted = false;\n      break;\n    }\n\n    svint32_t dup_check = svdupq_n_s32(0);\n    for(size_t j = 0; j < n; ++j){\n        svbool_t pg_dup = svwhilelt_b32(0, n);\n        svint32_t val = svld1_s32(pg_dup, &lst[j]);\n        svbool_t eq_check = svcmpeq_s32(pg_dup, current, val);\n        dup_check = svadd_s32_x(pg_dup, dup_check, svextract(eq_check, 0));\n    }\n    \n    int dup_count = 0;\n    for(int k = 0; k < svcntw(); ++k){\n        dup_count += svextract(dup_check, k);\n    }\n\n    if(dup_count > 1){\n        sorted = false;\n        break;\n    }\n  }\n\n  return sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n\n  size_t n = lst.size();\n  svbool_t pg = svwhilelt_b32(0, n - 1);\n  bool sorted = true;\n\n  for (size_t i = 0; i < n - 1; i += svcntw()) {\n    svint32_t current = svld1_s32(pg, &lst[i]);\n    svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n    svbool_t cmp = svcmplt_s32(pg, next, current);\n    if (svptest_any(pg, cmp)) {\n      sorted = false;\n      break;\n    }\n\n    svbool_t eq = svcmpeq_s32(pg, current, next);\n    if (svptest_any(pg, sveor_b32(eq, svlsr_b32(eq, 1)))) {\n        size_t count = 0;\n        for(size_t j = 0; j < n; ++j){\n            if(lst[i] == lst[j]){\n                count++;\n            }\n        }\n        if(count > 2){\n            sorted = false;\n            break;\n        }\n    }\n\n    pg = svwhilelt_b32(i + svcntw(), n - 1);\n  }\n\n  return sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n  if (lst.size() <= 1) {\n    return true;\n  }\n\n  size_t n = lst.size();\n  svbool_t pg = svwhilelt_b32(0, n - 1);\n  bool sorted = true;\n\n  for (size_t i = 0; i < n - 1; i += svcntw()) {\n    svint32_t v1 = svld1_s32(pg, &lst[i]);\n    svint32_t v2 = svld1_s32(pg, &lst[i + 1]);\n    svbool_t lt = svcmplt_s32(pg, v1, v2);\n    svbool_t eq = svcmpeq_s32(pg, v1, v2);\n\n    if (svptest_any(pg, svand_b32(svnot_b32(lt), svnot_b32(eq)))) {\n      sorted = false;\n      break;\n    }\n\n    if (svptest_any(pg, eq)) {\n        svint32_t dup_check = svdupq_n_s32(lst[i]);\n        svbool_t eq_dup = svcmpeq_s32(pg, v1, dup_check);\n        \n        int count = 0;\n        for(size_t j = 0; j < lst.size(); ++j){\n            if(lst[i] == lst[j]){\n                count++;\n            }\n        }\n        if(count > 2){\n            return false;\n        }\n    }\n    pg = svwhilelt_b32(i + svcntw(), n - 1);\n  }\n\n  if(sorted){\n      for(size_t i = 0; i < lst.size() - 1; ++i){\n          if(lst[i] == lst[i+1]){\n              int count = 0;\n              for(size_t j = 0; j < lst.size(); ++j){\n                  if(lst[i] == lst[j]){\n                      count++;\n                  }\n              }\n              if(count > 2){\n                  return false;\n              }\n          }\n      }\n  }\n\n  return sorted;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return std::numeric_limits<short>::min();\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = arr.size() / vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i * vector_length]);\n        svbool_t pg = svptrue_b32();\n\n        svint32_t signs = svdup_s32(1);\n        svint32_t magnitudes = svabs_s32_x(pg, vec);\n\n        svbool_t positive = svcmpgt_s32(pg, vec, svdup_s32(0));\n        signs = svsel_s32(positive, signs, svdup_s32(1));\n\n        svbool_t negative = svcmplt_s32(pg, vec, svdup_s32(0));\n        signs = svsel_s32(negative, svdup_s32(-1), signs);\n\n        svbool_t zero = svcmpeq_s32(pg, vec, svdup_s32(0));\n        signs = svsel_s32(zero, svdup_s32(0), signs);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            prod_signs *= svgetelement_s32(signs, j);\n            sum_magnitudes += svgetelement_s32(magnitudes, j);\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < arr.size(); ++i) {\n        int num = arr[i];\n        if (num > 0) {\n            prod_signs *= 1;\n        } else if (num < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n        sum_magnitudes += std::abs(num);\n    }\n\n    return sum_magnitudes * prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return std::numeric_limits<short>::min();\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = arr.size() / vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i * vector_length]);\n        svbool_t pg = svptrue_b32();\n\n        svint32_t signs = svdup_s32(1);\n        svint32_t magnitudes = svabs_s32(vec);\n\n        svbool_t positive = svcmpgt_s32(pg, vec, svdup_s32(0));\n        svbool_t negative = svcmplt_s32(pg, vec, svdup_s32(0));\n        svbool_t zero = svcmpeq_s32(pg, vec, svdup_s32(0));\n\n        signs = svsel_s32(negative, svdup_s32(-1), signs);\n        signs = svsel_s32(zero, svdup_s32(0), signs);\n\n        int32_t signs_arr[vector_length];\n        int32_t magnitudes_arr[vector_length];\n\n        svst1_s32(pg, signs_arr, signs);\n        svst1_s32(pg, magnitudes_arr, magnitudes);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            prod_signs *= signs_arr[j];\n            sum_magnitudes += magnitudes_arr[j];\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < arr.size(); ++i) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n        sum_magnitudes += std::abs(arr[i]);\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return std::numeric_limits<short>::min();\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = arr.size() / vector_length;\n    size_t remainder = arr.size() % vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i * vector_length]);\n        svbool_t pg = svptrue_b32();\n\n        svint32_t signs = svdup_n_s32(1);\n        svint32_t magnitudes = svabs_s32_x(pg, vec);\n\n        svbool_t positive = svcmpgt_n_s32(pg, vec, 0);\n        svbool_t negative = svcmplt_n_s32(pg, vec, 0);\n        svbool_t zero = svcmpeq_n_s32(pg, vec, 0);\n\n        signs = svsel_s32(positive, svdup_n_s32(1), signs);\n        signs = svsel_s32(negative, svdup_n_s32(-1), signs);\n        signs = svsel_s32(zero, svdup_n_s32(0), signs);\n\n        int32_t signs_arr[vector_length];\n        int32_t magnitudes_arr[vector_length];\n\n        svst1_s32(pg, signs_arr, signs);\n        svst1_s32(pg, magnitudes_arr, magnitudes);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            prod_signs *= signs_arr[j];\n            sum_magnitudes += magnitudes_arr[j];\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < arr.size(); ++i) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n        sum_magnitudes += std::abs(arr[i]);\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return std::numeric_limits<short>::min();\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = arr.size() / vector_length;\n    size_t remainder = arr.size() % vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i * vector_length]);\n        svbool_t pg = svptrue_b32();\n\n        for (size_t j = 0; j < vector_length; ++j)\n        {\n            int val = arr[i * vector_length + j];\n            sum_magnitudes += abs(val);\n            if (val > 0) {\n                prod_signs *= 1;\n            } else if (val < 0) {\n                prod_signs *= -1;\n            } else {\n                prod_signs = 0;\n            }\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < arr.size(); ++i) {\n        int val = arr[i];\n        sum_magnitudes += abs(val);\n        if (val > 0) {\n            prod_signs *= 1;\n        } else if (val < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs = 0;\n        }\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return std::numeric_limits<short>::min();\n    }\n\n    int prod_signs = 1;\n    int sum_magnitudes = 0;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = arr.size() / vector_length;\n    size_t remainder = arr.size() % vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i * vector_length]);\n        svbool_t pg = svptrue_b32();\n\n        svint32_t signs = svdup_n_s32(1);\n        svint32_t magnitudes = svabs_s32_x(pg, vec);\n\n        signs = svsel_s32(svcmpgt_n_s32(pg, vec, 0), svdup_n_s32(1), signs);\n        signs = svsel_s32(svcmplt_n_s32(pg, vec, 0), svdup_n_s32(-1), signs);\n        signs = svsel_s32(svcmpeq_n_s32(pg, vec, 0), svdup_n_s32(0), signs);\n\n        int32_t signs_arr[vector_length];\n        int32_t magnitudes_arr[vector_length];\n        svst1_s32(pg, signs_arr, signs);\n        svst1_s32(pg, magnitudes_arr, magnitudes);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            prod_signs *= signs_arr[j];\n            sum_magnitudes += magnitudes_arr[j];\n\n            if (prod_signs == 0) {\n                return 0;\n            }\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < arr.size(); ++i) {\n        if (arr[i] > 0) {\n            prod_signs *= 1;\n        } else if (arr[i] < 0) {\n            prod_signs *= -1;\n        } else {\n            prod_signs *= 0;\n        }\n\n        sum_magnitudes += std::abs(arr[i]);\n\n        if (prod_signs == 0) {\n            return 0;\n        }\n    }\n\n    return prod_signs * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    std::function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            solve(i, j, current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n  uint64_t product = 1;\n  bool hasOdd = false;\n  char str[21];\n  sprintf(str, \"%lu\", n);\n  int len = strlen(str);\n\n  for (int i = 0; i < len; ++i) {\n    int digit = str[i] - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n  }\n\n  if (!hasOdd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    char str[21];\n    sprintf(str, \"%lu\", n);\n    int len = strlen(str);\n\n    for (int i = 0; i < len; ++i) {\n        int digit = str[i] - '0';\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = true;\n        }\n    }\n\n    if (!has_odd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n  uint64_t product = 1;\n  bool hasOdd = false;\n  char str[21];\n  sprintf(str, \"%lu\", n);\n  int len = strlen(str);\n\n  for (int i = 0; i < len; ++i) {\n    int digit = str[i] - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n  }\n\n  if (!hasOdd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n  uint64_t product = 1;\n  bool hasOdd = false;\n  char str[21];\n  sprintf(str, \"%lu\", n);\n  int len = strlen(str);\n\n  for (int i = 0; i < len; ++i) {\n    int digit = str[i] - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n  }\n\n  if (!hasOdd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n  uint64_t product = 1;\n  bool hasOdd = false;\n  char str[21];\n  sprintf(str, \"%lu\", n);\n  int len = strlen(str);\n\n  for (int i = 0; i < len; ++i) {\n    int digit = str[i] - '0';\n    if (digit % 2 != 0) {\n      product *= digit;\n      hasOdd = true;\n    }\n  }\n\n  if (!hasOdd) {\n    return 0;\n  }\n\n  return product;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svfloat32_t vf = svld1_f32(svptrue_b32(), &lst[i]);\n        svint32_t vi = svceil_s32_f32(vf);\n        svint32_t vi_sq = svmul_s32_x(svptrue_b32(), vi, vi);\n        int32_t temp[vl];\n        svst1_s32(svptrue_b32(), temp, vi_sq);\n\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            sum += (uint64_t)temp[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= n; i += svcntw()) {\n        svfloat32_t vf = svld1_f32(pg, &lst[i]);\n        svfloat32_t vf_ceil = svceil_f32_z(pg, vf);\n        svint32_t vi = svcvt_s32_f32_z(pg, vf_ceil);\n        svint32_t vi_sq = svmul_s32_x(pg, vi, vi, vi);\n        sum += svaddv_s32(pg, vi_sq);\n    }\n\n    for (; i < n; ++i) {\n        sum += pow(ceil(lst[i]), 2);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n\n    for (; i < n - n % svcntw(); i += svcntw()) {\n        svfloat32_t vf = svld1_f32(pg, &lst[i]);\n        svfloat32_t vf_ceil = svceil_f32_z(pg, vf);\n        svint32_t vi = svcvt_s32_f32_z(pg, vf_ceil);\n        svint32_t vi_sq = svmul_s32_x(pg, vi, vi);\n        sum += svaddv_s32(pg, vi_sq);\n    }\n\n    for (; i < n; ++i) {\n        sum += pow(ceil(lst[i]), 2);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n        svint32_t vec_ceil = svrintp_s32_f32(vec);\n        svint32_t vec_sq = svmul_s32_x(svptrue_b32(), vec_ceil, vec_ceil);\n        sum += svaddv_s32(svptrue_b32(), vec_sq);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n        svint32_t vec_ceil = svrintz_f32_z(svptrue_b32(), vec);\n\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            int32_t val = svgetelement_s32(vec_ceil, j);\n            sum += (uint64_t)val * val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int64_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    int64_t index = -1;\n\n    for (int64_t i = 1; i < n; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        svint32_t previous = svdup_n_s32(arr[i - 1]);\n\n        if (svptest_any(pg, svcmpgt_s32(pg, previous, current))) {\n            index = i;\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32_t last_index = -1;\n\n    for (int i = 1; i < n; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        svint32_t previous = svdup_n_s32(arr[i - 1]);\n\n        svbool_t compare = svcmpgt_s32(pg, previous, current);\n\n        if (svptest_any(pg, compare)) {\n            last_index = i;\n        }\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32_t last_index = -1;\n\n    for (int i = 1; i < n; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        svint32_t previous = svdup_n_s32(arr[i - 1]);\n        svbool_t compare = svcmpgt_s32(pg, previous, current);\n\n        if (svptest_any(pg, compare)) {\n            last_index = i;\n        }\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int64_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    int64_t index = -1;\n\n    for (int64_t i = 1; i < n; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        svint32_t previous = svdup_n_s32(arr[i - 1]);\n\n        if (svptest_any(pg, svcmpgt_s32(pg, previous, current))) {\n            index = i;\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int64_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    int64_t index = -1;\n\n    for (int64_t i = 1; i < n; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        svint32_t previous = svdup_n_s32(arr[i - 1]);\n        svbool_t compare = svcmpgt_s32(pg, previous, current);\n\n        if (svptest_any(pg, compare)) {\n            index = i;\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32_t largest_neg_val = 0;\n    int32_t smallest_pos_val = 0;\n    bool neg_found = false;\n    bool pos_found = false;\n\n    size_t vector_length = svcntw();\n    size_t list_size = lst.size();\n\n    for (size_t i = 0; i < list_size; i += vector_length) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        if (svptest_any(pg, neg_mask)) {\n            svint32_t neg_vals = svand_s32(neg_mask, vec);\n\n            for (size_t j = 0; j < vector_length && i + j < list_size; ++j) {\n                if (svgetelem_s32(neg_mask, j)) {\n                    int32_t val = lst[i + j];\n                    if (!neg_found) {\n                        largest_neg_val = val;\n                        neg_found = true;\n                    } else if (val > largest_neg_val) {\n                        largest_neg_val = val;\n                    }\n                }\n            }\n        }\n\n        if (svptest_any(pg, pos_mask)) {\n            svint32_t pos_vals = svand_s32(pos_mask, vec);\n\n            for (size_t j = 0; j < vector_length && i + j < list_size; ++j) {\n                if (svgetelem_s32(pos_mask, j)) {\n                    int32_t val = lst[i + j];\n                    if (!pos_found) {\n                        smallest_pos_val = val;\n                        pos_found = true;\n                    } else if (val < smallest_pos_val) {\n                        smallest_pos_val = val;\n                    }\n                }\n            }\n        }\n    }\n    \n    if(neg_found){\n        largest_negative = largest_neg_val;\n    }\n    if(pos_found){\n        smallest_positive = smallest_pos_val;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svIsActive(svptrue_b32(), svptrue_b32());\n    int32_t largest_neg_vec = 0;\n    int32_t smallest_pos_vec = 0;\n    bool neg_found = false;\n    bool pos_found = false;\n\n    size_t vector_length = svcntw();\n    size_t num_vectors = lst.size() / vector_length;\n    size_t remainder = lst.size() % vector_length;\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        svint32_t vec = svld1_s32(pg, &lst[i * vector_length]);\n\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n        if (svptest_any(pg, neg_mask)) {\n            if (!neg_found) {\n                largest_neg_vec = svmaxv_s32(pg, vec);\n                neg_found = true;\n            } else {\n                largest_neg_vec = std::max(largest_neg_vec, svmaxv_s32(pg, vec));\n            }\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n        if (svptest_any(pg, pos_mask)) {\n            if (!pos_found) {\n                smallest_pos_vec = svminv_s32(pg, vec);\n                pos_found = true;\n            } else {\n                smallest_pos_vec = std::min(smallest_pos_vec, svminv_s32(pg, vec));\n            }\n        }\n    }\n\n    if (remainder > 0) {\n        std::vector<int32_t> tail(lst.begin() + num_vectors * vector_length, lst.end());\n        tail.resize(vector_length, 0); \n        svint32_t tail_vec = svld1_s32(pg, tail.data());\n        svbool_t tail_pg = svwhilelt_b32(svindex_u32(0, 1), svdup_n_u32(remainder));\n\n        svbool_t neg_mask = svcmpgt_s32(tail_pg, svdup_n_s32(0), tail_vec);\n        if (svptest_any(tail_pg, neg_mask)) {\n            if (!neg_found) {\n                largest_neg_vec = svmaxv_s32(tail_pg, tail_vec);\n                neg_found = true;\n            } else {\n                largest_neg_vec = std::max(largest_neg_vec, svmaxv_s32(tail_pg, tail_vec));\n            }\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(tail_pg, tail_vec, svdup_n_s32(0));\n        if (svptest_any(tail_pg, pos_mask)) {\n            if (!pos_found) {\n                smallest_pos_vec = svminv_s32(tail_pg, tail_vec);\n                pos_found = true;\n            } else {\n                smallest_pos_vec = std::min(smallest_pos_vec, svminv_s32(tail_pg, tail_vec));\n            }\n        }\n    }\n\n    if (neg_found) {\n        largest_negative = largest_neg_vec;\n    }\n    if (pos_found) {\n        smallest_positive = smallest_pos_vec;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32_t largest_neg_vec = 0;\n    int32_t smallest_pos_vec = 0;\n    bool neg_found = false;\n    bool pos_found = false;\n\n    size_t vector_length = svcntw();\n    size_t list_size = lst.size();\n\n    for (size_t i = 0; i < list_size; i += vector_length) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n        if (svptest_any(pg, neg_mask)) {\n            svint32_t masked_neg = svand_s32(neg_mask, vec);\n\n            for (int j = 0; j < vector_length && i + j < list_size; ++j) {\n                if (svgetelem_s32(masked_neg, j) != 0) {\n                    if (!neg_found) {\n                        largest_negative = svgetelem_s32(masked_neg, j);\n                        neg_found = true;\n                    } else if (svgetelem_s32(masked_neg, j) > largest_negative) {\n                        largest_negative = svgetelem_s32(masked_neg, j);\n                    }\n                }\n            }\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n        if (svptest_any(pg, pos_mask)) {\n            svint32_t masked_pos = svand_s32(pos_mask, vec);\n\n            for (int j = 0; j < vector_length && i + j < list_size; ++j) {\n                if (svgetelem_s32(masked_pos, j) != 0) {\n                    if (!pos_found) {\n                        smallest_positive = svgetelem_s32(masked_pos, j);\n                        pos_found = true;\n                    } else if (svgetelem_s32(masked_pos, j) < smallest_positive) {\n                        smallest_positive = svgetelem_s32(masked_pos, j);\n                    }\n                }\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svIsActive(svptrue_b32(), svptrue_b32());\n    int32_t largest_neg_vec = 0;\n    int32_t smallest_pos_vec = 0;\n    bool neg_found = false;\n    bool pos_found = false;\n\n    size_t vector_length = svcntw();\n    size_t num_vectors = lst.size() / vector_length;\n    size_t remainder = lst.size() % vector_length;\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        svint32_t vec = svld1_s32(pg, &lst[i * vector_length]);\n\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n        if (svptest_any(pg, neg_mask)) {\n            if (!neg_found) {\n                largest_neg_vec = svmaxv_s32(pg, vec);\n                neg_found = true;\n            } else {\n                largest_neg_vec = std::max(largest_neg_vec, svmaxv_s32(pg, vec));\n            }\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n        if (svptest_any(pg, pos_mask)) {\n            if (!pos_found) {\n                smallest_pos_vec = svminv_s32(pg, vec);\n                pos_found = true;\n            } else {\n                smallest_pos_vec = std::min(smallest_pos_vec, svminv_s32(pg, vec));\n            }\n        }\n    }\n\n    if (remainder > 0) {\n        std::vector<int32_t> tail(lst.begin() + num_vectors * vector_length, lst.end());\n        tail.resize(vector_length, 0);\n\n        svint32_t vec = svld1_s32(pg, tail.data());\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n         if (svptest_any(pg, neg_mask)) {\n            if (!neg_found) {\n                largest_neg_vec = svmaxv_s32(pg, vec);\n                neg_found = true;\n            } else {\n                largest_neg_vec = std::max(largest_neg_vec, svmaxv_s32(pg, vec));\n            }\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n        if (svptest_any(pg, pos_mask)) {\n            if (!pos_found) {\n                smallest_pos_vec = svminv_s32(pg, vec);\n                pos_found = true;\n            } else {\n                smallest_pos_vec = std::min(smallest_pos_vec, svminv_s32(pg, vec));\n            }\n        }\n    }\n\n    if (neg_found) {\n        largest_negative = largest_neg_vec;\n    }\n    if (pos_found) {\n        smallest_positive = smallest_pos_vec;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svIsActive(svptrue_b32(), svptrue_b32());\n    int32_t largest_neg_vec = 0;\n    int32_t smallest_pos_vec = 0;\n    bool neg_found = false;\n    bool pos_found = false;\n\n    size_t vector_length = svcntw();\n    size_t loop_count = lst.size() / vector_length;\n    size_t remainder = lst.size() % vector_length;\n\n    for (size_t i = 0; i < loop_count; ++i) {\n        svint32_t vec = svld1_s32(pg, &lst[i * vector_length]);\n\n        svbool_t neg_mask = svcmpgt_s32(pg, svdup_n_s32(0), vec);\n        if (svptest_any(pg, neg_mask)) {\n            svint32_t neg_values = svand_s32(neg_mask, vec);\n            int32_t temp_largest = largest_negative;\n            for (size_t j = 0; j < vector_length; ++j) {\n                if (svptest_lane(neg_mask, j)) {\n                    int32_t val = svget_s32(neg_values, j);\n                    if (!neg_found || val > temp_largest) {\n                        temp_largest = val;\n                        neg_found = true;\n                    }\n                }\n            }\n            largest_negative = temp_largest;\n        }\n\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n        if (svptest_any(pg, pos_mask)) {\n            svint32_t pos_values = svand_s32(pos_mask, vec);\n            int32_t temp_smallest = smallest_positive;\n            for (size_t j = 0; j < vector_length; ++j) {\n                if (svptest_lane(pos_mask, j)) {\n                    int32_t val = svget_s32(pos_values, j);\n                    if (!pos_found || val < temp_smallest) {\n                        temp_smallest = val;\n                        pos_found = true;\n                    }\n                }\n            }\n            if (!pos_found) {\n                smallest_positive = temp_smallest;\n                pos_found = true;\n            } else if (temp_smallest < smallest_positive) {\n                smallest_positive = temp_smallest;\n            }\n        }\n    }\n\n    for (size_t i = loop_count * vector_length; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            if (!neg_found || lst[i] > largest_negative) {\n                largest_negative = lst[i];\n                neg_found = true;\n            }\n        } else if (lst[i] > 0) {\n            if (!pos_found || lst[i] < smallest_positive) {\n                smallest_positive = lst[i];\n                pos_found = true;\n            }\n        }\n    }\n    \n    if (!neg_found) largest_negative = 0;\n    if (!pos_found) smallest_positive = 0;\n    \n    return {largest_negative, (pos_found ? smallest_positive : 0)};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    for (size_t i = 0; i < n; ++i) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            int firstDigit = 0;\n            int temp = num;\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t sv_nums = svld1_s32(pg, &nums[i]);\n        svbool_t gt_10 = svcmpgt_s32(pg, sv_nums, svdup_n_s32(10));\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (i + j < n && svptest_first(pg, gt_10, i + j)) {\n                int num = nums[i + j];\n\n                int last_digit = num % 10;\n                if (last_digit < 0) last_digit *= -1;\n\n                int first_digit = num;\n                if (first_digit < 0) first_digit *= -1;\n                while (first_digit >= 10) {\n                    first_digit /= 10;\n                }\n\n                if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svIsActivePredicate(svTrue(), svFirst(svGetTypeSize(int)));\n\n    for (size_t i = 0; i < n; i++) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            int firstDigit = 0;\n            int temp = num;\n\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            \n            if ((firstDigit % 2 != 0) && (lastDigit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    for (size_t i = 0; i < n; ++i) {\n        if (nums[i] > 10) {\n            int num = nums[i];\n            int lastDigit = num % 10;\n            int firstDigit = 0;\n            int temp = num;\n            while (temp != 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if ((firstDigit % 2 != 0) && (lastDigit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t sv_nums = svld1_s32(pg, &nums[i]);\n\n        svbool_t greater_than_10 = svcmpgt_s32(pg, sv_nums, svdup_n_s32(10));\n\n        int32_t *p = (int32_t *)&nums[i];\n        for (int j = 0; j < svcntw(); ++j) {\n            if (i + j < n) {\n                if (svptest_any(pg, greater_than_10, (i + j) % svcntw())) {\n                    int num = nums[i + j];\n                    if (num > 0) {\n                        int lastDigit = num % 10;\n                        int firstDigit = num;\n                        while (firstDigit >= 10) {\n                            firstDigit /= 10;\n                        }\n\n                        if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count = 0;\n    uint64_t a[n];\n\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i + i + 1;\n    }\n\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) return 0;\n\n    uint64_t count0 = 0;\n    uint64_t count1 = 0;\n    uint64_t count2 = 0;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = (i * i - i + 1) % 3;\n        if (val == 0) count0++;\n        else if (val == 1) count1++;\n        else count2++;\n    }\n\n    return (count0 * (count0 - 1) * (count0 - 2) / 6) +\n           (count1 * (count1 - 1) * (count1 - 2) / 6) +\n           (count2 * (count2 - 1) * (count2 - 2) / 6) +\n           (count0 * count1 * count2);\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count = 0;\n    uint64_t a[n];\n\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i + i + 1;\n    }\n\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 1; i <= n - 2; ++i) {\n        for (uint64_t j = i + 1; j <= n - 1; ++j) {\n            for (uint64_t k = j + 1; k <= n; ++k) {\n                uint64_t ai = i * i - i + 1;\n                uint64_t aj = j * j - j + 1;\n                uint64_t ak = k * k - k + 1;\n\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t count = 0;\n    uint64_t a[n];\n\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i + i + 1;\n    }\n\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n\n    int is_prime = 1;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    if (is_prime) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svfloat32_t vf = svld1(pg, &lst[i]);\n        svint32_t vi = svcvt_s32_f32(vf);\n        svbool_t positive_mask = svcmpge(pg, vf, 0.0);\n        svint32_t masked_vi = svsel(positive_mask, vi, 0);\n        svint32_t odd_mask = svand_n_s32(masked_vi, 1);\n        svbool_t odd_bool = svcmpne(pg, odd_mask, 0);\n        svint32_t sq = svmul_x(odd_bool, masked_vi, masked_vi);\n        sum += svaddv_u64(sq);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vf = svld1(pg, &lst[i]);\n        svint32_t vi = svrintz_s32_f32(vf);\n        svbool_t valid = svptrue_b32();\n        svbool_t is_positive = svcmpge(valid, vf, 0.0);\n        svbool_t is_integer = svcmpeq(valid, svcvt_f32_s32(vi), vf);\n        svbool_t is_odd = svand_b32(svcmpne(valid, sviand_n_s32(vi, 1), 0), svand_b32(is_positive, is_integer));\n\n        svint32_t odd_numbers = svselect(is_odd, vi, 0);\n        svint64_t odd_numbers_squared = svmul_x(is_odd, (svint64_t)odd_numbers, (svint64_t)odd_numbers);\n        sum += svaddv(valid, odd_numbers_squared);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svfloat32_t vf = svld1(pg, &lst[i]);\n        svint32_t vi = svcvt_s32_f32(vf);\n        svbool_t positive_mask = svcmpge(pg, vf, 0.0);\n        svbool_t integer_mask = svcmpe(pg, svcvt_f32_s32(vi), vf);\n        svbool_t odd_mask = svand_z(pg, svnot_b(svcmpne(pg, sviand_n_s32(vi, 1), 0)), svand_z(pg, positive_mask, integer_mask));\n        svint32_t odd_numbers = svsel(odd_mask, vi, 0);\n        svint64_t odd_numbers_squared = svmul_x(odd_mask, (svint64_t)odd_numbers, (svint64_t)odd_numbers);\n        sum += svaddv_s64(pg, odd_numbers_squared);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vf = svld1(pg, &lst[i]);\n        svint32_t vi = svcvt_s32_f32(vf);\n        svbool_t positive_mask = svcmpge_n_s32(pg, vi, 0);\n        svint32_t masked_vi = svsel(positive_mask, vi, svdup_n_s32(0));\n        svbool_t odd_mask = svcmpne_n_s32(pg, sveor_n_s32(masked_vi, 1), masked_vi);\n        svint32_t odd_numbers = svsel(odd_mask, masked_vi, svdup_n_s32(0));\n        svuint64_t odd_numbers_squared = svmul_x_u64_s32(pg, svcvt_u64_s32(odd_numbers), odd_numbers);\n        sum += svaddv_u64(pg, odd_numbers_squared);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vf = svld1(pg, &lst[i]);\n        svint32_t vi = svcvt_s32_f32(vf);\n        svbool_t is_positive = svcmpge(pg, vf, 0.0);\n        svbool_t is_integer = sveq(pg, svcvt_f32_s32(vi), vf);\n        svbool_t is_odd = svand_z(pg, sveq(pg, svand_n_s32(vi, 1), 1), svptrue_b32());\n        svbool_t mask = svand3(pg, is_positive, is_integer, is_odd);\n        svint32_t odd_numbers = svsel(mask, vi, 0);\n        svint64_t odd_numbers_squared = svmul_x(mask, (svint64_t)odd_numbers, (svint64_t)odd_numbers);\n        sum += svaddv(mask, odd_numbers_squared);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    int n = game.size();\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_game = svld1_s32(pg, &game[i]);\n        svint32_t sv_guess = svld1_s32(pg, &guess[i]);\n        svint32_t diff = svabs_s32_x(pg, svsub_s32_x(pg, sv_game, sv_guess));\n        svint32_t correct = sveq_s32(sv_game, sv_guess);\n        svint32_t res = svsel_s32(correct, svdup_n_s32(0), diff);\n        svst1_s32(pg, &result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_game = svld1_s32(pg, &game[i]);\n        svint32_t sv_guess = svld1_s32(pg, &guess[i]);\n        svint32_t diff = svabs_s32_x(pg, svsub_s32_x(pg, sv_game, sv_guess));\n        svint32_t correct = sveq_s32(sv_game, sv_guess);\n        svint32_t res = svsel_s32(correct, svdup_n_s32(0), diff);\n        svst1_s32(pg, &result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    int n = game.size();\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        }\n    }\n    return result;\n}\n```"}

{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n  if (arr == NULL || start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n\n  if (len <= 1) {\n    return;\n  }\n\n  uint64_t i = start;\n  uint64_t j = end;\n\n  while (i < j) {\n    int16_t temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n  if (arr == NULL || start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n\n  if (len <= 1) {\n    return;\n  }\n\n  uint64_t i = start;\n  uint64_t j = end;\n\n  while (i < j) {\n    int16_t temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n  if (arr == NULL || start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n\n  if (len <= 1) {\n    return;\n  }\n\n  uint64_t i = start;\n  uint64_t j = end;\n\n  while (i < j) {\n    int16_t temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n  if (arr == NULL || start >= end) {\n    return;\n  }\n\n  uint64_t len = end - start + 1;\n\n  if (start < 0 || end < 0) return;\n\n  int16_t temp;\n  for (uint64_t i = 0; i < len / 2; i++) {\n    temp = arr[start + i];\n    arr[start + i] = arr[end - i];\n    arr[end - i] = temp;\n  }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    if (arr == NULL || start >= end) {\n        return;\n    }\n\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i, j;\n    if (slice_idx >= dim3) return;\n\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            size_t index_3d = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t index_2d = i * dim2 + j;\n            slice[index_2d] = tensor[index_3d];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i, j;\n    if (slice_idx >= dim3) return;\n\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            size_t index_3d = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t index_2d = i * dim2 + j;\n            slice[index_2d] = tensor[index_3d];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i, j;\n    if (slice_idx >= dim3) return;\n\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            size_t index_3d = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t index_2d = i * dim2 + j;\n            slice[index_2d] = tensor[index_3d];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i, j;\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            size_t index_3d = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t index_2d = i * dim2 + j;\n            slice[index_2d] = tensor[index_3d];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i, j;\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            size_t index_3d = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t index_2d = i * dim2 + j;\n            slice[index_2d] = tensor[index_3d];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < rows && x < i + block_size; ++x) {\n                for (size_t y = j; y < cols && y < j + block_size; ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < rows && x < i + block_size; ++x) {\n                for (size_t y = j; y < cols && y < j + block_size; ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < rows && x < i + block_size; ++x) {\n                for (size_t y = j; y < cols && y < j + block_size; ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < rows && x < i + block_size; ++x) {\n                for (size_t y = j; y < cols && y < j + block_size; ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t x = i; x < rows && x < i + block_size; ++x) {\n                for (size_t y = j; y < cols && y < j + block_size; ++y) {\n                    dst[y * rows + x] = src[x * cols + y];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n  float sum = 0.0f;\n  for (size_t i = 0; i < dim; ++i) {\n    sum += array[i * dim * dim + i * dim + i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n  float sum = 0.0f;\n  for (size_t i = 0; i < dim; ++i) {\n    sum += array[i * dim * dim + i * dim + i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n  float sum = 0.0f;\n  for (size_t i = 0; i < dim; ++i) {\n    sum += array[i * dim * dim + i * dim + i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n  float sum = 0.0f;\n  for (size_t i = 0; i < dim; ++i) {\n    size_t index = i * dim * dim + i * dim + i;\n    sum += array[index];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t new_row_index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[new_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t new_row_index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[new_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t new_row_index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[new_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = -1;\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] % 2 == 0) {\n            if (min_val == -1 || src[i] < min_val) {\n                min_val = src[i];\n            }\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = -1;\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0) {\n            if (min_val == -1 || src[i] < min_val) {\n                min_val = src[i];\n            }\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = -1;\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] % 2 == 0) {\n            if (min_val == -1 || src[i] < min_val) {\n                min_val = src[i];\n            }\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = -1;\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] % 2 == 0) {\n            if (min_val == -1 || src[i] < min_val) {\n                min_val = src[i];\n            }\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_val = -1;\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0) {\n            if (min_val == -1 || src[i] < min_val) {\n                min_val = src[i];\n            }\n        }\n    }\n    \n    if (min_val == -1)\n        return -1;\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)(((unsigned int)src[i]) >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < rows * cols; ++i) {\n    sum += matrix[i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < rows * cols; ++i) {\n    sum += matrix[i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < rows * cols; ++i) {\n    sum += matrix[i];\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 0; j < cols; ++j) {\n      sum += matrix[i * cols + j];\n    }\n  }\n  return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  for (size_t i = 1; i < length; ++i) {\n    if (src[i] > max_value) {\n      max_value = src[i];\n      max_index = i;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  for (size_t i = 1; i < length; ++i) {\n    if (src[i] > max_value) {\n      max_value = src[i];\n      max_index = i;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  for (size_t i = 1; i < length; ++i) {\n    if (src[i] > max_value) {\n      max_value = src[i];\n      max_index = i;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n  if (length == 0) {\n    return 0;\n  }\n\n  size_t max_index = 0;\n  int8_t max_value = src[0];\n\n  for (size_t i = 1; i < length; ++i) {\n    if (src[i] > max_value) {\n      max_value = src[i];\n      max_index = i;\n    }\n  }\n\n  return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            num &= (num - 1);\n            count++;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            num &= (num - 1);\n            count++;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            num &= (num - 1);\n            count++;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            num &= (num - 1);\n            count++;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            num &= (num - 1);\n            count++;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 &&\n                    B[k * p + j] >= -100.0 && B[k * p + j] <= 100.0) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 &&\n                    B[k * p + j] >= -100.0 && B[k * p + j] <= 100.0) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 &&\n                    B[k * p + j] >= -100.0 && B[k * p + j] <= 100.0) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 &&\n                    B[k * p + j] >= -100.0 && B[k * p + j] <= 100.0) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            for (k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            for (k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            for (k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            for (k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; ++j) {\n            for (k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stdio.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stdio.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stdio.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stdio.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stdio.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n  size_t i, j;\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < n; j++) {\n      dst[i * n + j] = mat[i * n + j] * scalar;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        if (sub_result > 0.0f) {\n            dst[i] = floorf(sub_result);\n        } else {\n            dst[i] = ceilf(sub_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        float sub_result = tensor1[i] - tensor2[i];\n        if (sub_result > 0.0f) {\n            dst[i] = floorf(sub_result);\n        } else {\n            dst[i] = ceilf(sub_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        if (result > 0.0f) {\n            dst[i] = floorf(result);\n        } else {\n            dst[i] = ceilf(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = truncf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h> // For truncf\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = truncf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    dst[i] = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n      dst[i] += mat[i * n + j] * vec[j];\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    dst[i] = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n      dst[i] += mat[i * n + j] * vec[j];\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    dst[i] = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n      dst[i] += mat[i * n + j] * vec[j];\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n  for (size_t i = 0; i < m; ++i) {\n    dst[i] = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n      dst[i] += mat[i * n + j] * vec[j];\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\n#include <stddef.h>\n\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n  for (size_t i = 0; i < rows; ++i) {\n    bool match = true;\n    for (size_t j = 0; j < cols; ++j) {\n      if (matrix[i * cols + j] != vector[j]) {\n        match = false;\n        break;\n      }\n    }\n    if (match) {\n      return true;\n    }\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n  for (size_t i = 0; i < rows; ++i) {\n    bool match = true;\n    for (size_t j = 0; j < cols; ++j) {\n      if (matrix[i * cols + j] != vector[j]) {\n        match = false;\n        break;\n      }\n    }\n    if (match) {\n      return true;\n    }\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n  for (size_t i = 0; i < rows; ++i) {\n    bool match = true;\n    for (size_t j = 0; j < cols; ++j) {\n      if (matrix[i * cols + j] != vector[j]) {\n        match = false;\n        break;\n      }\n    }\n    if (match) {\n      return true;\n    }\n  }\n  return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t size = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t size = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t size = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t size = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t size = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  for (size_t i = 0; i < length; ++i) {\n    int64_t temp = a * x[i];\n    if (temp < 0) {\n      y[i] = -temp;\n    } else {\n      y[i] = temp;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  for (size_t i = 0; i < length; ++i) {\n    int64_t temp = a * x[i];\n    if (temp < 0) {\n      y[i] = -temp;\n    } else {\n      y[i] = temp;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  for (size_t i = 0; i < length; ++i) {\n    int64_t temp = a * x[i];\n    if (temp < 0) {\n      y[i] = -temp;\n    } else {\n      y[i] = temp;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  for (size_t i = 0; i < length; ++i) {\n    int64_t temp = a * x[i];\n    if (temp < 0) {\n      y[i] = -temp;\n    } else {\n      y[i] = temp;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n  for (size_t i = 0; i < length; ++i) {\n    int64_t temp = a * x[i];\n    if (temp < 0) {\n      y[i] = -temp;\n    } else {\n      y[i] = temp;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 1; j < cols; ++j) {\n      if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 1; j < cols; ++j) {\n      if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 1; j < cols; ++j) {\n      if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 1; j < cols; ++j) {\n      if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n  if (rows == 0 || cols == 0) {\n    return false;\n  }\n\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 1; j < cols; ++j) {\n      if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t i = 0; i < num_row_blocks; ++i) {\n        for (size_t j = 0; j < num_col_blocks; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                for (size_t col = 0; col < block_size; ++col) {\n                    if (matrix[(i * block_size + row) * cols + (j * block_size + col)] != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t i = 0; i < num_row_blocks; ++i) {\n        for (size_t j = 0; j < num_col_blocks; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                for (size_t col = 0; col < block_size; ++col) {\n                    if (matrix[(i * block_size + row) * cols + (j * block_size + col)] != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t i = 0; i < num_row_blocks; ++i) {\n        for (size_t j = 0; j < num_col_blocks; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                for (size_t col = 0; col < block_size; ++col) {\n                    if (matrix[(i * block_size + row) * cols + (j * block_size + col)] != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t i = 0; i < num_row_blocks; ++i) {\n        for (size_t j = 0; j < num_col_blocks; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                for (size_t col = 0; col < block_size; ++col) {\n                    if (matrix[(i * block_size + row) * cols + (j * block_size + col)] != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t i = 0; i < num_row_blocks; ++i) {\n        for (size_t j = 0; j < num_col_blocks; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            for (size_t row = 0; row < block_size; ++row) {\n                for (size_t col = 0; col < block_size; ++col) {\n                    if (matrix[(i * block_size + row) * cols + (j * block_size + col)] != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  for (size_t i = 1; i < num_blocks; ++i) {\n    for (size_t j = 0; j < block_size; ++j) {\n      if (abs(vec[j] - vec[i * block_size + j]) > tolerance) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  for (size_t i = 1; i < num_blocks; ++i) {\n    for (size_t j = 0; j < block_size; ++j) {\n      if (abs(vec[j] - vec[i * block_size + j]) > tolerance) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  for (size_t i = 1; i < num_blocks; ++i) {\n    for (size_t j = 0; j < block_size; ++j) {\n      if (abs(vec[j] - vec[i * block_size + j]) > tolerance) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  for (size_t i = 1; i < num_blocks; ++i) {\n    for (size_t j = 0; j < block_size; ++j) {\n      if (abs(vec[j] - vec[i * block_size + j]) > tolerance) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n  if (vec == nullptr || length == 0 || block_size == 0 || tolerance < 0) {\n    return false;\n  }\n\n  if (block_size > length) {\n    return false;\n  }\n\n  size_t num_blocks = length / block_size;\n\n  if (num_blocks == 0) {\n    return false;\n  }\n\n  for (size_t i = 1; i < num_blocks; ++i) {\n    for (size_t j = 0; j < block_size; ++j) {\n      if (abs(vec[j] - vec[i * block_size + j]) > tolerance) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double element = matrix[i * cols + j];\n            norm += element * element;\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n  for (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n  }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (int64_t)A[i] * A[i] - (int64_t)A[i] * B[i];\n    }\n    return sum_sq;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (int64_t)A[i] * A[i] - (int64_t)A[i] * B[i];\n    }\n    return sum_sq;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (int64_t)A[i] * A[i] - (int64_t)A[i] * B[i];\n    }\n    return sum_sq;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (int64_t)A[i] * A[i] - (int64_t)A[i] * B[i];\n    }\n    return sum_sq;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (int64_t)A[i] * A[i] - (int64_t)A[i] * B[i];\n    }\n    return sum_sq;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  for (size_t i = 0; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  for (size_t i = 0; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  for (size_t i = 0; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n  for (size_t i = 0; i < length; ++i) {\n    if (A[i] > 0 && B[i] > 0) {\n      C[i] = 1;\n    } else if (A[i] < 0 && B[i] < 0) {\n      C[i] = -1;\n    } else {\n      C[i] = 0;\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\n*/\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\n*/\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\n*/\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        for (int j = 0; j < 32; ++j) {\n            if ((val >> j) & 1) {\n                count++;\n            }\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            if (A[index] % 3 == 0) {\n                B[index] = abs(A[index]);\n            } else {\n                B[index] = A[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n  for (size_t i = 0; i < rows; ++i) {\n    for (size_t j = 0; j < cols; ++j) {\n      size_t index = i * cols + j;\n      if (A[index] % 3 == 0) {\n        B[index] = abs(A[index]);\n      } else {\n        B[index] = A[index];\n      }\n    }\n  }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            if (A[index] % 3 == 0) {\n                B[index] = abs(A[index]);\n            } else {\n                B[index] = A[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            if (A[index] % 3 == 0) {\n                B[index] = abs(A[index]);\n            } else {\n                B[index] = A[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            if (A[index] % 3 == 0) {\n                B[index] = abs(A[index]);\n            } else {\n                B[index] = A[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            rotate_bits %= 32;\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            rotate_bits %= 32;\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            rotate_bits %= 32;\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            rotate_bits %= 32;\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            rotate_bits %= 32;\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = abs(epsilon);\n\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = abs(epsilon);\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = abs(epsilon);\n\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = abs(epsilon);\n\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = abs(epsilon);\n\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n  for (size_t i = 0; i < size; i++) {\n    float division_result = A[i] / B[i];\n    C[i] = (int32_t)roundf(division_result);\n  }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n  for (size_t i = 0; i < size; i++) {\n    float result = A[i] / B[i];\n    C[i] = (int32_t)roundf(result);\n  }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            }\n            if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_16 = A[i] >> 16;\n        float float_value = (float)high_16;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n#include <stddef.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_16 = A[i] >> 16;\n        float float_value = (float)high_16;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n  for (size_t i = 0; i < size; i++) {\n    B[i] = *(float*)&A[i];\n  }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n  for (size_t i = 0; i < length; i++) {\n    dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n  }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += input[(i + m) * input_size + (j + n)] * kernel[m * kernel_size + n];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += input[(i + m) * input_size + (j + n)] * kernel[m * kernel_size + n];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += input[(i + m) * input_size + (j + n)] * kernel[m * kernel_size + n];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += input[(i + m) * input_size + (j + n)] * kernel[m * kernel_size + n];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    sum += input[(i + m) * input_size + (j + n)] * kernel[m * kernel_size + n];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) {\n        return false;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int operation : operations){\n        balance += operation;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int operation : operations){\n        balance += operation;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int operation : operations){\n        balance += operation;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int operation : operations){\n        balance += operation;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int operation : operations){\n        balance += operation;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double absolute_deviation_sum = 0.0;\n    for (double number : numbers) {\n        absolute_deviation_sum += std::abs(number - mean);\n    }\n\n    return absolute_deviation_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double absolute_deviation_sum = 0.0;\n    for (double number : numbers) {\n        absolute_deviation_sum += std::abs(number - mean);\n    }\n    return absolute_deviation_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double absolute_deviation_sum = 0.0;\n    for (double number : numbers) {\n        absolute_deviation_sum += std::abs(number - mean);\n    }\n    return absolute_deviation_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double absolute_deviation_sum = 0.0;\n    for (double number : numbers) {\n        absolute_deviation_sum += std::abs(number - mean);\n    }\n\n    return absolute_deviation_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n\n    double absolute_deviation_sum = 0.0;\n    for (double number : numbers) {\n        absolute_deviation_sum += std::abs(number - mean);\n    }\n\n    return absolute_deviation_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int16_t number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {(int64_t)sum, (int64_t)product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int16_t number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {(int64_t)sum, (int64_t)product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int16_t number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {(int64_t)sum, (int64_t)product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int16_t number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {(int64_t)sum, (int64_t)product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    for (int16_t number : numbers) {\n        sum += number;\n        product *= number;\n    }\n\n    return {(int64_t)sum, (int64_t)product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for(int i = 0; i < numbers.size(); ++i){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = -2147483648;\n    for (int number : numbers) {\n        current_max = std::max(current_max, number);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for(int i = 0; i < numbers.size(); ++i){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for(int i = 0; i < numbers.size(); i++){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for(int i = 0; i < numbers.size(); i++){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(int i = 0; i < a.length(); i++){\n        if(a[i] == b[i]){\n            result += \"0\";\n        }else{\n            result += \"1\";\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(int i = 0; i < a.length(); i++){\n        if(a[i] == b[i]){\n            result += \"0\";\n        }\n        else{\n            result += \"1\";\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(int i = 0; i < a.length(); i++){\n        if(a[i] == b[i]){\n            result += \"0\";\n        }else{\n            result += \"1\";\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(int i = 0; i < a.length(); i++){\n        if(a[i] == b[i]){\n            result += \"0\";\n        } else {\n            result += \"1\";\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(int i = 0; i < a.length(); i++){\n        if(a[i] == b[i]){\n            result += \"0\";\n        }else{\n            result += \"1\";\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > longest_string.length()) {\n            longest_string = strings[i];\n        }\n    }\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > longest_string.length()) {\n            longest_string = strings[i];\n        }\n    }\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > longest_string.length()) {\n            longest_string = strings[i];\n        }\n    }\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > longest_string.length()) {\n            longest_string = strings[i];\n        }\n    }\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_string = strings[0];\n    for (const std::string &s : strings) {\n        if (s.length() > longest_string.length()) {\n            longest_string = s;\n        }\n    }\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    if (b == 0) {\n        return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <float.h>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = FLT_MAX;\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = numbers[i];\n                num2 = numbers[j];\n            }\n        }\n    }\n\n    if (num1 > num2) {\n        return {num2, num1};\n    } else {\n        return {num1, num2};\n    }\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <float.h>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float min_diff = FLT_MAX;\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <float.h>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = FLT_MAX;\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = numbers[i];\n                num2 = numbers[j];\n            }\n        }\n    }\n\n    if (num1 > num2) {\n        return {num2, num1};\n    } else {\n        return {num1, num2};\n    }\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <float.h>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = FLT_MAX;\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = numbers[i];\n                num2 = numbers[j];\n            }\n        }\n    }\n\n    if (num1 > num2) {\n        return {num2, num1};\n    } else {\n        return {num1, num2};\n    }\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <float.h>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float min_diff = FLT_MAX;\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = numbers[i];\n                num2 = numbers[j];\n            }\n        }\n    }\n\n    if (num1 > num2) {\n        return {num2, num1};\n    } else {\n        return {num1, num2};\n    }\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    for (float num : numbers) {\n        min_val = std::min(min_val, num);\n        max_val = std::max(max_val, num);\n    }\n\n    if (min_val == max_val) {\n        std::vector<float> rescaled_numbers(numbers.size(), 0.0);\n        return rescaled_numbers;\n    }\n\n    float range = max_val - min_val;\n    std::vector<float> rescaled_numbers;\n    for (float num : numbers) {\n        rescaled_numbers.push_back((num - min_val) / range);\n    }\n\n    return rescaled_numbers;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; i--){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; i--){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; i--){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; i--){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; i--){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    int divisor = 2;\n    while (n > 1) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor++;\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n  std::vector<float> positive_numbers;\n  for (float number : l) {\n    if (number > 0) {\n      positive_numbers.push_back(number);\n    }\n  }\n  return positive_numbers;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> positive_numbers;\n    for (float num : l) {\n        if (num > 0) {\n            positive_numbers.push_back(num);\n        }\n    }\n    return positive_numbers;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    for (int64_t i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n  if (n <= 1) {\n    return false;\n  }\n  for (int64_t i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    for (int64_t i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n  if (n <= 1) {\n    return false;\n  }\n  for (int64_t i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    for (int64_t i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n\nstd::string solve(const std::string & s){\n    std::string res = s;\n    bool hasLetters = false;\n    for(int i = 0; i < s.length(); i++){\n        if(isalpha(s[i])){\n            hasLetters = true;\n            if(islower(s[i])){\n                res[i] = toupper(s[i]);\n            }else{\n                res[i] = tolower(s[i]);\n            }\n        }\n    }\n    if(!hasLetters){\n        std::reverse(res.begin(), res.end());\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n\nstd::string solve(const std::string & s){\n    std::string res = s;\n    bool hasLetters = false;\n    for(char c : s){\n        if(isalpha(c)){\n            hasLetters = true;\n            break;\n        }\n    }\n    if(!hasLetters){\n        std::reverse(res.begin(), res.end());\n        return res;\n    }\n    for(int i = 0; i < res.size(); i++){\n        if(isalpha(res[i])){\n            if(islower(res[i])){\n                res[i] = toupper(res[i]);\n            } else {\n                res[i] = tolower(res[i]);\n            }\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n\nstd::string solve(const std::string & s){\n    std::string res = s;\n    bool hasLetters = false;\n    for(char c : s){\n        if(isalpha(c)){\n            hasLetters = true;\n            break;\n        }\n    }\n    if(!hasLetters){\n        std::reverse(res.begin(), res.end());\n        return res;\n    }\n    for(int i = 0; i < res.size(); i++){\n        if(isalpha(res[i])){\n            if(islower(res[i])){\n                res[i] = toupper(res[i]);\n            } else {\n                res[i] = tolower(res[i]);\n            }\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n\nstd::string solve(const std::string & s){\n    std::string result = s;\n    bool hasLetters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (int i = 0; i < result.length(); ++i) {\n            if (isalpha(result[i])) {\n                if (islower(result[i])) {\n                    result[i] = toupper(result[i]);\n                } else {\n                    result[i] = tolower(result[i]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n\nstd::string solve(const std::string & s){\n    std::string result = s;\n    bool hasLetters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (int i = 0; i < result.length(); ++i) {\n            if (isalpha(result[i])) {\n                if (islower(result[i])) {\n                    result[i] = toupper(result[i]);\n                } else {\n                    result[i] = tolower(result[i]);\n                }\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    int divisible_index = 0;\n    std::vector<int> result;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            result.push_back(divisible_by_three[divisible_index]);\n            divisible_index++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    int divisible_index = 0;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            l[i] = divisible_by_three[divisible_index];\n            divisible_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    int divisible_index = 0;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            l[i] = divisible_by_three[divisible_index];\n            divisible_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    int divisible_index = 0;\n    std::vector<int> result;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            result.push_back(divisible_by_three[divisible_index]);\n            divisible_index++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    int divisible_index = 0;\n    std::vector<int> result;\n    for(int i = 0; i < l.size(); i++){\n        if(i % 3 == 0){\n            result.push_back(divisible_by_three[divisible_index]);\n            divisible_index++;\n        } else {\n            result.push_back(l[i]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (int i = 1; i < l.size(); i++){\n        if (l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (int i = 1; i < l.size(); i++){\n        if (l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(int i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (int i = 1; i < l.size(); i++){\n        if (l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(int i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```python\ndef fizz_buzz(n):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            s = str(i)\n            count += s.count('7')\n    return count\n```"}
{"task_id": "SimdBench_80", "completion": "```python\ndef fizz_buzz(n):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            s = str(i)\n            count += s.count('7')\n    return count\n```"}
{"task_id": "SimdBench_80", "completion": "```python\ndef fizz_buzz(n):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            s = str(i)\n            count += s.count('7')\n    return count\n```"}
{"task_id": "SimdBench_80", "completion": "```python\ndef fizz_buzz(n):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            s = str(i)\n            count += s.count('7')\n    return count\n```"}
{"task_id": "SimdBench_80", "completion": "```python\ndef fizz_buzz(n):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            s = str(i)\n            count += s.count('7')\n    return count\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_indexed_values;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            even_indexed_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_indexed_values.begin(), even_indexed_values.end());\n    size_t even_index = 0;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            l[i] = even_indexed_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_indexed_values;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            even_indexed_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_indexed_values.begin(), even_indexed_values.end());\n    size_t even_index = 0;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            l[i] = even_indexed_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_indexed_values;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            even_indexed_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_indexed_values.begin(), even_indexed_values.end());\n    size_t even_index = 0;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            l[i] = even_indexed_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for(size_t i = 0; i < l.size(); ++i){\n        if(i % 2 == 0){\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    \n    std::vector<float> result = l;\n    size_t even_index = 0;\n    for(size_t i = 0; i < result.size(); ++i){\n        if(i % 2 == 0){\n            result[i] = even_elements[even_index];\n            even_index++;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_indexed_values;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            even_indexed_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_indexed_values.begin(), even_indexed_values.end());\n    size_t even_index = 0;\n    for(size_t i = 0; i < l.size(); i++){\n        if(i % 2 == 0){\n            l[i] = even_indexed_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3){\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++){\n        for (int j = i + 1; j < l.size(); j++){\n            for (int k = j + 1; k < l.size(); k++){\n                if (l[i] + l[j] + l[k] == 0){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3){\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++){\n        for (int j = i + 1; j < l.size(); j++){\n            for (int k = j + 1; k < l.size(); k++){\n                if (l[i] + l[j] + l[k] == 0){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            for (int k = j + 1; k < l.size(); k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n  std::vector<int> result;\n  for (int x : l) {\n    result.push_back(x + 1);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n  std::vector<int> result;\n  for (int x : l) {\n    result.push_back(x + 1);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n  std::vector<int> result;\n  for (int x : l) {\n    result.push_back(x + 1);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n  std::vector<int> result;\n  for (int x : l) {\n    result.push_back(x + 1);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n  std::vector<int> result;\n  for (int x : l) {\n    result.push_back(x + 1);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n    for (int i = 0; i < l.size(); i++) {\n        for (int j = i + 1; j < l.size(); j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result = \"\";\n    while (x > 0) {\n        int digit = x % base;\n        result = std::to_string(digit) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result += std::to_string(remainder);\n        x /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\ndecode_shift: takes as input string encoded with encode_shift function. Returns decoded string.\n*/\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\ndecode_shift: takes as input string encoded with encode_shift function. Returns decoded string.\n*/\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\ndecode_shift: takes as input string encoded with encode_shift function. Returns decoded string.\n*/\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int i = 0; i < l.size(); i++){\n        if(l[i] >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```python\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```python\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```python\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```python\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```python\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            count++;\n        } else if (bracket == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){\n            count++;\n        } else if (c == 'y' && i == s.length() - 1){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){\n            count++;\n        } else if (c == 'y' && i == s.length() - 1){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){\n            count++;\n        } else if (c == 'y' && i == s.length() - 1){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){\n            count++;\n        } else if (c == 'y' && i == s.length() - 1){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){\n            count++;\n        } else if (c == 'y' && i == s.length() - 1){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += (int)c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n    int smallest_even = -1;\n    int smallest_index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n    if (smallest_even == -1) {\n        return {};\n    }\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n    int smallest_even = -1;\n    int smallest_index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n    if (smallest_even == -1) {\n        return {};\n    }\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n    int smallest_even = -1;\n    int smallest_index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n    if (smallest_even == -1) {\n        return {};\n    }\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) {\n        return {};\n    } else {\n        return {smallest_even, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n    int smallest_even = -1;\n    int smallest_index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n    if (smallest_even == -1) {\n        return {};\n    }\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\nint search(std::vector<int> lst){\n    std::map<int, int> freq;\n    for(int x : lst){\n        freq[x]++;\n    }\n    int ans = -1;\n    for(auto const& [key, val] : freq){\n        if(key > 0 && val >= key){\n            ans = std::max(ans, key);\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\nint search(std::vector<int> lst){\n    std::map<int, int> freq;\n    for(int x : lst){\n        freq[x]++;\n    }\n    int ans = -1;\n    for(auto const& [key, val] : freq){\n        if(key > 0 && val >= key){\n            ans = std::max(ans, key);\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\nint search(std::vector<int> lst){\n    std::map<int, int> freq;\n    for(int x : lst){\n        freq[x]++;\n    }\n    int ans = -1;\n    for(auto const& [key, val] : freq){\n        if(key > 0 && val >= key){\n            ans = std::max(ans, key);\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\nint search(std::vector<int> lst){\n    std::map<int, int> freq;\n    for(int x : lst){\n        freq[x]++;\n    }\n    int ans = -1;\n    for(auto const& [key, val] : freq){\n        if(key > 0 && val >= key){\n            ans = std::max(ans, key);\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n\nint search(std::vector<int> lst){\n    std::map<int, int> freq;\n    for(int x : lst){\n        freq[x]++;\n    }\n    int ans = -1;\n    for(auto const& [key, val] : freq){\n        if(key > 0 && val >= key){\n            ans = std::max(ans, key);\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q,int w){\n    int sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    for(int i = 0; i < q.size() / 2; i++){\n        if(q[i] != q[q.size() - i - 1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q,int w){\n    int sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    for(int i = 0; i < q.size() / 2; i++){\n        if(q[i] != q[q.size() - i - 1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q,int w){\n    int sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    for(int i = 0; i < q.size() / 2; i++){\n        if(q[i] != q[q.size() - i - 1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q,int w){\n    int sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    for(int i = 0; i < q.size() / 2; i++){\n        if(q[i] != q[q.size() - i - 1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q,int w){\n    int sum = 0;\n    for(int i = 0; i < q.size(); i++){\n        sum += q[i];\n    }\n    if(sum > w){\n        return false;\n    }\n    for(int i = 0; i < q.size() / 2; i++){\n        if(q[i] != q[q.size() - i - 1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n/2; i++){\n        if(arr[i] != arr[n-i-1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; i++){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n / 2; i++){\n        if(arr[i] != arr[n - i - 1]){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int count = 0;\n    for(int i = 0; i < n/2; i++){\n        if(arr[i] != arr[n-i-1]){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0;\n    for(const std::string& str : lst1){\n        sum1 += str.length();\n    }\n    int sum2 = 0;\n    for(const std::string& str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }else{\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0;\n    for(const std::string& str : lst1){\n        sum1 += str.length();\n    }\n    int sum2 = 0;\n    for(const std::string& str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }else{\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0;\n    for(const std::string& str : lst1){\n        sum1 += str.length();\n    }\n    int sum2 = 0;\n    for(const std::string& str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }else{\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0;\n    for(const std::string& str : lst1){\n        sum1 += str.length();\n    }\n    int sum2 = 0;\n    for(const std::string& str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }else{\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0;\n    for(const std::string& str : lst1){\n        sum1 += str.length();\n    }\n    int sum2 = 0;\n    for(const std::string& str : lst2){\n        sum2 += str.length();\n    }\n    if(sum1 <= sum2){\n        return lst1;\n    }else{\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 0;\n    }\n    uint64_t p = 1;\n    while (p <= x) {\n        if (p == x) {\n            return true;\n        }\n        if (x / n < p) {\n            return false;\n        }\n        p *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 0;\n    }\n    if (x == 0) {\n        return false;\n    }\n    uint64_t p = 1;\n    while (p <= x) {\n        if (p == x) {\n            return true;\n        }\n        if (x / n < p) {\n            return false;\n        }\n        p *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 0;\n    }\n    if (x == 0) {\n        return false;\n    }\n    uint64_t p = 1;\n    while (p <= x) {\n        if (p == x) {\n            return true;\n        }\n        if (x / n < p) {\n            return false;\n        }\n        p *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 0;\n    }\n    if (x == 0) {\n        return false;\n    }\n    uint64_t p = 1;\n    while (p <= x) {\n        if (p == x) {\n            return true;\n        }\n        if (x / n < p) {\n            return false;\n        }\n        p *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) {\n        return x == 1;\n    }\n    if (n == 0) {\n        return x == 0;\n    }\n    if (x == 0) {\n        return false;\n    }\n    uint64_t p = 1;\n    while (p <= x) {\n        if (p == x) {\n            return true;\n        }\n        if (x / n < p) {\n            return false;\n        }\n        p *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n    for(int i = 0; i < s.length() - 2; i++){\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n    for(int i = 0; i < s.length() - 2; i++){\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n    for(int i = 0; i < s.length() - 2; i++){\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n    for(int i = 0; i < s.length() - 2; i++){\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n    for(int i = 0; i < s.length() - 2; i++){\n        if(s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N){\n    uint64_t sum = 0;\n    std::string binary = \"\";\n\n    std::string num_str = std::to_string(N);\n    for (char c : num_str) {\n        sum += (c - '0');\n    }\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    while (sum > 0) {\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N){\n    uint64_t sum = 0;\n    std::string result = \"\";\n\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if(sum == 0){\n        return \"0\";\n    }\n\n    while(sum > 0){\n        result += std::to_string(sum % 2);\n        sum /= 2;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N){\n    uint64_t sum = 0;\n    std::string result = \"\";\n    std::string temp = \"\";\n\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if(sum == 0){\n        return \"0\";\n    }\n\n    while(sum > 0){\n        temp += std::to_string(sum % 2);\n        sum /= 2;\n    }\n\n    for(int i = temp.length() - 1; i >= 0; i--){\n        result += temp[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N){\n    uint64_t sum = 0;\n    std::string binary = \"\";\n    std::string result = \"\";\n\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if(sum == 0){\n        return \"0\";\n    }\n\n    while(sum > 0){\n        binary += std::to_string(sum % 2);\n        sum /= 2;\n    }\n\n    for(int i = binary.length() - 1; i >= 0; i--){\n        result += binary[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N){\n    uint64_t sum = 0;\n    std::string result = \"\";\n\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n\n    if(sum == 0){\n        return \"0\";\n    }\n\n    while(sum > 0){\n        result += std::to_string(sum % 2);\n        sum /= 2;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 != 0 && lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 != 0 && lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 != 0 && lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 != 0 && lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 2 != 0 && lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (char)(((c - base + 4) % 26) + base);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (char)(((c - base + 4) % 26) + base);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (char)(((c - base + 4) % 26) + base);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (char)(((c - base + 4) % 26) + base);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (char)(((c - base + 4) % 26) + base);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                char upperC = toupper(c);\n                if (upperC == 'A') {\n                    encodedMessage += 'C';\n                } else if (upperC == 'E') {\n                    encodedMessage += 'G';\n                } else if (upperC == 'I') {\n                    encodedMessage += 'K';\n                } else if (upperC == 'O') {\n                    encodedMessage += 'Q';\n                } else if (upperC == 'U') {\n                    encodedMessage += 'W';\n                } else {\n                    encodedMessage += upperC;\n                }\n            } else {\n                char lowerC = tolower(c);\n                if (lowerC == 'a') {\n                    encodedMessage += 'c';\n                } else if (lowerC == 'e') {\n                    encodedMessage += 'g';\n                } else if (lowerC == 'i') {\n                    encodedMessage += 'k';\n                } else if (lowerC == 'o') {\n                    encodedMessage += 'q';\n                } else if (lowerC == 'u') {\n                    encodedMessage += 'w';\n                } else {\n                    encodedMessage += lowerC;\n                }\n            }\n        } else {\n            encodedMessage += c;\n        }\n    }\n    return encodedMessage;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encoded_message = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                char encoded_char = c;\n                switch (c) {\n                    case 'a': encoded_char = 'c'; break;\n                    case 'e': encoded_char = 'g'; break;\n                    case 'i': encoded_char = 'k'; break;\n                    case 'o': encoded_char = 'q'; break;\n                    case 'u': encoded_char = 'w'; break;\n                    default: encoded_char = toupper(c); break;\n                }\n                encoded_message += encoded_char;\n            } else {\n                char encoded_char = c;\n                switch (c) {\n                    case 'A': encoded_char = 'C'; break;\n                    case 'E': encoded_char = 'G'; break;\n                    case 'I': encoded_char = 'K'; break;\n                    case 'O': encoded_char = 'Q'; break;\n                    case 'U': encoded_char = 'W'; break;\n                    default: encoded_char = tolower(c); break;\n                }\n                encoded_message += encoded_char;\n            }\n        } else {\n            encoded_message += c;\n        }\n    }\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encodedMessage = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                char encodedChar = toupper(c);\n                if (encodedChar == 'A') {\n                    encodedChar = 'C';\n                } else if (encodedChar == 'E') {\n                    encodedChar = 'G';\n                } else if (encodedChar == 'I') {\n                    encodedChar = 'K';\n                } else if (encodedChar == 'O') {\n                    encodedChar = 'Q';\n                } else if (encodedChar == 'U') {\n                    encodedChar = 'W';\n                }\n                encodedMessage += encodedChar;\n            } else {\n                char encodedChar = tolower(c);\n                 if (encodedChar == 'a') {\n                    encodedChar = 'c';\n                } else if (encodedChar == 'e') {\n                    encodedChar = 'g';\n                } else if (encodedChar == 'i') {\n                    encodedChar = 'k';\n                } else if (encodedChar == 'o') {\n                    encodedChar = 'q';\n                } else if (encodedChar == 'u') {\n                    encodedChar = 'w';\n                }\n                encodedMessage += toupper(encodedChar);\n            }\n        } else {\n            encodedMessage += c;\n        }\n    }\n    return encodedMessage;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encoded_message = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                char encoded_char = c;\n                switch (c) {\n                    case 'a': encoded_char = 'c'; break;\n                    case 'e': encoded_char = 'g'; break;\n                    case 'i': encoded_char = 'k'; break;\n                    case 'o': encoded_char = 'q'; break;\n                    case 'u': encoded_char = 'w'; break;\n                    default: encoded_char = toupper(c); break;\n                }\n                encoded_message += encoded_char;\n            } else {\n                char encoded_char = c;\n                switch (c) {\n                    case 'A': encoded_char = 'C'; break;\n                    case 'E': encoded_char = 'G'; break;\n                    case 'I': encoded_char = 'K'; break;\n                    case 'O': encoded_char = 'Q'; break;\n                    case 'U': encoded_char = 'W'; break;\n                    default: encoded_char = tolower(c); break;\n                }\n                encoded_message += encoded_char;\n            }\n        } else {\n            encoded_message += c;\n        }\n    }\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encoded_message = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                char encoded_char = c;\n                switch (c) {\n                    case 'a': encoded_char = 'c'; break;\n                    case 'e': encoded_char = 'g'; break;\n                    case 'i': encoded_char = 'k'; break;\n                    case 'o': encoded_char = 'q'; break;\n                    case 'u': encoded_char = 'w'; break;\n                    default: encoded_char = toupper(c); break;\n                }\n                encoded_message += encoded_char;\n            } else {\n                char encoded_char = c;\n                switch (c) {\n                    case 'A': encoded_char = 'C'; break;\n                    case 'E': encoded_char = 'G'; break;\n                    case 'I': encoded_char = 'K'; break;\n                    case 'O': encoded_char = 'Q'; break;\n                    case 'U': encoded_char = 'W'; break;\n                    default: encoded_char = tolower(c); break;\n                }\n                encoded_message += encoded_char;\n            }\n        } else {\n            encoded_message += c;\n        }\n    }\n    return encoded_message;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (auto const& [key, val] : dict) {\n        bool is_lower = true;\n        bool is_upper = true;\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n            if (!isalpha(c)) {\n                is_lower = false;\n                is_upper = false;\n            }\n        }\n        if (!is_lower) {\n            all_lower = false;\n        }\n        if (!is_upper) {\n            all_upper = false;\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (auto const& [key, val] : dict) {\n        bool is_lower = true;\n        bool is_upper = true;\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n            if (!isalpha(c)) {\n                is_lower = false;\n                is_upper = false;\n            }\n        }\n        if (!is_lower) {\n            all_lower = false;\n        }\n        if (!is_upper) {\n            all_upper = false;\n        }\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (auto const& [key, val] : dict) {\n        bool is_lower = true;\n        bool is_upper = true;\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n            if (!isalpha(c)) {\n                is_lower = false;\n                is_upper = false;\n            }\n        }\n        if (!is_lower) {\n            all_lower = false;\n        }\n        if (!is_upper) {\n            all_upper = false;\n        }\n        if (!all_lower && !all_upper)\n            return false;\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (auto const& [key, val] : dict) {\n        bool is_lower = true;\n        bool is_upper = true;\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n            if (!isalpha(c)) {\n                is_lower = false;\n                is_upper = false;\n            }\n        }\n        if (!is_lower) {\n            all_lower = false;\n        }\n        if (!is_upper) {\n            all_upper = false;\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (auto const& [key, val] : dict) {\n        bool is_lower = true;\n        bool is_upper = true;\n        for (char c : key) {\n            if (!islower(c)) {\n                is_lower = false;\n            }\n            if (!isupper(c)) {\n                is_upper = false;\n            }\n            if (!isalpha(c)) {\n                is_lower = false;\n                is_upper = false;\n            }\n        }\n        if (!is_lower) {\n            all_lower = false;\n        }\n        if (!is_upper) {\n            all_upper = false;\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if (n <= 1) {\n        return primes;\n    }\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n    \n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n  int count = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(i % 2 == 0){\n      if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n  int count = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(i % 2 == 0){\n      if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n  int count = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(i % 2 == 0){\n      if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n  int count = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(i % 2 == 0){\n      if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n  int count = 0;\n  for(int i = 0; i < s.length(); i++){\n    if(i % 2 == 0){\n      if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U'){\n        count++;\n      }\n    }\n  }\n  return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    pile.push_back(n);\n    for(int i = 1; i < n; i++){\n        if(n % 2 == 0){\n            pile.push_back(pile[i-1] + 2);\n        } else {\n            pile.push_back(pile[i-1] + 2);\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    pile.push_back(n);\n    for(int i = 1; i < n; i++){\n        if(n % 2 == 0){\n            pile.push_back(pile[i-1] + 2);\n        } else {\n            pile.push_back(pile[i-1] + 2);\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    pile.push_back(n);\n    for(int i = 1; i < n; i++){\n        if(n % 2 == 0){\n            n += 2;\n        } else {\n            n += 2;\n        }\n        pile.push_back(n);\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    pile.push_back(n);\n    for(int i = 1; i < n; i++){\n        if(n % 2 == 0){\n            pile.push_back(pile[i-1] + 2);\n        }else{\n            pile.push_back(pile[i-1] + 2);\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    pile.push_back(n);\n    for(int i = 1; i < n; i++){\n        if(n % 2 == 0){\n            pile.push_back(pile[i-1] + 2);\n        } else {\n            pile.push_back(pile[i-1] + 2);\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    double sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = static_cast<int64_t>(sum / (m - n + 1));\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    double sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = static_cast<int64_t>(sum / (m - n + 1));\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    double sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = static_cast<int64_t>(sum / (m - n + 1));\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    double sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = static_cast<int64_t>(sum / (m - n + 1));\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    double sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = static_cast<int64_t>(sum / (m - n + 1));\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    for(int i = 0; i < n; ++i){\n        if((i + 1) % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= (i + 1); ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    for(int i = 0; i < n; ++i){\n        if((i + 1) % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= (i + 1); ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    for(int i = 0; i < n; ++i){\n        if((i + 1) % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= (i + 1); ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    for(int i = 0; i < n; ++i){\n        if((i + 1) % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= (i + 1); ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    for(int i = 0; i < n; ++i){\n        if((i + 1) % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= (i + 1); ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = (int)factorial;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0;\n    int odd = 0;\n    for(int i = 1; i <= n; i++){\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        if(s == reversed_s){\n            if(i % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0;\n    int odd = 0;\n    for(int i = 1; i <= n; i++){\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        if(s == reversed_s){\n            if(i % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0;\n    int odd = 0;\n    for(int i = 1; i <= n; i++){\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n        if(s == rs){\n            if(i % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0;\n    int odd = 0;\n    for(int i = 1; i <= n; i++){\n        std::string s = std::to_string(i);\n        std::string rs = s;\n        std::reverse(rs.begin(), rs.end());\n        if(s == rs){\n            if(i % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0;\n    int odd = 0;\n    for(int i = 1; i <= n; i++){\n        std::string s = std::to_string(i);\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        if(s == reversed_s){\n            if(i % 2 == 0){\n                even++;\n            }else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        std::string s = std::to_string(num);\n        if (num < 0) {\n            sum += -(s[1] - '0');\n            for (int i = 2; i < s.length(); i++) {\n                sum += (s[i] - '0');\n            }\n        } else {\n            std::string s = std::to_string(num);\n            for (char c : s) {\n                sum += (c - '0');\n            }\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = num;\n        while (temp != 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums({}) == 0\n>>> count_nums({-1, 11, -11}) == 1\n>>> count_nums({1, 1, 2}) == 3\n*/\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int i = 0; i < n.size(); i++){\n        int num = n[i];\n        int sum = 0;\n        std::string s = std::to_string(num);\n        if (num < 0){\n            sum += (s[0] - '0') * -1;\n            for (int j = 1; j < s.length(); j++){\n                sum += s[j] - '0';\n            }\n        } else {\n            for (int j = 0; j < s.length(); j++){\n                sum += s[j] - '0';\n            }\n        }\n        if (sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = num;\n        while (temp != 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = num;\n        while (temp != 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    int n = arr.size();\n    for(int i=0; i<n; i++){\n        bool sorted = true;\n        for(int j=0; j<n-1; j++){\n            if(arr[j] > arr[j+1]){\n                sorted = false;\n                break;\n            }\n        }\n        if(sorted){\n            return true;\n        }\n        int temp = arr[n-1];\n        for(int j=n-1; j>0; j--){\n            arr[j] = arr[j-1];\n        }\n        arr[0] = temp;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    int n = arr.size();\n    for(int i=0; i<n; i++){\n        std::vector<int> temp = arr;\n        bool sorted = true;\n        for(int j=0; j<n-1; j++){\n            if(temp[j] > temp[j+1]){\n                sorted = false;\n                break;\n            }\n        }\n        if(sorted){\n            return true;\n        }\n        int last = arr[n-1];\n        for(int j=n-1; j>0; j--){\n            arr[j] = arr[j-1];\n        }\n        arr[0] = last;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    int n = arr.size();\n    for(int i=0; i<n; i++){\n        std::vector<int> temp = arr;\n        bool sorted = true;\n        for(int j=0; j<n-1; j++){\n            if(temp[j] > temp[j+1]){\n                sorted = false;\n                break;\n            }\n        }\n        if(sorted){\n            return true;\n        }\n        int last = arr[n-1];\n        for(int j=n-1; j>0; j--){\n            arr[j] = arr[j-1];\n        }\n        arr[0] = last;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    int n=arr.size();\n    for(int i=0;i<n;i++){\n        std::vector<int> temp=arr;\n        bool sorted=true;\n        for(int j=0;j<n-1;j++){\n            if(temp[j]>temp[j+1]){\n                sorted=false;\n                break;\n            }\n        }\n        if(sorted){\n            return true;\n        }\n        int last=arr[n-1];\n        for(int j=n-1;j>0;j--){\n            arr[j]=arr[j-1];\n        }\n        arr[0]=last;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    int n=arr.size();\n    for(int i=0;i<n;i++){\n        std::vector<int> temp=arr;\n        bool sorted=true;\n        for(int j=0;j<n-1;j++){\n            if(temp[j]>temp[j+1]){\n                sorted=false;\n                break;\n            }\n        }\n        if(sorted){\n            return true;\n        }\n        int last=arr[n-1];\n        for(int j=n-1;j>0;j--){\n            arr[j]=arr[j-1];\n        }\n        arr[0]=last;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    int even_count2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count1++;\n        }\n    }\n\n    int even_count2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count2++;\n        }\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count1++;\n        }\n    }\n    int even_count2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count2++;\n        }\n    }\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n  std::vector<std::string> result;\n  for (const std::string& s : lst) {\n    int count = 0;\n    for (char c : s) {\n      if ((c - '0') % 2 != 0) {\n        count++;\n      }\n    }\n    std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    result.push_back(temp);\n  }\n  return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string new_str = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    for (int64_t num : nums) {\n        current_min += num;\n        min_so_far = std::min(min_so_far, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    if (nums.empty()) {\n        return 0;\n    }\n\n    if (min_so_far == std::numeric_limits<int64_t>::max()) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    for (int64_t num : nums) {\n        current_min += num;\n        min_so_far = std::min(min_so_far, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    if (nums.empty()) return 0;\n\n    if (min_so_far == std::numeric_limits<int64_t>::max()) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n    \n    if (min_so_far > 0) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    for (int64_t num : nums) {\n        current_min += num;\n        min_so_far = std::min(min_so_far, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    if (nums.empty()) {\n        return 0;\n    }\n\n    if (min_so_far == std::numeric_limits<int64_t>::max()) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    for (int64_t num : nums) {\n        current_min += num;\n        min_so_far = std::min(min_so_far, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    if (nums.empty()) {\n        return 0;\n    }\n\n    if (min_so_far == std::numeric_limits<int64_t>::max()) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n    \n    if (min_so_far > 0) {\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_so_far = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    for (int64_t num : nums) {\n        current_min += num;\n        min_so_far = std::min(min_so_far, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n    if(nums.size() == 0){\n        return 0;\n    }\n    if(min_so_far == std::numeric_limits<int64_t>::max()){\n        min_so_far = *std::min_element(nums.begin(), nums.end());\n    }\n\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        int well_capacity = 0;\n        for(int j = 0; j < grid[i].size(); j++){\n            well_capacity += grid[i][j];\n        }\n        count += (well_capacity + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        int water = 0;\n        for(int j = 0; j < grid[i].size(); j++){\n            water += grid[i][j];\n        }\n        count += (water + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        int well_capacity = 0;\n        for(int j = 0; j < grid[i].size(); j++){\n            well_capacity += grid[i][j];\n        }\n        count += (well_capacity + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        int water = 0;\n        for(int j = 0; j < grid[i].size(); j++){\n            water += grid[i][j];\n        }\n        count += (water + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++){\n        int water = 0;\n        for(int j = 0; j < grid[i].size(); j++){\n            water += grid[i][j];\n        }\n        count += (water + capacity - 1) / capacity;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 2 == 0 && lst[i] % 2 != 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 2 == 0 && lst[i] % 2 != 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 2 == 0 && lst[i] % 2 != 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 2 == 0 && lst[i] % 2 != 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 2 == 0 && lst[i] % 2 != 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        if(arr[i] > 99){\n            continue;\n        } else {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        if(arr[i] > 0 && arr[i] < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        if(arr[i] > 0 && arr[i] < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        if(arr[i] > 99){\n            continue;\n        } else {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; i++){\n        if(arr[i] > 0 && arr[i] < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1){\n        return true;\n    }\n    std::map<int, int> counts;\n    for (int i = 0; i < lst.size(); i++){\n        counts[lst[i]]++;\n        if (counts[lst[i]] > 2){\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++){\n        if (lst[i] < lst[i-1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1){\n        return true;\n    }\n    std::map<int, int> counts;\n    for (int i = 0; i < lst.size() - 1; i++){\n        if (lst[i] > lst[i+1]){\n            return false;\n        }\n    }\n    for (int num : lst){\n        counts[num]++;\n        if (counts[num] > 2){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1){\n        return true;\n    }\n    std::map<int, int> counts;\n    for (int i = 0; i < lst.size(); i++){\n        counts[lst[i]]++;\n        if (counts[lst[i]] > 2){\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++){\n        if (lst[i] < lst[i-1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1){\n        return true;\n    }\n    std::map<int, int> counts;\n    for (int i = 0; i < lst.size() - 1; i++){\n        if (lst[i] > lst[i+1]){\n            return false;\n        }\n    }\n    for (int num : lst){\n        counts[num]++;\n        if (counts[num] > 2){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1){\n        return true;\n    }\n    std::map<int, int> counts;\n    for (int i = 0; i < lst.size(); i++){\n        counts[lst[i]]++;\n        if (counts[lst[i]] > 2){\n            return false;\n        }\n    }\n    for (int i = 1; i < lst.size(); i++){\n        if (lst[i] < lst[i-1]){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n    return product_of_signs * sum_of_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n    return product_of_signs * sum_of_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n    return product_of_signs * sum_of_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n    return product_of_signs * sum_of_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product_of_signs = 1;\n    int sum_of_magnitudes = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product_of_signs *= 1;\n        } else if (num < 0) {\n            product_of_signs *= -1;\n        } else {\n            product_of_signs *= 0;\n        }\n        sum_of_magnitudes += abs(num);\n    }\n    return product_of_signs * sum_of_magnitudes;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n        } else {\n            int dr[] = {0, 0, 1, -1};\n            int dc[] = {1, -1, 0, 0};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n\n        current_path.pop_back();\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int dr[] = {0, 0, 1, -1};\n        int dc[] = {1, -1, 0, 0};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                std::vector<int> next_path = current_path;\n                next_path.push_back(grid[new_row][new_col]);\n                solve(new_row, new_col, next_path);\n            }\n        }\n    };\n\n    std::vector<std::vector<int>> all_paths;\n    int start_row = -1, start_col = -1;\n    int min_val = n * n + 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                start_row = i;\n                start_col = j;\n            }\n        }\n    }\n\n    solve(start_row, start_col, {grid[start_row][start_col]});\n    \n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n    std::vector<int> current_path;\n\n    std::function<void(int, int)> solve = \n        [&](int row, int col) {\n        current_path.push_back(grid[row][col]);\n\n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n        } else {\n            int dr[] = {0, 0, 1, -1};\n            int dc[] = {1, -1, 0, 0};\n\n            for (int i = 0; i < 4; ++i) {\n                int new_row = row + dr[i];\n                int new_col = col + dc[i];\n\n                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                    solve(new_row, new_col);\n                }\n            }\n        }\n        current_path.pop_back();\n    };\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            solve(i, j);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        current_path.push_back(grid[row][col]);\n\n        int dr[] = {0, 0, 1, -1};\n        int dc[] = {1, -1, 0, 0};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    std::vector<int> initial_path;\n    int start_row = 0, start_col = 0;\n    int min_val = n * n + 1;\n\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            if(grid[i][j] < min_val){\n                min_val = grid[i][j];\n                start_row = i;\n                start_col = j;\n            }\n        }\n    }\n    \n    solve(start_row, start_col, initial_path);\n    \n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<int> best_path;\n\n    function<void(int, int, std::vector<int>)> solve = \n        [&](int row, int col, std::vector<int> current_path) {\n        \n        if (current_path.size() == k) {\n            if (best_path.empty() || current_path < best_path) {\n                best_path = current_path;\n            }\n            return;\n        }\n\n        int current_val = grid[row][col];\n        current_path.push_back(current_val);\n\n        int dr[] = {-1, 1, 0, 0};\n        int dc[] = {0, 0, -1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            int new_row = row + dr[i];\n            int new_col = col + dc[i];\n\n            if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                solve(new_row, new_col, current_path);\n            }\n        }\n    };\n\n    std::vector<int> initial_path;\n    std::vector<std::vector<int>> all_paths;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> current_path;\n            function<void(int, int, std::vector<int>)> solve_start = \n                [&](int row, int col, std::vector<int> current_path) {\n                \n                if (current_path.size() == k) {\n                    all_paths.push_back(current_path);\n                    return;\n                }\n\n                int current_val = grid[row][col];\n                current_path.push_back(current_val);\n\n                int dr[] = {-1, 1, 0, 0};\n                int dc[] = {0, 0, -1, 1};\n\n                for (int l = 0; l < 4; ++l) {\n                    int new_row = row + dr[l];\n                    int new_col = col + dc[l];\n\n                    if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                        solve_start(new_row, new_col, current_path);\n                    }\n                }\n            };\n            solve_start(i, j, {});\n        }\n    }\n    \n    if (all_paths.empty()) {\n        int min_val = grid[0][0];\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                min_val = std::min(min_val, grid[i][j]);\n            }\n        }\n        return std::vector<int>(k, min_val);\n    }\n\n    best_path = all_paths[0];\n    for (const auto& path : all_paths) {\n        if (path < best_path) {\n            best_path = path;\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    if (n == 0) return 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) return 0;\n    return product;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    if (n == 0) return 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    if (n == 0) return 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    if (n == 0) return 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) return 0;\n    return product;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    if (n == 0) return 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    if (!hasOdd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(float x : lst){\n        sum += pow(ceil(x), 2);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(float x : lst){\n        sum += pow(ceil(x), 2);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(float x : lst){\n        sum += (uint64_t)pow(ceil(x), 2);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float x : lst){\n        sum += pow(ceil(x), 2);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(float x : lst){\n        sum += pow(ceil(x), 2);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i-1] > arr[i]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = 1; i < arr.size(); i++){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n    \n    if (largest_negative == 0) {\n        for(int num : lst){\n            if(num < 0){\n                largest_negative = num;\n                break;\n            }\n        }\n    }\n    \n    if (smallest_positive == 0) {\n        for(int num : lst){\n            if(num > 0){\n                smallest_positive = num;\n                break;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <iostream>\n\nuint64_t factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <iostream>\n\nuint64_t factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <iostream>\n\nuint64_t factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <iostream>\n\nuint64_t factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <iostream>\n\nuint64_t factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        } else if(i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int lastDigit = abs(num) % 10;\n            int temp = abs(num);\n            while(temp >= 10){\n                temp /= 10;\n            }\n            int firstDigit = temp;\n            if(firstDigit % 2 != 0 && lastDigit % 2 != 0){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int temp = abs(num);\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            int firstDigit = temp;\n\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = 0;\n            int temp = abs(num);\n            while (temp > 0) {\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i + i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n*/\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n*/\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n*/\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n*/\nint x_or_y(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y(7, 34, 12) == 34\nfor x_or_y(15, 8, 5) == 5\n*/\nint x_or_y(int n, int x, int y){\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    if (lst.empty()) {\n        return 0;\n    }\n    for (float num : lst) {\n        if (num >= 0 && num == (int)num && ((int)num % 2 != 0)) {\n            sum += (uint64_t)num * (uint64_t)num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    if (lst.empty()) {\n        return 0;\n    }\n    for (float num : lst) {\n        if (num >= 0 && (int)num == num && (int)num % 2 != 0) {\n            sum += (uint64_t)num * (uint64_t)num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    if (lst.empty()) {\n        return 0;\n    }\n    for (float num : lst) {\n        if (num >= 0 && num == (int)num && ((int)num % 2 != 0)) {\n            sum += (uint64_t)num * (uint64_t)num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <cmath>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    if (lst.empty()) {\n        return 0;\n    }\n    for (float num : lst) {\n        if (num >= 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    if (lst.empty()) {\n        return 0;\n    }\n    for (float num : lst) {\n        if (num >= 0 && (int)num == num && (int)num % 2 != 0) {\n            sum += (uint64_t)num * (uint64_t)num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}

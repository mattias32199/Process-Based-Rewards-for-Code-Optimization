{"task_id": "SimdBench_0_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Loop through the arrays in chunks of SVE vector length\n    while (i < length) {\n        // Create a predicate 'pg' for the current chunk of int64_t elements.\n        // This predicate is true for elements that are within the current vector\n        // and also within the total 'length' of the array.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load a vector of int64_t elements from the source array 'src'.\n        // The load is predicated by 'pg', meaning only active lanes (within bounds)\n        // will load valid data; inactive lanes will have undefined values.\n        svint64_t src_vec = svld1_s64(pg, src + i);\n\n        // Load a vector of boolean mask values.\n        // The 'bool' array is treated as 'int8_t' for loading.\n        // svld1_s8 converts each non-zero byte to true and each zero byte to false,\n        // creating a scalable predicate 'mask_pg'.\n        // The predicate 'pg' also guards this load, ensuring that only mask values\n        // corresponding to active int64_t lanes are considered.\n        svbool_t mask_pg = svld1_s8(pg, (const int8_t*)(mask + i));\n\n        // Conditionally store elements from 'src_vec' to the destination array 'dst'.\n        // The store is guarded by 'mask_pg'. Only lanes where 'mask_pg' is true\n        // will write their corresponding 'src_vec' element to 'dst'.\n        // If a lane in 'pg' was false (due to being out of bounds), the corresponding\n        // lane in 'mask_pg' will also be false, preventing an out-of-bounds write.\n        svst1_s64(mask_pg, dst + i, src_vec);\n\n        // Increment the loop counter by the number of int64_t elements\n        // processed in this iteration (the full SVE vector length for int64_t).\n        // The 'pg' predicate handles the tail end of the array where 'i + svcntd()'\n        // might exceed 'length'.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    // Initialize the loop control predicate for 64-bit elements.\n    // This predicate determines which lanes are active based on the remaining length.\n    svbool_t pg_64 = svwhilelt_b64(i, length);\n\n    // Loop while there are any active lanes (i.e., elements remaining to process).\n    while (svptest_any(svptrue_b64(), pg_64)) {\n        // 1. Load source data (int64_t) using the loop control predicate.\n        //    Elements corresponding to inactive lanes in pg_64 will be zeroed out in src_vec.\n        svint64_t src_vec = svld1_s64(pg_64, &src[i]);\n\n        // 2. Load current destination data (int64_t) using the loop control predicate.\n        //    This is necessary because svsel requires a value for both true and false conditions.\n        //    If the mask is false, we want to keep the existing destination value.\n        //    Elements corresponding to inactive lanes in pg_64 will be zeroed out in dst_vec_current.\n        svint64_t dst_vec_current = svld1_s64(pg_64, &dst[i]);\n\n        // 3. Load mask data (bool, which is typically 1 byte) into an 8-bit vector.\n        //    The pg_64 predicate (for 64-bit elements) ensures that only the\n        //    first `svcntd()` bytes are loaded into the corresponding 8-bit lanes.\n        //    The remaining 8-bit lanes in mask_bytes will be zeroed by the predicate.\n        svuint8_t mask_bytes = svld1_u8(pg_64, &mask[i]);\n\n        // 4. Generate an 8-bit predicate from the loaded mask bytes.\n        //    This predicate will have a bit set for each 8-bit lane where the mask byte is non-zero.\n        //    The pg_64 predicate ensures that only relevant mask bytes (those corresponding to active 64-bit lanes)\n        //    are considered for comparison.\n        svbool_t mask_predicate_8bit = svcmpne(pg_64, mask_bytes, svdup_n_u8(0));\n\n        // 5. Reinterpret the 8-bit predicate as a 64-bit predicate.\n        //    The `svreinterpret_bX_bY` intrinsic converts a predicate from one element size to another.\n        //    It reinterprets the predicate bits such that the first `VL/64` bits of the result predicate\n        //    correspond to the first `VL/8` bits of the input predicate.\n        //    Since `svcntd()` (number of 64-bit elements) is `VL/64` and `svcntb()` (number of 8-bit elements) is `VL/8`,\n        //    this effectively takes the first `svcntd()` bits of the 8-bit predicate, which correctly\n        //    correspond to the mask values for the current 64-bit elements.\n        svbool_t mask_predicate_64bit = svreinterpret_b8_b64(mask_predicate_8bit);\n\n        // 6. Select elements: if `mask_predicate_64bit` is true for a lane, pick the value from `src_vec`;\n        //    otherwise, pick the existing value from `dst_vec_current` for that lane.\n        svint64_t result_vec = svsel(mask_predicate_64bit, src_vec, dst_vec_current);\n\n        // 7. Store the result vector to the destination array.\n        //    The `pg_64` predicate ensures that only elements within the bounds of `length` are written,\n        //    and inactive lanes are left untouched in memory.\n        svst1_s64(pg_64, &dst[i], result_vec);\n\n        // 8. Advance the loop counter by the number of 64-bit elements processed in this iteration.\n        i += svcntd();\n        \n        // 9. Update the loop control predicate for the next iteration.\n        pg_64 = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    // Get the vector length for 64-bit elements (double-word)\n    // This defines the granularity of the loop and the predicate.\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    // Loop while there are active elements in the predicate 'pg'\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load a vector of 64-bit integers from the source array.\n        // The 'pg' predicate ensures that only elements within the current valid range are loaded.\n        svint64_t src_vec = svld1_s64(pg, src + i);\n\n        // Load a vector of 64-bit integers from the destination array.\n        // This is necessary because for elements where the mask is false,\n        // the existing value in 'dst' should be preserved.\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n\n        // Generate a predicate from the boolean mask array.\n        // The cast `(const svbool_t*)` is a common pattern in SVE for loading predicates\n        // from a `bool` array, assuming `bool` is 1 byte and can be interpreted as predicate bits.\n        // The 'pg' predicate ensures that only mask values corresponding to active lanes\n        // (i.e., within the current loop bounds) are considered for the conditional move.\n        svbool_t p_cond = svld1_vnum_b64(pg, (const svbool_t*)(mask + i));\n\n        // Select elements based on the generated predicate 'p_cond'.\n        // If 'p_cond' is true for a lane, the element from 'src_vec' is chosen.\n        // Otherwise (if 'p_cond' is false), the element from 'dst_vec' is chosen,\n        // effectively preserving the original destination value.\n        svint64_t result_vec = svsel(p_cond, src_vec, dst_vec);\n\n        // Store the resulting vector back to the destination array.\n        // The 'pg' predicate ensures that only elements within the current valid range are written.\n        svst1_s64(pg, dst + i, result_vec);\n\n        // Advance the index 'i' by the number of 64-bit elements processed in this iteration.\n        i += svcntd();\n\n        // Update the predicate 'pg' for the next iteration, considering the remaining length.\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": ""}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Get the predicate for the current chunk of int64_t elements, handling the tail\n        svbool_t pg_64 = svwhilelt_b64(i, length);\n\n        // Get the predicate for the current chunk of bool (uint8_t) mask elements, handling the tail\n        svbool_t pg_8 = svwhilelt_b8(i, length);\n\n        // Load the mask values as uint8_t vectors\n        svuint8_t mask_vec_u8 = svld1_u8(pg_8, (const uint8_t *)&mask[i]);\n        \n        // Create a predicate from the mask_vec_u8: true where mask value is non-zero\n        // The svbool_t type is a scalable predicate and can be used for int64_t operations.\n        svbool_t copy_predicate = svcmpne_n_u8(pg_8, mask_vec_u8, 0);\n\n        // Combine the loop predicate (pg_64) with the copy predicate (copy_predicate)\n        // This final predicate determines which lanes are active AND where the mask is true.\n        svbool_t final_predicate = svand_b(pg_64, copy_predicate);\n\n        // Load source data using the final predicate\n        // Elements where final_predicate is false will be undefined in src_vec, which is fine\n        // as they won't be stored.\n        svint64_t src_vec = svld1_s64(final_predicate, &src[i]);\n\n        // Conditionally store source data to destination using the final predicate\n        // This will only write to dst where final_predicate is true.\n        svst1_s64(final_predicate, &dst[i], src_vec);\n\n        // Advance the loop counter by the number of 64-bit elements in a vector\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register for 32-bit elements\n    \n    // Duplicate scalar values into SVE vectors once.\n    // These vectors will contain the same scalar value across all lanes.\n    svint32_t vec_scale = svdup_s32(scale);\n    svint32_t vec_seven = svdup_s32(7);\n\n    while (i < length) {\n        // Generate a predicate for the current vector chunk.\n        // This predicate will be true for elements within the bounds [i, length).\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit integers from src.\n        // Inactive lanes (where pg is false) are zeroed by default for svld1.\n        svint32_t vec_src = svld1_s32(pg, &src[i]);\n\n        // Calculate (element * scale).\n        // Only active lanes are computed; inactive lanes are zeroed.\n        svint32_t vec_prod_scale = svmul_s32(pg, vec_src, vec_scale);\n\n        // Calculate tmp1 = (element * scale) right-shifted by 3 bits.\n        // Using svasr_s32 for arithmetic right shift, which is appropriate for signed integers.\n        svint32_t vec_tmp1 = svasr_s32(pg, vec_prod_scale, 3);\n\n        // Calculate tmp2 = (element * scale) left-shifted by 3 bits.\n        svint32_t vec_tmp2 = svlsl_s32(pg, vec_prod_scale, 3);\n\n        // Compute (tmp1 * tmp2).\n        svint32_t vec_tmp1_tmp2_prod = svmul_s32(pg, vec_tmp1, vec_tmp2);\n\n        // Compute (element * scale + tmp1 * tmp2).\n        svint32_t vec_numerator = svadd_s32(pg, vec_prod_scale, vec_tmp1_tmp2_prod);\n\n        // Compute final result: (numerator) / 7.\n        svint32_t vec_dst_val = svdiv_s32(pg, vec_numerator, vec_seven);\n\n        // Store the results into dst.\n        // Only active lanes are stored.\n        svst1_s32(pg, &dst[i], vec_dst_val);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements in an SVE vector (VL/4).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Get the predicate for the current vector length\n        // This predicate ensures we don't process elements beyond 'length'\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit signed integers from src\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Calculate (element * scale)\n        // svmul_n_s32 performs vector-scalar multiplication\n        svint32_t e_times_scale_vec = svmul_n_s32(src_vec, scale);\n\n        // Calculate tmp1 as (element * scale) right-shifted by 3 bits\n        // svshr_n_s32 performs vector-scalar right shift\n        svint32_t tmp1_vec = svshr_n_s32(e_times_scale_vec, 3);\n\n        // Calculate tmp2 as (element * scale) left-shifted by 3 bits\n        // svshl_n_s32 performs vector-scalar left shift\n        svint32_t tmp2_vec = svshl_n_s32(e_times_scale_vec, 3);\n\n        // Calculate tmp1 * tmp2\n        // svmul_s32 performs vector-vector multiplication\n        svint32_t tmp1_times_tmp2_vec = svmul_s32(tmp1_vec, tmp2_vec);\n\n        // Calculate (element * scale + tmp1 * tmp2)\n        // svadd_s32 performs vector-vector addition\n        svint32_t numerator_vec = svadd_s32(e_times_scale_vec, tmp1_times_tmp2_vec);\n\n        // Compute the final result as: (numerator) divided by 7\n        // svdiv_n_s32 performs vector-scalar division\n        svint32_t result_vec = svdiv_n_s32(numerator_vec, 7);\n\n        // Store the result vector into dst\n        svst1_s32(pg, &dst[i], result_vec);\n\n        // Increment the loop counter by the number of 32-bit elements processed\n        // svcntw() returns the number of 32-bit elements in a vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Duplicate scalar constants into SVE vectors once outside the loop\n    svint32_t scale_vec = svdup_s32(scale);\n    svint32_t three_vec = svdup_s32(3);\n    svint32_t seven_vec = svdup_s32(7);\n\n    while (i < length) {\n        // Generate a predicate for the current chunk of 32-bit integers.\n        // This predicate ensures that operations only apply to valid elements,\n        // especially for the tail end of the array if length is not a multiple of VL.\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit integers from src using the predicate\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Calculate (element * scale) for all active lanes\n        // The _x suffix ensures that operations are performed only on active lanes\n        svint32_t e_scale_vec = svmul_s32_x(pg, src_vec, scale_vec);\n\n        // 1. Calculate tmp1 as (element * scale) right-shifted by 3 bits\n        svint32_t tmp1_vec = svasr_s32_x(pg, e_scale_vec, three_vec);\n\n        // 2. Calculate tmp2 as (element * scale) left-shifted by 3 bits\n        svint32_t tmp2_vec = svlsl_s32_x(pg, e_scale_vec, three_vec);\n\n        // 3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7\n        svint32_t tmp1_tmp2_vec = svmul_s32_x(pg, tmp1_vec, tmp2_vec);\n        svint32_t numerator_vec = svadd_s32_x(pg, e_scale_vec, tmp1_tmp2_vec);\n        svint32_t result_vec = svdiv_s32_x(pg, numerator_vec, seven_vec);\n\n        // 4. Store the result in dst using the predicate\n        svst1_s32(pg, &dst[i], result_vec);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements that fit in an SVE vector (VL/32).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    while (i < length) {\n        // Get the predicate for the current chunk, processing up to svcntw() elements\n        pg = svwhilelt_b32(i, length);\n\n        // Load elements from src into an SVE vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n\n        // Calculate (element * scale)\n        // svmul_n_s32 multiplies each element in src_vec by the scalar 'scale'\n        svint32_t e_times_scale_vec = svmul_n_s32(src_vec, scale);\n\n        // Calculate tmp1 = (e * scale) >> 3\n        // svshr_n_s32 performs a right shift by 3 bits on each element\n        svint32_t tmp1_vec = svshr_n_s32(e_times_scale_vec, 3);\n\n        // Calculate tmp2 = (e * scale) << 3\n        // svshl_n_s32 performs a left shift by 3 bits on each element\n        svint32_t tmp2_vec = svshl_n_s32(e_times_scale_vec, 3);\n\n        // Calculate tmp1 * tmp2\n        // svmul_s32 performs element-wise multiplication of two vectors\n        svint32_t tmp1_times_tmp2_vec = svmul_s32(tmp1_vec, tmp2_vec);\n\n        // Calculate (e * scale + tmp1 * tmp2)\n        // svadd_s32 performs element-wise addition of two vectors\n        svint32_t numerator_vec = svadd_s32(e_times_scale_vec, tmp1_times_tmp2_vec);\n\n        // Calculate the final result: numerator / 7\n        // svdiv_n_s32 performs element-wise division by the scalar 7\n        svint32_t result_vec = svdiv_n_s32(numerator_vec, 7);\n\n        // Store the results into dst\n        svst1_s32(pg, dst + i, result_vec);\n\n        // Increment the loop counter by the number of elements processed in this chunk\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register for active lanes\n\n    // Duplicate the scalar 'scale' and '7' into SVE vectors once\n    svint32_t sv_scale = svdup_s32(scale);\n    svint32_t sv_seven = svdup_s32(7);\n\n    // Loop through the arrays in chunks determined by the SVE vector length (VL)\n    while (i < length) {\n        // 1. Generate a predicate for the current vector chunk.\n        // This predicate will be true for elements within the array bounds.\n        pg = svwhilelt_b32(i, length);\n\n        // 2. Load a vector of 32-bit integers from 'src' using the predicate.\n        // Only active lanes (where pg is true) will load data.\n        svint32_t sv_src_elements = svld1_s32(pg, src + i);\n\n        // 3. Perform the calculations using SVE intrinsics.\n        // Calculate (element * scale)\n        svint32_t sv_e_times_scale = svmul_s32_x(pg, sv_src_elements, sv_scale);\n\n        // Calculate tmp1 = (element * scale) >> 3; (Arithmetic right shift for signed integers)\n        svint32_t sv_tmp1 = svasr_s32_x(pg, sv_e_times_scale, 3);\n\n        // Calculate tmp2 = (element * scale) << 3; (Logical left shift)\n        svint32_t sv_tmp2 = svlsl_s32_x(pg, sv_e_times_scale, 3);\n\n        // Calculate tmp1 * tmp2\n        svint32_t sv_tmp1_times_tmp2 = svmul_s32_x(pg, sv_tmp1, sv_tmp2);\n\n        // Calculate (element * scale + tmp1 * tmp2)\n        svint32_t sv_numerator = svadd_s32_x(pg, sv_e_times_scale, sv_tmp1_times_tmp2);\n\n        // Compute the final result: numerator / 7\n        svint32_t sv_result = svdiv_s32_x(pg, sv_numerator, sv_seven);\n\n        // 4. Store the calculated results into 'dst' using the predicate.\n        // Only active lanes will write data.\n        svst1_s32(pg, dst + i, sv_result);\n\n        // Increment the loop counter by the number of 32-bit elements in an SVE vector.\n        // svcntw() returns the count of 32-bit elements (VL / 4).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the number of double elements that fit into an SVE vector.\n    // This value (VL) is determined at runtime by the SVE hardware.\n    size_t svl = svcntd();\n\n    // Loop through the rows, processing 'svl' elements at a time.\n    // 'r' acts as the starting row index for each vector operation.\n    for (size_t r = 0; r < rows; r += svl) {\n        // Create a predicate for the current vector operation.\n        // svwhilelt_b64(r, rows) generates a predicate that is true for elements\n        // where the current index (starting from 'r') is less than 'rows'.\n        // This correctly handles the tail end of the loop where 'rows' is not\n        // a multiple of 'svl', ensuring operations only apply to valid elements.\n        svbool_t pg = svwhilelt_b64(r, rows);\n\n        // Generate a vector of row indices [r, r+1, ..., r+svl-1].\n        // svindex_s64(start, step) creates a vector of signed 64-bit integers\n        // starting from 'start' and incrementing by 'step' for each element.\n        svint64_t r_indices = svindex_s64(r, 1);\n\n        // Duplicate 'cols' and 'stride' into SVE vectors.\n        // svdup_s64(value) creates a vector where all elements are 'value'.\n        // This is necessary for element-wise vector arithmetic.\n        svint64_t cols_vec = svdup_s64(cols);\n        svint64_t stride_vec = svdup_s64(stride);\n\n        // Calculate the (r * cols) part of the source index for each element in the vector.\n        // svmul_s64 performs element-wise multiplication of two svint64_t vectors.\n        svint64_t col_multipliers = svmul_s64(r_indices, cols_vec);\n\n        // Calculate the final source indices (r * cols + stride) for each element.\n        // svadd_s64 performs element-wise addition of two svint64_t vectors.\n        // This 'src_indices' vector contains the 1D array index in 'src' for each element.\n        svint64_t src_indices = svadd_s64(col_multipliers, stride_vec);\n\n        // Perform a gather load from the 'src' array.\n        // svld1_gather_s64index_f64 loads double-precision floating-point values\n        // from 'src' using the calculated 'src_indices' vector.\n        // The 'pg' predicate ensures that only elements corresponding to true\n        // predicate lanes are loaded; other lanes will be zeroed or remain unchanged\n        // depending on the context (though for loads, they are typically masked).\n        svfloat64_t loaded_data = svld1_gather_s64index_f64(pg, src, src_indices);\n\n        // Perform a contiguous store to the 'dst' array.\n        // svst1_f64 stores the 'loaded_data' vector contiguously starting at &dst[r].\n        // The 'pg' predicate ensures that only elements corresponding to true\n        // predicate lanes are stored.\n        svst1_f64(pg, &dst[r], loaded_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    // Get the number of 64-bit elements (doubles) that fit in an SVE vector.\n    size_t svl = svcntd();\n\n    // Loop through the rows, processing 'svl' elements at a time.\n    // The loop continues as long as 'i' is less than 'rows'.\n    for (; i < rows; ) {\n        // Create a predicate vector 'pg'. This predicate is active for lanes\n        // where the current row index (i + lane_idx) is less than 'rows'.\n        // This handles the tail end of the loop where fewer than 'svl' elements remain.\n        svbool_t pg = svwhilelt_b64(i, rows);\n\n        // Generate a vector of increasing integers: {0, 1, 2, ..., svl-1}.\n        // These represent the relative index within the current SVE vector.\n        svint64_t v_lane_indices = svindex_s64(0, 1);\n\n        // Calculate the absolute row index for each lane in the current vector.\n        // For example, if i=0, v_current_row_indices = {0, 1, 2, ...}\n        // If i=svl, v_current_row_indices = {svl, svl+1, svl+2, ...}\n        svint64_t v_current_row_indices = svadd_s64(svdup_s64(i), v_lane_indices);\n\n        // Calculate the base element index within the 'src' array for each row.\n        // This is (current_row_index * cols).\n        svint64_t v_src_base_indices = svmul_s64(v_current_row_indices, svdup_s64(cols));\n\n        // Add the 'stride' to get the final element index in 'src' for each lane.\n        // This is (current_row_index * cols + stride).\n        svint64_t v_src_element_indices = svadd_s64(v_src_base_indices, svdup_s64(stride));\n\n        // Convert the element indices to byte offsets.\n        // Since 'src' is an array of 'double', each element occupies sizeof(double) bytes (typically 8).\n        // The gather load intrinsic expects byte offsets.\n        svint64_t v_src_byte_offsets = svmul_s64(v_src_element_indices, svdup_s64(sizeof(double)));\n\n        // Perform the gather load operation from 'src'.\n        // 'src' is the base pointer, and 'v_src_byte_offsets' provides the byte offsets\n        // from 'src' for each element to be loaded.\n        // Only active lanes (determined by 'pg') will load data.\n        svfloat64_t loaded_data = svld1_gather_s64offset_f64(pg, src, v_src_byte_offsets);\n\n        // Perform the contiguous store operation to 'dst'.\n        // The data is stored starting at 'dst + i'.\n        // Only active lanes (determined by 'pg') will store data.\n        svst1_f64(pg, dst + i, loaded_data);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        i += svl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    // Get the vector length for double (64-bit) elements\n    svbool_t pg; // Predicate register\n    size_t vl = svcntd(); // Number of double elements per vector\n\n    // Loop through rows in chunks of VL\n    for (r = 0; r < rows; r += vl) {\n        // Generate predicate for the current chunk\n        // This predicate will be true for elements within the bounds of 'rows'\n        pg = svwhilelt_b64(r, rows);\n\n        // 1. Calculate source indices for the current vector\n        //    Generate a vector of row offsets: 0, 1, 2, ..., vl-1\n        svint64_t row_offsets_in_vec = svindex_s64(0, 1);\n        \n        //    Add the current base row 'r' to get the actual row numbers for this vector\n        //    (r, r+1, r+2, ...)\n        svint64_t current_rows_vec = svadd_n_s64(row_offsets_in_vec, r);\n\n        //    Multiply by 'cols' to get the base offset for each row\n        //    (r*cols, (r+1)*cols, ...)\n        svint64_t src_base_offsets_vec = svmul_n_s64(current_rows_vec, cols);\n\n        //    Add 'stride' to get the final element offset for each load\n        //    (r*cols + stride, (r+1)*cols + stride, ...)\n        svint64_t src_element_offsets_vec = svadd_n_s64(src_base_offsets_vec, stride);\n\n        // 2. Perform gather load from src using the calculated element offsets\n        //    svld1_gather_s64offset scales the offsets by sizeof(double) automatically.\n        svfloat64_t loaded_data = svld1_gather_s64offset(pg, src, src_element_offsets_vec);\n\n        // 3. Store to dst\n        //    The destination address is &dst[r] for the current chunk, which is a contiguous store.\n        svst1_f64(pg, &dst[r], loaded_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Loop through the rows in chunks determined by the SVE vector length for double (svcntd())\n    for (size_t r = 0; r < rows; r += svcntd()) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements within the [r, rows) range.\n        svbool_t pg = svwhilelt_b64(r, rows);\n\n        // Generate a vector of row indices for the current chunk: [r, r+1, r+2, ..., r+VL-1].\n        // These are the 'r' values for which we need to compute src addresses.\n        svint64_t row_indices = svindex_s64(r, 1);\n\n        // Duplicate 'cols' and 'stride' into SVE vectors.\n        // This allows element-wise multiplication and addition with the row_indices vector.\n        svint64_t sv_cols = svdup_s64(cols);\n        svint64_t sv_stride = svdup_s64(stride);\n\n        // Calculate the source array indices for the gather operation.\n        // The formula is: (row_index * cols + stride) for each element in the vector.\n        // These operations are unpredicated, calculating indices for all lanes.\n        svint64_t src_idx_part1 = svmul_s64(row_indices, sv_cols);\n        svint64_t src_gather_indices = svadd_s64(src_idx_part1, sv_stride);\n\n        // Load data from the 'src' array using a gather operation.\n        // 'src' is the base pointer. 'src_gather_indices' provides the element indices.\n        // The actual address accessed for each lane is src + index * sizeof(double).\n        // The predicate 'pg' ensures that only active lanes perform the load.\n        svfloat64_t loaded_data = svld1_gather_index_f64(pg, src, src_gather_indices);\n\n        // Store the loaded data contiguously into the 'dst' array.\n        // The base pointer for 'dst' for this chunk is 'dst + r'.\n        // The predicate 'pg' ensures that only active lanes perform the store.\n        svst1_f64(pg, dst + r, loaded_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array,\nStore it in position r of dst array\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    // Get the number of 64-bit floating-point elements (doubles) that fit in an SVE vector.\n    // This value (VL) is determined at runtime by the SVE implementation.\n    size_t vl = svcntd();\n\n    // Loop through the rows in chunks of VL (Vector Length).\n    // 'i' represents the starting row index for the current SVE vector operation.\n    for (i = 0; i < rows; i += vl) {\n        // Create a predicate for the current vector operation.\n        // svwhilelt_b64(i, rows) generates a predicate where lanes are active\n        // as long as their logical index (i + lane_idx) is less than 'rows'.\n        // This correctly handles the last (partial) chunk of data.\n        svbool_t pg = svwhilelt_b64(i, rows);\n\n        // 1. Generate the element offsets for the gather load from 'src'.\n        // For each row 'r' in the current vector (r = i, i+1, ..., i+VL-1),\n        // we need to load from src[r * cols + stride].\n\n        // First, generate a vector of row indices: {i, i+1, i+2, ..., i+VL-1}.\n        // svindex_s64(start, step) creates a vector of signed 64-bit integers.\n        svint64_t row_indices_vec = svindex_s64((int64_t)i, 1);\n\n        // Multiply each row index by 'cols' to get the base column offset for each row.\n        // Result: {i*cols, (i+1)*cols, ..., (i+VL-1)*cols}\n        // svmul_s64_x performs a predicated multiplication.\n        svint64_t col_multiplied_indices = svmul_s64_x(pg, row_indices_vec, (int64_t)cols);\n\n        // Add 'stride' to each element to get the final element index in 'src'.\n        // Result: {i*cols+stride, (i+1)*cols+stride, ..., (i+VL-1)*cols+stride}\n        // svadd_s64_x performs a predicated addition.\n        svint64_t final_src_element_offsets = svadd_s64_x(pg, col_multiplied_indices, (int64_t)stride);\n\n        // Convert element offsets to byte offsets.\n        // SVE gather load intrinsics (like svld1_gather_s64offset_f64)\n        // expect byte offsets relative to the base pointer.\n        // For double (64-bit float), sizeof(double) is 8 bytes.\n        svint64_t byte_offsets = svmul_s64_x(pg, final_src_element_offsets, (int64_t)sizeof(double));\n\n        // Perform the gather load from 'src'.\n        // 'src' is the base pointer. 'byte_offsets' contains the byte offsets for each lane.\n        svfloat64_t loaded_data = svld1_gather_s64offset_f64(pg, src, byte_offsets);\n\n        // 2. Perform the contiguous store to 'dst'.\n        // The destination elements are dst[i], dst[i+1], ..., dst[i+VL-1].\n        // This is a contiguous store, so we can use svst1_f64.\n        // '&dst[i]' is the base address for the current vector store.\n        svst1_f64(pg, &dst[i], loaded_data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    size_t sv_len = svcntw(); // Number of 32-bit elements in a vector\n\n    // --- Gather Operation: dst[i] = src[indices[i]] ---\n    // Copies values from the source array to the destination array using the indices as lookups.\n    i = 0;\n    while (i < length) {\n        // Create a predicate for the current vector chunk\n        pg = svwhilelt_b32(i, length);\n        \n        // Load a vector of 32-bit integer indices from the 'indices' array\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n        \n        // Gather 32-bit float values from 'src' using 'current_indices' as element offsets\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, current_indices);\n        \n        // Store the gathered values into the 'dst' array at the current sequential position\n        svst1_f32(pg, &dst[i], gathered_values);\n        \n        // Advance the loop counter by the number of elements processed in this vector\n        i += sv_len;\n    }\n\n    // --- Scatter Operation: dst[indices[i]] = src[i] ---\n    // Copies values from the source array to the destination array using the indices as write locations.\n    i = 0;\n    while (i < length) {\n        // Create a predicate for the current vector chunk\n        pg = svwhilelt_b32(i, length);\n        \n        // Load a vector of 32-bit float values from the 'src' array\n        svfloat32_t current_src_values = svld1_f32(pg, &src[i]);\n        \n        // Load a vector of 32-bit integer indices from the 'indices' array\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n        \n        // Scatter 'current_src_values' into the 'dst' array using 'current_indices' as element offsets\n        svst1_scatter_s32index_f32(pg, dst, current_indices, current_src_values);\n        \n        // Advance the loop counter by the number of elements processed in this vector\n        i += sv_len;\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    svbool_t pg;\n    size_t sv_len;\n\n    // Phase 1: Gather operation (dst[i] = src[indices[i]])\n    // Copies values from the source array to the destination array using the indices as lookups.\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        sv_len = svcntw();\n\n        // Load a vector of indices from the 'indices' array\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n\n        // Gather float values from the 'src' array using 'current_indices' as offsets\n        // The base address for the gather operation is 'src'.\n        svfloat32_t gathered_values = svld1_gather_s32offset_f32(pg, src, current_indices);\n\n        // Store the gathered values into the 'dst' array\n        svst1_f32(pg, &dst[i], gathered_values);\n\n        i += sv_len;\n    }\n\n    // Phase 2: Scatter operation (dst[indices[i]] = src[i])\n    // Copies values from the source array to the destination array using the indices as write locations.\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        sv_len = svcntw();\n\n        // Load a vector of indices from the 'indices' array\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n\n        // Load a vector of source values from the 'src' array\n        svfloat32_t current_src_values = svld1_f32(pg, &src[i]);\n\n        // Scatter 'current_src_values' into the 'dst' array using 'current_indices' as offsets\n        // The base address for the scatter operation is 'dst'.\n        svst1_scatter_s32offset_f32(pg, dst, current_indices, current_src_values);\n\n        i += sv_len;\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    svbool_t pg;\n\n    // Phase 1: Gather operation (dst[i] = src[indices[i]])\n    // Copies values from the source array to the destination array using the indices as lookups.\n    i = 0;\n    while (i < length) {\n        // Create a predicate for the current vector chunk, handling the tail.\n        pg = svwhilelt_b32(i, length);\n        \n        // Load a vector of 32-bit integer indices from the 'indices' array.\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n        \n        // Gather float values from 'src' using the loaded indices.\n        // svld1_gather_s32index_f32 automatically scales the indices by sizeof(float).\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, current_indices);\n        \n        // Store the gathered float values into the 'dst' array.\n        svst1_f32(pg, &dst[i], gathered_values);\n        \n        // Advance the loop counter by the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n\n    // Phase 2: Scatter operation (dst[indices[i]] = src[i])\n    // Copies values from the source array to the destination array using the indices as write locations.\n    i = 0;\n    while (i < length) {\n        // Create a predicate for the current vector chunk, handling the tail.\n        pg = svwhilelt_b32(i, length);\n        \n        // Load a vector of float values from the 'src' array.\n        svfloat32_t current_src_values = svld1_f32(pg, &src[i]);\n        \n        // Load a vector of 32-bit integer indices from the 'indices' array.\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n        \n        // Scatter the float values from 'current_src_values' into the 'dst' array\n        // using 'current_indices' as write locations.\n        // svst1_scatter_s32index_f32 automatically scales the indices by sizeof(float).\n        svst1_scatter_s32index_f32(pg, dst, current_indices, current_src_values);\n        \n        // Advance the loop counter by the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // Required for size_t\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    // First operation: Gather (dst[i] = src[indices[i]])\n    // This loop iterates linearly through the 'dst' array and fills it by gathering\n    // elements from 'src' at positions specified by 'indices'.\n    for (i = 0; i < length; i += svcntw()) {\n        // Create a predicate for the current vector length, handling tail elements.\n        // svwhilelt_b32 generates a predicate for 32-bit elements.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit integer indices from the 'indices' array.\n        // These indices determine which elements from 'src' will be gathered.\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n\n        // Perform the gather operation:\n        // Load 32-bit floating-point values from 'src' using 'current_indices'\n        // as element-wise offsets/indices.\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, current_indices);\n\n        // Store the gathered floating-point values into the 'dst' array\n        // at the current linear position 'i'.\n        svst1_f32(pg, &dst[i], gathered_values);\n    }\n\n    // Second operation: Scatter (dst[indices[i]] = src[i])\n    // This loop iterates linearly through the 'src' array and scatters its values\n    // into 'dst' at locations specified by 'indices'.\n    for (i = 0; i < length; i += svcntw()) {\n        // Create a predicate for the current vector length, handling tail elements.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit floating-point values from the 'src' array.\n        // These are the values that will be scattered into 'dst'.\n        svfloat32_t values_to_scatter = svld1_f32(pg, &src[i]);\n\n        // Load a vector of 32-bit integer indices from the 'indices' array.\n        // These indices determine where in 'dst' the 'values_to_scatter' will be placed.\n        svint32_t current_indices = svld1_s32(pg, &indices[i]);\n\n        // Perform the scatter operation:\n        // Store 'values_to_scatter' into the 'dst' array at locations specified by 'current_indices'.\n        svst1_scatter_s32index_f32(pg, dst, current_indices, values_to_scatter);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    const int float_size_bytes = sizeof(float);\n\n    // Phase 1: Gather operation (dst[i] = src[indices[i]])\n    // Copies values from the source array to the destination array using the indices\n    // as lookups.\n    i = 0; // Initialize loop index\n    while (i < length) {\n        // Create a predicate for the current vector chunk, handling the tail elements.\n        // `svwhilelt_b32` generates a predicate where elements are active as long as\n        // the current index `i` is less than `length`.\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit integer indices from the 'indices' array starting at `&indices[i]`.\n        svint32_t current_indices_vec = svld1_s32(pg, &indices[i]);\n\n        // Calculate byte offsets for the gather operation.\n        // Each index needs to be multiplied by the size of a float (4 bytes) to get the byte offset.\n        svint32_t byte_offsets_vec = svmul_s32(current_indices_vec, svdup_s32(float_size_bytes));\n\n        // Perform the gather operation:\n        // Load float values from the 'src' array using 'src' as the base pointer\n        // and 'byte_offsets_vec' as the vector of byte offsets.\n        svfloat32_t gathered_values_vec = svld1_gather_s32offset_f32(pg, src, byte_offsets_vec);\n\n        // Store the gathered float values into the 'dst' array starting at `&dst[i]`.\n        svst1_f32(pg, &dst[i], gathered_values_vec);\n\n        // Increment the loop index by the number of 32-bit elements in an SVE vector.\n        // `svcntw()` returns the current vector length in 32-bit elements.\n        i += svcntw();\n    }\n\n    // Phase 2: Scatter operation (dst[indices[i]] = src[i])\n    // Copies values from the source array to the destination array using the indices\n    // as write locations.\n    i = 0; // Reset loop index for the second phase\n    while (i < length) {\n        // Create a predicate for the current vector chunk, handling the tail elements.\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit float values from the 'src' array starting at `&src[i]`.\n        svfloat32_t current_src_values_vec = svld1_f32(pg, &src[i]);\n\n        // Load a vector of 32-bit integer indices from the 'indices' array starting at `&indices[i]`.\n        svint32_t current_indices_vec = svld1_s32(pg, &indices[i]);\n\n        // Calculate byte offsets for the scatter operation.\n        // Each index needs to be multiplied by the size of a float (4 bytes) to get the byte offset.\n        svint32_t byte_offsets_vec = svmul_s32(current_indices_vec, svdup_s32(float_size_bytes));\n\n        // Perform the scatter operation:\n        // Store 'current_src_values_vec' into the 'dst' array using 'dst' as the base pointer\n        // and 'byte_offsets_vec' as the vector of byte offsets for the write locations.\n        svst1_scatter_s32offset_f32(pg, dst, byte_offsets_vec, current_src_values_vec);\n\n        // Increment the loop index by the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <algorithm> // Required for std::min\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If the range is empty or contains a single element, no reversal is needed.\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left_ptr = start;\n    uint64_t right_ptr = end;\n\n    while (left_ptr < right_ptr) {\n        // Get the number of 16-bit elements that fit in a single SVE vector.\n        size_t k = svcntw();\n\n        // Calculate the total number of elements remaining in the current range segment.\n        uint64_t remaining_len = right_ptr - left_ptr + 1;\n\n        // Determine how many elements can be processed from each end in this iteration.\n        // This is limited by the vector length (k) and half of the remaining length.\n        uint64_t num_elements_to_process_per_side = std::min((uint64_t)k, remaining_len / 2);\n\n        // If no elements can be processed (e.g., only one element left in the middle for odd length ranges),\n        // or if the remaining length is less than 2, break the loop.\n        if (num_elements_to_process_per_side == 0) {\n            break;\n        }\n\n        // Create a predicate for the current vector operation.\n        // This predicate will be active for the first 'num_elements_to_process_per_side' lanes,\n        // ensuring we only process the required number of elements.\n        svbool_t pg = svwhilelt_b16(0, num_elements_to_process_per_side);\n\n        // Load a vector from the left side of the current range.\n        svint16_t v_left = svld1(pg, arr + left_ptr);\n\n        // Load a vector from the right side of the current range.\n        // The starting address for the right vector load is calculated to align with the end of the range.\n        svint16_t v_right = svld1(pg, arr + right_ptr - num_elements_to_process_per_side + 1);\n\n        // Store the vector loaded from the right side back to the left side's position.\n        svst1(pg, arr + left_ptr, v_right);\n\n        // Store the vector loaded from the left side back to the right side's position.\n        svst1(pg, arr + right_ptr - num_elements_to_process_per_side + 1, v_left);\n\n        // Advance the left pointer and retract the right pointer by the number of elements processed.\n        left_ptr += num_elements_to_process_per_side;\n        right_ptr -= num_elements_to_process_per_side;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If the start index is greater than or equal to the end index,\n    // there's nothing to reverse or only a single element, so return.\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left = start;\n    uint64_t right = end;\n\n    // Get the vector length for int16_t elements.\n    // svcntw() returns the number of 16-bit elements that fit in an SVE vector.\n    size_t vl = svcntw();\n\n    // Create a full predicate for 16-bit elements.\n    // This predicate indicates that all elements in the vector are active.\n    svbool_t pg = svptrue_b16();\n\n    // Loop as long as the left pointer is less than the right pointer.\n    while (left < right) {\n        // Calculate the number of elements remaining in the current range to be reversed.\n        uint64_t remaining_elements = right - left + 1;\n\n        // If the remaining elements are fewer than a full vector length,\n        // it's more efficient to handle the rest with scalar operations\n        // to avoid complex partial vector handling and potential overhead.\n        if (remaining_elements < vl) {\n            // Perform scalar swaps for the remaining elements.\n            while (left < right) {\n                int16_t temp = arr[left];\n                arr[left] = arr[right];\n                arr[right] = temp;\n                left++;\n                right--;\n            }\n            // Break out of the main loop as the reversal is complete.\n            break;\n        }\n\n        // Load a vector from the left side of the range.\n        // `svld1_s16` loads `vl` signed 16-bit integers starting from `&arr[left]`.\n        svint16_t vec_left_data = svld1_s16(pg, &arr[left]);\n\n        // Load a vector from the right side of the range.\n        // The starting address for this load is `arr[right - vl + 1]`,\n        // which ensures we load the last `vl` elements from the current right segment.\n        // This calculation is safe because `remaining_elements >= vl` ensures `right - vl + 1`\n        // is a valid index within the current `[left, right]` segment or just before `left`.\n        svint16_t vec_right_data = svld1_s16(pg, &arr[right - vl + 1]);\n\n        // Reverse the elements within `vec_right_data` and store them to the left side.\n        // `svrev_s16` reverses the order of elements within the vector.\n        // This effectively moves elements from the right end of the array segment to the left end.\n        svst1_s16(pg, &arr[left], svrev_s16(vec_right_data));\n\n        // Reverse the elements within `vec_left_data` and store them to the right side.\n        // This moves elements from the left end of the array segment to the right end.\n        svst1_s16(pg, &arr[right - vl + 1], svrev_s16(vec_left_data));\n\n        // Advance the left pointer by the vector length.\n        left += vl;\n        // Decrement the right pointer by the vector length.\n        right -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c++\n#include <arm_sve.h> \n#include <stdint.h> // Required for int16_t, uint64_t\n#include <stddef.h> // Required for size_t\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If the range is empty or contains a single element, no reversal is needed.\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left_idx = start;\n    uint64_t right_idx = end;\n\n    // Get the number of 16-bit elements that fit into an SVE vector.\n    // This value 'k' is determined by the current vector length (VL) at runtime.\n    const size_t k = svcntw();\n\n    // Process full, non-overlapping vector pairs from both ends of the range.\n    // The loop continues as long as there are at least 2*k elements remaining\n    // to ensure that the left and right vector loads do not overlap.\n    while (right_idx - left_idx + 1 >= 2 * k) {\n        // Load a vector of 16-bit integers from the left side of the range.\n        // svptrue_b16() creates a predicate that enables all elements in the vector.\n        svint16_t vec_l = svld1_s16(svptrue_b16(), arr + left_idx);\n\n        // Load a vector of 16-bit integers from the right side of the range.\n        // The load starts 'k' elements before 'right_idx' to get the last 'k' elements.\n        svint16_t vec_r = svld1_s16(svptrue_b16(), arr + right_idx - k + 1);\n\n        // Reverse the order of elements within each loaded vector.\n        // For example, if vec_l = [A, B, C, D], reversed_vec_l becomes [D, C, B, A].\n        svint16_t reversed_vec_l = svrev_s16(vec_l);\n        svint16_t reversed_vec_r = svrev_s16(vec_r);\n\n        // Store the reversed right vector to the left side of the array.\n        // This effectively swaps the first 'k' elements of the left block with\n        // the last 'k' elements of the right block, in reversed order.\n        svst1_s16(svptrue_b16(), arr + left_idx, reversed_vec_r);\n\n        // Store the reversed left vector to the right side of the array.\n        // This completes the swap for this block of elements.\n        svst1_s16(svptrue_b16(), arr + right_idx - k + 1, reversed_vec_l);\n\n        // Move the pointers inward by 'k' elements for the next iteration.\n        left_idx += k;\n        right_idx -= k;\n    }\n\n    // Handle any remaining elements in the middle of the range using a scalar loop.\n    // This covers cases where the remaining elements are less than 2*k,\n    // or when 'left_idx' and 'right_idx' have crossed or met.\n    while (left_idx < right_idx) {\n        int16_t temp = arr[left_idx];\n        arr[left_idx] = arr[right_idx];\n        arr[right_idx] = temp;\n        left_idx++;\n        right_idx--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If the range is empty or contains a single element, no reversal is needed.\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t current_left_idx = start;\n    uint64_t current_right_idx = end;\n\n    // Get the vector length in terms of 16-bit elements.\n    // This value is constant for a given SVE implementation.\n    const uint64_t VL = svcntw();\n\n    // Create an index vector for reversing elements within a vector.\n    // For a vector of VL elements, this creates {VL-1, VL-2, ..., 0}.\n    const svint16_t indices_for_reverse = svindex_s16(VL - 1, -1);\n\n    // Loop while the left pointer is to the left of the right pointer.\n    while (current_left_idx < current_right_idx) {\n        // Calculate the number of pairs of elements remaining to be swapped.\n        // This is (number of elements in the remaining range) / 2.\n        uint64_t num_remaining_elements_in_range = current_right_idx - current_left_idx + 1;\n        uint64_t num_pairs_to_swap = num_remaining_elements_in_range / 2;\n\n        // Create a predicate for the current iteration.\n        // This predicate will be true for the first `num_pairs_to_swap` elements of a vector,\n        // up to the vector length (VL).\n        svbool_t pg_active_elements = svwhilelt_b16(0, num_pairs_to_swap);\n\n        // If no active elements in this iteration (e.g., num_pairs_to_swap is 0 or less than VL), break.\n        if (svptest_any(svptrue_b16(), pg_active_elements) == 0) {\n            break;\n        }\n\n        // Get the actual number of elements that will be processed in this vector iteration.\n        // This is the count of true bits in `pg_active_elements`.\n        uint64_t num_elements_in_this_iter = svcntp_b16(pg_active_elements);\n\n        // Load a full vector from the left side.\n        // `svptrue_b16()` ensures a full vector load, regardless of `pg_active_elements`.\n        // This is important because `svtbl` operates on the full vector.\n        svint16_t left_vec_full = svld1_s16(svptrue_b16(), arr + current_left_idx);\n\n        // Load a full vector from the right side.\n        // The load starts at `current_right_idx - (VL - 1)` to get `VL` elements ending at `current_right_idx`.\n        svint16_t right_vec_full = svld1_s16(svptrue_b16(), arr + current_right_idx - (VL - 1));\n\n        // Reverse the elements within the loaded vectors.\n        // `svtbl` uses `indices_for_reverse` to permute elements.\n        svint16_t right_vec_reversed = svtbl_s16(right_vec_full, indices_for_reverse);\n        svint16_t left_vec_reversed = svtbl_s16(left_vec_full, indices_for_reverse);\n\n        // Store the reversed right vector to the left side of the array.\n        // `pg_active_elements` ensures only the relevant elements are written.\n        svst1_s16(pg_active_elements, arr + current_left_idx, right_vec_reversed);\n\n        // Create a predicate for storing to the right side.\n        // This predicate needs to be true for the *last* `num_elements_in_this_iter` elements of the vector.\n        // `svwhilelt_b16(VL - num_elements_in_this_iter, VL)` generates a predicate\n        // that is true for indices from `VL - num_elements_in_this_iter` up to `VL - 1`.\n        svbool_t pg_right_store = svwhilelt_b16(VL - num_elements_in_this_iter, VL);\n\n        // Store the reversed left vector to the right side of the array.\n        // The store address is `arr + current_right_idx - (VL - 1)` (same as load).\n        // `pg_right_store` ensures the correct elements are written to their target positions.\n        svst1_s16(pg_right_store, arr + current_right_idx - (VL - 1), left_vec_reversed);\n\n        // Update the pointers for the next iteration.\n        // Both pointers move by `num_elements_in_this_iter` elements.\n        current_left_idx += num_elements_in_this_iter;\n        current_right_idx -= num_elements_in_this_iter;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left_idx = start;\n    uint64_t right_idx = end;\n\n    size_t vl = svcntw();\n\n    while (left_idx + 2 * vl - 2 < right_idx) {\n        svbool_t pg = svptrue_b16();\n\n        svint16_t vec_l = svld1_s16(pg, &arr[left_idx]);\n        svint16_t vec_r = svld1_s16(pg, &arr[right_idx - vl + 1]);\n\n        svint16_t vec_l_rev = svrev_s16(vec_l);\n        svint16_t vec_r_rev = svrev_s16(vec_r);\n\n        svst1_s16(pg, &arr[right_idx - vl + 1], vec_l_rev);\n        svst1_s16(pg, &arr[left_idx], vec_r_rev);\n\n        left_idx += vl;\n        right_idx -= vl;\n    }\n\n    while (left_idx < right_idx) {\n        int16_t temp = arr[left_idx];\n        arr[left_idx] = arr[right_idx];\n        arr[right_idx] = temp;\n        left_idx++;\n        right_idx--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Loop over the first dimension (dim1)\n    for (size_t i = 0; i < dim1; ++i) {\n        // Calculate the base offset for the current 'i' plane in the 3D tensor.\n        // This represents the starting index of the current dim2 x dim3 sub-tensor.\n        size_t base_offset_i = i * dim2 * dim3;\n\n        // Loop over the second dimension (dim2) using SVE intrinsics for parallelism.\n        size_t j = 0;\n        while (j < dim2) {\n            // Get the predicate for the current vector length (VL).\n            // This predicate ensures that operations only apply to valid elements,\n            // handling the tail elements when dim2 is not a multiple of VL.\n            svbool_t pg = svwhilelt_b8(j, dim2);\n\n            // Generate a vector of indices starting from 'j'.\n            // For example, if j=0, it generates 0, 1, 2, ..., VL-1.\n            // If j=VL, it generates VL, VL+1, VL+2, ..., 2*VL-1.\n            svuint64_t v_j_indices = svindex_u64(j, 1);\n\n            // Calculate the offsets for gathering data from the 'tensor' array.\n            // For each element 'k' in the vector (0 to VL-1), the full offset from\n            // the beginning of 'tensor' is:\n            // base_offset_i + (j + k) * dim3 + slice_idx\n            \n            // Step 1: Calculate (j + k) * dim3\n            svuint64_t v_j_dim3_offsets = svmul_n_u64(v_j_indices, dim3);\n\n            // Step 2: Add slice_idx to get (j + k) * dim3 + slice_idx\n            svuint64_t v_j_dim3_slice_offsets = svadd_n_u64(v_j_dim3_offsets, slice_idx);\n\n            // Step 3: Add base_offset_i to get the full offset from the start of 'tensor'\n            svuint64_t v_full_tensor_offsets = svadd_n_u64(v_j_dim3_slice_offsets, base_offset_i);\n\n            // Gather the uint8_t data from 'tensor' using the calculated offsets.\n            // This performs a gather load, fetching non-contiguous data into a vector.\n            svuint8_t v_data = svld1_gather_u64offset_u8(pg, tensor, v_full_tensor_offsets);\n\n            // Store the gathered data contiguously into the 'slice' array.\n            // The destination address for the current vector is 'slice + i * dim2 + j'.\n            // This performs a contiguous store.\n            svst1_u8(pg, slice + i * dim2 + j, v_data);\n\n            // Increment 'j' by the number of elements processed in this vector.\n            // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector.\n            j += svcntb();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        size_t base_offset_i = i * dim2 * dim3;\n\n        for (size_t j = 0; j < dim2; j += svcntb()) {\n            svbool_t pg = svwhilelt_b8(j, dim2);\n\n            svuint64_t indices_vec = svindex_u64(j, 1);\n            svuint64_t offsets_vec = svmul_n_u64(indices_vec, dim3);\n            offsets_vec = svadd_n_u64(offsets_vec, slice_idx);\n\n            svuint8_t loaded_data = svld1_gather_offset_u8(pg, tensor + base_offset_i, offsets_vec);\n\n            svst1_u8(pg, slice + i * dim2 + j, loaded_data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Handle edge cases for empty dimensions or invalid slice index\n    if (dim1 == 0 || dim2 == 0 || dim3 == 0 || slice_idx >= dim3) {\n        return;\n    }\n\n    // Iterate over the first dimension (rows of the 2D slice)\n    for (size_t i = 0; i < dim1; ++i) {\n        // Calculate the base pointer in the 3D tensor for the current 'row' (i.e., for a fixed 'i' and 'slice_idx').\n        // This points to the element tensor[i][0][slice_idx].\n        const uint8_t *current_row_base_tensor_ptr = tensor + (i * dim2 * dim3) + slice_idx;\n\n        // Calculate the base pointer in the output 2D slice for the current 'row'.\n        // This points to the element slice[i][0].\n        uint8_t *current_row_base_slice_ptr = slice + (i * dim2);\n\n        // Iterate over the second dimension (columns of the 2D slice) using SVE vectors.\n        // `j` is the column index within the current row.\n        for (size_t j = 0; j < dim2; j += svcntb()) {\n            // Create a predicate to handle the tail elements (when dim2 is not a multiple of vector length).\n            // `svwhilelt_b8` generates a predicate that is true for elements where `j + lane_idx < dim2`.\n            svbool_t pg = svwhilelt_b8(j, dim2);\n\n            // Generate a vector of offsets for the gather load.\n            // For each lane `k` (0 to svcntb()-1), the offset will be `(j + k) * dim3`.\n            // `svindex_u64(start, step)` generates a sequence `start, start+step, start+2*step, ...`.\n            // Here, `start` is `j * dim3` and `step` is `dim3`.\n            svuint64_t gather_offsets = svindex_u64((uint64_t)j * dim3, dim3);\n\n            // Perform the gather load operation.\n            // `svld1_gather_u8offset_u64` loads `uint8_t` elements from memory locations\n            // calculated by adding the `gather_offsets` to `current_row_base_tensor_ptr`.\n            svuint8_t loaded_vec = svld1_gather_u8offset_u64(pg, current_row_base_tensor_ptr, gather_offsets);\n\n            // Perform the contiguous store operation.\n            // `svst1_u8` stores the `loaded_vec` contiguously into the `slice` array,\n            // starting at `current_row_base_slice_ptr + j`.\n            svst1_u8(pg, current_row_base_slice_ptr + j, loaded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Loop over the first dimension (dim1)\n    for (size_t i = 0; i < dim1; ++i) {\n        // Calculate the base pointer for the current 2D plane (dim2 x dim3) within the 3D tensor.\n        // This is `tensor[i][0][0]` in 3D tensor terms.\n        const uint8_t *current_tensor_plane_base = tensor + i * dim2 * dim3;\n\n        // Calculate the base pointer for the current row in the output 2D slice.\n        // This is `slice[i][0]` in 2D slice terms.\n        uint8_t *current_slice_row_base = slice + i * dim2;\n\n        // Loop over the second dimension (dim2) with SVE vectorization.\n        // We process `dim2` elements for each `i` using SVE vectors.\n        for (size_t j = 0; j < dim2; j += svcntb()) {\n            // Create a predicate for the current vector chunk.\n            // This handles the tail elements when `dim2` is not a multiple of the vector length (VL).\n            svbool_t pg = svwhilelt_b8(j, dim2);\n\n            // Generate a vector of indices [j, j+1, ..., j+VL-1].\n            // These indices correspond to the 'j' dimension within the current 'i' plane.\n            svuint64_t indices_j = svindex_u64(j, 1);\n\n            // Calculate the byte offsets for the gather load from `current_tensor_plane_base`.\n            // For each element `tensor[i][j_vec][slice_idx]`, the offset from `current_tensor_plane_base`\n            // is `(j_vec * dim3 + slice_idx)`.\n            svuint64_t tensor_offsets = svmul_n_u64(indices_j, dim3);\n            tensor_offsets = svadd_n_u64(tensor_offsets, slice_idx);\n\n            // Perform the gather load: load `uint8_t` elements from scattered memory locations.\n            // The base address is `current_tensor_plane_base`, and offsets are in `tensor_offsets`.\n            svuint8_t vec_data = svld1_gather_u64offset_u8(pg, current_tensor_plane_base, tensor_offsets);\n\n            // Store the loaded data into the output slice.\n            // The store is contiguous, starting from `current_slice_row_base + j`.\n            svst1_u8(pg, current_slice_row_base + j, vec_data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t current_slice_output_idx = 0; // Tracks the current position in the output 'slice' array\n\n    // Iterate over the first dimension (dim1)\n    for (size_t i = 0; i < dim1; ++i) {\n        // Calculate the base offset for the current 'i' plane in the 3D tensor.\n        // This is the starting address of the i-th dim1-slice in the flattened tensor.\n        size_t base_offset_i_plane = i * dim2 * dim3;\n\n        // Iterate over the second dimension (dim2) using SVE intrinsics.\n        // For each (i, j) pair, we need to extract tensor[i * dim2 * dim3 + j * dim3 + slice_idx].\n        // The elements for a fixed 'i' and varying 'j' are strided in memory.\n        for (size_t j = 0; j < dim2; ) {\n            // Get the predicate for the current vector length (vl).\n            // This predicate ensures that only valid elements up to 'dim2' are processed,\n            // handling the tail end of the loop.\n            svbool_t pg = svwhilelt_b8(j, dim2);\n            \n            // Get the actual number of elements (uint8_t) that can be processed in this SVE vector.\n            size_t vl = svcntb(); \n\n            // Generate a vector of indices [j, j+1, j+2, ...].\n            // These represent the 'j' component for the current vector.\n            svuint64_t j_indices = svindex_u64(j, 1);\n\n            // Calculate the memory offsets for the gather load.\n            // For each element 'k' in the vector (where 'k' corresponds to j, j+1, ...),\n            // the offset in the 'tensor' array is:\n            // base_offset_i_plane + (j+k) * dim3 + slice_idx\n            \n            // Step 1: Multiply j_indices by dim3: [j*dim3, (j+1)*dim3, ...]\n            svuint64_t offsets_j_dim3 = svmul_n_u64(pg, j_indices, dim3);\n\n            // Step 2: Add the fixed part of the offset (base_offset_i_plane + slice_idx)\n            // to get the full absolute memory offsets for each element.\n            svuint64_t full_offsets = svadd_n_u64(pg, offsets_j_dim3, base_offset_i_plane + slice_idx);\n\n            // Perform the gather load from the 'tensor' array using the calculated full_offsets.\n            // svld1_gather_u8_u64 loads uint8_t elements from memory locations specified by 64-bit indices.\n            svuint8_t loaded_data = svld1_gather_u8_u64(pg, tensor, full_offsets);\n\n            // Store the loaded data contiguously into the 'slice' array.\n            // The store address is 'slice' + 'current_slice_output_idx'.\n            svst1_u8(pg, slice + current_slice_output_idx, loaded_data);\n\n            // Advance the loop counter for 'j' by the number of elements processed in this vector.\n            j += vl;\n            // Advance the output index by the number of elements processed.\n            current_slice_output_idx += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <algorithm> // For std::min\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Iterate through the matrix in blocks\n    for (size_t r = 0; r < rows; r += block_size) {\n        for (size_t c = 0; c < cols; c += block_size) {\n            // Calculate the actual dimensions of the current block\n            // This handles blocks at the edges of the matrix that might be smaller than block_size\n            size_t r_block_end = std::min(r + block_size, rows);\n            size_t c_block_end = std::min(c + block_size, cols);\n\n            // Transpose the current block:\n            // Iterate through columns of the source block (j)\n            // For each column 'j' in the source block, we gather its elements\n            // and then store them as a contiguous row in the destination block.\n            // This means src[row_idx][j] will be written to dst[j][row_idx].\n            for (size_t j = c; j < c_block_end; ++j) { // 'j' is the column index in src, which becomes the row index in dst\n                // Generate a vector of offsets for gathering elements from a column in 'src'.\n                // The base pointer for gather is 'src + j' (which points to src[0][j]).\n                // The offsets are 'i * cols' to access src[i][j].\n                // svindex_s64(start_value, step) generates a vector of [start_value, start_value + step, ...]\n                // Here, 'start_value' is 'r * cols' (to start from the current block row 'r'), and 'step' is 'cols'.\n                svint64_t gather_offsets = svindex_s64(r * cols, cols);\n\n                // Iterate through rows within the current block column (i)\n                // This loop processes elements in chunks determined by the SVE vector length.\n                for (size_t i = r; i < r_block_end; ) { // 'i' is the row index in src, which becomes the column index in dst\n                    // Create a predicate register for the current vector operation.\n                    // svwhilelt_b16(current_index, limit) generates a predicate where lanes are active\n                    // as long as current_index < limit.\n                    // (i - r) is the 0-based index within the current block column.\n                    // (r_block_end - r) is the height of the current block column.\n                    svbool_t pg = svwhilelt_b16(i - r, r_block_end - r);\n\n                    // Check if any elements are active in the predicate.\n                    // If not, we've processed all elements in this column of the block.\n                    if (!svptest_any(svptrue_b16(), pg)) {\n                        break;\n                    }\n\n                    // Gather a vector of int16_t elements from the current column of 'src'.\n                    // 'src + j' is the base address (src[0][j]).\n                    // 'gather_offsets' provides the strides to access src[r][j], src[r+1][j], etc.\n                    svint16_t vec = svld1_gather_s16offset(pg, src + j, gather_offsets);\n\n                    // Store the gathered vector contiguously into the destination matrix.\n                    // The destination address is &dst[j * rows + i], which corresponds to dst[j][i]\n                    // in a conceptual 'rows'-major layout for the transposed matrix.\n                    svst1_s16(pg, &dst[j * rows + i], vec);\n\n                    // Advance 'i' by the number of elements actually processed in this vector.\n                    // svcntp_b16(pg) returns the number of active lanes in the predicate 'pg'.\n                    i += svcntp_b16(pg);\n\n                    // Advance the gather offsets for the next vector load.\n                    // We need to add (svcntp_b16(pg) * cols) to each offset.\n                    gather_offsets = svadd_s64_x(pg, gather_offsets, svcntp_b16(pg) * cols);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <algorithm> // For std::min\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Get the scalable vector length for int16_t elements\n    size_t svl = svcnts();\n\n    // Iterate over blocks of rows\n    for (size_t r_block_start = 0; r_block_start < rows; r_block_start += block_size) {\n        // Iterate over blocks of columns\n        for (size_t c_block_start = 0; c_block_start < cols; c_block_start += block_size) {\n\n            // Iterate over individual rows within the current row block\n            for (size_t r = r_block_start; r < std::min(r_block_start + block_size, rows); ++r) {\n                // Iterate over columns within the current column block, processing 'svl' elements at a time\n                for (size_t c = c_block_start; c < std::min(c_block_start + block_size, cols); c += svl) {\n                    // Determine the number of active elements for the current vector operation\n                    // This handles partial vectors at the end of a row or block\n                    size_t num_elements_in_vec = std::min(svl, std::min(c_block_start + block_size, cols) - c);\n                    svbool_t pg = svwhilelt_b16(0, num_elements_in_vec);\n\n                    // Load a vector of int16_t from the source matrix row\n                    // The source pointer points to src[r * cols + c]\n                    const int16_t *src_vec_ptr = src + r * cols + c;\n                    svint16_t src_vec = svld1_s16(pg, src_vec_ptr);\n\n                    // Calculate the base address for the scatter store in the destination matrix\n                    // For an element src[r * cols + (c + i)], it needs to be stored at dst[(c + i) * rows + r].\n                    // The base address for the scatter operation is dst[c * rows + r].\n                    int16_t *dst_scatter_base_ptr = dst + c * rows + r;\n\n                    // Generate offsets for the scatter operation.\n                    // The stride is 'rows' because we are moving down a column in the destination matrix\n                    // for each consecutive element from the source vector.\n                    // This creates a vector like [0 * rows, 1 * rows, 2 * rows, ..., (svl-1) * rows].\n                    svint16_t scatter_offsets = svindex_s16(0, rows);\n\n                    // Store the vector using a scatter operation.\n                    // Each element src_vec[i] is stored at dst_scatter_base_ptr + scatter_offsets[i].\n                    svst1_scatter_s16offset(pg, dst_scatter_base_ptr, scatter_offsets, src_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Transpose the current block defined by (row_block, col_block)\n            // Iterate over rows within the current block\n            for (size_t r = 0; r < block_size; ++r) {\n                size_t src_row_idx = row_block + r;\n\n                // If this row is beyond the matrix boundary, stop processing this block's rows.\n                if (src_row_idx >= rows) {\n                    break;\n                }\n\n                // Iterate over columns within the current block, using SVE vectors\n                // 'c' is the starting column index within the current block for the SVE vector operation.\n                for (size_t c = 0; c < block_size; c += svcntw()) {\n                    size_t src_col_idx = col_block + c;\n\n                    // If this column segment starts beyond the matrix boundary, stop processing this row's columns.\n                    if (src_col_idx >= cols) {\n                        break;\n                    }\n\n                    // Create a predicate for the current vector operation.\n                    // This predicate ensures that we only process elements that are:\n                    // 1. Within the current 'block_size' column chunk (c to c + svcntw() - 1, limited by block_size).\n                    // 2. Within the overall 'cols' matrix boundary (src_col_idx to src_col_idx + svcntw() - 1, limited by cols).\n                    svbool_t pg = svwhilelt_b16(c, block_size);\n                    pg = svand_b(pg, svwhilelt_b16(src_col_idx, cols));\n\n                    // Load a vector of int16_t elements from the source matrix row.\n                    // The base address is src[src_row_idx * cols + src_col_idx].\n                    const int16_t *src_ptr = &src[src_row_idx * cols + src_col_idx];\n                    svint16_t src_vec = svld1_s16(pg, src_ptr);\n\n                    // Prepare for scatter store to the destination matrix column.\n                    // The elements from src_vec (which are src[src_row_idx][src_col_idx + i])\n                    // need to be stored at dst[(src_col_idx + i) * rows + src_row_idx].\n                    // The base pointer for the scatter operation is &dst[src_col_idx * rows + src_row_idx].\n                    // The offsets for each element 'i' in the vector should be 'i * rows'.\n                    // svindex_s64(0, rows) generates a vector of {0, rows, 2*rows, ..., (svcntw()-1)*rows}.\n                    int16_t *dst_base_ptr = &dst[src_col_idx * rows + src_row_idx];\n                    \n                    // Perform the scatter store.\n                    // The predicate 'pg' ensures that only valid elements are written.\n                    svst1_scatter_s16offset(pg, dst_base_ptr, svindex_s64(0, rows), src_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int16_t\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Get the maximum number of int16_t elements that can fit in a vector register.\n    // This value is used to determine the step size for processing elements in the inner loop.\n    const size_t sv_vl_int16 = svcnt_s16();\n\n    // Iterate over blocks of the source matrix\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n\n            // Transpose the current block (or partial block if at matrix edges)\n            // Iterate over rows within the current source block\n            for (size_t r = 0; r < block_size; ++r) {\n                // Calculate the global row index in the source matrix\n                size_t src_row_global = row_block + r;\n\n                // If the current source row (global index) is beyond the actual matrix rows,\n                // then any further rows in this block are out of bounds for the source matrix.\n                // This also implies that the corresponding destination column (row_block + r)\n                // would be out of bounds for the 'rows' dimension of the transposed matrix.\n                if (src_row_global >= rows) {\n                    break; // Exit the 'r' loop as no more valid source rows in this block\n                }\n\n                // Iterate over columns within the current source block, processing 'sv_vl_int16' elements at a time\n                for (size_t c = 0; c < block_size; c += sv_vl_int16) {\n                    // Calculate the global starting column index for the current vector load\n                    size_t src_col_global_start = col_block + c;\n\n                    // Create a predicate for elements that are within the current block's column range.\n                    // This handles the right edge of the block if 'block_size' is not a multiple of 'sv_vl_int16'.\n                    svbool_t pg_block_boundary = svwhilelt_b16(c, block_size);\n\n                    // Create a predicate for elements that are within the actual source matrix's column bounds.\n                    // This handles the right edge of the matrix if 'cols' is not a multiple of 'block_size'\n                    // or if 'block_size' extends beyond 'cols'.\n                    svbool_t pg_matrix_boundary = svwhilelt_b16(src_col_global_start, cols);\n\n                    // Combine both predicates: an element is active (loaded/stored) only if it's\n                    // within both the current block's boundaries AND the overall matrix's boundaries.\n                    svbool_t pg_active_lanes = svand_b(pg_block_boundary, pg_matrix_boundary);\n\n                    // Load a vector of int16_t elements from the source matrix.\n                    // The load is predicated, meaning only active lanes will load data.\n                    const int16_t *src_vec_ptr = src + src_row_global * cols + src_col_global_start;\n                    svint16_t data_vec = svld1_s16(pg_active_lanes, src_vec_ptr);\n\n                    // Prepare for the scatter store operation to the destination matrix.\n                    // In the transposed matrix, the source row index (src_row_global = row_block + r)\n                    // becomes the column index in the destination matrix.\n                    size_t dst_col_global = row_block + r;\n\n                    // The base pointer for the scatter operation.\n                    // For an element at source index (src_row_global, src_col_global_start + i),\n                    // its destination index is ((col_block + c + i), dst_col_global).\n                    // The memory address for this element is dst[(col_block + c + i) * rows + dst_col_global].\n                    // The base pointer for the scatter (when i=0) is dst[(col_block + c) * rows + dst_col_global].\n                    int16_t *dst_base_ptr = dst + (col_block + c) * rows + dst_col_global;\n\n                    // Generate scatter offsets. For each element 'i' in the vector,\n                    // its destination row index is (col_block + c + i).\n                    // The stride between consecutive rows in the destination matrix is 'rows'.\n                    // So, the offsets from 'dst_base_ptr' are 0 * rows, 1 * rows, 2 * rows, etc.\n                    svint16_t scatter_offsets = svindex_s16(0, rows);\n\n                    // Store the vector using a scatter operation.\n                    // The same 'pg_active_lanes' predicate is used to ensure writes only occur\n                    // to valid destination locations within the transposed matrix.\n                    svst1_scatter_s16offset(pg_active_lanes, dst_base_ptr, scatter_offsets, data_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Iterate over blocks in the source matrix\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n\n            // Iterate over rows within the current source block\n            for (size_t r = 0; r < block_size; ++r) {\n                // Calculate the actual row index in the full matrix\n                size_t current_src_row = row_block + r;\n                if (current_src_row >= rows) {\n                    break; // Reached end of matrix rows\n                }\n\n                // Base pointer for the current source row in the full matrix\n                const int16_t *src_row_base_ptr = src + current_src_row * cols;\n\n                // Iterate over columns within the current source block, using SVE vectors\n                // 'c' is the offset within the current block, relative to col_block\n                for (size_t c = 0; c < block_size; c += svcntw()) {\n                    // Calculate the actual starting column index in the full matrix for the current vector\n                    size_t current_src_col_actual = col_block + c;\n                    if (current_src_col_actual >= cols) {\n                        break; // Reached end of matrix columns\n                    }\n\n                    // Create a predicate for the current vector operation.\n                    // This predicate ensures that we only process elements that are:\n                    // 1. Within the current block (c + i < block_size)\n                    // 2. Within the actual matrix bounds (current_src_col_actual + i < cols)\n                    svbool_t pg_block = svwhilelt_b16(c, block_size);\n                    svbool_t pg_matrix = svwhilelt_b16(current_src_col_actual, cols);\n                    svbool_t pg = svand_b(pg_block, pg_matrix);\n\n                    // If no lanes are active in the predicate, there's nothing more to process in this row.\n                    if (!svptest_any(svptrue_b16(), pg)) {\n                        break;\n                    }\n\n                    // Load a vector of int16_t elements from the source row.\n                    // This is a contiguous load from `src[current_src_row][current_src_col_actual ... ]`.\n                    svint16_t src_vec = svld1_s16(pg, src_row_base_ptr + current_src_col_actual);\n\n                    // Prepare for scatter store to the destination matrix.\n                    // The elements from `src_vec[i]` need to be stored at `dst[(col_block + c + i) * rows + (row_block + r)]`.\n                    // The base pointer for the scatter operation is `dst + (row_block + r)`.\n                    // The offsets are `(col_block + c + i) * rows`.\n                    // `svindex_s64` generates a vector of 64-bit integers:\n                    // `start = (int64_t)(col_block + c) * rows`\n                    // `step = (int64_t)rows`\n                    svint64_t dst_offsets = svindex_s64((int64_t)(col_block + c) * rows, (int64_t)rows);\n\n                    // Perform the scatter store.\n                    // This stores `src_vec[i]` to `dst_base_ptr + dst_offsets[i]` for active lanes.\n                    svst1_scatter_s16offset(pg, dst + (row_block + r), dst_offsets, src_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    // Initialize a vector sum to zero. This vector will accumulate the sum of diagonal elements.\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n\n    // Calculate the constant stride for diagonal elements.\n    // In a 3D array of dimensions dim*dim*dim, the element at (i, j, k)\n    // is flattened to a 1D index: i * dim * dim + j * dim + k.\n    // For diagonal elements (i, i, i), the 1D index is:\n    // i * dim * dim + i * dim + i\n    // This simplifies to: i * (dim * dim + dim + 1)\n    // So, the stride between consecutive diagonal elements (e.g., index for (0,0,0) and (1,1,1))\n    // is (dim * dim + dim + 1).\n    const size_t stride = dim * dim + dim + 1;\n\n    // Loop variable 'i' represents the current diagonal index (from 0 to dim-1).\n    size_t i = 0;\n\n    // Generate the initial predicate for the SVE loop.\n    // svwhilelt_b32(i, dim) creates a predicate where lanes are active as long as\n    // the logical index (starting from 'i') is less than 'dim'.\n    svbool_t pg = svwhilelt_b32(i, dim);\n\n    // Loop as long as there are any active lanes in the predicate, meaning 'i' is still less than 'dim'.\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Generate a vector of sequential offsets: 0, 1, 2, ..., VL-1 (where VL is vector length).\n        svuint32_t indices_offset = svindex_u32(0, 1);\n\n        // Calculate the actual diagonal indices for the current vector chunk.\n        // This gives: i, i+1, i+2, ..., i+VL-1 (for active lanes).\n        // The _x suffix indicates that the operation is predicated by 'pg', meaning\n        // results are written only to active lanes.\n        svuint32_t current_diagonal_indices = svadd_u32_x(pg, svdup_u32(i), indices_offset);\n\n        // Calculate the 1D array offsets for the diagonal elements.\n        // Each diagonal index is multiplied by the pre-calculated 'stride'.\n        svuint32_t array_offsets = svmul_u32_x(pg, current_diagonal_indices, svdup_u32(stride));\n\n        // Gather load the float values from the 'array' using the calculated 1D offsets.\n        // svld1_gather_u32offset_f32(predicate, base_pointer, offsets_vector)\n        // Only active lanes (determined by 'pg') will perform the load.\n        svfloat32_t loaded_values = svld1_gather_u32offset_f32(pg, array, array_offsets);\n\n        // Accumulate the loaded values to the vector sum.\n        // svadd_f32_x(predicate, operand1, operand2) performs addition only on active lanes.\n        vec_sum = svadd_f32_x(pg, vec_sum, loaded_values);\n\n        // Advance the loop variable 'i' by the number of elements processed in a vector.\n        i += svcntw(); // svcntw() returns the number of 32-bit elements in an SVE vector.\n\n        // Generate the predicate for the next iteration.\n        // This will correctly handle the end of the loop, where 'i' might exceed 'dim',\n        // resulting in a partially or fully inactive predicate.\n        pg = svwhilelt_b32(i, dim);\n    }\n\n    // Reduce the final vector sum to a single scalar float value.\n    // svaddv_f32(predicate, vector) sums all elements in the vector.\n    // svptrue_b32() creates an all-true predicate, ensuring all elements in vec_sum are included.\n    float total_sum = svaddv_f32(svptrue_b32(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    // Calculate the stride for diagonal elements.\n    // The 1D index for array[i][i][i] in a dim x dim x dim array is:\n    // i * dim * dim + i * dim + i\n    // This simplifies to i * (dim * dim + dim + 1).\n    // So, the stride between consecutive diagonal elements (array[i][i][i] and array[i+1][i+1][i+1])\n    // is (dim * dim + dim + 1).\n    size_t stride = dim * dim + dim + 1;\n\n    // Initialize an SVE vector to accumulate the sum.\n    // All lanes are set to 0.0f.\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n\n    // Get the current vector length (number of float elements) for SVE.\n    // This determines how many elements are processed in parallel.\n    size_t sv_vl = svcnt_f32();\n\n    // Duplicate the calculated stride into an SVE vector.\n    // This is needed for element-wise multiplication with index vectors.\n    svuint64_t stride_vec = svdup_u64(stride);\n\n    // Loop through the diagonal elements.\n    // The loop increments by `sv_vl` to process elements in chunks.\n    for (size_t i = 0; i < dim; i += sv_vl) {\n        // Create a predicate vector.\n        // `svwhilelt_b32(i, dim)` generates a predicate where lanes are true\n        // as long as the current logical index (starting from `i`) is less than `dim`.\n        // This handles the \"tail\" elements when `dim` is not a multiple of `sv_vl`.\n        svbool_t pg = svwhilelt_b32(i, dim);\n\n        // Generate a vector of base indices for the current chunk.\n        // `svindex_u64(i, 1)` creates a vector like [i, i+1, i+2, ..., i + sv_vl - 1].\n        // These are the 'i' values for array[i][i][i].\n        svuint64_t current_indices = svindex_u64(i, 1);\n\n        // Calculate the 1D offsets for the diagonal elements in the current chunk.\n        // Each offset is `current_index * stride`.\n        svuint64_t offsets = svmul_u64(current_indices, stride_vec);\n\n        // Load the elements from the array using a gather load operation.\n        // `svld1_gather_u64offset_f32` loads float values from `array + offset` for each lane.\n        // Only lanes where `pg` is true will load valid data; inactive lanes typically load zeros.\n        svfloat32_t loaded_elements = svld1_gather_u64offset_f32(pg, array, offsets);\n\n        // Accumulate the loaded elements to the running sum vector.\n        sum_vec = svadd_f32(sum_vec, loaded_elements);\n    }\n\n    // Reduce the SVE sum vector to a single scalar float value.\n    // `svaddv_f32` sums all elements in the vector.\n    // `svptrue_b32()` creates a predicate where all lanes are active, ensuring all accumulated\n    // values in `sum_vec` are included in the final reduction.\n    float total_sum = svaddv_f32(svptrue_b32(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t current_sum_vec = svdup_f32(0.0f);\n\n    size_t dim_sq = dim * dim;\n    size_t stride_factor = dim_sq + dim + 1;\n\n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n\n        svuint32_t indices_base = svindex_u32(i, 1);\n\n        svuint32_t offsets = svmul_u32(indices_base, svdup_u32(stride_factor));\n\n        svfloat32_t loaded_elements = svld1_gather_u32offset_f32(pg, array, offsets);\n\n        current_sum_vec = svadd_f32_m(pg, current_sum_vec, loaded_elements);\n    }\n\n    float total_sum = svaddv_f32(svptrue_b32(), current_sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    // Initialize an SVE vector to accumulate the sum, filled with zeros.\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n\n    // Calculate the stride for diagonal elements.\n    // A diagonal element array[i][i][i] in a flattened 1D array has an index:\n    // i * dim * dim + i * dim + i\n    // This simplifies to i * (dim * dim + dim + 1).\n    // The stride is (dim * dim + dim + 1).\n    // Use uint64_t for stride calculation to prevent potential overflow for large 'dim' values,\n    // as 'dim * dim' can exceed 32-bit integer limits.\n    uint64_t stride = (uint64_t)dim * dim + dim + 1;\n\n    // Loop through the diagonal elements using SVE intrinsics.\n    // 'i' represents the current logical index along the diagonal (0 to dim-1).\n    // The loop increments 'i' by the number of float elements in an SVE vector (svcnt_f32()),\n    // processing multiple diagonal elements in parallel.\n    for (size_t i = 0; i < dim; i += svcnt_f32()) {\n        // Create a predicate for active lanes.\n        // svwhilelt_b32(i, dim) generates a predicate that is true for lanes\n        // where the current logical index (i + lane_idx) is less than 'dim'.\n        // This handles the tail elements when 'dim' is not a multiple of the vector length.\n        svbool_t pg = svwhilelt_b32(i, dim);\n\n        // Generate a vector of indices for the current batch of diagonal elements.\n        // svindex_s64(i, 1) creates a vector [i, i+1, i+2, ..., i + VL - 1]\n        // where VL is the SVE vector length. These are the 'k' values for 'k * stride'.\n        svint64_t k_indices = svindex_s64(i, 1);\n\n        // Calculate the 1D byte offsets for the diagonal elements.\n        // Each index 'k_indices' is multiplied by the 'stride'.\n        // svdup_s64(stride) broadcasts the scalar 'stride' value to all lanes of an svint64_t vector.\n        svint64_t offsets = svmul_s64(k_indices, svdup_s64(stride));\n\n        // Load the elements from 'array' using a gather load operation.\n        // svld1_gather_s64offset_f32 loads float32 elements from memory locations\n        // specified by 'array' (base pointer) and 'offsets' (vector of 64-bit offsets).\n        // The 'pg' predicate ensures that only active lanes load data; inactive lanes get 0.0f.\n        svfloat32_t loaded_elements = svld1_gather_s64offset_f32(pg, array, offsets);\n\n        // Accumulate the loaded elements into the sum vector.\n        vec_sum = svadd_f32(vec_sum, loaded_elements);\n    }\n\n    // Reduce the SVE sum vector to a single scalar float sum.\n    // svaddv_f32 sums all elements in the 'vec_sum' vector.\n    // svptrue_b32() creates an all-true predicate, ensuring all elements in 'vec_sum' are included.\n    float total_sum = svaddv_f32(svptrue_b32(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    // Calculate the constant stride for diagonal elements.\n    // A diagonal element array[i][i][i] has a 1D index of:\n    // i * dim * dim + i * dim + i = i * (dim * dim + dim + 1)\n    // The stride between consecutive diagonal elements is (dim * dim + dim + 1).\n    const size_t stride_val = dim * dim + dim + 1;\n\n    // Initialize the SVE vector accumulator for the sum.\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n\n    // Get the number of 32-bit float elements that fit in an SVE vector.\n    const size_t sv_len = svcntw();\n\n    // Loop through the diagonal elements using SVE vector processing.\n    // 'i' represents the current diagonal index (from 0 to dim-1).\n    for (size_t i = 0; i < dim; i += sv_len) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that we only process elements up to 'dim-1'.\n        svbool_t pg = svwhilelt_b32(i, dim);\n\n        // Generate a vector of indices for the current chunk: [i, i+1, i+2, ..., i+sv_len-1].\n        // These are the 'i' values for array[i][i][i].\n        svuint64_t current_diagonal_indices = svindex_u64(i, 1);\n\n        // Calculate the 1D array offsets for the diagonal elements.\n        // Each index 'k' in current_diagonal_indices is multiplied by 'stride_val'.\n        // The result is a vector of 1D offsets:\n        // [i * stride_val, (i+1) * stride_val, ..., (i+sv_len-1) * stride_val]\n        svuint64_t offsets = svmul_u64_x(pg, current_diagonal_indices, svdup_u64(stride_val));\n\n        // Gather the float values from the 'array' at the calculated offsets.\n        // Only active lanes (determined by 'pg') will perform the load.\n        svfloat32_t loaded_elements = svld1_gather_u64offset_f32(pg, array, offsets);\n\n        // Add the loaded elements to the vector sum accumulator.\n        // The addition is also predicated, so only active lanes contribute.\n        vec_sum = svadd_f32_x(pg, vec_sum, loaded_elements);\n    }\n\n    // Perform a horizontal sum of all elements in the vector accumulator to get the final scalar sum.\n    // svptrue_b32() creates a predicate where all lanes are true, ensuring all accumulated values are summed.\n    float total_sum = svaddv_f32(svptrue_b32(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n    svfloat64_t sv_scale = svdup_f64(scale);\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        svfloat64_t sv_src_val = svld1_f64(pg, &src[i]);\n\n        svbool_t cmp_gt_pred = svcmpgt_f64(pg, sv_src_val, sv_threshold);\n\n        svfloat64_t sv_scaled_val = svmul_f64(pg, sv_src_val, sv_scale);\n\n        svfloat64_t sv_result = svsel_f64(cmp_gt_pred, sv_scaled_val, sv_src_val);\n\n        svst1_f64(pg, &dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i = 0;\n    size_t total_elements = rows * cols;\n\n    // Duplicate threshold and scale into SVE vectors once\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    // Loop through the array in chunks determined by the SVE vector length\n    // svwhilelt_b64 generates a predicate for the active elements in the current chunk\n    // and handles the tail elements automatically.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the source array using the predicate 'pg'\n        svfloat64_t v_src = svld1_f64(pg, &src[i]);\n\n        // Compare if source value is greater than threshold.\n        // The 'pg' predicate ensures comparison only happens for active lanes.\n        svbool_t cmp_gt_pred = svcmpgt_f64(pg, v_src, v_threshold);\n\n        // Calculate the scaled value (src * scale).\n        // The 'pg' predicate ensures multiplication only happens for active lanes.\n        svfloat64_t v_scaled = svmul_f64(pg, v_src, v_scale);\n\n        // Select between the scaled value and the original value based on the comparison predicate.\n        // If cmp_gt_pred is true, select v_scaled; otherwise, select v_src.\n        // svsel_f64 does not take a governing predicate; it operates on all lanes based on its selection predicate.\n        // The 'pg' predicate from svwhilelt_b64 will govern the final store operation.\n        svfloat64_t v_dst = svsel_f64(cmp_gt_pred, v_scaled, v_src);\n\n        // Store the result to the destination array using the predicate 'pg'.\n        // This ensures that only the active elements (including tail elements) are written.\n        svst1_f64(pg, &dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Duplicate threshold and scale into SVE vectors for broadcasting\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n    svfloat64_t scale_vec = svdup_f64(scale);\n\n    // Loop through the array in chunks determined by the SVE vector length\n    // The svwhilelt_b64 predicate handles the loop termination and tail processing automatically.\n    do {\n        // Get a predicate for the current chunk of elements.\n        // This predicate is true for elements where i + element_index < total_elements.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of double-precision floating-point values from src.\n        // Only elements where pg is true are loaded.\n        svfloat64_t src_vec = svld1_f64(pg, &src[i]);\n\n        // Compare each element in src_vec with threshold_vec.\n        // Returns a predicate mask where true indicates src_vec_element > threshold_vec_element.\n        // The comparison is only performed for active elements defined by pg.\n        svbool_t condition_mask = svcmpgt_f64(pg, src_vec, threshold_vec);\n\n        // Perform the multiplication: src_vec * scale_vec.\n        // This operation is only applied to elements where condition_mask is true.\n        // For elements where condition_mask is false, the corresponding element in the result\n        // vector is undefined (or remains unchanged if the destination is src_vec itself,\n        // but here it's a new vector).\n        svfloat64_t scaled_vec = svmul_f64(condition_mask, src_vec, scale_vec);\n\n        // Select the final values for the destination vector.\n        // If condition_mask is true for an element, select the corresponding element from scaled_vec.\n        // Otherwise (if condition_mask is false), select the corresponding element from src_vec (original value).\n        // This selection is only performed for active elements defined by pg.\n        svfloat64_t result_vec = svsel_f64(condition_mask, scaled_vec, src_vec);\n\n        // Store the result vector into the destination array.\n        // Only elements where pg is true are stored.\n        svst1_f64(pg, &dst[i], result_vec);\n\n        // Increment the index by the number of double elements in an SVE vector.\n        i += svcntd();\n\n        // Continue looping as long as the predicate 'pg' is active (i.e., not all elements have been processed).\n    } while (svsvcnt_b64(pg));\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Duplicate threshold and scale into SVE vectors to broadcast them\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n    svfloat64_t sv_scale = svdup_f64(scale);\n\n    // Loop through the array in chunks determined by the SVE vector length\n    // svcntd() returns the number of 64-bit elements (doubles) in a vector.\n    // svwhilelt_b64 generates a predicate for elements less than 'total_elements',\n    // handling the tail end of the array automatically.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Get the predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of 'total_elements'.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of double-precision floating-point values from the source array.\n        // The 'pg' predicate ensures only active elements are loaded.\n        svfloat64_t src_vec = svld1_f64(pg, &src[i]);\n\n        // Compare each element in src_vec with sv_threshold.\n        // This returns a predicate where elements are greater than the threshold.\n        svbool_t cmp_gt_pred = svcmpgt_f64(pg, src_vec, sv_threshold);\n\n        // Perform conditional multiplication:\n        // svmul_f64_m(operand_if_false, predicate, operand1_if_true, operand2_if_true)\n        // If cmp_gt_pred is true for an element, result = src_vec * sv_scale.\n        // If cmp_gt_pred is false, result = src_vec (the original value, effectively unchanged).\n        svfloat64_t result_vec = svmul_f64_m(src_vec, cmp_gt_pred, src_vec, sv_scale);\n\n        // Store the resulting vector to the destination array.\n        // The 'pg' predicate ensures only active elements are stored.\n        svst1_f64(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Duplicate threshold and scale into SVE vectors for efficient comparison and multiplication\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n    svfloat64_t sv_scale = svdup_f64(scale);\n\n    // Loop through the elements in chunks determined by the SVE vector length\n    // svwhilelt_b64 generates a predicate that is true for active lanes\n    // as long as the current index 'i' is less than 'total_elements'.\n    // The loop continues as long as the predicate is not all false.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Generate the predicate for the current vector chunk.\n        // This predicate 'pg' controls which lanes are active for the current iteration,\n        // especially handling the tail elements.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the source array using the predicate 'pg'.\n        // Inactive lanes (for tail elements) will be zeroed.\n        svfloat64_t src_vec = svld1_f64(pg, &src[i]);\n\n        // Compare each element in src_vec with sv_threshold.\n        // This generates a new predicate 'cmp_gt_pred' where lanes are true\n        // if the corresponding src_vec element is greater than the threshold AND\n        // the lane was active in 'pg'.\n        svbool_t cmp_gt_pred = svcmpgt_f64(pg, src_vec, sv_threshold);\n\n        // Perform the scaling operation on all active lanes of src_vec.\n        // For lanes where 'pg' is true, this computes src_vec * sv_scale.\n        // For lanes where 'pg' is false (tail elements), src_vec is 0, so scaled_vec will be 0.\n        svfloat64_t scaled_vec = svmul_f64(src_vec, sv_scale);\n\n        // Select the final values for the destination vector.\n        // If 'cmp_gt_pred' is true for a lane, select the value from 'scaled_vec'.\n        // Otherwise (if 'cmp_gt_pred' is false), select the original value from 'src_vec'.\n        // This correctly handles both the conditional scaling and the tail elements\n        // (where cmp_gt_pred would be false for inactive lanes).\n        svfloat64_t result_vec = svsel_f64(cmp_gt_pred, scaled_vec, src_vec);\n\n        // Store the result vector into the destination array using the predicate 'pg'.\n        // Only active lanes (defined by 'pg') will be written to 'dst'.\n        svst1_f64(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Iterate over each row of the destination matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Get the source row index from the indices array\n        size_t src_row_index = indices[i];\n\n        // Calculate the starting memory addresses for the source and destination rows\n        const double *current_src_row_ptr = src + src_row_index * cols;\n        double *current_dst_row_ptr = dst + i * cols;\n\n        // Process the current row using SVE intrinsics\n        // k is the current column offset within the row\n        for (size_t k = 0; k < cols; k += svcntd()) {\n            // Create a predicate for the current vector operation.\n            // svwhilelt_b64 generates a predicate that is true for elements\n            // from k up to (but not including) cols, handling partial vectors at the end.\n            svbool_t pg = svwhilelt_b64(k, cols);\n\n            // Load a vector of double-precision floating-point values from the source row\n            svfloat64_t vec = svld1(pg, current_src_row_ptr + k);\n\n            // Store the vector of double-precision floating-point values to the destination row\n            svst1(pg, current_dst_row_ptr + k, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        const size_t src_row_idx = indices[i];\n        const double *current_src_row_ptr = src + src_row_idx * cols;\n        double *current_dst_row_ptr = dst + i * cols;\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(pg, current_src_row_ptr + j);\n            svst1(pg, current_dst_row_ptr + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Iterate over each row of the destination matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Get the index of the source row to be copied\n        size_t src_row_idx = indices[i];\n\n        // Calculate the starting address of the source row\n        const double *current_src_row = src + src_row_idx * cols;\n        // Calculate the starting address of the destination row\n        double *current_dst_row = dst + i * cols;\n\n        // Process the columns of the current row using SVE intrinsics\n        size_t col_offset = 0;\n        // Loop while the column offset is less than the total number of columns\n        while (col_offset < cols) {\n            // Create a predicate for the current vector operation.\n            // This predicate ensures that operations only occur on valid elements\n            // up to 'cols', handling cases where 'cols' is not a multiple of the vector length.\n            svbool_t pg = svwhilelt_b64(col_offset, cols);\n\n            // Load a vector of double-precision floating-point values from the source row\n            // using the generated predicate.\n            svfloat64_t vec = svld1_f64(pg, current_src_row + col_offset);\n\n            // Store the loaded vector of double-precision floating-point values\n            // to the destination row using the same predicate.\n            svst1_f64(pg, current_dst_row + col_offset, vec);\n\n            // Increment the column offset by the number of elements processed in one SVE vector.\n            // svcntd() returns the number of double elements in an SVE vector.\n            col_offset += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Iterate over each row of the destination matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Get the index of the source row that should be copied to the current destination row\n        size_t src_row_idx = indices[i];\n\n        // Calculate the starting memory address for the source row\n        const double *current_src_row_ptr = src + src_row_idx * cols;\n        // Calculate the starting memory address for the destination row\n        double *current_dst_row_ptr = dst + i * cols;\n\n        // Use SVE intrinsics to copy the elements of the row\n        size_t col_offset = 0;\n        while (col_offset < cols) {\n            // Create a predicate for the current vector operation.\n            // This predicate ensures that operations only occur within the bounds of the row.\n            // svwhilelt_b64 generates a predicate where elements are active as long as\n            // the current index (col_offset) is less than the total number of columns (cols).\n            svbool_t pg = svwhilelt_b64(col_offset, cols);\n\n            // Load a vector of double-precision floating-point values from the source row\n            // using the generated predicate. Inactive elements are not loaded.\n            svfloat64_t vec = svld1_f64(pg, current_src_row_ptr + col_offset);\n\n            // Store the loaded vector of double-precision floating-point values to the destination row\n            // using the same predicate. Inactive elements are not stored.\n            svst1_f64(pg, current_dst_row_ptr + col_offset, vec);\n\n            // Advance the column offset by the number of double elements processed in one SVE vector.\n            // svcntd() returns the number of double elements that fit in an SVE vector.\n            col_offset += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Iterate over each row in the destination matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Get the index of the source row that should be copied to the current destination row\n        size_t src_row_idx = indices[i];\n\n        // Calculate the starting memory addresses for the source and destination rows\n        const double *current_src_row_ptr = src + src_row_idx * cols;\n        double *current_dst_row_ptr = dst + i * cols;\n\n        // Initialize column offset for vector processing\n        size_t col_offset = 0;\n\n        // Loop through the columns of the current row using SVE vectors\n        // The predicate 'pg' controls which elements within the vector are active\n        // svwhilelt_b64 generates a predicate for 64-bit elements (doubles)\n        // that are less than 'cols' (total columns in the row).\n        svbool_t pg = svwhilelt_b64(col_offset, cols);\n\n        // Continue looping as long as there are active elements in the predicate\n        // svptest_any(svptrue_b64(), pg) checks if any lane in 'pg' is true\n        while (svptest_any(svptrue_b64(), pg)) {\n            // Load a vector of doubles from the source row using the predicate\n            svfloat64_t vec = svld1_f64(pg, current_src_row_ptr + col_offset);\n\n            // Store the vector of doubles to the destination row using the predicate\n            svst1_f64(pg, current_dst_row_ptr + col_offset, vec);\n\n            // Advance the column offset by the number of doubles in an SVE vector\n            col_offset += svcntd();\n\n            // Update the predicate for the next iteration\n            pg = svwhilelt_b64(col_offset, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t scalar_vec = svdup_s64(scalar);\n    svint64_t two_vec = svdup_s64(2);\n\n    for (i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        svint64_t src1_vec = svld1_s64(pg, &src1[i]);\n        svint64_t src2_vec = svld1_s64(pg, &src2[i]);\n\n        svint64_t sum_src1_src2 = svadd_s64_x(pg, src1_vec, src2_vec);\n        svint64_t sum_all = svadd_s64_x(pg, sum_src1_src2, scalar_vec);\n        svint64_t result_vec = svdiv_s64_x(pg, sum_all, two_vec);\n\n        svst1_s64(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n\n    // Duplicate the scalar value into an SVE vector, once outside the loop\n    svint64_t v_scalar = svdup_s64(scalar);\n    // Duplicate the divisor 2 into an SVE vector, once outside the loop\n    svint64_t v_divisor = svdup_s64(2);\n\n    // Loop through the arrays in chunks determined by the SVE vector length\n    // svwhilelt_b64 generates a predicate for the current chunk, handling tail elements automatically.\n    while (i < length) {\n        // Create a predicate for the current vector chunk.\n        // This predicate will be true for elements within the bounds [i, length).\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load data from src1 and src2 using the predicate.\n        // Only active elements (where pg is true) are loaded.\n        svint64_t v_src1 = svld1_s64(pg, src1 + i);\n        svint64_t v_src2 = svld1_s64(pg, src2 + i);\n\n        // Perform element-wise addition: src1 + src2.\n        // The _x suffix means the operation is performed only for active elements (where pg is true).\n        svint64_t v_sum_src = svadd_s64_x(pg, v_src1, v_src2);\n\n        // Add the scalar value to the sum.\n        svint64_t v_sum_total = svadd_s64_x(pg, v_sum_src, v_scalar);\n\n        // Divide the result by 2 (round-toward-zero for signed integers).\n        svint64_t v_result = svdiv_s64_x(pg, v_sum_total, v_divisor);\n\n        // Store the final result into the destination array using the predicate.\n        // Only active elements are stored.\n        svst1_s64(pg, dst + i, v_result);\n\n        // Increment the loop counter by the number of 64-bit elements in a full SVE vector.\n        // svcntd() returns the number of 64-bit elements (doublewords) in a full SVE vector.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < length) {\n        // Get a predicate for the current vector length.\n        // This predicate will be true for elements within the bounds [i, length).\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load vectors from src1 and src2 using the predicate\n        svint64_t vec1 = svld1_s64(pg, src1 + i);\n        svint64_t vec2 = svld1_s64(pg, src2 + i);\n\n        // Perform element-wise addition: vec1 + vec2\n        svint64_t sum_vec = svadd_s64(pg, vec1, vec2);\n\n        // Add the scalar value to the sum\n        svint64_t sum_scalar_vec = svadd_n_s64(pg, sum_vec, scalar);\n\n        // Divide the result by 2 (round-toward-zero)\n        svint64_t result_vec = svdiv_n_s64(pg, sum_scalar_vec, 2);\n\n        // Store the final result to the destination array\n        svst1_s64(pg, dst + i, result_vec);\n\n        // Increment the loop counter by the number of 64-bit elements in a full SVE vector.\n        // The predicate ensures that operations only apply to valid elements,\n        // and the loop condition `i < length` handles termination for the tail.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Duplicate the scalar value into an SVE vector\n    svint64_t sv_scalar = svdup_s64(scalar);\n    // Duplicate the divisor (2) into an SVE vector\n    svint64_t sv_two = svdup_s64(2);\n\n    // Loop through the arrays in chunks determined by the SVE vector length\n    while (i < length) {\n        // Get the predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the array bounds, especially for the tail end.\n        pg = svwhilelt_b64(i, length);\n\n        // Load data from src1 and src2 into SVE vectors\n        svint64_t sv_src1 = svld1_s64(pg, src1 + i);\n        svint64_t sv_src2 = svld1_s64(pg, src2 + i);\n\n        // Perform element-wise addition: (src1 + src2)\n        // The _x suffix indicates that the operation is predicated.\n        svint64_t sum_src1_src2 = svadd_s64_x(pg, sv_src1, sv_src2);\n\n        // Add the scalar value to the sum: (sum_src1_src2 + scalar)\n        svint64_t sum_all = svadd_s64_x(pg, sum_src1_src2, sv_scalar);\n\n        // Divide the result by 2 (round-toward-zero)\n        // svdiv_s64 performs integer division truncating towards zero,\n        // matching C's behavior for integer division.\n        svint64_t result = svdiv_s64_x(pg, sum_all, sv_two);\n\n        // Store the final result back to the destination array\n        svst1_s64(pg, dst + i, result);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        // svcntd() returns the number of 64-bit elements in an SVE vector.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n\n    // Duplicate the scalar value into an SVE vector once\n    svint64_t sv_scalar = svdup_s64(scalar);\n    // Duplicate the divisor (2) into an SVE vector once\n    svint64_t sv_divisor = svdup_s64(2);\n\n    // Loop while there are still elements to process\n    // svwhilelt_b64 generates a predicate for elements where 'i' < 'length'\n    // and implicitly handles the loop increment by the vector length.\n    for (i = 0; i < length; ) {\n        // Generate a predicate for the current vector chunk.\n        // 'pg' will be active for elements from 'i' up to 'length' (or svcntd() elements),\n        // ensuring correct handling of the last partial vector.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load data from src1 and src2 into SVE vectors using the predicate\n        svint64_t sv_src1 = svld1_s64(pg, src1 + i);\n        svint64_t sv_src2 = svld1_s64(pg, src2 + i);\n\n        // Perform element-wise addition: src1 + src2\n        svint64_t sv_sum1 = svadd_s64(pg, sv_src1, sv_src2);\n\n        // Add the scalar value to the sum\n        svint64_t sv_sum2 = svadd_s64(pg, sv_sum1, sv_scalar);\n\n        // Divide the result by 2 (round-toward-zero for integer division)\n        svint64_t sv_result = svdiv_s64(pg, sv_sum2, sv_divisor);\n\n        // Store the final result into the destination array using the predicate\n        svst1_s64(pg, dst + i, sv_result);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        // svcntd() returns the number of 64-bit elements in an SVE vector, which is dynamic.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find and return the minimum value among the even-numbered elements in the array..\nIf the array is empty, return -1.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    // Initialize the SVE vector for minimums with the largest possible 32-bit integer value (INT_MAX).\n    // Using the literal value for INT_MAX (2^31 - 1) to avoid requiring <limits.h> explicitly in this snippet.\n    svint32_t min_vec = svdup_s32(2147483647); \n\n    // Loop through the array in chunks determined by the SVE vector length.\n    for (size_t i = 0; i < length; i += svcnt_s32()) {\n        // Get a predicate for the current chunk, ensuring we don't read past the end of the array.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load the current chunk of data into an SVE vector.\n        svint32_t current_vec = svld1_s32(pg, &src[i]);\n\n        // Create a mask to identify even numbers.\n        // An integer 'x' is even if 'x % 2 == 0', which is equivalent to '(x & 1) == 0'.\n        svint32_t is_odd_check = svand_s32(pg, current_vec, svdup_s32(1));\n        svbool_t even_mask = svcmpeq_s32(pg, is_odd_check, svdup_s32(0));\n\n        // Update the minimum vector.\n        // svmin_s32_z performs a masked minimum: only lanes where 'even_mask' is true are updated.\n        // For lanes where 'even_mask' is false (odd numbers), 'min_vec' remains unchanged.\n        min_vec = svmin_s32_z(even_mask, min_vec, current_vec);\n    }\n\n    // Reduce the SVE vector to a single scalar minimum value across all lanes.\n    int final_min = svmin_s32_reduce(svptrue_b32(), min_vec);\n\n    // If 'final_min' is still the initial INT_MAX value, it means no even numbers were found in the array.\n    // In this case, return -1, consistent with the behavior for an empty array.\n    if (final_min == 2147483647) {\n        return -1;\n    }\n\n    return final_min;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c++\n#include <arm_sve.h> \n#include <limits> // For std::numeric_limits\n#include <algorithm> // For std::min\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    // Initialize a scalar variable to hold the overall minimum found.\n    // Set it to the maximum possible integer value so any valid even number will be smaller.\n    int overall_min_scalar = std::numeric_limits<int>::max();\n    \n    // Flag to track if any even number was found in the array.\n    bool found_even = false;\n\n    // Get the number of 32-bit integer elements that can fit in an SVE vector.\n    size_t sv_len = svcntw();\n\n    // Initialize an SVE vector with the maximum possible integer value.\n    // This vector will accumulate the minimum even value found in each lane's processing path.\n    svint32_t min_vec = svdup_n_s32(std::numeric_limits<int>::max());\n\n    // Loop through the array in chunks of `sv_len`.\n    // `i` is the starting index for the current vector chunk.\n    for (size_t i = 0; i < length; i += sv_len) {\n        // Create a predicate `pg` for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements,\n        // especially for the last, potentially partial, vector.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit integers from the source array using the predicate `pg`.\n        svint32_t current_vec = svld1_s32(pg, src + i);\n\n        // Determine if each element in `current_vec` is even.\n        // An integer 'x' is even if (x & 1) == 0.\n        // `svand_n_s32(current_vec, 1)` performs a bitwise AND with 1 for each lane.\n        // `sveq_n_s32(..., 0)` creates a predicate where lanes are true if the result of AND was 0.\n        svbool_t is_even_pred = sveq_n_s32(svand_n_s32(current_vec, 1), 0);\n\n        // Update `min_vec` with the minimum of its current values and `current_vec` values.\n        // This operation is conditional: only lanes where `is_even_pred` is true are updated.\n        // For lanes where `is_even_pred` is false (odd numbers or inactive lanes), `min_vec` retains its value.\n        min_vec = svmin_s32(is_even_pred, min_vec, current_vec);\n\n        // Check if any even number was found within the currently processed active elements.\n        // `svptest_any(pg, is_even_pred)` returns true if any element covered by `pg`\n        // also satisfies `is_even_pred`.\n        if (svptest_any(pg, is_even_pred)) {\n            found_even = true;\n        }\n    }\n\n    // After the loop, `min_vec` holds the minimum even value found in each lane's processing path,\n    // or `std::numeric_limits<int>::max()` if no even value was encountered in that path.\n\n    // Perform a horizontal reduction on `min_vec` to find the overall minimum across all lanes.\n    // `svmin_s32_x(svptrue_b32(), min_vec)` finds the minimum value among all elements in `min_vec`.\n    // If all elements in `min_vec` are `std::numeric_limits<int>::max()`, the result will be that value.\n    int vec_min_result = svmin_s32_x(svptrue_b32(), min_vec);\n\n    // The overall minimum is the minimum of the scalar initialized value and the vector reduction result.\n    // In this specific implementation, `overall_min_scalar` will simply be updated to `vec_min_result`.\n    overall_min_scalar = std::min(overall_min_scalar, vec_min_result);\n\n    // Return the result based on whether any even number was found.\n    if (found_even) {\n        return overall_min_scalar;\n    } else {\n        return -1; // No even numbers found in the array.\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // Required for INT_MAX\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    // Initialize the SVE vector for the minimum value with the largest possible integer.\n    // This ensures any valid even number found will be smaller.\n    svint32_t sv_min_val = svdup_s32(INT_MAX);\n\n    // Loop through the array in chunks determined by the SVE vector length (svcntw()).\n    // 'i' is the current starting index for each chunk.\n    for (size_t i = 0; i < length; i += svcntw()) {\n        // Get a predicate for the current chunk.\n        // This predicate ensures that we only process elements within the array bounds.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load data from the source array into an SVE vector.\n        // Only active lanes (determined by 'pg') will load valid data; inactive lanes are undisturbed.\n        svint32_t sv_data = svld1_s32(pg, src + i);\n\n        // Create a predicate for even numbers.\n        // An integer 'x' is even if (x % 2 == 0), which is equivalent to (x & 1 == 0).\n        // svdup_s32(1) creates a vector where all lanes are 1.\n        // svand_s32 performs bitwise AND.\n        // svcmpeq_s32 compares the result of the AND operation with 0.\n        // The predicate 'pg' ensures this check only applies to valid elements.\n        svbool_t sv_is_even = svcmpeq_s32(pg, svand_s32(sv_data, svdup_s32(1)), svdup_s32(0));\n\n        // Update the minimum value vector.\n        // svmin_s32_m(operand1, predicate, operand2, operand3) performs a masked minimum.\n        // For each lane where 'predicate' (sv_is_even) is true, operand1[lane] = min(operand2[lane], operand3[lane]).\n        // For each lane where 'predicate' is false, operand1[lane] = operand2[lane] (i.e., it remains unchanged).\n        // Here, we update 'sv_min_val' with the minimum of its current value and 'sv_data',\n        // but only for those lanes where the corresponding element in 'sv_data' is even.\n        sv_min_val = svmin_s32_m(sv_min_val, sv_is_even, sv_min_val, sv_data);\n    }\n\n    // Reduce the SVE vector to a single scalar minimum value.\n    // svminv_s32 finds the minimum value across all lanes of the vector.\n    // svptrue_b32() creates a predicate where all lanes are true, ensuring all lanes of sv_min_val are considered\n    // in the final reduction.\n    int overall_min = svminv_s32(svptrue_b32(), sv_min_val);\n\n    // If 'overall_min' is still INT_MAX, it means no even numbers were found in the array.\n    // In this case, INT_MAX is the correct result of the minimum operation.\n    // The problem specifies returning -1 only if the array is empty.\n    return overall_min;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <climits> // For INT_MAX\n#include <cstddef> // For size_t\n\nint vector_even_min_simd(const int *src, size_t length) {\n    // If the array is empty, return -1 as per the requirement.\n    if (length == 0) {\n        return -1;\n    }\n\n    // Initialize an SVE vector with the maximum possible integer value (INT_MAX).\n    // This vector will accumulate the minimum even number found in each lane.\n    // Any actual even number from the array will be less than or equal to INT_MAX.\n    svint32_t min_vec = svdup_s32(INT_MAX);\n\n    // A boolean flag to track if at least one even number has been found in the array.\n    bool found_even = false;\n\n    // Loop through the array using SVE vector operations.\n    // svwhilelt_b32 generates a predicate that controls which elements are processed\n    // in the current vector, ensuring we don't read beyond the array bounds.\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for the first vector chunk\n\n    // Continue processing as long as there are active elements in the predicate.\n    while (svcnt_b32(pg) > 0) {\n        // Load a vector of 32-bit integers from the source array using the predicate 'pg'.\n        svint32_t data_vec = svld1_s32(pg, src + i);\n\n        // Create a predicate for even numbers.\n        // An integer 'x' is even if (x & 1) == 0.\n        // svdup_s32(1) creates a vector where all lanes are 1.\n        // svand_s32 performs a bitwise AND operation.\n        // svcmpeq_s32 compares the result with 0 (svdup_s32(0)).\n        svint32_t one_vec = svdup_s32(1);\n        svint32_t zero_vec = svdup_s32(0);\n        svbool_t p_even = svcmpeq_s32(svand_s32(data_vec, one_vec), zero_vec);\n\n        // Update min_vec:\n        // For elements where 'p_even' is true (i.e., the number is even),\n        // take the minimum between the current min_vec lane value and the\n        // corresponding data_vec lane value.\n        // For elements where 'p_even' is false (odd numbers), the min_vec\n        // lane value remains unchanged.\n        min_vec = svmin_s32(min_vec, data_vec, p_even);\n\n        // Check if any even number was found in the current vector chunk.\n        // svptest_any returns true if any active lane in the main predicate 'pg'\n        // also has its corresponding lane true in the 'p_even' predicate.\n        if (svptest_any(pg, p_even)) {\n            found_even = true;\n        }\n\n        // Advance the index by the number of elements processed in this chunk.\n        i += svcnt_b32(pg);\n        // Get the predicate for the next vector chunk.\n        pg = svwhilelt_b32(i, length);\n    }\n\n    // After the loop, 'min_vec' contains the minimum even numbers found in each lane.\n    // Now, perform a horizontal minimum reduction across all lanes of 'min_vec'\n    // to get the single overall minimum even value.\n    // svptrue_b32() creates a predicate where all lanes are active, ensuring all\n    // elements of 'min_vec' are considered for the final reduction.\n    int final_min_value = svminv_s32(svptrue_b32(), min_vec);\n\n    // If no even numbers were found throughout the array (i.e., 'found_even' is still false),\n    // return -1 as per the requirement. Otherwise, return the calculated minimum.\n    if (!found_even) {\n        return -1;\n    } else {\n        return final_min_value;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // For INT_MAX\n#include <stddef.h> // For size_t\n\nint vector_even_min_simd(const int *src, size_t length) {\n    // If the array is empty, return -1 as per the requirement.\n    if (length == 0) {\n        return -1;\n    }\n\n    // Initialize an SVE vector with the maximum possible integer value.\n    // This ensures that any valid even number found will be smaller than the initial value,\n    // allowing the svmin_s32_m intrinsic to correctly find the minimum.\n    svint32_t min_vec = svdup_s32(INT_MAX);\n\n    // Get the number of 32-bit integers that fit in an SVE vector.\n    // This determines the stride for processing the array in chunks.\n    size_t sv_vec_len = svcntw();\n\n    // Loop through the array in chunks determined by the SVE vector length.\n    for (size_t i = 0; i < length; i += sv_vec_len) {\n        // Create a predicate for the current vector load.\n        // svwhilelt_b32 generates a predicate that is true for lanes\n        // where the current index (i + lane_offset) is less than 'length'.\n        // This handles array bounds and partial vectors at the end of the array.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load the current vector of elements from the source array using the predicate 'pg'.\n        // Elements outside the bounds (where pg is false) will not be loaded or processed.\n        svint32_t current_vec = svld1_s32(pg, src + i);\n\n        // Create a vector of 2s, which will be used for the modulo operation.\n        svint32_t two_vec = svdup_s32(2);\n\n        // Calculate the remainder when dividing by 2 for each active element in 'current_vec'.\n        // The '_m' suffix indicates a masked operation: only lanes where 'pg' is true are processed.\n        svint32_t remainder_vec = svmod_s32_m(pg, current_vec, two_vec);\n\n        // Create a predicate that is true for elements that are even (i.e., their remainder when divided by 2 is 0).\n        // This comparison is also masked by 'pg', so only in-bounds elements are considered.\n        svbool_t is_even_val_pred = svcmpeq_s32(pg, remainder_vec, svdup_s32(0));\n\n        // Conditionally update 'min_vec'.\n        // For lanes where 'is_even_val_pred' is true (meaning the element is in-bounds AND even),\n        // min_vec[lane] is updated to the minimum of its current value and current_vec[lane].\n        // For lanes where 'is_even_val_pred' is false (meaning the element is out-of-bounds OR odd),\n        // min_vec[lane] remains unchanged. This effectively ignores odd numbers and out-of-bounds elements.\n        min_vec = svmin_s32_m(is_even_val_pred, min_vec, current_vec);\n    }\n\n    // After the loop, 'min_vec' holds the minimum even value found in each of its lanes.\n    // Perform a horizontal reduction to find the overall minimum value across all lanes of 'min_vec'.\n    // svptrue_b32() creates a predicate that is true for all lanes, ensuring all lane minimums are considered\n    // in the final reduction.\n    int final_min_from_vec = svmin_s32_z(svptrue_b32(), min_vec);\n\n    // If 'final_min_from_vec' is still INT_MAX, it means no even numbers were found in the entire array.\n    if (final_min_from_vec == INT_MAX) {\n        return -1;\n    } else {\n        // Otherwise, return the minimum even number found.\n        return final_min_from_vec;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    // Broadcast the shift amount to a vector for both signed and unsigned shifts.\n    // The shift amount is the same for both operations.\n    svint32_t v_shift_s32 = svdup_s32(shift);\n    svuint32_t v_shift_u32 = svdup_u32(shift);\n\n    // Loop through the array in chunks determined by the SVE vector length (VL).\n    // svcntw() returns the number of 32-bit elements that fit in a vector register.\n    for (size_t i = 0; i < length; i += svcntw()) {\n        // Create a predicate for the current vector length.\n        // This handles the tail of the array by setting inactive lanes to false.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit signed integers from the source array.\n        svint32_t v_src = svld1_s32(pg, src + i);\n\n        // 1. Calculate the arithmetic right shift of each element.\n        // svasr_s32 performs an arithmetic right shift on signed 32-bit integers.\n        svint32_t v_arith_shifted = svasr_s32(pg, v_src, v_shift_s32);\n\n        // 2. Calculate the logical right shift of each element.\n        // First, reinterpret the signed integer vector as an unsigned integer vector.\n        // This does not change the bit pattern, only how it's interpreted.\n        svuint32_t v_src_u = svreinterpret_u32_s32(v_src);\n        // Perform the logical right shift on the unsigned integer vector.\n        svuint32_t v_logical_shifted_u = svlsr_u32(pg, v_src_u, v_shift_u32);\n        // Reinterpret the result back to a signed integer vector.\n        // This preserves the bit pattern, effectively casting the unsigned result back to int.\n        svint32_t v_logical_shifted_s = svreinterpret_s32_u32(v_logical_shifted_u);\n\n        // 3. Add the results of the arithmetic and logical shifts together.\n        svint32_t v_result = svadd_s32(pg, v_arith_shifted, v_logical_shifted_s);\n\n        // 4. Store the final results into the destination array.\n        svst1_s32(pg, dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    // Duplicate the shift value into SVE vectors for signed and unsigned operations\n    svint32_t vec_shift_s = svdup_n_s32(shift);\n    svuint32_t vec_shift_u = svdup_n_u32(shift);\n\n    while (i < length) {\n        // Generate a predicate for the current vector chunk\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit signed integers from the source array\n        svint32_t vec_src_s = svld1_s32(pg, src + i);\n\n        // 1. Calculate arithmetic right shift\n        svint32_t arith_shifted = svasr_s32(vec_src_s, vec_shift_s);\n\n        // 2. Calculate logical right shift\n        // Convert the signed integer vector to an unsigned integer vector\n        svuint32_t vec_src_u = svreinterpret_u32_s32(vec_src_s);\n        // Perform logical right shift on the unsigned vector\n        svuint32_t logic_shifted_u = svlsr_u32(vec_src_u, vec_shift_u);\n        // Convert the result back to a signed integer vector\n        svint32_t logic_shifted_s = svreinterpret_s32_u32(logic_shifted_u);\n\n        // 3. Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32(arith_shifted, logic_shifted_s);\n\n        // Store the final result into the destination array\n        svst1_s32(pg, dst + i, result);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process.\n    // svwhilelt_b32 generates a predicate for 32-bit elements\n    // that are less than 'length', starting from index 'i'.\n    for (svbool_t pg = svwhilelt_b32(i, length); svcnt_b32(pg) > 0; i += svcntw(), pg = svwhilelt_b32(i, length)) {\n        // Load a vector of 32-bit signed integers from the source array.\n        svint32_t src_vec = svld1_s32(pg, src + i);\n\n        // 1. Calculate the arithmetic right shift.\n        // svasr_s32 performs an arithmetic right shift on signed 32-bit integers.\n        svint32_t arith_shifted_vec = svasr_s32(src_vec, shift);\n\n        // 2. Calculate the logical right shift.\n        // First, reinterpret the signed integer vector as an unsigned integer vector.\n        svuint32_t src_vec_u = svreinterpret_u32(src_vec);\n        // Perform a logical right shift on the unsigned integer vector.\n        svuint32_t logic_shifted_u_vec = svlsr_u32(src_vec_u, shift);\n        // Reinterpret the result back to a signed integer vector.\n        svint32_t logic_shifted_vec = svreinterpret_s32(logic_shifted_u_vec);\n\n        // 3. Add the results of the arithmetic and logical shifts.\n        // svadd_s32 performs element-wise addition on signed 32-bit integers.\n        svint32_t result_vec = svadd_s32(arith_shifted_vec, logic_shifted_vec);\n\n        // 4. Store the final result into the destination array.\n        svst1_s32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n\n    // Duplicate the scalar shift amount into SVE vectors for signed and unsigned operations.\n    svint32_t v_shift_s32 = svdup_n_s32(shift);\n    svuint32_t v_shift_u32 = svdup_n_u32(shift);\n\n    while (length > 0) {\n        // Create a predicate for the current vector length, processing up to 'length' elements.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Get the number of elements that will be processed in this iteration.\n        size_t elements_in_vector = svcntp_b32(pg);\n\n        // Load data from the source array.\n        svint32_t v_src = svld1_s32(pg, src + i);\n\n        // 1. Calculate the arithmetic right shift.\n        // svasr_s32 performs a signed arithmetic right shift.\n        svint32_t v_arith_shifted = svasr_s32(pg, v_src, v_shift_s32);\n\n        // 2. Calculate the logical right shift.\n        // First, reinterpret the signed integer vector as an unsigned integer vector.\n        svuint32_t v_src_u = svreinterpret_u32_s32(v_src);\n        // Perform the logical right shift on the unsigned vector.\n        svuint32_t v_logical_shifted_u = svlsr_u32(pg, v_src_u, v_shift_u32);\n        // Reinterpret the result back to a signed integer vector.\n        svint32_t v_logical_shifted_s = svreinterpret_s32_u32(v_logical_shifted_u);\n\n        // 3. Add the results of the arithmetic and logical shifts.\n        svint32_t v_result = svadd_s32(pg, v_arith_shifted, v_logical_shifted_s);\n\n        // 4. Store the combined result into the destination array.\n        svst1_s32(pg, dst + i, v_result);\n\n        // Update the loop variables for the next iteration.\n        i += elements_in_vector;\n        length -= elements_in_vector;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while (i < length) {\n        // Get a predicate for the current vector length, active for elements within bounds\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of signed 32-bit integers from the source array\n        svint32_t vec_src = svld1_s32(pg, src + i);\n\n        // Perform arithmetic right shift\n        svint32_t vec_arith_shifted = svasr_s32(vec_src, shift);\n\n        // Convert the signed vector to an unsigned vector for logical shift\n        svuint32_t vec_src_u = svreinterpret_u32_s32(vec_src);\n        \n        // Perform logical right shift on the unsigned vector\n        svuint32_t vec_logical_shifted_u = svlsr_u32(vec_src_u, shift);\n        \n        // Convert the result of the logical shift back to a signed vector\n        svint32_t vec_logical_shifted = svreinterpret_s32_u32(vec_logical_shifted_u);\n\n        // Add the results of the arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32(vec_arith_shifted, vec_logical_shifted);\n\n        // Store the final result to the destination array\n        svst1_s32(pg, dst + i, vec_result);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t final_sum = 0;\n\n    // Initialize a vector of 64-bit integers to accumulate sums.\n    // Using 64-bit integers for accumulation prevents intermediate overflows,\n    // as the input elements are 32-bit and the final sum is 64-bit.\n    svint64_t vec_sum_acc = svdup_s64(0);\n\n    // Get the number of 32-bit elements that fit into an SVE vector.\n    // This determines the processing stride.\n    size_t svl_w = svcntw();\n\n    // Loop through the matrix elements in chunks of `svl_w`.\n    // `i` tracks the current element index in the flattened matrix.\n    for (size_t i = 0; i < total_elements; i += svl_w) {\n        // Create a predicate for the current vector operation.\n        // `svwhilelt_b32` generates a predicate that is true for elements\n        // where `i + element_index < total_elements`. This handles the tail\n        // of the array where the number of remaining elements is less than `svl_w`.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load 32-bit integers from the matrix into an SVE vector.\n        // Elements for which the predicate `pg` is false will be loaded as zero.\n        svint32_t data_vec_32 = svld1_s32(pg, matrix + i);\n\n        // To convert all 32-bit elements in `data_vec_32` to 64-bit elements,\n        // we need to split the `svint32_t` vector into two `svint32_t` vectors,\n        // each containing half the elements (even and odd indexed elements).\n        // `svuzp1_s32` and `svuzp2_s32` de-interleave elements. When used with\n        // the same input vector, they effectively split it into even and odd indexed elements.\n        // Each resulting vector will have `svcntd()` (number of 64-bit elements) elements.\n        svint32_t data_vec_32_even = svuzp1_s32(data_vec_32, data_vec_32);\n        svint32_t data_vec_32_odd = svuzp2_s32(data_vec_32, data_vec_32);\n\n        // Convert the two 32-bit vectors (each containing `svcntd()` elements)\n        // to 64-bit vectors.\n        svint64_t data_vec_64_even = svcvt_s64_s32(data_vec_32_even);\n        svint64_t data_vec_64_odd = svcvt_s64_s32(data_vec_32_odd);\n\n        // Accumulate the 64-bit sums into `vec_sum_acc`.\n        // `svptrue_b64()` creates a predicate where all elements are active,\n        // ensuring all elements of `data_vec_64_even` and `data_vec_64_odd` are added.\n        vec_sum_acc = svadd_s64_x(svptrue_b64(), vec_sum_acc, data_vec_64_even);\n        vec_sum_acc = svadd_s64_x(svptrue_b64(), vec_sum_acc, data_vec_64_odd);\n    }\n\n    // After the loop, `vec_sum_acc` holds partial sums in its elements.\n    // Perform a horizontal sum (sum all elements within the vector) to get the final total.\n    final_sum = svaddv_s64(svptrue_b64(), vec_sum_acc);\n\n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg; // Predicate register for SVE operations\n\n    // Loop through the matrix elements using SVE vectors.\n    // The loop continues until all elements have been processed.\n    do {\n        // Generate a predicate 'pg' for 32-bit elements.\n        // This predicate is true for lanes where 'i' (current index) is less than 'total_elements'.\n        // It handles the last, potentially partial, vector chunk.\n        pg = svwhilelt_b32(i, total_elements);\n\n        // Check if any lanes in the predicate are active (true).\n        // If no lanes are active, it means 'i' has reached or exceeded 'total_elements',\n        // and there are no more elements to process. Break the loop.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of 32-bit integers from the matrix, using the predicate 'pg'.\n        // Only elements corresponding to true predicate lanes are loaded effectively.\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n\n        // Horizontally sum the active elements within the loaded vector.\n        // svaddlv_s32 returns an int32_t, which is then implicitly promoted to int64_t\n        // before being added to the 'total_sum'.\n        total_sum += svaddlv_s32(pg, vec);\n\n        // Advance the index 'i' by the number of 32-bit elements in an SVE vector.\n        // svcntw() returns the number of 32-bit elements (words) that fit in an SVE vector.\n        i += svcntw();\n\n    } while (true); // The loop continues indefinitely until explicitly broken by the 'if' condition\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    \n    // Initialize an SVE vector of 64-bit integers with zeros.\n    // This vector will accumulate the sum of elements from the matrix.\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    size_t i = 0; // Current index in the flattened matrix array\n\n    // Loop through the matrix elements in chunks determined by the SVE vector length.\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    while (i < total_elements) {\n        // Create a predicate for the current vector operation.\n        // svwhilelt_b32(i, total_elements) generates a predicate that is true\n        // for elements from 'i' up to (but not including) 'total_elements'.\n        // This correctly handles the tail end of the matrix where fewer than\n        // a full vector's worth of elements remain.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load 32-bit integer elements from the matrix into an SVE vector.\n        // Only elements corresponding to true predicate lanes are loaded.\n        svint32_t vec_s32 = svld1_s32(pg, &matrix[i]);\n\n        // Convert the 32-bit integer elements to 64-bit integers.\n        // This is crucial to prevent potential overflow during summation,\n        // as the problem guarantees the final sum fits in int64_t, but\n        // intermediate sums of 32-bit elements might exceed int32_t limits.\n        svint64_t vec_s64 = svcvt_s64_s32(pg, vec_s32);\n\n        // Add the 64-bit elements from the current vector to the accumulating sum vector.\n        // The addition is performed only for elements where the predicate 'pg' is true.\n        sum_vec = svadd_s64(pg, sum_vec, vec_s64);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        i += svcntw();\n    }\n\n    // Reduce the final sum vector to a single 64-bit scalar sum.\n    // svptrue_b64() creates a predicate where all lanes are true, ensuring\n    // all elements within the 'sum_vec' are included in the horizontal sum.\n    int64_t total_sum = svaddv_s64(svptrue_b64(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n\n    // Initialize a vector of 64-bit integers to accumulate sums.\n    // All elements are initialized to 0.\n    svint64_t sum_vec = svdup_s64(0);\n\n    // Loop through the matrix elements, processing them in SVE vector chunks.\n    // 'i' tracks the current index in the flattened matrix array.\n    size_t i = 0;\n    while (i < total_elements) {\n        // Create a predicate for 32-bit elements.\n        // This predicate ensures that we only process valid elements,\n        // especially for the last (partial) vector.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit integers from the matrix.\n        // The predicate 'pg' controls which lanes are loaded.\n        svint32_t data_vec = svld1_s32(pg, &matrix[i]);\n\n        // Widen the 32-bit integers to 64-bit integers.\n        // svaddl_s32 performs a widening add: result[i] = (int64_t)op1[i] + (int64_t)op2[i].\n        // By adding with a zero vector (svdup_s32(0)), we effectively cast/widen\n        // each 32-bit element in 'data_vec' to a 64-bit element.\n        svint32_t zero_vec_s32 = svdup_s32(0);\n        svint64_t widened_data_vec = svaddl_s32(data_vec, zero_vec_s32);\n\n        // Accumulate the widened data vector into the 64-bit sum vector.\n        // svadd_s64_x performs an element-wise addition.\n        // svptrue_b64() creates a predicate where all 64-bit lanes are active.\n        sum_vec = svadd_s64_x(svptrue_b64(), sum_vec, widened_data_vec);\n\n        // Advance the index by the number of 32-bit elements in an SVE vector.\n        // svcntw() returns the number of 32-bit elements that fit in a vector.\n        i += svcntw();\n    }\n\n    // Perform a horizontal sum of all elements in the 'sum_vec' accumulator.\n    // This reduces the vector of 64-bit partial sums to a single 64-bit scalar sum.\n    // svptrue_b64() ensures all lanes of the sum vector are included in the reduction.\n    int64_t final_scalar_sum = svaddv_s64(svptrue_b64(), sum_vec);\n\n    return final_scalar_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n\n    // Initialize an SVE vector to accumulate 64-bit sums.\n    // This prevents intermediate overflows as 32-bit integers are summed.\n    svint64_t vec_sum = svdup_s64(0);\n\n    // Iterate through the matrix elements in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements,\n        // handling the tail (remaining) elements at the end of the array.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load 32-bit integer elements from the matrix into an SVE vector,\n        // using the predicate to mask out-of-bounds elements for the last chunk.\n        svint32_t current_elements = svld1_s32(pg, &matrix[i]);\n\n        // Widen the 32-bit elements to 64-bit. This is crucial to prevent\n        // overflow when accumulating sums within the vector, as the sum can\n        // quickly exceed the range of a 32-bit integer.\n        svint64_t widened_elements = svsext_s64_s32(current_elements);\n\n        // Accumulate the widened 64-bit elements into the 64-bit sum vector.\n        vec_sum = svadd_s64(vec_sum, widened_elements);\n    }\n\n    // Perform a horizontal sum reduction on the final 64-bit accumulator vector.\n    // svptrue_b64() creates a predicate that enables all lanes of the 64-bit vector\n    // to be included in the sum.\n    int64_t total_sum = svaddv_s64(svptrue_b64(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For int8_t\n#include <limits.h> // For INT8_MIN\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    // Pass 1: Find the global maximum value in the array.\n    // Initialize a vector with the smallest possible int8_t value.\n    svint8_t current_max_vec = svdup_s8(INT8_MIN);\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the array in SVE vector chunks.\n    // svwhilelt_b8 generates a predicate for elements less than 'length'.\n    // svcntb() returns the number of 8-bit elements in an SVE vector.\n    do {\n        pg = svwhilelt_b8(i, length);\n        // Load data into an SVE vector using the predicate.\n        svint8_t data_vec = svld1_s8(pg, src + i);\n        // Update the current maximum vector by comparing with loaded data.\n        current_max_vec = svmax_s8(current_max_vec, data_vec);\n        // Advance the index by the number of elements in an SVE vector.\n        i += svcntb();\n    } while (i < length);\n\n    // Reduce the vector of maximum values to a single scalar global maximum.\n    // svptrue_b8() creates a predicate where all lanes are active for the reduction.\n    int8_t global_max_val = svmaxv_s8(svptrue_b8(), current_max_vec);\n\n    // Pass 2: Find the first index of the global maximum value.\n    // Initialize a vector of indices with SIZE_MAX (a very large value)\n    // to ensure that any valid index will be smaller.\n    svuint64_t min_idx_vec = svdup_u64(SIZE_MAX);\n    i = 0; // Reset index for the second pass.\n\n    do {\n        pg = svwhilelt_b8(i, length);\n        // Load data into an SVE vector.\n        svint8_t data_vec = svld1_s8(pg, src + i);\n\n        // Create a predicate for elements that are equal to the global maximum value.\n        svbool_t match_pred = svcmpeq_s8(pg, data_vec, svdup_s8(global_max_val));\n\n        // Generate a vector of current indices (i, i+1, i+2, ...).\n        svuint64_t current_indices = svindex_u64(i, 1);\n\n        // Select current_indices for matching elements, otherwise keep SIZE_MAX.\n        // Then, take the minimum between the current min_idx_vec and the selected indices.\n        // This ensures that min_idx_vec accumulates the smallest index found so far for any matching element.\n        min_idx_vec = svmin_u64(min_idx_vec, svsel_u64(match_pred, current_indices, svdup_u64(SIZE_MAX)));\n\n        // Advance the index.\n        i += svcntb();\n    } while (i < length);\n\n    // Reduce the vector of minimum indices to a single scalar minimum index.\n    // svptrue_b64() creates a predicate where all lanes are active for the reduction\n    // of the uint64_t vector.\n    size_t final_max_idx = svminv_u64(svptrue_b64(), min_idx_vec);\n\n    return final_max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For int8_t\n#include <limits.h> // For INT8_MIN\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    // Initialize scalar max value and index for the final reduction\n    int8_t max_val_scalar = INT8_MIN;\n    size_t max_idx_scalar = 0;\n\n    // Get the SVE vector length in bytes (which is also the number of int8_t elements)\n    // This value is constant for a given execution but can vary between SVE implementations.\n    const size_t vl = svcntb();\n\n    // Initialize SVE vectors for current maximum value and its corresponding index.\n    // Each lane in these vectors will accumulate the maximum value and its index\n    // from elements at `lane_idx`, `lane_idx + VL`, `lane_idx + 2*VL`, etc.\n    svint8_t current_max_val_vec = svdup_s8(INT8_MIN);\n    svuint64_t current_max_idx_vec = svdup_u64(0);\n\n    // Loop through the array in chunks of VL elements\n    for (size_t i = 0; i < length; i += vl) {\n        // Create a predicate for the current vector operation.\n        // This handles partial vectors at the end of the array.\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load a vector of 8-bit integer data from the source array\n        svint8_t data_vec = svld1_s8(pg, src + i);\n\n        // Generate a vector of absolute indices for the current block: i, i+1, i+2, ...\n        svuint64_t indices_vec = svindex_u64(i, 1);\n\n        // 1. Find elements that are strictly greater than the current maximums in their respective lanes.\n        svbool_t cmp_gt = svcmpgt_s8(pg, data_vec, current_max_val_vec);\n\n        // 2. Find elements that are equal to the current maximums AND have a smaller index.\n        // This handles the tie-breaking rule (return the first occurrence).\n        svbool_t cmp_eq = svcmpeq_s8(pg, data_vec, current_max_val_vec);\n        svbool_t cmp_lt_idx = svcmplt_u64(pg, indices_vec, current_max_idx_vec);\n        svbool_t update_on_tie = svand_b(cmp_eq, cmp_lt_idx);\n\n        // Combine predicates: update if strictly greater OR (equal AND smaller index)\n        svbool_t final_update_pred = svorr_b(cmp_gt, update_on_tie);\n\n        // Update the current maximum value vector\n        current_max_val_vec = svsel_s8(final_update_pred, data_vec, current_max_val_vec);\n        // Update the current maximum index vector\n        current_max_idx_vec = svsel_u64(final_update_pred, indices_vec, current_max_idx_vec);\n    }\n\n    // Horizontal reduction: After the loop, current_max_val_vec and current_max_idx_vec\n    // hold the maximum value and its index for each \"logical lane\" across the entire array.\n    // For example, lane 0 holds the max of src[0], src[VL], src[2*VL], etc.\n    // We need to find the overall maximum among these VL results and its corresponding index.\n\n    // Store the vector results to temporary arrays for scalar processing.\n    // The size of these arrays is VL, which is typically small (e.g., 16 for int8_t on A64FX).\n    int8_t temp_max_vals[vl];\n    size_t temp_max_indices[vl];\n\n    // Use svptrue_b8() and svptrue_b64() to ensure all lanes are stored, as these vectors\n    // are fully populated with meaningful results from the loop.\n    svst1_s8(svptrue_b8(), temp_max_vals, current_max_val_vec);\n    svst1_u64(svptrue_b64(), temp_max_indices, current_max_idx_vec);\n\n    // Perform a scalar loop over the temporary arrays to find the global maximum and its first index.\n    for (size_t k = 0; k < vl; ++k) {\n        if (temp_max_vals[k] > max_val_scalar) {\n            max_val_scalar = temp_max_vals[k];\n            max_idx_scalar = temp_max_indices[k];\n        } else if (temp_max_vals[k] == max_val_scalar) {\n            // If values are equal, choose the one with the smaller index\n            if (temp_max_indices[k] < max_idx_scalar) {\n                max_idx_scalar = temp_max_indices[k];\n            }\n        }\n    }\n\n    return max_idx_scalar;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h> // For int8_t\n#include <limits.h> // For INT8_MIN, SIZE_MAX\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    // Initialize SVE vectors for accumulating the maximum value and its corresponding index.\n    // For argmax (finding the first occurrence of the maximum value),\n    // initialize `vec_max_val` to the smallest possible int8_t value (INT8_MIN).\n    // Initialize `vec_max_idx` to the largest possible size_t value (SIZE_MAX)\n    // so that any valid index will be smaller and thus preferred in tie-breaking.\n    svint8_t vec_max_val = svdup_s8(INT8_MIN);\n    svuint64_t vec_max_idx = svdup_u64(SIZE_MAX);\n\n    size_t i = 0;\n    // Loop through the array in chunks of SVE vector length.\n    // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector.\n    // The loop continues as long as 'i' is less than 'length'.\n    // The predicate 'pg' handles partial vectors at the end of the array.\n    for (; i < length; ) {\n        // Create a predicate for active lanes.\n        // svwhilelt_b8(i, length) generates a predicate where lanes are true\n        // as long as their corresponding index (starting from 'i') is less than 'length'.\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load current values from the source array into an SVE vector.\n        // Only active lanes (determined by 'pg') will load valid data.\n        svint8_t current_vals = svld1_s8(pg, &src[i]);\n\n        // Generate current indices for the loaded elements.\n        // svindex_u64(i, 1) creates a vector with elements (i, i+1, i+2, ...).\n        svuint64_t current_indices = svindex_u64(i, 1);\n\n        // Compare current values with the current maximums stored in `vec_max_val`.\n        // cmp_gt: true if current_vals > vec_max_val\n        svbool_t cmp_gt = svcmpgt_s8(pg, current_vals, vec_max_val);\n        // cmp_eq: true if current_vals == vec_max_val\n        svbool_t cmp_eq = svcmpeq_s8(pg, current_vals, vec_max_val);\n        // cmp_idx_lt: true if current_indices < vec_max_idx (for tie-breaking)\n        svbool_t cmp_idx_lt = svcmplt_u64(pg, current_indices, vec_max_idx);\n\n        // Determine the update mask for each lane:\n        // A lane should be updated if:\n        // 1. Its current value is strictly greater than the current max value (cmp_gt is true) OR\n        // 2. Its current value is equal to the current max value (cmp_eq is true) AND\n        //    its current index is strictly smaller than the current max index (cmp_idx_lt is true).\n        // This implements the \"first occurrence\" tie-breaking rule for argmax.\n        svbool_t update_mask = svorr_b(cmp_gt, svand_b(cmp_eq, cmp_idx_lt));\n\n        // Select new max values and indices based on the `update_mask`.\n        // For lanes where `update_mask` is true, take `current_vals` (or `current_indices`).\n        // Otherwise, keep the existing `vec_max_val` (or `vec_max_idx`).\n        vec_max_val = svsel_s8(update_mask, current_vals, vec_max_val);\n        vec_max_idx = svsel_u64(update_mask, current_indices, vec_max_idx);\n\n        // Advance the loop counter by the full SVE vector length.\n        // The predicate 'pg' ensures that only valid elements are processed in each iteration.\n        i += svcntb();\n    }\n\n    // Horizontal reduction to find the overall maximum value and its first index across all lanes.\n\n    // Step 1: Find the overall maximum value among all lanes of `vec_max_val`.\n    // svmaxv_s8 performs a horizontal maximum reduction on the vector.\n    int8_t overall_max_val = svmaxv_s8(svptrue_b8(), vec_max_val);\n\n    // Step 2: Create a mask for lanes where `vec_max_val` equals the `overall_max_val`.\n    // This identifies all lanes that potentially hold the global maximum value.\n    svbool_t mask_is_max = svcmpeq_s8(svptrue_b8(), vec_max_val, svdup_s8(overall_max_val));\n\n    // Step 3: Select the indices corresponding to the maximum values.\n    // For lanes that do not contain the `overall_max_val`, set their index to SIZE_MAX.\n    // This ensures that when we find the minimum index in the next step,\n    // only those indices corresponding to the actual maximum value are considered.\n    svuint64_t selected_indices = svsel_u64(mask_is_max, vec_max_idx, svdup_u64(SIZE_MAX));\n\n    // Step 4: Find the minimum index among the `selected_indices`.\n    // Since `SIZE_MAX` was used for non-max values, this will correctly yield\n    // the smallest index among all occurrences of the `overall_max_val`.\n    size_t final_max_idx = svminv_u64(svptrue_b8(), selected_indices);\n\n    return final_max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    // Initialize scalar max value and its index.\n    // Start with the first element as the initial maximum.\n    // This correctly handles arrays with all negative numbers and single-element arrays.\n    int8_t current_max_val = src[0];\n    size_t current_max_idx = 0;\n\n    // Loop through the array using SVE vectors.\n    // 'i' tracks the current global index for the start of each vector chunk.\n    size_t i = 0;\n    while (i < length) {\n        // Get a predicate for the current vector chunk.\n        // svwhilelt_b8 generates a predicate for 8-bit elements,\n        // setting lanes to true as long as 'i' is less than 'length'.\n        // This handles partial vectors at the end of the array.\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load the vector of 8-bit integers from the source array.\n        svint8_t data_vec = svld1_s8(pg, &src[i]);\n\n        // Find the maximum value within the current vector.\n        // svmaxv_s8 reduces the vector to a single scalar maximum value,\n        // considering only the active lanes defined by 'pg'.\n        int8_t vec_max_val = svmaxv_s8(pg, data_vec);\n\n        // Compare the vector's maximum with the current global maximum.\n        if (vec_max_val > current_max_val) {\n            // If the vector's maximum is strictly greater, update the global maximum value.\n            current_max_val = vec_max_val;\n\n            // Find the index of the first occurrence of this new maximum within the current vector.\n            // 1. Create a predicate where lanes matching 'vec_max_val' are true.\n            svbool_t match_pred = svcmpeq_s8(pg, data_vec, svdup_s8(vec_max_val));\n            \n            // 2. Use svfirst_b8 to get the index of the first true lane in 'match_pred'.\n            // This intrinsic returns the relative index (0 to svcntb()-1) of the first matching element.\n            size_t relative_idx = svfirst_b8(match_pred);\n            \n            // Update the global maximum index by adding the relative index to the base index 'i'.\n            current_max_idx = i + relative_idx;\n        } else if (vec_max_val == current_max_val) {\n            // If the vector's maximum is equal to the current global maximum (tie-breaking scenario).\n            // We need to check if there's an occurrence of this value at an earlier index\n            // within the current vector chunk compared to the current_max_idx.\n            \n            // 1. Create a predicate for elements in 'data_vec' that match 'vec_max_val'.\n            svbool_t match_pred = svcmpeq_s8(pg, data_vec, svdup_s8(vec_max_val));\n            \n            // 2. Get the relative index of the first matching element in the current vector.\n            size_t relative_idx = svfirst_b8(match_pred);\n            \n            // If the calculated global index (i + relative_idx) is smaller than the\n            // current_max_idx, update current_max_idx to this new, earlier index.\n            if (i + relative_idx < current_max_idx) {\n                current_max_idx = i + relative_idx;\n            }\n        }\n\n        // Move to the next vector chunk.\n        // svcntb() returns the number of 8-bit elements in an SVE vector for the current VL (Vector Length).\n        i += svcntb();\n    }\n\n    return current_max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // For SCHAR_MIN\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t i = 0;\n    size_t vl = svcntb(); // Get the number of 8-bit elements per vector\n\n    // Initialize SVE vectors for tracking the maximum value and its index.\n    // vec_max_val: Stores the maximum value found in each lane's conceptual partition.\n    // vec_max_idx: Stores the index corresponding to the value in vec_max_val.\n    // Initialize vec_max_val with the smallest possible int8_t value.\n    // Initialize vec_max_idx with 0s; these will be updated by the first valid comparisons.\n    svint8_t vec_max_val = svdup_s8(SCHAR_MIN);\n    svuint64_t vec_max_idx = svdup_u64(0);\n\n    // Loop through the array in full vector lengths\n    for (i = 0; i + vl <= length; i += vl) {\n        // Create a full predicate for the current vector block\n        svbool_t pg = svptrue_b8();\n\n        // Load the current block of values and generate their corresponding indices\n        svint8_t current_vec_val = svld1_s8(pg, src + i);\n        svuint64_t current_vec_idx = svindex_u64(i, 1); // Generates i, i+1, i+2, ...\n\n        // Predicate for elements where current_vec_val is strictly greater than vec_max_val\n        svbool_t cmp_gt_pred = svcmpgt_s8(pg, current_vec_val, vec_max_val);\n\n        // Predicate for elements where current_vec_val is equal to vec_max_val\n        svbool_t cmp_eq_pred = svcmpeq_s8(pg, current_vec_val, vec_max_val);\n\n        // Update vec_max_val: take the element-wise maximum\n        vec_max_val = svmax_s8(pg, vec_max_val, current_vec_val);\n\n        // Update vec_max_idx:\n        // If current_vec_val was greater, update the index to current_vec_idx\n        vec_max_idx = svsel_u64(cmp_gt_pred, current_vec_idx, vec_max_idx);\n\n        // If current_vec_val was equal AND current_vec_idx is smaller (for first occurrence tie-breaking),\n        // then update the index to current_vec_idx.\n        svbool_t cmp_eq_and_idx_lt_pred = svand_b(cmp_eq_pred, svcmplt_u64(pg, current_vec_idx, vec_max_idx));\n        vec_max_idx = svsel_u64(cmp_eq_and_idx_lt_pred, current_vec_idx, vec_max_idx);\n    }\n\n    // Handle the tail (remaining elements that don't form a full vector)\n    if (i < length) {\n        // Create a predicate for the remaining elements\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load the tail elements and generate their corresponding indices\n        svint8_t current_vec_val = svld1_s8(pg, src + i);\n        svuint64_t current_vec_idx = svindex_u64(i, 1);\n\n        // Apply the same comparison and update logic as in the main loop\n        svbool_t cmp_gt_pred = svcmpgt_s8(pg, current_vec_val, vec_max_val);\n        svbool_t cmp_eq_pred = svcmpeq_s8(pg, current_vec_val, vec_max_val);\n\n        vec_max_val = svmax_s8(pg, vec_max_val, current_vec_val);\n        vec_max_idx = svsel_u64(cmp_gt_pred, current_vec_idx, vec_max_idx);\n        svbool_t cmp_eq_and_idx_lt_pred = svand_b(cmp_eq_pred, svcmplt_u64(pg, current_vec_idx, vec_max_idx));\n        vec_max_idx = svsel_u64(cmp_eq_and_idx_lt_pred, current_vec_idx, vec_max_idx);\n    }\n\n    // Reduce the vector results to a single scalar maximum value and its index.\n    // This involves iterating through the lanes of the final vectors.\n    int8_t temp_max_vals[vl];\n    size_t temp_max_idxs[vl];\n\n    // Store the vector contents into temporary arrays\n    svst1_s8(svptrue_b8(), temp_max_vals, vec_max_val);\n    svst1_u64(svptrue_b8(), (uint64_t*)temp_max_idxs, vec_max_idx); // Cast to uint64_t* for svst1_u64\n\n    // Initialize the final scalar result with the first lane's data.\n    // Since length > 0, at least one lane will contain valid data.\n    int8_t final_max_val = temp_max_vals[0];\n    size_t final_max_idx = temp_max_idxs[0];\n\n    // Iterate through the remaining lanes to find the overall maximum and its index.\n    for (size_t k = 1; k < vl; ++k) {\n        if (temp_max_vals[k] > final_max_val) {\n            final_max_val = temp_max_vals[k];\n            final_max_idx = temp_max_idxs[k];\n        } else if (temp_max_vals[k] == final_max_val) {\n            // Tie-breaking: if values are equal, choose the one with the smaller index (first occurrence).\n            if (temp_max_idxs[k] < final_max_idx) {\n                final_max_idx = temp_max_idxs[k];\n            }\n        }\n    }\n\n    return final_max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    // Loop predicate for 16-bit elements, ensuring operations only apply to valid elements within length.\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    do {\n        // 1. Load uint16_t data from source arrays using the current loop predicate.\n        svuint16_t vec1 = svld1(pg, src1 + i);\n        svuint16_t vec2 = svld1(pg, src2 + i);\n\n        // 2. Generate uint32_t indices for the current block of uint16_t elements.\n        // SVE vectors for uint16_t elements are twice as long as for uint32_t elements (svcntw() = 2 * svcntd()).\n        // We need to generate indices for each uint16_t element, but perform the mask operation with uint32_t.\n        // So, we generate two svuint32_t vectors of indices to cover all uint16_t elements in the current vector length.\n        svuint32_t indices_low_32 = svindex_u32(i, 1); // Indices for the first half of uint16_t elements\n        svuint32_t indices_high_32 = svindex_u32(i + svcntd(), 1); // Indices for the second half\n\n        // 3. Duplicate the mask value into a uint32_t vector.\n        svuint32_t mask_vec_32 = svdup_u32(mask);\n\n        // 4. Perform bitwise AND with the mask for both halves of indices.\n        // Use svptrue_b32() as the predicate for these operations to compute for all lanes\n        // within the 32-bit vector, as the loop predicate 'pg' will be applied later.\n        svuint32_t masked_low_32 = svand_u32_z(svptrue_b32(), indices_low_32, mask_vec_32);\n        svuint32_t masked_high_32 = svand_u32_z(svptrue_b32(), indices_high_32, mask_vec_32);\n\n        // 5. Generate 32-bit predicates based on the condition (masked_value != 0).\n        svbool_t pred_low_32 = svcmpne_u32(svptrue_b32(), masked_low_32, 0);\n        svbool_t pred_high_32 = svcmpne_u32(svptrue_b32(), masked_high_32, 0);\n\n        // 6. Convert the 32-bit predicates (true/false) into uint32_t vectors containing 1s (for true) or 0s (for false).\n        svuint32_t bool_low_32 = svsel_u32(pred_low_32, svdup_u32(1), svdup_u32(0));\n        svuint32_t bool_high_32 = svsel_u32(pred_high_32, svdup_u32(1), svdup_u32(0));\n\n        // 7. Narrow the uint32_t (1/0) vectors to uint16_t (1/0) vectors.\n        // This conversion is safe because the values are guaranteed to be either 0 or 1, which fit within uint16_t.\n        svuint16_t bool_low_16 = svcvt_u16_u32(bool_low_32);\n        svuint16_t bool_high_16 = svcvt_u16_u32(bool_high_32);\n\n        // 8. Combine the two uint16_t (1/0) vectors into a single svuint16_t vector.\n        // svcreate2_u16 concatenates the two input vectors: bool_low_16 forms the lower half,\n        // and bool_high_16 forms the upper half of the resulting svuint16_t vector.\n        svuint16_t combined_bool_16 = svcreate2_u16(bool_low_16, bool_high_16);\n\n        // 9. Generate the final 16-bit predicate from the combined uint16_t (1/0) vector.\n        // This predicate will have one bit for each uint16_t element, correctly reflecting\n        // the (index & mask) != 0 condition for each individual element.\n        svbool_t blend_predicate_16 = svcmpne_u16(pg, combined_bool_16, 0);\n\n        // 10. Blend the source vectors based on the generated 16-bit predicate.\n        // If blend_predicate_16 is true for a lane, take the value from vec1 (src1);\n        // otherwise, take the value from vec2 (src2).\n        svuint16_t result_vec = svsel_u16(blend_predicate_16, vec1, vec2);\n\n        // 11. Store the blended result to the destination array using the loop predicate.\n        svst1(pg, dst + i, result_vec);\n\n        // 12. Update the loop counter and the loop predicate for the next iteration.\n        i += svcntw(); // Increment by the number of 16-bit elements processed in this iteration.\n        pg = svwhilelt_b16(i, length);\n    } while (svany(pg)); // Continue looping as long as there are active lanes (elements left to process).\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register for uint16_t elements\n\n    // Loop while there are elements remaining to process\n    while (i < length) {\n        // Get the predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements within the array bounds.\n        pg = svwhilelt_b16(i, length);\n\n        // Load data from src1 and src2 into SVE vectors.\n        // The predicate 'pg' ensures that only active lanes are loaded.\n        svuint16_t vec_src1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec_src2 = svld1_u16(pg, src2 + i);\n\n        // Generate a vector of indices for the current chunk.\n        // For example, if i=0, this might be {0, 1, 2, 3, ...}\n        // Note: svindex_u16 generates uint16_t indices. If 'i' or 'length' can exceed 0xFFFF,\n        // these indices will wrap around. Similarly, svdup_u16 will truncate 'mask' if it exceeds 0xFFFF.\n        // This implementation assumes that for the purpose of the bitwise AND condition,\n        // the effective index and mask can be treated as uint16_t within the SVE vector lanes.\n        // If strict uint32_t arithmetic for (index & mask) is required for values > 0xFFFF,\n        // a more complex approach involving widening to uint32_t for calculation and then\n        // combining predicates would be necessary, which is not directly supported by simple SVE intrinsics.\n        svuint16_t indices = svindex_u16(i, 1);\n\n        // Broadcast the mask value to an SVE vector of uint16_t.\n        svuint16_t vec_mask = svdup_u16(mask);\n\n        // Perform the bitwise AND operation: (element's index & mask).\n        // The 'x' suffix indicates that inactive lanes (masked by 'pg') are not written to.\n        svuint16_t and_result = svand_u16_x(pg, indices, vec_mask);\n\n        // Create a boolean predicate based on the condition: (and_result != 0).\n        // This predicate will be true for elements where the condition is met, and false otherwise.\n        svbool_t condition_pred = svcmpne_u16(pg, and_result, 0);\n\n        // Select elements for the destination vector based on the condition predicate.\n        // If condition_pred is true for a lane, take the value from vec_src1; otherwise, take from vec_src2.\n        svuint16_t result = svsel_u16(condition_pred, vec_src1, vec_src2);\n\n        // Store the blended result into the destination array.\n        // The predicate 'pg' ensures that only active lanes are written to.\n        svst1_u16(pg, dst + i, result);\n\n        // Advance the loop counter by the number of elements processed in this vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    // Duplicate the mask value into an SVE vector of uint32_t elements.\n    svuint32_t v_mask = svdup_n_u32(mask);\n\n    // Loop through the arrays in chunks.\n    // We use svcntd() (number of uint32_t elements in a vector) as the stride\n    // because the index calculation (i & mask) requires uint32_t arithmetic.\n    // This means we process svcntd() uint16_t elements at a time.\n    while (i < length) {\n        // Create a predicate for the current chunk of uint32_t elements.\n        // This predicate determines which lanes are active based on the remaining length.\n        svbool_t pg_u32 = svwhilelt_b32(i, length);\n\n        // If no lanes are active, break the loop.\n        if (svptest_n(svptrue_b32(), pg_u32) == 0) {\n            break;\n        }\n\n        // Generate a vector of uint32_t indices for the current chunk.\n        // The indices start from 'i' and increment by 1 for each lane.\n        svuint32_t current_indices = svindex_u32(i, 1);\n\n        // Perform the bitwise AND operation (index & mask) for active lanes.\n        svuint32_t masked_indices = svand_u32_x(pg_u32, current_indices, v_mask);\n\n        // Create a predicate for selection: true if (masked_index != 0), false otherwise.\n        // This predicate is of type svbool_t (b32), meaning it has one bit per uint32_t lane.\n        svbool_t select_pred_u32 = svcmpne_n_u32(pg_u32, masked_indices, 0);\n\n        // Reinterpret the b32 predicate as a b16 predicate.\n        // This is crucial because the data elements (src1, src2, dst) are uint16_t,\n        // and svsel_u16 requires a b16 predicate.\n        // When reinterpreting b32 to b16, the bits of the b32 predicate are mapped\n        // to the lower half of the b16 predicate's bits. The upper half will be zero.\n        // This effectively means the predicate applies only to the first svcntd() uint16_t elements\n        // within a full svcntw() vector.\n        svbool_t select_pred_u16 = svreinterpret_b16_b32(select_pred_u32);\n\n        // Load uint16_t elements from src1 and src2 using the reinterpreted predicate.\n        // The predicate for loading/storing must match the element size (b16 for uint16_t).\n        // We use the reinterpreted predicate for loading as well, to ensure we only load\n        // the elements corresponding to the active uint32_t index lanes.\n        svuint16_t v_src1 = svld1_u16(select_pred_u16, src1 + i);\n        svuint16_t v_src2 = svld1_u16(select_pred_u16, src2 + i);\n\n        // Select elements based on the condition:\n        // If select_pred_u16 is true for a lane, take from v_src1; otherwise, take from v_src2.\n        svuint16_t v_dst = svsel_u16(select_pred_u16, v_src1, v_src2);\n\n        // Store the result to the destination array using the same predicate.\n        svst1_u16(select_pred_u16, dst + i, v_dst);\n\n        // Advance the index by the number of uint32_t elements processed in this iteration.\n        // This ensures correct progression for the uint32_t index calculation.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg_16;     // Predicate for 16-bit operations (loads, stores, selects)\n    svbool_t pg_32_lo;  // Predicate for the first half of 32-bit index operations\n    svbool_t pg_32_hi;  // Predicate for the second half of 32-bit index operations\n\n    // Get the number of 16-bit elements per SVE vector (VL/16)\n    const size_t svl_16 = svcntw();\n    // Get the number of 32-bit elements per SVE vector (VL/32)\n    const size_t svl_32 = svcntd();\n\n    // Duplicate the mask value into a 32-bit SVE vector once, as it's constant\n    const svuint32_t mask_vec = svdup_n_u32(mask);\n\n    // Loop through the arrays in chunks of svl_16 (the natural vector length for uint16_t).\n    // The svwhilelt_b16 predicate generator handles the main loop and the tail elements efficiently.\n    for (i = 0; i < length; i += svl_16) {\n        // Generate the predicate for the current 16-bit vector chunk.\n        // This predicate is true for elements within the array bounds and false otherwise.\n        pg_16 = svwhilelt_b16(i, length);\n\n        // Load 16-bit data vectors from src1 and src2.\n        // Inactive lanes (where pg_16 is false) will be loaded as zeros.\n        svuint16_t vec1 = svld1_u16(pg_16, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg_16, src2 + i);\n\n        // --- Generate 32-bit indices and the blending predicate ---\n        // Since the mask is uint32_t, index operations need to be performed on 32-bit values.\n        // A single svuint16_t vector (svl_16 elements) corresponds to two svuint32_t vectors\n        // (each with svl_32 elements, where svl_16 = 2 * svl_32).\n\n        // Generate the predicate for the first half of 32-bit indices.\n        pg_32_lo = svwhilelt_b32(i, length);\n        // Generate the first half of 32-bit indices (starting from 'i').\n        svuint32_t indices_lo = svindex_u32(i, 1);\n        // Apply the mask: (index & mask).\n        svuint32_t masked_indices_lo = svand_u32_x(pg_32_lo, indices_lo, mask_vec);\n        // Generate the selection predicate for the first half: (masked_index != 0).\n        svbool_t pred_lo = svcmpne_n_u32(pg_32_lo, masked_indices_lo, 0);\n\n        // Generate the predicate for the second half of 32-bit indices.\n        pg_32_hi = svwhilelt_b32(i + svl_32, length);\n        // Generate the second half of 32-bit indices (starting from 'i + svl_32').\n        svuint32_t indices_hi = svindex_u32(i + svl_32, 1);\n        // Apply the mask: (index & mask).\n        svuint32_t masked_indices_hi = svand_u32_x(pg_32_hi, indices_hi, mask_vec);\n        // Generate the selection predicate for the second half: (masked_index != 0).\n        svbool_t pred_hi = svcmpne_n_u32(pg_32_hi, masked_indices_hi, 0);\n\n        // Combine the two 32-bit predicates (pred_lo and pred_hi) into a single 16-bit predicate.\n        // svzip1_b interleaves the active lanes from the two source predicates,\n        // effectively creating a predicate for the narrower 16-bit elements.\n        svbool_t final_selection_predicate = svzip1_b(pred_lo, pred_hi);\n\n        // Select elements for the result vector.\n        // If final_selection_predicate is true for a lane, take from vec1 (src1).\n        // If final_selection_predicate is false for a lane, take from vec2 (src2).\n        // Inactive lanes (where pg_16 is false) in vec1 and vec2 are zeros,\n        // and these results will not be stored by svst1_u16.\n        svuint16_t result_vec = svsel_u16(final_selection_predicate, vec1, vec2);\n\n        // Store the result vector into the destination array.\n        // The pg_16 predicate ensures that only active lanes (within array bounds) are written.\n        svst1_u16(pg_16, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Get a predicate for the current vector length, processing uint16_t elements\n        pg = svwhilelt_b16(i, length);\n\n        // Check if any lanes are active\n        if (svptest_any(svptrue_b16(), pg)) {\n            // Load data from src1 and src2 using the predicate\n            svuint16_t vec_src1 = svld1(pg, src1 + i);\n            svuint16_t vec_src2 = svld1(pg, src2 + i);\n\n            // Generate a vector of indices (i, i+1, i+2, ...) as uint64_t\n            // This is necessary because 'i' is size_t and 'mask' is uint32_t,\n            // and the bitwise AND operation should handle potentially large indices.\n            svuint64_t vec_idx_u64 = svindex_u64(i, 1);\n\n            // Broadcast the mask value into a uint64_t vector\n            svuint64_t vec_mask_u64 = svdup_n_u64(mask);\n\n            // Perform bitwise AND operation on indices and mask\n            svuint64_t and_result_u64 = svand_u64(vec_idx_u64, vec_mask_u64);\n\n            // Create a blend predicate: true if (index & mask) != 0, false otherwise.\n            // The comparison is performed only for active lanes defined by 'pg'.\n            svbool_t blend_pg = svcmpne_n_u64(pg, and_result_u64, 0);\n\n            // Select elements: if blend_pg is true, take from vec_src1; otherwise, take from vec_src2.\n            svuint16_t vec_dst = svsel(blend_pg, vec_src1, vec_src2);\n\n            // Store the result to the destination array using the predicate\n            svst1(pg, dst + i, vec_dst);\n\n            // Increment the loop counter by the number of 16-bit elements processed in this vector\n            i += svcntw();\n        } else {\n            // No more active lanes, break the loop\n            break;\n        }\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // Required for uint32_t and size_t\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the array in chunks determined by the SVE vector length.\n    // The loop continues as long as there are elements remaining to process.\n    do {\n        // Generate a predicate 'pg' for the current vector chunk.\n        // `svwhilelt_b32(i, length)` creates a predicate where lanes are active\n        // as long as their corresponding index (starting from 'i') is less than 'length'.\n        // This handles both full vector processing and the tail end of the array.\n        pg = svwhilelt_b32(i, length);\n\n        // Check if any lanes are active in the predicate.\n        // If no lanes are active, it means all remaining elements have been processed,\n        // so we can break out of the loop.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of uint32_t from the source array 'src' using the predicate 'pg'.\n        // Data is loaded only for active lanes.\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n\n        // Calculate the population count (number of set bits) for each element\n        // in 'src_vec'. The operation is performed only on active lanes as per 'pg'.\n        svuint32_t dst_vec = svcnt_u32(pg, src_vec);\n\n        // Store the resulting vector 'dst_vec' to the destination array 'dst'\n        // using the predicate 'pg'. Only active lanes will write to memory.\n        svst1_u32(pg, dst + i, dst_vec);\n\n        // Increment the loop counter 'i' by the number of elements actually processed\n        // in this iteration. `svcntp_b32(svptrue_b32(), pg)` counts the number of\n        // true (active) elements in the predicate 'pg'. This correctly advances 'i'\n        // by the vector length for full vectors and by the remaining count for the tail.\n        i += svcntp_b32(svptrue_b32(), pg);\n\n    } while (true); // The loop continues indefinitely until explicitly broken.\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    // Loop through the array in chunks determined by the SVE vector length\n    for (; i < length; ) {\n        // Get a predicate for the current vector operation.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // from 'i' up to 'length - 1'. This handles the tail of the array automatically.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // If no lanes are active (i.e., we've processed all elements), break the loop.\n        // This check is important for correctness and efficiency, especially for small 'length'.\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break;\n        }\n\n        // Load a vector of uint32_t from the source array using the predicate.\n        // Only active lanes will load data.\n        svuint32_t vec_src = svld1_u32(pg, src + i);\n\n        // Calculate the population count (number of set bits) for each element\n        // in the loaded vector. The predicate ensures only active lanes are processed.\n        svuint32_t vec_popcount = svcnt_u32(pg, vec_src);\n\n        // Store the resulting population counts to the destination array using the predicate.\n        // Only active lanes will write data.\n        svst1_u32(pg, dst + i, vec_popcount);\n\n        // Advance the index by the number of 32-bit elements in an SVE vector.\n        // The predicate 'pg' ensures that operations only occur on valid elements,\n        // so we can always advance by the full vector length.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ) {\n        // Get a predicate for the current vector length, processing up to 'length' elements.\n        // svwhilelt_b32 generates a predicate that is true for elements from 'i' up to 'length - 1'.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of uint32_t elements from the source array.\n        // Only elements corresponding to true predicate lanes are loaded.\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n\n        // Calculate the population count (number of set bits) for each active element\n        // in the loaded vector.\n        svuint32_t popcount_vec = svcnt_u32(pg, src_vec);\n\n        // Store the resulting population count vector to the destination array.\n        // Only elements corresponding to true predicate lanes are stored.\n        svst1_u32(pg, dst + i, popcount_vec);\n\n        // Advance the loop counter by the number of elements processed in this iteration.\n        // svcntp_b32 returns the number of active elements in the predicate 'pg'.\n        i += svcntp_b32(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    // Loop through the arrays in chunks determined by the SVE vector length\n    for (i = 0; i < length; ) {\n        // Create a predicate for the current vector operation.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // where the current index 'i' is less than 'length'.\n        // This handles the tail end of the array automatically.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of uint32_t elements from the source array using the predicate.\n        // Only active elements (where pg is true) are loaded.\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n\n        // Calculate the population count (number of set bits) for each element\n        // in the loaded vector. The result is a vector of uint32_t.\n        svuint32_t popcount_vec = svcnt_u32(pg, src_vec);\n\n        // Store the resulting population count vector into the destination array\n        // using the same predicate.\n        svst1_u32(pg, dst + i, popcount_vec);\n\n        // Increment the loop counter by the number of elements processed in this iteration.\n        // svcntp_b32 counts the number of active elements in the predicate 'pg'.\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        svuint32_t popcount_vec = svcnt_u32(pg, src_vec);\n        svst1_u32(pg, dst + i, popcount_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        // Get the predicate for the current vector length\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load data from src1 and src2\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n\n        // Perform saturating addition\n        svuint16_t result = svqadd_u16(vec1, vec2);\n\n        // Store the result in dst\n        svst1_u16(pg, dst + i, result);\n\n        // Update loop variables\n        size_t elements_processed = svcntw(); // Number of 16-bit elements in a vector\n        i += elements_processed;\n        length -= svcntw(); // Decrement remaining length by the number of elements processed\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        // Get the predicate for the current vector length\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load data from src1 and src2\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n\n        // Perform saturating addition\n        svuint16_t result = svqadd_u16(vec1, vec2);\n\n        // Store the result in dst\n        svst1_u16(pg, dst + i, result);\n\n        // Update loop variables\n        size_t elements_processed = svcntw(); // Number of 16-bit elements in a vector\n        i += elements_processed;\n        length -= elements_processed;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < length) {\n        // Get the predicate for the current vector length\n        // This predicate will be true for elements within the bounds of 'length - i'\n        // and false for elements beyond that, handling the tail end of the array.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load elements from src1 into an SVE vector using the predicate\n        svuint16_t vec1 = svld1(pg, src1 + i);\n\n        // Load elements from src2 into an SVE vector using the predicate\n        svuint16_t vec2 = svld1(pg, src2 + i);\n\n        // Perform saturating addition of the two vectors\n        // svqadd_u16 performs unsigned 16-bit saturating addition.\n        svuint16_t result_vec = svqadd_u16(vec1, vec2);\n\n        // Store the result vector into the destination array using the predicate\n        svst1(pg, dst + i, result_vec);\n\n        // Increment the loop counter by the number of elements processed in this iteration.\n        // svcntw() returns the number of 16-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        // Get the number of 16-bit elements that fit in a vector\n        svcount_t vg = svcntw();\n\n        // Create a predicate for the current vector operation\n        // This predicate will be true for 'vg' elements or 'length' elements if 'length < vg'\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load data from src1 and src2 into SVE vectors using the predicate\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n\n        // Perform saturating addition of the two vectors\n        // svqadd_u16 performs unsigned saturating addition for 16-bit elements\n        svuint16_t result_vec = svqadd_u16(vec1, vec2);\n\n        // Store the result back to the destination array using the predicate\n        svst1_u16(pg, dst + i, result_vec);\n\n        // Update the loop counter and remaining length\n        i += vg;\n        length -= svcntp_b16(pg); // Decrement length by the actual number of elements processed\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while the predicate is active (i.e., there are still elements to process)\n    // svwhilelt_b16 generates a predicate for 16-bit elements based on the remaining length.\n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n\n        // Load vector from src1\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n\n        // Load vector from src2\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n\n        // Perform saturating addition: result = (vec1 + vec2) clamped to UINT16_MAX\n        svuint16_t result = svadd_sat_u16(vec1, vec2);\n\n        // Store the result into dst\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize C to zeros.\n    // For large m*p, this initialization could also be vectorized for better performance,\n    // but a scalar loop is acceptable for correctness and simplicity here.\n    for (size_t i = 0; i < m * p; ++i) {\n        C[i] = 0.0;\n    }\n\n    // Pre-calculate constant vectors for range checks to avoid redundant computations\n    // inside the inner loops.\n    svfloat64_t neg100_vec = svdup_n_f64(-100.0);\n    svfloat64_t pos100_vec = svdup_n_f64(100.0);\n\n    // Loop over rows of matrix A (and C)\n    for (size_t i = 0; i < m; ++i) {\n        // Loop over columns of matrix B (and C). This loop is vectorized using SVE.\n        for (size_t j = 0; j < p; ) {\n            // Generate a predicate 'pg' for the current vector segment.\n            // This predicate handles the \"tail\" elements where (j + vector_length) might exceed p.\n            // Only active lanes (where pg is true) will perform operations.\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Load the current block of C elements (C[i][j] to C[i][j+vl-1]).\n            // C_vec will accumulate the sum for this block.\n            svfloat64_t C_vec = svld1(pg, &C[i * p + j]);\n\n            // Inner loop for summation over k (columns of A / rows of B)\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k]; // Scalar value A[i][k]\n\n                // Check if a_val is within the range [-100, 100].\n                // This predicate applies uniformly to all elements in the current vector operation.\n                svbool_t a_in_range_scalar_pred = svptrue_b64(); // Assume true initially\n                if (a_val < -100.0 || a_val > 100.0) {\n                    // If A[i][k] is out of range, no contribution from this k for any j.\n                    a_in_range_scalar_pred = svpfalse_b64();\n                }\n\n                // Load a vector of B[k][j] values (B[k][j] to B[k][j+vl-1]).\n                svfloat64_t B_vec = svld1(pg, &B[k * p + j]);\n\n                // Create a vector where all elements are a_val, for vector multiplication.\n                svfloat64_t A_scalar_vec = svdup_n_f64(a_val);\n\n                // Check if B_vec elements are within the range [-100, 100].\n                // These predicates are lane-specific, meaning each element of B_vec is checked independently.\n                svbool_t B_in_range_pred_low = svcmpge(pg, B_vec, neg100_vec);\n                svbool_t B_in_range_pred_high = svcmple(pg, B_vec, pos100_vec);\n                svbool_t B_in_range_pred = svand_b(B_in_range_pred_low, B_in_range_pred_high);\n\n                // Combine all predicates to determine which lanes contribute to the sum:\n                // 1. 'pg': Ensures we only process valid lanes for the current vector block (j to j+vl-1).\n                // 2. 'a_in_range_scalar_pred': Ensures A[i][k] is in range. If false, all lanes for this k are masked out.\n                // 3. 'B_in_range_pred': Ensures B[k][j+x] is in range for each specific lane x.\n                svbool_t combined_pred = svand_b(pg, svand_b(a_in_range_scalar_pred, B_in_range_pred));\n\n                // Perform masked multiply-add: C_vec += A_scalar_vec * B_vec.\n                // Only lanes where 'combined_pred' is true will be updated.\n                // For inactive lanes (where combined_pred is false), C_vec remains unchanged,\n                // effectively skipping the sum for out-of-range elements.\n                C_vec = svmla_f64(combined_pred, C_vec, A_scalar_vec, B_vec);\n            }\n            // Store the accumulated result back to C.\n            svst1(pg, &C[i * p + j], C_vec);\n\n            // Advance j by the number of elements processed in this vector.\n            // svcntd() returns the number of 64-bit (double) elements in an SVE vector.\n            j += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Define the range bounds as SVE vectors. These can be initialized once.\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    // Get the vector length for doubles (number of doubles per vector).\n    // This value is dynamic and depends on the SVE implementation at runtime.\n    size_t svl = svcntd();\n\n    // Loop over rows of matrix A (and C).\n    for (size_t i = 0; i < m; ++i) {\n        // Loop over columns of matrix B (and C), processing 'svl' elements at a time.\n        for (size_t k = 0; k < p; k += svl) {\n            // Create a predicate for the current vector chunk of C.\n            // This predicate ensures that operations only apply to valid elements\n            // when 'k + svl' exceeds 'p' (handling the tail elements).\n            svbool_t pg = svwhilelt_b64(k, p);\n\n            // Initialize an accumulator vector for the current C[i][k...k+svl-1] elements.\n            // All elements are initialized to 0.0, as C is a sum of products.\n            svfloat64_t c_vec = svdup_f64(0.0);\n\n            // Inner loop for the common dimension 'j'. This loop performs the dot product\n            // for the current C[i][k...k+svl-1] elements.\n            for (size_t j = 0; j < n; ++j) {\n                // Load the scalar A[i][j] element.\n                // Matrix A is stored in row-major order: A[row * num_cols_A + col].\n                double a_val = A[i * n + j];\n\n                // Load a vector of B[j][k...k+svl-1] elements.\n                // Matrix B is stored in row-major order: B[row * num_cols_B + col].\n                // For a fixed 'j', we load a contiguous block from B's j-th row starting at column 'k'.\n                svfloat64_t b_vec = svld1(pg, &B[j * p + k]);\n\n                // Replicate the scalar 'a_val' into an SVE vector.\n                // This creates a vector where all active lanes contain the same 'a_val'.\n                svfloat64_t a_vec = svdup_f64(a_val);\n\n                // Check if 'a_val' is within the range [-100, 100].\n                // Since 'a_vec' has the same value in all active lanes, 'a_in_range' will be\n                // either all true or all false for the active lanes defined by 'pg'.\n                svbool_t a_in_range = svcmpge(pg, a_vec, lower_bound); // Check if a_vec >= -100.0\n                a_in_range = svand_b(a_in_range, svcmple(pg, a_vec, upper_bound)); // Check if a_vec <= 100.0\n\n                // Check if each element in 'b_vec' is within the range [-100, 100].\n                // 'b_in_range' is a predicate vector where each lane corresponds to an element in 'b_vec'.\n                svbool_t b_in_range = svcmpge(pg, b_vec, lower_bound); // Check if b_vec >= -100.0\n                b_in_range = svand_b(b_in_range, svcmple(pg, b_vec, upper_bound)); // Check if b_vec <= 100.0\n\n                // Combine predicates: a product term A[i][j] * B[j][k'] is included in the sum\n                // only if both A[i][j] AND B[j][k'] are within the specified range [-100, 100].\n                svbool_t both_in_range = svand_b(a_in_range, b_in_range);\n\n                // Perform a Fused Multiply-Add (FMA) operation.\n                // For each lane 'l':\n                // If 'both_in_range[l]' is true, then c_vec[l] = c_vec[l] + (a_vec[l] * b_vec[l]).\n                // If 'both_in_range[l]' is false, c_vec[l] remains unchanged (effectively adding 0).\n                c_vec = svmla_f64(c_vec, both_in_range, a_vec, b_vec);\n            }\n            // Store the accumulated result vector into the destination matrix C.\n            // Matrix C is stored in row-major order: C[row * num_cols_C + col].\n            svst1(pg, &C[i * p + k], c_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Define the range bounds as SVE vectors\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    // Loop over rows of C (and A)\n    for (size_t i = 0; i < m; ++i) {\n        // Loop over columns of C (and B), processing in SVE vector chunks\n        for (size_t j = 0; j < p; ) {\n            // Get the predicate for the current vector chunk.\n            // This predicate ensures we only process up to 'p' columns.\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize the accumulator vector for the current C[i][j] block to zeros.\n            svfloat64_t C_acc_vec = svdup_f64(0.0);\n\n            // Loop over the inner dimension 'k'\n            for (size_t k = 0; k < n; ++k) {\n                // Load the scalar element A[i][k]\n                double val_A_scalar = A[i * n + k];\n\n                // Check if val_A_scalar is within the range [-100, 100].\n                // Create a predicate where all active lanes are true if scalar is in range,\n                // and all active lanes are false if scalar is out of range.\n                svbool_t A_in_range_scalar_pred = svdup_sve_as_b(val_A_scalar >= -100.0 && val_A_scalar <= 100.0);\n\n                // Load the vector of B[k][j] elements.\n                // Use 'pg' to ensure only valid elements within 'p' are loaded.\n                svfloat64_t val_B_vec = svld1_f64(pg, &B[k * p + j]);\n\n                // Check if elements of val_B_vec are within the range [-100, 100].\n                // This predicate is per-lane, based on 'pg'.\n                svbool_t B_in_range_pred = svand_b(svcmpge_f64(pg, val_B_vec, lower_bound),\n                                                   svcmple_f64(pg, val_B_vec, upper_bound));\n\n                // Combine the predicates: a product is valid only if both A[i][k] and B[k][j] are in range.\n                // The 'A_in_range_scalar_pred' applies to all lanes of the current vector operation.\n                // 'svand_b' combines the two predicates.\n                svbool_t combined_pred = svand_b(A_in_range_scalar_pred, B_in_range_pred);\n\n                // Broadcast A[i][k] to a vector for multiplication.\n                svfloat64_t val_A_vec = svdup_f64(val_A_scalar);\n\n                // Perform multiplication:\n                // svmul_f64_z(predicate, operand1, operand2) computes operand1 * operand2\n                // for lanes where 'predicate' is true, and 0.0 for lanes where 'predicate' is false.\n                // This correctly handles the \"skipping summing elements\" requirement.\n                svfloat64_t product_vec = svmul_f64_z(combined_pred, val_A_vec, val_B_vec);\n\n                // Accumulate the products into C_acc_vec.\n                // svadd_f64_x(predicate, passthrough, operand1, operand2) adds operand1 and operand2\n                // for lanes where 'predicate' is true, and keeps 'passthrough' for lanes where 'predicate' is false.\n                // Here, 'pg' is used as the predicate to ensure we only update lanes within the 'p' boundary.\n                // Since 'product_vec' already contains 0.0 for out-of-range elements (due to _z suffix),\n                // we can simply add it to the accumulator.\n                C_acc_vec = svadd_f64_x(pg, C_acc_vec, product_vec);\n            }\n\n            // Store the accumulated result for the current C[i][j] block back to memory.\n            // Use 'pg' to ensure only valid elements within 'p' are stored.\n            svst1_f64(pg, &C[i * p + j], C_acc_vec);\n\n            // Increment 'j' by the number of elements processed in this vector chunk.\n            j += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Define constants for range check once\n    // svptrue_b64() creates a predicate with all lanes active.\n    svbool_t pg_all = svptrue_b64(); \n    sv_d_t sv_low_bound = svdup_f64(pg_all, -100.0);\n    sv_d_t sv_high_bound = svdup_f64(pg_all, 100.0);\n\n    // Get the number of double-precision floating-point elements per SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    size_t sv_len = svcntd(); \n\n    // Outer loop iterates over rows of matrix A (and C)\n    for (size_t i = 0; i < m; ++i) {\n        // Initialize the current row of matrix C to zeros.\n        // This is necessary because we are accumulating sums.\n        size_t j_init = 0;\n        // Vectorized initialization for full SVE vectors\n        for (; j_init + sv_len <= p; j_init += sv_len) {\n            svst1_f64(pg_all, &C[i * p + j_init], svdup_f64(pg_all, 0.0));\n        }\n        // Scalar initialization for remaining elements (tail)\n        for (; j_init < p; ++j_init) {\n            C[i * p + j_init] = 0.0;\n        }\n\n        // Middle loop iterates over columns of matrix A (and rows of matrix B)\n        for (size_t k = 0; k < n; ++k) {\n            // Get the scalar element A[i][k]\n            double val_A_scalar = A[i * n + k];\n\n            // Check if A[i][k] is within the specified range [-100, 100].\n            // If it's outside the range, skip this 'k' iteration entirely,\n            // as no products involving this A[i][k] should contribute to the sum.\n            if (!(val_A_scalar >= -100.0 && val_A_scalar <= 100.0)) {\n                continue; \n            }\n\n            // Duplicate the scalar A[i][k] value into all lanes of an SVE vector.\n            // This allows it to be multiplied with a vector of B elements.\n            sv_d_t sv_A_val_dup = svdup_f64(pg_all, val_A_scalar);\n\n            // Inner loop iterates over columns of matrix B (and C)\n            size_t j = 0;\n            for (; j + sv_len <= p; j += sv_len) {\n                // Use a full predicate for the main loop iterations.\n                svbool_t pg = pg_all; \n\n                // Load a vector of elements from row 'k' of matrix B, starting at B[k][j].\n                // These elements are contiguous in memory.\n                sv_d_t sv_B_val = svld1_f64(pg, &B[k * p + j]);\n\n                // Load the current partial sums for row 'i' of matrix C, starting at C[i][j].\n                // These elements are also contiguous.\n                sv_d_t sv_C_val = svld1_f64(pg, &C[i * p + j]);\n\n                // Perform range checks for the loaded B elements.\n                // svcge_f64: greater than or equal\n                // svcmple_f64: less than or equal\n                svbool_t pred_B_ge_low = svcge_f64(pg, sv_B_val, sv_low_bound);\n                svbool_t pred_B_le_high = svcmple_f64(pg, sv_B_val, sv_high_bound);\n                // Combine predicates: an element is in range if it's >= low AND <= high.\n                svbool_t pred_B_in_range = svand_b64(pred_B_ge_low, pred_B_le_high);\n\n                // Perform masked fused multiply-add (FMA).\n                // svmla_f64(acc, pred, op1, op2) computes acc += (pred ? op1 * op2 : 0.0).\n                // The 'pred_B_in_range' acts as a mask: only if a B element is in range,\n                // its corresponding product (A[i][k] * B[k][j]) is added to C[i][j].\n                // The 'pg' argument is the governing predicate, ensuring only active lanes are processed.\n                sv_C_val = svmla_f64(sv_C_val, pred_B_in_range, sv_A_val_dup, sv_B_val);\n\n                // Store the updated partial sums back to matrix C.\n                svst1_f64(pg, &C[i * p + j], sv_C_val);\n            }\n\n            // Handle remaining elements (tail loop) for 'j' when 'p' is not a multiple of sv_len.\n            if (j < p) {\n                // svwhilelt_b64 generates a predicate for the remaining elements.\n                // It sets lanes to true as long as the current index 'j' is less than 'p'.\n                svbool_t pg_tail = svwhilelt_b64(j, p);\n\n                sv_d_t sv_B_val = svld1_f64(pg_tail, &B[k * p + j]);\n                sv_d_t sv_C_val = svld1_f64(pg_tail, &C[i * p + j]);\n\n                svbool_t pred_B_ge_low = svcge_f64(pg_tail, sv_B_val, sv_low_bound);\n                svbool_t pred_B_le_high = svcmple_f64(pg_tail, sv_B_val, sv_high_bound);\n                svbool_t pred_B_in_range = svand_b64(pred_B_ge_low, pred_B_le_high);\n\n                sv_C_val = svmla_f64(sv_C_val, pred_B_in_range, sv_A_val_dup, sv_B_val);\n                svst1_f64(pg_tail, &C[i * p + j], sv_C_val);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            svbool_t pg;\n            size_t k = 0;\n            while (k < n) {\n                pg = svwhilelt_b64(k, n);\n\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n\n                svuint64_t k_indices = svindex_u64(k, 1);\n                svuint64_t b_offsets = svmul_n_u64(k_indices, p);\n                b_offsets = svadd_n_u64(b_offsets, j);\n                svfloat64_t b_vec = svld1_gather_u64index_f64(pg, B, b_offsets);\n\n                svbool_t a_in_range_lower = svcmpge_n_f64(pg, a_vec, -100.0);\n                svbool_t a_in_range_upper = svcmple_n_f64(pg, a_vec, 100.0);\n                svbool_t a_in_range = svand_b(a_in_range_lower, a_in_range_upper);\n\n                svbool_t b_in_range_lower = svcmpge_n_f64(pg, b_vec, -100.0);\n                svbool_t b_in_range_upper = svcmple_n_f64(pg, b_vec, 100.0);\n                svbool_t b_in_range = svand_b(b_in_range_lower, b_in_range_upper);\n\n                svbool_t valid_elements_pg = svand_b(a_in_range, b_in_range);\n\n                svfloat64_t prod_vec = svmul_f64_m(svdup_f64(0.0), valid_elements_pg, a_vec, b_vec);\n\n                sum_vec = svadd_f64(sum_vec, prod_vec);\n\n                k += svcntd();\n            }\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements using SVE vector operations\n    // svwhilelt_b64 generates a predicate that is true for elements\n    // where the current index 'i' is less than 'total_elements'.\n    // This handles both full vectors and the tail elements.\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load vector from A\n        svint64_t vec_a = svld1_s64(pg, &A[i]);\n        // Load vector from B\n        svint64_t vec_b = svld1_s64(pg, &B[i]);\n\n        // Perform element-wise addition\n        svint64_t vec_c = svadd_s64(vec_a, vec_b);\n\n        // Store the result in C\n        svst1_s64(pg, &C[i], vec_c);\n\n        // Increment the index by the number of 64-bit elements in an SVE vector\n        i += svcntd();\n        // Update the predicate for the next iteration\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop while 'i' is less than the total number of elements\n    // The loop increments by the number of 64-bit elements in an SVE vector (svcntd())\n    for (i = 0; i < total_elements; ) {\n        // Get a predicate for the current vector length.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the tensor, especially for the last partial vector.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of 64-bit integers from tensor A\n        svint64_t va = svld1_s64(pg, &A[i]);\n\n        // Load a vector of 64-bit integers from tensor B\n        svint64_t vb = svld1_s64(pg, &B[i]);\n\n        // Perform element-wise addition of the two vectors\n        svint64_t vc = svadd_s64(pg, va, vb);\n\n        // Store the resulting vector into tensor C\n        svst1_s64(pg, &C[i], vc);\n\n        // Increment the index by the number of 64-bit elements processed in this iteration.\n        // svcntd() returns the current vector length for 64-bit elements.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the elements in steps of the SVE vector length\n    // The predicate 'pg' handles the tail elements where the remaining count is less than the vector length.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Create a predicate for the current vector operation.\n        // It ensures that operations only apply to valid elements within the bounds.\n        pg = svwhilelt_b64(i, total_elements);\n\n        // Load vector from tensor A\n        svint64_t vec_A = svld1_s64(pg, &A[i]);\n\n        // Load vector from tensor B\n        svint64_t vec_B = svld1_s64(pg, &B[i]);\n\n        // Perform element-wise addition\n        svint64_t vec_C = svadd_s64(vec_A, vec_B);\n\n        // Store the result vector into tensor C\n        svst1_s64(pg, &C[i], vec_C);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Get the number of 64-bit elements per SVE vector\n    // This value is determined at runtime by the SVE implementation.\n    size_t sv_len = svcntd();\n\n    // Loop through the elements, processing 'sv_len' elements at a time.\n    // The svwhilelt_b64 predicate handles the loop termination and\n    // ensures that only valid elements are processed, especially for the\n    // last (partial) vector.\n    for (i = 0; i < total_elements; i += sv_len) {\n        // Create a predicate for the current vector operation.\n        // This predicate is true for elements from 'i' up to 'total_elements - 1'\n        // within the current vector length.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of 64-bit integers from tensor A\n        svint64_t vec_a = svld1_s64(pg, &A[i]);\n\n        // Load a vector of 64-bit integers from tensor B\n        svint64_t vec_b = svld1_s64(pg, &B[i]);\n\n        // Perform element-wise addition of the two vectors\n        svint64_t vec_c = svadd_s64(pg, vec_a, vec_b);\n\n        // Store the resulting vector into tensor C\n        svst1_s64(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements using SVE vectors\n    // svcntd() returns the number of 64-bit elements in an SVE vector.\n    // svwhilelt_b64 generates a predicate for elements where the current index\n    // is less than the total_elements, handling the tail of the array.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load vectors from source tensors A and B\n        svint64_t vec_A = svld1_s64(pg, &A[i]);\n        svint64_t vec_B = svld1_s64(pg, &B[i]);\n\n        // Perform element-wise addition\n        // _x variant ensures that the operation is performed only on active lanes\n        svint64_t vec_C = svadd_s64_x(pg, vec_A, vec_B);\n\n        // Store the result in the destination tensor C\n        svst1_s64(pg, &C[i], vec_C);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < length) {\n        // Get a predicate for the current vector length, processing up to 'length' elements\n        // svwhilelt_b32 generates a predicate for 32-bit elements (float)\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load data from src1 and src2 into SVE float vectors\n        // svld1 loads elements based on the predicate 'pg'\n        svfloat32_t v_src1 = svld1(pg, &src1[i]);\n        svfloat32_t v_src2 = svld1(pg, &src2[i]);\n\n        // Perform element-wise addition of the two vectors\n        // svadd_f32_x performs addition under the control of predicate 'pg'\n        svfloat32_t v_sum = svadd_f32_x(pg, v_src1, v_src2);\n\n        // Round the sum to the nearest integer, ties to even\n        // svrintn_f32_x performs rounding under the control of predicate 'pg'\n        svfloat32_t v_rounded = svrintn_f32_x(pg, v_sum);\n\n        // Store the rounded result into the destination array\n        // svst1 stores elements based on the predicate 'pg'\n        svst1(pg, &dst[i], v_rounded);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this iteration\n        // svcntw() returns the number of 32-bit elements (words) in an SVE vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load vectors from src1 and src2\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n\n        // Perform element-wise addition\n        svfloat32_t sum_vec = svadd_f32(pg, vec1, vec2);\n\n        // Round the result to the nearest integer\n        // svrintn_f32 rounds to the nearest integer, with ties to even.\n        svfloat32_t rounded_vec = svrintn_f32(pg, sum_vec);\n\n        // Store the result in the destination array\n        svst1_f32(pg, dst + i, rounded_vec);\n\n        // Move to the next chunk of elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Get the predicate for the current vector operation.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // where the current index 'i' is less than 'length'.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of float values from src1 using the predicate.\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n\n        // Load a vector of float values from src2 using the predicate.\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n\n        // Perform element-wise addition of the two vectors.\n        svfloat32_t sum = svadd_f32(pg, vec1, vec2);\n\n        // Round the result to the nearest integer.\n        // svrintn_f32 rounds to the nearest integer, with ties to even.\n        svfloat32_t rounded_sum = svrintn_f32(pg, sum);\n\n        // Store the rounded result into the destination array.\n        svst1_f32(pg, dst + i, rounded_sum);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        // svcntw() returns the number of 32-bit elements in a vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while there are still elements to process\n    do {\n        // Get a predicate for the current vector length, active for elements within bounds\n        pg = svwhilelt_b32(i, length);\n\n        // Load elements from src1 and src2 into SVE vectors using the predicate\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n\n        // Perform element-wise addition\n        svfloat32_t sum = svadd_f32(vec1, vec2);\n\n        // Round the sum to the nearest integer (ties to even)\n        svfloat32_t rounded_result = svrintn_f32(sum);\n\n        // Store the rounded result into the destination array\n        svst1_f32(pg, &dst[i], rounded_result);\n\n        // Increment the loop counter by the number of elements processed in this iteration\n        i += svcntw();\n\n    } while (svsvcnt_b32(pg) > 0); // Continue as long as the predicate was active for at least one element\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Get the predicate for the current vector operation\n        // This handles the tail elements correctly by setting inactive lanes.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load elements from src1 and src2 into SVE float vectors\n        svfloat32_t vec1 = svld1(pg, src1 + i);\n        svfloat32_t vec2 = svld1(pg, src2 + i);\n\n        // Perform element-wise addition\n        svfloat32_t sum_vec = svadd_f32_x(pg, vec1, vec2);\n\n        // Round the result to the nearest integer (ties to even)\n        svfloat32_t rounded_vec = svrintn_f32_x(pg, sum_vec);\n\n        // Store the rounded result into the destination array\n        svst1(pg, dst + i, rounded_vec);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        // svcntw() returns the number of 32-bit elements (floats) in a full SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    // Constant vector for -1.0f (default value)\n    svfloat32_t sv_minus_one = svdup_f32(-1.0f);\n    // Constant vector for 50.0f (comparison threshold)\n    svfloat32_t sv_fifty = svdup_f32(50.0f);\n\n    while (i < length) {\n        // Get the predicate for the current vector length\n        // This predicate controls which lanes are active based on the remaining length\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load elements from src1 and src2 into SVE vectors\n        svfloat32_t s1_vec = svld1(pg, src1 + i);\n        svfloat32_t s2_vec = svld1(pg, src2 + i);\n\n        // Condition 1: abs(src1[i] - src2[i]) <= 50.0f\n        // Calculate the difference\n        svfloat32_t diff = svsub_f32_x(pg, s1_vec, s2_vec);\n        // Calculate the absolute difference\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n        // Compare absolute difference with 50.0f\n        svbool_t cond1_pred = svacle_f32(pg, abs_diff, sv_fifty); // abs_diff <= 50.0f\n\n        // Condition 2: index is a multiple of 2 (i % 2 == 0)\n        // Generate a vector of indices starting from 'i'\n        svuint32_t indices = svindex_u32(i, 1); // Generates i, i+1, i+2, ...\n        // Calculate (index % 2) using bitwise AND with 1\n        svuint32_t indices_mod_2 = svand_n_u32_x(pg, indices, 1);\n        // Check if (index % 2) is equal to 0\n        svbool_t cond2_pred = svcmpeq_n_u32(pg, indices_mod_2, 0);\n\n        // Combine both conditions using logical AND\n        svbool_t combined_pred = svand_b(cond1_pred, cond2_pred);\n\n        // Perform the element-wise multiplication\n        svfloat32_t mul_result = svmul_f32_x(pg, s1_vec, s2_vec);\n        // Round the result up toward positive infinity (ceil)\n        svfloat32_t rounded_result = svceil_f32_x(pg, mul_result);\n\n        // Select the final result based on the combined predicate:\n        // If combined_pred is true for a lane, use rounded_result; otherwise, use -1.0f\n        svfloat32_t final_result = svsel_f32(combined_pred, rounded_result, sv_minus_one);\n\n        // Store the final results into the destination array\n        svst1(pg, dst + i, final_result);\n\n        // Increment the loop counter by the number of elements processed in this iteration\n        i += svcnt_f32();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    // Duplicate scalar constants into SVE vectors\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n    svfloat32_t v_neg_one = svdup_f32(-1.0f);\n    svuint32_t v_one_u32 = svdup_u32(1);   // For checking LSB for even/odd\n    svuint32_t v_zero_u32 = svdup_u32(0);  // For comparison with LSB\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        // Get the predicate for the current vector chunk\n        // This predicate ensures we only process valid elements up to 'length'\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load data from source arrays\n        svfloat32_t v_src1 = svld1(pg, &src1[i]);\n        svfloat32_t v_src2 = svld1(pg, &src2[i]);\n\n        // Condition 1: abs(src1[i] - src2[i]) <= 50.0f\n        svfloat32_t v_diff = svsub_f32(v_src1, v_src2);\n        svfloat32_t v_abs_diff = svabs_f32(v_diff);\n        svbool_t pg_cond1 = svcmple_f32(pg, v_abs_diff, v_fifty); // abs_diff <= 50.0f\n\n        // Condition 2: index is a multiple of 2 (i.e., index % 2 == 0)\n        // Generate a vector of indices for the current chunk: [i, i+1, i+2, ...]\n        svuint32_t v_indices = svindex_u32(i, 1);\n        // Check if the least significant bit is 0 (equivalent to % 2 == 0)\n        svuint32_t v_lsb = svand_u32(v_indices, v_one_u32);\n        svbool_t pg_cond2 = svcmpeq_u32(pg, v_lsb, v_zero_u32);\n\n        // Combine both conditions using logical AND\n        svbool_t pg_final = svand_b(pg_cond1, pg_cond2);\n\n        // Calculate result for elements that meet the conditions: ceil(src1[i] * src2[i])\n        svfloat32_t v_mul_result = svmul_f32(v_src1, v_src2);\n        svfloat32_t v_ceil_result = svceil_f32(v_mul_result);\n\n        // Select the final result: v_ceil_result if pg_final is true, else v_neg_one\n        svfloat32_t v_dst_val = svsel(pg_final, v_ceil_result, v_neg_one);\n\n        // Store the result into the destination array\n        svst1(pg, &dst[i], v_dst_val);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n\n    // Duplicate scalar values into SVE vectors once outside the loop\n    svfloat32_t v_neg_one = svdup_f32(-1.0f);\n    svfloat32_t v_50 = svdup_f32(50.0f);\n    svuint32_t v_one_u32 = svdup_u32(1);   // For (index & 1) check\n    svuint32_t v_zero_u32 = svdup_u32(0);  // For (index & 1) == 0 check\n\n    while (i < length) {\n        // Get the predicate for the current vector length, handling the tail\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load data from source arrays\n        svfloat32_t v_src1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v_src2 = svld1_f32(pg, src2 + i);\n\n        // --- Condition 1: abs(src1[i] - src2[i]) <= 50.0f ---\n        // Calculate difference: (src1 - src2)\n        svfloat32_t v_diff = svsub_f32_x(pg, v_src1, v_src2);\n        // Calculate absolute difference\n        svfloat32_t v_abs_diff = svabs_f32_x(pg, v_diff);\n        // Compare absolute difference with 50.0f\n        svbool_t cond1_pred = svcle_f32(pg, v_abs_diff, v_50);\n\n        // --- Condition 2: index is a multiple of 2 (i.e., i % 2 == 0) ---\n        // Generate a vector of indices starting from 'i'\n        svuint32_t v_indices = svindex_u32(i, 1);\n        // Check if (index & 1) == 0, which is equivalent to index % 2 == 0\n        svuint32_t v_indices_and_1 = svand_u32_x(pg, v_indices, v_one_u32);\n        svbool_t cond2_pred = svcmpeq_u32(pg, v_indices_and_1, v_zero_u32);\n\n        // --- Combine both conditions ---\n        // The resulting predicate will be true only for lanes that are active (within 'length')\n        // AND satisfy both condition 1 AND condition 2.\n        svbool_t final_cond_pred = svand_b(cond1_pred, cond2_pred);\n\n        // --- Calculate result if conditions met: (src1 * src2) rounded up ---\n        // Perform multiplication\n        svfloat32_t v_mul_result = svmul_f32_x(pg, v_src1, v_src2);\n        // Round up toward positive infinity\n        svfloat32_t v_ceil_result = svceil_f32_x(pg, v_mul_result);\n\n        // --- Select final values for destination array ---\n        // If final_cond_pred is true for a lane, select v_ceil_result;\n        // otherwise (conditions not met), select v_neg_one (-1.0f).\n        svfloat32_t v_dst_val = svsel_f32(final_cond_pred, v_ceil_result, v_neg_one);\n\n        // Store the results to the destination array\n        svst1_f32(pg, dst + i, v_dst_val);\n\n        // Increment loop counter by the number of elements processed in this vector\n        i += svcnt_f32();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n\n    // Constants for SVE operations\n    svfloat32_t threshold_vec = svdup_f32(50.0f); // Vector with all elements set to 50.0f\n    svfloat32_t neg_one_vec = svdup_f32(-1.0f);   // Vector with all elements set to -1.0f\n    svuint32_t lsb_mask = svdup_u32(1);           // Mask for checking the least significant bit (LSB)\n    svuint32_t zero_u32_vec = svdup_u32(0);       // Vector with all elements set to 0 (for LSB comparison)\n\n    // Loop through the arrays in chunks determined by the SVE vector length.\n    // svwhilelt_b32 generates a predicate 'pg' that is true for elements\n    // within the array bounds (i < length) and false otherwise.\n    // The loop continues as long as 'i' is less than 'length'.\n    for (; i < length; ) {\n        // Get the predicate for the current chunk.\n        // 'pg' will have active lanes for elements from 'i' up to 'length-1'.\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Get the number of active elements in the current predicate.\n        // This is used to correctly increment 'i' for the next iteration.\n        size_t active_elements = svcntp_b32(pg);\n        if (active_elements == 0) {\n            break; // No more active elements, exit loop.\n        }\n\n        // 1. Load data for active lanes from source arrays.\n        svfloat32_t s1_vec = svld1_f32(pg, &src1[i]);\n        svfloat32_t s2_vec = svld1_f32(pg, &src2[i]);\n\n        // 2. Condition 1: abs(src1[i] - src2[i]) <= 50.0f\n        // Calculate difference for active lanes. Inactive lanes are unchanged.\n        svfloat32_t diff_vec = svsub_f32_x(pg, s1_vec, s2_vec);\n        // Calculate absolute difference for active lanes.\n        svfloat32_t abs_diff_vec = svabs_f32_x(pg, diff_vec);\n        // Compare absolute difference with 50.0f for active lanes.\n        // 'cond1_pred' will be true for lanes where the condition holds.\n        svbool_t cond1_pred = svcle_f32(pg, abs_diff_vec, threshold_vec);\n\n        // 3. Condition 2: index is a multiple of 2 (i % 2 == 0)\n        // Generate a vector of current indices: [i, i+1, i+2, ...]\n        svuint32_t current_indices = svindex_u32(i, 1);\n        // Extract the least significant bit (LSB) for active lanes.\n        // If LSB is 0, the index is even. If LSB is 1, the index is odd.\n        svuint32_t lsb_values = svand_u32_x(pg, current_indices, lsb_mask);\n        // Create a predicate where true means the index is even (LSB is 0).\n        // 'cond2_pred' will be true for lanes where the index is even.\n        svbool_t cond2_pred = svcmpeq_u32(pg, lsb_values, zero_u32_vec);\n\n        // 4. Combine predicates: (abs(diff) <= 50.0f) AND (index is even)\n        // 'combined_pred' is true only for lanes where both conditions are met.\n        svbool_t combined_pred = svand_b(cond1_pred, cond2_pred);\n\n        // 5. Perform calculation (multiplication and round up) for elements\n        // that meet the combined conditions.\n        // These operations are performed on all lanes. For lanes where 'pg'\n        // was false (beyond 'length'), the inputs might be garbage, but\n        // svsel_f32 will correctly handle this later.\n        svfloat32_t mul_vec = svmul_f32(s1_vec, s2_vec);\n        svfloat32_t result_vec = svceil_f32(mul_vec);\n\n        // 6. Select final values for the destination array.\n        // For lanes where 'combined_pred' is true, take the calculated 'result_vec'.\n        // For lanes where 'combined_pred' is false (including those beyond 'length'\n        // due to 'pg' being false), take 'neg_one_vec'.\n        svfloat32_t final_vec = svsel_f32(combined_pred, result_vec, neg_one_vec);\n\n        // 7. Store results into the destination array for active lanes.\n        svst1_f32(pg, &dst[i], final_vec);\n\n        // Move to the next chunk of elements.\n        i += active_elements;\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    // Predicate for 32-bit floats, active while i < length\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    // Constant for comparison (50.0f)\n    svfloat32_t s_50 = svdup_f32(50.0f);\n    // Constant for default value (-1.0f)\n    svfloat32_t s_neg_1 = svdup_f32(-1.0f);\n    // Constant for modulo operation (2)\n    svint32_t s_2 = svdup_s32(2);\n    // Constant for comparison (0)\n    svint32_t s_0 = svdup_s32(0);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load data from src1 and src2 using the current predicate 'pg'\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // --- Condition 1: abs(src1[i] - src2[i]) <= 50.0f ---\n        // Calculate difference\n        svfloat32_t diff = svsub_f32(vec_src1, vec_src2);\n        // Calculate absolute difference\n        svfloat32_t abs_diff = svabs_f32(diff);\n        // Compare absolute difference with 50.0f. 'pg' ensures comparison only for active lanes.\n        svbool_t cond1_pred = svcle_f32(pg, abs_diff, s_50);\n\n        // --- Condition 2: index is a multiple of 2 (i % 2 == 0) ---\n        // Generate a vector of indices starting from 'i'\n        svint32_t indices = svindex_s32(i, 1);\n        // Calculate indices % 2\n        svint32_t mod_indices = svmod_s32(indices, s_2);\n        // Check if (indices % 2) == 0. 'pg' ensures comparison only for active lanes.\n        svbool_t cond2_pred = svcmpeq_s32(pg, mod_indices, s_0);\n\n        // --- Combine conditions: cond1_pred AND cond2_pred ---\n        svbool_t final_pred = svand_b(cond1_pred, cond2_pred);\n\n        // --- Perform operations for elements that meet conditions ---\n        // Calculate product: src1[i] * src2[i]\n        svfloat32_t product = svmul_f32(vec_src1, vec_src2);\n        // Round up the product toward positive infinity\n        svfloat32_t rounded_product = svceil_f32(product);\n\n        // Select the final result:\n        // If final_pred is true, use rounded_product.\n        // If final_pred is false, use -1.0f.\n        svfloat32_t result_vec = svsel_f32(final_pred, rounded_product, s_neg_1);\n\n        // Store the result into the destination array 'dst' using the current predicate 'pg'\n        svst1(pg, &dst[i], result_vec);\n\n        // Move to the next vector block\n        i += svcntw(); // Increment 'i' by the number of 32-bit elements in a vector\n        // Update the predicate for the next iteration, covering remaining elements\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Duplicate the scalar value into an SVE vector.\n    // This allows the scalar to be used in vector operations.\n    svfloat64_t sv_scalar = svdup_f64(scalar);\n\n    // Loop through the matrix elements in chunks determined by the SVE vector length.\n    // svcntd() returns the number of 64-bit elements (doubles) that fit in an SVE vector.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Generate a predicate for the current vector segment.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the total_elements, handling the tail of the array.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the source matrix 'mat'.\n        // The load is predicated, meaning only active lanes (determined by 'pg') are loaded.\n        svfloat64_t sv_mat = svld1_f64(pg, &mat[i]);\n\n        // Perform element-wise multiplication of the loaded 'sv_mat' vector\n        // with the 'sv_scalar' vector.\n        // The multiplication is predicated, so only active lanes are computed.\n        svfloat64_t sv_result = svmul_f64(pg, sv_mat, sv_scalar);\n\n        // Store the resulting vector 'sv_result' back into the destination matrix 'dst'.\n        // The store is predicated, ensuring results are written only to active lanes.\n        svst1_f64(pg, &dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Duplicate the scalar value into an SVE vector register\n    svfloat64_t sv_scalar = svdup_f64(scalar);\n\n    // Loop through the elements of the matrix using SVE vectors\n    // svwhilelt_b64 generates a predicate for the current vector length,\n    // handling both full vectors and the partial tail.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Create a predicate for the current vector segment.\n        // This predicate ensures that operations only apply to elements within bounds.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of double-precision floating-point values from the source matrix\n        svfloat64_t sv_mat = svld1_f64(pg, &mat[i]);\n\n        // Perform element-wise multiplication of the loaded vector by the scalar vector\n        svfloat64_t sv_result = svmul_f64(sv_mat, sv_scalar);\n\n        // Store the resulting vector back into the destination matrix\n        svst1_f64(pg, &dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Duplicate the scalar value into all lanes of an SVE vector register\n    svfloat64_t sv_scalar = svdup_f64(scalar);\n\n    // Loop through the matrix elements, processing 'svcntd()' doubles at a time\n    // svwhilelt_b64 generates a predicate for the current vector length,\n    // ensuring that only valid elements up to 'total_elements' are processed.\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Create a predicate for the current vector operation.\n        // This predicate will be true for elements from 'i' up to 'total_elements - 1'.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the source matrix 'mat' using the predicate\n        svfloat64_t sv_mat_vec = svld1_f64(pg, &mat[i]);\n\n        // Perform element-wise multiplication of the loaded vector with the scalar vector.\n        // The '_x' suffix indicates that inactive lanes (determined by 'pg') are not modified.\n        svfloat64_t sv_result_vec = svmul_f64_x(pg, sv_mat_vec, sv_scalar);\n\n        // Store the resulting vector into the destination matrix 'dst' using the predicate\n        svst1_f64(pg, &dst[i], sv_result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Splat the scalar value into an SVE vector register\n    svfloat64_t sv_scalar = svdup_f64(scalar);\n\n    // Loop through the elements in chunks of SVE vector length\n    // using svwhilelt_b64 for predicate generation\n    while (i < total_elements) {\n        // Generate a predicate for the current vector operation\n        // This predicate ensures we only process valid elements up to total_elements\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of double-precision floating-point values from mat\n        svfloat64_t sv_mat = svld1_f64(pg, &mat[i]);\n\n        // Perform element-wise multiplication: sv_mat * sv_scalar\n        svfloat64_t sv_result = svmul_f64(sv_mat, sv_scalar);\n\n        // Store the result back to dst\n        svst1_f64(pg, &dst[i], sv_result);\n\n        // Increment the index by the number of elements processed in this vector\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Duplicate the scalar value into all lanes of an SVE vector register.\n    svfloat64_t sv_scalar = svdup_f64(scalar);\n\n    // Loop through the elements of the matrix, processing 'svcntd()' doubles at a time.\n    // svwhilelt_b64 generates a predicate for the current vector operation,\n    // ensuring that operations do not go beyond 'total_elements'.\n    // The loop counter 'i' is advanced by the actual vector length (svcntd()).\n    for (i = 0; i < total_elements; i += svcntd()) {\n        // Create a predicate 'pg' that is true for elements within the bounds [i, total_elements).\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the source matrix 'mat' using the predicate.\n        // Only active lanes (where pg is true) will load data.\n        svfloat64_t sv_mat_val = svld1_f64(pg, &mat[i]);\n\n        // Perform element-wise multiplication of the loaded matrix values by the scalar.\n        // The operation is performed only on active lanes defined by 'pg'.\n        svfloat64_t sv_result = svmul_f64(pg, sv_mat_val, sv_scalar);\n\n        // Store the result vector into the destination matrix 'dst' using the predicate.\n        // Only active lanes will write data.\n        svst1_f64(pg, &dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>   // For sqrtf\n#include <float.h>  // For FLT_EPSILON\n#include <stddef.h> // For size_t\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row_ptr = mat + i * n;\n\n        svfloat32_t sum_sq_vec = svdup_f32(0.0f);\n        svbool_t pg;\n\n        for (size_t j = 0; j < n; j += svcnt_f32()) {\n            pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t sq_vec = svmul_f32(vec, vec);\n            sum_sq_vec = svadd_f32(sum_sq_vec, sq_vec);\n        }\n\n        float sum_sq_row = svaddv_f32(svptrue_b32(), sum_sq_vec);\n        float l2_norm_scalar = sqrtf(sum_sq_row);\n\n        if (l2_norm_scalar < FLT_EPSILON) {\n            for (size_t j = 0; j < n; ++j) {\n                row_ptr[j] = 0.0f;\n            }\n            continue;\n        }\n\n        svfloat32_t l2_norm_vec = svdup_f32(l2_norm_scalar);\n\n        for (size_t j = 0; j < n; j += svcnt_f32()) {\n            pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t normalized_vec = svdiv_f32(vec, l2_norm_vec);\n            svst1_f32(pg, row_ptr + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For sqrtf\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    // Iterate over each row of the matrix\n    for (size_t i = 0; i < m; ++i) {\n        // Calculate the starting address of the current row\n        float* row_ptr = mat + i * n;\n\n        // --- Step 1: Calculate the L2 norm (sqrt of sum of squares) for the current row ---\n\n        // Initialize an SVE vector to accumulate the sum of squares.\n        // All lanes are initialized to 0.0f.\n        svfloat32_t sum_sq_vec = svdup_f32(0.0f);\n\n        // Loop through the current row, processing elements in SVE vector chunks\n        // svcntw() returns the number of 32-bit elements (floats) in an SVE vector.\n        for (size_t j = 0; j < n; j += svcntw()) {\n            // Create a predicate for the current chunk.\n            // This predicate ensures that only valid elements within the row bounds (n) are processed,\n            // handling the tail (remaining elements less than a full vector length).\n            svbool_t current_pg = svwhilelt_b32(j, n);\n\n            // Load a vector of float elements from the current row using the predicate.\n            // Elements outside the predicate's active lanes will not be loaded (or will be zero if not masked).\n            svfloat32_t vec = svld1_f32(current_pg, row_ptr + j);\n\n            // Square each element in the loaded vector.\n            svfloat32_t squared_vec = svmul_f32(vec, vec);\n\n            // Accumulate the squared values into sum_sq_vec.\n            // This performs element-wise addition.\n            sum_sq_vec = svadd_f32(sum_sq_vec, squared_vec);\n        }\n\n        // Perform a horizontal sum of all elements in the sum_sq_vec accumulator.\n        // svptrue_b32() creates a predicate where all lanes are active, ensuring all accumulated values are summed.\n        float total_sum_sq = svaddv_f32(svptrue_b32(), sum_sq_vec);\n\n        // Calculate the L2 norm by taking the square root of the total sum of squares.\n        float l2_norm = sqrtf(total_sum_sq);\n\n        // Handle the case where L2 norm is zero to avoid division by zero.\n        // If l2_norm is 0, it means all elements in the row are 0.\n        // Dividing 0 by 0 results in NaN, which is standard IEEE 754 behavior.\n        // If a row is all zeros, it remains all zeros after normalization (or becomes NaN if 0/0).\n        if (l2_norm == 0.0f) {\n            continue; // Skip normalization for this row if L2 norm is zero\n        }\n\n        // --- Step 2: Divide each element in the row by the calculated L2 norm ---\n\n        // Broadcast the scalar L2 norm into an SVE vector, so it can be used for element-wise division.\n        svfloat32_t l2_norm_vec = svdup_f32(l2_norm);\n\n        // Loop through the current row again to normalize its elements\n        for (size_t j = 0; j < n; j += svcntw()) {\n            // Create a predicate for the current chunk, similar to the sum of squares loop.\n            svbool_t current_pg = svwhilelt_b32(j, n);\n\n            // Load a vector of float elements from the current row.\n            svfloat32_t vec = svld1_f32(current_pg, row_ptr + j);\n\n            // Perform element-wise division: vec / l2_norm_vec.\n            svfloat32_t normalized_vec = svdiv_f32(vec, l2_norm_vec);\n\n            // Store the normalized vector back into memory at the current row's position.\n            svst1_f32(current_pg, row_ptr + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // Required for sqrtf\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row_ptr = mat + i * n;\n\n        // Step 1: Calculate the sum of squares for the current row\n        svfloat32_t sum_sq_vec = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg, &row_ptr[j]);\n            sum_sq_vec = svmla_f32(sum_sq_vec, vec, vec); // sum_sq_vec += vec * vec\n        }\n        float sum_sq = svaddv_f32(svptrue_v_f32(), sum_sq_vec);\n\n        // Step 2: Calculate the L2 norm (square root of the sum of squares)\n        float l2_norm = sqrtf(sum_sq);\n\n        // Step 3: Normalize the row by dividing each element by the L2 norm\n        // Handle the case where l2_norm is zero or very small to avoid division by zero/inf.\n        // If the norm is zero, all elements in the row are zero, and they should remain zero.\n        if (l2_norm > 1e-6f) { // Use a small epsilon to handle near-zero norms\n            svfloat32_t l2_norm_vec = svdup_f32(l2_norm);\n            for (size_t j = 0; j < n; j += svcntw()) {\n                svbool_t pg = svwhilelt_b32(j, n);\n                svfloat32_t vec = svld1_f32(pg, &row_ptr[j]);\n                svfloat32_t normalized_vec = svdiv_f32(vec, l2_norm_vec);\n                svst1_f32(pg, &row_ptr[j], normalized_vec);\n            }\n        }\n        // If l2_norm is <= 1e-6f, the row is considered all zeros (or very close),\n        // and its elements remain unchanged (i.e., all zeros), which is the correct normalization.\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For sqrtf\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row_ptr = mat + i * n;\n\n        svfloat32_t sum_sq_vec = svdup_f32(0.0f);\n        size_t k = 0;\n        svbool_t pg;\n\n        for (; k + svcntf() <= n; k += svcntf()) {\n            pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1(pg, row_ptr + k);\n            sum_sq_vec = svmla_f32(sum_sq_vec, vec, vec);\n        }\n\n        if (k < n) {\n            pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1(pg, row_ptr + k);\n            sum_sq_vec = svmla_f32(sum_sq_vec, vec, vec);\n        }\n\n        float sum_sq = svaddv_f32(svptrue_b32(), sum_sq_vec);\n        float l2_norm = sqrtf(sum_sq);\n\n        if (l2_norm == 0.0f) {\n            continue;\n        }\n\n        svfloat32_t l2_norm_vec = svdup_f32(l2_norm);\n        k = 0;\n\n        for (; k + svcntf() <= n; k += svcntf()) {\n            pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1(pg, row_ptr + k);\n            vec = svdiv_f32(pg, vec, l2_norm_vec);\n            svst1(pg, row_ptr + k, vec);\n        }\n\n        if (k < n) {\n            pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1(pg, row_ptr + k);\n            vec = svdiv_f32(pg, vec, l2_norm_vec);\n            svst1(pg, row_ptr + k, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // Required for sqrtf\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t r = 0; r < m; ++r) {\n        float* row_ptr = mat + r * n;\n\n        // Calculate L2 norm for the current row\n        svfloat32_t sum_sq_vec = svdup_f32(0.0f);\n        size_t col_idx = 0;\n        svbool_t pg;\n\n        while (col_idx < n) {\n            pg = svwhilelt_b32(col_idx, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col_idx);\n            svfloat32_t sq_vec = svmul_f32(vec, vec);\n            sum_sq_vec = svadd_f32(sum_sq_vec, sq_vec);\n            col_idx += svcntw();\n        }\n\n        float total_sum_sq = svaddv_f32(svptrue_b32(), sum_sq_vec);\n        float l2_norm = sqrtf(total_sum_sq);\n\n        // Normalize elements in the current row\n        // Handle the case where L2 norm is zero to avoid division by zero.\n        // If the norm is zero, the row is a zero vector, and normalization is undefined.\n        // We skip normalization for such rows.\n        if (l2_norm < 1e-6f) { \n            continue; \n        }\n\n        svfloat32_t inv_l2_norm_vec = svdup_f32(1.0f / l2_norm);\n\n        col_idx = 0; \n        while (col_idx < n) {\n            pg = svwhilelt_b32(col_idx, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col_idx);\n            svfloat32_t normalized_vec = svmul_f32(vec, inv_l2_norm_vec);\n            svst1_f32(pg, row_ptr + col_idx, normalized_vec);\n            col_idx += svcntw();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    // Iterate over rows of mat1 (and dst)\n    for (size_t i = 0; i < m; ++i) {\n        // Iterate over columns of mat2 (and dst) in vector chunks\n        // svcntd() returns the number of double-precision elements in an SVE vector.\n        for (size_t j = 0; j < p; j += svcntd()) {\n            // Create a predicate for the current vector chunk.\n            // This handles the tail elements where (j + svcntd()) might exceed p.\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize the accumulator vector for the current dst[i][j...j+VL-1] elements to zero.\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Iterate over the inner dimension 'k'\n            for (size_t k = 0; k < n; ++k) {\n                // Load the scalar element mat1[i][k] and broadcast it to all lanes of a vector.\n                // mat1[i][k] is located at mat1[i * n + k] in the flattened array.\n                svfloat64_t mat1_val_scalar = svdup_f64(mat1[i * n + k]);\n\n                // Load a vector from mat2[k][j...j+VL-1].\n                // mat2[k][j] is located at mat2[k * p + j] in the flattened array.\n                // The predicate 'pg' ensures that only valid elements are loaded and processed.\n                svfloat64_t mat2_col_vec = svld1_f64(pg, &mat2[k * p + j]);\n\n                // Perform fused multiply-add: sum_vec += mat1_val_scalar * mat2_col_vec\n                sum_vec = svmla_f64(sum_vec, mat1_val_scalar, mat2_col_vec);\n            }\n\n            // After accumulating all products for the current dst[i][j...j+VL-1] chunk,\n            // round the result to the nearest integer.\n            // svrintn_f64 performs rounding to nearest, ties to even.\n            svfloat64_t rounded_vec = svrintn_f64(sum_vec);\n\n            // Store the rounded result into the destination matrix.\n            // dst[i][j] is located at dst[i * p + j] in the flattened array.\n            // The predicate 'pg' ensures that only valid elements are stored.\n            svst1_f64(pg, &dst[i * p + j], rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    // Iterate over rows of mat1 (and dst)\n    for (size_t i = 0; i < m; ++i) {\n        // Iterate over columns of mat2 (and dst) with SVE vectorization\n        // j is the starting column index for the current SVE vector operation\n        for (size_t j = 0; j < p; j += svcntd()) {\n            // Get the predicate for the current vector length.\n            // This ensures that operations only apply to valid elements within the matrix bounds.\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize an accumulator vector for the current block of dst elements to zero.\n            svfloat64_t acc = svdup_f64(0.0);\n\n            // Inner loop for the dot product sum (k-dimension)\n            for (size_t k = 0; k < n; ++k) {\n                // Load the scalar element mat1[i][k].\n                // Broadcast this scalar value to all lanes of an SVE vector.\n                svfloat64_t mat1_val_vec = svdup_f64(mat1[i * n + k]);\n\n                // Load a vector of elements from mat2[k][j...j+VL-1].\n                // The predicate 'pg' ensures that only valid elements are loaded.\n                svfloat64_t mat2_vec = svld1_f64(pg, &mat2[k * p + j]);\n\n                // Perform fused multiply-add: acc += mat1_val_vec * mat2_vec.\n                // This accumulates the products for the dot product.\n                acc = svmla_f64(acc, mat1_val_vec, mat2_vec);\n            }\n\n            // After computing the dot product for the current block, round the result\n            // to the nearest integer. svrintn_f64 rounds to the nearest, ties to even.\n            svfloat64_t rounded_acc = svrintn_f64(acc);\n\n            // Store the rounded result vector back to the destination matrix.\n            // The predicate 'pg' ensures that only valid elements are written.\n            svst1_f64(pg, &dst[i * p + j], rounded_acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    // Get the number of double elements in an SVE vector\n    size_t sv_double_elements = svcntd();\n\n    // Loop over rows of mat1 (i)\n    for (size_t i = 0; i < m; ++i) {\n        // Loop over columns of mat2 (j), processing sv_double_elements at a time\n        for (size_t j = 0; j < p; j += sv_double_elements) {\n            // Create a predicate for the current vector chunk.\n            // This handles the tail elements when p is not a multiple of sv_double_elements.\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize the accumulator vector for the current dst[i][j...j+VL-1] elements to zero.\n            svfloat64_t acc_vec = svdup_f64(0.0);\n\n            // Inner loop for k (summation of products)\n            for (size_t k = 0; k < n; ++k) {\n                // Load the scalar element mat1[i][k] and duplicate it across the vector.\n                // This element will be multiplied by a vector from mat2.\n                svfloat64_t mat1_scalar_vec = svdup_f64(mat1[i * n + k]);\n\n                // Load a vector from mat2[k][j...j+VL-1].\n                // The base address for this row of mat2 is mat2 + k * p.\n                // We then add j to get the starting column for the current vector.\n                svfloat64_t mat2_vec = svld1_f64(pg, mat2 + k * p + j);\n\n                // Perform fused multiply-add: acc_vec += mat1_scalar_vec * mat2_vec\n                acc_vec = svmla_f64(acc_vec, mat1_scalar_vec, mat2_vec);\n            }\n\n            // After the k-loop, acc_vec holds the accumulated dot product for the current\n            // block of dst elements. Now, round these results to the nearest integer.\n            // svrintn_f64 rounds to the nearest integer, with ties rounding to even.\n            svfloat64_t rounded_vec = svrintn_f64(pg, acc_vec);\n\n            // Store the rounded results into the destination matrix.\n            // The base address for this row of dst is dst + i * p.\n            // We then add j to get the starting column for the current vector.\n            svst1_f64(pg, dst + i * p + j, rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    // Loop over rows of mat1 (and dst)\n    for (size_t i = 0; i < m; ++i) {\n        // Loop over columns of mat2 (and dst), processing svcntd() elements at a time\n        // svcntd() returns the number of 64-bit double-precision floating-point elements\n        // that fit into an SVE vector register.\n        for (size_t j = 0; j < p; j += svcntd()) {\n            // Create a predicate for the current vector chunk.\n            // This handles the tail elements when p is not a multiple of svcntd().\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize the accumulator vector for the current dst[i][j...j+VL-1] elements to zero.\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Inner loop for dot product accumulation: sum(mat1[i][k] * mat2[k][j])\n            for (size_t k = 0; k < n; ++k) {\n                // Load the scalar element from mat1 for the current row i and column k.\n                // This scalar value is broadcast to all lanes of an SVE vector.\n                svfloat64_t mat1_scalar_vec = svdup_f64(mat1[i * n + k]);\n\n                // Load a vector of elements from mat2 for the current row k and columns j...j+VL-1.\n                // These elements are contiguous in memory for a fixed k and varying j.\n                // The predicate 'pg' ensures that only valid elements are loaded and processed.\n                svfloat64_t mat2_vec = svld1_f64(pg, &mat2[k * p + j]);\n\n                // Perform fused multiply-add: sum_vec += mat1_scalar_vec * mat2_vec.\n                // This accumulates the product of mat1[i][k] and mat2[k][j...j+VL-1] into sum_vec.\n                sum_vec = svmla_f64(sum_vec, mat1_scalar_vec, mat2_vec);\n            }\n\n            // After accumulating the sum for the current dst[i][j...j+VL-1] elements,\n            // round the result to the nearest integer.\n            // svrintn_f64 rounds to the nearest integer, with ties to even.\n            // The '_x' suffix indicates that the operation is predicated.\n            svfloat64_t rounded_vec = svrintn_f64_x(pg, sum_vec);\n\n            // Store the rounded result into the destination matrix.\n            // The predicate 'pg' ensures that only valid elements are stored.\n            svst1_f64(pg, &dst[i * p + j], rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    // Get the vector length for double precision floats (svcntd() returns the number of double elements)\n    size_t VL = svcntd();\n\n    // Precompute the index vector for gathering elements from mat2.\n    // For mat2[k * p + j], elements are at offsets 0, p, 2*p, ..., (VL-1)*p from the base address.\n    // svindex_s64(start, step) generates a vector of signed 64-bit integers: {start, start+step, start+2*step, ...}\n    svint64_t indices_for_mat2_gather = svindex_s64(0, p);\n\n    // Iterate over rows of mat1\n    for (size_t i = 0; i < m; ++i) {\n        // Iterate over columns of mat2\n        for (size_t j = 0; j < p; ++j) {\n            // Initialize a vector to accumulate the sum for the current dst[i][j] element.\n            // All elements of sum_vec are initialized to 0.0.\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Loop over the 'k' dimension (columns of mat1 / rows of mat2).\n            // This is the inner loop where vectorization is applied.\n            for (size_t k = 0; k < n; k += VL) {\n                // Create a predicate for the current vector chunk.\n                // svwhilelt_b64(k, n) generates a predicate that is true for elements\n                // where the effective index (k + element_offset) is less than n.\n                // This correctly handles the tail elements when n is not a multiple of VL.\n                svbool_t pg = svwhilelt_b64(k, n);\n\n                // Load elements from mat1 (contiguous access).\n                // mat1[i * n + k] is the starting address for the current chunk in mat1's row 'i'.\n                svfloat64_t mat1_row_vec = svld1_f64(pg, &mat1[i * n + k]);\n\n                // Load elements from mat2 (strided/gathered access).\n                // mat2[k * p + j] is the base address for the current chunk in mat2's column 'j'.\n                // svld1_gather_s64offset_f64 loads elements using the base address and the precomputed\n                // 64-bit integer offsets (indices_for_mat2_gather).\n                svfloat64_t mat2_col_vec = svld1_gather_s64offset_f64(pg, &mat2[k * p + j], indices_for_mat2_gather);\n\n                // Perform fused multiply-add: sum_vec += mat1_row_vec * mat2_col_vec.\n                // This accumulates the products into sum_vec.\n                sum_vec = svmla_f64(sum_vec, mat1_row_vec, mat2_col_vec);\n            }\n\n            // Reduce the sum_vec to a single scalar value.\n            // svaddv_f64 performs a horizontal sum of all elements in sum_vec.\n            // svptrue_b64() creates a predicate that enables all elements in the vector for the reduction.\n            double final_sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            // Round the final sum to the nearest integer using an SVE intrinsic.\n            // svdup_f64(final_sum) creates a vector where all elements are 'final_sum'.\n            // svrint_f64(pg, op) rounds each element of 'op' to the nearest integer.\n            // For double-precision, svrint_f64 rounds ties away from zero, which matches the behavior of C's round() function.\n            // svget_f64(vec, index) extracts a scalar element from a vector.\n            dst[i * p + j] = svget_f64(svrint_f64(svptrue_b64(), svdup_f64(final_sum)), 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Get the number of float elements that fit in an SVE vector.\n    // This determines the vector length (VL) at runtime.\n    size_t sv_float_count = svcntw();\n\n    // Pre-calculate the vector of offsets for the scatter store.\n    // When transposing, an element src[r][c+k] goes to dst[c+k][r].\n    // The memory address for dst[c+k][r] is `dst + (c+k) * rows + r`.\n    // This can be rewritten as `(dst + c * rows + r) + k * rows`.\n    // So, for a scatter operation, the base pointer will be `dst + c * rows + r`,\n    // and the offsets for each element `k` in the vector will be `k * rows`.\n    // `svindex_s32(start, step)` generates a vector of indices: `start, start+step, start+2*step, ...`\n    svint32_t scatter_offsets = svindex_s32(0, rows);\n\n    // Iterate over rows of the source matrix\n    for (size_t r = 0; r < rows; ++r) {\n        // Iterate over columns of the source matrix, processing 'sv_float_count' elements at a time\n        for (size_t c = 0; c < cols; c += sv_float_count) {\n            // Create a predicate for the current vector operation.\n            // This predicate ensures that we only process valid elements when 'c + sv_float_count'\n            // extends beyond the actual number of columns 'cols'.\n            svbool_t pg = svwhilelt_b32(c, cols);\n\n            // Load a vector of float elements from the source matrix.\n            // The elements loaded are src[r][c], src[r][c+1], ..., src[r][c+sv_float_count-1].\n            svfloat32_t vec_src = svld1(pg, src + r * cols + c);\n\n            // Perform the rounding operation: round(x * 4.0) / 4.0\n            // 1. Multiply by 4.0\n            svfloat32_t vec_scaled = svmul_f32(vec_src, svdup_f32(4.0f));\n            // 2. Round to the nearest integer. `svrintn_f32` rounds to nearest, ties to even.\n            svfloat32_t vec_rounded_int = svrintn_f32(vec_scaled);\n            // 3. Divide by 4.0 to get the nearest quarter\n            svfloat32_t vec_final = svdiv_f32(vec_rounded_int, svdup_f32(4.0f));\n\n            // Store the processed vector into the destination matrix with transposition.\n            // The k-th element of `vec_final` (which corresponds to `src[r][c+k]`)\n            // needs to be stored at `dst[c+k][r]`.\n            // The base pointer for the scatter is `dst + c * rows + r`.\n            // The `scatter_offsets` vector provides the `k * rows` offsets.\n            svst1_scatter_s32offset_f32(pg, dst + c * rows + r, scatter_offsets, vec_final);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Constants for rounding, duplicated across all SVE lanes\n    svfloat32_t four_f = svdup_f32(svptrue_v_f32(), 4.0f);\n    svfloat32_t half_f = svdup_f32(svptrue_v_f32(), 0.5f);\n    svfloat32_t zero_f = svdup_f32(svptrue_v_f32(), 0.0f);\n    svfloat32_t quarter_f = svdup_f32(svptrue_v_f32(), 0.25f);\n\n    // Duplicate rows count into a vector for offset calculation\n    svint32_t rows_s32 = svdup_s32(svptrue_v_s32(), (int32_t)rows);\n\n    // Iterate over rows of the source matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Iterate over columns of the source matrix, processing VL elements at a time\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            // Create a predicate for the current vector chunk.\n            // This predicate will be true for active lanes within the matrix bounds\n            // and false for lanes that go beyond 'cols'.\n            svbool_t pg = svwhilelt_b32(j, cols);\n\n            // If no lanes are active under the predicate, break the inner loop\n            if (!svptest_any(svptrue_v_f32(), pg)) {\n                break;\n            }\n\n            // 1. Load a vector from the source matrix (row-major access)\n            // Elements are loaded from src[i * cols + j], src[i * cols + j + 1], ...\n            svfloat32_t src_vec = svld1_f32(pg, &src[i * cols + j]);\n\n            // 2. Round each element to the nearest quarter.\n            // This implementation uses \"round half away from zero\" behavior,\n            // similar to the standard C `roundf` function.\n            // First, multiply by 4 to shift the quarter-rounding to integer-rounding.\n            svfloat32_t val_x4 = svmul_f32(pg, src_vec, four_f);\n\n            // Determine the sign of each element in val_x4 for correct rounding logic.\n            svbool_t is_positive = svacge_f32(pg, val_x4, zero_f);\n\n            // For positive values: floor(val_x4 + 0.5f)\n            svfloat32_t val_pos_adjusted = svadd_f32(pg, val_x4, half_f);\n            svfloat32_t rounded_pos = svfloor_f32(val_pos_adjusted);\n\n            // For negative values: ceil(val_x4 - 0.5f)\n            svfloat32_t val_neg_adjusted = svsub_f32(pg, val_x4, half_f);\n            svfloat32_t rounded_neg = svceil_f32(val_neg_adjusted);\n\n            // Select the rounded value based on the sign predicate.\n            svfloat32_t rounded_val_x4 = svsel_f32(is_positive, rounded_pos, rounded_neg);\n\n            // Divide by 4 to get the final rounded value to the nearest quarter.\n            svfloat32_t final_rounded_vec = svmul_f32(pg, rounded_val_x4, quarter_f);\n\n            // 3. Prepare offsets for scatter store to the destination matrix (column-major access).\n            // The target address for src[i*cols + j+k] is dst[(j+k)*rows + i].\n            // For scatter, we need a base address and a vector of offsets.\n            // Base address: &dst[i] (which is dst + i * sizeof(float)).\n            // Offsets needed: (j*rows), ((j+1)*rows), ..., ((j+VL-1)*rows).\n            // `svindex_s32(j, 1)` generates a vector [j, j+1, j+2, ...].\n            svint32_t current_j_indices = svindex_s32(j, 1);\n            // Multiply these indices by `rows` to get the correct strides for column-major access.\n            svint32_t offsets = svmul_s32(pg, current_j_indices, rows_s32);\n\n            // 4. Store the rounded vector to the destination matrix using scatter.\n            // `svst1_scatter_s32offset_f32(pg, base, offsets, data)` stores `data[k]`\n            // to `base + offsets[k] * sizeof(float)` for active lanes.\n            // This correctly places `final_rounded_vec[k]` into `dst[i + (j+k)*rows]`,\n            // which is equivalent to `dst[(j+k)*rows + i]`, the transposed position.\n            svst1_scatter_s32offset_f32(pg, &dst[i], offsets, final_rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Define the constants for rounding to the nearest quarter\n    // To round x to the nearest quarter: round(x * 4.0) / 4.0\n    svfloat32_t quarter_factor = svdup_f32(4.0f);\n    svfloat32_t inv_quarter_factor = svdup_f32(0.25f);\n\n    // Iterate over each row of the source matrix\n    for (size_t i_src = 0; i_src < rows; ++i_src) {\n        // Iterate over columns of the source matrix using SVE vectors\n        // These elements will form a row in the destination matrix after transpose.\n        // The elements are loaded contiguously from src.\n        size_t j_src = 0;\n        svbool_t pg_cols = svwhilelt_b32(j_src, cols); // Predicate for the current vector length\n        while (svptest_any(svptrue_b32(), pg_cols)) {\n            // Load a vector of float elements from the current row of src\n            // src_ptr points to the start of the current row in src\n            const float* src_ptr = src + i_src * cols + j_src;\n            svfloat32_t vec_src = svld1(pg_cols, src_ptr);\n\n            // Perform the rounding to the nearest quarter\n            // 1. Multiply by 4.0\n            svfloat32_t vec_scaled = svmul_f32(pg_cols, vec_src, quarter_factor);\n            // 2. Round to the nearest integer (ties to even)\n            svfloat32_t vec_rounded_int = svrintn_f32(pg_cols, vec_scaled);\n            // 3. Divide by 4.0 (multiply by 0.25)\n            svfloat32_t vec_rounded_quarter = svmul_f32(pg_cols, vec_rounded_int, inv_quarter_factor);\n\n            // Store the rounded elements to the destination matrix with transpose\n            // The element src[i_src * cols + j_src] goes to dst[j_src * rows + i_src].\n            // For a vector of elements loaded from src[i_src * cols + j_src], src[i_src * cols + j_src + 1], ...\n            // they need to be stored at dst[j_src * rows + i_src], dst[(j_src + 1) * rows + i_src], ...\n            // This is a scatter operation.\n            // The base address for scatter is dst + i_src.\n            // The offsets are j_src * rows, (j_src + 1) * rows, (j_src + 2) * rows, ...\n            svint32_t offsets = svindex_s32(j_src * rows, rows); // Generate vector of offsets\n\n            // Perform the scatter store\n            svst1_scatter_s32offset_f32(pg_cols, dst + i_src, offsets, vec_rounded_quarter);\n\n            // Move to the next vector chunk in the current row\n            j_src += svcntw();\n            pg_cols = svwhilelt_b32(j_src, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t src_row_idx, src_col_idx;\n\n    // Duplicate constants into SVE vectors\n    svfloat32_t four = svdup_f32(4.0f);\n    svfloat32_t quarter = svdup_f32(0.25f);\n\n    // Iterate over columns of the source matrix (which become rows of the destination matrix)\n    for (src_col_idx = 0; src_col_idx < cols; ++src_col_idx) {\n        // Iterate over rows of the source matrix (which become columns of the destination matrix)\n        // Process 'rows' in chunks of svcntw() (SVE vector length for floats)\n        for (src_row_idx = 0; src_row_idx < rows; src_row_idx += svcntw()) {\n            // Create a predicate for the current vector length, handling partial vectors at the end\n            svbool_t pg = svwhilelt_b32((uint32_t)src_row_idx, (uint32_t)rows);\n\n            // Calculate gather offsets for loading elements from the source matrix.\n            // For transpose, src[r][c] goes to dst[c][r].\n            // We are processing a column of src (fixed src_col_idx, varying src_row_idx).\n            // The elements to load are src[src_row_idx * cols + src_col_idx],\n            // src[(src_row_idx + 1) * cols + src_col_idx], etc.\n            // This is a gather operation with a base address 'src' and varying offsets.\n            // The starting offset for the current vector is (src_row_idx * cols + src_col_idx).\n            // The step between consecutive elements in the column is 'cols'.\n            svint32_t gather_offsets = svindex_s32((int32_t)(src_row_idx * cols + src_col_idx), (int32_t)cols);\n\n            // Load a vector of elements from the source matrix using gather\n            svfloat32_t vec_src = svld1_gather_s32offset_f32(pg, src, gather_offsets);\n\n            // Round to the nearest quarter: round(x * 4.0) / 4.0\n            // 1. Multiply by 4.0\n            svfloat32_t temp = svmul_f32_x(pg, vec_src, four);\n            // 2. Round to the nearest integer (using the current FPU rounding mode, typically round-to-nearest-even)\n            temp = svround_f32_x(pg, temp);\n            // 3. Multiply by 0.25 (divide by 4.0)\n            svfloat32_t vec_rounded = svmul_f32_x(pg, temp, quarter);\n\n            // Store the rounded values contiguously to the destination matrix.\n            // These elements correspond to a row in the transposed destination matrix.\n            // The destination address for the current vector starts at dst[src_col_idx * rows + src_row_idx].\n            svst1_f32(pg, &dst[src_col_idx * rows + src_row_idx], vec_rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t r, c;\n    svbool_t pg;\n\n    // Multiplier for rounding to quarter (0.25)\n    svfloat32_t quarter_multiplier = svdup_f32(4.0f);\n    svfloat32_t quarter_divisor = svdup_f32(0.25f); // 1.0f / 4.0f\n\n    // Iterate through columns of the source matrix (which become rows of the destination matrix)\n    for (c = 0; c < cols; ++c) {\n        // Iterate through rows of the source matrix (which become columns of the destination matrix)\n        // Process in chunks of the SVE vector length (svcnt_f32())\n        for (r = 0; r < rows; r += svcnt_f32()) {\n            // Create a predicate for the current vector segment, handling partial vectors at the end of rows.\n            pg = svwhilelt_b32(r, rows);\n\n            // Generate offsets for gathering elements from the source matrix.\n            // For src[row_idx][col_idx], the linear address is src + row_idx * cols + col_idx.\n            // We want to gather src[r][c], src[r+1][c], ..., src[r+VL-1][c].\n            // The base pointer for the gather operation is `src + c`.\n            // The offsets for each element `i` in the vector are `(r + i) * cols`.\n            svint32_t row_indices_in_vec = svindex_s32(r, 1); // Generates r, r+1, r+2, ...\n            svint32_t col_stride_vec = svdup_s32(cols);\n            svint32_t gather_offsets = svmul_s32_x(pg, row_indices_in_vec, col_stride_vec);\n\n            // Gather a vector of elements from the current column of the source matrix.\n            svfloat32_t vec_src = svld1_gather_s32offset_f32(pg, src + c, gather_offsets);\n\n            // Step 1: Multiply by 4.0\n            svfloat32_t vec_scaled = svmul_f32_x(pg, vec_src, quarter_multiplier);\n\n            // Step 2: Round to the nearest integer.\n            // svrintn_f32 rounds to nearest, ties to even.\n            svfloat32_t vec_rounded_int = svrintn_f32_x(pg, vec_scaled);\n\n            // Step 3: Divide by 4.0 (multiply by 0.25)\n            svfloat32_t vec_dst = svmul_f32_x(pg, vec_rounded_int, quarter_divisor);\n\n            // Store the processed vector contiguously into the destination matrix.\n            // For dst[col_idx][row_idx], the linear address is dst + col_idx * rows + row_idx.\n            // We are storing to dst[c][r], dst[c][r+1], ..., dst[c][r+VL-1].\n            // The base pointer for the contiguous store is `dst + c * rows + r`.\n            svst1(pg, dst + c * rows + r, vec_dst);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the elements in chunks of SVE vector length\n    // svcntw() returns the number of 32-bit elements (floats) in an SVE vector\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds [i, total_elements).\n        pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of floats from tensor1\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n\n        // Load a vector of floats from tensor2\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction: vec1 - vec2\n        // The _x suffix indicates that the operation is predicated.\n        svfloat32_t result_sub = svsub_f32_x(pg, vec1, vec2);\n\n        // Round the result towards zero (truncation)\n        // The _x suffix indicates that the operation is predicated.\n        svfloat32_t result_rounded = svrintz_f32_x(pg, result_sub);\n\n        // Store the rounded result into the destination tensor\n        svst1_f32(pg, &dst[i], result_rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements using SVE vectors\n    // svcnt_f32() returns the number of float elements that fit in an SVE vector register\n    for (i = 0; i < total_elements; i += svcnt_f32()) {\n        // Create a predicate for the current vector operation.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of total_elements, handling tail elements automatically.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load vector from tensor1\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n\n        // Load vector from tensor2\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction: vec1 - vec2\n        svfloat32_t result_sub = svsub_f32(vec1, vec2);\n\n        // Round the result towards zero\n        svfloat32_t result_rounded = svrintz_f32(result_sub);\n\n        // Store the rounded result into the destination tensor\n        svst1_f32(pg, &dst[i], result_rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop using SVE intrinsics\n    // Get the number of 32-bit elements (floats) in an SVE vector\n    size_t sv_float_len = svcntw();\n\n    // Predicate for the loop, active while i < total_elements\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    // Loop continues as long as there are active elements in the predicate\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors from tensor1 and tensor2 using the current predicate\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction\n        svfloat32_t result_sub = svsub_f32(vec1, vec2);\n\n        // Round the result towards zero\n        svfloat32_t result_rounded = svrintz_f32(result_sub);\n\n        // Store the result in dst using the current predicate\n        svst1(pg, &dst[i], result_rounded);\n\n        // Increment loop counter by the SVE vector length\n        i += sv_float_len;\n\n        // Update predicate for the next iteration\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop while 'i' is less than the total number of elements\n    // svwhilelt_b32 generates a predicate for the current vector length,\n    // handling the tail elements automatically.\n    while (i < total_elements) {\n        // Get a predicate for the current vector operation.\n        // This predicate ensures we don't process elements beyond total_elements.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load vector from tensor1\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n\n        // Load vector from tensor2\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction\n        svfloat32_t diff = svsub_f32(vec1, vec2);\n\n        // Round the result towards zero\n        svfloat32_t rounded_diff = svrintz_f32(diff);\n\n        // Store the result to the destination tensor\n        svst1_f32(pg, &dst[i], rounded_diff);\n\n        // Increment the index by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements with SVE vector operations\n    // svcntw() returns the number of 32-bit elements in an SVE vector\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Get a predicate for the current vector operation.\n        // This predicate ensures that we only process valid elements,\n        // especially for the tail end of the array where total_elements\n        // might not be a multiple of svcntw().\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load vector from tensor1\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n\n        // Load vector from tensor2\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction\n        svfloat32_t diff = svsub_f32(vec1, vec2);\n\n        // Round the result towards zero\n        svfloat32_t rounded_diff = svrintz_f32(diff);\n\n        // Store the result in the destination tensor\n        svst1(pg, &dst[i], rounded_diff);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Loop while the remaining elements are greater than or equal to the SVE vector length\n    for (i = 0; i < total_elements; ) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Get the number of elements processed in this iteration\n        size_t elements_in_vector = svcntd();\n        if (i + elements_in_vector > total_elements) {\n            elements_in_vector = total_elements - i;\n            pg = svwhilelt_b64(0, elements_in_vector); // Predicate for the remaining elements\n        }\n\n        // Load vectors from mat1 and mat2\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n\n        // Perform element-wise multiplication\n        svfloat64_t result_vec = svmul_f64_z(pg, vec1, vec2);\n\n        // Store the result into dst\n        svst1_f64(pg, &dst[i], result_vec);\n\n        // Advance the index\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Loop while the current index 'i' is less than the total number of elements\n    // and there are enough elements remaining to fill at least one SVE vector.\n    while (i < total_elements) {\n        // Get the current vector length for double-precision floating-point numbers.\n        // This determines how many elements can be processed in this iteration.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        size_t elements_to_process = svcntd(); // Number of double elements in an SVE vector\n\n        // Load a vector from mat1 starting at mat1[i]\n        svfloat64_t vec1 = svld1(pg, &mat1[i]);\n\n        // Load a vector from mat2 starting at mat2[i]\n        svfloat64_t vec2 = svld1(pg, &mat2[i]);\n\n        // Perform element-wise multiplication (Hadamard product)\n        svfloat64_t result_vec = svmul_f64_z(pg, vec1, vec2);\n\n        // Store the result vector into dst starting at dst[i]\n        svst1(pg, &dst[i], result_vec);\n\n        // Advance the index by the number of elements processed in this iteration.\n        i += elements_to_process;\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Loop through the elements using SVE vectors\n    // svwhilelt_b64 generates a predicate for the remaining elements,\n    // handling the tail of the loop automatically.\n    while (i < total_elements) {\n        // Get a predicate for the current vector length,\n        // ensuring we don't go past total_elements.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load elements from mat1 and mat2 into SVE vectors\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n\n        // Perform element-wise multiplication\n        svfloat64_t result_vec = svmul_f64(vec1, vec2);\n\n        // Store the result back to the destination matrix\n        svst1_f64(pg, &dst[i], result_vec);\n\n        // Increment the index by the number of elements processed in this vector.\n        // svcntd() returns the number of double elements in an SVE vector.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while 'i' is less than 'total_elements', processing elements in SVE vector chunks\n    while (i < total_elements) {\n        // Generate a predicate for the current iteration.\n        // This predicate will be true for elements within the bounds [i, total_elements)\n        // and false for elements beyond 'total_elements' or for elements that don't fill a full vector.\n        pg = svwhilelt_b64(i, total_elements);\n\n        // Load vector from mat1 using the generated predicate\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n\n        // Load vector from mat2 using the generated predicate\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n\n        // Perform element-wise multiplication of the two vectors\n        svfloat64_t result_vec = svmul_f64(vec1, vec2);\n\n        // Store the result vector into the destination matrix using the same predicate\n        svst1_f64(pg, &dst[i], result_vec);\n\n        // Increment the loop counter by the number of double elements processed in this iteration.\n        // svcntd() returns the number of double elements that fit into an SVE vector.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrices (m);\n- The number of columns in the matrices (n).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform the Hadamard product (element-wise multiplication) of mat1 and mat2,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Loop through the elements using SVE intrinsics\n    while (i < total_elements) {\n        // Get the predicate for the current vector length.\n        // This predicate ensures that we only process up to 'total_elements'.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load elements from mat1 into an SVE vector\n        svfloat64_t v_mat1 = svld1_f64(pg, &mat1[i]);\n\n        // Load elements from mat2 into an SVE vector\n        svfloat64_t v_mat2 = svld1_f64(pg, &mat2[i]);\n\n        // Perform element-wise multiplication (Hadamard product)\n        svfloat64_t v_result = svmul_f64(pg, v_mat1, v_mat2);\n\n        // Store the result into the destination matrix\n        svst1_f64(pg, &dst[i], v_result);\n\n        // Increment the index by the number of double elements processed in this vector\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    // Loop over each row of the matrix\n    for (size_t i = 0; i < m; ++i) {\n        // Pointer to the current row in the matrix\n        // The matrix is flattened, so mat[i*n] points to the start of the i-th row.\n        const float* current_row_ptr = &mat[i * n];\n\n        // Initialize a vector register for the sum of products for the current row.\n        // All lanes are initialized to 0.0f. This register will accumulate the dot product.\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Loop over the columns of the matrix (which corresponds to elements of the vector 'vec').\n        // We process 'n' elements in chunks determined by the SVE vector length (svcntw()).\n        for (size_t j = 0; j < n; j += svcntw()) {\n            // Create a predicate for the current chunk.\n            // svwhilelt_b32(j, n) generates a predicate that is true for lanes\n            // where the element index (starting from j) is less than n.\n            // This correctly handles the end of the row/vector where 'n' might not be\n            // a multiple of the SVE vector length, masking out invalid elements.\n            svbool_t pg = svwhilelt_b32(j, n);\n\n            // Load elements from the current row of the matrix.\n            // Only active lanes (determined by 'pg') will be loaded.\n            svfloat32_t mat_val = svld1_f32(pg, &current_row_ptr[j]);\n\n            // Load elements from the vector 'vec'.\n            // Only active lanes (determined by 'pg') will be loaded.\n            svfloat32_t vec_val = svld1_f32(pg, &vec[j]);\n\n            // Perform fused multiply-add: sum_vec += mat_val * vec_val.\n            // This operation is predicated. For inactive lanes (where 'pg' is false),\n            // the corresponding lane in 'sum_vec' remains unchanged.\n            sum_vec = svmla_f32(sum_vec, mat_val, vec_val);\n        }\n\n        // After processing all chunks for the current row,\n        // horizontally sum all elements in 'sum_vec' to get the final scalar result\n        // for dst[i].\n        // svwhilelt_b32(0, svcntw()) creates a predicate that is true for all\n        // active lanes in the current SVE vector length, ensuring all accumulated\n        // values are summed.\n        dst[i] = svaddv_f32(svwhilelt_b32(0, svcntw()), sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    // Loop through each row of the matrix\n    for (size_t i = 0; i < m; ++i) {\n        // Initialize a vector accumulator for the dot product of the current row\n        // with the vector 'vec'.\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Pointer to the start of the current row in the flattened matrix\n        const float* current_row_ptr = &mat[i * n];\n\n        // Loop through the columns (elements of the current row and vector 'vec')\n        // using SVE vector operations.\n        // The loop increments by svcntw() which is the number of float elements\n        // that fit into an SVE vector register.\n        for (size_t j = 0; j < n; j += svcntw()) {\n            // Create a predicate for the current vector chunk.\n            // This ensures that we only process valid elements, especially for the\n            // last chunk if 'n' is not a multiple of svcntw().\n            svbool_t pg = svwhilelt_b32(j, n);\n\n            // Load a vector chunk from the current row of 'mat'.\n            svfloat32_t mat_val = svld1_f32(pg, current_row_ptr + j);\n\n            // Load a vector chunk from 'vec'.\n            svfloat32_t vec_val = svld1_f32(pg, vec + j);\n\n            // Perform element-wise multiplication of the loaded chunks.\n            svfloat32_t prod = svmul_f32(mat_val, vec_val);\n\n            // Accumulate the products into sum_vec.\n            sum_vec = svadd_f32(sum_vec, prod);\n        }\n\n        // After processing all chunks for the current row, perform a horizontal\n        // sum (reduction) on the accumulated vector to get the final scalar result\n        // for dst[i].\n        // svptrue_b32() creates a predicate that is true for all elements,\n        // ensuring all elements in sum_vec are included in the reduction.\n        dst[i] = svaddv_f32(svptrue_b32(), sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    // Iterate over each row of the matrix\n    for (size_t i = 0; i < m; ++i) {\n        // Initialize a vector register to accumulate the dot product for the current row.\n        // All lanes are set to 0.0f.\n        svfloat32_t row_sum_vec = svdup_f32(0.0f);\n\n        // Pointer to the start of the current row in the flattened matrix\n        const float* current_row_ptr = &mat[i * n];\n\n        // Loop through the columns (elements of vec) using SVE vectors\n        size_t j = 0;\n        svbool_t pg; // Predicate register for active lanes\n\n        // Loop while 'j' is less than 'n' (total columns)\n        while (j < n) {\n            // Generate a predicate for the current vector chunk.\n            // It will be true for lanes where 'j + lane_idx' < 'n'.\n            pg = svwhilelt_b32(j, n);\n\n            // Load a vector from the current row of 'mat'\n            svfloat32_t mat_val = svld1_f32(pg, current_row_ptr + j);\n\n            // Load a vector from 'vec'\n            svfloat32_t vec_val = svld1_f32(pg, vec + j);\n\n            // Perform fused multiply-add: row_sum_vec += mat_val * vec_val\n            // This accumulates the products into row_sum_vec.\n            row_sum_vec = svmla_f32(row_sum_vec, mat_val, vec_val);\n\n            // Increment 'j' by the number of elements processed in this SVE vector length (VL).\n            // svcntw() returns the number of 32-bit elements (floats) in an SVE vector.\n            j += svcntw();\n        }\n\n        // After processing all columns for the current row,\n        // horizontally sum all elements in 'row_sum_vec' to get the final scalar dot product.\n        // svptrue_b32() creates a predicate where all lanes are active, ensuring all accumulated\n        // partial sums within the vector are included in the final reduction.\n        dst[i] = svaddv_f32(svptrue_b32(), row_sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    // Get the number of float elements an SVE vector can hold.\n    size_t svl = svcnt_f32();\n\n    for (size_t i = 0; i < m; ++i) {\n        const float* current_mat_row = mat + i * n;\n        svfloat32_t row_sum_vec = svdup_f32(0.0f); // Accumulator for the dot product of the current row\n\n        size_t j = 0;\n        // Process 'n' elements in chunks of 'svl'\n        while (j < n) {\n            // Generate a predicate for the current chunk, ensuring we don't go past 'n'\n            svbool_t p_loop = svwhilelt_b32(j, n);\n\n            // Load elements from the current matrix row\n            svfloat32_t mat_vec = svld1_f32(p_loop, current_mat_row + j);\n\n            // Load elements from the 'vec' vector\n            svfloat32_t vec_vec = svld1_f32(p_loop, vec + j);\n\n            // Perform element-wise multiplication, only for active lanes\n            svfloat32_t prod_vec = svmul_f32_x(p_loop, mat_vec, vec_vec);\n\n            // Accumulate products into row_sum_vec, only for active lanes\n            // Inactive lanes in row_sum_vec retain their previous values (0.0f initially)\n            row_sum_vec = svadd_f32_x(p_loop, row_sum_vec, prod_vec);\n\n            j += svl; // Move to the next chunk\n        }\n\n        // Reduce the accumulated vector sum to a scalar.\n        // svaddv_f32 sums all active elements in the vector.\n        // We use svptrue_v_f32() to ensure all elements in row_sum_vec are summed,\n        // including those that might have been inactive in the last loop iteration.\n        float row_scalar_sum = svaddv_f32(svptrue_v_f32(), row_sum_vec);\n\n        dst[i] = row_scalar_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    // Get the number of float elements that fit into an SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    size_t sv_float_count = svcntw();\n\n    // Loop over each row of the matrix\n    for (size_t i = 0; i < m; ++i) {\n        // Initialize an SVE vector to accumulate the dot product for the current row.\n        // All elements are set to 0.0f.\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Pointer to the beginning of the current row in the flattened matrix.\n        const float* current_row_ptr = &mat[i * n];\n\n        // Loop over the columns, processing 'sv_float_count' elements at a time.\n        // This inner loop computes the dot product of the current matrix row and the vector 'vec'.\n        for (size_t j = 0; j < n; j += sv_float_count) {\n            // Create a predicate for the current vector chunk.\n            // This predicate ensures that we only process valid elements, especially for the tail\n            // of the vector 'vec' if 'n' is not a multiple of 'sv_float_count'.\n            svbool_t pg = svwhilelt_b32(j, n);\n\n            // Load a vector chunk from the current row of the matrix.\n            // Elements beyond 'n' (if any) will be inactive according to 'pg'.\n            svfloat32_t mat_val = svld1(pg, current_row_ptr + j);\n\n            // Load a vector chunk from the input vector 'vec'.\n            // Elements beyond 'n' (if any) will be inactive according to 'pg'.\n            svfloat32_t vec_val = svld1(pg, vec + j);\n\n            // Perform fused multiply-add: sum_vec = sum_vec + (mat_val * vec_val).\n            // The '_x' suffix indicates that inactive elements in 'sum_vec' are not updated.\n            sum_vec = svmla_f32_x(pg, sum_vec, mat_val, vec_val);\n        }\n\n        // After processing all chunks for the current row, perform a horizontal sum\n        // of all elements in 'sum_vec' to get the final scalar dot product result.\n        // svptrue_b32() creates an all-true predicate, ensuring all elements in sum_vec are summed.\n        dst[i] = svaddv_f32(svptrue_b32(), sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n\n    // Initialize an SVE vector to accumulate sums.\n    // All lanes are set to 0.0.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    // Loop through the matrix elements in SVE vector chunks.\n    // The loop continues as long as there are elements remaining to process.\n    size_t i = 0;\n    while (i < total_elements) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b64 generates a predicate that is true for elements\n        // starting from 'i' up to, but not including, 'total_elements'.\n        // This handles the tail (remaining elements) automatically in the last iteration.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load a vector of doubles from the matrix using the predicate.\n        // Elements corresponding to 'false' in the predicate are loaded as zero.\n        svfloat64_t data = svld1_f64(pg, &mat[i]);\n\n        // Add the loaded vector to the accumulating sum vector.\n        sum_vec = svadd_f64(sum_vec, data);\n\n        // Advance the index by the number of elements in an SVE double vector.\n        // svcntd() returns the number of double elements per SVE vector.\n        i += svcntd();\n    }\n\n    // Reduce the SVE sum vector to a single scalar sum.\n    // svptrue_b64() creates a predicate where all elements are true,\n    // ensuring all elements of sum_vec are included in the reduction.\n    double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n    // Calculate the average by dividing the total sum by the total number of elements.\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n\n    // Initialize an SVE vector to accumulate the sum of elements.\n    // All lanes are initialized to 0.0.\n    svfloat64_t sv_sum = svdup_f64(0.0);\n\n    // Pointer to iterate through the matrix elements.\n    const double* current_ptr = mat;\n\n    // Loop counter for the number of elements processed.\n    size_t i = 0;\n\n    // Predicate register for SVE operations.\n    svbool_t pg;\n\n    // Process elements in chunks of SVE vector length.\n    // The loop continues as long as there are elements remaining to be processed.\n    while (i < total_elements) {\n        // Generate a predicate for the current chunk of elements.\n        // This predicate will be true for 'vl' elements or for the remaining\n        // elements if less than 'vl' are left.\n        pg = svwhilelt_b64(i, total_elements);\n\n        // Load elements from memory into an SVE vector using the generated predicate.\n        // Only active lanes (where pg is true) will load data; inactive lanes\n        // will remain unchanged (or be zeroed depending on the instruction variant,\n        // but for svld1, it's typically zeroed or left undefined for inactive lanes\n        // if not explicitly masked, but here it's used with a predicate).\n        svfloat64_t sv_data = svld1_f64(pg, current_ptr);\n\n        // Add the loaded vector to the accumulated sum vector.\n        // This operation is performed element-wise across the vector lanes.\n        sv_sum = svadd_f64(sv_sum, sv_data);\n\n        // Advance the loop counter by the number of elements in an SVE vector (for double).\n        // svcntd() returns the number of 64-bit floating-point elements that fit in an SVE vector.\n        i += svcntd();\n\n        // Advance the pointer to the next chunk of elements.\n        current_ptr += svcntd();\n    }\n\n    // Perform a horizontal sum reduction on the SVE sum vector.\n    // This sums all elements within the sv_sum vector into a single double value.\n    // A full predicate (true for all lanes) is used for the reduction.\n    double total_sum = svaddv_f64(svwhilelt_b64(0, svcntd()), sv_sum);\n\n    // Calculate the average.\n    // The problem states the matrix is non-empty, so total_elements will be > 0.\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n\n    // Handle the case of an empty matrix, though the description states non-empty.\n    if (total_elements == 0) {\n        return 0.0;\n    }\n\n    // Initialize an SVE vector to accumulate the sum of elements.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    // Loop through the matrix elements, processing them in SVE vector chunks.\n    // The svwhilelt_b64 intrinsic generates a predicate for the current chunk,\n    // handling both full vectors and the remaining \"tail\" elements.\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        // Generate a predicate for the current vector load.\n        // It will be true for elements from 'i' up to 'total_elements - 1'.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // Load elements from the matrix into an SVE vector using the predicate.\n        // Elements where the predicate is false will not be loaded (or loaded as 0 depending on implementation).\n        svfloat64_t data_vec = svld1_f64(pg, mat + i);\n\n        // Add the loaded vector to the accumulating sum vector.\n        sum_vec = svadd_f64(sum_vec, data_vec);\n    }\n\n    // Perform a horizontal sum of all elements in the sum_vec to get the total sum.\n    // svptrue_b64() ensures all lanes of sum_vec are included in the reduction.\n    double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n    // Calculate the average by dividing the total sum by the number of elements.\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c++\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n\n    // Initialize an SVE vector for accumulating the sum.\n    // All lanes are initialized to 0.0.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    // Loop through the matrix elements in chunks of SVE vector length.\n    // svcntd() returns the number of double-precision elements in an SVE vector.\n    size_t i = 0;\n    do {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the matrix, especially for the last partial vector.\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n\n        // If no elements are active in the predicate, we've processed all elements.\n        // This check is important for the 'do-while' loop termination.\n        if (!svptest_any(svptrue_b64(), pg)) {\n            break;\n        }\n\n        // Load data into an SVE vector using the predicate.\n        // Only active lanes are loaded from 'mat + i'.\n        // Inactive lanes in 'data_vec' will be unpredictable, but this is fine\n        // because they will not be used by the masked addition.\n        svfloat64_t data_vec = svld1_f64(pg, mat + i);\n\n        // Add the loaded vector to the sum accumulator using a masked operation.\n        // sum_vec[j] = (pg[j]) ? (sum_vec[j] + data_vec[j]) : sum_vec[j];\n        // This ensures that only active lanes contribute to the sum, and inactive\n        // lanes of sum_vec remain unchanged from their previous value.\n        sum_vec = svadd_f64_m(sum_vec, pg, sum_vec, data_vec);\n\n        // Advance the index by the number of elements processed in this vector.\n        i += svcntd();\n    } while (true); // Loop continues until 'svptest_any' breaks it\n\n    // Perform a horizontal sum reduction on the accumulator vector.\n    // svptrue_b64() creates a predicate where all elements are active,\n    // ensuring all lanes of sum_vec are included in the final sum.\n    double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n    // Calculate the average.\n    // The problem states the matrix is non-empty, so total_elements will be >= 1.\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c++\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n\n    // Initialize an SVE vector to accumulate the sum\n    svfloat64_t vec_sum = svdup_f64(0.0);\n\n    // Get the number of double elements an SVE vector can hold\n    size_t sv_vec_len = svcntd();\n\n    size_t i = 0;\n\n    // Process the matrix in full SVE vector chunks\n    // The loop condition ensures we only process chunks that fit entirely within the matrix\n    for (; i + sv_vec_len <= total_elements; i += sv_vec_len) {\n        // Load a full SVE vector of doubles from the matrix\n        // svptrue_b64() creates a predicate that is true for all lanes\n        svfloat64_t data = svld1_f64(svptrue_b64(), &mat[i]);\n        \n        // Add the loaded vector to the accumulating sum vector\n        vec_sum = svadd_f64(vec_sum, data);\n    }\n\n    // Process any remaining elements (tail of the matrix)\n    // This handles cases where total_elements is not a multiple of sv_vec_len\n    if (i < total_elements) {\n        // Create a predicate for the remaining elements\n        // svwhilelt_b64(i, total_elements) generates a predicate that is true for\n        // elements from 'i' up to 'total_elements - 1'\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load the remaining elements using the generated predicate\n        svfloat64_t data = svld1_f64(pg, &mat[i]);\n        \n        // Add these elements to the accumulating sum vector\n        vec_sum = svadd_f64(vec_sum, data);\n    }\n\n    // Perform a horizontal sum reduction on the SVE sum vector\n    // svaddv_f64 sums all active elements in the vector into a single scalar double\n    double total_scalar_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    // Calculate the average by dividing the total sum by the total number of elements\n    return total_scalar_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h> // For size_t\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    if (cols <= 1) {\n        return true;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 0; j < cols - 1; ) {\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            svint32_t vec_curr = svld1_s32(pg, row_ptr + j);\n            svint32_t vec_next = svld1_s32(pg, row_ptr + j + 1);\n\n            svbool_t unsorted_predicate;\n            if (ascending) {\n                unsorted_predicate = svcmpgt_s32(pg, vec_curr, vec_next);\n            } else {\n                unsorted_predicate = svcmplt_s32(pg, vec_curr, vec_next);\n            }\n\n            if (svptest_any(pg, unsorted_predicate)) {\n                return false;\n            }\n\n            j += svcntw();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c++\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    // A matrix with 0 or 1 column is always considered sorted.\n    if (cols <= 1) {\n        return true;\n    }\n\n    // Get the number of 32-bit integers that fit in an SVE vector.\n    // This value is determined at runtime and depends on the SVE implementation.\n    const size_t svl = svcntw();\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row_ptr = matrix + r * cols;\n        const bool ascending = directions[r];\n        bool row_is_sorted = true; // Assume the current row is sorted until proven otherwise\n\n        // The number of comparisons needed for a row of 'cols' elements is 'cols - 1'.\n        // We compare element[i] with element[i+1] for i from 0 to cols-2.\n        const size_t num_comparisons = cols - 1;\n\n        // Iterate through the row, processing elements in SVE vector chunks.\n        for (size_t i = 0; i < num_comparisons; i += svl) {\n            // Create a predicate for the current vector operation.\n            // This predicate ensures we only process valid elements up to 'num_comparisons - 1'.\n            svbool_t pg = svwhilelt_b32(i, num_comparisons);\n\n            // If the predicate is empty (no active lanes), it means we have processed all\n            // elements for this row, so we can break out of the inner loop.\n            if (svptest_any(svptrue_b32(), pg) == 0) {\n                break;\n            }\n\n            // Load the current set of elements (matrix[i], matrix[i+1], ...)\n            svint32_t current_elements = svld1_s32(pg, row_ptr + i);\n\n            // Load the next set of elements (matrix[i+1], matrix[i+2], ...)\n            svint32_t next_elements = svld1_s32(pg, row_ptr + i + 1);\n\n            svbool_t comparison_result_predicate;\n            if (ascending) {\n                // For ascending order, check if current_elements <= next_elements\n                comparison_result_predicate = svcmple_s32(pg, current_elements, next_elements);\n            } else {\n                // For descending order, check if current_elements >= next_elements\n                comparison_result_predicate = svcmge_s32(pg, current_elements, next_elements);\n            }\n\n            // Check if all active elements in the current vector comparison passed the sort condition.\n            // svptest_all returns true if all active lanes in 'pg' are true in 'comparison_result_predicate'.\n            if (!svptest_all(pg, comparison_result_predicate)) {\n                row_is_sorted = false;\n                break; // This row is not sorted, no need to check further elements in this row.\n            }\n        }\n\n        // If we found that the current row is not sorted, we can immediately return false.\n        if (!row_is_sorted) {\n            return false;\n        }\n    }\n\n    // If we've checked all rows and none were found to be unsorted, the matrix is sorted correctly.\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n#include <stdbool.h> // For bool\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    // Iterate over each row in the matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Calculate the starting address of the current row\n        const int* current_row = matrix + i * cols;\n        // Determine the sorting direction for the current row\n        bool is_ascending = directions[i];\n\n        // A row with 0 or 1 element is always considered sorted.\n        // In such cases, there are no adjacent pairs to compare.\n        if (cols <= 1) {\n            continue;\n        }\n\n        // Flag to track if the current row is sorted.\n        // It's assumed true until a violation is found.\n        bool row_is_sorted = true;\n\n        // Iterate through the elements of the current row using SVE intrinsics.\n        // We need to compare current_row[j] with current_row[j+1].\n        // The loop runs for 'j' from 0 up to 'cols - 2' (inclusive),\n        // as the last comparison is between current_row[cols-2] and current_row[cols-1].\n        for (size_t j = 0; j < cols - 1; /* j is incremented by svcntw() inside the loop */) {\n            // Generate a predicate for the current vector chunk.\n            // svwhilelt_b32(j, cols - 1) creates a predicate that is true for elements 'k'\n            // such that 'j <= k < cols - 1'. This correctly covers all necessary comparisons\n            // up to the (cols-2) vs (cols-1) pair.\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n\n            // If the predicate is empty (no active elements), it means we have processed\n            // all relevant elements in the row, so we can break the loop.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load a vector of 32-bit integers starting at current_row[j].\n            svint32_t vec_a = svld1_s32(pg, current_row + j);\n            // Load a vector of 32-bit integers starting at current_row[j+1].\n            // This creates the shifted vector needed for adjacent comparisons.\n            svint32_t vec_b = svld1_s32(pg, current_row + j + 1);\n\n            svbool_t comparison_result;\n            if (is_ascending) {\n                // For ascending order, elements must be less than or equal to the next element (a <= b).\n                comparison_result = svcmple_s32(pg, vec_a, vec_b);\n            } else {\n                // For descending order, elements must be greater than or equal to the next element (a >= b).\n                comparison_result = svcmpge_s32(pg, vec_a, vec_b);\n            }\n\n            // Check if all active elements in the 'comparison_result' predicate are true.\n            // If svptest_all returns false, it means at least one comparison failed within this vector chunk,\n            // indicating the row is not sorted according to the specified direction.\n            if (!svptest_all(pg, comparison_result)) {\n                row_is_sorted = false;\n                break; // This row is not sorted, no need to check further elements in this row.\n            }\n\n            // Advance 'j' by the number of 32-bit elements processed in this vector.\n            // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n            j += svcntw();\n        }\n\n        // If the current row was found to be unsorted, we can immediately return false\n        // as the overall condition (all rows sorted) is not met.\n        if (!row_is_sorted) {\n            return false;\n        }\n    }\n\n    // If the loop completes without finding any unsorted rows, it means all rows\n    // are sorted according to their specified directions.\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    // If cols is 0 or 1, any row is considered sorted by definition.\n    // The comparison loop will correctly not execute.\n    if (cols <= 1) {\n        return true;\n    }\n\n    // Number of comparisons needed per row is cols - 1.\n    const size_t num_comparisons_per_row = cols - 1;\n\n    for (size_t row_idx = 0; row_idx < rows; ++row_idx) {\n        const int* row_ptr = matrix + row_idx * cols;\n        bool ascending = directions[row_idx];\n\n        // Iterate through the row using SVE for comparisons\n        // 'i' represents the starting index for the current vector of elements to compare.\n        // We need to compare elements at index 'i' with elements at 'i+1'.\n        for (size_t i = 0; i < num_comparisons_per_row; i += svcntw()) {\n            // Create a predicate for the current vector chunk.\n            // This predicate ensures we only process elements within the valid range [i, num_comparisons_per_row - 1].\n            svbool_t pg = svwhilelt_b32(i, num_comparisons_per_row);\n\n            // Load the current elements (e.g., [e0, e1, e2, ...])\n            svint32_t v_curr = svld1_s32(pg, row_ptr + i);\n            // Load the next elements (e.g., [e1, e2, e3, ...])\n            svint32_t v_next = svld1_s32(pg, row_ptr + i + 1);\n\n            svbool_t violation_predicate;\n            if (ascending) {\n                // For ascending order, we expect v_curr <= v_next.\n                // A violation occurs if v_curr > v_next.\n                violation_predicate = svcmpgt_s32(pg, v_curr, v_next);\n            } else {\n                // For descending order, we expect v_curr >= v_next.\n                // A violation occurs if v_curr < v_next.\n                violation_predicate = svcmplt_s32(pg, v_curr, v_next);\n            }\n\n            // Check if any active lane in the current vector chunk violates the sort order.\n            // svptest_any returns true if any element under the predicate 'pg' in 'violation_predicate' is true.\n            if (svptest_any(pg, violation_predicate)) {\n                return false; // Found a violation, the matrix is not sorted as required.\n            }\n        }\n    }\n\n    // All rows passed the sorting verification.\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    // A matrix with 0 or 1 column is always considered sorted.\n    // The problem states non-empty matrix, so rows >= 1, cols >= 1.\n    if (cols <= 1) {\n        return true;\n    }\n\n    // Get the number of 32-bit integer elements in an SVE vector.\n    // This value is constant for a given SVE implementation.\n    const size_t sv_vec_len_int32 = svcntw();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = matrix + i * cols;\n        bool is_ascending = directions[i];\n\n        // Loop through the elements of the current row to compare adjacent elements.\n        // We need to compare element `j` with element `j+1`.\n        // So, `j` goes from `0` up to `cols - 2`.\n        // The loop condition `j < cols - 1` ensures that `j+1` is always a valid index.\n        for (size_t j = 0; j < cols - 1; /* increment inside loop */) {\n            // Create a predicate for the current vector chunk.\n            // `svwhilelt_b32(j, cols - 1)` generates a predicate that is true for elements\n            // `j, j+1, ..., k` as long as `k < cols - 1`.\n            // This ensures that for each active element `k` in the vector, both `row_ptr[k]`\n            // and `row_ptr[k+1]` are valid memory accesses within the row.\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n\n            // If the predicate is all false, it means we have processed all relevant elements\n            // in the row, or there are no more elements to process.\n            if (svptest_any(svptrue_b32(), pg) == 0) {\n                break;\n            }\n\n            // Load the current elements and the next elements into SVE vectors.\n            // `current_elements` will contain `row_ptr[j], row_ptr[j+1], ...`\n            // `next_elements` will contain `row_ptr[j+1], row_ptr[j+2], ...`\n            svint32_t current_elements = svld1_s32(pg, row_ptr + j);\n            svint32_t next_elements = svld1_s32(pg, row_ptr + j + 1);\n\n            svbool_t violation_mask;\n            if (is_ascending) {\n                // For ascending order, a violation occurs if `current_element > next_element`.\n                violation_mask = svcmpgt(pg, current_elements, next_elements);\n            } else {\n                // For descending order, a violation occurs if `current_element < next_element`.\n                violation_mask = svcmplt(pg, current_elements, next_elements);\n            }\n\n            // Check if any violation occurred within this vector chunk.\n            // `svptest_any(pg, violation_mask)` returns true if any active element\n            // (i.e., element covered by `pg`) in `violation_mask` is true.\n            if (svptest_any(pg, violation_mask)) {\n                return false; // A violation was found, the row is not sorted.\n            }\n\n            // Move to the next vector chunk.\n            j += sv_vec_len_int32;\n        }\n    }\n\n    // If all rows were processed without finding any violations, the matrix is sorted correctly.\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    // Broadcast the base value to an SVE vector of int16_t\n    svint16_t sv_base = svdup_s16(base);\n    // Broadcast zero and one for comparisons and adjustments\n    svint16_t sv_zero = svdup_s16(0);\n    svint16_t sv_one = svdup_s16(1);\n\n    while (i < length) {\n        // Get the predicate for the current vector length\n        // This ensures we only process up to 'length' elements\n        svbool_t pg = svwhilelt_b16(i, length);\n        \n        // Load a vector of 16-bit integers from the source array\n        svint16_t src_vec = svld1_s16(pg, src + i);\n\n        // Perform signed integer division (truncates towards zero)\n        svint16_t q_vec = svdiv_s16(pg, src_vec, sv_base);\n        \n        // Calculate the remainder\n        svint16_t r_vec = svrem_s16(pg, src_vec, sv_base);\n\n        // Determine the predicate for elements that need quotient adjustment.\n        // An adjustment is needed if src_vec is negative AND the remainder is non-zero.\n        // This ensures that svdiv_s16 (truncating division) behaves like floor division.\n        svbool_t src_neg_pred = svcmplt_s16(pg, src_vec, sv_zero); // src_vec < 0\n        svbool_t rem_nonzero_pred = svcmpne_s16(pg, r_vec, sv_zero); // r_vec != 0\n        \n        // Combine the two conditions: (src_vec < 0) && (r_vec != 0)\n        svbool_t adjust_pred = svand_b(src_neg_pred, rem_nonzero_pred);\n\n        // Conditionally subtract 1 from the quotient for elements where adjust_pred is true.\n        // For inactive lanes or lanes where adjust_pred is false, q_vec remains unchanged.\n        q_vec = svsub_s16_m(q_vec, adjust_pred, q_vec, sv_one);\n\n        // Multiply the adjusted quotient by base to get the desired multiple\n        svint16_t dst_vec = svmul_s16(pg, q_vec, sv_base);\n\n        // Store the result vector to the destination array\n        svst1_s16(pg, dst + i, dst_vec);\n\n        // Increment the loop counter by the number of elements processed in this iteration\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svint16_t sv_base = svdup_s16(base);\n\n    do {\n        // Get the predicate for the current vector chunk\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // If no elements are active in the predicate, break the loop\n        if (!svptest_any(svptrue_b16(), pg)) {\n            break;\n        }\n\n        // Load source elements into an SVE vector\n        svint16_t x_vec = svld1_s16(pg, src + i);\n\n        // Calculate quotient and remainder\n        svint16_t quotient_vec = svdiv_s16(x_vec, sv_base);\n        svint16_t remainder_vec = svmod_s16(x_vec, sv_base);\n\n        // Determine the correction needed for negative numbers not perfectly divisible by base\n        // Condition: (x < 0) AND (remainder != 0)\n        svbool_t pg_x_neg = svcmplt_s16(pg, x_vec, svdup_s16(0));\n        svbool_t pg_rem_nonzero = svcmpne_s16(pg, remainder_vec, svdup_s16(0));\n        svbool_t pg_condition_for_minus_one = svand_b(pg, pg_x_neg, pg_rem_nonzero);\n\n        // Create a vector of 1s where correction is needed, 0s otherwise\n        svint16_t correction_vec = svsel_s16(pg_condition_for_minus_one, svdup_s16(1), svdup_s16(0));\n\n        // Adjust the quotient: subtract 1 if correction is needed\n        svint16_t adjusted_quotient_vec = svsub_s16(quotient_vec, correction_vec);\n\n        // Calculate the final result: (adjusted_quotient) * base\n        svint16_t result_vec = svmul_s16(adjusted_quotient_vec, sv_base);\n\n        // Store the results into the destination array\n        svst1_s16(pg, dst + i, result_vec);\n\n        // Increment the loop counter by the number of 16-bit elements in a vector\n        i += svcntw();\n    } while (true); // Loop indefinitely until explicitly broken\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n#include <stdint.h> // For int16_t, uint8_t\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    // Convert the 8-bit unsigned base to a 16-bit signed integer for SVE operations.\n    // The problem states base is greater than 0, so it will always be positive.\n    int16_t s16_base = (int16_t)base;\n    // Duplicate the 16-bit base value into all lanes of an SVE vector.\n    svint16_t sv_base = svdup_s16(s16_base);\n\n    // Loop through the arrays in chunks determined by the SVE vector length (VL).\n    // svwhilelt_b16 generates a predicate for 16-bit elements, active for indices < length.\n    // svptest_any checks if any lane in the predicate is active, indicating more work to do.\n    for (svbool_t pg = svwhilelt_b16(i, length); svptest_any(pg, pg); i += svcnt_s16()) {\n        // Load a vector of 16-bit integers from the source array.\n        // The predicate 'pg' ensures only valid elements are loaded, handling the tail.\n        svint16_t sv_src = svld1_s16(pg, &src[i]);\n\n        // Calculate the remainder of sv_src divided by sv_base.\n        // In C/C++, the result of '%' has the same sign as the dividend.\n        // svrem_s16_x performs the remainder operation on all active lanes.\n        svint16_t remainder = svrem_s16_x(pg, sv_src, sv_base);\n\n        // Adjust the remainder to be non-negative, then take modulo base again.\n        // This effectively computes (a % b + b) % b, which correctly handles negative 'a'\n        // to give a positive remainder in the range [0, b-1].\n        svint16_t remainder_plus_base = svadd_s16_x(pg, remainder, sv_base);\n        svint16_t positive_remainder = svrem_s16_x(pg, remainder_plus_base, sv_base);\n\n        // Subtract this positive remainder from the source value.\n        // This operation (src - positive_remainder) correctly computes floor(src / base) * base,\n        // which is the largest multiple of 'base' that is less than or equal to 'src'.\n        svint16_t sv_dst = svsub_s16_x(pg, sv_src, positive_remainder);\n\n        // Store the resulting vector of 16-bit integers into the destination array.\n        // The predicate 'pg' ensures only valid elements are stored, handling the tail.\n        svst1_s16(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    // Duplicate the base value into an SVE vector of 16-bit integers.\n    // This vector will be used for all lane operations.\n    svint16_t sv_base = svdup_s16(base);\n    // Duplicate zero into an SVE vector for comparisons.\n    svint16_t sv_zero = svdup_s16(0);\n\n    // Loop through the arrays in chunks determined by the SVE vector length.\n    // svcntw() returns the number of 16-bit elements in an SVE vector.\n    for (i = 0; i < length; i += svcntw()) {\n        // Generate a predicate for the current vector chunk.\n        // This ensures that operations only apply to valid elements within the array bounds.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load a vector of 16-bit integers from the source array.\n        svint16_t src_vec = svld1_s16(pg, src + i);\n\n        // Calculate the remainder for each element: src_vec % sv_base.\n        // SVE's svmod_s16 follows C's behavior for integer modulo (remainder has same sign as dividend).\n        svint16_t remainder_vec = svmod_s16(pg, src_vec, sv_base);\n\n        // Calculate the initial result: src_vec - remainder_vec.\n        // This gives a multiple of base, but might be greater than src_vec for negative src_vec.\n        svint16_t result_vec = svsub_s16(pg, src_vec, remainder_vec);\n\n        // Determine which lanes need adjustment. An adjustment is needed if:\n        // 1. The remainder is not zero (meaning src_vec is not already a multiple of base).\n        // 2. The original src_vec value is negative.\n        // In this case, (src_vec - remainder_vec) would be the next multiple *above* src_vec,\n        // so we need to subtract 'base' to get the multiple *below* or equal to src_vec.\n\n        // Predicate for (remainder != 0)\n        svbool_t p_rem_ne_0 = svcmpne_s16(pg, remainder_vec, sv_zero);\n        \n        // Predicate for (src < 0)\n        svbool_t p_src_lt_0 = svcmplt_s16(pg, src_vec, sv_zero);\n\n        // Combine the two predicates using logical AND.\n        // This predicate 'p_adjust' will be true only for lanes that require adjustment.\n        svbool_t p_adjust = svand_b(p_rem_ne_0, p_src_lt_0);\n\n        // Apply the adjustment: subtract 'base' from 'result_vec' only where 'p_adjust' is true.\n        // The svsub_s16(predicate, op1, op2) intrinsic performs op1 - op2 for active lanes\n        // (where predicate is true) and leaves op1 unchanged for inactive lanes.\n        result_vec = svsub_s16(p_adjust, result_vec, sv_base);\n\n        // Store the calculated results into the destination array.\n        svst1_s16(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    // Duplicate the base value into an SVE vector of 16-bit integers\n    svint16_t sv_base = svdup_s16((int16_t)base);\n    // Duplicate zero and one for comparisons and subtractions\n    svint16_t sv_zero = svdup_s16(0);\n    svint16_t sv_one = svdup_s16(1);\n\n    // Loop while the current index 'i' is less than 'length'\n    // svwhilelt_b16 generates a predicate for 16-bit elements\n    for (svbool_t pg = svwhilelt_b16(i, length); svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        // Load a vector of 16-bit integers from the source array\n        svint16_t sv_src = svld1_s16(pg, &src[i]);\n\n        // Perform integer division: quotient = src / base (truncates towards zero)\n        // _x suffix means the operation is predicated, inactive lanes are not computed\n        svint16_t sv_quotient = svdiv_s16_x(pg, sv_src, sv_base);\n\n        // Calculate the remainder: remainder = src % base\n        svint16_t sv_remainder = svrem_s16_x(pg, sv_src, sv_base);\n\n        // Determine the condition for decrementing the quotient to achieve floor division:\n        // (remainder != 0) AND (src < 0)\n        svbool_t cond_rem_ne_0 = svcmpne_s16(pg, sv_remainder, sv_zero);\n        svbool_t cond_src_lt_0 = svcmplt_s16(pg, sv_src, sv_zero);\n        svbool_t final_cond = svand_b(cond_rem_ne_0, cond_src_lt_0);\n\n        // Conditionally decrement the quotient for lanes where final_cond is true.\n        // For inactive lanes of final_cond, sv_quotient remains unchanged.\n        sv_quotient = svsub_s16_x(final_cond, sv_quotient, sv_one);\n\n        // Calculate the final result: result = floor(src / base) * base\n        svint16_t sv_result = svmul_s16_x(pg, sv_quotient, sv_base);\n\n        // Store the result vector into the destination array\n        svst1_s16(pg, &dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Iterate over each row of the matrix\n    for (size_t r = 0; r < rows; ++r) {\n        const double* current_row_ptr = matrix + r * cols;\n        bool current_row_fully_matches = true;\n\n        // Loop through the columns, processing `double` elements in SVE vector chunks\n        size_t c = 0;\n        // Generate a predicate for the first chunk of elements.\n        // This predicate will be active for elements from 'c' up to 'cols - 1'.\n        svbool_t pg = svwhilelt_b64(c, cols);\n\n        // Continue processing as long as there are active elements in the predicate.\n        // svptest_any(svptrue_b64(), pg) checks if any bit in 'pg' is set,\n        // indicating there are still elements to process in the current row.\n        while (svptest_any(svptrue_b64(), pg)) {\n            // Load a vector of doubles from the current row using the predicate 'pg'.\n            svfloat64_t row_vec = svld1_f64(pg, current_row_ptr + c);\n            // Load a vector of doubles from the target vector using the predicate 'pg'.\n            svfloat64_t target_vec = svld1_f64(pg, vector + c);\n\n            // Compare the loaded vectors element-wise for equality.\n            // The result is a predicate where active elements are true if they match.\n            svbool_t cmp_result = svcmpeq_f64(pg, row_vec, target_vec);\n\n            // Check if ALL active elements in the comparison result are true.\n            // If even one active element did not match, this chunk does not fully match.\n            if (!svptest_all(pg, cmp_result)) {\n                current_row_fully_matches = false; // Mismatch found in this chunk\n                break; // No need to check further elements in this row\n            }\n\n            // Advance the column index by the number of doubles processed in one SVE vector.\n            c += svcntd();\n            // Generate the predicate for the next chunk of elements.\n            pg = svwhilelt_b64(c, cols);\n        }\n\n        // If after checking all chunks, the current row still fully matches,\n        // then we found a matching row.\n        if (current_row_fully_matches) {\n            return true; // Found a matching row, exit early\n        }\n    }\n\n    // If the loop completes without finding any matching row, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Get the number of double elements that fit into an SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    const size_t sv_doubles = svcntd();\n\n    // Iterate through each row of the matrix.\n    for (size_t i = 0; i < rows; ++i) {\n        const double* current_row_ptr = matrix + i * cols;\n        bool current_row_matches = true; // Assume the current row matches the vector initially.\n\n        // Iterate through the columns of the current row in SVE vector chunks.\n        for (size_t col_idx = 0; col_idx < cols; col_idx += sv_doubles) {\n            // Create a predicate for the current SVE vector operation.\n            // svwhilelt_b64 generates a predicate that is true for elements\n            // where the index (starting from col_idx) is less than 'cols'.\n            // This handles the loop tail (when remaining elements are fewer than sv_doubles).\n            svbool_t pg = svwhilelt_b64(col_idx, cols);\n\n            // Check if there are any active elements in the current predicate.\n            // If not, it means we have processed all columns for this row.\n            if (svptest_any(svptrue_b64(), pg) == 0) {\n                break; // No active elements, finished with this row.\n            }\n\n            // Load segments of the vector and the current matrix row into SVE registers.\n            // The predicate 'pg' ensures that only valid elements are loaded,\n            // and elements beyond 'cols' are not accessed.\n            svfloat64_t vec_segment = svld1_f64(pg, vector + col_idx);\n            svfloat64_t mat_segment = svld1_f64(pg, current_row_ptr + col_idx);\n\n            // Compare the loaded segments for equality element-wise.\n            // The comparison is performed only for elements enabled by 'pg'.\n            svbool_t cmp_result = svcmpeq_f64(pg, vec_segment, mat_segment);\n\n            // Check if all *active* elements in the current chunk are equal.\n            // svptest_all(pg, cmp_result) returns true if all elements enabled by 'pg'\n            // in 'cmp_result' are true (i.e., all active elements matched).\n            if (svptest_all(pg, cmp_result) == 0) {\n                // If even one active element in this chunk does not match,\n                // then the entire row does not match the vector.\n                current_row_matches = false;\n                break; // No need to check further chunks for this row.\n            }\n        }\n\n        // After checking all chunks for the current row, if it still matches,\n        // we have found a matching row.\n        if (current_row_matches) {\n            return true; // Return true immediately.\n        }\n    }\n\n    // If the loop completes without finding any matching row, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const double* current_row_ptr = matrix + r * cols;\n        bool current_row_fully_matches = true;\n\n        for (size_t c = 0; c < cols; ) {\n            svbool_t pg = svwhilelt_b64(c, cols);\n\n            // If no elements are active in this predicate, we've processed all columns\n            if (svptest_any(svptrue_b64(), pg) == 0) {\n                break;\n            }\n\n            svfloat64_t row_chunk = svld1(pg, current_row_ptr + c);\n            svfloat64_t vector_chunk = svld1(pg, vector + c);\n\n            svbool_t cmp_eq = svcmpeq(pg, row_chunk, vector_chunk);\n\n            // If not all active elements in the current chunk matched, this row does not fully match\n            if (!svptest_all(pg, cmp_eq)) {\n                current_row_fully_matches = false;\n                break; // No need to check further columns for this row\n            }\n\n            c += svcntd(); // Advance column index by the number of doubles in an SVE vector\n        }\n\n        if (current_row_fully_matches) {\n            return true; // Found a matching row\n        }\n    }\n\n    return false; // No matching row found after checking all rows\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Iterate through each row of the matrix\n    for (size_t r = 0; r < rows; ++r) {\n        const double* current_row = matrix + r * cols;\n        bool current_row_is_match = true; // Assume current row matches until proven otherwise\n\n        // Loop through columns in chunks of SVE vector length\n        // svcntd() returns the number of 64-bit double elements that fit in an SVE vector.\n        for (size_t c = 0; c < cols; c += svcntd()) {\n            // Generate a predicate for the current chunk.\n            // This predicate ensures that operations only apply to valid elements\n            // within the bounds of 'cols', especially for the last chunk.\n            svbool_t pg = svwhilelt_b64(c, cols);\n\n            // Load a chunk of the current matrix row into an SVE vector register.\n            svfloat64_t sv_row_chunk = svld1_f64(pg, current_row + c);\n            // Load a chunk of the target vector into an SVE vector register.\n            svfloat64_t sv_vec_chunk = svld1_f64(pg, vector + c);\n\n            // Compare elements for equality.\n            // The result is a predicate where true indicates equality for that lane.\n            svbool_t cmp_result = svcmpeq_f64(pg, sv_row_chunk, sv_vec_chunk);\n\n            // Check if any active lane in the comparison result is FALSE (i.e., not equal).\n            // svnot_b(cmp_result) inverts the predicate: true means 'not equal'.\n            // svptest_any(pg, svnot_b(cmp_result)) returns true if any active lane\n            // within the current chunk is 'not equal'.\n            if (svptest_any(pg, svnot_b(cmp_result))) {\n                current_row_is_match = false; // A mismatch found in this row\n                break; // No need to check further elements in this row\n            }\n        }\n\n        // If after checking all chunks, no mismatch was found, then the row matches.\n        if (current_row_is_match) {\n            return true; // Found a matching row in the matrix\n        }\n    }\n\n    // If the loop completes without finding any matching row, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* current_row_ptr = matrix + i * cols;\n        bool current_row_is_match = true;\n\n        // Iterate through the columns using SVE vector operations\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            // Create a predicate for the current chunk, handling tail elements\n            svbool_t pg = svwhilelt_b64(j, cols);\n\n            // Load elements from the current row and the target vector\n            svfloat64_t row_vec = svld1(pg, current_row_ptr + j);\n            svfloat64_t target_vec = svld1(pg, vector + j);\n\n            // Compare the loaded vectors for equality\n            svbool_t cmp_result = svcmpeq(pg, row_vec, target_vec);\n\n            // Check if any active element in the current chunk is NOT equal.\n            // svnot_b(cmp_result) will have 'true' for elements that are not equal.\n            // svany(pg, ...) checks if any of these 'true' values exist within the active elements.\n            if (svany(pg, svnot_b(cmp_result))) {\n                current_row_is_match = false;\n                break; // Mismatch found in this row, no need to check further columns for this row\n            }\n        }\n\n        if (current_row_is_match) {\n            return true; // A matching row was found\n        }\n    }\n\n    return false; // No matching row found after checking all rows\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c++\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n#include <stdint.h> // For uint8_t\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    // Calculate the total number of elements in the flattened tensors.\n    size_t total_elements = 1;\n    for (int i = 0; i < 4; ++i) {\n        total_elements *= dims[i];\n    }\n\n    size_t count = 0; // Initialize the counter for equal elements.\n    size_t i = 0;     // Initialize the loop index.\n\n    // Get the number of 8-bit elements that fit into a single SVE vector.\n    // This value is determined by the current vector length (VL) of the SVE hardware.\n    const size_t sv_vec_len = svcntb();\n\n    // Loop through the arrays in chunks determined by the SVE vector length.\n    // The loop continues as long as there are elements remaining to be processed.\n    while (i < total_elements) {\n        // Generate a predicate for the current vector operation.\n        // svwhilelt_b8(current_index, total_elements) creates a predicate\n        // that is true for elements from 'current_index' up to 'total_elements - 1',\n        // effectively handling full vectors and the remaining tail elements.\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n\n        // Load elements from tensor A into an SVE vector (vec_A).\n        // The load operation is masked by 'pg', ensuring only valid elements are loaded.\n        svuint8_t vec_A = svld1_u8(pg, &A[i]);\n\n        // Load elements from tensor B into an SVE vector (vec_B).\n        // The load operation is masked by 'pg'.\n        svuint8_t vec_B = svld1_u8(pg, &B[i]);\n\n        // Compare the elements of vec_A and vec_B for equality.\n        // The comparison is performed only for active elements defined by 'pg'.\n        // The result is a predicate vector where true indicates equality.\n        svbool_t cmp_result = svcmpeq_u8(pg, vec_A, vec_B);\n\n        // Count the number of active (true) elements in the 'cmp_result' predicate.\n        // The first 'pg' argument ensures that only elements within the currently\n        // processed range are considered for counting.\n        count += svcntp_b8(pg, cmp_result);\n\n        // Advance the index by the full SVE vector length for 8-bit elements.\n        // The 'while' loop condition (i < total_elements) will correctly handle\n        // termination, including the final partial vector.\n        i += sv_vec_len;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = 1;\n    for (int i = 0; i < 4; ++i) {\n        total_elements *= dims[i];\n    }\n\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Loop through the elements using SVE intrinsics.\n    // svcntb() returns the number of 8-bit elements in an SVE vector.\n    // The loop condition and predicate generation handle the main loop and the tail elements efficiently.\n    for (i = 0; i < total_elements; i += svcntb()) {\n        // Generate a predicate for the current vector chunk.\n        // This predicate will be true for elements within the bounds [i, total_elements)\n        // and false for elements out of bounds (useful for handling the tail).\n        svbool_t pg = svwhilelt_b_u8(i, total_elements);\n\n        // Load data from A and B into SVE vectors using the generated predicate.\n        // Elements corresponding to false predicate lanes will not be loaded (or will be zeroed/ignored).\n        svuint8_t va = svld1_u8(pg, &A[i]);\n        svuint8_t vb = svld1_u8(pg, &B[i]);\n\n        // Compare elements for equality. The comparison is masked by 'pg'.\n        // Only active lanes (where pg is true) participate in the comparison.\n        // The result 'cmp_result' is a predicate vector where each lane is true if va[j] == vb[j]\n        // for active lanes, and false otherwise.\n        svbool_t cmp_result = svcmpeq_u8(pg, va, vb);\n\n        // Count the number of active elements in 'cmp_result' that are also active in 'pg'.\n        // This effectively counts the number of equal elements within the current valid chunk.\n        equal_count += svcntp_b(pg, cmp_result);\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Get the vector length in bytes for uint8_t elements\n    // This is equivalent to the number of uint8_t elements per vector\n    const size_t sv_vl = svcntb();\n\n    // Loop through the arrays in chunks of SVE vector length\n    // svwhilelt_b8 generates a predicate that is true for elements\n    // from 'i' up to 'total_elements - 1', handling the tail automatically.\n    for (i = 0; i < total_elements; i += sv_vl) {\n        // Generate a predicate for the current vector operation.\n        // This predicate ensures that operations only apply to valid elements,\n        // especially for the last (tail) chunk.\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n\n        // Load vector chunks from A and B using the generated predicate.\n        // Elements beyond the valid range (in the tail) will not be loaded\n        // or will be loaded with a masked value, depending on the implementation,\n        // but the predicate ensures they don't affect the comparison.\n        svuint8_t vec_A = svld1_u8(pg, &A[i]);\n        svuint8_t vec_B = svld1_u8(pg, &B[i]);\n\n        // Compare the loaded vectors for equality.\n        // The comparison is performed only for active lanes defined by 'pg'.\n        svbool_t cmp_result = svcmpeq_u8(pg, vec_A, vec_B);\n\n        // Count the number of active (true) elements in the comparison result predicate.\n        // The first argument 'pg' ensures that only elements within the current\n        // valid range are considered for counting.\n        equal_count += svcntp_b8(pg, cmp_result);\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For uint8_t\n#include <stddef.h> // For size_t\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (B);\n- An array of 4 size_t integers representing the dimensions of the tensors (dims).\n\nA and B are flattened into 1D arrays.\nYour goal is to count the number of equal elements between the two tensors.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    // Get the number of 8-bit elements in an SVE vector. This can vary at runtime.\n    size_t sv_len = svcntb();\n\n    // Loop through the arrays in chunks of sv_len\n    for (size_t i = 0; i < total_elements; i += sv_len) {\n        // Generate a predicate for the current chunk, handling the tail elements.\n        // 'pg' will be true for elements from 'i' up to 'total_elements - 1'.\n        svbool_t pg = svwhilelt_b(i, total_elements);\n\n        // If no lanes are active in the predicate, it means we've processed all elements.\n        // svptest_any(svptrue_b(), pg) checks if any lane in 'pg' is true.\n        if (!svptest_any(svptrue_b(), pg)) {\n            break;\n        }\n\n        // Load vectors from A and B using the predicate 'pg'.\n        // Only active lanes (where pg is true) will be loaded.\n        svuint8_t vec_A = svld1_u8(pg, &A[i]);\n        svuint8_t vec_B = svld1_u8(pg, &B[i]);\n\n        // Compare elements for equality. The comparison is performed only for active lanes.\n        svbool_t cmp_eq = svcmpeq_u8(pg, vec_A, vec_B);\n\n        // Count the number of true predicates (equal elements) under the active predicate 'pg'.\n        // svcntp_b returns the count of true lanes in 'cmp_eq' that are also true in 'pg'.\n        equal_count += svcntp_b(pg, cmp_eq);\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = 1;\n    for (int i = 0; i < 4; ++i) {\n        total_elements *= dims[i];\n    }\n\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Loop while the current index 'i' is less than the total number of elements\n    while (i < total_elements) {\n        // Get a predicate for the current vector length, active for elements within bounds\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n\n        // Load vector chunks from A and B using the predicate\n        svuint8_t a_vec = svld1_u8(pg, A + i);\n        svuint8_t b_vec = svld1_u8(pg, B + i);\n\n        // Compare elements for equality. The result is a predicate where lanes are true if equal.\n        svbool_t eq_predicate = svcmpeq_u8(pg, a_vec, b_vec);\n\n        // Count the number of active (true) lanes in the equality predicate,\n        // considering only those lanes that were also active in the governing predicate 'pg'.\n        equal_count += svcntp_b8(pg, eq_predicate);\n\n        // Advance the index by the number of elements processed in one SVE vector\n        i += svcnt_u8();\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Loop counter\n    size_t i = 0;\n\n    // Loop while there are still elements to process\n    // svwhilelt_b64 generates a predicate for elements where 'i' < 'length'\n    // and 'i' increments by the vector length (svcntd()).\n    for (i = 0; i < length; i += svcntd()) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the array, especially for the last partial vector.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Broadcast the scalar 'a' into an SVE vector of 64-bit integers.\n        svint64_t va = svdup_s64(a);\n\n        // Load a vector of 64-bit integers from array 'x' starting at index 'i'.\n        // Only active lanes (determined by 'pg') will load data.\n        svint64_t vx = svld1_s64(pg, &x[i]);\n\n        // Load a vector of 64-bit integers from array 'y' starting at index 'i'.\n        // Only active lanes (determined by 'pg') will load data.\n        svint64_t vy = svld1_s64(pg, &y[i]);\n\n        // Perform element-wise scalar-vector multiplication: (a * x[i]).\n        // The operation is masked by 'pg'.\n        svint64_t prod = svmul_s64(pg, va, vx);\n\n        // Calculate the element-wise absolute value of vector 'y'.\n        // The operation is masked by 'pg'.\n        svint64_t abs_vy = svabs_s64(pg, vy);\n\n        // Perform element-wise subtraction: (a * x[i]) - abs(y[i]).\n        // The operation is masked by 'pg'.\n        svint64_t result = svsub_s64(pg, prod, abs_vy);\n\n        // Store the resulting vector back into array 'y' starting at index 'i'.\n        // Only active lanes (determined by 'pg') will write data.\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    for (svbool_t pg = svwhilelt_b64(i, length); svcnt_b64(pg) > 0; pg = svwhilelt_b64(i, length)) {\n        svint64_t vx = svld1_s64(pg, &x[i]);\n        svint64_t vy = svld1_s64(pg, &y[i]);\n\n        svint64_t ax = svmul_s64(pg, vx, a);\n        svint64_t abs_vy = svabs_s64(pg, vy);\n        svint64_t result = svsub_s64(pg, ax, abs_vy);\n\n        svst1_s64(pg, &y[i], result);\n        i += svcnt_b64(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    // Broadcast the scalar 'a' into an SVE vector register once\n    svint64_t a_vec = svdup_s64(a);\n\n    while (i < length) {\n        // Get a predicate for the current vector length, handling the tail\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load elements from x into an SVE vector register\n        svint64_t x_vec = svld1_s64(pg, &x[i]);\n\n        // Load elements from y into an SVE vector register\n        svint64_t y_vec = svld1_s64(pg, &y[i]);\n\n        // Perform scalar-vector multiplication: a * x\n        svint64_t ax_vec = svmul_s64(pg, a_vec, x_vec);\n\n        // Calculate the absolute value of y\n        svint64_t abs_y_vec = svabs_s64(pg, y_vec);\n\n        // Perform element-wise subtraction: (a * x) - abs(y)\n        svint64_t result_vec = svsub_s64(pg, ax_vec, abs_y_vec);\n\n        // Store the results back to y\n        svst1_s64(pg, &y[i], result_vec);\n\n        // Increment the loop counter by the number of 64-bit elements processed in this vector\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    // Duplicate the scalar 'a' into an SVE vector register\n    svint64_t va = svdup_s64(a);\n\n    // Loop while 'i' is less than 'length'\n    // svwhilelt_b64 generates a predicate for the remaining elements\n    for (svbool_t pg = svwhilelt_b64(i, length); svcnt_u64(pg) > 0;\n         i += svcnt_u64(pg), pg = svwhilelt_b64(i, length)) {\n\n        // Load vector x elements\n        svint64_t vx = svld1_s64(pg, &x[i]);\n\n        // Load vector y elements\n        svint64_t vy = svld1_s64(pg, &y[i]);\n\n        // 1. Scalar-vector multiplication: (a * x[i])\n        svint64_t prod_ax = svmul_s64(pg, va, vx);\n\n        // 2. Absolute value of vector y: abs(y[i])\n        svint64_t abs_y = svabs_s64(pg, vy);\n\n        // 3. Element-wise subtraction: (a * x[i]) - abs(y[i])\n        svint64_t result = svsub_s64(pg, prod_ax, abs_y);\n\n        // Store the result back to y\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    // Duplicate the scalar 'a' into an SVE vector once, as it's constant for all operations.\n    // This can be done inside the loop as well, but outside might be slightly more efficient\n    // if the compiler doesn't optimize it. However, svdup_s64 is very fast.\n    // For simplicity and to ensure predicate is applied if needed, it's often duplicated per iteration.\n    // Let's keep it inside the loop for consistency with predicate usage.\n\n    while (i < length) {\n        // Get the predicate for the current vector chunk\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load vector x elements\n        svint64_t vx = svld1_s64(pg, &x[i]);\n\n        // Load vector y elements (input for abs)\n        svint64_t vy_in = svld1_s64(pg, &y[i]);\n\n        // Duplicate scalar 'a' into an SVE vector\n        svint64_t va = svdup_s64(a);\n\n        // Perform scalar-vector multiplication: a * x\n        svint64_t prod_ax = svmul_s64(pg, va, vx);\n\n        // Perform absolute value of vector y\n        svint64_t abs_vy = svabs_s64(pg, vy_in);\n\n        // Perform element-wise subtraction: (a * x) - abs(y)\n        svint64_t result = svsub_s64(pg, prod_ax, abs_vy);\n\n        // Store the results back to y\n        svst1_s64(pg, &y[i], result);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <limits.h> // Required for INT16_MAX and INT16_MIN\n#include <stddef.h> // Required for size_t\n\n// Assuming MinMaxPair is defined as:\n// typedef struct {\n//     int16_t min_num;\n//     int16_t max_num;\n// } MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    // Initialize SVE vectors for accumulating minimum and maximum values.\n    // Start with the largest possible value for min_vec and smallest for max_vec.\n    svint16_t current_min_vec = svdup_s16(INT16_MAX);\n    svint16_t current_max_vec = svdup_s16(INT16_MIN);\n\n    size_t i = 0;\n    // Loop through the vector using SVE predicates to handle full and partial chunks.\n    // svwhilelt_b16 generates a predicate for elements from 'i' up to 'length - 1'.\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    // Continue looping as long as the predicate is active (i.e., there are elements left to process).\n    while (svcntp_b16(pg) > 0) {\n        // Load a vector of 16-bit integers from the input array using the current predicate.\n        svint16_t data_vec = svld1_s16(pg, &vec[i]);\n\n        // Perform element-wise minimum and maximum operations.\n        // Update current_min_vec with the minimum of its current values and the loaded data.\n        current_min_vec = svmin_s16(current_min_vec, data_vec);\n        // Update current_max_vec with the maximum of its current values and the loaded data.\n        current_max_vec = svmax_s16(current_max_vec, data_vec);\n\n        // Advance the index by the number of 16-bit elements in an SVE vector (svcntw()).\n        i += svcntw();\n        // Generate the predicate for the next iteration.\n        pg = svwhilelt_b16(i, length);\n    }\n\n    // After processing all elements, reduce the accumulated SVE vectors to scalar values.\n    // svptrue_b16() creates a predicate that enables all lanes for the reduction.\n    int16_t final_min = svminv_s16(svptrue_b16(), current_min_vec);\n    int16_t final_max = svmaxv_s16(svptrue_b16(), current_max_vec);\n\n    // Return the final minimum and maximum values in a MinMaxPair struct.\n    MinMaxPair result = { .min_num = final_min, .max_num = final_max };\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h> // For INT16_MAX, INT16_MIN\n#include <stddef.h> // For size_t\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n\n    // Initialize SVE vectors for min and max.\n    // Use INT16_MAX for initial min and INT16_MIN for initial max\n    // to ensure any value from the vector will be smaller than initial min\n    // and larger than initial max.\n    svint16_t current_min_vec = svdup_s16(INT16_MAX);\n    svint16_t current_max_vec = svdup_s16(INT16_MIN);\n\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Loop through the vector using SVE.\n    // svwhilelt_b16 generates a predicate for elements from 'i' up to 'length',\n    // ensuring that partial vectors at the end are handled correctly.\n    while (i < length) {\n        pg = svwhilelt_b16(i, length); // Predicate for the current vector chunk\n\n        // Load data from the vector using the predicate.\n        // Inactive lanes (beyond 'length') will be loaded as zero, but\n        // the predicate will prevent them from affecting the min/max calculation.\n        svint16_t data_vec = svld1_s16(pg, &vec[i]);\n\n        // Update the element-wise minimum and maximum.\n        // The non-'_z' versions (svmin_s16, svmax_s16) preserve the original\n        // values in inactive lanes, which is crucial for reduction.\n        current_min_vec = svmin_s16(pg, current_min_vec, data_vec);\n        current_max_vec = svmax_s16(pg, current_max_vec, data_vec);\n\n        // Advance the index by the number of elements in an SVE vector (svcntw()).\n        i += svcntw();\n    }\n\n    // After processing all elements, perform a horizontal reduction\n    // to find the overall minimum and maximum from the SVE vectors.\n    // svptrue_b16() creates a predicate where all lanes are active.\n    result.min_num = svminv_s16(svptrue_b16(), current_min_vec);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // Required for INT16_MAX and INT16_MIN\n\n// Definition of MinMaxPair type as provided in the problem description\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    // Initialize SVE vectors for min and max with extreme values.\n    // These initial values ensure that any actual value from the vector\n    // will be less than or equal to current_min_vec and greater than or equal to current_max_vec.\n    svint16_t current_min_vec = svdup_s16(INT16_MAX);\n    svint16_t current_max_vec = svdup_s16(INT16_MIN);\n\n    size_t i = 0;\n    // Loop through the vector in chunks of SVE vector length (svcnt_s16()).\n    // The svwhilelt_b16 predicate handles partial vectors at the end of the array.\n    while (i < length) {\n        // Generate a predicate for the current chunk.\n        // 'pg' will be true for elements from 'i' up to 'length-1' that fit in the current vector.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load data from the input vector into an SVE vector using the predicate.\n        // Inactive elements (beyond 'length') will be zeroed out by svld1_s16.\n        svint16_t data_vec = svld1_s16(pg, &vec[i]);\n\n        // Update the current minimum vector.\n        // svmin_s16_m merges the result with the original 'current_min_vec' for inactive lanes.\n        // This ensures that inactive lanes retain their previous (INT16_MAX) value,\n        // which is crucial for correct reduction later.\n        current_min_vec = svmin_s16_m(current_min_vec, pg, current_min_vec, data_vec);\n        \n        // Update the current maximum vector.\n        // svmax_s16_m merges the result with the original 'current_max_vec' for inactive lanes.\n        // This ensures that inactive lanes retain their previous (INT16_MIN) value.\n        current_max_vec = svmax_s16_m(current_max_vec, pg, current_max_vec, data_vec);\n\n        // Move to the next chunk. svcnt_s16() returns the number of int16_t elements\n        // in a full SVE vector for the current architecture.\n        i += svcnt_s16();\n    }\n\n    // Perform horizontal reduction to get the final scalar minimum and maximum values.\n    // svminv_s16 and svmaxv_s16 reduce all elements within a single SVE vector\n    // to a scalar value. svptrue_b16() ensures all elements in the vector are considered.\n    int16_t final_min = svminv_s16(svptrue_b16(), current_min_vec);\n    int16_t final_max = svmaxv_s16(svptrue_b16(), current_max_vec);\n\n    MinMaxPair result;\n    result.min_num = final_min;\n    result.max_num = final_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For int16_t\n#include <limits.h> // For INT16_MAX, INT16_MIN\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    // Initialize SVE vectors for accumulating minimum and maximum values.\n    // Start with extreme values to ensure any actual vector element will be smaller/larger.\n    svint16_t sve_min_vec = svdup_s16(INT16_MAX);\n    svint16_t sve_max_vec = svdup_s16(INT16_MIN);\n\n    size_t i = 0;\n    // Loop through the input vector in chunks determined by the SVE vector length.\n    // svwhilelt_b16 generates a predicate for the remaining elements, handling partial vectors.\n    while (i < length) {\n        // Generate a predicate for the current chunk of elements.\n        // This predicate ensures that only valid elements within the bounds of 'length' are processed.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load the current chunk of 16-bit integers into an SVE vector.\n        // Elements beyond 'length' (as per 'pg') will be inactive.\n        svint16_t current_vec = svld1_s16(pg, vec + i);\n\n        // Update the running minimum SVE vector.\n        // For active lanes, it takes the minimum of the current 'sve_min_vec' and 'current_vec'.\n        // For inactive lanes, the value from 'sve_min_vec' is preserved.\n        sve_min_vec = svmin_s16(sve_min_vec, current_vec);\n\n        // Update the running maximum SVE vector.\n        // Similar to svmin_s16, but takes the maximum.\n        sve_max_vec = svmax_s16(sve_max_vec, current_vec);\n\n        // Advance the index by the number of 16-bit elements in an SVE vector.\n        i += svcntw();\n    }\n\n    // After processing all chunks, reduce the SVE min/max vectors to single scalar values.\n    // svptrue_b16() creates a predicate where all lanes are active, ensuring reduction across the entire vector.\n    int16_t final_min = svminv_s16(svptrue_b16(), sve_min_vec);\n    int16_t final_max = svmaxv_s16(svptrue_b16(), sve_max_vec);\n\n    // Construct and return the MinMaxPair result.\n    MinMaxPair result;\n    result.min_num = final_min;\n    result.max_num = final_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h> // For int16_t\n#include <limits.h> // For INT16_MAX, INT16_MIN\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    // Initialize SVE vectors for min and max with extreme values.\n    // This ensures that any actual value from the input vector will be\n    // smaller than the initial min_val and larger than the initial max_val.\n    svint16_t sv_min_val = svdup_n_s16(INT16_MAX);\n    svint16_t sv_max_val = svdup_n_s16(INT16_MIN);\n\n    // Get the number of 16-bit elements that fit into an SVE vector.\n    // This value is determined by the hardware and can vary.\n    size_t sv_elements_per_vec = svcntw();\n\n    // Loop through the input vector in chunks of SVE vector length.\n    // The loop iterates as long as 'i' is less than 'length'.\n    for (size_t i = 0; i < length; i += sv_elements_per_vec) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b16(i, length) generates a predicate that is true for lanes\n        // where the element index (starting from 'i') is less than 'length'.\n        // This correctly handles the tail (partial) vector at the end of the array.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load data from the input vector into an SVE vector using the predicate.\n        // Only active lanes (where 'pg' is true) will load data. Inactive lanes\n        // will remain undisturbed in the destination vector.\n        svint16_t sv_vec = svld1_s16(pg, &vec[i]);\n\n        // Update the SVE min vector.\n        // For active lanes, svmin_s16 takes the minimum of the current sv_min_val\n        // and the loaded sv_vec. For inactive lanes, sv_min_val remains unchanged.\n        sv_min_val = svmin_s16(pg, sv_min_val, sv_vec);\n\n        // Update the SVE max vector.\n        // Similar to svmin_s16, but takes the maximum.\n        sv_max_val = svmax_s16(pg, sv_max_val, sv_vec);\n    }\n\n    // Perform horizontal reduction to find the overall minimum and maximum\n    // from the SVE vectors.\n    // svptrue_b16() creates a predicate where all lanes are active, ensuring\n    // the reduction considers all elements accumulated in sv_min_val and sv_max_val.\n    int16_t final_min = svminv_s16(svptrue_b16(), sv_min_val);\n    int16_t final_max = svmaxv_s16(svptrue_b16(), sv_max_val);\n\n    // Return the result in the MinMaxPair struct.\n    MinMaxPair result;\n    result.min_num = final_min;\n    result.max_num = final_max;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    // A single-column matrix is always strictly increasing as there are no elements to compare.\n    if (cols == 1) {\n        return true;\n    }\n\n    // Get the vector length for 32-bit integers\n    size_t vl = svcntw();\n\n    // Loop through each row of the matrix\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row_ptr = matrix + r * cols;\n        bool row_is_increasing = true;\n        size_t k = 0; // Current index for SVE processing\n\n        // Process elements using SVE vectors\n        // The loop condition `k + vl < cols` ensures that when we load `current_vec` from `row_ptr + k`\n        // and `next_vec` from `row_ptr + k + 1`, the last element accessed by `next_vec`\n        // (which is `row_ptr[k + vl]`) is still within the bounds of the row (`< cols`).\n        for (k = 0; k + vl < cols; k += vl) {\n            svbool_t pg = svptrue_b32(); // Predicate for all active lanes\n            \n            // Load current elements: [row_ptr[k], ..., row_ptr[k + vl - 1]]\n            svint32_t current_vec = svld1_s32(pg, row_ptr + k);\n            \n            // Load next elements: [row_ptr[k + 1], ..., row_ptr[k + vl]]\n            svint32_t next_vec = svld1_s32(pg, row_ptr + k + 1);\n\n            // Compare if current_vec[i] < next_vec[i] for all active lanes\n            svbool_t cmp_result = svcmplt_s32(pg, current_vec, next_vec);\n\n            // If any comparison fails (i.e., current_vec[i] >= next_vec[i]),\n            // then the row is not strictly increasing.\n            if (!svall_b(pg, cmp_result)) {\n                row_is_increasing = false;\n                break;\n            }\n        }\n\n        // Handle the remaining tail elements using a scalar loop\n        // `k` is now the first index not processed by the SVE loop.\n        // We need to compare `row_ptr[i]` with `row_ptr[i+1]` for `i` from `k` to `cols - 2`.\n        for (size_t i = k; i < cols - 1; ++i) {\n            if (row_ptr[i] >= row_ptr[i+1]) {\n                row_is_increasing = false;\n                break;\n            }\n        }\n\n        if (!row_is_increasing) {\n            return false; // Found a row that is not strictly increasing\n        }\n    }\n\n    return true; // All rows are strictly increasing\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    // If the matrix is empty (0 rows or 0 columns), return false as per requirement.\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    // Iterate through each row of the matrix.\n    for (size_t r = 0; r < rows; ++r) {\n        // Get a pointer to the beginning of the current row.\n        const int* row_ptr = &matrix[r * cols];\n        size_t j = 0; // Index for iterating through elements within the row.\n\n        // Loop through the elements of the row using SVE intrinsics.\n        // We need to compare elements up to 'cols - 2' with their successors (up to 'cols - 1').\n        // The loop continues as long as 'j' is less than 'cols - 1', ensuring there's a 'j+1' element to compare.\n        while (j < cols - 1) {\n            // Create a predicate for the current SVE vector operation.\n            // svwhilelt_b32(base, limit) generates a predicate for elements from 'base' up to 'limit - 1'.\n            // Here, it covers indices from 'j' up to 'cols - 2', which are the elements that need to be compared.\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n\n            // If the predicate is empty, it means we have processed all relevant elements in the row,\n            // or there are no more elements to form a comparison pair.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load the current set of elements from the row (e.g., row_ptr[j], row_ptr[j+1], ...).\n            svint32_t current_vec = svld1_s32(pg, row_ptr + j);\n\n            // Load the next set of elements from the row (e.g., row_ptr[j+1], row_ptr[j+2], ...).\n            // The predicate 'pg' ensures that we only load elements that correspond to valid comparisons.\n            svint32_t next_vec = svld1_s32(pg, row_ptr + j + 1);\n\n            // Perform the element-wise comparison: current_vec < next_vec.\n            // The result is a boolean vector where each lane is true if the comparison holds, false otherwise.\n            svbool_t cmp_result = svcmplt_s32(pg, current_vec, next_vec);\n\n            // Check if all active elements (those covered by 'pg') in the comparison satisfy the condition.\n            // If any comparison fails (i.e., an element is not strictly less than its successor),\n            // then this row is not strictly increasing.\n            if (!svptest_all(pg, cmp_result)) {\n                // If a row is found not to be strictly increasing, we can immediately return false\n                // as the overall condition (all rows strictly increasing) is violated.\n                return false;\n            }\n\n            // Advance the index 'j' by the number of elements processed in this vector operation.\n            // svcnt_x_s32() returns the number of 32-bit integers that fit in an SVE vector.\n            j += svcnt_x_s32();\n        }\n    }\n\n    // If the loop completes without returning false, it means all rows are strictly increasing.\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    // If the input matrix is empty (0 rows or 0 columns), return false as per requirement.\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    // Iterate over each row of the matrix.\n    for (size_t r = 0; r < rows; ++r) {\n        // Get a pointer to the beginning of the current row.\n        const int* row_ptr = matrix + r * cols;\n\n        // Iterate through the elements of the current row using SVE intrinsics.\n        // We need to compare element at index 'c' with element at index 'c+1'.\n        // The last comparison will be for element at 'cols - 2' with 'cols - 1'.\n        // Therefore, the loop for 'c' should go up to 'cols - 2'.\n        for (size_t c = 0; c < cols - 1; c += svcntw()) {\n            // Create a predicate for the current vector chunk.\n            // svwhilelt_b32(start_index, limit_index) generates a predicate that is true\n            // for elements whose original index (starting from 'start_index') is less than 'limit_index'.\n            // In our case, 'c' is the starting index for the current elements, and 'cols - 1' is the limit.\n            // This ensures we only process valid comparisons within the row bounds.\n            svbool_t pg = svwhilelt_b32(c, cols - 1);\n\n            // If the predicate is all false (meaning 'c' is beyond 'cols - 1'),\n            // there are no more elements to process in this row, so break the inner loop.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load the current elements from row_ptr + c.\n            svint32_t current_elements = svld1_s32(pg, row_ptr + c);\n            // Load the next elements from row_ptr + c + 1.\n            svint32_t next_elements = svld1_s32(pg, row_ptr + c + 1);\n\n            // Perform the element-wise comparison: current_elements < next_elements.\n            // This generates a new predicate where each lane is true if the comparison holds.\n            svbool_t comparison_result_pg = svcmplt_s32(pg, current_elements, next_elements);\n\n            // Check if all active elements (defined by 'pg') in this vector chunk\n            // satisfy the strictly increasing condition.\n            // If svptest_all returns false, it means at least one comparison failed\n            // within the active part of the vector. In this case, the row is not\n            // strictly increasing, so we can immediately return false.\n            if (!svptest_all(pg, comparison_result_pg)) {\n                return false; // Found a row that is not strictly increasing.\n            }\n        }\n    }\n\n    // If all rows have been processed and no non-strictly increasing row was found,\n    // then all rows are strictly increasing.\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false; // As per requirement for an empty matrix\n    }\n    if (cols == 1) {\n        return true; // A single-column matrix is always strictly increasing (no pairs to check)\n    }\n\n    // Get the number of 32-bit integers in an SVE vector.\n    // This value is constant for a given SVE implementation.\n    const size_t sv_vec_len = svcntw();\n\n    // Loop through each row of the matrix.\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row_ptr = matrix + r * cols;\n\n        // Loop through elements in the current row using SVE intrinsics.\n        // We need to check row_ptr[i] < row_ptr[i+1] for i from 0 to cols-2.\n        // The loop iterates with a stride equal to the SVE vector length.\n        for (size_t c = 0; c < cols - 1; c += sv_vec_len) {\n            // Create a predicate for the current vector chunk.\n            // 'svwhilelt_b32(c, cols - 1)' generates a predicate that is true for lanes\n            // where (c + lane_index) < (cols - 1). This ensures we only process valid pairs.\n            svbool_t pg = svwhilelt_b32(c, cols - 1);\n\n            // If no lanes are active for this chunk, it means we have processed all relevant\n            // elements in this row, so we can break out of the inner loop.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load the 'current' elements into an SVE vector.\n            // For active lanes, this loads row_ptr[c], row_ptr[c+1], etc.\n            svint32_t current_elements = svld1(pg, row_ptr + c);\n\n            // Load the 'next' elements into an SVE vector.\n            // For active lanes, this loads row_ptr[c+1], row_ptr[c+2], etc.\n            svint32_t next_elements = svld1(pg, row_ptr + c + 1);\n\n            // Compare 'current_elements' strictly less than 'next_elements' for active lanes.\n            // The result is a predicate where a 'true' bit indicates the condition holds for that lane.\n            svbool_t cmp_result = svcmplt(pg, current_elements, next_elements);\n\n            // Check if all active lanes satisfy the strictly increasing condition.\n            // If 'svptest_all' returns false, it means at least one pair in the current\n            // vector chunk (for active lanes) did not satisfy the condition.\n            // In this case, the row is not strictly increasing, so we return false immediately.\n            if (!svptest_all(pg, cmp_result)) {\n                return false; // Found a violation\n            }\n        }\n    }\n\n    // If we have iterated through all rows and found no violations,\n    // then all rows are strictly increasing.\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    // As per requirement: \"If the input matrix is empty, return false.\"\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = &matrix[i * cols];\n        bool row_is_strictly_increasing = true;\n\n        // Loop through the row using SVE intrinsics to check for strictly increasing property.\n        // We need to compare elements at index `j` with elements at `j+1`.\n        // The last comparison needed is for `row_ptr[cols-2]` vs `row_ptr[cols-1]`.\n        // So, the index `j` for the first element of a pair iterates from `0` up to `cols-2`.\n        size_t j = 0;\n        \n        // The predicate `pg` is generated to be active for elements `k` such that `j + k < cols - 1`.\n        // This ensures that `j + k` (the index of the first element in a pair within the vector)\n        // does not exceed `cols - 2`, which is the last valid index for the first element of a pair.\n        svbool_t pg = svwhilelt_b32(j, cols - 1);\n\n        // Loop while there are active elements in the predicate (i.e., comparisons still need to be made).\n        while (svptest_any(svptrue_b32(), pg)) {\n            // Load the current elements starting from row_ptr[j].\n            // Only elements corresponding to active lanes in `pg` will be loaded effectively.\n            svint32_t current_elements = svld1(pg, &row_ptr[j]);\n\n            // Load the next elements, shifted by one position, starting from row_ptr[j+1].\n            // This allows for direct element-wise comparison of (element_k, element_k+1).\n            svint32_t next_elements = svld1(pg, &row_ptr[j+1]);\n\n            // Perform element-wise comparison: current_elements < next_elements.\n            // The result `cmp_mask` will have true for lanes where the condition holds, false otherwise.\n            // Only active lanes (defined by `pg`) are considered.\n            svbool_t cmp_mask = svcmplt(pg, current_elements, next_elements);\n\n            // Check if all active comparisons were true.\n            // If `svptest_all` returns false, it means at least one active comparison failed (current >= next).\n            // In this case, the row is not strictly increasing.\n            if (!svptest_all(svptrue_b32(), cmp_mask)) {\n                row_is_strictly_increasing = false;\n                break; // No need to check further in this row, it's already invalid.\n            }\n\n            // Advance the index `j` by the number of elements processed in this vector.\n            // `svcntw()` returns the number of 32-bit elements in an SVE vector.\n            j += svcntw();\n            \n            // Update the predicate for the next chunk of elements.\n            pg = svwhilelt_b32(j, cols - 1);\n        }\n\n        // If we found a row that is not strictly increasing, we can immediately return false.\n        if (!row_is_strictly_increasing) {\n            return false;\n        }\n    }\n\n    // If the loop completes, it means all rows have been checked and found to be strictly increasing.\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h> // For bool type\n#include <stddef.h>  // For size_t\n#include <stdlib.h>  // For malloc, free\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // 1. Input Validation\n    // Check if block_size is valid (non-zero) and if matrix dimensions are perfectly divisible by block_size.\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false; // Illegal block_size or matrix not perfectly divisible\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // 2. Store Base Block\n    // Allocate memory to store the first block (base block) for comparison.\n    int* base_block_data = (int*)malloc(block_size * block_size * sizeof(int));\n    if (base_block_data == NULL) {\n        // Handle memory allocation failure\n        return false;\n    }\n\n    // Copy the first block from the matrix into base_block_data using SVE intrinsics.\n    // This ensures the base block is contiguous in memory, which is beneficial for SVE loads.\n    for (size_t r = 0; r < block_size; ++r) {\n        // Pointer to the start of the current row in the original matrix (first block)\n        const int* src_row_ptr = &matrix[r * cols];\n        // Pointer to the start of the current row in the base_block_data buffer\n        int* dest_row_ptr = &base_block_data[r * block_size];\n\n        // SVE loop to copy elements of the row\n        for (size_t c = 0; c < block_size; c += svcntw()) {\n            // Create a predicate for the current vector length, handling partial vectors at the end of the row.\n            svbool_t pg = svwhilelt_b32(c, block_size);\n            // Load a vector of 32-bit integers from the source row\n            svint32_t vec = svld1_s32(pg, src_row_ptr + c);\n            // Store the vector into the destination row\n            svst1_s32(pg, dest_row_ptr + c, vec);\n        }\n    }\n\n    // 3. Iterate and Compare Blocks\n    // Loop through all blocks in the matrix (including the first one, which will be skipped for comparison)\n    for (size_t block_row_idx = 0; block_row_idx < num_block_rows; ++block_row_idx) {\n        for (size_t block_col_idx = 0; block_col_idx < num_block_cols; ++block_col_idx) {\n            // Skip the first block as it's the reference block we just copied.\n            if (block_row_idx == 0 && block_col_idx == 0) {\n                continue;\n            }\n\n            // Compare the current block with the base block, row by row.\n            for (size_t r_in_block = 0; r_in_block < block_size; ++r_in_block) {\n                // Calculate the starting address of the current row within the current block in the original matrix.\n                size_t current_matrix_row_start = (block_row_idx * block_size + r_in_block) * cols;\n                size_t current_matrix_col_start = block_col_idx * block_size;\n                const int* current_row_ptr = &matrix[current_matrix_row_start + current_matrix_col_start];\n\n                // Calculate the starting address of the corresponding row in the base block data.\n                const int* base_row_ptr = &base_block_data[r_in_block * block_size];\n\n                // SVE loop for columns within the current row of the block.\n                for (size_t c_in_block = 0; c_in_block < block_size; c_in_block += svcntw()) {\n                    // Create a predicate for the current vector length.\n                    svbool_t pg = svwhilelt_b32(c_in_block, block_size);\n\n                    // Load vectors from the current block's row and the base block's row.\n                    svint32_t current_vec = svld1_s32(pg, current_row_ptr + c_in_block);\n                    svint32_t base_vec = svld1_s32(pg, base_row_ptr + c_in_block);\n\n                    // Compare the two vectors element-wise for equality.\n                    svbool_t cmp_result = svcmpeq_s32(pg, current_vec, base_vec);\n\n                    // Check if all active elements in the comparison result are true (i.e., all elements are equal).\n                    // If svptest_all returns false, it means at least one element in the current vector comparison\n                    // did not match, so the blocks are not identical.\n                    if (!svptest_all(pg, cmp_result)) {\n                        free(base_block_data); // Clean up allocated memory\n                        return false;          // Blocks are not identical\n                    }\n                }\n            }\n        }\n    }\n\n    // 4. Cleanup and Return True\n    // If the function reaches this point, all blocks were identical to the first block.\n    free(base_block_data); // Clean up allocated memory\n    return true;           // All blocks are identical\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h> // For size_t\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    for (size_t r_block = 0; r_block < num_block_rows; ++r_block) {\n        for (size_t c_block = 0; c_block < num_block_cols; ++c_block) {\n            if (r_block == 0 && c_block == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* ref_row_ptr = matrix + (i * cols);\n                const int* current_row_ptr = matrix + (r_block * block_size + i) * cols + (c_block * block_size);\n\n                size_t j = 0;\n                svbool_t pg = svwhilelt_b32(j, block_size);\n\n                while (svptest_any(svptrue_b32(), pg)) {\n                    svint32_t ref_vec = svld1_s32(pg, ref_row_ptr + j);\n                    svint32_t current_vec = svld1_s32(pg, current_row_ptr + j);\n\n                    svbool_t cmp_result = svcmpeq_s32(pg, ref_vec, current_vec);\n\n                    if (!svptest_all(pg, cmp_result)) {\n                        return false;\n                    }\n\n                    j += svcntw();\n                    pg = svwhilelt_b32(j, block_size);\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c++\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Handle invalid block_size or dimensions not divisible by block_size\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // If the matrix is empty, or block_size is larger than matrix dimensions,\n    // there are no blocks to compare, or it's an invalid block size for comparison.\n    // If rows or cols are 0, it means no blocks exist, so it's vacuously true.\n    if (rows == 0 || cols == 0) {\n        return true;\n    }\n    // If block_size is greater than matrix dimensions, it's an invalid block configuration.\n    if (block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Iterate through all blocks in the matrix\n    for (size_t block_row_idx = 0; block_row_idx < num_row_blocks; ++block_row_idx) {\n        for (size_t block_col_idx = 0; block_col_idx < num_col_blocks; ++block_col_idx) {\n            // Skip the first block itself, as it's the reference\n            if (block_row_idx == 0 && block_col_idx == 0) {\n                continue;\n            }\n\n            // Calculate the starting row and column index for the current block\n            size_t current_block_start_row = block_row_idx * block_size;\n            size_t current_block_start_col = block_col_idx * block_size;\n\n            // Compare the current block with the first block element by element\n            for (size_t r = 0; r < block_size; ++r) { // Iterate rows within the block\n                // Calculate the starting linear index for the current row in the first block\n                const int* first_block_row_ptr = &matrix[r * cols];\n                \n                // Calculate the starting linear index for the current row in the current block\n                const int* current_block_row_ptr = &matrix[(current_block_start_row + r) * cols + current_block_start_col];\n\n                // Vectorize the column comparison within the block row\n                for (size_t c = 0; c < block_size; ) { // Iterate columns within the block using SVE\n                    // Create a predicate for the current vector load, handling partial vectors at the end of the row\n                    svbool_t pg = svwhilelt_b32(c, block_size);\n                    \n                    // If the predicate is empty (no more elements to process in this row), break\n                    if (!svptest_any(svptrue_b32(), pg)) {\n                        break;\n                    }\n\n                    // Load vector from the first block\n                    svint32_t first_vec = svld1_s32(pg, first_block_row_ptr + c);\n\n                    // Load vector from the current block\n                    svint32_t current_vec = svld1_s32(pg, current_block_row_ptr + c);\n\n                    // Compare the two vectors for equality\n                    svbool_t cmp_result = svcmpeq_s32(pg, first_vec, current_vec);\n\n                    // Check if all active elements in the comparison result are true (i.e., all elements are equal)\n                    if (!svptest_all(pg, cmp_result)) {\n                        return false; // Mismatch found, blocks are not identical\n                    }\n                    \n                    // Advance column index by the number of elements in an SVE vector\n                    c += svcntw();\n                }\n            }\n        }\n    }\n\n    // If all blocks have been compared and no mismatches were found\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n#include <cstddef> // Required for size_t\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size);\notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // 1. Input Validation\n    if (block_size == 0) {\n        return false; // Illegal block_size: block_size must be positive.\n    }\n\n    // Check if matrix dimensions are valid for forming blocks.\n    // `rows` and `cols` must be at least `block_size` to form a single block.\n    // Also, `rows` and `cols` must be perfect multiples of `block_size`.\n    if (rows < block_size || cols < block_size || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // 2. Store the first block's data as a reference.\n    // Using std::vector for dynamic allocation to avoid stack overflow for large block_size.\n    std::vector<int> first_block_data(block_size * block_size);\n    for (size_t r = 0; r < block_size; ++r) {\n        for (size_t c = 0; c < block_size; ++c) {\n            first_block_data[r * block_size + c] = matrix[r * cols + c];\n        }\n    }\n\n    // 3. Iterate through all blocks and compare with the first block using SVE intrinsics.\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    for (size_t block_row_idx = 0; block_row_idx < num_row_blocks; ++block_row_idx) {\n        for (size_t block_col_idx = 0; block_col_idx < num_col_blocks; ++block_col_idx) {\n            // Skip the first block (0,0) as it's the reference itself and doesn't need comparison.\n            if (block_row_idx == 0 && block_col_idx == 0) {\n                continue;\n            }\n\n            // Calculate the starting row and column index of the current block in the matrix.\n            size_t current_block_start_row = block_row_idx * block_size;\n            size_t current_block_start_col = block_col_idx * block_size;\n\n            // Compare this current block with the stored first_block_data, row by row.\n            for (size_t r = 0; r < block_size; ++r) { // Iterate through rows within the block.\n                // Pointers to the start of the current row in first_block_data and the current matrix block.\n                const int* first_block_row_ptr = &first_block_data[r * block_size];\n                const int* current_matrix_row_ptr = &matrix[(current_block_start_row + r) * cols + current_block_start_col];\n\n                // SVE loop for columns within the current row.\n                // 'c' is the column index within the current block row.\n                for (size_t c = 0; c < block_size; ) {\n                    // Generate a predicate for the current vector segment.\n                    // svwhilelt_b32(c, block_size) creates a predicate that is true for lanes\n                    // corresponding to indices from 'c' up to 'block_size - 1'.\n                    svbool_t pg = svwhilelt_b32(c, block_size);\n\n                    // If the predicate is empty (no active lanes), it means we have processed\n                    // all elements in this row, so break the inner SVE loop.\n                    if (!svptest_any(svptrue_b8(), pg)) {\n                        break;\n                    }\n\n                    // Load vector segments from both the first block's data and the current matrix block.\n                    svint32_t vec_first = svld1_s32(pg, first_block_row_ptr + c);\n                    svint32_t vec_current = svld1_s32(pg, current_matrix_row_ptr + c);\n\n                    // Compare the two vector segments for inequality.\n                    // svcmpne_s32 returns a predicate where lanes are true if the corresponding elements are not equal.\n                    svbool_t cmp_result = svcmpne_s32(pg, vec_first, vec_current);\n\n                    // If any element in the current vector segment is not equal, return false immediately.\n                    // svptest_any(pg, cmp_result) checks if any active lane (true in 'pg') in 'cmp_result' is true.\n                    if (svptest_any(pg, cmp_result)) {\n                        return false;\n                    }\n\n                    // Advance the column index by the number of 32-bit elements processed by SVE.\n                    // svcntw() returns the number of 32-bit elements in an SVE vector.\n                    c += svcntw();\n                }\n            }\n        }\n    }\n\n    // If all comparisons passed without finding any mismatches, all blocks are identical to the first block.\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Handle edge cases and invalid block_size\n    if (block_size == 0 || rows == 0 || cols == 0) {\n        return false;\n    }\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false; // Matrix cannot be perfectly divided into blocks of block_size\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Iterate through all blocks\n    for (size_t block_row_idx = 0; block_row_idx < num_row_blocks; ++block_row_idx) {\n        for (size_t block_col_idx = 0; block_col_idx < num_col_blocks; ++block_col_idx) {\n            // Skip the first block, as we are comparing all other blocks against it\n            if (block_row_idx == 0 && block_col_idx == 0) {\n                continue;\n            }\n\n            // Calculate starting indices for the current block\n            size_t current_block_start_row = block_row_idx * block_size;\n            size_t current_block_start_col = block_col_idx * block_size;\n\n            // Compare current block with the first block (at row 0, col 0)\n            for (size_t r = 0; r < block_size; ++r) { // Iterate through rows within the block\n                // Calculate starting pointers for the current row in both blocks\n                const int* ptr_first_block_row = matrix + r * cols; // Row 'r' of the first block\n                const int* ptr_current_block_row = matrix + (current_block_start_row + r) * cols + current_block_start_col;\n\n                // Iterate through columns within the row using SVE intrinsics\n                for (size_t c = 0; c < block_size; ) {\n                    // Create a predicate for the current vector operation\n                    // It will be true for elements within the block_size boundary\n                    svbool_t pg = svwhilelt_b32(c, block_size);\n\n                    // If the predicate is empty, we've processed all elements in this row\n                    if (!svptest_any(svptrue_b32(), pg)) {\n                        break;\n                    }\n\n                    // Load vector from the first block's corresponding row\n                    svint32_t first_vec = svld1(pg, ptr_first_block_row + c);\n                    // Load vector from the current block's corresponding row\n                    svint32_t current_vec = svld1(pg, ptr_current_block_row + c);\n\n                    // Compare the two vectors element-wise\n                    svbool_t cmp_res = svcmpeq(pg, first_vec, current_vec);\n\n                    // Check if all active elements in the comparison result are true\n                    // If not, it means at least one element is different, so blocks are not identical\n                    if (!svptest_all(pg, cmp_res)) {\n                        return false;\n                    }\n\n                    // Advance column index by the number of elements in an SVE vector\n                    c += svcntw();\n                }\n            }\n        }\n    }\n\n    return true; // All blocks are identical to the first one\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Handle illegal input or cases where no complete blocks can be formed.\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate the number of complete blocks in the vector.\n    size_t num_complete_blocks = length / block_size;\n\n    // If there's only one block or no complete blocks, there's nothing to compare against,\n    // so it's vacuously true that all *other* blocks are equal to the first.\n    // However, the problem statement implies \"all blocks ... are element-wise equal to the first block\".\n    // If num_complete_blocks is 0, we return false as per the initial check.\n    // If num_complete_blocks is 1, there are no *subsequent* blocks to compare, so it's true.\n    if (num_complete_blocks <= 1) {\n        return true;\n    }\n\n    // Duplicate the tolerance value into an SVE vector register.\n    svfloat64_t sv_tolerance = svdup_f64(tolerance);\n\n    // Get the current SVE vector length for double-precision floats.\n    // This is useful for iterating through chunks.\n    // size_t sv_vl = svcntd(); // Not strictly needed as svwhilelt_b64 handles iteration\n\n    // Loop through blocks starting from the second one (index 1).\n    // The first block (index 0) is the reference.\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        // Pointer to the start of the current block being compared.\n        const double* current_block_ptr = vec + (i * block_size);\n        \n        // Loop through elements within the current block and the reference block using SVE vectors.\n        // 'j' is the offset within the block.\n        for (size_t j = 0; j < block_size; j += svcntd()) {\n            // Create a predicate for the current SVE vector chunk.\n            // This predicate ensures we only process elements up to 'block_size'.\n            svbool_t pg = svwhilelt_b64(j, block_size);\n            \n            // Load a chunk of the reference block (first block).\n            svfloat64_t ref_chunk = svld1_f64(pg, &vec[j]);\n            \n            // Load a chunk of the current block being compared.\n            svfloat64_t current_chunk = svld1_f64(pg, &current_block_ptr[j]);\n            \n            // Calculate the absolute difference between the corresponding elements.\n            svfloat64_t diff = svabs_f64(svsub_f64(ref_chunk, current_chunk));\n            \n            // Compare the absolute difference with the tolerance: diff <= tolerance.\n            svbool_t cmp_result = svle_f64(pg, diff, sv_tolerance);\n            \n            // Check if all active elements (those enabled by 'pg') in the comparison result are true.\n            // If even one element fails the tolerance check, the blocks are not equal.\n            if (!svall_b(pg, cmp_result)) {\n                return false; // Mismatch found, return false immediately.\n            }\n        }\n    }\n\n    // If all blocks and their elements have been successfully compared and matched within tolerance, return true.\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Input validation\n    if (vec == NULL || length == 0 || block_size == 0) {\n        return false;\n    }\n    // If there are no complete blocks (e.g., length = 5, block_size = 6), return false.\n    if (length < block_size) {\n        return false;\n    }\n\n    // Get the number of double elements per SVE vector\n    size_t sv_len = svcntd();\n\n    // Broadcast the tolerance value into an SVE vector\n    svfloat64_t sv_tolerance = svdup_f64(tolerance);\n\n    // Iterate through the vector, block by block, starting from the second block.\n    // The loop continues as long as there's a full block remaining to compare.\n    // current_block_start_idx points to the beginning of the block being compared.\n    for (size_t current_block_start_idx = block_size;\n         current_block_start_idx <= length - block_size;\n         current_block_start_idx += block_size) {\n\n        // Inner loop to compare the current block with the first block, element by element, using SVE.\n        // 'i' is the offset within the block (0 to block_size - 1).\n        for (size_t i = 0; i < block_size; i += sv_len) {\n            // Create a predicate for the current SVE vector operation.\n            // This predicate ensures we only process elements up to 'block_size'.\n            svbool_t pg = svwhilelt_b64(i, block_size);\n\n            // If the predicate is inactive (no elements to process in this vector), break.\n            if (!svptest_any(svptrue_b64(), pg)) {\n                break;\n            }\n\n            // Load elements from the first block (reference block)\n            svfloat64_t sv_first_block_val = svld1_f64(pg, &vec[i]);\n\n            // Load elements from the current block being compared\n            svfloat64_t sv_current_block_val = svld1_f64(pg, &vec[current_block_start_idx + i]);\n\n            // Calculate the absolute difference between corresponding elements\n            svfloat64_t sv_diff = svabs_f64(svsub_f64(sv_first_block_val, sv_current_block_val));\n\n            // Compare the absolute difference with the tolerance: |a - b| <= tolerance\n            svbool_t sv_comparison_result = svle_f64(pg, sv_diff, sv_tolerance);\n\n            // Check if ALL active elements in the current SVE vector satisfy the condition.\n            // If any element fails the comparison, then the blocks are not equal.\n            if (!svptest_all(pg, sv_comparison_result)) {\n                return false; // Mismatch found\n            }\n        }\n    }\n\n    // If all complete blocks have been successfully compared and found to be equal within tolerance\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <stdlib.h> // For malloc, free\n#include <stdbool.h> // For bool type\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Input validation\n    if (vec == NULL || length == 0 || block_size == 0) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 1) {\n        return false; // No complete blocks to compare\n    }\n\n    // Get SVE vector length in elements (doubles)\n    size_t sv_vl = svcntd();\n\n    // Calculate how many SVE vectors are needed to store one block\n    // This is ceil(block_size / sv_vl)\n    size_t num_vecs_per_block = (block_size + sv_vl - 1) / sv_vl;\n\n    // Allocate space for the first block's SVE vectors\n    // Using malloc/free for dynamic allocation as block_size can be large.\n    svfloat64_t* ref_block_vecs = (svfloat64_t*)malloc(num_vecs_per_block * sizeof(svfloat64_t));\n    if (ref_block_vecs == NULL) {\n        return false; // Memory allocation failed\n    }\n\n    // Duplicate tolerance into an SVE vector once\n    svfloat64_t sv_tolerance = svdup_f64(tolerance);\n\n    // Load the first block into SVE registers\n    size_t current_offset = 0;\n    for (size_t i = 0; i < num_vecs_per_block; ++i) {\n        // Create a predicate for the current vector segment within the block\n        // This predicate ensures we only process elements up to block_size\n        svbool_t pg = svwhilelt_b64(current_offset, block_size);\n        \n        // If no active lanes, we've loaded all relevant elements of the block\n        if (svptest_any(svptrue_b64(), pg) == 0) {\n            break; \n        }\n        \n        ref_block_vecs[i] = svld1_f64(pg, vec + current_offset);\n        current_offset += sv_vl;\n    }\n\n    // Iterate through subsequent blocks (from the second block onwards)\n    for (size_t block_idx = 1; block_idx < num_complete_blocks; ++block_idx) {\n        const double* current_block_ptr = vec + block_idx * block_size;\n        \n        bool current_block_is_equal = true; // Flag to track if the current block matches the first\n\n        current_offset = 0;\n        for (size_t i = 0; i < num_vecs_per_block; ++i) {\n            // Create a predicate for the current vector segment within the block\n            svbool_t pg = svwhilelt_b64(current_offset, block_size);\n            \n            // If no active lanes, we've processed all relevant elements of the block\n            if (svptest_any(svptrue_b64(), pg) == 0) {\n                break; \n            }\n\n            // Load current block data\n            svfloat64_t current_data = svld1_f64(pg, current_block_ptr + current_offset);\n            \n            // Get reference data from the first block\n            svfloat64_t ref_data = ref_block_vecs[i];\n\n            // Calculate absolute difference: |current_data - ref_data|\n            svfloat64_t diff = svabs_f64(svsub_f64(current_data, ref_data));\n\n            // Compare with tolerance: diff <= tolerance\n            // The predicate 'pg' ensures only active lanes are considered in the comparison\n            svbool_t comparison_result = svle_f64(pg, diff, sv_tolerance);\n\n            // Check if all active lanes in this vector comparison passed\n            // svptest_all(pg, comparison_result) returns true if all lanes enabled by 'pg' are true in 'comparison_result'\n            if (!svptest_all(pg, comparison_result)) {\n                current_block_is_equal = false;\n                break; // No need to check further elements in this block\n            }\n\n            current_offset += sv_vl;\n        }\n\n        // If any element in the current block did not match the first block within tolerance\n        if (!current_block_is_equal) {\n            free(ref_block_vecs); // Clean up allocated memory\n            return false;\n        }\n    }\n\n    free(ref_block_vecs); // Clean up allocated memory\n    return true; // All blocks were equal within tolerance\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Input validation\n    if (vec == NULL || length == 0 || block_size == 0) {\n        return false; // Illegal input\n    }\n\n    // Calculate the number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n\n    // If there are no complete blocks (length < block_size), return false as per requirement.\n    // If there is only one complete block (num_complete_blocks == 1),\n    // there are no subsequent blocks to compare against. In this case,\n    // the condition \"all blocks are equal to the first block\" is trivially true.\n    if (num_complete_blocks == 0) {\n        return false;\n    }\n    if (num_complete_blocks == 1) {\n        return true;\n    }\n\n    // Get the SVE vector length for double-precision floats\n    size_t sv_len = svcntd();\n\n    // Duplicate the tolerance value into an SVE vector register\n    svfloat64_t tol_vec = svdup_f64(tolerance);\n\n    // Loop through subsequent blocks, starting from the second block (block_idx = 1)\n    for (size_t block_idx = 1; block_idx < num_complete_blocks; ++block_idx) {\n        // Calculate the starting offset of the current block being checked\n        size_t current_block_start_offset = block_idx * block_size;\n\n        // Loop through elements within the current block, processing in SVE vector chunks\n        for (size_t i = 0; i < block_size; i += sv_len) {\n            // Create a predicate for the current vector chunk.\n            // This handles partial vectors at the end of the block, ensuring we only\n            // process elements up to 'block_size'.\n            svbool_t pg = svwhilelt_b64(i, block_size);\n\n            // Load elements from the first block (reference block)\n            // The address is vec + i, as we compare current_block_vec[j] with first_block_vec[j]\n            svfloat64_t first_block_vec = svld1_f64(pg, &vec[i]);\n\n            // Load elements from the current block being checked\n            svfloat64_t current_block_vec = svld1_f64(pg, &vec[current_block_start_offset + i]);\n\n            // Calculate the absolute difference between corresponding elements: |current - first|\n            svfloat64_t diff = svabs_f64(svsub_f64(current_block_vec, first_block_vec));\n\n            // Compare the absolute difference with the tolerance: diff <= tolerance\n            // The result is a predicate where lanes are true if the condition holds.\n            svbool_t cmp_result = svle_f64(diff, tol_vec);\n\n            // Check if all active elements in this vector chunk satisfy the condition.\n            // If any active element fails the comparison (i.e., diff > tolerance),\n            // svall_b will return false, and we can immediately return false.\n            if (!svall_b(pg, cmp_result)) {\n                return false; // Mismatch found\n            }\n        }\n    }\n\n    // If all blocks and their elements passed the comparison, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // 1. Input Validation\n    // Return false if the input pointer is NULL, or if length/block_size is zero.\n    if (vec == NULL || length == 0 || block_size == 0) {\n        return false;\n    }\n\n    // Return false if there are no complete blocks at all.\n    if (length < block_size) {\n        return false;\n    }\n\n    // If there's only one complete block (i.e., length is less than 2 * block_size),\n    // there are no *other* blocks to compare against the first one.\n    // In this case, the condition \"all blocks ... are element-wise equal to the first block\"\n    // is vacuously true.\n    if (length < 2 * block_size) {\n        return true;\n    }\n\n    // 2. Prepare the tolerance value as an SVE vector.\n    // This broadcasts the scalar tolerance to all elements of an SVE vector.\n    svfloat64_t sv_tolerance = svdup_f64(tolerance);\n\n    // Get the number of double elements an SVE vector can hold.\n    // This value is determined at runtime by the SVE hardware.\n    size_t sv_len = svcntd();\n\n    // Calculate the total number of complete blocks in the vector.\n    size_t num_blocks = length / block_size;\n\n    // 3. Iterate through each subsequent block, starting from the second block (index 1).\n    // We compare each of these blocks against the first block (index 0).\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        // Calculate the starting memory offset for the current block being checked.\n        size_t current_block_start_offset = block_idx * block_size;\n\n        // 4. Iterate through elements within the current block using SVE intrinsics.\n        // 'k' represents the offset within a block (from 0 to block_size - 1).\n        // We increment 'k' by 'sv_len' to process elements in SVE vector chunks.\n        for (size_t k = 0; k < block_size; k += sv_len) {\n            // Create a predicate for the current SVE vector chunk.\n            // `svwhilelt_b64(k, block_size)` generates a predicate that is true for elements\n            // from 'k' up to (but not including) 'block_size'. This correctly handles\n            // partial SVE vectors at the end of a block if 'block_size' is not a multiple of 'sv_len'.\n            svbool_t pg = svwhilelt_b64(k, block_size);\n\n            // Load elements from the first block (reference block).\n            // `&vec[k]` points to the 'k'-th element of the first block.\n            svfloat64_t first_block_vec = svld1_f64(pg, &vec[k]);\n\n            // Load elements from the current block being compared.\n            // `&vec[current_block_start_offset + k]` points to the 'k'-th element\n            // of the current block.\n            svfloat64_t current_block_vec = svld1_f64(pg, &vec[current_block_start_offset + k]);\n\n            // Calculate the absolute difference between corresponding elements.\n            // `svsub_f64_x` performs subtraction only for active elements (defined by 'pg').\n            // `svabs_f64_x` calculates the absolute value only for active elements.\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, current_block_vec, first_block_vec));\n\n            // Compare the absolute difference with the tolerance.\n            // `svle_f64` performs a less-than-or-equal comparison for active elements,\n            // returning a predicate where true indicates the condition (diff <= tolerance) is met.\n            svbool_t cmp_result = svle_f64(pg, diff, sv_tolerance);\n\n            // Check if all active elements in the current SVE vector chunk satisfy the condition.\n            // `svptest_all(pg, cmp_result)` returns true if all elements that are active in 'pg'\n            // are also true in 'cmp_result'. If even one active element fails the comparison,\n            // this function returns false, indicating a mismatch.\n            if (!svptest_all(pg, cmp_result)) {\n                return false; // Found a mismatch, so the blocks are not all equal within tolerance.\n            }\n        }\n    }\n\n    // If the loops complete without returning false, it means all subsequent complete blocks\n    // matched the first block within the specified tolerance.\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <cmath> // Required for std::sqrt\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    // Iterate over each row of the matrix\n    for (size_t r = 0; r < rows; ++r) {\n        // Pointer to the start of the current row\n        const double* current_row_ptr = matrix + r * cols;\n\n        // SVE vector to accumulate the sum of squares for the current row\n        svfloat64_t vec_sum_sq = svdup_f64(0.0);\n\n        // Loop through columns using SVE intrinsics\n        size_t col_idx = 0;\n        // Predicate for the first chunk of elements\n        svbool_t pg = svwhilelt_b64(col_idx, cols);\n\n        // Loop while there are still active elements in the predicate\n        while (svptest_any(svptrue_b64(), pg)) {\n            // Load a vector of doubles from the current row\n            svfloat64_t vec_data = svld1_f64(pg, current_row_ptr + col_idx);\n\n            // Square each element in the vector\n            svfloat64_t vec_squared = svmul_f64(vec_data, vec_data);\n\n            // Add the squared elements to the accumulator\n            vec_sum_sq = svadd_f64(vec_sum_sq, vec_squared);\n\n            // Move to the next chunk of elements\n            col_idx += svcntd();\n            // Update the predicate for the next chunk\n            pg = svwhilelt_b64(col_idx, cols);\n        }\n\n        // Horizontally sum all elements in the accumulator vector to get the total sum of squares\n        double total_sum_sq = svaddv_f64(svptrue_b64(), vec_sum_sq);\n\n        // Calculate the Euclidean norm (square root of the sum of squares)\n        double norm = std::sqrt(total_sum_sq);\n\n        // Compare the calculated norm with the corresponding threshold and store the result\n        result[r] = (norm > thresholds[r]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <cmath> // For std::sqrt\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    // Loop through each row of the matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Pointer to the start of the current row in the flattened matrix\n        const double* row_ptr = matrix + i * cols;\n\n        // Initialize an SVE vector to accumulate the sum of squares for the current row.\n        // Each lane of this vector will accumulate a partial sum of squares.\n        svfloat64_t sum_sq_vec = svdup_f64(0.0);\n\n        // Loop through the columns of the current row using SVE intrinsics\n        size_t col_idx = 0;\n        while (col_idx < cols) {\n            // Create a predicate for the current vector load.\n            // This predicate ensures that we only process valid elements,\n            // especially for the last vector if cols is not a multiple of svcntd().\n            svbool_t pg = svwhilelt_b64(col_idx, cols);\n\n            // Load a vector of double-precision floating-point numbers from the current row\n            svfloat64_t current_elements = svld1(pg, row_ptr + col_idx);\n\n            // Square each element in the loaded vector\n            svfloat64_t squared_elements = svmul_f64(current_elements, current_elements);\n\n            // Add the squared elements to the accumulator vector.\n            // This performs an element-wise addition, accumulating sums in each lane.\n            sum_sq_vec = svadd_f64(sum_sq_vec, squared_elements);\n\n            // Advance the column index by the number of elements processed in one SVE vector\n            col_idx += svcntd();\n        }\n\n        // After processing all elements in the row, perform a horizontal sum\n        // across all lanes of the accumulator vector to get the final scalar sum of squares.\n        // svptrue_b64() creates a predicate where all lanes are active, ensuring all accumulated\n        // partial sums are combined.\n        double sum_sq = svaddv_f64(svptrue_b64(), sum_sq_vec);\n\n        // Calculate the Euclidean norm by taking the square root of the sum of squares.\n        double norm = std::sqrt(sum_sq);\n\n        // Compare the calculated norm with the corresponding threshold and store the boolean result.\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For sqrt\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    // Loop through each row of the matrix\n    for (size_t i = 0; i < rows; ++i) {\n        // Initialize a vector to accumulate the sum of squares for the current row\n        svfloat64_t sum_sq_vec = svdup_f64(0.0);\n\n        // Get the base pointer for the current row in the flattened matrix\n        const double* current_row_ptr = &matrix[i * cols];\n\n        // Get the number of double elements that fit into an SVE vector\n        size_t sv_double_count = svcntd();\n\n        // Loop through the columns, processing 'sv_double_count' elements at a time\n        for (size_t j = 0; j < cols; j += sv_double_count) {\n            // Create a predicate for the current vector chunk.\n            // This predicate ensures that we only process valid elements up to 'cols'.\n            svbool_t current_pg = svwhilelt_b64(j, cols);\n\n            // Load a vector of double elements from the current row\n            svfloat64_t row_elements = svld1_f64(current_pg, current_row_ptr + j);\n\n            // Square each loaded element\n            svfloat64_t squared_elements = svmul_f64(current_pg, row_elements, row_elements);\n\n            // Accumulate the sum of squares. Elements not enabled by 'current_pg' in 'squared_elements'\n            // are not added, and corresponding elements in 'sum_sq_vec' remain unchanged.\n            sum_sq_vec = svadd_f64(current_pg, sum_sq_vec, squared_elements);\n        }\n\n        // Horizontally sum all elements in the 'sum_sq_vec' to get the total sum of squares for the row.\n        // svptrue_b64() creates a predicate where all lanes are active.\n        double total_sum_of_squares = svaddv_f64(svptrue_b64(), sum_sq_vec);\n\n        // Calculate the Euclidean norm by taking the square root of the total sum of squares\n        double norm = sqrt(total_sum_of_squares);\n\n        // Compare the calculated norm with the corresponding threshold and store the boolean result\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t sv_doubles = svcntd();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* current_row_ptr = &matrix[i * cols];\n        svfloat64_t sum_sq_vec = svdup_f64(0.0);\n\n        for (size_t j = 0; j < cols; j += sv_doubles) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t row_elements = svld1_f64(pg, current_row_ptr + j);\n            svfloat64_t squared_elements = svmul_f64(row_elements, row_elements);\n            sum_sq_vec = svadd_f64(sum_sq_vec, squared_elements);\n        }\n\n        svbool_t pg_full = svptrue_b64();\n        double row_norm_sq = svaddv_f64(pg_full, sum_sq_vec);\n\n        double threshold_val = thresholds[i];\n        double threshold_sq = threshold_val * threshold_val;\n\n        result[i] = (row_norm_sq > threshold_sq);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // Required for sqrt\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* current_row_ptr = matrix + i * cols;\n        double row_sum_sq = 0.0;\n\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        size_t col_idx = 0;\n        svbool_t pg;\n\n        while (col_idx < cols) {\n            pg = svwhilelt_b64(col_idx, cols);\n            svfloat64_t row_elements = svld1_f64(pg, current_row_ptr + col_idx);\n            svfloat64_t squares = svmul_f64(pg, row_elements, row_elements);\n            sum_vec = svadd_f64(pg, sum_vec, squares);\n            col_idx += svcntd();\n        }\n\n        row_sum_sq = svaddv_f64(svptrue_b64(), sum_vec);\n\n        double row_norm = sqrt(row_sum_sq);\n\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    // Get the number of 32-bit elements a vector can hold\n    size_t sv_elements = svcntw();\n\n    // Loop through the arrays in chunks of SVE vector length\n    // The loop continues as long as there are enough elements for at least one full SVE vector\n    for (; i + sv_elements <= length; i += sv_elements) {\n        // Load elements from A into an SVE vector\n        svuint32_t vec_a = svld1_u32(svptrue_b32(), A + i);\n        // Load elements from B into an SVE vector\n        svuint32_t vec_b = svld1_u32(svptrue_b32(), B + i);\n\n        // Perform element-wise bitwise OR operation\n        svuint32_t vec_c = svorr_u32(vec_a, vec_b);\n\n        // Store the result into C\n        svst1_u32(svptrue_b32(), C + i, vec_c);\n    }\n\n    // Handle remaining elements (tail processing)\n    // If there are any elements left that didn't fit into full SVE vectors\n    if (i < length) {\n        // Create a predicate for the remaining elements\n        // This predicate will be true for elements from 'i' up to 'length - 1'\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load the remaining elements from A using the predicate\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        // Load the remaining elements from B using the predicate\n        svuint32_t vec_b = svld1_u32(pg, B + i);\n\n        // Perform element-wise bitwise OR operation on the remaining elements\n        svuint32_t vec_c = svorr_u32(vec_a, vec_b);\n\n        // Store the result into C using the predicate\n        svst1_u32(pg, C + i, vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Get a predicate for the current vector operation.\n        // svwhilelt_b32(i, length) generates a predicate that is true for\n        // elements from 'i' up to 'length - 1', effectively handling the\n        // loop termination and the tail elements automatically.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit unsigned integers from A.\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // Load a vector of 32-bit unsigned integers from B.\n        svuint32_t vec_B = svld1_u32(pg, B + i);\n\n        // Perform element-wise bitwise OR operation.\n        svuint32_t vec_C = svorr_u32(vec_A, vec_B);\n\n        // Store the result vector to C.\n        svst1_u32(pg, C + i, vec_C);\n\n        // Increment the index by the number of 32-bit elements in a full SVE vector.\n        // The predicate 'pg' ensures that only valid elements are processed,\n        // and the loop condition 'i < length' combined with svwhilelt_b32\n        // correctly handles the last (possibly partial) vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < length) {\n        // Get a predicate for the current vector length, processing up to 'length - i' elements\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load vector from A\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // Load vector from B\n        svuint32_t vec_B = svld1_u32(pg, B + i);\n\n        // Perform element-wise bitwise OR operation\n        svuint32_t vec_C = svorr_u32(vec_A, vec_B);\n\n        // Store the result into C\n        svst1_u32(pg, C + i, vec_C);\n\n        // Increment the index by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        // Get the number of 32-bit elements that fit in an SVE vector\n        // This determines the current vector length (VL)\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load elements from A and B into SVE vectors using the predicate guard\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n        svuint32_t vec_B = svld1_u32(pg, B + i);\n\n        // Perform element-wise bitwise OR operation\n        svuint32_t vec_C = svorr_u32_z(pg, vec_A, vec_B);\n\n        // Store the result back into C using the predicate guard\n        svst1_u32(pg, C + i, vec_C);\n\n        // Update the loop counter and remaining length\n        // svcntw() returns the number of 32-bit elements in the current vector length (VL)\n        i += svcntw();\n        length -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the arrays in chunks of SVE vector length\n    // The svwhilelt_b32 intrinsic generates a predicate that is true for elements\n    // where the current index 'i' is less than 'length'. This handles\n    // both full vectors and the tail (remaining elements).\n    while (i < length) {\n        // Generate a predicate for the current vector operation.\n        // This predicate will be active for elements from 'i' up to 'length - 1'.\n        pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit unsigned integers from A, using the predicate.\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n\n        // Load a vector of 32-bit unsigned integers from B, using the predicate.\n        svuint32_t vec_b = svld1_u32(pg, &B[i]);\n\n        // Perform element-wise bitwise OR operation between vec_a and vec_b.\n        svuint32_t vec_c = svorr_u32(vec_a, vec_b);\n\n        // Store the result vector vec_c into C, using the predicate.\n        svst1_u32(pg, &C[i], vec_c);\n\n        // Increment the index by the number of 32-bit elements in an SVE vector.\n        // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    // Initialize 64-bit sum accumulator. This will hold the final sum of all elements.\n    svint64_t sum_vec_64 = svdup_s64(0);\n\n    // Initialize four 32-bit sum accumulators.\n    // Each 8-bit vector (VL bytes) processed will produce VL/2 16-bit products.\n    // These VL/2 16-bit products are split into two VL/4 16-bit vectors (vprod_l, vprod_h).\n    // Each VL/4 16-bit vector is then widened to two VL/8 32-bit vectors.\n    // So, a single VL-byte iteration produces 4 VL/8 32-bit vectors of products.\n    // These are accumulated into four separate 32-bit sum vectors to prevent overflow\n    // before converting to 64-bit.\n    svint32_t sum_vec_32_0 = svdup_s32(0);\n    svint32_t sum_vec_32_1 = svdup_s32(0);\n    svint32_t sum_vec_32_2 = svdup_s32(0);\n    svint32_t sum_vec_32_3 = svdup_s32(0);\n\n    size_t i = 0;\n    while (i < length) {\n        // Get a predicate for the current chunk of 8-bit elements.\n        // svwhilelt_b8 generates a predicate that is true for elements\n        // from 'i' up to 'length-1', and false otherwise.\n        // This intrinsically handles the tail of the array.\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        // Load 8-bit vectors from A and B using the predicate.\n        // Inactive lanes (where predicate is false) will be loaded as zeros.\n        svint8_t va = svld1(pg, A + i);\n        svint8_t vb = svld1(pg, B + i);\n\n        // Calculate the difference: A[i] - B[i].\n        // svsub_s8_z ensures that result lanes corresponding to false predicate\n        // elements are zero, maintaining the zero-padding from the loads.\n        svint8_t vdiff = svsub_s8_z(pg, va, vb);\n\n        // Widen the 8-bit vectors to 16-bit vectors.\n        // svmovlb_s16_s8 moves the low half of the 8-bit vector elements to a 16-bit vector.\n        // svmovlt_s16_s8 moves the high half.\n        // The zeroed inactive lanes from va and vdiff will propagate to va_l, va_h, vdiff_l, vdiff_h.\n        svint16_t va_l = svmovlb_s16_s8(va);\n        svint16_t va_h = svmovlt_s16_s8(va);\n        svint16_t vdiff_l = svmovlb_s16_s8(vdiff);\n        svint16_t vdiff_h = svmovlt_s16_s8(vdiff);\n\n        // Perform element-wise multiplication: A[i] * (A[i] - B[i]).\n        // Since inactive lanes in va_l/h and vdiff_l/h are already zero (due to prior predicated operations),\n        // we can use a true predicate (svptrue_b16()) for multiplication.\n        // The _z suffix on svmul_s16_z ensures that inactive lanes in the result are zeroed,\n        // which is redundant here but harmless.\n        svbool_t pg_16_all = svptrue_b16(); \n        svint16_t vprod_l = svmul_s16_z(pg_16_all, va_l, vdiff_l);\n        svint16_t vprod_h = svmul_s16_z(pg_16_all, va_h, vdiff_h);\n\n        // Widen the 16-bit product vectors to 32-bit vectors for accumulation.\n        // Each 16-bit vector splits into two 32-bit vectors.\n        svint32_t vprod_l_32_l = svmovlb_s32_s16(vprod_l);\n        svint32_t vprod_l_32_h = svmovlt_s32_s16(vprod_l);\n        svint32_t vprod_h_32_l = svmovlb_s32_s16(vprod_h);\n        svint32_t vprod_h_32_h = svmovlt_s32_s16(vprod_h);\n\n        // Accumulate the 32-bit product vectors into the 32-bit sum accumulators.\n        // Since inactive lanes are already zero, unpredicated addition (svadd_s32) is safe.\n        sum_vec_32_0 = svadd_s32(sum_vec_32_0, vprod_l_32_l);\n        sum_vec_32_1 = svadd_s32(sum_vec_32_1, vprod_l_32_h);\n        sum_vec_32_2 = svadd_s32(sum_vec_32_2, vprod_h_32_l);\n        sum_vec_32_3 = svadd_s32(sum_vec_32_3, vprod_h_32_h);\n\n        // Advance the pointer and length counter by the number of processed elements.\n        i += svcnt_b8(pg);\n    }\n\n    // After the loop, sum the four 32-bit accumulators into 64-bit accumulators.\n    // Each 32-bit vector splits into two 64-bit vectors.\n    svint64_t sum_vec_64_0 = svmovlb_s64_s32(sum_vec_32_0);\n    svint64_t sum_vec_64_1 = svmovlt_s64_s32(sum_vec_32_0);\n    svint64_t sum_vec_64_2 = svmovlb_s64_s32(sum_vec_32_1);\n    svint64_t sum_vec_64_3 = svmovlt_s64_s32(sum_vec_32_1);\n    svint64_t sum_vec_64_4 = svmovlb_s64_s32(sum_vec_32_2);\n    svint64_t sum_vec_64_5 = svmovlt_s64_s32(sum_vec_32_2);\n    svint64_t sum_vec_64_6 = svmovlb_s64_s32(sum_vec_32_3);\n    svint64_t sum_vec_64_7 = svmovlt_s64_s32(sum_vec_32_3);\n\n    // Sum all eight 64-bit intermediate sum vectors into the final 64-bit accumulator.\n    // Unpredicated addition is safe as inactive lanes are zero.\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_0);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_1);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_2);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_3);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_4);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_5);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_6);\n    sum_vec_64 = svadd_s64(sum_vec_64, sum_vec_64_7);\n\n    // Perform a horizontal sum of the final 64-bit accumulator vector to get a scalar result.\n    // svptrue_b64() ensures all elements in the final vector are summed.\n    return svaddv_s64(svptrue_b64(), sum_vec_64);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": ""}
{"task_id": "SimdBench_41_SVE", "completion": "```c++\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total_sum = 0;\n    size_t i = 0;\n\n    // Loop through the arrays in chunks determined by the SVE vector length for 8-bit elements.\n    for (i = 0; i < length; i += svcntb()) {\n        // Get the predicate for the current chunk of 8-bit elements.\n        // This predicate ensures that operations only apply to valid elements,\n        // especially for the tail end of the array.\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load 8-bit vectors from A and B.\n        svint8_t va_8 = svld1_s8(pg, A + i);\n        svint8_t vb_8 = svld1_s8(pg, B + i);\n\n        // Widen 8-bit integers to 16-bit integers.\n        // svcvt_s16_s8 produces a vector of the same element count as the input (VL_B elements).\n        svint16_t va_16 = svcvt_s16_s8(pg, va_8);\n        svint16_t vb_16 = svcvt_s16_s8(pg, vb_8);\n\n        // Split the 16-bit vectors into two halves (even and odd elements).\n        // Each half will contain VL_B/2 elements. This is necessary because\n        // svcvt_s32_s16 converts a 16-bit vector to a 32-bit vector with half the element count.\n        svint16_t va_16_0 = svuzp1_s16(va_16, va_16); // Even-indexed elements\n        svint16_t va_16_1 = svuzp2_s16(va_16, va_16); // Odd-indexed elements\n        svint16_t vb_16_0 = svuzp1_s16(vb_16, vb_16);\n        svint16_t vb_16_1 = svuzp2_s16(vb_16, vb_16);\n\n        // Convert 16-bit halves to 32-bit integers.\n        // This is crucial to prevent overflow during multiplication and summation,\n        // as (128*128 + 128*128 - (-128*128)) can exceed int16_t max.\n        // svcvt_s32_s16 takes a predicate for 16-bit elements. We use svptrue_b16()\n        // because we want to convert all elements in these split halves.\n        svint32_t va_32_0 = svcvt_s32_s16(svptrue_b16(), va_16_0);\n        svint32_t va_32_1 = svcvt_s32_s16(svptrue_b16(), va_16_1);\n        svint32_t vb_32_0 = svcvt_s32_s16(svptrue_b16(), vb_16_0);\n        svint32_t vb_32_1 = svcvt_s32_s16(svptrue_b16(), vb_16_1);\n\n        // Calculate squares (A*A, B*B) and product (A*B) using 32-bit multiplication.\n        // svmul_s32 operates on 32-bit vectors.\n        svint32_t va_sq_32_0 = svmul_s32(va_32_0, va_32_0);\n        svint32_t va_sq_32_1 = svmul_s32(va_32_1, va_32_1);\n        svint32_t vb_sq_32_0 = svmul_s32(vb_32_0, vb_32_0);\n        svint32_t vb_sq_32_1 = svmul_s32(vb_32_1, vb_32_1);\n        svint32_t vab_prod_32_0 = svmul_s32(va_32_0, vb_32_0);\n        svint32_t vab_prod_32_1 = svmul_s32(va_32_1, vb_32_1);\n\n        // Calculate (A*A + B*B - A*B) for each element in 32-bit.\n        svint32_t term_32_0 = svsub_s32(svadd_s32(va_sq_32_0, vb_sq_32_0), vab_prod_32_0);\n        svint32_t term_32_1 = svsub_s32(svadd_s32(va_sq_32_1, vb_sq_32_1), vab_prod_32_1);\n\n        // Reduce the 32-bit vector sums to scalar and accumulate into total_sum.\n        // The predicate for svaddv_s32 must correspond to the active elements in the 32-bit vectors.\n        // We derive these predicates from the original 8-bit predicate 'pg'.\n        // svreinterpret_b16_b8 reinterprets the 8-bit predicate as a 16-bit predicate.\n        // svuzp1_b16 and svuzp2_b16 then split this 16-bit predicate into two 32-bit predicates.\n        svbool_t pg_32_0 = svuzp1_b16(svreinterpret_b16_b8(pg), svreinterpret_b16_b8(pg));\n        svbool_t pg_32_1 = svuzp2_b16(svreinterpret_b16_b8(pg), svreinterpret_b16_b8(pg));\n        \n        total_sum += svaddv_s32(pg_32_0, term_32_0);\n        total_sum += svaddv_s32(pg_32_1, term_32_1);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total_sum = 0;\n    size_t i = 0;\n\n    // Accumulator for 32-bit sums.\n    // The maximum intermediate sum for a single element (A[i]*A[i] + B[i]*B[i] - A[i]*B[i])\n    // is approximately 48769 (e.g., A=127, B=-128).\n    // A full SVE vector of 32-bit elements (e.g., 16 elements for 512-bit SVE)\n    // can hold 16 * 48769 = 780304, which fits within int32_t.\n    // The final sum over 'length' elements can exceed int32_t, so a 64-bit accumulator is needed.\n    svint32_t sum_vec_s32 = svdup_s32(0);\n\n    while (i < length) {\n        // Get a predicate for the current chunk of 8-bit elements.\n        // This predicate ensures we only process valid elements, especially for the tail.\n        svbool_t pg_8 = svwhilelt_b8(i, length);\n        \n        // Get the number of active 8-bit elements in this chunk.\n        size_t num_active_8 = svcnt_s8(pg_8);\n\n        // Load 8-bit vectors from A and B.\n        svint8_t a_8 = svld1_s8(pg_8, A + i);\n        svint8_t b_8 = svld1_s8(pg_8, B + i);\n\n        // Widen the 8-bit elements to 16-bit for multiplication.\n        // svcnv_s16_s8 converts a full svint8_t vector (svcntb() elements)\n        // into a full svint16_t vector (svcnth() elements).\n        svint16_t a_16 = svcnv_s16_s8(a_8);\n        svint16_t b_16 = svcnv_s16_s8(b_8);\n\n        // Create a predicate for 16-bit operations.\n        // This predicate should cover `num_active_8 / 2` elements, as each 16-bit element\n        // corresponds to two 8-bit elements.\n        svbool_t pg_16 = svwhilelt_b16(0, num_active_8 / 2);\n\n        // Perform element-wise operations using 16-bit arithmetic.\n        // sq_A = A[i]*A[i]\n        // sq_B = B[i]*B[i]\n        // prod_AB = A[i]*B[i]\n        svint16_t sq_A = svmul_s16_x(pg_16, a_16, a_16);\n        svint16_t sq_B = svmul_s16_x(pg_16, b_16, b_16);\n        svint16_t prod_AB = svmul_s16_x(pg_16, a_16, b_16);\n\n        // Calculate (A[i]*A[i] + B[i]*B[i] - A[i]*B[i]) for each element.\n        svint16_t term_s16 = svadd_s16_x(pg_16, sq_A, sq_B);\n        term_s16 = svsub_s16_x(pg_16, term_s16, prod_AB);\n\n        // Widen the 16-bit results to 32-bit for accumulation.\n        // svcnv_s32_s16 converts a full svint16_t vector (svcnth() elements)\n        // into a full svint32_t vector (svcntw() elements).\n        svint32_t term_s32 = svcnv_s32_s16(term_s16);\n\n        // Create a predicate for 32-bit operations.\n        // This predicate should cover `num_active_8 / 4` elements.\n        svbool_t pg_32 = svwhilelt_b32(0, num_active_8 / 4);\n\n        // Accumulate the 32-bit terms into the 32-bit sum vector.\n        sum_vec_s32 = svadd_s32_x(pg_32, sum_vec_s32, term_s32);\n\n        // Advance the index by the number of 8-bit elements processed in this iteration.\n        i += num_active_8;\n    }\n\n    // After the loop, horizontally sum the 32-bit accumulator vector.\n    // First, widen the 32-bit sum vector to 64-bit.\n    // svcnv_s64_s32 converts a full svint32_t vector (svcntw() elements)\n    // into a full svint64_t vector (svcntd() elements).\n    svint64_t final_sum_vec_s64 = svcnv_s64_s32(sum_vec_s32);\n\n    // Reduce the 64-bit vector to a single scalar sum.\n    // svptrue_b64() creates a predicate where all 64-bit elements are active.\n    total_sum = svaddv_s64(svptrue_b64(), final_sum_vec_s64);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total_sum_sq = 0;\n    int64_t total_sum_prod = 0;\n\n    size_t i = 0;\n    size_t vl_8 = svcntb(); // Number of 8-bit elements in a vector\n    // vl_16 = svcntw() (vl_8 / 2)\n    // vl_32 = svcntd() (vl_16 / 2)\n\n    // The SVE widening multiply-add long intrinsic `svmlal_s16` takes two `svint16_t`\n    // vectors (each with `vl_32` elements) and accumulates their products into an\n    // `svint32_t` vector (also with `vl_32` elements).\n    // To get `svint16_t` vectors from `svint8_t` vectors, `svcvt_s16_s8` is used.\n    // This intrinsic converts the first half of an `svint8_t` vector (vl_8 elements)\n    // into an `svint16_t` vector (vl_16 elements).\n    // To process a full `svint8_t` vector and then split its `int16_t` representation\n    // into even/odd parts for `svmlal_s16`, we need to load `2 * vl_8` bytes at a time.\n    // This ensures we can generate four `svint16_t` vectors (two from A, two from B)\n    // and then split each of those into two `svint16_t` vectors (even/odd elements),\n    // each containing `vl_32` elements, suitable for `svmlal_s16`.\n    size_t loop_step = 2 * vl_8; \n\n    svbool_t pg_8 = svptrue_b8();   // Predicate for 8-bit operations\n    svbool_t pg_32 = svptrue_b32(); // Predicate for 32-bit operations (for horizontal sum)\n\n    // Main loop for SVE vector processing\n    for (; i + loop_step <= length; i += loop_step) {\n        // Load two svint8_t vectors for A and B\n        svint8_t va_8_0 = svld1_s8(pg_8, A + i);\n        svint8_t vb_8_0 = svld1_s8(pg_8, B + i);\n        svint8_t va_8_1 = svld1_s8(pg_8, A + i + vl_8);\n        svint8_t vb_8_1 = svld1_s8(pg_8, B + i + vl_8);\n\n        // Convert int8_t to int16_t. Each svint8_t vector (vl_8 elements)\n        // produces one svint16_t vector (vl_8/2 = vl_16 elements).\n        svint16_t va_16_0 = svcvt_s16_s8(va_8_0);\n        svint16_t vb_16_0 = svcvt_s16_s8(vb_8_0);\n        svint16_t va_16_1 = svcvt_s16_s8(va_8_1);\n        svint16_t vb_16_1 = svcvt_s16_s8(vb_8_1);\n\n        // Initialize temporary 32-bit accumulators for this chunk\n        svint32_t current_sum_sq_32 = svdup_s32(0);\n        svint32_t current_sum_prod_32 = svdup_s32(0);\n\n        // Process the first half of the 2*vl_8 chunk (from va_16_0 and vb_16_0)\n        // Split svint16_t vectors into even and odd elements.\n        // Each resulting vector (e.g., va_16_0_even) has vl_16/2 = vl_32 elements,\n        // which is the correct size for svmlal_s16 operands.\n        svint16_t va_16_0_even = svuzp1_s16(va_16_0, va_16_0);\n        svint16_t va_16_0_odd = svuzp2_s16(va_16_0, va_16_0);\n        svint16_t vb_16_0_even = svuzp1_s16(vb_16_0, vb_16_0);\n        svint16_t vb_16_0_odd = svuzp2_s16(vb_16_0, vb_16_0);\n\n        // Accumulate squares: A*A + B*B using widening multiply-add long\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, va_16_0_even, va_16_0_even);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, vb_16_0_even, vb_16_0_even);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, va_16_0_odd, va_16_0_odd);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, vb_16_0_odd, vb_16_0_odd);\n\n        // Accumulate products: A*B using widening multiply-add long\n        current_sum_prod_32 = svmlal_s16(current_sum_prod_32, va_16_0_even, vb_16_0_even);\n        current_sum_prod_32 = svmlal_s16(current_sum_prod_32, va_16_0_odd, vb_16_0_odd);\n\n        // Process the second half of the 2*vl_8 chunk (from va_16_1 and vb_16_1)\n        svint16_t va_16_1_even = svuzp1_s16(va_16_1, va_16_1);\n        svint16_t va_16_1_odd = svuzp2_s16(va_16_1, va_16_1);\n        svint16_t vb_16_1_even = svuzp1_s16(vb_16_1, vb_16_1);\n        svint16_t vb_16_1_odd = svuzp2_s16(vb_16_1, vb_16_1);\n\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, va_16_1_even, va_16_1_even);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, vb_16_1_even, vb_16_1_even);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, va_16_1_odd, va_16_1_odd);\n        current_sum_sq_32 = svmlal_s16(current_sum_sq_32, vb_16_1_odd, vb_16_1_odd);\n\n        current_sum_prod_32 = svmlal_s16(current_sum_prod_32, va_16_1_even, vb_16_1_even);\n        current_sum_prod_32 = svmlal_s16(current_sum_prod_32, va_16_1_odd, vb_16_1_odd);\n\n        // Horizontally sum the 32-bit accumulators and add to total 64-bit scalars\n        total_sum_sq += svaddv_s32(pg_32, current_sum_sq_32);\n        total_sum_prod += svaddv_s32(pg_32, current_sum_prod_32);\n    }\n\n    // Tail processing for remaining elements (if length is not a multiple of loop_step)\n    for (; i < length; ++i) {\n        int64_t a_val = A[i]; // Promote to int64_t to prevent overflow during multiplication\n        int64_t b_val = B[i];\n        total_sum_sq += a_val * a_val + b_val * b_val;\n        total_sum_prod += a_val * b_val;\n    }\n\n    return total_sum_sq - total_sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        // Get the predicate for the current vector length\n        // svwhilelt_b64(i, length) generates a predicate that is true for elements\n        // where the current index 'i' is less than 'length'.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load a vector from A\n        svuint64_t vec_A = svld1_u64(pg, A + i);\n\n        // Load a vector from B\n        svuint64_t vec_B = svld1_u64(pg, B + i);\n\n        // Perform bitwise NOT on vec_B\n        svuint64_t vec_not_B = svnot_u64_x(pg, vec_B); // _x variant for predicated operation\n\n        // Perform bitwise AND between vec_A and vec_not_B\n        svuint64_t vec_result = svand_u64_x(pg, vec_A, vec_not_B); // _x variant for predicated operation\n\n        // Store the result to C\n        svst1_u64(pg, C + i, vec_result);\n\n        // Get the number of elements processed in this iteration\n        // svcntd() returns the number of 64-bit elements in a full SVE vector.\n        size_t elements_processed = svcntd();\n\n        // Update the loop variables\n        i += elements_processed;\n        length -= elements_processed;\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < length) {\n        // Get a predicate for the current vector length, processing up to 'length' elements\n        // starting from 'i'. The predicate 'pg' will be true for active lanes.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load a vector of 64-bit unsigned integers from A using the predicate 'pg'.\n        // Only active lanes will load data; inactive lanes will have undefined values.\n        svuint64_t vec_A = svld1_u64(pg, A + i);\n\n        // Load a vector of 64-bit unsigned integers from B using the predicate 'pg'.\n        svuint64_t vec_B = svld1_u64(pg, B + i);\n\n        // Perform bitwise NOT operation on vec_B.\n        svuint64_t vec_not_B = svnot_u64_z(pg, vec_B); // _z variant ensures inactive lanes are zeroed\n\n        // Perform bitwise AND operation between vec_A and vec_not_B.\n        // The result will be C[i] = A[i] & (~B[i]).\n        svuint64_t vec_result = svand_u64_z(pg, vec_A, vec_not_B); // _z variant ensures inactive lanes are zeroed\n\n        // Store the result vector into C using the predicate 'pg'.\n        // Only active lanes will write data.\n        svst1_u64(pg, C + i, vec_result);\n\n        // Increment the index 'i' by the number of 64-bit elements processed in this iteration.\n        // svcntd() returns the number of 64-bit elements in a full SVE vector.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    while (length > 0) {\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        svuint64_t vec_a = svld1_u64(pg, &A[i]);\n        svuint64_t vec_b = svld1_u64(pg, &B[i]);\n\n        // Perform bitwise NOT on vec_b\n        svuint64_t vec_not_b = svnot_u64_z(pg, vec_b); // Use _z variant for zeroing inactive elements\n\n        // Perform bitwise AND between vec_a and vec_not_b\n        svuint64_t vec_result = svand_u64_z(pg, vec_a, vec_not_b); // Use _z variant for zeroing inactive elements\n\n        svst1_u64(pg, &C[i], vec_result);\n\n        size_t elements_processed = svcntd();\n        i += elements_processed;\n        length -= elements_processed;\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        svuint64_t vec_A = svld1(pg, A + i);\n        svuint64_t vec_B = svld1(pg, B + i);\n\n        // Perform bitwise NOT on B\n        svuint64_t vec_not_B = svnot_u64_z(pg, vec_B);\n\n        // Perform bitwise AND between A and (NOT B)\n        svuint64_t vec_result = svand_u64_z(pg, vec_A, vec_not_B);\n\n        svst1(pg, C + i, vec_result);\n\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        svuint64_t vec_a = svld1_u64(pg, A + i);\n        svuint64_t vec_b = svld1_u64(pg, B + i);\n\n        // Perform bitwise NOT on B\n        svuint64_t vec_not_b = svnot_u64_x(pg, vec_b);\n\n        // Perform bitwise AND between A and (NOT B)\n        svuint64_t vec_result = svand_u64_x(pg, vec_a, vec_not_b);\n\n        svst1_u64(pg, C + i, vec_result);\n\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    // Loop while 'i' is less than 'length', generating a predicate for 8-bit elements.\n    // The predicate 'pg' will be true for elements within the bounds [i, length-1].\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    do {\n        // Load vector segments from A and B using the current predicate 'pg'.\n        // Only elements corresponding to true bits in 'pg' will be loaded.\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n\n        // Initialize the result vector for C with zeros.\n        // This serves as the default value for elements that don't meet the other conditions.\n        svint8_t vc_res = svdup_s8(0);\n\n        // Condition 1: A[k] > 0 AND B[k] > 0 => C[k] = 1\n        // Create predicates for A > 0 and B > 0.\n        svbool_t pa_gt_0 = svcmpgt_s8(pg, va, 0);\n        svbool_t pb_gt_0 = svcmpgt_s8(pg, vb, 0);\n        // Combine the predicates using a logical AND.\n        svbool_t p_both_gt_0 = svand_b(pa_gt_0, pb_gt_0);\n        // Select 1 for elements where p_both_gt_0 is true, otherwise keep the current value in vc_res (which is 0).\n        vc_res = svsel_s8(vc_res, svdup_s8(1), p_both_gt_0);\n\n        // Condition 2: A[k] < 0 AND B[k] < 0 => C[k] = -1\n        // Create predicates for A < 0 and B < 0.\n        svbool_t pa_lt_0 = svcmplt_s8(pg, va, 0);\n        svbool_t pb_lt_0 = svcmplt_s8(pg, vb, 0);\n        // Combine the predicates using a logical AND.\n        svbool_t p_both_lt_0 = svand_b(pa_lt_0, pb_lt_0);\n        // Select -1 for elements where p_both_lt_0 is true.\n        // Since the two conditions (both > 0 and both < 0) are mutually exclusive,\n        // this operation will not conflict with the previous svsel_s8.\n        vc_res = svsel_s8(vc_res, svdup_s8(-1), p_both_lt_0);\n\n        // Store the computed result vector into C using the current predicate 'pg'.\n        svst1_s8(pg, C + i, vc_res);\n\n        // Increment the loop counter by the number of 8-bit elements in an SVE vector.\n        i += svcntb();\n        // Generate the next predicate for the loop.\n        pg = svwhilelt_b8(i, length);\n    } while (svptest_any(svptrue_b8(), pg)); // Continue loop as long as 'pg' has any active elements.\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    // Loop while the current index 'i' is less than the total 'length'\n    // svwhilelt_b8 generates a predicate for 8-bit elements\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    do {\n        // Load vectors from A and B using the current predicate 'pg'\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n\n        // Initialize the result vector 'vc' with zeros.\n        // This handles the \"in other cases, C[i][j][k] should be 0\" condition.\n        svint8_t vc = svdup_s8(0);\n\n        // Condition 1: If A[i] > 0 AND B[i] > 0, C[i] should be 1\n        // Create predicates for A > 0 and B > 0\n        svbool_t p_A_gt_0 = svcmpgt_s8(pg, va, svdup_s8(0));\n        svbool_t p_B_gt_0 = svcmpgt_s8(pg, vb, svdup_s8(0));\n        // Combine the predicates with logical AND\n        svbool_t p_both_gt_0 = svand_b8(p_A_gt_0, p_B_gt_0);\n        // Select 1 where p_both_gt_0 is true, otherwise keep the current value in vc\n        vc = svsel_s8(p_both_gt_0, svdup_s8(1), vc);\n\n        // Condition 2: If A[i] < 0 AND B[i] < 0, C[i] should be -1\n        // Create predicates for A < 0 and B < 0\n        svbool_t p_A_lt_0 = svcmplt_s8(pg, va, svdup_s8(0));\n        svbool_t p_B_lt_0 = svcmplt_s8(pg, vb, svdup_s8(0));\n        // Combine the predicates with logical AND\n        svbool_t p_both_lt_0 = svand_b8(p_A_lt_0, p_B_lt_0);\n        // Select -1 where p_both_lt_0 is true, otherwise keep the current value in vc\n        // Note: Conditions 1 and 2 are mutually exclusive, so sequential svsel is fine.\n        vc = svsel_s8(p_both_lt_0, svdup_s8(-1), vc);\n\n        // Store the result vector 'vc' back to C\n        svst1_s8(pg, C + i, vc);\n\n        // Increment the index 'i' by the number of processed elements (vector length)\n        i += svcntb();\n        // Generate the next predicate for the remaining elements\n        pg = svwhilelt_b8(i, length);\n    } while (svcnt_b8(pg) > 0); // Continue as long as there are active elements in the predicate\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Duplicate scalar values into SVE vectors for constants\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0); // Used for initializing C_vec and comparisons\n\n    while (i < length) {\n        // Get the predicate for the current vector length.\n        // This handles the loop termination and partial vectors at the end.\n        pg = svwhilelt_b8(i, length);\n\n        // Load vectors from A and B using the generated predicate\n        svint8_t a_vec = svld1_s8(pg, A + i);\n        svint8_t b_vec = svld1_s8(pg, B + i);\n\n        // Initialize the result vector for C with zeros.\n        // Elements that do not satisfy either condition will remain 0.\n        svint8_t c_vec = zero_vec;\n\n        // Condition 1: if A[i] > 0 AND B[i] > 0, C[i] should be 1\n        // Create predicates for A > 0 and B > 0\n        svbool_t pg_a_gt_0 = svcmpgt_s8(pg, a_vec, 0);\n        svbool_t pg_b_gt_0 = svcmpgt_s8(pg, b_vec, 0);\n        // Combine predicates: (A > 0 AND B > 0)\n        svbool_t pg_both_gt_0 = svand_b8(pg, pg_a_gt_0, pg_b_gt_0);\n        // Select 1 for elements where pg_both_gt_0 is true, otherwise keep current c_vec value (initially 0)\n        c_vec = svsel_s8(pg_both_gt_0, one_vec, c_vec);\n\n        // Condition 2: if A[i] < 0 AND B[i] < 0, C[i] should be -1\n        // Create predicates for A < 0 and B < 0\n        svbool_t pg_a_lt_0 = svcmplt_s8(pg, a_vec, 0);\n        svbool_t pg_b_lt_0 = svcmplt_s8(pg, b_vec, 0);\n        // Combine predicates: (A < 0 AND B < 0)\n        svbool_t pg_both_lt_0 = svand_b8(pg, pg_a_lt_0, pg_b_lt_0);\n        // Select -1 for elements where pg_both_lt_0 is true, otherwise keep current c_vec value (which could be 0 or 1)\n        c_vec = svsel_s8(pg_both_lt_0, neg_one_vec, c_vec);\n\n        // Store the computed result vector back to C\n        svst1_s8(pg, C + i, c_vec);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        // svcntb() returns the number of 8-bit elements in an SVE vector (VL).\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    // Get the predicate for the first vector chunk, covering elements from 'i' up to 'length'.\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    // Define constant vectors for 0, 1, and -1.\n    const svint8_t zero_vec = svdup_s8(0);\n    const svint8_t one_vec = svdup_s8(1);\n    const svint8_t neg_one_vec = svdup_s8(-1);\n\n    // Loop while the predicate indicates there are active elements.\n    while (svcnt_b8(pg) > 0) {\n        // Load vector chunks from A and B using the current predicate.\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n\n        // --- Condition 1: A[i] > 0 AND B[i] > 0 (result should be 1) ---\n        // Create predicates for A > 0 and B > 0.\n        svbool_t a_gt_0_pred = svcmpgt_s8(pg, a_vec, zero_vec);\n        svbool_t b_gt_0_pred = svcmpgt_s8(pg, b_vec, zero_vec);\n        // Combine them with a logical AND to get the predicate for the positive condition.\n        svbool_t pos_cond_pred = svand_b(a_gt_0_pred, b_gt_0_pred);\n\n        // --- Condition 2: A[i] < 0 AND B[i] < 0 (result should be -1) ---\n        // Create predicates for A < 0 and B < 0.\n        svbool_t a_lt_0_pred = svcmplt_s8(pg, a_vec, zero_vec);\n        svbool_t b_lt_0_pred = svcmplt_s8(pg, b_vec, zero_vec);\n        // Combine them with a logical AND to get the predicate for the negative condition.\n        svbool_t neg_cond_pred = svand_b(a_lt_0_pred, b_lt_0_pred);\n\n        // Initialize the result vector C with zeros (default case).\n        svint8_t c_vec = zero_vec;\n\n        // Apply the positive condition: if pos_cond_pred is true, set element to 1.\n        // Otherwise, keep the current value in c_vec (which is 0 or potentially -1 if processed later).\n        c_vec = svsel_s8(pos_cond_pred, one_vec, c_vec);\n\n        // Apply the negative condition: if neg_cond_pred is true, set element to -1.\n        // Since the positive and negative conditions are mutually exclusive for any given element,\n        // this will correctly overwrite elements that were initially 0 (or not affected by pos_cond_pred).\n        c_vec = svsel_s8(neg_cond_pred, neg_one_vec, c_vec);\n\n        // Store the resulting vector chunk into C.\n        svst1_s8(pg, &C[i], c_vec);\n\n        // Advance the index by the number of elements processed in this chunk.\n        i += svcnt_b8(pg);\n        // Generate the predicate for the next vector chunk.\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Loop through the arrays in chunks of SVE vector length\n    while (i < length) {\n        // Get a predicate for the current vector length, handling the tail\n        pg = svwhilelt_b8(i, length);\n\n        // Load elements from A and B into SVE vectors\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n\n        // Initialize the result vector C with zeros. This handles the \"otherwise\" case.\n        svint8_t vc = svdup_s8(0);\n\n        // --- Condition 1: A[i] > 0 AND B[i] > 0 => C[i] = 1 ---\n        // Create predicates for A > 0 and B > 0\n        svbool_t pg_A_pos = svcmpgt_s8(pg, va, 0);\n        svbool_t pg_B_pos = svcmpgt_s8(pg, vb, 0);\n        // Combine predicates: true where both A > 0 AND B > 0\n        svbool_t pg_both_pos = svand_b8(pg_A_pos, pg_B_pos);\n        // Select 1 where pg_both_pos is true, otherwise keep the current value in vc (which is 0 or potentially -1 from a later step, but these conditions are mutually exclusive)\n        vc = svsel_s8(pg_both_pos, svdup_s8(1), vc);\n\n        // --- Condition 2: A[i] < 0 AND B[i] < 0 => C[i] = -1 ---\n        // Create predicates for A < 0 and B < 0\n        svbool_t pg_A_neg = svcmplt_s8(pg, va, 0);\n        svbool_t pg_B_neg = svcmplt_s8(pg, vb, 0);\n        // Combine predicates: true where both A < 0 AND B < 0\n        svbool_t pg_both_neg = svand_b8(pg_A_neg, pg_B_neg);\n        // Select -1 where pg_both_neg is true, otherwise keep the current value in vc\n        vc = svsel_s8(pg_both_neg, svdup_s8(-1), vc);\n\n        // Store the result vector C back to memory\n        svst1_s8(pg, C + i, vc);\n\n        // Increment the loop counter by the number of 8-bit elements processed in this vector\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    // Calculate the index of the midpoint element.\n    // For a length N, indices are 0 to N-1. The midpoint is at (N-1)/2.\n    size_t mid_idx = (length - 1) / 2;\n    size_t i = 0;\n\n    // Part 1: Elements before the midpoint (bitwise XOR operation)\n    // Loop processes elements from index 0 up to (but not including) mid_idx.\n    while (i < mid_idx) {\n        // Generate a predicate for the current vector segment.\n        // `svwhilelt_b16(i, mid_idx)` creates a predicate that is true for elements\n        // whose logical index (starting from `i`) is less than `mid_idx`.\n        svbool_t pg = svwhilelt_b16(i, mid_idx);\n        \n        // Load vector segments from A and B using the generated predicate.\n        // Only active elements (where pg is true) are loaded.\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        \n        // Perform element-wise bitwise XOR operation.\n        svuint16_t vc = svxor_u16(va, vb);\n        \n        // Store the result in C using the predicate.\n        // Only active elements are written to C.\n        svst1_u16(pg, &C[i], vc);\n        \n        // Advance the current index by the number of 16-bit elements in an SVE vector.\n        // `svcntw()` returns the number of 16-bit elements (words) in the current SVE vector length.\n        i += svcntw();\n    }\n\n    // Part 2: Element exactly at the midpoint\n    // This operation is performed scalarly as it applies to a single specific element.\n    C[mid_idx] = A[mid_idx];\n\n    // Part 3: Elements after the midpoint (bitwise AND operation)\n    // Reset the loop index to start from the element immediately after the midpoint.\n    // Loop processes elements from (mid_idx + 1) up to (but not including) length.\n    i = mid_idx + 1; \n    while (i < length) {\n        // Generate a predicate for the current vector segment.\n        // `svwhilelt_b16(i, length)` creates a predicate that is true for elements\n        // whose logical index (starting from `i`) is less than `length`.\n        svbool_t pg = svwhilelt_b16(i, length);\n        \n        // Load vector segments from A and B using the generated predicate.\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        \n        // Perform element-wise bitwise AND operation.\n        svuint16_t vc = svand_u16(va, vb);\n        \n        // Store the result in C using the predicate.\n        svst1_u16(pg, &C[i], vc);\n        \n        // Advance the current index by the number of 16-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    size_t mid_idx = length / 2;\n    size_t i = 0;\n\n    // Phase 1: Elements before the midpoint (bitwise XOR)\n    // Iterate from index 0 up to (but not including) mid_idx.\n    while (i < mid_idx) {\n        // Generate a predicate for the current vector segment, ensuring we don't go past mid_idx.\n        svbool_t pg = svwhilelt_b16(i, mid_idx);\n\n        // Load vector elements from A and B\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n\n        // Perform element-wise bitwise XOR operation\n        svuint16_t vc = sveor_u16(va, vb);\n\n        // Store the result in C\n        svst1_u16(pg, &C[i], vc);\n\n        // Increment the loop counter by the number of 16-bit elements in a vector\n        i += svcntw();\n    }\n\n    // Phase 2: The element exactly at the midpoint (direct copy from A)\n    // This element is at index mid_idx.\n    C[mid_idx] = A[mid_idx];\n\n    // Update the loop counter to start from the element immediately after the midpoint\n    i = mid_idx + 1;\n\n    // Phase 3: Elements after the midpoint (bitwise AND)\n    // Iterate from index (mid_idx + 1) up to (but not including) length.\n    while (i < length) {\n        // Generate a predicate for the current vector segment, ensuring we don't go past length.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load vector elements from A and B\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n\n        // Perform element-wise bitwise AND operation\n        svuint16_t vc = svand_u16(va, vb);\n\n        // Store the result in C\n        svst1_u16(pg, &C[i], vc);\n\n        // Increment the loop counter by the number of 16-bit elements in a vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint_idx = length / 2;\n\n    // Part 1: Elements before the midpoint (A XOR B)\n    // Iterate from index 0 up to (but not including) midpoint_idx\n    size_t i = 0;\n    size_t limit_before = midpoint_idx;\n\n    while (i < limit_before) {\n        // Get a predicate for the current vector chunk, active as long as i < limit_before\n        svbool_t pg = svwhilelt_b16(i, limit_before);\n\n        // Load vector chunks from A and B\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n\n        // Perform element-wise bitwise XOR operation\n        // _x suffix means inactive elements in the result vector are unchanged,\n        // which is fine as we are writing to C based on the predicate.\n        svuint16_t vc = svxor_u16_x(pg, va, vb);\n\n        // Store the result back to C\n        svst1_u16(pg, C + i, vc);\n\n        // Increment the loop counter by the number of 16-bit elements in an SVE vector\n        i += svcntw();\n    }\n\n    // Part 2: Element exactly at the midpoint (keep A's value)\n    // This operation is performed scalarly as it's a single element.\n    C[midpoint_idx] = A[midpoint_idx];\n\n    // Part 3: Elements after the midpoint (A AND B)\n    // Iterate from index midpoint_idx + 1 up to (but not including) length\n    size_t i_after = midpoint_idx + 1;\n    size_t limit_after = length;\n\n    while (i_after < limit_after) {\n        // Get a predicate for the current vector chunk, active as long as i_after < limit_after\n        svbool_t pg = svwhilelt_b16(i_after, limit_after);\n\n        // Load vector chunks from A and B\n        svuint16_t va = svld1_u16(pg, A + i_after);\n        svuint16_t vb = svld1_u16(pg, B + i_after);\n\n        // Perform element-wise bitwise AND operation\n        // _x suffix means inactive elements in the result vector are unchanged.\n        svuint16_t vc = svand_u16_x(pg, va, vb);\n\n        // Store the result back to C\n        svst1_u16(pg, C + i_after, vc);\n\n        // Increment the loop counter by the number of 16-bit elements in an SVE vector\n        i_after += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For uint16_t\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    size_t midpoint = length / 2;\n\n    // Region 1: Elements before the midpoint (XOR operation)\n    // Iterate from 0 up to (but not including) midpoint\n    size_t i = 0;\n    for (; i < midpoint; i += svcntw()) {\n        // Generate a predicate for the current vector chunk, active lanes up to 'midpoint'\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        \n        // Load vector elements from A and B using the predicate\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        \n        // Perform element-wise bitwise XOR operation\n        svuint16_t vc = svxor_u16(va, vb);\n        \n        // Store the result to C using the predicate\n        svst1_u16(pg, C + i, vc);\n    }\n\n    // Region 2: The element exactly at the midpoint (assignment from A)\n    // This is a scalar operation as it's a single element.\n    C[midpoint] = A[midpoint];\n\n    // Region 3: Elements after the midpoint (AND operation)\n    // Iterate from midpoint + 1 up to (but not including) length\n    size_t j = midpoint + 1;\n    for (; j < length; j += svcntw()) {\n        // Generate a predicate for the current vector chunk, active lanes up to 'length'\n        svbool_t pg = svwhilelt_b16(j, length);\n        \n        // Load vector elements from A and B using the predicate\n        svuint16_t va = svld1_u16(pg, A + j);\n        svuint16_t vb = svld1_u16(pg, B + j);\n        \n        // Perform element-wise bitwise AND operation\n        svuint16_t vc = svand_u16(va, vb);\n        \n        // Store the result to C using the predicate\n        svst1_u16(pg, C + j, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    size_t midpoint_idx = length / 2;\n    size_t i = 0;\n\n    // Part 1: Elements before the midpoint (XOR operation)\n    // Loop for i from 0 up to midpoint_idx - 1\n    while (i < midpoint_idx) {\n        // Generate a predicate for the current vector chunk, ensuring we don't go past midpoint_idx\n        svbool_t pg = svwhilelt_b16(i, midpoint_idx);\n\n        // Load vector elements from A and B\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n\n        // Perform element-wise bitwise XOR\n        svuint16_t vc = svxor_u16(va, vb);\n\n        // Store the result in C\n        svst1_u16(pg, &C[i], vc);\n\n        // Increment index by the number of elements processed in this vector\n        i += svcntw();\n    }\n\n    // Part 2: Handle the element exactly at the midpoint (keep value from A)\n    // This is handled scalar-wise as it's a single, distinct operation.\n    C[midpoint_idx] = A[midpoint_idx];\n\n    // Part 3: Elements after the midpoint (AND operation)\n    // Start 'i' from the element immediately after the midpoint.\n    i = midpoint_idx + 1;\n\n    // Loop for i from midpoint_idx + 1 up to length - 1\n    while (i < length) {\n        // Generate a predicate for the current vector chunk, ensuring we don't go past length\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // Load vector elements from A and B\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n\n        // Perform element-wise bitwise AND\n        svuint16_t vc = svand_u16(va, vb);\n\n        // Store the result in C\n        svst1_u16(pg, &C[i], vc);\n\n        // Increment index by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t N = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the flattened tensors in chunks of SVE vector length\n    // svwhilelt_b32 generates a predicate for 32-bit elements (float)\n    svbool_t pg = svwhilelt_b32(i, N);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load data vectors for A, B, C, D\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        // Load boolean conditions as SVE predicates.\n        // C++ bool is typically 1 byte, so casting to uint8_t* is generally safe for svld1_b.\n        svbool_t cond1_pred = svld1_b(pg, (const uint8_t*)&cond1[i]);\n        svbool_t cond2_pred = svld1_b(pg, (const uint8_t*)&cond2[i]);\n\n        // Perform the selection logic:\n        // If cond1[k] is true:\n        //   If cond2[k] is true, select A[k]\n        //   If cond2[k] is false, select B[k]\n        // This is equivalent to: result_if_cond1_true = cond2 ? A : B\n        svfloat32_t result_if_cond1_true = svsel_f32(cond2_pred, a_vec, b_vec);\n\n        // If cond1[k] is false:\n        //   If cond2[k] is true, select C[k]\n        //   If cond2[k] is false, select D[k]\n        // This is equivalent to: result_if_cond1_false = cond2 ? C : D\n        svfloat32_t result_if_cond1_false = svsel_f32(cond2_pred, c_vec, d_vec);\n\n        // Final selection based on cond1:\n        // If cond1[k] is true, select result_if_cond1_true\n        // If cond1[k] is false, select result_if_cond1_false\n        // This is equivalent to: out = cond1 ? result_if_cond1_true : result_if_cond1_false\n        svfloat32_t out_vec = svsel_f32(cond1_pred, result_if_cond1_true, result_if_cond1_false);\n\n        // Store the result vector to the output array\n        svst1_f32(pg, &out[i], out_vec);\n\n        // Increment the index by the number of 32-bit elements processed in this vector\n        i += svcntw();\n        // Update the predicate for the next iteration\n        pg = svwhilelt_b32(i, N);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop using SVE vector length.\n    // svwhilelt_b32 creates a predicate for 32-bit elements (like float)\n    // The predicate 'pg' will control which elements are processed in each vector operation.\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load float vectors from input tensors A, B, C, D.\n        // The 'pg' predicate ensures that only active elements within the vector are loaded.\n        svfloat32_t vec_A = svld1(pg, A + i);\n        svfloat32_t vec_B = svld1(pg, B + i);\n        svfloat32_t vec_C = svld1(pg, C + i);\n        svfloat32_t vec_D = svld1(pg, D + i);\n\n        // Load boolean conditions.\n        // `svld1_vnum_b8` loads bytes from memory and converts them into a predicate for 8-bit elements.\n        // It interprets non-zero bytes as true and zero bytes as false.\n        // We cast `const bool*` to `const uint8_t*` as `bool` is typically represented by a byte.\n        // The `+ i` correctly advances the pointer by `i` elements, matching the float tensor indexing.\n        svbool_t p_cond1_b8 = svld1_vnum_b8(svptrue_b8(), (const uint8_t*)cond1 + i);\n        svbool_t p_cond2_b8 = svld1_vnum_b8(svptrue_b8(), (const uint8_t*)cond2 + i);\n\n        // Reinterpret the 8-bit element predicates to 32-bit element predicates.\n        // This is necessary because `svsel_f32` operates on `svfloat32_t` vectors and expects\n        // a predicate for 32-bit elements. According to the ACLE specification,\n        // `svreinterpret_bX_bY` typically takes the first `svcntY()` bits from the source predicate,\n        // which aligns with our need to use the first `svcntw()` boolean values.\n        svbool_t p_cond1_f32 = svreinterpret_b8_b32(p_cond1_b8);\n        svbool_t p_cond2_f32 = svreinterpret_b8_b32(p_cond2_b8);\n\n        // Perform the element-wise selection logic:\n        // The overall logic is equivalent to: out = svsel(cond1, svsel(cond2, A, B), svsel(cond2, C, D))\n        \n        // Step 1: Determine the result if cond1 is true (i.e., (cond2 ? A : B))\n        svfloat32_t result_if_cond1_true = svsel_f32(p_cond2_f32, vec_A, vec_B);\n        \n        // Step 2: Determine the result if cond1 is false (i.e., (cond2 ? C : D))\n        svfloat32_t result_if_cond1_false = svsel_f32(p_cond2_f32, vec_C, vec_D);\n        \n        // Step 3: Final selection based on cond1\n        svfloat32_t vec_out = svsel_f32(p_cond1_f32, result_if_cond1_true, result_if_cond1_false);\n\n        // Store the result vector into the output tensor.\n        // The 'pg' predicate ensures that only active elements are written back to memory.\n        svst1(pg, out + i, vec_out);\n\n        // Move to the next block of elements.\n        // `svcntw()` returns the number of 32-bit elements in the current SVE vector.\n        i += svcntw(); \n        // Update the predicate for the next iteration, ensuring we don't go past total_elements.\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c++\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t N = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop over the flattened tensors with SVE vector length\n    // The main predicate 'pg' is for 32-bit floating-point elements.\n    svbool_t pg = svwhilelt_b32(i, N);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load data vectors for A, B, C, D\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        // Load boolean conditions. Since 'bool' is typically 1 byte,\n        // and we need a predicate for 32-bit floats, we load 8-bit values\n        // and then expand them to 32-bit integers (0 or 1).\n        // svcntw() gives the number of 32-bit elements in a vector.\n        // We need to load svcntw() boolean values (bytes).\n        // svld1_u8 loads svcntb() bytes, which is 4 * svcntw().\n        // So, we create a predicate to only load the first svcntw() bytes.\n        svbool_t pg_b8_for_float_lanes = svwhilelt_b8(0, svcntw());\n        \n        svuint8_t cond1_u8_loaded = svld1_u8(pg_b8_for_float_lanes, (const uint8_t*)&cond1[i]);\n        svuint8_t cond2_u8_loaded = svld1_u8(pg_b8_for_float_lanes, (const uint8_t*)&cond2[i]);\n\n        // Expand the 8-bit boolean values (0 or 1) to 32-bit integers.\n        // svuzp1_u8 interleaves elements from two 8-bit vectors.\n        // By interleaving with a zero vector, we effectively zero-extend.\n        // First, expand to 16-bit:\n        svuint16_t cond1_u16 = svuzp1_u8(cond1_u8_loaded, svdup_n_u8(0));\n        svuint16_t cond2_u16 = svuzp1_u8(cond2_u8_loaded, svdup_n_u8(0));\n        // Then, expand to 32-bit:\n        svuint32_t cond1_u32 = svuzp1_u16(cond1_u16, svdup_n_u16(0));\n        svuint32_t cond2_u32 = svuzp1_u16(cond2_u16, svdup_n_u16(0));\n\n        // Create 32-bit predicates from the expanded integer values.\n        // Assuming 'true' is represented by 1 and 'false' by 0.\n        svbool_t pg_cond1 = svcmpeq_u32(pg, cond1_u32, svdup_n_u32(1));\n        svbool_t pg_cond2 = svcmpeq_u32(pg, cond2_u32, svdup_n_u32(1));\n\n        // Perform the element-wise selection based on conditions:\n        // if (cond1 && cond2) -> A\n        // if (cond1 && !cond2) -> B\n        // if (!cond1 && cond2) -> C\n        // if (!cond1 && !cond2) -> D\n\n        // Step 1: Select between A and B based on cond2 (if cond1 is true)\n        svfloat32_t res_if_cond1_true = svsel_f32(pg_cond2, a_vec, b_vec);\n\n        // Step 2: Select between C and D based on cond2 (if cond1 is false)\n        svfloat32_t res_if_cond1_false = svsel_f32(pg_cond2, c_vec, d_vec);\n\n        // Step 3: Final selection based on cond1\n        svfloat32_t out_vec = svsel_f32(pg_cond1, res_if_cond1_true, res_if_cond1_false);\n\n        // Store the result\n        svst1_f32(pg, &out[i], out_vec);\n\n        // Move to the next vector chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, N);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop while the predicate for the current chunk is active\n    // svwhilelt_b32 generates a predicate for elements where the index is less than total_elements\n    for (svbool_t pg = svwhilelt_b32(i, total_elements); svptest_any(svptrue_b32(), pg); i += svcntf32(), pg = svwhilelt_b32(i, total_elements)) {\n        // Load boolean conditions into SVE predicates.\n        // bool is typically 1 byte, so casting to uint8_t* is appropriate for svld1_b.\n        svbool_t cond1_pg = svld1_b(pg, (const uint8_t*)cond1 + i);\n        svbool_t cond2_pg = svld1_b(pg, (const uint8_t*)cond2 + i);\n\n        // Load float data into SVE vectors\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        svfloat32_t c_vec = svld1_f32(pg, C + i);\n        svfloat32_t d_vec = svld1_f32(pg, D + i);\n\n        // Perform the selection logic:\n        // if cond1[k] is true:\n        //   if cond2[k] is true: out[k] = A[k]\n        //   if cond2[k] is false: out[k] = B[k]\n        // else (cond1[k] is false):\n        //   if cond2[k] is true: out[k] = C[k]\n        //   if cond2[k] is false: out[k] = D[k]\n\n        // Step 1: Select between A and B based on cond2 (when cond1 is true)\n        svfloat32_t result_if_cond1_true = svsel_f32(cond2_pg, a_vec, b_vec);\n\n        // Step 2: Select between C and D based on cond2 (when cond1 is false)\n        svfloat32_t result_if_cond1_false = svsel_f32(cond2_pg, c_vec, d_vec);\n\n        // Step 3: Final selection based on cond1\n        svfloat32_t final_result = svsel_f32(cond1_pg, result_if_cond1_true, result_if_cond1_false);\n\n        // Store the result back to memory\n        svst1_f32(pg, out + i, final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c++\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements in chunks determined by the SVE vector length.\n    // svcntw() returns the number of 32-bit elements (floats) in an SVE vector.\n    // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector.\n    // Note that svcntb() is 4 times svcntw().\n\n    // Loop while there are active lanes to process\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Create a predicate for 32-bit elements (for float operations)\n        // This predicate ensures that operations only apply to valid elements,\n        // especially for the tail end of the array.\n        svbool_t pg_f32 = svwhilelt_b32(i, total_elements);\n\n        // Create a predicate for 8-bit elements (for boolean/byte operations)\n        // This predicate ensures that byte loads and comparisons only apply to valid elements.\n        // The 'i' here refers to the byte offset, which is the same as the float offset\n        // because each boolean is 1 byte and corresponds to one float element.\n        svbool_t pg_u8 = svwhilelt_b8(i, total_elements);\n\n        // Load float vectors for A, B, C, D using the float predicate\n        svfloat32_t vec_A = svld1_f32(pg_f32, A + i);\n        svfloat32_t vec_B = svld1_f32(pg_f32, B + i);\n        svfloat32_t vec_C = svld1_f32(pg_f32, C + i);\n        svfloat32_t vec_D = svld1_f32(pg_f32, D + i);\n\n        // Load boolean conditions as uint8_t vectors.\n        // `bool` in C++ is typically 1 byte. `svld1_u8` loads `svcntb()` bytes.\n        // `pg_u8` ensures that only the relevant `svcntw()` bytes (corresponding to the float elements)\n        // are considered active, and any excess bytes loaded by `svld1_u8` beyond `total_elements`\n        // or beyond the current `svcntw()` block are masked out.\n        svuint8_t v_cond1_u8 = svld1_u8(pg_u8, (const uint8_t*)cond1 + i);\n        svuint8_t v_cond2_u8 = svld1_u8(pg_u8, (const uint8_t*)cond2 + i);\n\n        // Convert uint8_t vectors to svbool_t predicates.\n        // A boolean 'true' is represented by a non-zero value.\n        // `svcmpne_n_u8` creates an 8-bit predicate (svbool_t) where lanes are true if the value is non-zero.\n        // When these 8-bit predicates are used with 32-bit float operations (e.g., svsel_f32),\n        // the SVE architecture implicitly reinterprets the predicate bits for the 32-bit element size.\n        // This means the first `svcntw()` bits of the 8-bit predicate will correspond to the `svcntw()` float elements.\n        svbool_t p_cond1 = svcmpne_n_u8(pg_u8, v_cond1_u8, 0);\n        svbool_t p_cond2 = svcmpne_n_u8(pg_u8, v_cond2_u8, 0);\n\n        // Perform element-wise selection based on the conditions:\n        // Logic: out = (cond1 && cond2) ? A : (cond1 && !cond2) ? B : (!cond1 && cond2) ? C : D;\n        // This can be implemented as:\n        // temp1 = (cond2) ? A : B;\n        // temp2 = (cond2) ? C : D;\n        // result = (cond1) ? temp1 : temp2;\n\n        // If cond2 is true, select A; else select B. (This covers cases where cond1 is true)\n        svfloat32_t temp1 = svsel_f32(p_cond2, vec_A, vec_B);\n        \n        // If cond2 is true, select C; else select D. (This covers cases where cond1 is false)\n        svfloat32_t temp2 = svsel_f32(p_cond2, vec_C, vec_D);\n        \n        // If cond1 is true, select from temp1; else select from temp2.\n        svfloat32_t result = svsel_f32(p_cond1, temp1, temp2);\n\n        // Store the result back to the output tensor using the float predicate\n        svst1_f32(pg_f32, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements, processing them in SVE vector chunks.\n    // The predicate `svwhilelt_b32` handles the tail elements automatically.\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Create a predicate for the current vector length, active for elements\n        // within the bounds [i, total_elements). This handles partial vectors at the end.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load 32-bit unsigned integers from tensor A into an SVE vector.\n        svuint32_t vec_A = svld1_u32(pg, &A[i]);\n\n        // Count the number of set bits (population count) for each 32-bit lane.\n        // The result is an svuint32_t vector where each lane contains the bit count.\n        svuint32_t bit_counts_u32 = svcntw_u32(vec_A);\n\n        // Narrow the 32-bit counts to 8-bit counts.\n        // Since the maximum bit count for a uint32_t is 32, which fits within a uint8_t,\n        // saturation will not occur.\n        svuint8_t bit_counts_u8 = svqxtnt_u8(bit_counts_u32);\n\n        // Store the resulting 8-bit counts into the output tensor 'out'.\n        svst1_u8(pg, &out[i], bit_counts_u8);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; ) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        svuint32_t popcounts_u32 = svcntw_u32(pg, vec_A);\n\n        svuint8_t popcounts_u8 = svcvt_u8_u32(pg, popcounts_u32);\n\n        svst1_u8(pg, out + i, popcounts_u8);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n#include <stdint.h> // For uint32_t, uint8_t\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Get the number of 32-bit elements that fit into an SVE vector.\n    // This determines the processing granularity for the loop.\n    size_t svl_u32 = svcntw(); \n\n    while (i < total_elements) {\n        // Create a predicate for the current vector chunk.\n        // It ensures that operations only apply to valid elements within the tensor bounds.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit unsigned integers from the input tensor A.\n        svuint32_t vec_A = svld1(pg, A + i);\n\n        // Count the number of set bits (population count) for each element in the vector.\n        // The result is a vector of 32-bit unsigned integers, where each element\n        // contains the bit count of the corresponding input element.\n        svuint32_t popcount_res_u32 = svcnt_u32(pg, vec_A);\n\n        // Narrow the 32-bit popcount results to 8-bit results.\n        // Since the maximum popcount for a 32-bit integer is 32, it fits within an 8-bit unsigned integer.\n        // We use two steps of saturating narrow intrinsics:\n        // Step 1: Convert from svuint32_t to svuint16_t.\n        //         svqxtnb_u32 extracts the lower 16 bits of each 32-bit element.\n        //         No saturation occurs as 32 fits in 16 bits.\n        svuint16_t popcount_res_u16 = svqxtnb_u32(popcount_res_u32);\n        \n        // Step 2: Convert from svuint16_t to svuint8_t.\n        //         svqxtnb_u16 extracts the lower 8 bits of each 16-bit element.\n        //         No saturation occurs as 32 fits in 8 bits.\n        svuint8_t popcount_res_u8 = svqxtnb_u16(popcount_res_u16);\n\n        // Store the 8-bit results to the output tensor 'out'.\n        // The predicate 'pg' (originally generated for 32-bit elements) is implicitly\n        // adapted by the svst1 intrinsic to operate on 8-bit elements.\n        svst1(pg, out + i, popcount_res_u8);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        i += svl_u32;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Loop through the elements using SVE vectors.\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Generate a predicate for the current vector chunk.\n        // svwhilelt_b32 ensures that only valid lanes (within total_elements) are active\n        // for 32-bit element processing.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit unsigned integers from the input array A.\n        svuint32_t vec_A = svld1(pg, &A[i]);\n\n        // Count the number of set bits (population count) for each 32-bit element\n        // in the loaded vector. The result is a vector of 32-bit unsigned integers,\n        // where each element holds the popcount (a value between 0 and 32).\n        svuint32_t vec_popcount_u32 = svcnt_u32(vec_A);\n\n        // Convert the 32-bit popcount results to 8-bit unsigned integers.\n        // Since the maximum popcount for a 32-bit integer is 32, the result\n        // fits perfectly within an 8-bit unsigned integer.\n        svuint8_t vec_popcount_u8 = svcvt_u8_u32(vec_popcount_u32);\n\n        // Store the 8-bit popcount results into the output array 'out'.\n        svst1_u8(pg, &out[i], vec_popcount_u8);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Determine the number of 32-bit elements per SVE vector.\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    size_t sv_elements_per_vec = svcntw();\n\n    // Allocate a temporary buffer on the stack to hold one SVE vector of uint32_t results.\n    // This is used as an intermediate step to facilitate narrowing from uint32_t to uint8_t,\n    // as there isn't a direct SVE intrinsic for element-wise narrowing of integer types\n    // where the output vector has the same number of elements as the input vector.\n    uint32_t temp_popcount_buffer[sv_elements_per_vec];\n\n    // Loop through the elements in chunks determined by the SVE vector length.\n    // The loop increment `sv_elements_per_vec` ensures we process a full vector's worth\n    // of 32-bit elements in each iteration.\n    for (i = 0; i < total_elements; i += sv_elements_per_vec) {\n        // Get the active predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate for 32-bit elements, ensuring that\n        // only elements within the bounds of `total_elements` are processed.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of uint32_t from the input tensor A.\n        // The predicate `pg` ensures that only active elements are loaded.\n        svuint32_t a_vec = svld1_u32(pg, A + i);\n\n        // Count the number of set bits (popcount) for each element in the vector.\n        // svcnt_u32 returns a svuint32_t vector where each element contains the popcount\n        // of the corresponding input element.\n        svuint32_t popcount_vec_u32 = svcnt_u32(a_vec);\n\n        // Store the 32-bit popcount results to the temporary buffer.\n        // The predicate `pg` ensures that only active elements are written to the buffer.\n        svst1_u32(pg, temp_popcount_buffer, popcount_vec_u32);\n\n        // Determine the number of active elements in the current vector.\n        // This is crucial for correctly handling the tail end of the array\n        // where the number of remaining elements might be less than a full vector.\n        size_t num_active_elements = svcntp_b32(pg);\n\n        // Manually narrow and store the results to the output array.\n        // This part is a scalar loop, but it operates on a small, cache-local buffer\n        // (size of one SVE vector), minimizing memory access overhead.\n        // The maximum popcount for a uint32_t is 32, which fits perfectly into a uint8_t,\n        // so a simple cast is sufficient.\n        for (size_t k = 0; k < num_active_elements; ++k) {\n            out[i + k] = (uint8_t)temp_popcount_buffer[k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Loop through the elements in chunks of SVE vector length\n    // The predicate 'pg' will handle partial vectors at the end of the array\n    for (i = 0; i < total_elements; ) {\n        // Get a predicate for the current vector chunk.\n        // This predicate will be true for active lanes (within bounds)\n        // and false for inactive (tail) lanes.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load elements from matrix A into an SVE vector\n        svint32_t vec_A = svld1_s32(pg, A + i);\n\n        // Calculate the absolute value of elements in vec_A\n        svint32_t vec_abs_A = svabs_s32(vec_A);\n\n        // Prepare constants for modulo operation\n        svint32_t three = svdup_n_s32(3);\n        svint32_t zero = svdup_n_s32(0);\n\n        // Calculate (vec_A / 3) using integer division\n        svint32_t div_result = svdiv_s32(pg, vec_A, three);\n\n        // Calculate (vec_A / 3) * 3\n        svint32_t mul_result = svmul_s32(pg, div_result, three);\n\n        // Calculate remainder: vec_A - ((vec_A / 3) * 3)\n        svint32_t rem_result = svsub_s32(pg, vec_A, mul_result);\n\n        // Create a condition mask: true if remainder is 0 (i.e., divisible by 3)\n        svbool_t condition_mask = svcmpeq_s32(pg, rem_result, zero);\n\n        // Select elements for the output vector vec_B based on the condition_mask.\n        // If condition_mask is true (divisible by 3), take vec_abs_A.\n        // Otherwise (not divisible by 3), take vec_A.\n        svint32_t vec_B = svsel_s32(condition_mask, vec_abs_A, vec_A);\n\n        // Store the result vector into matrix B\n        svst1_s32(pg, B + i, vec_B);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector.\n        // svcntw() returns the number of 32-bit integers that fit in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Duplicate constants into SVE vectors once\n    svint32_t three_vec = svdup_s32(3);\n    svint32_t zero_vec = svdup_s32(0);\n\n    // Loop through the elements in steps of SVE vector length\n    while (i < total_elements) {\n        // Get a predicate for the current vector operation.\n        // This handles the tail of the array where fewer than svcntw() elements remain.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit integers from matrix A\n        svint32_t vec_A = svld1_s32(pg, A + i);\n\n        // Calculate the modulo: vec_A % 3\n        // SVE does not have a direct modulo intrinsic.\n        // We compute it as A - (A / 3) * 3\n        svint32_t div_result = svdiv_s32(pg, vec_A, three_vec); // A / 3\n        svint32_t mul_result = svmul_s32(pg, div_result, three_vec); // (A / 3) * 3\n        svint32_t mod_result = svsub_s32(pg, vec_A, mul_result); // A - (A / 3) * 3 = A % 3\n\n        // Create a mask for the condition: A % 3 == 0\n        svbool_t condition_mask = svcmpeq_s32(pg, mod_result, zero_vec);\n\n        // Calculate the absolute value of vec_A\n        svint32_t abs_A = svabs_s32(pg, vec_A);\n\n        // Select the result based on the condition_mask:\n        // If condition_mask is true for a lane, use abs_A; otherwise, use vec_A.\n        svint32_t result_vec = svsel_s32(condition_mask, abs_A, vec_A);\n\n        // Store the resulting vector into matrix B\n        svst1_s32(pg, B + i, result_vec);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t N = rows * cols;\n    size_t i = 0;\n\n    // Get the number of 32-bit integers that fit in an SVE vector\n    size_t sv_elements = svcntw();\n\n    // Duplicate the scalar value 3 into an SVE vector\n    svint32_t three = svdup_s32(3);\n    \n    // Loop through the matrix elements in chunks of SVE vector length\n    for (i = 0; i < N; i += sv_elements) {\n        // Create a predicate for the current vector operation.\n        // This handles the tail of the loop where N is not a multiple of sv_elements.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Check if any lanes are active in the current predicate\n        if (svptest_any(svptrue_b32(), pg)) {\n            // Load a vector of integers from matrix A\n            svint32_t vec_A = svld1_s32(pg, A + i);\n\n            // Calculate the absolute value of vec_A\n            svint32_t vec_abs_A = svabs_s32(vec_A);\n\n            // Calculate vec_A % 3.\n            // SVE does not have a direct modulo intrinsic, so we compute it as A - (A / 3) * 3.\n            // Integer division (truncates towards zero)\n            svint32_t div_res = svdiv_s32(pg, vec_A, three);\n            // Multiply by 3\n            svint32_t mul_res = svmul_s32(pg, div_res, three);\n            // Subtract to get the remainder\n            svint32_t mod_res = svsub_s32(pg, vec_A, mul_res);\n\n            // Create a condition mask: true if element % 3 == 0\n            svbool_t condition_mask = svcmpeq_s32(pg, mod_res, svdup_s32(0));\n\n            // Select the result:\n            // If condition_mask is true, use vec_abs_A.\n            // If condition_mask is false, use vec_A.\n            svint32_t vec_B = svsel_s32(condition_mask, vec_abs_A, vec_A);\n\n            // Store the resulting vector to matrix B\n            svst1_s32(pg, B + i, vec_B);\n        } else {\n            // No more active elements, break out of the loop\n            break;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Loop through the matrix in chunks determined by the SVE vector length (svcntw())\n    // svwhilelt_b32 generates a predicate for elements that are within the bounds\n    // [i, total_elements), ensuring safe memory access for the current vector.\n    for (i = 0; i < total_elements; i += svcntw()) {\n        // Get a predicate for the current vector length, ensuring we don't go out of bounds.\n        // This predicate 'pg' will be used for all subsequent SVE operations in this iteration.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit integers from matrix A starting at A + i.\n        svint32_t a_vec = svld1_s32(pg, A + i);\n\n        // Prepare constant vectors for division and comparison.\n        svint32_t three_vec = svdup_s32(3); // Vector filled with 3\n        svint32_t zero_vec = svdup_s32(0);  // Vector filled with 0\n\n        // Calculate remainder: A[x] % 3.\n        // SVE does not have a direct integer remainder intrinsic.\n        // We compute it as: remainder = A[x] - (A[x] / 3) * 3.\n        // First, calculate the quotient (A[x] / 3). Integer division truncates towards zero.\n        svint32_t quotient_vec = svdiv_s32(pg, a_vec, three_vec);\n\n        // Then, calculate (quotient * 3).\n        svint32_t product_vec = svmul_s32(pg, quotient_vec, three_vec);\n\n        // Finally, calculate the remainder.\n        svint32_t remainder_vec = svsub_s32(pg, a_vec, product_vec);\n\n        // Create the condition mask: true if remainder is 0 (i.e., divisible by 3).\n        svbool_t condition_mask = svcmpeq_s32(pg, remainder_vec, zero_vec);\n\n        // Calculate the absolute value of the elements in a_vec.\n        svint32_t abs_a_vec = svabs_s32(pg, a_vec);\n\n        // Select the final elements for the result vector B.\n        // If condition_mask is true for an element, select the absolute value (abs_a_vec).\n        // Otherwise, select the original value (a_vec).\n        svint32_t result_vec = svsel_s32(condition_mask, abs_a_vec, a_vec);\n\n        // Store the result vector to matrix B starting at B + i.\n        svst1_s32(pg, B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Duplicate the divisor (3) into a vector for SVE operations.\n    svint32_t three_vec = svdup_s32(3);\n\n    // Loop through the elements of the matrix in chunks determined by SVE vector length.\n    while (i < total_elements) {\n        // Get the predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // from 'i' up to 'total_elements - 1', and false for the rest.\n        // This handles the loop tail automatically.\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        // Load a vector of 32-bit integers from matrix A.\n        // Elements corresponding to false predicate lanes will be undefined.\n        svint32_t val = svld1_s32(pg, A + i);\n\n        // Calculate (val / 3) for active lanes.\n        // For inactive lanes, the elements in 'quotient' remain unchanged from their initial state.\n        svint32_t quotient = svdiv_s32_x(pg, val, three_vec);\n\n        // Calculate (quotient * 3) for active lanes.\n        // For inactive lanes, the elements in 'product' remain unchanged.\n        svint32_t product = svmul_s32_x(pg, quotient, three_vec);\n\n        // Create a condition mask: true if val % 3 == 0 (i.e., val == (val/3)*3).\n        // svcmpeq_s32 sets predicate elements to false for inactive lanes of 'pg'.\n        svbool_t condition_mask = svcmpeq_s32(pg, val, product);\n\n        // Calculate the absolute value of 'val' for all elements.\n        // For inactive lanes (where 'val' is undefined), 'abs_val' will also be undefined.\n        svint32_t abs_val = svabs_s32(val);\n\n        // Select the result based on the condition_mask.\n        // If condition_mask[lane] is true, result[lane] = abs_val[lane].\n        // If condition_mask[lane] is false (either because val % 3 != 0 or because the lane is inactive),\n        // result[lane] = val[lane].\n        // For inactive lanes, 'val' is undefined, so 'result' for inactive lanes is undefined.\n        svint32_t result = svsel_s32(condition_mask, abs_val, val);\n\n        // Store the result vector into matrix B.\n        // Only elements corresponding to true predicate lanes ('pg') are stored.\n        // This ensures that undefined values from inactive lanes are not written to memory.\n        svst1_s32(pg, B + i, result);\n\n        // Increment the loop counter by the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    \n    // Normalize rotate_bits to be within [0, 31] for 32-bit rotation.\n    // This handles cases where rotate_bits might be >= 32 (e.g., 33 becomes 1).\n    uint32_t actual_rotate_bits = rotate_bits % 32;\n    // Calculate the inverse shift amount for the left part of the rotation.\n    // For a right rotation by 'k' bits, it's (val >> k) | (val << (32 - k)).\n    // If actual_rotate_bits is 0, (32 - 0) % 32 correctly yields 0.\n    uint32_t inverse_rotate_bits = (32 - actual_rotate_bits) % 32; \n\n    // Duplicate scalar rotate amounts into SVE vectors, as SVE shift intrinsics\n    // typically take a vector of shift amounts.\n    svuint32_t sv_rotate_bits = svdup_u32(actual_rotate_bits);\n    svuint32_t sv_inverse_rotate_bits = svdup_u32(inverse_rotate_bits);\n    \n    // Duplicate the constant 0xF (binary 1111) for the condition check.\n    // This value represents the low 4 bits all being 1.\n    svuint32_t sv_mask_0xF = svdup_u32(0xF);\n\n    // Loop through the arrays in chunks determined by the SVE vector length.\n    while (i < length) {\n        // Get a predicate for the current vector length. This ensures that\n        // operations only apply to valid elements within the array bounds.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit unsigned integers from the source array.\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n\n        // --- Condition Check: (src_vec & 0xF) == 0xF ---\n        // 1. Perform bitwise AND with 0xF to isolate the low 4 bits.\n        svuint32_t low_4_bits = svand_u32(src_vec, sv_mask_0xF);\n        // 2. Compare the isolated low 4 bits with 0xF to create a boolean mask.\n        //    Elements where the condition is true will have their corresponding\n        //    bit set in 'condition_mask'.\n        svbool_t condition_mask = svcmpeq_u32(pg, low_4_bits, sv_mask_0xF);\n\n        // --- Calculate Rotated Value (for the 'true' branch of the condition) ---\n        // Perform a right bitwise rotation: (value >> k) | (value << (32 - k)).\n        // 1. Right shift part.\n        svuint32_t rotated_right_part = svlsr_u32(src_vec, sv_rotate_bits);\n        // 2. Left shift part.\n        svuint32_t rotated_left_part = svlsl_u32(src_vec, sv_inverse_rotate_bits);\n        // 3. Combine the shifted parts with bitwise OR to complete the rotation.\n        svuint32_t rotated_result = svor_u32(rotated_right_part, rotated_left_part);\n\n        // --- Calculate Negated Value (for the 'false' branch of the condition) ---\n        // Perform bitwise negation (one's complement).\n        svuint32_t negated_result = svnot_u32(src_vec);\n\n        // --- Select the final result based on the condition mask ---\n        // For each element, if the corresponding bit in 'condition_mask' is true,\n        // select the 'rotated_result'; otherwise, select the 'negated_result'.\n        svuint32_t final_result = svsel_u32(condition_mask, rotated_result, negated_result);\n\n        // Store the computed vector of results to the destination array.\n        svst1_u32(pg, dst + i, final_result);\n\n        // Increment the loop counter by the number of 32-bit elements processed\n        // in the current SVE vector. svcntw() returns the number of words (32-bit elements).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    // Create a vector with all elements set to 0xF for the condition check\n    svuint32_t sv_mask_0xF = svdup_u32(0xF);\n\n    while (i < length) {\n        // Get the predicate for the current vector length\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load the source vector elements\n        svuint32_t sv_src = svld1_u32(pg, src + i);\n\n        // Extract the low 4 bits of each element\n        svuint32_t sv_low_4_bits = svand_u32(sv_src, sv_mask_0xF);\n\n        // Create a predicate where true indicates the low 4 bits are all 1 (0xF)\n        svbool_t condition_predicate = svcmpeq_u32(pg, sv_low_4_bits, sv_mask_0xF);\n\n        // Perform the rotation operation for the 'true' branch\n        // svror_u32 performs a right rotate (towards low bits)\n        svuint32_t sv_rotated_result = svror_u32(sv_src, rotate_bits);\n\n        // Perform the bitwise negation operation for the 'false' branch\n        svuint32_t sv_negated_result = svnot_u32(sv_src);\n\n        // Select the final result based on the condition predicate\n        // svsel_u32(false_value, true_value, predicate)\n        svuint32_t sv_final_result = svsel_u32(sv_negated_result, sv_rotated_result, condition_predicate);\n\n        // Store the result to the destination vector\n        svst1_u32(pg, dst + i, sv_final_result);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Duplicate rotate_bits and the mask 0xF into SVE vectors once\n    const svuint32_t rotate_val_vec = svdup_u32(rotate_bits);\n    const svuint32_t mask_0xF_vec = svdup_u32(0xF);\n\n    do {\n        // Get a predicate for the current vector chunk, handling tail elements\n        pg = svwhilelt_b32(i, length);\n\n        // If no lanes are active, break the loop\n        if (svptest_any(svptrue_b32(), pg)) {\n            // Load the source vector\n            svuint32_t src_vec = svld1_u32(pg, src + i);\n\n            // Calculate the low 4 bits of each element\n            svuint32_t low_4_bits = svand_u32(src_vec, mask_0xF_vec);\n\n            // Create a predicate for the condition: low 4 bits are all 1 (0xF)\n            // The comparison is only performed for active lanes defined by 'pg'\n            svbool_t condition_predicate = svcmpeq_u32(pg, low_4_bits, mask_0xF_vec);\n\n            // Calculate the result for the 'true' branch (rotate right)\n            svuint32_t rotated_result = svror_u32(src_vec, rotate_val_vec);\n\n            // Calculate the result for the 'false' branch (bitwise negation)\n            svuint32_t negated_result = svnot_u32(src_vec);\n\n            // Select elements based on the condition predicate\n            // svsel_u32(if_false_vec, if_true_vec, predicate)\n            svuint32_t final_result = svsel_u32(negated_result, rotated_result, condition_predicate);\n\n            // Store the result vector into the destination\n            svst1_u32(pg, dst + i, final_result);\n\n            // Increment the loop counter by the number of 32-bit elements in an SVE vector\n            i += svcntw();\n        } else {\n            // No more elements to process\n            break;\n        }\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n\n    // Duplicate rotate_bits into a vector for svror\n    svuint32_t sv_rotate_bits = svdup_n_u32(rotate_bits);\n    // Duplicate 0xF (mask for low 4 bits) into a vector for the condition check\n    svuint32_t sv_mask_0f = svdup_n_u32(0xF);\n\n    // Loop through the data in chunks determined by the SVE vector length\n    // svwhilelt_b32 generates a predicate for the current chunk\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svcnt_u32(pg) > 0) {\n        // Load a vector from src. Inactive lanes (beyond 'length') are zeroed.\n        svuint32_t src_vec = svld1_u32_z(pg, src + i);\n\n        // --- Calculate the condition predicate: (src_element & 0xF) == 0xF ---\n        // Perform bitwise AND with 0xF\n        svuint32_t and_result = svand_u32(src_vec, sv_mask_0f);\n        // Compare the result with 0xF to get the condition predicate\n        svbool_t condition_predicate = svcmpeq_u32(pg, and_result, sv_mask_0f);\n\n        // --- Calculate the 'true' branch result: rotate right ---\n        svuint32_t rotated_vec = svror_u32(src_vec, sv_rotate_bits);\n\n        // --- Calculate the 'false' branch result: bitwise negation ---\n        svuint32_t negated_vec = svnot_u32(src_vec);\n\n        // Select elements for the destination vector based on the condition predicate.\n        // If condition_predicate is true, pick from rotated_vec; otherwise, pick from negated_vec.\n        svuint32_t result_vec = svsel_u32(condition_predicate, rotated_vec, negated_vec);\n\n        // Store the result vector into dst. Only active lanes (where pg is true) are written.\n        svst1_u32(pg, dst + i, result_vec);\n\n        // Move to the next chunk\n        i += svcnt_u32(pg);\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    // Duplicate the rotate_bits scalar to a vector for svror_u32 if needed,\n    // though svror_u32 also accepts a scalar shift amount.\n    // Using scalar directly for svror_u32 is more efficient.\n    const uint32_t rotate_amount_scalar = rotate_bits;\n\n    // Create a vector with the mask value 0xF (binary 1111)\n    const svuint32_t mask_val = svdup_u32(0xF);\n\n    // Loop through the arrays in chunks of SVE vector length\n    while (i < length) {\n        // Get a predicate for the current chunk, ensuring we don't go past 'length'\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of 32-bit unsigned integers from src\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        // --- Condition Check: (src_element & 0xF) == 0xF ---\n        // Perform bitwise AND with the mask_val (0xF)\n        svuint32_t masked_src = svand_u32(src_vec, mask_val);\n        // Compare the masked result with 0xF to get the condition predicate\n        // The 'pg' argument ensures comparison only happens for active lanes.\n        svbool_t condition_predicate = svcmpeq_u32(pg, masked_src, mask_val);\n\n        // --- True Branch Operation: Rotate right by rotate_bits ---\n        // Perform right rotation on the source vector\n        svuint32_t rotated_val = svror_u32(src_vec, rotate_amount_scalar);\n\n        // --- False Branch Operation: Bitwise negation ---\n        // Perform bitwise negation on the source vector\n        svuint32_t negated_val = svnot_u32(src_vec);\n\n        // --- Select result based on condition ---\n        // If condition_predicate is true for a lane, select from rotated_val;\n        // otherwise, select from negated_val.\n        svuint32_t result_vec = svsel_u32(condition_predicate, rotated_val, negated_val);\n\n        // Store the resulting vector into the destination array\n        svst1_u32(pg, &dst[i], result_vec);\n\n        // Increment the loop counter by the number of 32-bit elements in an SVE vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For fabsf\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    // Calculate absolute epsilon and its negative once\n    float abs_epsilon = fabsf(epsilon);\n    float neg_abs_epsilon = -abs_epsilon;\n\n    // Broadcast scalar values to SVE float vectors\n    svfloat32_t sv_abs_epsilon = svdup_f32(abs_epsilon);\n    svfloat32_t sv_neg_abs_epsilon = svdup_f32(neg_abs_epsilon);\n\n    while (i < length) {\n        // Get the active predicate for 32-bit float elements for the current chunk\n        svbool_t pg_f32 = svwhilelt_b32(i, length);\n\n        // Load A and B vectors using the predicate\n        svfloat32_t A_vec = svld1_f32(pg_f32, A + i);\n        svfloat32_t B_vec = svld1_f32(pg_f32, B + i);\n\n        // Calculate the element-wise difference\n        svfloat32_t diff_vec = svsub_f32(A_vec, B_vec);\n\n        // Initialize the result vector with 0.0f\n        svfloat32_t result_f32_vec = svdup_f32(0.0f);\n\n        // Predicate for A[i] - B[i] > abs(epsilon)\n        svbool_t pred_gt_abs_eps = svcmpgt_f32(pg_f32, diff_vec, sv_abs_epsilon);\n        // Predicate for A[i] - B[i] < -abs(epsilon)\n        svbool_t pred_lt_neg_abs_eps = svcmplt_f32(pg_f32, diff_vec, sv_neg_abs_epsilon);\n\n        // Apply conditional selection:\n        // If diff > abs_epsilon, set result to 1.0f\n        result_f32_vec = svsel_f32(pred_gt_abs_eps, svdup_f32(1.0f), result_f32_vec);\n        // If diff < -abs_epsilon, set result to -1.0f\n        // This operation correctly overwrites elements that were 0.0f,\n        // and leaves elements that were set to 1.0f unchanged (as the conditions are mutually exclusive).\n        result_f32_vec = svsel_f32(pred_lt_neg_abs_eps, svdup_f32(-1.0f), result_f32_vec);\n\n        // Convert the float results (0.0f, 1.0f, -1.0f) to 8-bit signed integers.\n        // svcvt_s8_f32 converts svfloat32_t to svint8_t. It places the svcntw()\n        // results into the first svcntw() lanes of the svint8_t vector.\n        svint8_t result_s8_vec = svcvt_s8_f32(result_f32_vec);\n\n        // Get the actual number of active float elements in this iteration (for tail handling)\n        size_t num_active_floats = svcnt_f32(pg_f32);\n\n        // Create an 8-bit predicate for storing only the active elements.\n        // This predicate ensures that only the first 'num_active_floats'\n        // elements of the svint8_t vector are stored, matching the number\n        // of valid results from the float operations.\n        svbool_t pg_s8 = svwhilelt_b8(0, num_active_floats);\n\n        // Store the int8_t results to the output array using the 8-bit predicate\n        svst1_s8(pg_s8, out + i, result_s8_vec);\n\n        // Advance the loop counter by the number of 32-bit float elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>   // For fabsf\n#include <stddef.h> // For size_t\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    // Calculate the absolute value of epsilon once\n    const float abs_epsilon = fabsf(epsilon);\n\n    // Duplicate abs_epsilon and -abs_epsilon into SVE float vectors for comparison\n    svfloat32_t sv_abs_epsilon = svdup_f32(abs_epsilon);\n    svfloat32_t sv_neg_abs_epsilon = svneg_f32(sv_abs_epsilon);\n\n    // Duplicate constant float values (1.0f, -1.0f, 0.0f) for the intermediate result vector\n    svfloat32_t sv_one_f32 = svdup_f32(1.0f);\n    svfloat32_t sv_neg_one_f32 = svdup_f32(-1.0f);\n    svfloat32_t sv_zero_f32 = svdup_f32(0.0f);\n\n    // Loop using SVE predicate generation for 32-bit elements (float)\n    while (i < length) {\n        // Generate a predicate 'pg' for the current vector length of 32-bit elements.\n        // This predicate determines which elements are active in the current SVE vector operation.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load A and B vectors using the predicate 'pg'.\n        // Only elements corresponding to true bits in 'pg' are loaded.\n        svfloat32_t sv_A = svld1(pg, A + i);\n        svfloat32_t sv_B = svld1(pg, B + i);\n\n        // Calculate the element-wise difference: diff = A - B\n        svfloat32_t sv_diff = svsub_f32(sv_A, sv_B);\n\n        // Generate predicates for the comparison conditions based on float values\n        // Condition 1: diff > abs(epsilon)\n        svbool_t p_gt_abs_epsilon = svcmpgt_f32(pg, sv_diff, sv_abs_epsilon);\n        // Condition 2: diff < -abs(epsilon)\n        svbool_t p_lt_neg_abs_epsilon = svcmplt_f32(pg, sv_diff, sv_neg_abs_epsilon);\n\n        // Initialize an intermediate float result vector to 0.0f.\n        // This serves as the default case: abs(diff) <= abs(epsilon) -> out = 0.\n        svfloat32_t sv_out_result_f32 = sv_zero_f32;\n\n        // Apply Condition 1: If diff > abs(epsilon), set the result to 1.0f.\n        // svsel_f32 selects elements from sv_one_f32 where p_gt_abs_epsilon is true,\n        // otherwise it selects from the current sv_out_result_f32 (which is 0.0f initially).\n        sv_out_result_f32 = svsel_f32(p_gt_abs_epsilon, sv_one_f32, sv_out_result_f32);\n\n        // Apply Condition 2: If diff < -abs(epsilon), set the result to -1.0f.\n        // This operation is performed after Condition 1. Since the two conditions\n        // (diff > abs(epsilon) and diff < -abs(epsilon)) are mutually exclusive,\n        // this sequence correctly assigns 1.0f, -1.0f, or 0.0f to each element.\n        // If p_gt_abs_epsilon was true for an element, p_lt_neg_abs_epsilon must be false,\n        // so the 1.0f result is retained. If p_lt_neg_abs_epsilon is true, it overrides\n        // the previous value (which would have been 0.0f) to -1.0f.\n        // If neither condition is true, the element remains 0.0f.\n        sv_out_result_f32 = svsel_f32(p_lt_neg_abs_epsilon, sv_neg_one_f32, sv_out_result_f32);\n\n        // Convert the float results (1.0f, -1.0f, 0.0f) to int8_t.\n        // SVE does not have a direct float-to-int8_t conversion, so we do it in steps:\n        // 1. Convert float to int32_t. The '_x' suffix indicates a predicated conversion,\n        //    meaning only active elements (as per 'pg') are converted.\n        svint32_t sv_out_result_s32 = svcvt_s32_f32_x(pg, sv_out_result_f32);\n\n        // 2. Narrow int32_t to int16_t using saturating narrowing.\n        //    This operation is not predicated; it operates on all elements of the vector.\n        //    However, only the elements corresponding to 'pg' contain meaningful data.\n        svint16_t sv_out_result_s16 = svqxtn_s16(sv_out_result_s32);\n\n        // 3. Narrow int16_t to int8_t using saturating narrowing.\n        svint8_t sv_out_result_s8 = svqxtn_s8(sv_out_result_s16);\n\n        // Store the final int8_t result vector to the output array.\n        // The predicate 'pg' ensures that only the elements corresponding to the\n        // original active float operations are written to memory.\n        svst1_s8(pg, out + i, sv_out_result_s8);\n\n        // Increment the loop counter by the number of elements processed in this iteration.\n        // svcnt_b32(pg) returns the number of active 32-bit elements (floats) processed.\n        i += svcnt_b32(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>   // For fabsf\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int8_t\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n\n    // Calculate absolute epsilon and negative absolute epsilon once\n    const float abs_epsilon = fabsf(epsilon);\n    const float neg_abs_epsilon = -abs_epsilon;\n\n    // Broadcast scalar values to SVE vectors once outside the loop\n    const svfloat32_t sv_abs_epsilon = svdup_n_f32(abs_epsilon);\n    const svfloat32_t sv_neg_abs_epsilon = svdup_n_f32(neg_abs_epsilon);\n\n    // Broadcast constant result values for int8_t once outside the loop\n    const svint8_t sv_one = svdup_n_s8(1);\n    const svint8_t sv_zero = svdup_n_s8(0);\n    const svint8_t sv_neg_one = svdup_n_s8(-1);\n\n    // Loop through the tensors in chunks determined by SVE vector length\n    while (i < length) {\n        // Get a predicate for the current vector operation.\n        // This predicate ensures that operations only apply to valid elements\n        // up to 'length', handling the tail end of the array.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load elements from tensors A and B into SVE float vectors\n        svfloat32_t A_vec = svld1(pg, A + i);\n        svfloat32_t B_vec = svld1(pg, B + i);\n\n        // Calculate the element-wise difference: diff_vec = A_vec - B_vec\n        // _x suffix indicates that the operation is predicated (elements where pg is false are untouched)\n        svfloat32_t diff_vec = svsub_f32_x(pg, A_vec, B_vec);\n\n        // Create predicates for the comparison conditions\n        // pg_gt is true where diff_vec > abs_epsilon\n        svbool_t pg_gt = svcmpgt_f32(pg, diff_vec, sv_abs_epsilon);\n        // pg_lt is true where diff_vec < -abs_epsilon\n        svbool_t pg_lt = svcmplt_f32(pg, diff_vec, sv_neg_abs_epsilon);\n\n        // Initialize the result vector with zeros. This covers the case\n        // abs(A[i] - B[i]) <= abs(epsilon) by default.\n        svint8_t result_vec = sv_zero;\n\n        // Apply the first condition: If A[i] - B[i] > abs(epsilon), out[i] should be 1.\n        // svsel_s8 selects elements from sv_one where pg_gt is true,\n        // otherwise it selects from the current result_vec (which is sv_zero).\n        result_vec = svsel_s8(pg_gt, sv_one, result_vec);\n\n        // Apply the second condition: If A[i] - B[i] < -abs(epsilon), out[i] should be -1.\n        // svsel_s8 selects elements from sv_neg_one where pg_lt is true.\n        // Otherwise, it selects from the current result_vec (which is either 0 or 1 from the previous step).\n        // Since pg_gt and pg_lt are mutually exclusive, there's no conflict here.\n        result_vec = svsel_s8(pg_lt, sv_neg_one, result_vec);\n\n        // Store the computed int8_t results back to the output tensor 'out'\n        svst1(pg, out + i, result_vec);\n\n        // Advance the index by the number of elements processed in this vector.\n        // svcntw() returns the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For fabsf\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    // Calculate absolute epsilon once\n    const float abs_epsilon = fabsf(epsilon);\n\n    // Duplicate abs_epsilon and -abs_epsilon into SVE vectors\n    // These will be used for comparison against the difference vector\n    svfloat32_t abs_epsilon_vec = svdup_f32(abs_epsilon);\n    svfloat32_t neg_abs_epsilon_vec = svdup_f32(-abs_epsilon);\n\n    // Loop through the tensors in chunks determined by the SVE vector length\n    while (length > 0) {\n        // Get the predicate for the current chunk, for 32-bit float elements\n        // This predicate determines which elements are active in the current vector operation\n        svbool_t pg_f32 = svwhilelt_b32(0, length);\n\n        // Get the number of active 32-bit float elements in the current chunk\n        // This is equivalent to the number of int8_t elements we will produce\n        size_t current_vl_f32 = svcnt_f32();\n\n        // Load current chunks of A and B into SVE vectors\n        svfloat32_t a_vec = svld1_f32(pg_f32, A);\n        svfloat32_t b_vec = svld1_f32(pg_f32, B);\n\n        // Calculate the element-wise difference: A[i] - B[i]\n        svfloat32_t diff_vec = svsub_f32_x(pg_f32, a_vec, b_vec);\n\n        // Perform comparisons to generate predicates for each condition\n        // Predicate for diff > abs_epsilon\n        svbool_t pg_gt_abs_eps = svcmpgt_f32(pg_f32, diff_vec, abs_epsilon_vec);\n        // Predicate for diff < -abs_epsilon\n        svbool_t pg_lt_neg_abs_eps = svcmplt_f32(pg_f32, diff_vec, neg_abs_epsilon_vec);\n\n        // Initialize a float result vector with 0.0f\n        svfloat32_t result_f32 = svdup_f32(0.0f);\n\n        // If diff > abs_epsilon, set result to 1.0f\n        // The 'pg_gt_abs_eps' predicate ensures this applies only to relevant lanes\n        result_f32 = svsel_f32(pg_gt_abs_eps, svdup_f32(1.0f), result_f32);\n\n        // If diff < -abs_epsilon, set result to -1.0f\n        // This operation will overwrite previous values if 'pg_lt_neg_abs_eps' is true.\n        // This correctly implements the ternary logic: if diff is within [-abs_epsilon, abs_epsilon],\n        // neither predicate is true, and result remains 0.0f.\n        result_f32 = svsel_f32(pg_lt_neg_abs_eps, svdup_f32(-1.0f), result_f32);\n\n        // Convert the float results (0.0f, 1.0f, -1.0f) to int8_t\n        // The predicate 'pg_f32' ensures conversion only for active lanes.\n        // The resulting svint8_t vector will contain the converted values in its first 'current_vl_f32' elements.\n        svint8_t final_result_s8 = svcvt_s8_f32_x(pg_f32, result_f32);\n\n        // Create a predicate for storing int8_t elements.\n        // We only want to store 'current_vl_f32' int8_t elements,\n        // corresponding to the float elements processed.\n        svbool_t pg_store_s8 = svwhilelt_b8(0, current_vl_f32);\n\n        // Store the int8_t results to the output tensor\n        // 'pg_store_s8' ensures that only the relevant int8_t elements are written\n        svst1_s8(pg_store_s8, out, final_result_s8);\n\n        // Update pointers and remaining length\n        A += current_vl_f32;\n        B += current_vl_f32;\n        out += current_vl_f32;\n        length -= current_vl_f32;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // For fabsf\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    // Calculate absolute epsilon once\n    const float abs_epsilon_val = fabsf(epsilon);\n\n    // Duplicate epsilon values into SVE vectors for float32 comparison\n    const svfloat32_t abs_epsilon_vec = svdup_f32(abs_epsilon_val);\n    const svfloat32_t neg_abs_epsilon_vec = svdup_f32(-abs_epsilon_val);\n\n    // Duplicate output values into SVE vectors for int8_t results\n    const svint8_t one_s8 = svdup_s8(1);\n    const svint8_t neg_one_s8 = svdup_s8(-1);\n    const svint8_t zero_s8 = svdup_s8(0);\n\n    size_t i = 0;\n    // Loop while 'i' is less than 'length', processing 'svcnt_f32()' elements at a time.\n    // The predicate 'pg' controls which elements are active in the vector operations,\n    // handling the tail end of the array correctly.\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from A and B into SVE float32 vectors\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n\n        // Calculate the element-wise difference: diff = A[i] - B[i]\n        svfloat32_t diff_vec = svsub_f32(pg, a_vec, b_vec);\n\n        // Create a predicate for the condition: diff > abs(epsilon)\n        svbool_t p_gt_abs_eps = svcmpgt_f32(pg, diff_vec, abs_epsilon_vec);\n\n        // Create a predicate for the condition: diff < -abs(epsilon)\n        svbool_t p_lt_neg_abs_eps = svcmplt_f32(pg, diff_vec, neg_abs_epsilon_vec);\n\n        // Initialize the output vector with zeros. This handles the 'abs(diff) <= abs(epsilon)' case by default.\n        svint8_t current_out_vec = zero_s8;\n\n        // If diff > abs(epsilon), set the corresponding output element to 1.\n        // For elements where p_gt_abs_eps is false, current_out_vec retains its value (0).\n        current_out_vec = svsel_s8(p_gt_abs_eps, one_s8, current_out_vec);\n\n        // If diff < -abs(epsilon), set the corresponding output element to -1.\n        // Since p_gt_abs_eps and p_lt_neg_abs_eps are mutually exclusive, this correctly\n        // overwrites elements that were initially 0 (or would have been 0 if not for this condition).\n        current_out_vec = svsel_s8(p_lt_neg_abs_eps, neg_one_s8, current_out_vec);\n\n        // Store the resulting int8_t vector to the output array\n        svst1_s8(pg, out + i, current_out_vec);\n\n        // Advance the index by the number of elements processed in this vector\n        i += svcnt_f32();\n        // Update the predicate for the next iteration, considering the remaining length\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For int32_t\n#include <limits.h> // For INT32_MAX, INT32_MIN\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Duplicate INT32_MAX and INT32_MIN as float values into SVE vectors.\n    // These integer limits are exactly representable as float.\n    const svfloat32_t sv_int32_max_f = svdup_f32((float)INT32_MAX);\n    const svfloat32_t sv_int32_min_f = svdup_f32((float)INT32_MIN);\n\n    // Loop through the arrays in chunks determined by the SVE vector length.\n    // svwhilelt_b32 generates a predicate for the active elements in the current vector.\n    for (; i < size; i += svcntw()) {\n        // Get the predicate for the current vector, ensuring we don't go past 'size'.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load float values from the source array A.\n        svfloat32_t va = svld1(pg, A + i);\n\n        // --- Saturation Logic ---\n        // Step 1: Handle values greater than INT32_MAX.\n        // Create a predicate for elements where va > INT32_MAX (as float).\n        svbool_t pg_gt_max = svcmpgt(pg, va, sv_int32_max_f);\n        // If va > INT32_MAX, select sv_int32_max_f; otherwise, keep va.\n        svfloat32_t va_saturated = svsel(pg_gt_max, sv_int32_max_f, va);\n\n        // Step 2: Handle values less than INT32_MIN.\n        // Create a predicate for elements where va_saturated < INT32_MIN (as float).\n        svbool_t pg_lt_min = svcmplt(pg, va_saturated, sv_int32_min_f);\n        // If va_saturated < INT32_MIN, select sv_int32_min_f; otherwise, keep va_saturated.\n        va_saturated = svsel(pg_lt_min, sv_int32_min_f, va_saturated);\n\n        // Convert the saturated float values to int32_t.\n        // The svcvt_s32_f32_x intrinsic performs a saturating conversion if the input float\n        // is within the range of float values representable by int32_t.\n        // Our explicit saturation above handles cases where the float value is\n        // outside this range (e.g., extremely large or small floats like FLT_MAX/FLT_MIN).\n        svint32_t vb = svcvt_s32_f32_x(pg, va_saturated);\n\n        // Store the resulting int32_t values to the destination array B.\n        svst1(pg, B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // Required for int32_t\n#include <limits.h> // Required for INT32_MAX and INT32_MIN (though svcvt_s32_f32_x handles saturation internally)\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    // Loop while the predicate is active for at least one element\n    // svwhilelt_b32 generates a predicate for 32-bit elements, active as long as 'i' is less than 'size'.\n    // The number of active elements in the predicate will be the current vector length (VL)\n    // or the remaining elements (size - i), whichever is smaller.\n    for (; i < size; ) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load float values from array A using the predicate.\n        // Only active elements are loaded.\n        svfloat32_t vec_A = svld1_f32(pg, A + i);\n\n        // Convert float to int32_t with saturation.\n        // The svcvt_s32_f32_x intrinsic performs the conversion.\n        // According to the Arm SVE ACLE specification, this intrinsic inherently handles\n        // saturation: if the floating-point value is outside the range of the signed\n        // 32-bit integer type, the result is saturated to INT32_MAX or INT32_MIN.\n        svint32_t vec_B = svcvt_s32_f32_x(pg, vec_A);\n\n        // Store the resulting int32_t values to array B using the predicate.\n        // Only active elements are stored.\n        svst1_s32(pg, B + i, vec_B);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector.\n        // svcntw() returns the number of 32-bit elements in a vector (VL/4).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // Required for INT32_MAX and INT32_MIN\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Define float versions of INT32_MAX and INT32_MIN for comparison.\n    // Note: (float)INT32_MAX and (float)INT32_MIN might not be exactly\n    // representable as floats, but they will be rounded to the nearest\n    // representable float, which is typically 2^31 and -2^31 respectively.\n    // This is suitable for the saturation logic.\n    const float INT32_MAX_F = (float)INT32_MAX;\n    const float INT32_MIN_F = (float)INT32_MIN;\n\n    // Duplicate these constants into SVE vectors to use in comparisons.\n    svfloat32_t sv_int32_max_f = svdup_f32(INT32_MAX_F);\n    svfloat32_t sv_int32_min_f = svdup_f32(INT32_MIN_F);\n\n    // Loop through the arrays in chunks determined by the SVE vector length\n    while (i < size) {\n        // Get the predicate for the current vector length, ensuring we don't\n        // process beyond the array bounds.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Get the number of active elements in this vector.\n        // This is used to correctly advance the pointer for the next iteration.\n        size_t elements_in_vector = svcnt_u32(pg);\n\n        // Load float values from array A into an SVE float vector.\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n\n        // --- Saturation Logic ---\n        // 1. Check for values greater than INT32_MAX_F\n        //    Create a predicate where elements of a_vec are greater than sv_int32_max_f.\n        svbool_t pg_gt_max = svcmpgt_f32(pg, a_vec, sv_int32_max_f);\n\n        // 2. Apply saturation for values greater than INT32_MAX_F\n        //    If pg_gt_max is true for an element, select sv_int32_max_f;\n        //    otherwise, keep the original a_vec value.\n        svfloat32_t saturated_a_vec = svsel_f32(pg_gt_max, sv_int32_max_f, a_vec);\n\n        // 3. Check for values less than INT32_MIN_F\n        //    Create a predicate where elements of saturated_a_vec are less than sv_int32_min_f.\n        svbool_t pg_lt_min = svcmplt_f32(pg, saturated_a_vec, sv_int32_min_f);\n\n        // 4. Apply saturation for values less than INT32_MIN_F\n        //    If pg_lt_min is true for an element, select sv_int32_min_f;\n        //    otherwise, keep the previously saturated_a_vec value.\n        saturated_a_vec = svsel_f32(pg_lt_min, sv_int32_min_f, saturated_a_vec);\n\n        // Convert the saturated float values to signed 32-bit integers.\n        // The svcvt_s32_f32 intrinsic performs rounding towards zero.\n        svint32_t b_vec = svcvt_s32_f32(pg, saturated_a_vec);\n\n        // Store the resulting int32_t values to array B.\n        svst1_s32(pg, &B[i], b_vec);\n\n        // Advance the index for the next iteration by the number of elements\n        // processed in this vector.\n        i += elements_in_vector;\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h> // Required for INT32_MAX and INT32_MIN\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    // Define the float representations of INT32_MAX and INT32_MIN.\n    // These will be used for clamping the input float values before conversion.\n    const float float_int32_max = (float)INT32_MAX;\n    const float float_int32_min = (float)INT32_MIN;\n\n    size_t i = 0;\n    // Loop through the arrays using SVE vector processing\n    // svwhilelt_b32 generates a predicate for the remaining elements\n    // in the array, ensuring correct handling of the tail.\n    while (i < size) {\n        // Get the predicate for the current vector operation.\n        // 'pg' will be true for elements where 'i' is less than 'size'.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load a vector of float values from array A.\n        // Only active elements (determined by 'pg') are loaded.\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n\n        // Create SVE vectors containing the float_int32_max and float_int32_min constants.\n        svfloat32_t vec_float_int32_max = svdup_f32(float_int32_max);\n        svfloat32_t vec_float_int32_min = svdup_f32(float_int32_min);\n\n        // Clamp the float values in vec_A to be within the range [float_int32_min, float_int32_max].\n        // First, ensure no value is less than float_int32_min.\n        vec_A = svmax_f32(pg, vec_A, vec_float_int32_min);\n        // Then, ensure no value is greater than float_int32_max.\n        vec_A = svmin_f32(pg, vec_A, vec_float_int32_max);\n\n        // Convert the clamped float values to signed 32-bit integers.\n        // The conversion is performed for active elements only.\n        svint32_t vec_B = svcvt_s32_f32(pg, vec_A);\n\n        // Store the resulting int32_t values into array B.\n        // Only active elements are written to memory.\n        svst1_s32(pg, &B[i], vec_B);\n\n        // Advance the loop counter by the number of elements processed in this iteration.\n        // svcntp_b32(pg) returns the count of active elements in the predicate.\n        i += svcntp_b32(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // Required for int32_t\n#include <limits.h> // Required for INT32_MAX, INT32_MIN (though not directly used, good practice)\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    // Loop while there are elements remaining to process\n    while (size > 0) {\n        // Get a predicate for the current vector length (VL) or remaining elements.\n        // svwhilelt_b32(0, size) generates a predicate that is true for elements\n        // from 0 up to (VL-1) or 'size-1', whichever is smaller.\n        svbool_t pg = svwhilelt_b32(0, size);\n\n        // Get the actual number of elements that will be processed in this iteration.\n        // This is the number of active lanes in the predicate 'pg'.\n        size_t elements_in_vector = svcnt_f32(pg);\n\n        // Load a vector of float values from the source array A using the predicate.\n        svfloat32_t vec_A = svld1_f32(pg, A);\n\n        // Convert the float values to signed 32-bit integers with saturation.\n        // The svcvt_s32_f32_x intrinsic (which maps to the FCVTZS instruction)\n        // inherently handles the saturation requirement:\n        // - Values greater than INT32_MAX are saturated to INT32_MAX.\n        // - Values less than INT32_MIN are saturated to INT32_MIN.\n        // - Other values are converted directly (truncated towards zero).\n        svint32_t vec_B = svcvt_s32_f32_x(pg, vec_A);\n\n        // Store the resulting int32_t vector to the destination array B using the predicate.\n        svst1_s32(pg, B, vec_B);\n\n        // Advance the pointers for the source and destination arrays.\n        A += elements_in_vector;\n        B += elements_in_vector;\n\n        // Decrease the remaining size by the number of elements processed.\n        size -= elements_in_vector;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    // Duplicate the scale factor into a float vector once\n    // It's important to cast scale to float before duplicating to avoid potential issues\n    // with implicit type promotion during multiplication if scale was duplicated as int.\n    // However, svdup_f32 takes a float, so we must cast.\n    svfloat32_t sv_scale = svdup_f32((float)scale);\n\n    // Loop through the arrays in chunks determined by the SVE vector length\n    while (i < size) {\n        // Get a predicate for the current chunk\n        // This predicate will be true for elements within the current chunk and within the array bounds\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load int32_t values from array A into an SVE vector\n        svint32_t sv_A = svld1_s32(pg, A + i);\n\n        // Convert the int32_t vector to a float vector\n        svfloat32_t sv_B_float = svcvt_f32_s32(pg, sv_A);\n\n        // Scale the float vector by the pre-duplicated scale factor\n        sv_B_float = svmul_f32(pg, sv_B_float, sv_scale);\n\n        // Store the result into array B\n        svst1_f32(pg, B + i, sv_B_float);\n\n        // Increment the loop counter by the number of elements processed in this chunk\n        // svcntw() returns the number of 32-bit elements in a full SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    // Duplicate the scale factor into a float vector\n    // This needs to be done once outside the loop as it's a scalar value.\n    // First, convert int8_t scale to float.\n    float f_scale = (float)scale;\n    svfloat32_t sv_scale = svdup_f32(f_scale);\n\n    while (i < size) {\n        // Get the predicate for the current vector length\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load int32_t values from A\n        svint32_t vec_A = svld1_s32(pg, A + i);\n\n        // Convert int32_t to float\n        svfloat32_t vec_B_float = svcvt_f32_s32_x(pg, vec_A);\n\n        // Scale the float values\n        svfloat32_t vec_B_scaled = svmul_f32_x(pg, vec_B_float, sv_scale);\n\n        // Store the result to B\n        svst1_f32(pg, B + i, vec_B_scaled);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    // Convert the int8_t scale factor to float once\n    float scale_f = (float)scale;\n\n    // Duplicate the float scale factor into an SVE float vector\n    svfloat32_t sv_scale = svdup_f32(scale_f);\n\n    // Loop through the arrays in chunks determined by the SVE vector length\n    // svwhilelt_b32 generates a predicate for elements where 'i' is less than 'size'\n    // and 'i' is incremented by the number of elements in a vector (svcntw()).\n    for (i = 0; i < size; i += svcntw()) {\n        // Create a predicate for the current chunk.\n        // The predicate will be active for elements within the bounds [i, size).\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load 32-bit integers from array A into an SVE vector.\n        // Only active elements (determined by pg) are loaded.\n        svint32_t sv_int_val = svld1_s32(pg, A + i);\n\n        // Convert the 32-bit integer vector to a 32-bit floating-point vector.\n        // The conversion is performed only for active elements.\n        svfloat32_t sv_float_val = svcvt_f32_s32(pg, sv_int_val);\n\n        // Multiply the floating-point vector by the scale factor vector.\n        // The multiplication is performed only for active elements.\n        svfloat32_t sv_result = svmul_f32(pg, sv_float_val, sv_scale);\n\n        // Store the resulting floating-point vector into array B.\n        // Only active elements are stored.\n        svst1_f32(pg, B + i, sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Convert the int8_t scale factor to float once\n    float float_scale = (float)scale;\n\n    // Loop while there are still elements to process\n    while (size > 0) {\n        // Get the predicate for the current vector length\n        // This predicate will be true for the number of elements that fit in a vector\n        // or the remaining 'size', whichever is smaller.\n        svbool_t pg = svwhilelt_b32(0, size);\n\n        // Load a vector of int32_t from array A using the predicate\n        svint32_t vec_A = svld1_s32(pg, A);\n\n        // Convert the int32_t vector to a float vector\n        svfloat32_t vec_B_float = svcvt_f32_s32(pg, vec_A);\n\n        // Broadcast the float_scale factor to a vector of floats\n        svfloat32_t vec_scale = svdup_f32(float_scale);\n\n        // Multiply the converted float vector by the scale factor vector\n        svfloat32_t vec_scaled_B = svmul_f32(pg, vec_B_float, vec_scale);\n\n        // Store the resulting float vector into array B using the predicate\n        svst1_f32(pg, B, vec_scaled_B);\n\n        // Get the number of elements processed in this iteration\n        // This is the actual number of active elements in the predicate.\n        size_t elements_processed = svcntp_b32(pg);\n\n        // Advance the pointers and decrement the remaining size\n        A += elements_processed;\n        B += elements_processed;\n        size -= elements_processed;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    // Convert the int8_t scale factor to float once for broadcasting\n    float scale_f = (float)scale;\n\n    while (i < size) {\n        // Get the predicate for the current vector length\n        // This predicate will be true for elements up to 'size - i'\n        svbool_t pg = svwhilelt_b32((uint64_t)i, (uint64_t)size);\n\n        // Load a vector of int32_t from array A\n        svint32_t vec_A = svld1_s32(pg, A + i);\n\n        // Convert the int32_t vector to a float vector\n        svfloat32_t vec_B_float = svcvt_f32_s32_x(pg, vec_A);\n\n        // Broadcast the float scale factor to a full SVE float vector\n        svfloat32_t vec_scale = svdup_f32(scale_f);\n\n        // Multiply the float vector by the scale factor\n        svfloat32_t vec_scaled_B = svmul_f32_x(pg, vec_B_float, vec_scale);\n\n        // Store the result into array B\n        svst1_f32(pg, B + i, vec_scaled_B);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        // svcntw() returns the number of 32-bit elements in a vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while there are still elements to process\n    while (i < size) {\n        // Get a predicate for the current vector operation.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the array, especially for the last, partial vector.\n        pg = svwhilelt_b32(i, size);\n\n        // Load a vector of float32 from array A\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n\n        // Load a vector of float32 from array B\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division: A / B\n        svfloat32_t vec_div_result = svdiv_f32(pg, vec_A, vec_B);\n\n        // Round the floating-point result to the nearest integer (ties to even)\n        svfloat32_t vec_rounded_float = svrintn_f32(pg, vec_div_result);\n\n        // Convert the rounded floating-point values to signed 32-bit integers.\n        // This intrinsic handles saturation if the value is outside the int32_t range.\n        svint32_t vec_C = svcvt_s32_f32(pg, vec_rounded_float);\n\n        // Store the resulting int32_t vector into array C\n        svst1_s32(pg, &C[i], vec_C);\n\n        // Increment the loop counter by the number of elements processed in this vector.\n        // svcntw() returns the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        // Get the predicate for the current vector length\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load elements from A and B\n        svfloat32_t vec_a = svld1_f32(pg, A + i);\n        svfloat32_t vec_b = svld1_f32(pg, B + i);\n\n        // Perform element-wise division: A / B\n        svfloat32_t vec_div_result = svdiv_f32(pg, vec_a, vec_b);\n\n        // Round the result to the nearest integer (using round-to-nearest-even tie-breaking)\n        svfloat32_t vec_rounded_float = svrintn_f32(pg, vec_div_result);\n\n        // Convert the rounded float result to a 32-bit signed integer\n        // This intrinsic handles potential out-of-range values by saturating to INT_MIN/INT_MAX\n        svint32_t vec_int_result = svcvt_s32_f32(pg, vec_rounded_float);\n\n        // Store the integer results into C\n        svst1_s32(pg, C + i, vec_int_result);\n\n        // Move to the next chunk of data\n        i += svcntw(); // svcntw() returns the number of 32-bit elements in a vector\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        // Get a predicate for the current vector length\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load vector elements from A and B\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n\n        // Perform element-wise division: A / B\n        svfloat32_t vdiv = svdiv_f32(pg, va, vb);\n\n        // Round the result to the nearest integer (ties to even)\n        svfloat32_t vround = svrintn_f32(pg, vdiv);\n\n        // Convert the rounded float to a signed 32-bit integer.\n        // This intrinsic handles saturation for values outside the int32_t range.\n        svint32_t vc = svcvt_s32_f32(pg, vround);\n\n        // Store the result into the destination array C\n        svst1(pg, &C[i], vc);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t va = svld1(pg, A + i);\n        svfloat32_t vb = svld1(pg, B + i);\n\n        svfloat32_t vdiv = svdiv_f32(pg, va, vb);\n\n        svfloat32_t vround = svrintn_f32(pg, vdiv);\n\n        svint32_t vres = svcvt_s32_f32(pg, vround);\n\n        svst1(pg, C + i, vres);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (i = 0; i < size; ) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t vec_a = svld1_f32(pg, A + i);\n        svfloat32_t vec_b = svld1_f32(pg, B + i);\n\n        svfloat32_t vec_div_result = svdiv_f32(pg, vec_a, vec_b);\n\n        svfloat32_t vec_rounded_float = svrintn_f32(pg, vec_div_result);\n\n        svint32_t vec_c = svcvt_s32_f32(pg, vec_rounded_float);\n\n        svst1_s32(pg, C + i, vec_c);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <float.h> // Required for FLT_MAX\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    size_t sv_double_elements = svcntd(); // Number of double elements per SVE vector\n\n    // Predicate for all active lanes for double operations\n    svbool_t pg_64 = svptrue_b64();\n    // Predicate for all active lanes for float operations (for store and conversion)\n    svbool_t pg_32 = svptrue_b32();\n\n    // Load FLT_MAX and -FLT_MAX into double vectors for comparison\n    // FLT_MAX is implicitly promoted to double for svdup_f64\n    svfloat64_t v_flt_max_d = svdup_f64(FLT_MAX);\n    svfloat64_t v_neg_flt_max_d = svdup_f64(-FLT_MAX);\n\n    for (i = 0; i + sv_double_elements <= size; i += sv_double_elements) {\n        // Load double values from source array A\n        svfloat64_t v_d = svld1(pg_64, A + i);\n\n        // Compare v_d with FLT_MAX (as double)\n        svbool_t pg_gt_flt_max = svcmpgt(pg_64, v_d, v_flt_max_d);\n        // Compare v_d with -FLT_MAX (as double)\n        svbool_t pg_lt_neg_flt_max = svcmplt(pg_64, v_d, v_neg_flt_max_d);\n\n        // Apply saturation logic in double precision\n        // If v_d > FLT_MAX, set to FLT_MAX (as double), otherwise keep v_d\n        svfloat64_t saturated_d = svsel_f64(pg_gt_flt_max, v_flt_max_d, v_d);\n        // If v_d < -FLT_MAX, set to -FLT_MAX (as double), otherwise keep the previously saturated value\n        saturated_d = svsel_f64(pg_lt_neg_flt_max, v_neg_flt_max_d, saturated_d);\n\n        // Convert saturated double values to float values\n        // The predicate pg_32 ensures all elements are converted and written to the output float vector\n        svfloat32_t v_f = svcvt_f32_f64(pg_32, saturated_d);\n\n        // Store float values to destination array B\n        svst1(pg_32, B + i, v_f);\n    }\n\n    // Handle remaining elements (tail processing)\n    if (i < size) {\n        // Create a predicate for the remaining double elements\n        svbool_t pg_tail_64 = svwhilelt_b64(i, size);\n        // Create a predicate for the remaining float elements (for conversion and store)\n        svbool_t pg_tail_32 = svwhilelt_b32(i, size);\n\n        // Load double values for tail\n        svfloat64_t v_d_tail = svld1(pg_tail_64, A + i);\n\n        // Apply saturation logic for tail elements\n        svbool_t pg_gt_flt_max_tail = svcmpgt(pg_tail_64, v_d_tail, v_flt_max_d);\n        svbool_t pg_lt_neg_flt_max_tail = svcmplt(pg_tail_64, v_d_tail, v_neg_flt_max_d);\n\n        svfloat64_t saturated_d_tail = svsel_f64(pg_gt_flt_max_tail, v_flt_max_d, v_d_tail);\n        saturated_d_tail = svsel_f64(pg_lt_neg_flt_max_tail, v_neg_flt_max_d, saturated_d_tail);\n\n        // Convert and store for tail elements\n        svfloat32_t v_f_tail = svcvt_f32_f64(pg_tail_32, saturated_d_tail);\n        svst1(pg_tail_32, B + i, v_f_tail);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cfloat> // Required for FLT_MAX\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    // Get the number of double elements that fit in an SVE vector.\n    // This determines the loop step size.\n    size_t sv_double_count = svcntd();\n\n    // Duplicate FLT_MAX and -FLT_MAX into SVE double vectors for comparison.\n    svfloat64_t flt_max_v = svdup_f64(FLT_MAX);\n    svfloat64_t neg_flt_max_v = svdup_f64(-FLT_MAX);\n\n    // Loop through the arrays using SVE vector processing.\n    // svwhilelt_b64 generates a predicate for the remaining elements,\n    // handling both full vectors and the tail.\n    for (i = 0; i < size; i += sv_double_count) {\n        // Generate a predicate for the current vector chunk.\n        // Elements beyond 'size' will have their predicate bit set to false.\n        svbool_t pg = svwhilelt_b64(i, size);\n\n        // Load a vector of double values from array A.\n        svfloat64_t vec_A = svld1_f64(pg, &A[i]);\n\n        // Initialize the saturated vector with the original values.\n        svfloat64_t saturated_vec = vec_A;\n\n        // Predicate for elements where vec_A > FLT_MAX.\n        svbool_t p_gt = svcmpgt_f64(pg, vec_A, flt_max_v);\n        // If vec_A > FLT_MAX, set the element to FLT_MAX, otherwise keep original.\n        saturated_vec = svsel_f64(p_gt, flt_max_v, saturated_vec);\n\n        // Predicate for elements where vec_A < -FLT_MAX.\n        svbool_t p_lt = svcmplt_f64(pg, vec_A, neg_flt_max_v);\n        // If vec_A < -FLT_MAX, set the element to -FLT_MAX, otherwise keep the\n        // value (which might already be FLT_MAX from the previous step).\n        saturated_vec = svsel_f64(p_lt, neg_flt_max_v, saturated_vec);\n\n        // Convert the saturated double vector to a float vector.\n        svfloat32_t vec_B = svcvt_f32_f64(pg, saturated_vec);\n\n        // Store the resulting float vector to array B.\n        svst1_f32(pg, &B[i], vec_B);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h> // For FLT_MAX\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Duplicate FLT_MAX and -FLT_MAX into SVE double vectors.\n    // These constants are used for saturation.\n    const svfloat64_t vec_FLT_MAX = svdup_f64(FLT_MAX);\n    const svfloat64_t vec_NEG_FLT_MAX = svdup_f64(-FLT_MAX);\n\n    while (i < size) {\n        // Get a predicate for the current vector length, processing 64-bit elements (doubles).\n        // This predicate ensures that we only process up to 'size' elements, handling the tail.\n        pg = svwhilelt_b64(i, size);\n\n        // Load a vector of doubles from array A using the predicate.\n        svfloat64_t vec_A = svld1(pg, A + i);\n\n        // Create a predicate for elements where A > FLT_MAX.\n        svbool_t pg_gt = svcmpgt(pg, vec_A, vec_FLT_MAX);\n\n        // Create a predicate for elements where A < -FLT_MAX.\n        svbool_t pg_lt = svcmplt(pg, vec_A, vec_NEG_FLT_MAX);\n\n        // Apply saturation for values greater than FLT_MAX.\n        // If pg_gt is true for an element, select FLT_MAX; otherwise, select the original value from vec_A.\n        svfloat64_t vec_saturated_A = svsel(pg_gt, vec_FLT_MAX, vec_A);\n\n        // Apply saturation for values less than -FLT_MAX.\n        // If pg_lt is true for an element, select -FLT_MAX; otherwise, select the value from the previous saturation step.\n        vec_saturated_A = svsel(pg_lt, vec_NEG_FLT_MAX, vec_saturated_A);\n\n        // Convert the saturated double vector to a float vector.\n        // The 'pg' (b64) predicate ensures that conversion is performed only for active lanes.\n        // svcvt_f32_f64 converts each 64-bit double lane to a 32-bit float lane.\n        svfloat32_t vec_B = svcvt_f32_f64(pg, vec_saturated_A);\n\n        // Store the resulting float vector into array B.\n        // The 'pg' (b64) predicate ensures that only the elements corresponding\n        // to the active 64-bit lanes (from the original double array) are stored.\n        svst1(pg, B + i, vec_B);\n\n        // Increment the loop counter by the number of 64-bit elements processed in this iteration.\n        // svcntd() returns the number of 64-bit elements in an SVE vector for the current vector length.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h> // Required for FLT_MAX\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Get FLT_MAX and -FLT_MAX as double values for comparison\n    const double flt_max_d = FLT_MAX;\n    const double neg_flt_max_d = -FLT_MAX;\n\n    // Broadcast FLT_MAX and -FLT_MAX into SVE double vectors\n    // These vectors will be used for comparison and saturation\n    svfloat64_t sv_flt_max = svdup_f64(flt_max_d);\n    svfloat64_t sv_neg_flt_max = svdup_f64(neg_flt_max_d);\n\n    // Loop through the arrays using SVE vector processing\n    // The loop iterates while 'i' (current index) is less than 'size' (total elements)\n    while (i < size) {\n        // Generate a predicate for 64-bit elements (doubles)\n        // This predicate 'pg' determines which elements in the current vector are active\n        // It ensures that we don't process beyond the 'size' boundary.\n        svbool_t pg = svwhilelt_b64(i, size);\n\n        // Load a vector of double values from array A\n        // Only elements corresponding to active predicate lanes are loaded.\n        svfloat64_t vec_A = svld1_f64(pg, A + i);\n\n        // --- Saturation Logic ---\n        // 1. Check if elements in vec_A are greater than FLT_MAX\n        svbool_t cmp_gt_flt_max = svcmpgt_f64(pg, vec_A, sv_flt_max);\n        // 2. Check if elements in vec_A are less than -FLT_MAX\n        svbool_t cmp_lt_neg_flt_max = svcmplt_f64(pg, vec_A, sv_neg_flt_max);\n\n        // Apply the saturation:\n        // If an element in vec_A is > FLT_MAX (cmp_gt_flt_max is true), set it to sv_flt_max.\n        // Otherwise, keep the original vec_A value.\n        svfloat64_t saturated_vec_A = svsel_f64(cmp_gt_flt_max, sv_flt_max, vec_A);\n\n        // Now, from the result of the previous step (saturated_vec_A),\n        // if an element was < -FLT_MAX (cmp_lt_neg_flt_max is true), set it to sv_neg_flt_max.\n        // Otherwise, keep the value from the previous saturation step.\n        saturated_vec_A = svsel_f64(cmp_lt_neg_flt_max, sv_neg_flt_max, saturated_vec_A);\n\n        // Convert the saturated double values to float values\n        // The predicate 'pg' ensures that only active elements are converted.\n        svfloat32_t vec_B = svcvt_f32_f64(pg, saturated_vec_A);\n\n        // Store the resulting float values into array B\n        // The predicate 'pg' (for 64-bit elements) correctly applies to the corresponding\n        // 32-bit elements, ensuring only active lanes are written.\n        svst1_f32(pg, B + i, vec_B);\n\n        // Advance the loop counter by the number of 64-bit elements processed in this iteration.\n        // svcntd() returns the number of 64-bit elements in a full SVE vector for the current architecture.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h> // Required for FLT_MAX\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Duplicate FLT_MAX and -FLT_MAX into SVE double vectors.\n    // FLT_MAX is a float, but it's promoted to double for these comparisons.\n    const svfloat64_t flt_max_d = svdup_f64(FLT_MAX);\n    const svfloat64_t neg_flt_max_d = svdup_f64(-FLT_MAX);\n\n    // Loop through the arrays using SVE's variable vector length (VL)\n    // svwhilelt_b64 generates a predicate for elements where 'i' < 'size'.\n    // The predicate is for 64-bit elements (doubles).\n    while (i < size) {\n        svbool_t pg = svwhilelt_b64(i, size);\n\n        // Load a vector of double values from array A\n        svfloat64_t vec_d = svld1_f64(pg, A + i);\n\n        // Clamp the double values to the range [-FLT_MAX, FLT_MAX]\n        // 1. Ensure values are not less than -FLT_MAX\n        //    clamped_d = max(vec_d, -FLT_MAX_d)\n        svfloat64_t clamped_d = svmax_f64(pg, vec_d, neg_flt_max_d);\n        // 2. Ensure values are not greater than FLT_MAX\n        //    clamped_d = min(clamped_d, FLT_MAX_d)\n        clamped_d = svmin_f64(pg, clamped_d, flt_max_d);\n\n        // Convert the clamped double values to float values.\n        // svcvt_f32_f64 converts VL_d (number of double elements per vector)\n        // double values to VL_d float values.\n        svfloat32_t vec_f = svcvt_f32_f64(pg, clamped_d);\n\n        // Store the resulting float values to array B.\n        // The predicate 'pg' (b64) correctly controls the store of VL_d elements,\n        // as the conversion also produced VL_d elements.\n        svst1_f32(pg, B + i, vec_f);\n\n        // Increment the loop counter by the number of double elements processed\n        // in this vector. svcntd() returns the current vector length for doubles.\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        // Create a predicate for the current vector length of int32_t elements.\n        // This predicate determines how many int32_t elements to process in this iteration.\n        svbool_t pg_32 = svwhilelt_b32(i, size);\n\n        // Get the number of active int32_t elements for the current predicate.\n        // This is the actual number of elements that will be processed in this iteration.\n        size_t current_vl_32 = svcntp_b32(svptrue_b32(), pg_32);\n\n        // Create a predicate for loading int16_t elements.\n        // Since svcvt_s32_s16 converts the lower half of an svint16_t vector\n        // to a full svint32_t vector (i.e., svcntw() elements),\n        // we need to ensure that at least 'current_vl_32' int16_t elements are loaded.\n        // The svwhilelt_b16 predicate will cover up to svcnth() elements,\n        // which is twice svcntw(). This is sufficient.\n        svbool_t pg_16 = svwhilelt_b16(i, size);\n\n        // Load int16_t values from array A using the int16_t predicate.\n        // Inactive lanes (beyond 'size' or 'current_vl_32' if it's less than svcntw())\n        // will be loaded as zero, but these will be masked out during store.\n        svint16_t a_vec = svld1_s16(pg_16, A + i);\n\n        // Convert the int16_t vector to an int32_t vector.\n        // svcvt_s32_s16 converts the lower svcntw() elements of the svint16_t vector\n        // into a full svint32_t vector.\n        svint32_t b_vec = svcvt_s32_s16(a_vec);\n\n        // Store the converted int32_t values to array B using the int32_t predicate.\n        // This ensures that only the active elements (up to 'current_vl_32') are written.\n        svst1_s32(pg_32, B + i, b_vec);\n\n        // Advance the index by the number of int32_t elements processed in this iteration.\n        i += current_vl_32;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        // Get a predicate for the current vector length for 32-bit elements.\n        // This predicate determines how many elements to process in this iteration,\n        // handling the tail elements automatically.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load int16_t elements from array A, sign-extend them to int32_t,\n        // and store them into a svint32_t vector.\n        // svld1_s16_s32 loads svcntw() elements of int16_t and converts them to int32_t.\n        svint32_t vec_32 = svld1_s16_s32(pg, A + i);\n\n        // Store the resulting svint32_t vector to array B.\n        svst1_s32(pg, B + i, vec_32);\n\n        // Increment the loop counter by the number of elements processed in this iteration.\n        // svcnt_s32(pg) returns the number of active 32-bit elements in the predicate.\n        i += svcnt_s32(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    // Get the number of 16-bit elements that fit in an SVE vector.\n    // This is VL / sizeof(int16_t).\n    size_t elements_per_vec_16 = svcnth(); \n    // Get the number of 32-bit elements that fit in an SVE vector.\n    // This is VL / sizeof(int32_t).\n    size_t elements_per_vec_32 = svcntw();\n\n    // In SVE, elements_per_vec_16 is always twice elements_per_vec_32.\n    // This means one svint16_t vector holds enough data to produce two svint32_t vectors.\n\n    while (i < size) {\n        // 1. Generate a predicate for loading 'elements_per_vec_16' 16-bit elements from A.\n        // This predicate ensures that we only process valid elements up to 'size'.\n        svbool_t pg_16 = svwhilelt_b16(i, size);\n        \n        // If no elements are active in the predicate, it means we have processed all elements\n        // or the remaining elements are fewer than what a 16-bit vector can hold.\n        if (!svptest_any(svptrue_b16(), pg_16)) {\n            break;\n        }\n\n        // 2. Load a vector of 16-bit integers from A.\n        // This vector will contain 'elements_per_vec_16' elements, with inactive elements masked.\n        svint16_t vec_16 = svld1(pg_16, A + i);\n\n        // 3. Convert the lower half of the 16-bit vector to a 32-bit vector.\n        // The svsext_s32_s16 intrinsic implicitly operates on the lower 'elements_per_vec_32'\n        // elements of the input svint16_t vector and sign-extends them to 32-bit.\n        svint32_t vec_32_lo = svsext_s32_s16(vec_16);\n\n        // 4. Extract the upper half of the 16-bit vector.\n        // svextract_s16 shifts the vector by 'elements_per_vec_32' positions.\n        // The second argument (svdup_s16(0)) provides elements to fill the vacated positions,\n        // effectively extracting the upper half of 'vec_16'.\n        svint16_t vec_16_hi = svextract_s16(vec_16, svdup_s16(0), elements_per_vec_32);\n\n        // 5. Convert the extracted upper half (now in vec_16_hi) to a 32-bit vector.\n        svint32_t vec_32_hi = svsext_s32_s16(vec_16_hi);\n\n        // 6. Generate predicates for storing the two 32-bit vectors to B.\n        // pg_32_lo covers the first 'elements_per_vec_32' 32-bit elements.\n        svbool_t pg_32_lo = svwhilelt_b32(i, size);\n        // Store the first 32-bit vector to B.\n        svst1(pg_32_lo, B + i, vec_32_lo);\n\n        // pg_32_hi covers the next 'elements_per_vec_32' 32-bit elements.\n        svbool_t pg_32_hi = svwhilelt_b32(i + elements_per_vec_32, size);\n        // Store the second 32-bit vector to B.\n        svst1(pg_32_hi, B + i + elements_per_vec_32, vec_32_hi);\n\n        // 7. Advance the index by the total number of 16-bit elements processed in this iteration.\n        // This is 'elements_per_vec_16' (which is equivalent to 2 * elements_per_vec_32).\n        i += elements_per_vec_16;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Loop through the arrays using SVE vector operations.\n    // The loop continues as long as there are elements remaining to process.\n    // svwhilelt_b32 generates a predicate for 32-bit elements,\n    // which determines how many elements (up to the SVE vector length for 32-bit integers)\n    // will be processed in the current iteration.\n    for (; i < size; ) {\n        // Generate a predicate 'pg' for the current iteration.\n        // It's active for elements from 'i' up to 'size - 1'.\n        // The predicate is generated with a granularity of 32-bit elements.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Get the actual number of active elements in the current predicate.\n        // This tells us how many 32-bit elements (and thus how many 16-bit elements\n        // for the conversion) are being processed in this iteration.\n        size_t num_active_elements = svcntp_b32(svptrue_b32(), pg);\n\n        // Load int16_t values from array A using the generated predicate.\n        // svld1_s16 loads 'num_active_elements' of int16_t values into a vector.\n        svint16_t vec_s16 = svld1_s16(pg, &A[i]);\n\n        // Convert the loaded int16_t values to int32_t values.\n        // svsext_s32_s16 performs a sign-extension from 16-bit to 32-bit.\n        // It operates on 'num_active_elements' of int16_t and produces\n        // 'num_active_elements' of int32_t.\n        svint32_t vec_s32 = svsext_s32_s16(pg, vec_s16);\n\n        // Store the resulting int32_t values into array B using the same predicate.\n        svst1_s32(pg, &B[i], vec_s32);\n\n        // Advance the loop counter by the number of elements processed in this iteration.\n        i += num_active_elements;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int16_t, int32_t\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    size_t sv_elements_s16 = svcntw(); \n    size_t sv_elements_s32 = svcntd();\n\n    for (i = 0; i < size; i += sv_elements_s16) {\n        svbool_t pg_s16 = svwhilelt_b16(i, size);\n\n        svint16_t vec_s16 = svld1_s16(pg_s16, &A[i]);\n\n        svint32_t vec_s32_low = svget_s32_s16(vec_s16);\n        svint32_t vec_s32_high = svget_s32_s16_v2(vec_s16);\n\n        svbool_t pg_s32_low = svwhilelt_b32(i, size);\n        svbool_t pg_s32_high = svwhilelt_b32(i + sv_elements_s32, size);\n\n        svst1_s32(pg_s32_low, &B[i], vec_s32_low);\n        svst1_s32(pg_s32_high, &B[i + sv_elements_s32], vec_s32_high);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Duplicate scalar values into SVE vectors\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t zero_f_vec = svdup_f32(0.0f);\n    svfloat32_t one_f_vec = svdup_f32(1.0f);\n    svint32_t zero_s32_vec = svdup_s32(0);\n\n    // Calculate the range (max_val - min_val)\n    // This will be used as the divisor in the normalization formula.\n    // If max_val == min_val, range_vec will be 0.0f.\n    // Division by zero will result in Inf or NaN according to IEEE 754,\n    // which will then be handled by the clamping operations (Inf becomes 0.0f or 1.0f, NaN propagates).\n    svfloat32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        // Get the predicate for the current vector length, handling the tail end of the array\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // If no active lanes, break the loop\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break;\n        }\n\n        // Load data from arrays A and control\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        // Create a predicate for lanes where normalization is required (control > 0)\n        svbool_t pg_normalize = svcmpgt_s32(pg, control_vec, zero_s32_vec);\n\n        // Perform normalization calculations on all lanes.\n        // The results will be conditionally selected later using svsel.\n        // val = (A[i] - min_val) / (max_val - min_val);\n        svfloat32_t val_sub = svsub_f32(a_vec, min_val_vec);\n        svfloat32_t val_div = svdiv_f32(val_sub, range_vec);\n\n        // Clamp the normalized value to the [0, 1] range\n        // val = fmaxf(0.0f, fminf(1.0f, val));\n        svfloat32_t clamped_val = svmax_f32(val_div, zero_f_vec);\n        clamped_val = svmin_f32(clamped_val, one_f_vec);\n\n        // Select the final result for B[i] based on the control predicate:\n        // If pg_normalize is true (control > 0), use the clamped_val.\n        // Otherwise (control <= 0), copy the original a_vec value.\n        svfloat32_t result_vec = svsel_f32(pg_normalize, clamped_val, a_vec);\n\n        // Store the result vector to array B\n        svst1_f32(pg, &B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Duplicate scalar values into SVE vectors\n    svfloat32_t v_min_val = svdup_f32(min_val);\n    svfloat32_t v_max_val = svdup_f32(max_val);\n    svfloat32_t v_zero_f32 = svdup_f32(0.0f);\n    svfloat32_t v_one_f32 = svdup_f32(1.0f);\n    svint32_t v_zero_s32 = svdup_s32(0);\n\n    // Calculate the difference (max_val - min_val) once.\n    // This value is constant for all lanes that normalize.\n    // If max_val == min_val, v_diff will contain zeros.\n    // Division by zero will result in +/-Inf or NaN, which will then be handled by clamping.\n    svfloat32_t v_diff = svsub_f32(v_max_val, v_min_val);\n\n    for (size_t i = 0; i < size; i += svcnt_f32()) {\n        // Get the predicate for the current vector chunk\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load data from source arrays A and control\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svint32_t vcontrol = svld1_s32(pg, &control[i]);\n\n        // Create a predicate for lanes where normalization is required (control > 0)\n        svbool_t pg_normalize = svcmpgt_s32(pg, vcontrol, v_zero_s32);\n\n        // Perform normalization calculations only for active lanes (where pg_normalize is true)\n        // For inactive lanes, the elements in vnumerator and vnormalized remain unchanged,\n        // which is fine as they won't be selected by svsel_f32 for those lanes.\n        svfloat32_t vnumerator = svsub_f32_x(pg_normalize, va, v_min_val);\n        svfloat32_t vnormalized = svdiv_f32_x(pg_normalize, vnumerator, v_diff);\n\n        // Clamp the normalized values to the [0, 1] range for active normalization lanes\n        vnormalized = svmax_f32_x(pg_normalize, vnormalized, v_zero_f32); // val = max(val, 0.0f)\n        vnormalized = svmin_f32_x(pg_normalize, vnormalized, v_one_f32);  // val = min(val, 1.0f)\n\n        // Select the final values for the destination array B:\n        // If pg_normalize is true (control > 0), use the calculated vnormalized value.\n        // Otherwise (control <= 0), use the original value from A (va).\n        svfloat32_t vb = svsel_f32(pg_normalize, vnormalized, va);\n\n        // Store the result to the destination array B\n        svst1_f32(pg, &B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Duplicate scalar values into SVE vectors for efficient per-lane operations\n    svfloat32_t v_min_val = svdup_f32(min_val);\n    svfloat32_t v_max_val = svdup_f32(max_val);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_one = svdup_f32(1.0f);\n\n    // Calculate the denominator (max_val - min_val) once.\n    // If max_val == min_val, v_diff will contain zeros, leading to Inf/NaN for division.\n    // The subsequent clamping will handle Inf/-Inf (to 1.0f/0.0f respectively).\n    // NaN values will typically propagate. The problem description does not specify\n    // special handling for max_val == min_val, so standard float behavior is assumed.\n    svfloat32_t v_diff = svsub_f32(v_max_val, v_min_val);\n\n    // Loop through the arrays in SVE vector chunks\n    // svcnt_f32() returns the number of 32-bit float elements in an SVE vector for the current CPU.\n    for (size_t i = 0; i < size; i += svcnt_f32()) {\n        // Get the predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements where 'i' is less than 'size',\n        // effectively handling the tail end of the array where 'size' is not a multiple of vector length.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load data from source arrays A (float) and control (int32_t)\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svint32_t vc = svld1_s32(pg, &control[i]);\n\n        // Create a predicate for elements where control[i] > 0.\n        // This predicate determines which lanes require normalization.\n        svbool_t p_normalize = svcmpgt_s32(pg, vc, svdup_s32(0));\n\n        // --- Normalization calculation (performed for all lanes, results selected later) ---\n        // Calculate (A[i] - min_val)\n        svfloat32_t v_numerator = svsub_f32(va, v_min_val);\n        \n        // Calculate (A[i] - min_val) / (max_val - min_val)\n        svfloat32_t v_normalized = svdiv_f32(v_numerator, v_diff);\n\n        // Clamp the normalized value to the range [0, 1]\n        // val = fmaxf(0.0f, val)\n        v_normalized = svmax_f32(v_normalized, v_zero); \n        // val = fminf(1.0f, val)\n        v_normalized = svmin_f32(v_normalized, v_one);  \n\n        // --- Select the final result for B[i] based on the control predicate ---\n        // svsel_f32 selects elements: if p_normalize is true for a lane, use v_normalized;\n        // otherwise, use va (the original value from A).\n        svfloat32_t v_result = svsel_f32(p_normalize, v_normalized, va);\n\n        // Store the computed result to the destination array B\n        svst1_f32(pg, &B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h> // For size_t\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n\n    // Duplicate min_val and max_val into SVE vectors\n    svfloat32_t v_min_val = svdup_f32(min_val);\n    svfloat32_t v_max_val = svdup_f32(max_val);\n    \n    // Calculate the range (max_val - min_val) once.\n    // Use svptrue_b32() to ensure this operation applies to all lanes of the vector.\n    svfloat32_t v_range = svsub_f32_x(svptrue_b32(), v_max_val, v_min_val);\n\n    // Prepare constants for clamping\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_one = svdup_f32(1.0f);\n\n    // Pre-calculate the inverse of the range, handling division by zero.\n    // If v_range is zero, v_range_inv will be 0.0f.\n    svbool_t p_range_is_zero_global = svcmpeq(svptrue_b32(), v_range, v_zero);\n    svfloat32_t v_range_inv = svdiv_f32_x(svnot_b(p_range_is_zero_global), v_one, v_range);\n    v_range_inv = svsel_f32(p_range_is_zero_global, v_zero, v_range_inv);\n\n    while (i < size) {\n        // Get a predicate for the current vector length, handling partial vectors at the end\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load A and control values\n        svfloat32_t va = svld1(pg, &A[i]);\n        svint32_t vc = svld1(pg, &control[i]);\n\n        // Predicate for normalization: control[i] > 0\n        svbool_t p_normalize = svcmpgt(pg, vc, 0);\n\n        // Calculate (A[i] - min_val) for active lanes.\n        // For inactive lanes (where pg is false), v_numerator will contain garbage,\n        // but this is fine as subsequent operations are also masked by pg.\n        svfloat32_t v_numerator = svsub_f32_x(pg, va, v_min_val);\n\n        // Calculate normalized value: (A[i] - min_val) * (1.0f / (max_val - min_val))\n        // If v_range_inv is 0.0f (meaning original range was zero), this multiplication results in 0.0f.\n        svfloat32_t v_normalized = svmul_f32_x(pg, v_numerator, v_range_inv);\n        \n        // Clamp the normalized value to [0, 1].\n        // These operations are also masked by pg, so they only affect active lanes.\n        svfloat32_t v_clamped = svmax_f32_x(pg, svmin_f32_x(pg, v_normalized, v_one), v_zero);\n\n        // Select the final result for B[i]:\n        // If control[i] > 0 (p_normalize is true), use v_clamped.\n        // Otherwise (p_normalize is false), use the original A[i] value (va).\n        svfloat32_t v_result = svsel_f32(p_normalize, v_clamped, va);\n\n        // Store the result into B\n        svst1(pg, &B[i], v_result);\n\n        // Increment loop counter by the number of elements processed in this vector\n        i += svcnt_f32();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Get the vector length for 32-bit elements (floats and int32_t)\n    size_t sv_len = svcntw();\n\n    // Duplicate scalar values into SVE vectors for efficient computation\n    svfloat32_t sv_min_val = svdup_f32(min_val);\n    svfloat32_t sv_max_val = svdup_f32(max_val);\n    svfloat32_t sv_zero_f32 = svdup_f32(0.0f);\n    svfloat32_t sv_one_f32 = svdup_f32(1.0f);\n    svint32_t sv_zero_s32 = svdup_s32(0);\n\n    // Calculate the range difference (max_val - min_val) once\n    // If max_val == min_val, this will be 0.0f. Division by zero will result in Inf/NaN\n    // as per IEEE 754, which will then be handled by the clamping operations.\n    svfloat32_t sv_range_diff = svsub_f32(sv_max_val, sv_min_val);\n\n    // Loop through the arrays in chunks of SVE vector length\n    for (size_t i = 0; i < size; i += sv_len) {\n        // Get the active predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the array bounds, handling the tail of the array.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load a vector of float values from array A\n        svfloat32_t a_vec = svld1(pg, A + i);\n\n        // Load a vector of int32_t control values from the control array\n        svint32_t control_vec = svld1(pg, control + i);\n\n        // Create a predicate for elements where control > 0.\n        // These are the elements that need normalization.\n        svbool_t pg_normalize = svcmpgt(pg, control_vec, sv_zero_s32);\n\n        // --- Calculate the normalized value for all elements ---\n        // This calculation is performed for all elements, but only applied\n        // to the output based on the 'pg_normalize' predicate later.\n\n        // Step 1: Calculate (A[i] - min_val)\n        svfloat32_t diff_A_min = svsub_f32(a_vec, sv_min_val);\n\n        // Step 2: Calculate (A[i] - min_val) / (max_val - min_val)\n        // If sv_range_diff contains zeros, this will produce Inf or NaN.\n        svfloat32_t normalized_val = svdiv_f32(diff_A_min, sv_range_diff);\n\n        // Step 3: Clamp the normalized value to the [0, 1] range.\n        // First, clamp to a maximum of 1.0f.\n        svfloat32_t clamped_val_upper = svmin_f32(sv_one_f32, normalized_val);\n        // Then, clamp to a minimum of 0.0f.\n        svfloat32_t clamped_val = svmax_f32(sv_zero_f32, clamped_val_upper);\n\n        // --- Select the final value for B[i] based on the control predicate ---\n        // If pg_normalize is true (control > 0), use the clamped_val.\n        // Otherwise (control <= 0), use the original value from a_vec.\n        svfloat32_t result_vec = svsel_f32(clamped_val, a_vec, pg_normalize);\n\n        // Store the resulting vector into array B using the active predicate.\n        svst1(pg, B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while (i < size) {\n        // Generate a predicate for the current vector length,\n        // ensuring we don't process beyond 'size'.\n        pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t values from array A.\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // Extract the high 16 bits by right-shifting the uint32_t values by 16.\n        svuint32_t high_16_bits = svlsr_u32(pg, vec_A, 16);\n\n        // Convert the extracted high 16 bits (as uint32_t) to float.\n        svfloat32_t float_val = svcvt_f32_u32(pg, high_16_bits);\n\n        // Compute the square root of the float values.\n        svfloat32_t sqrt_val = svsqrt_f32(pg, float_val);\n\n        // Store the resulting float vector into array B.\n        svst1_f32(pg, B + i, sqrt_val);\n\n        // Increment the loop counter by the number of 32-bit elements processed\n        // in the current vector (which is the SVE vector length for 32-bit elements).\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    // Loop while there are elements remaining to be processed\n    while (i < size) {\n        // Get the predicate for the current vector length.\n        // svwhilelt_b32 generates a predicate where lanes are active\n        // as long as the current index 'i' plus the lane offset is less than 'size'.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // 1. Load a vector of uint32_t values from array A.\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // 2. Extract the high 16 bits of each uint32_t value.\n        // This is done by right-shifting each 32-bit element by 16 bits.\n        // The result is a svuint32_t vector where the lower 16 bits of each element\n        // now contain the original high 16 bits, and the upper 16 bits are zero.\n        svuint32_t high_16_bits_u32 = svlsr_u32(vec_A, 16);\n\n        // 3. Convert the extracted 16-bit unsigned integer values (now in 32-bit lanes) to float.\n        // svcvt_f32_u32 converts svuint32_t to svfloat32_t.\n        svfloat32_t vec_float = svcvt_f32_u32(high_16_bits_u32);\n\n        // 4. Compute the square root of each float value in the vector.\n        svfloat32_t vec_sqrt = svsqrt_f32(vec_float);\n\n        // 5. Store the resulting float vector into array B.\n        svst1_f32(pg, B + i, vec_sqrt);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector.\n        // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    // Loop while there are still elements to process.\n    // svwhilelt_b32 generates a predicate for 32-bit elements (uint32_t, float).\n    // It sets active elements as long as the current index 'i' is less than 'size'.\n    // The number of active elements in the predicate is determined by the SVE vector length (svcntw()).\n    for (svbool_t pg = svwhilelt_b32(i, size); svcnt_b32(pg) > 0; pg = svwhilelt_b32(i, size)) {\n        // 1. Load uint32_t values from array A using the predicate 'pg'.\n        //    Only elements corresponding to active lanes in 'pg' are loaded.\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // 2. Extract the high 16 bits from each uint32_t value.\n        //    Perform a logical right shift by 16 bits.\n        //    This operation is element-wise on the vector.\n        svuint32_t high_16_bits_u32 = svlsr_n_u32(vec_A, 16);\n\n        // 3. Convert the extracted uint32_t values to float.\n        //    The conversion is performed only for active lanes as determined by 'pg'.\n        svfloat32_t float_val = svcvt_f32_u32(pg, high_16_bits_u32);\n\n        // 4. Take the square root of the float values.\n        //    The square root is computed only for active lanes.\n        svfloat32_t sqrt_val = svsqrt_f32(pg, float_val);\n\n        // 5. Store the result in array B.\n        //    Results are stored only for active lanes as determined by 'pg'.\n        svst1_f32(pg, B + i, sqrt_val);\n\n        // Increment the index by the number of 32-bit elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    // Loop while there are elements remaining to process\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    for (i = 0; i < size; i += svcntw()) {\n        // Get a predicate for the current vector length.\n        // This predicate ensures that we only process valid elements,\n        // especially for the tail end of the array.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // 1. Load a vector of uint32_t values from array A.\n        svuint32_t vec_A_u32 = svld1_u32(pg, A + i);\n\n        // 2. Extract the high 16 bits from each uint32_t value.\n        // This is done by logically shifting right by 16 bits.\n        // The result is a svuint32_t vector where each element's lower 16 bits\n        // now contain the original high 16 bits.\n        svuint32_t high_16_bits_u32 = svlsr_u32(vec_A_u32, 16);\n\n        // 3. Convert the extracted 16-bit unsigned integer values (now held in 32-bit lanes) to float.\n        svfloat32_t high_16_bits_f32 = svcvt_f32_u32(pg, high_16_bits_u32);\n\n        // 4. Take the square root of each float value in the vector.\n        svfloat32_t sqrt_val_f32 = svsqrt_f32(pg, high_16_bits_f32);\n\n        // 5. Store the resulting float vector into array B.\n        svst1_f32(pg, B + i, sqrt_val_f32);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while the predicate is active (i.e., there are elements left to process)\n    while (i < size) {\n        // Get a predicate for the current vector length\n        // This predicate will be true for elements within the bounds of 'size'\n        // and false for elements beyond 'size' or the current vector length.\n        pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t from array A\n        svuint32_t vec_A = svld1_u32(pg, A + i);\n\n        // Extract the high 16 bits by right-shifting by 16\n        svuint32_t high_16_bits = svlsr_u32(vec_A, 16);\n\n        // Convert the uint32_t values (high 16 bits) to float\n        svfloat32_t float_val = svcvt_f32_u32(pg, high_16_bits);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrt_val = svsqrt_f32(pg, float_val);\n\n        // Store the resulting float vector into array B\n        svst1_f32(pg, B + i, sqrt_val);\n\n        // Increment the loop counter by the number of elements processed in this vector\n        i += svcntw(); // svcntw() returns the number of 32-bit elements in a vector\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while there are still elements to process\n    while (i < size) {\n        // Get a predicate for the current vector length, handling the tail\n        // pg will be true for active lanes and false for inactive ones (if i + svcntw() > size)\n        pg = svwhilelt_b32(i, size);\n\n        // Load uint32_t values from array A into an SVE vector register\n        svuint32_t u32_vec = svld1_u32(pg, A + i);\n\n        // Reinterpret the bit pattern of the uint32_t vector as a float vector\n        // This performs a bit-for-bit copy, not a numerical conversion.\n        svfloat32_t f32_vec = svreinterpret_f32_u32(u32_vec);\n\n        // Store the resulting float vector into array B\n        svst1_f32(pg, B + i, f32_vec);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < size) {\n        // Get a predicate for the current vector length.\n        // svwhilelt_b32(i, size) generates a predicate that is true for\n        // elements from 'i' up to 'size - 1', effectively handling\n        // full vectors and the tail elements.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t from array A using the predicate.\n        // Elements for which the predicate is false will not be loaded\n        // (or will be loaded as zeros, depending on the specific intrinsic behavior,\n        // but for svld1, it means only active lanes are accessed).\n        svuint32_t vec_u32 = svld1_u32(pg, &A[i]);\n\n        // Reinterpret the bit pattern of the uint32_t vector as a float vector.\n        // This intrinsic performs the type-punning directly at the bit level.\n        svfloat32_t vec_f32 = svreinterpret_f32_u32(vec_u32);\n\n        // Store the resulting float vector into array B using the same predicate.\n        // Only active lanes (where predicate is true) will be written to memory.\n        svst1_f32(pg, &B[i], vec_f32);\n\n        // Increment the index 'i' by the number of elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    // Loop while there are still elements to process\n    while (i < size) {\n        // Generate a predicate for the current vector chunk.\n        // svwhilelt_b32 generates a predicate where lanes are active\n        // as long as the current index 'i' is less than 'size'.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t values from array A using the predicate.\n        // Only active lanes will load data.\n        svuint32_t vec_u32 = svld1_u32(pg, A + i);\n\n        // Reinterpret the bit pattern of the uint32_t vector as a float vector.\n        // This intrinsic performs a bit-for-bit copy without numerical conversion.\n        svfloat32_t vec_f32 = svreinterpret_f32_u32(vec_u32);\n\n        // Store the resulting float vector into array B using the predicate.\n        // Only active lanes will store data.\n        svst1_f32(pg, B + i, vec_f32);\n\n        // Increment the index 'i' by the number of 32-bit elements (words)\n        // processed in the current vector. svcntw() returns the number of\n        // 32-bit elements that fit in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while the predicate is true (i.e., there are still elements to process)\n    // svwhilelt_b32 generates a predicate for 32-bit elements\n    // that is true for elements where the current index 'i' is less than 'size'.\n    for (i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t from array A using the predicate.\n        // Elements for which the predicate is false will not be loaded (or will be zero/unmodified depending on context, but here it's a masked load).\n        svuint32_t vec_u32 = svld1_u32(pg, A + i);\n\n        // Reinterpret the bit pattern of the uint32_t vector as a float vector.\n        // This intrinsic performs a bit-level reinterpretation without any numerical conversion.\n        svfloat32_t vec_f32 = svreinterpret_f32_u32(vec_u32);\n\n        // Store the resulting float vector into array B using the same predicate.\n        // Elements for which the predicate is false will not be written.\n        svst1_f32(pg, B + i, vec_f32);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop while there are elements remaining to process\n    while (i < size) {\n        // Create a predicate for the current vector length.\n        // This predicate ensures that operations only apply to valid elements\n        // within the array bounds, handling the tail of the array.\n        pg = svwhilelt_b32(i, size);\n\n        // Load a vector of uint32_t values from array A using the predicate.\n        // Only active lanes (where pg is true) will load data.\n        svuint32_t vec_u32 = svld1_u32(pg, A + i);\n\n        // Reinterpret the bit pattern of the uint32_t vector as a float vector.\n        // This intrinsic performs a bit-for-bit copy without numerical conversion.\n        svfloat32_t vec_f32 = svreinterpret_f32_u32(vec_u32);\n\n        // Store the resulting float vector into array B using the predicate.\n        // Only active lanes will store data.\n        svst1_f32(pg, B + i, vec_f32);\n\n        // Increment the loop counter by the number of 32-bit elements\n        // processed in the current SVE vector. svcntw() returns the\n        // number of 32-bit elements (words) in an SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int32_t, uint8_t\n#include <stdbool.h> // For bool\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Handle the first element: diff[0] is always 0.0f\n    if (size == 0) {\n        return;\n    }\n    diff[0] = 0.0f;\n\n    // Start processing from index 1\n    size_t i = 1;\n\n    // Loop while there are active elements to process\n    // svwhilelt_b32 generates a predicate for 32-bit elements (int32_t, float)\n    // that are less than 'size'.\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // 1. Load A[i]...A[i+VL-1]\n        svint32_t current_A = svld1_s32(pg, &A[i]);\n\n        // 2. Load A[i-1]...A[i+VL-2]\n        // The predicate `pg` ensures that we only load for active lanes.\n        // For the first iteration (i=1), this will correctly load A[0], A[1], ...\n        svint32_t prev_A = svld1_s32(pg, &A[i - 1]);\n\n        // 3. Compute the difference: (A[i] - A[i-1])\n        svint32_t diff_int = svsub_s32_x(pg, current_A, prev_A);\n\n        // 4. Convert the integer difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // 5. Load the boolean condition array elements\n        // The `cond` array contains `bool` (typically 1 byte).\n        // We need to load these bytes and convert them into a 32-bit predicate.\n        // First, create an 8-bit predicate from the 32-bit predicate `pg`.\n        svbool_t pg_8bit = svreinterpret_b8_b32(pg);\n        svuint8_t cond_bytes = svld1_u8(pg_8bit, (const uint8_t*)&cond[i]);\n\n        // Convert the loaded 8-bit boolean values to 32-bit integers.\n        // This conversion needs a 32-bit predicate. `pg` is suitable.\n        svint32_t cond_int32 = svcvt_s32_u8(pg, cond_bytes);\n\n        // Create a predicate for conditional selection: true if cond_int32 is non-zero.\n        // This predicate will be true for lanes where cond[i] is true.\n        svbool_t cond_true_predicate = svcmpne_n_s32(pg, cond_int32, 0);\n\n        // 6. Apply the condition:\n        // If cond[i] is true (cond_true_predicate is true), use diff_float.\n        // If cond[i] is false (cond_true_predicate is false), use 0.0f.\n        svfloat32_t result_vec = svsel_f32(cond_true_predicate, diff_float, svdup_n_f32(0.0f));\n\n        // 7. Store the result into the destination array `diff`\n        svst1_f32(pg, &diff[i], result_vec);\n\n        // Move to the next vector chunk\n        i += svcntw(); // Increment by the number of 32-bit elements in a vector\n        pg = svwhilelt_b32(i, size); // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Handle the first element: diff[0] is always 0.0f.\n    // If size is 0, there's nothing to do.\n    if (size == 0) {\n        return;\n    }\n    diff[0] = 0.0f;\n\n    // Get the number of 32-bit elements (words) that fit in an SVE vector.\n    size_t sv_len = svcntw();\n\n    // Loop through the arrays starting from the second element (index 1).\n    // The first element diff[0] is handled separately.\n    for (size_t i = 1; i < size; i += sv_len) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the 'size' boundary.\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load current elements A[i] into an SVE vector.\n        svint32_t A_curr = svld1_s32(pg, &A[i]);\n\n        // Load previous elements A[i-1] into an SVE vector.\n        // Note: The base address for loading A_prev is A[i-1].\n        // Since 'i' starts from 1, 'i-1' will always be non-negative.\n        svint32_t A_prev = svld1_s32(pg, &A[i-1]);\n\n        // Load boolean conditions cond[i] into an SVE boolean vector.\n        // svld1_b loads bytes, which is suitable for 'bool' type.\n        svbool_t cond_vec = svld1_b(pg, (const uint8_t*)&cond[i]);\n\n        // Compute the difference (A[i] - A[i-1]) for active lanes.\n        // The '_x' suffix means inactive lanes are unchanged, which is fine\n        // as we will use svsel later to pick the final value.\n        svint32_t diff_int = svsub_s32_x(pg, A_curr, A_prev);\n\n        // Convert the integer difference to a floating-point difference for active lanes.\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Create a combined predicate:\n        // This predicate is true only if the lane is within bounds (pg) AND\n        // the corresponding condition cond[i] is true (cond_vec).\n        svbool_t active_cond_pg = svand_b(pg, cond_vec);\n\n        // Select the final value for each lane in the result vector:\n        // - If active_cond_pg is true, use the calculated diff_float.\n        // - Otherwise (if cond[i] is false or out of bounds), use 0.0f.\n        svfloat32_t result_vec = svsel_f32(active_cond_pg, diff_float, svdup_f32(0.0f));\n\n        // Store the result vector into the destination array diff.\n        // The 'pg' predicate ensures that only valid elements within 'size' are written.\n        svst1_f32(pg, &diff[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    // The first element (diff[0]) is always set to 0.0f as there's no previous element\n    diff[0] = 0.0f;\n\n    // Start processing from the second element (index 1)\n    size_t i = 1;\n    while (i < size) {\n        // Get the predicate for the current vector chunk\n        // This predicate determines which lanes are active based on remaining elements\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Get the number of 32-bit elements in an SVE vector\n        size_t svcnt = svcnt_b32();\n\n        // Load current A values (A[i], A[i+1], ...)\n        svint32_t current_A_vec = svld1_s32(pg, &A[i]);\n\n        // Load previous A values (A[i-1], A[i], ...)\n        // This provides the A[k-1] for each A[k] in the current_A_vec\n        svint32_t prev_A_vec = svld1_s32(pg, &A[i-1]);\n\n        // Load boolean condition values (cond[i], cond[i+1], ...) into a predicate register\n        svbool_t cond_vec = svld1_b(pg, &cond[i]);\n\n        // Compute the difference: A[k] - A[k-1] for active lanes\n        // The _x suffix indicates that the operation is unpredicated,\n        // meaning it operates on all lanes determined by 'pg'.\n        svint32_t diff_int_vec = svsub_s32_x(pg, current_A_vec, prev_A_vec);\n\n        // Convert the integer difference to float for active lanes\n        svfloat32_t diff_float_vec = svcvt_f32_s32_x(pg, diff_int_vec);\n\n        // Create a vector of 0.0f to use when the condition is false\n        svfloat32_t zero_f_vec = svdup_f32(0.0f);\n\n        // Select the final result for each lane:\n        // If cond_vec lane is true, use diff_float_vec lane.\n        // If cond_vec lane is false, use zero_f_vec lane (0.0f).\n        svfloat32_t result_vec = svsel_f32(cond_vec, diff_float_vec, zero_f_vec);\n\n        // Store the computed results into the destination array 'diff'\n        svst1_f32(pg, &diff[i], result_vec);\n\n        // Advance the loop counter by the number of elements processed in this vector\n        i += svcnt;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    // Handle the first element: diff[0] is always 0.0f as there's no previous element.\n    diff[0] = 0.0f;\n\n    // Start processing from the second element (index 1).\n    size_t i = 1;\n\n    // Loop through the arrays using SVE vector operations.\n    while (i < size) {\n        // Create a predicate for the current vector chunk for 32-bit elements (int32_t, float).\n        // This predicate ensures that operations only apply to valid elements within the array bounds.\n        svbool_t pg_32bit = svwhilelt_b32(i, size);\n\n        // Load current elements A[i] into an SVE vector.\n        svint32_t current_A_vec = svld1_s32(pg_32bit, &A[i]);\n\n        // Load previous elements A[i-1] into an SVE vector.\n        svint32_t prev_A_vec = svld1_s32(pg_32bit, &A[i - 1]);\n\n        // Create a predicate for the current vector chunk for 8-bit elements (bool).\n        svbool_t pg_8bit = svwhilelt_b8(i, size);\n\n        // Load the boolean condition values as uint8_t into an SVE vector.\n        svuint8_t loaded_cond_bytes = svld1_u8(pg_8bit, &cond[i]);\n\n        // Create a byte-level predicate where cond[i] is true (non-zero).\n        // This predicate will be true for lanes where the corresponding cond byte is not zero.\n        svbool_t cond_mask_8bit = svcmpne_n_u8(pg_8bit, loaded_cond_bytes, 0);\n\n        // Convert the byte-level predicate to a 32-bit element predicate.\n        // This predicate will be used to conditionally select results for 32-bit float elements.\n        svbool_t cond_mask_32bit = svcvt_b_b32(cond_mask_8bit);\n\n        // Calculate the difference: A[i] - A[i-1].\n        svint32_t diff_int_vec = svsub_s32(pg_32bit, current_A_vec, prev_A_vec);\n\n        // Convert the integer difference to float.\n        svfloat32_t diff_float_vec = svcvt_f32_s32(pg_32bit, diff_int_vec);\n\n        // Create a vector of 0.0f for elements where cond[i] is false.\n        svfloat32_t zero_f32 = svdup_n_f32(0.0f);\n\n        // Select the final result for each lane:\n        // If cond_mask_32bit is true, use the calculated diff_float_vec.\n        // If cond_mask_32bit is false, use 0.0f.\n        svfloat32_t result_vec = svsel_f32(cond_mask_32bit, diff_float_vec, zero_f32);\n\n        // Store the computed results into the destination array diff[i].\n        svst1_f32(pg_32bit, &diff[i], result_vec);\n\n        // Advance the loop counter by the number of 32-bit elements processed in this iteration.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h> // For int32_t\n#include <stdbool.h> // For bool\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n\n    // Handle the first element: diff[0] is always 0.0f as there's no previous element.\n    diff[0] = 0.0f;\n\n    if (size == 1) {\n        return;\n    }\n\n    size_t i = 1; // Start processing from the second element (index 1)\n\n    // Duplicate 0.0f into a vector once, to be used for elements where condition is false.\n    svfloat32_t zero_f32 = svdup_f32(0.0f);\n\n    // Loop while 'i' is less than 'size'.\n    // svwhilelt_b32 generates a predicate for 32-bit elements (int32_t, float).\n    // svwhilelt_b8 generates a predicate for 8-bit elements (bool/uint8_t).\n    do {\n        // Predicate for 32-bit element operations (e.g., int32_t, float)\n        svbool_t pg_32bit = svwhilelt_b32(i, size);\n        // Predicate for 8-bit element operations (e.g., bool/uint8_t)\n        svbool_t pg_8bit = svwhilelt_b8(i, size);\n\n        // Load current A values: A[i], A[i+1], ...\n        svint32_t current_A_vec = svld1_s32(pg_32bit, A + i);\n\n        // Load previous A values: A[i-1], A[i], ...\n        // This allows computing A[k] - A[k-1] for each lane k.\n        svint32_t prev_A_vec = svld1_s32(pg_32bit, A + i - 1);\n\n        // Load condition values. Assuming 'bool' is stored as 1 byte (e.g., 0 for false, 1 for true).\n        svuint8_t cond_u8 = svld1_u8(pg_8bit, (const uint8_t*)cond + i);\n        \n        // Create a predicate from the condition array: true if the corresponding cond_u8 value is non-zero.\n        // This predicate (cond_mask_32bit) will be used to control operations on 32-bit lanes.\n        // SVE automatically maps the 8-bit predicate (from svcmpne_u8) to 32-bit lanes for svsel_f32.\n        svbool_t cond_mask_32bit = svcmpne_u8(pg_8bit, cond_u8, 0);\n\n        // Compute the difference: (A[k] - A[k-1]) for each active lane k.\n        // The _x suffix indicates that the operation is predicated by pg_32bit.\n        svint32_t diff_int = svsub_s32_x(pg_32bit, current_A_vec, prev_A_vec);\n\n        // Convert the integer difference to float.\n        // The _x suffix indicates that the operation is predicated by pg_32bit.\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg_32bit, diff_int);\n\n        // Select the final result for each lane:\n        // If cond_mask_32bit is true for a lane, use the computed diff_float.\n        // If cond_mask_32bit is false, use 0.0f (from zero_f32).\n        // The pg_32bit predicate implicitly governs which lanes are written to result_vec.\n        svfloat32_t result_vec = svsel_f32(cond_mask_32bit, diff_float, zero_f32);\n\n        // Store the results into the destination array 'diff'.\n        // Only active lanes (governed by pg_32bit) are written to memory.\n        svst1_f32(pg_32bit, diff + i, result_vec);\n\n        // Increment the loop counter by the number of 32-bit elements processed in this iteration.\n        i += svcntw(); \n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": ""}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    // Get the number of 32-bit and 64-bit elements per SVE vector.\n    // svcntw() returns the number of 32-bit elements (VL/4).\n    // svcntd() returns the number of 64-bit elements (VL/8).\n    // Note that svcntw() is always 2 * svcntd().\n    const size_t svcntw_val = svcntw();\n    const size_t svcntd_val = svcntd();\n\n    // Create a vector with all elements set to 0xFFFFFFFF00000000ULL.\n    // This mask will be ORed with the zero-extended 32-bit values.\n    const svuint64_t v_high_mask_u64 = svdup_u64(0xFFFFFFFF00000000ULL);\n\n    // Loop through the arrays in chunks of svcntw_val (number of 32-bit elements).\n    // Each iteration processes svcntw_val uint32_t elements from src\n    // and produces svcntw_val uint64_t elements for dst.\n    for (i = 0; i < length; i += svcntw_val) {\n        // 1. Generate a predicate for loading svcntw_val uint32_t elements.\n        // This predicate handles the tail end of the array where 'length' is not a multiple of svcntw_val.\n        svbool_t pg_u32 = svwhilelt_b32(i, length);\n\n        // 2. Load two interleaved vectors of uint32_t elements from src.\n        // svld2_u32 loads elements such that:\n        // v_src_u32_even gets src[i], src[i+2], src[i+4], ...\n        // v_src_u32_odd  gets src[i+1], src[i+3], src[i+5], ...\n        // Each of these vectors will contain svcntd_val elements.\n        svuint32x2_t v_src_tuple = svld2_u32(pg_u32, src + i);\n        svuint32_t v_src_u32_even = svget_vnum_u32(v_src_tuple, 0);\n        svuint32_t v_src_u32_odd = svget_vnum_u32(v_src_tuple, 1);\n\n        // 3. Convert (zero-extend) the 32-bit elements to 64-bit elements.\n        // svcvt_u64_u32 converts each element of the input svuint32_t vector\n        // to a 64-bit unsigned integer, producing a svuint64_t vector.\n        svuint64_t v_dst_u64_even = svcvt_u64_u32(v_src_u32_even);\n        svuint64_t v_dst_u64_odd = svcvt_u64_u32(v_src_u32_odd);\n\n        // 4. Set the high 32 bits of each 64-bit value to 1 (0xFFFFFFFF).\n        // This is achieved by ORing with the pre-computed mask.\n        v_dst_u64_even = svorr_u64(v_dst_u64_even, v_high_mask_u64);\n        v_dst_u64_odd = svorr_u64(v_dst_u64_odd, v_high_mask_u64);\n\n        // 5. Re-interleave the even and odd results to restore the original order.\n        // svzip1_u64 combines elements from v_dst_u64_even and v_dst_u64_odd into the first half of the output.\n        // svzip2_u64 combines elements into the second half.\n        // Example: if even = [E0, E1, E2, E3] and odd = [O0, O1, O2, O3]\n        // v_res_0 will be [E0, O0, E1, O1]\n        // v_res_1 will be [E2, O2, E3, O3]\n        svuint64_t v_res_0 = svzip1_u64(v_dst_u64_even, v_dst_u64_odd);\n        svuint64_t v_res_1 = svzip2_u64(v_dst_u64_even, v_dst_u64_odd);\n\n        // 6. Store the results to the destination array.\n        // Generate predicates for storing the two svuint64_t vectors.\n        // pg_u64_0 covers the first svcntd_val elements.\n        // pg_u64_1 covers the next svcntd_val elements.\n        svbool_t pg_u64_0 = svwhilelt_b64(i, length);\n        svst1_u64(pg_u64_0, dst + i, v_res_0);\n\n        svbool_t pg_u64_1 = svwhilelt_b64(i + svcntd_val, length);\n        svst1_u64(pg_u64_1, dst + i + svcntd_val, v_res_1);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    // Loop through the arrays in chunks determined by the SVE vector length\n    while (i < length) {\n        // Generate a predicate for 32-bit elements, active for elements up to 'length'\n        svbool_t pg_32 = svwhilelt_b32(i, length);\n        // Generate a predicate for 64-bit elements, active for elements up to 'length'\n        // This predicate will have the same number of active elements as pg_32\n        svbool_t pg_64 = svwhilelt_b64(i, length);\n\n        // Load a vector of uint32_t elements from the source array\n        svuint32_t src_vec = svld1_u32(pg_32, src + i);\n\n        // Convert (widen) the uint32_t vector to a uint64_t vector.\n        // This operation performs zero-extension, so the high 32 bits will be 0.\n        svuint64_t dst_vec_zero_extended = svcvt_u64_u32(pg_32, src_vec);\n\n        // Create a constant uint64_t vector where the high 32 bits are all 1s (0xFFFFFFFF)\n        // and the low 32 bits are all 0s.\n        svuint64_t high_bits_mask = svdup_u64(0xFFFFFFFF00000000ULL);\n\n        // Perform a bitwise OR operation to set the high 32 bits of each uint64_t element to 1.\n        // The predicate pg_64 ensures that only active lanes are modified.\n        svuint64_t result_vec = svorr_u64(pg_64, dst_vec_zero_extended, high_bits_mask);\n\n        // Store the resulting uint64_t vector to the destination array.\n        // The predicate pg_64 ensures that only active lanes are stored.\n        svst1_u64(pg_64, dst + i, result_vec);\n\n        // Advance the loop counter by the number of 32-bit elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements in a full SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Define the constant mask for setting the high 32 bits to 1.\n    // This value is 0xFFFFFFFF00000000ULL.\n    svuint64_t high_bits_mask = svdup_u64(0xFFFFFFFF00000000ULL);\n\n    while (i < length) {\n        // Get a predicate for the current chunk of 32-bit elements.\n        // This predicate will be active for `svcntw()` elements or fewer if at the end of the array.\n        svbool_t pg_32 = svwhilelt_b32(i, length);\n\n        // Load 32-bit unsigned integers from the source array.\n        // The number of elements loaded is determined by the active lanes in `pg_32`.\n        svuint32_t src_vec = svld1_u32(pg_32, src + i);\n\n        // Widen the 32-bit elements to 64-bit.\n        // SVE does not have a direct `svcvt_u64_u32` intrinsic.\n        // We achieve this by splitting the `svuint32_t` vector into two `svuint32_t` vectors\n        // containing the even and odd indexed elements, respectively.\n        // Then, we cast these 32-bit vectors to 64-bit vectors, which performs zero-extension.\n        svuint32_t src_vec_lo = svuzp1_u32(src_vec, src_vec); // Contains elements at even indices (0, 2, 4, ...)\n        svuint32_t src_vec_hi = svuzp2_u32(src_vec, src_vec); // Contains elements at odd indices (1, 3, 5, ...)\n\n        // Zero-extend the 32-bit values to 64-bit.\n        svuint64_t dst_vec_0 = svmov_u64(src_vec_lo);\n        svuint64_t dst_vec_1 = svmov_u64(src_vec_hi);\n\n        // Generate 64-bit predicates from the 32-bit predicate.\n        // These predicates correspond to the active lanes for the `dst_vec_0` (even indices)\n        // and `dst_vec_1` (odd indices) after the unzipping operation.\n        svbool_t pg_64_lo = svuzp1_b32(pg_32, pg_32);\n        svbool_t pg_64_hi = svuzp2_b32(pg_32, pg_32);\n\n        // Set the high 32 bits of each widened 64-bit value to 1 using a bitwise OR operation.\n        // This operation is performed conditionally based on the respective 64-bit predicates.\n        svuint64_t result_vec_0 = svorr_u64(pg_64_lo, dst_vec_0, high_bits_mask);\n        svuint64_t result_vec_1 = svorr_u64(pg_64_hi, dst_vec_1, high_bits_mask);\n\n        // Store the results back to the destination array.\n        // `result_vec_0` contains the processed elements that originated from even indices in `src`.\n        // `result_vec_1` contains the processed elements that originated from odd indices in `src`.\n        // We store them back to their respective interleaved positions in `dst`.\n        svst1_u64(pg_64_lo, dst + i, result_vec_0);\n        svst1_u64(pg_64_hi, dst + i + 1, result_vec_1);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        // `svcntw()` returns the number of 32-bit elements in a full SVE vector.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (src);\n- A pointer to a non-empty 64-bit unsigned integer (uint64_t) destination array (dst);\n- The common length of the arrays (length).\n\nYour goal is to:\n1. Convert each element in src to a 64-bit unsigned integer;\n2. Set all the high 32 bits of each value to 1 and store the results in dst.\n\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    // Create a vector with the constant 0xFFFFFFFF00000000ULL.\n    // This value has the lower 32 bits as 0 and the upper 32 bits as 1s.\n    svuint64_t high_bits_mask = svdup_u64(0xFFFFFFFF00000000ULL);\n\n    while (i < length) {\n        // Get a predicate for the current vector chunk.\n        // svwhilelt_b32 generates a predicate for 32-bit elements,\n        // active for elements where 'i + element_index < length'.\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load a vector of uint32_t elements from the source array.\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n\n        // Convert (widen) the uint32_t vector to a uint64_t vector.\n        // This operation performs zero-extension, so the high 32 bits of each\n        // uint64_t element will be zero after this step.\n        svuint64_t widened_vec = svcvt_u64_u32(pg, src_vec);\n\n        // Set the high 32 bits of each uint64_t element to 1.\n        // This is done by performing a bitwise OR with the high_bits_mask.\n        // Since widened_vec has its high 32 bits as 0, ORing with 0xFFFFFFFF00000000ULL\n        // will effectively set those bits to 1 without affecting the lower 32 bits.\n        svuint64_t result_vec = svorr_u64(pg, widened_vec, high_bits_mask);\n\n        // Store the resulting uint64_t vector to the destination array.\n        svst1_u64(pg, dst + i, result_vec);\n\n        // Increment the loop counter by the number of elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements in a full SVE vector.\n        // This is equivalent to the number of 64-bit elements processed since\n        // we are converting one 32-bit element to one 64-bit element.\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int16_t\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double total_sum = 0.0;\n    // Initialize a vector accumulator for partial sums.\n    // All elements are initialized to 0.0.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    // Get the number of 16-bit integer elements (words) that fit into an SVE vector.\n    // This determines the loop's step size for iterating through the index array.\n    const size_t svl_w = svcntw();\n\n    // Loop through the index array in chunks of 'svl_w' elements.\n    // 'i' tracks the current starting index in the 'index' array.\n    for (size_t i = 0; i < length; i += svl_w) {\n        // 1. Create a predicate for the current vector chunk.\n        // This predicate is true for elements within the array bounds [i, length).\n        // It handles the \"tail\" case where the remaining elements are less than svl_w.\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        // 2. Load a vector of int16_t indices from the 'index' array.\n        // Only elements enabled by 'pg' are loaded.\n        svint16_t current_indices_16 = svld1(pg, index + i);\n\n        // 3. Convert the 16-bit indices to 64-bit integers.\n        // SVE gather instructions for double-precision floats typically require 64-bit indices.\n        svint64_t element_indices_64 = svcvt_s64_s16(pg, current_indices_16);\n\n        // 4. Validate indices: Ensure each index is within the legal range [0, length).\n        // Create a mask for indices >= 0.\n        svbool_t valid_lower_bound = svcmpge(pg, element_indices_64, svdup_s64(0));\n        // Create a mask for indices < length.\n        svbool_t valid_upper_bound = svcmplt(pg, element_indices_64, svdup_s64(length));\n\n        // Combine all predicates:\n        // - 'pg' ensures we only process elements within the current loop chunk.\n        // - 'valid_lower_bound' and 'valid_upper_bound' ensure the index is within [0, length).\n        svbool_t active_mask = svand_b(valid_lower_bound, valid_upper_bound);\n        active_mask = svand_b(pg, active_mask);\n\n        // 5. Gather double values from the 'vec' array using the validated indices.\n        // Only elements corresponding to 'active_mask' are loaded.\n        // Inactive lanes in 'gathered_values' will be set to 0.0.\n        svfloat64_t gathered_values = svld1_gather_s64index_f64(active_mask, vec, element_indices_64);\n\n        // 6. Accumulate the gathered values into the vector sum.\n        // The '_m' suffix indicates a masked operation:\n        // sum_vec[lane] = active_mask[lane] ? (sum_vec[lane] + gathered_values[lane]) : sum_vec[lane];\n        // This ensures that only values from valid indices contribute to the sum.\n        sum_vec = svadd_f64_m(sum_vec, active_mask, sum_vec, gathered_values);\n    }\n\n    // 7. Reduce the final vector sum (sum_vec) into a single scalar double.\n    // svptrue_b64() creates a predicate where all lanes are active for the reduction.\n    total_sum += svaddv_f64(svptrue_b64(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n#include <stdint.h> // For int16_t\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double total_sum = 0.0;\n    size_t i = 0;\n\n    // Get the SVE predicate for 16-bit elements (int16_t indices)\n    // This predicate will control which lanes are active based on the remaining length.\n    svbool_t pg_w = svwhilelt_b16(i, length);\n\n    // Initialize a zero vector for 16-bit integers, used for zero-extension\n    // of int16_t to int32_t. Indices are guaranteed to be non-negative.\n    svint16_t zero_16 = svdup_n_s16(0);\n\n    // Loop while there are active elements in the predicate\n    while (svptest_any(svptrue_b16(), pg_w)) {\n        // 1. Load a vector of int16_t indices from the 'index' array.\n        // The predicate 'pg_w' ensures that only valid elements within 'length' are loaded.\n        svint16_t current_indices_16 = svld1(pg_w, index + i);\n\n        // 2. Widen int16_t indices to int32_t.\n        // Since SVE does not have a direct svcvt_s32_s16, we use a common pattern:\n        // - Interleave the int16_t vector with a zero vector using svzip1 and svzip2.\n        //   svzip1(a, b) produces (a[0], b[0], a[1], b[1], ...)\n        //   svzip2(a, b) produces (a[VL/2], b[VL/2], a[VL/2+1], b[VL/2+1], ...)\n        // - Reinterpret the resulting svint16_t vectors as svint32_t.\n        //   This effectively zero-extends each int16_t element into an int32_t element.\n        //   For example, (v16[0], 0) as svint16_t becomes (v16[0] | (0 << 16)) as svint32_t.\n        svint32_t indices_32_lo = svreinterpret_s32_s16(svzip1(current_indices_16, zero_16));\n        svint32_t indices_32_hi = svreinterpret_s32_s16(svzip2(current_indices_16, zero_16));\n\n        // 3. Widen int32_t indices to int64_t.\n        // SVE provides direct intrinsics for this conversion.\n        svint64_t indices_64_lo = svcvt_s64_s32(indices_32_lo);\n        svint64_t indices_64_hi = svcvt_s64_s32(indices_32_hi);\n\n        // 4. Split the 16-bit predicate (pg_w) into two 64-bit predicates.\n        // This is necessary because widening from int16_t to int64_t effectively\n        // doubles the number of logical elements per SVE vector register (e.g., if svcntw=8, svcntd=2,\n        // then 8 int16_t elements become 8 int64_t elements, which requires 4 svint64_t vectors,\n        // but our widening produces 2 svint64_t vectors from 1 svint16_t vector).\n        // svuzp1_b64 and svuzp2_b64 operate on b64 predicates.\n        // svreinterpret_b64_b16 converts the b16 predicate to a b64 predicate for splitting.\n        svbool_t pg_w_b64 = svreinterpret_b64_b16(pg_w);\n        svbool_t pg_d_lo = svuzp1_b64(pg_w_b64, pg_w_b64); // Predicate for the first half of int64_t indices\n        svbool_t pg_d_hi = svuzp2_b64(pg_w_b64, pg_w_b64); // Predicate for the second half of int64_t indices\n\n        // 5. Gather elements from 'vec' using the widened indices.\n        // svld1_gather_index_f64 loads double-precision floating-point values\n        // using a vector of 64-bit integer indices.\n        svfloat64_t gathered_elements_lo = svld1_gather_index_f64(pg_d_lo, vec, indices_64_lo);\n        svfloat64_t gathered_elements_hi = svld1_gather_index_f64(pg_d_hi, vec, indices_64_hi);\n\n        // 6. Horizontally sum the gathered elements and accumulate to total_sum.\n        // svaddv_f64 performs a horizontal sum of active elements in a float64 vector.\n        total_sum += svaddv_f64(pg_d_lo, gathered_elements_lo);\n        total_sum += svaddv_f64(pg_d_hi, gathered_elements_hi);\n\n        // Move to the next chunk of indices.\n        // svcntw() returns the number of 16-bit elements in an SVE vector.\n        i += svcntw();\n        // Update the predicate for the next iteration.\n        pg_w = svwhilelt_b16(i, length);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double total_sum = 0.0;\n    size_t i = 0;\n\n    for (i = 0; i < length; ) {\n        // Create a predicate for the current SVE vector chunk of int16_t indices.\n        // This predicate handles the tail end of the 'index' array.\n        svbool_t pg_loop = svwhilelt_b16(i, length);\n\n        // If no elements are active in this chunk, break the loop.\n        if (svptest_n(svptrue_b16(), pg_loop)) {\n            break;\n        }\n\n        // Load int16_t indices from the 'index' array using the loop predicate.\n        svint16_t current_indices_s16 = svld1_s16(pg_loop, index + i);\n\n        // Widen the int16_t indices to int64_t.\n        // This is necessary for gather instructions which typically use 64-bit offsets.\n        svint64_t current_indices_s64 = svcvt_s64_s16(pg_loop, current_indices_s16);\n\n        // Create predicates to check if the widened indices are within the valid range [0, length).\n        svbool_t pg_ge_zero = svcmpge_s64(pg_loop, current_indices_s64, 0);\n        svbool_t pg_lt_length = svcmplt_s64(pg_loop, current_indices_s64, (int64_t)length);\n\n        // Combine the loop predicate with the index validity predicates.\n        // This final predicate 'pg_gather' ensures only valid, in-range elements\n        // within the current processing chunk are considered for gathering and summing.\n        svbool_t pg_gather = svand_b(pg_ge_zero, pg_lt_length);\n        pg_gather = svand_b(pg_loop, pg_gather);\n\n        // Gather double elements from 'vec' using the validated 64-bit indices as offsets.\n        svfloat64_t gathered_elements = svld1_gather_s64offset_f64(pg_gather, vec, current_indices_s64);\n\n        // Horizontally sum the gathered double elements that are active according to 'pg_gather'.\n        total_sum += svaddv_f64(pg_gather, gathered_elements);\n\n        // Increment the loop counter by the number of 16-bit elements processed in this iteration.\n        i += svcntw();\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c++\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double total_sum = 0.0;\n\n    // Get the number of int16_t elements that fit in an SVE vector.\n    // This determines the loop step size for the index array.\n    size_t svl_s16 = svcntw();\n\n    // Loop through the index array in chunks of svl_s16 elements.\n    // The loop continues as long as there are elements remaining to process.\n    for (size_t i = 0; i < length; i += svl_s16) {\n        // Create a predicate for the current chunk of int16_t indices.\n        // This predicate ensures we only process valid elements up to 'length'.\n        svbool_t pg_active_s16 = svwhilelt_b16(i, length);\n\n        // If no lanes are active in the predicate, we've processed all elements.\n        if (!svptest_any(svptrue_b16(), pg_active_s16)) {\n            break;\n        }\n\n        // 1. Load a vector of int16_t indices from the 'index' array.\n        svint16_t current_indices_s16 = svld1_s16(pg_active_s16, &index[i]);\n\n        // 2. Convert the int16_t indices to int64_t.\n        // SVE gather loads for double (f64) typically use int64_t offsets.\n        svint64_t current_indices_s64 = svcnv_s64_s16(pg_active_s16, current_indices_s16);\n\n        // 3. Create a predicate for valid indices within the range [0, length).\n        //    a. Check if index[j] >= 0\n        svint64_t zero_s64 = svdup_s64(0);\n        svbool_t pg_ge_zero = svcmpge_s64(pg_active_s16, current_indices_s64, zero_s64);\n\n        //    b. Check if index[j] < length\n        svint64_t length_s64 = svdup_s64((int64_t)length);\n        svbool_t pg_lt_length = svcmplt_s64(pg_active_s16, current_indices_s64, length_s64);\n\n        //    c. Combine the two conditions: (index >= 0) AND (index < length)\n        svbool_t pg_valid_indices = svand_b(pg_ge_zero, pg_lt_length);\n\n        // 4. Perform a gather load: load double values from 'vec' using the valid indices.\n        //    Only elements corresponding to active lanes in 'pg_valid_indices' will be loaded.\n        svfloat64_t gathered_values = svld1_gather_s64index_f64(pg_valid_indices, vec, current_indices_s64);\n\n        // 5. Horizontally sum the gathered values that correspond to valid indices.\n        //    'svsum_f64' sums only the active elements as determined by 'pg_valid_indices'.\n        total_sum += svsum_f64(pg_valid_indices, gathered_values);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <cstddef> // For size_t\n#include <cstdint> // For int16_t\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double total_sum = 0.0;\n    // Initialize an SVE vector register for accumulating partial sums of doubles.\n    svfloat64_t vec_sum = svdup_n_f64(0.0);\n\n    // Get the number of 64-bit elements (doubles) that fit in an SVE vector.\n    // This determines the loop unrolling factor for processing 'vec' elements.\n    const size_t VL_D = svcntd();\n\n    // A temporary array to hold converted and validated int64_t indices.\n    // This is necessary because SVE gather intrinsics for doubles require int64_t offsets,\n    // and direct SVE intrinsics for converting int16_t to int64_t for contiguous data\n    // (without taking only even elements, etc.) are not straightforward or available.\n    int64_t temp_indices[VL_D];\n\n    // Loop through the index array in chunks of VL_D elements.\n    for (size_t i = 0; i < length; i += VL_D) {\n        // Create a predicate for the current vector chunk.\n        // This predicate determines which lanes are active based on the remaining length.\n        // It's a predicate for 64-bit elements, suitable for double operations.\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // If no lanes are active in the current predicate, it means we've processed all elements.\n        if (svptest_n(svptrue_b64(), pg) == 0) {\n            break;\n        }\n\n        // Determine the number of active lanes in the current predicate.\n        // This is used to limit the scalar loop for index conversion and validation.\n        size_t num_active_lanes = svcnt_active_b64(pg);\n\n        // Scalar loop to convert int16_t indices to int64_t offsets and validate them.\n        // This part is scalar due to the complexities of converting int16_t to int64_t\n        // for contiguous data using pure SVE intrinsics, and simultaneously validating.\n        for (size_t k = 0; k < num_active_lanes; ++k) {\n            int16_t current_idx = index[i + k];\n\n            // Validate the index: it must be within the range [0, length).\n            if (current_idx >= 0 && current_idx < length) {\n                // If valid, store the index as an int64_t.\n                temp_indices[k] = current_idx;\n            } else {\n                // If the index is invalid, mark the corresponding lane in the predicate as inactive.\n                // This ensures that the gather operation will not attempt to access an invalid memory location\n                // for this specific lane.\n                pg = svset_b64(pg, k, false);\n                // Store a dummy value; it won't be used because the predicate lane is false.\n                temp_indices[k] = 0;\n            }\n        }\n\n        // Load the validated int64_t indices into an SVE vector.\n        // The predicate `pg` ensures only valid indices are considered.\n        svint64_t offsets = svld1_s64(pg, temp_indices);\n\n        // Convert the indices to byte offsets by multiplying by sizeof(double).\n        // This is required for the gather intrinsic, which takes byte offsets.\n        offsets = svmul_s64(offsets, svdup_n_s64(sizeof(double)));\n\n        // Perform the gather operation: load double values from `vec` at the calculated offsets.\n        // Only active lanes (where `pg` is true) will perform the load; inactive lanes will be zeroed.\n        svfloat64_t gathered_values = svld1_gather_s64offset_f64(pg, vec, offsets);\n\n        // Accumulate the gathered values to the running vector sum.\n        // Since `gathered_values` already has inactive lanes zeroed out by the gather intrinsic,\n        // a simple `svadd_f64` is sufficient.\n        vec_sum = svadd_f64(vec_sum, gathered_values);\n    }\n\n    // Horizontally reduce the SVE vector sum to a single double value.\n    // `svptrue_b64()` creates an all-true predicate for the reduction.\n    total_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size_dim = input_size - kernel_size + 1;\n\n    // If output_size_dim is 0, no output can be generated (e.g., input_size < kernel_size).\n    if (output_size_dim == 0) {\n        return;\n    }\n\n    // Loop over output rows\n    for (size_t r = 0; r < output_size_dim; ++r) {\n        // Loop over output columns, processing multiple columns at a time using SVE\n        // svcntd() returns the number of 64-bit elements (doubles) in an SVE vector.\n        for (size_t c = 0; c < output_size_dim; c += svcntd()) {\n            // Generate a predicate for the current vector chunk.\n            // This handles the tail elements where 'c + svcntd()' might exceed 'output_size_dim'.\n            svbool_t pg = svwhilelt_b64(c, output_size_dim);\n\n            // Initialize an accumulator vector for the current batch of output pixels to 0.0.\n            svfloat64_t acc = svdup_f64(0.0);\n\n            // Loop over kernel rows\n            for (size_t kr = 0; kr < kernel_size; ++kr) {\n                // Calculate the starting pointer for the current input row slice relevant to 'r + kr'.\n                const double* current_input_row_ptr = input + (r + kr) * input_size;\n\n                // Loop over kernel columns\n                for (size_t kc = 0; kc < kernel_size; ++kc) {\n                    // Load the single kernel element for the current (kr, kc) position.\n                    // This value will be broadcasted across all lanes of the vector.\n                    svfloat64_t k_val = svdup_f64(kernel[kr * kernel_size + kc]);\n\n                    // Load the corresponding input elements for the current vector of output pixels.\n                    // For output[r][c+i], the input element is input[(r+kr)*input_size + (c+i+kc)].\n                    // These input elements are contiguous in memory for the current (r+kr) row.\n                    svfloat64_t input_vec = svld1_f64(pg, current_input_row_ptr + c + kc);\n\n                    // Perform multiply-accumulate: acc = acc + (input_vec * k_val).\n                    // This simultaneously updates the partial sums for all output pixels in the vector.\n                    acc = svmla_f64(acc, input_vec, k_val);\n                }\n            }\n\n            // Apply ReLU activation: output = max(0.0, sum).\n            // Create a vector of zeros.\n            svfloat64_t zero_vec = svdup_f64(0.0);\n            // Take the maximum of the accumulated sum and zero for each lane.\n            acc = svmax_f64(acc, zero_vec);\n\n            // Store the computed output pixels to the destination array.\n            // The predicate 'pg' ensures that only valid lanes are written, handling the tail.\n            svst1_f64(pg, output + r * output_size_dim + c, acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    // Calculate the dimensions of the output array\n    size_t output_size_dim = input_size - kernel_size + 1;\n\n    // Iterate over the output rows\n    for (size_t r = 0; r < output_size_dim; ++r) {\n        // Iterate over the output columns, vectorizing this loop using SVE intrinsics\n        // 'c' is incremented by svcntd() (the number of double elements in an SVE vector)\n        for (size_t c = 0; c < output_size_dim; c += svcntd()) {\n            // Generate a predicate for active lanes. This handles the tail end of the loop\n            // where 'c + lane_idx' might exceed 'output_size_dim'.\n            svbool_t pg = svwhilelt_b64(c, output_size_dim);\n\n            // Initialize the accumulator vector for the convolution sum to 0.0\n            svfloat64_t acc_vec = svdup_f64(0.0);\n\n            // Iterate over the kernel rows\n            for (size_t kr = 0; kr < kernel_size; ++kr) {\n                // Iterate over the kernel columns\n                for (size_t kc = 0; kc < kernel_size; ++kc) {\n                    // Get the scalar kernel value for the current kernel element\n                    double k_val = kernel[kr * kernel_size + kc];\n\n                    // Broadcast the scalar kernel value to all lanes of a vector\n                    svfloat64_t k_vec = svdup_f64(k_val);\n\n                    // Calculate the starting address for loading input elements.\n                    // For a given output position (r, c), and kernel position (kr, kc),\n                    // the corresponding input element is at (r + kr, c + kc).\n                    // Since we are vectorizing 'c', we need to load a contiguous block\n                    // of input elements starting from input[(r + kr) * input_size + (c + kc)]\n                    // for the current vector length.\n                    const double* input_ptr = input + (r + kr) * input_size + c + kc;\n\n                    // Load the input vector using the predicate 'pg'. Only active lanes will load data.\n                    svfloat64_t input_vec = svld1_f64(pg, input_ptr);\n\n                    // Perform fused multiply-add: acc_vec += input_vec * k_vec.\n                    // This accumulates the product of input and kernel elements into acc_vec.\n                    acc_vec = svmla_f64(acc_vec, input_vec, k_vec);\n                }\n            }\n\n            // Apply ReLU activation: max(0.0, acc_vec)\n            // Create a vector of zeros\n            svfloat64_t zero_vec = svdup_f64(0.0);\n            // Take the element-wise maximum between the accumulated sum and zero.\n            // This ensures all output values are non-negative.\n            acc_vec = svmax_f64(pg, acc_vec, zero_vec);\n\n            // Store the resulting vector to the output array.\n            // The starting address for storing output elements is output[r * output_size_dim + c].\n            double* output_ptr = output + r * output_size_dim + c;\n            svst1_f64(pg, output_ptr, acc_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <math.h> // Required for fmax\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    // Calculate the size of the output feature map\n    size_t output_size = input_size - kernel_size + 1;\n\n    // Loop over each row of the output feature map\n    for (size_t i = 0; i < output_size; ++i) {\n        // Loop over each column of the output feature map\n        for (size_t j = 0; j < output_size; ++j) {\n            // Initialize an SVE vector accumulator for the current output pixel's sum\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Loop over the rows of the kernel\n            for (size_t k_row = 0; k_row < kernel_size; ++k_row) {\n                // Calculate the starting address for the current row in the input and kernel\n                const double* current_input_row_base = input + (i + k_row) * input_size;\n                const double* current_kernel_row_base = kernel + k_row * kernel_size;\n\n                // Loop over the columns of the kernel with SVE vectorization\n                // k_col is incremented by svcntd() to process multiple elements at once\n                for (size_t k_col = 0; k_col < kernel_size; k_col += svcntd()) {\n                    // Create a predicate vector for active lanes.\n                    // This ensures that only valid elements within the kernel_size are processed,\n                    // handling cases where kernel_size is not a multiple of svcntd().\n                    svbool_t pg = svwhilelt_b64(k_col, kernel_size);\n\n                    // Load a vector of input elements from the current window.\n                    // The input elements are located at (i + k_row) * input_size + (j + k_col).\n                    // 'j' is the column offset for the current output pixel.\n                    svfloat64_t input_val = svld1_f64(pg, current_input_row_base + j + k_col);\n\n                    // Load a vector of kernel elements.\n                    // The kernel elements are located at k_row * kernel_size + k_col.\n                    svfloat64_t kernel_val = svld1_f64(pg, current_kernel_row_base + k_col);\n\n                    // Perform fused multiply-add: sum_vec += input_val * kernel_val\n                    sum_vec = svmla_f64(sum_vec, input_val, kernel_val);\n                }\n            }\n\n            // Reduce the SVE vector sum to a single scalar value.\n            // svptrue_b64() creates a predicate with all lanes active for the reduction.\n            double current_output_val = svaddv_f64(svptrue_b64(), sum_vec);\n\n            // Apply ReLU activation: max(0.0, value)\n            current_output_val = fmax(0.0, current_output_val);\n\n            // Store the computed output value in the flattened output array\n            output[i * output_size + j] = current_output_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stddef.h> // For size_t\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    // Calculate the dimension of the output array (output_dim x output_dim)\n    size_t output_dim = input_size - kernel_size + 1;\n\n    // If output_dim is 0 or less, it means the kernel is larger than the input,\n    // so no valid convolution can be performed.\n    if (output_dim <= 0) {\n        return;\n    }\n\n    // Iterate over each row of the output matrix\n    for (size_t out_row = 0; out_row < output_dim; ++out_row) {\n        // Iterate over columns of the output matrix, processing 'svcntd()' elements at a time\n        // svcntd() returns the number of double elements that fit in an SVE vector.\n        for (size_t out_col = 0; out_col < output_dim; out_col += svcntd()) {\n            // Create a predicate for active lanes. This handles the end of the row\n            // where the number of remaining elements might be less than the full vector length.\n            // Only lanes where out_col + lane_idx < output_dim will be active.\n            svbool_t pg = svwhilelt_b64(out_col, output_dim);\n\n            // Initialize a vector to accumulate the sum for the current batch of output pixels.\n            // All lanes are initialized to 0.0.\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Iterate over each row of the kernel\n            for (size_t k_row = 0; k_row < kernel_size; ++k_row) {\n                // Calculate the base index for the corresponding input row.\n                // This is (output_row_index + kernel_row_index) * input_size.\n                size_t input_row_base_idx = (out_row + k_row) * input_size;\n\n                // Iterate over each column of the kernel\n                for (size_t k_col = 0; k_col < kernel_size; ++k_col) {\n                    // Get the scalar value from the kernel at the current (k_row, k_col) position.\n                    double kernel_val = kernel[k_row * kernel_size + k_col];\n                    // Broadcast the scalar kernel value to all lanes of an SVE vector.\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n\n                    // Calculate the starting column index in the input array for the current batch of output pixels.\n                    // For each lane 'l', the input column will be (out_col + l + k_col).\n                    size_t input_col_start_idx = out_col + k_col;\n\n                    // Load a vector of input values. These values are contiguous in memory,\n                    // starting from input[input_row_base_idx + input_col_start_idx].\n                    // The predicate 'pg' ensures that only active lanes load data.\n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_row_base_idx + input_col_start_idx]);\n\n                    // Perform a fused multiply-add operation: sum_vec = sum_vec + (input_vec * kernel_vec).\n                    // This accumulates the product of input and kernel elements into sum_vec.\n                    sum_vec = svmla_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Apply ReLU activation: max(0.0, sum_vec).\n            // Create a vector of zeros.\n            svfloat64_t zero_vec = svdup_f64(0.0);\n            // Compare each element in sum_vec with 0.0 and take the maximum.\n            // The predicate 'pg' ensures that ReLU is applied only to active lanes.\n            sum_vec = svmax_f64(pg, sum_vec, zero_vec);\n\n            // Store the computed results (after ReLU) into the output array.\n            // The base address for storing is output[out_row * output_dim + out_col].\n            // The predicate 'pg' ensures that data is written only to active lanes.\n            svst1_f64(pg, &output[out_row * output_dim + out_col], sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_rows = input_size - kernel_size + 1;\n    size_t output_cols = input_size - kernel_size + 1;\n\n    // Get the number of double elements per SVE vector\n    size_t sv_len = svcntd();\n\n    // Vector of zeros for ReLU activation (max(0, value))\n    svfloat64_t zero_vec = svdup_f64(0.0);\n\n    // Loop over output rows\n    for (size_t r = 0; r < output_rows; ++r) {\n        // Loop over output columns, vectorizing this loop\n        for (size_t c = 0; c < output_cols; c += sv_len) {\n            // Create a predicate for the current vector chunk.\n            // This predicate will be true for lanes corresponding to valid output columns\n            // within the current vector, and false for lanes beyond output_cols.\n            svbool_t pg = svwhilelt_b64(c, output_cols);\n\n            // Initialize sum vector for the current output vector chunk.\n            // All active lanes start with 0.0.\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            // Loop over kernel rows\n            for (size_t kr = 0; kr < kernel_size; ++kr) {\n                // Loop over kernel columns\n                for (size_t kc = 0; kc < kernel_size; ++kc) {\n                    // Calculate the starting index for the input patch row for the current kernel row\n                    size_t input_row_base_idx = (r + kr) * input_size;\n\n                    // Get the scalar kernel element value\n                    double kernel_val = kernel[kr * kernel_size + kc];\n                    // Duplicate the scalar kernel value into a vector, so it can be multiplied with input vector\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n\n                    // Load input patch elements for the current vector of output columns.\n                    // The elements are contiguous in memory:\n                    // input[input_row_base_idx + c + kc], input[input_row_base_idx + c + 1 + kc], ...\n                    // The load is predicated by 'pg', so only active lanes load valid data.\n                    svfloat64_t input_patch_vec = svld1_f64(pg, &input[input_row_base_idx + c + kc]);\n\n                    // Perform element-wise multiplication of input patch and kernel vector.\n                    // This operation is predicated by 'pg'.\n                    svfloat64_t prod_vec = svmul_f64(pg, input_patch_vec, kernel_vec);\n\n                    // Accumulate the products into sum_vec.\n                    // svadd_f64_m (merge) ensures that for inactive lanes (where pg is false),\n                    // the corresponding element from sum_vec (first operand) is kept unchanged.\n                    // This is crucial for correct accumulation across multiple kernel elements.\n                    sum_vec = svadd_f64_m(sum_vec, pg, prod_vec);\n                }\n            }\n\n            // Apply ReLU activation: max(0, sum_vec).\n            // This operation is predicated by 'pg'.\n            svfloat64_t activated_vec = svmax_f64(pg, sum_vec, zero_vec);\n\n            // Store the result into the output array.\n            // The store operation is predicated by 'pg', ensuring only valid results for active lanes are written.\n            svst1_f64(pg, &output[r * output_cols + c], activated_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // Required for std::abs in general, though SVE intrinsics provide svabs_f64\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n\n    // If there are fewer than 2 elements, no two elements can be closer.\n    if (n < 2) {\n        return false;\n    }\n\n    // If the threshold is non-positive, no two distinct numbers can have an absolute\n    // difference less than it, as absolute differences are always non-negative.\n    if (threshold <= 0.0) {\n        return false;\n    }\n\n    // Duplicate the threshold value into an SVE vector register.\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n\n    // Outer loop: Iterate through each element 'numbers[i]'\n    for (size_t i = 0; i < n; ++i) {\n        // Duplicate the current reference element 'numbers[i]' into an SVE vector.\n        // All lanes of sv_val_i will contain numbers[i].\n        svfloat64_t sv_val_i = svdup_f64(numbers[i]);\n\n        // Inner loop: Compare 'numbers[i]' with 'numbers[j]' for j > i.\n        // This strategy avoids self-comparison (i == j) and redundant comparisons\n        // (e.g., comparing (a,b) and then (b,a)).\n        // The loop increments by svcnt_f64() to process multiple elements in parallel.\n        for (size_t j = i + 1; j < n; j += svcnt_f64()) {\n            // Create a predicate 'pg' that is true for valid elements within the current\n            // SVE vector chunk (i.e., elements whose index is less than 'n').\n            svbool_t pg = svwhilelt_b64(j, n);\n\n            // Load a vector of elements from 'numbers' starting at index 'j',\n            // using 'pg' to mask out elements beyond 'n'.\n            svfloat64_t sv_val_j = svld1_f64(pg, &numbers[j]);\n\n            // Calculate the absolute difference between sv_val_i and sv_val_j for each lane.\n            // diff[k] = |sv_val_i[k] - sv_val_j[k]|\n            svfloat64_t diff = svabs_f64(svsub_f64(sv_val_i, sv_val_j));\n\n            // Compare if the absolute difference is less than the threshold for each lane.\n            // close_mask[k] = (diff[k] < sv_threshold[k])\n            svbool_t close_mask = svcmplt_f64(pg, diff, sv_threshold);\n\n            // Check if any active lane in 'close_mask' is true.\n            // If true, it means we found at least one pair of numbers (numbers[i], numbers[j])\n            // where |numbers[i] - numbers[j]| < threshold.\n            if (svptest_any(pg, close_mask)) {\n                return true; // Found a pair of close elements\n            }\n        }\n    }\n\n    // If the loops complete without returning true, no such pair was found.\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // Not strictly needed for SVE abs, but good practice for general math\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n\n    // If there are fewer than 2 elements, no two elements can be close.\n    if (n < 2) {\n        return false;\n    }\n\n    // Get the number of double elements that fit in an SVE vector.\n    // This value is dynamic and depends on the SVE implementation.\n    size_t sv_vec_len = svcntd();\n\n    // Splat the threshold value across an SVE vector.\n    svfloat64_t sv_threshold = svdup_n_f64(threshold);\n\n    // Outer loop: Iterate through each element 'numbers[i]'\n    for (size_t i = 0; i < n; ++i) {\n        // Splat the current element 'numbers[i]' across an SVE vector.\n        svfloat64_t sv_num_i = svdup_n_f64(numbers[i]);\n\n        // Inner loop: Compare 'numbers[i]' with subsequent elements 'numbers[j]'\n        // Process 'numbers[j]' in chunks of 'sv_vec_len'.\n        for (size_t j = i + 1; j < n; j += sv_vec_len) {\n            // Create a predicate for the current chunk of elements.\n            // This predicate ensures we only process valid elements up to 'n-1'\n            // and handles partial vectors at the end of the array.\n            svbool_t current_pg = svwhilelt_b64(j, n);\n\n            // Load a chunk of 'numbers' starting from 'numbers[j]' into an SVE vector.\n            // Only lanes active according to 'current_pg' will be loaded.\n            svfloat64_t sv_chunk_j = svld1_f64(current_pg, &numbers[j]);\n\n            // Calculate the absolute difference between sv_num_i and sv_chunk_j.\n            // svsub_f64 performs element-wise subtraction.\n            // svabs_f64 performs element-wise absolute value.\n            svfloat64_t sv_diff = svsub_f64(sv_num_i, sv_chunk_j);\n            svfloat64_t sv_abs_diff = svabs_f64(sv_diff);\n\n            // Compare the absolute differences with the threshold.\n            // svcmplt_f64 returns a predicate where lanes are true if abs_diff < threshold.\n            // The comparison is only performed for lanes active according to 'current_pg'.\n            svbool_t sv_cmp_result = svcmplt_f64(current_pg, sv_abs_diff, sv_threshold);\n\n            // Check if any lane in the comparison result is true (i.e., any pair is closer than threshold).\n            // svptest_any checks if any active lane in 'sv_cmp_result' is true,\n            // considering only the lanes enabled by 'current_pg'.\n            if (svptest_any(current_pg, sv_cmp_result)) {\n                return true; // Found a pair of close elements\n            }\n        }\n    }\n\n    // No two elements were found to be closer than the threshold.\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // For std::abs if needed, though svabs_f64 handles it\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n\n    // If there are fewer than 2 elements, no two elements can be close.\n    if (n < 2) {\n        return false;\n    }\n\n    // Get the number of double elements that fit into an SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    size_t sv_len = svcntd();\n\n    // Duplicate the threshold value across all lanes of an SVE vector.\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n\n    // Outer loop: Iterate through each element 'i' in the vector.\n    for (size_t i = 0; i < n; ++i) {\n        // Duplicate the current element 'numbers[i]' across all lanes of an SVE vector.\n        // This allows us to compare 'numbers[i]' with multiple 'numbers[j]' elements simultaneously.\n        svfloat64_t sv_val_i = svdup_f64(numbers[i]);\n\n        // Inner loop: Iterate through elements 'j' starting from 'i + 1'.\n        // We process 'j' in chunks of 'sv_len' to leverage SVE parallelism.\n        for (size_t j = i + 1; j < n; j += sv_len) {\n            // Create a predicate for the current chunk of 'j' values.\n            // This predicate ensures that we only process valid elements within the vector bounds,\n            // especially for the tail end of the 'numbers' vector.\n            svbool_t pg = svwhilelt_b64(j, n);\n\n            // Load a chunk of 'numbers' starting from 'j' into an SVE vector.\n            // Only active lanes (determined by 'pg') will load data; inactive lanes are untouched.\n            svfloat64_t sv_val_j = svld1_f64(pg, &numbers[j]);\n\n            // Calculate the absolute difference between sv_val_i and sv_val_j.\n            // svsub_f64_z performs subtraction, zeroing inactive lanes.\n            svfloat64_t diff = svsub_f64_z(pg, sv_val_i, sv_val_j);\n            // svabs_f64_z computes the absolute value, zeroing inactive lanes.\n            svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n\n            // Compare the absolute differences with the threshold.\n            // svcmplt_f64 returns a predicate where lanes are true if abs_diff < threshold.\n            svbool_t cmp_result = svcmplt_f64(pg, abs_diff, sv_threshold);\n\n            // Check if any of the comparisons in the current chunk resulted in true.\n            // svptest_any returns true if any active lane in 'cmp_result' is true.\n            if (svptest_any(pg, cmp_result)) {\n                return true; // Found two elements closer than the threshold.\n            }\n        }\n    }\n\n    // If no such pair was found after checking all combinations, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n\n    if (n < 2) {\n        return false;\n    }\n\n    // Broadcast the threshold value into an SVE vector register\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n\n    // Iterate through each element 'numbers[i]'\n    for (size_t i = 0; i < n; ++i) {\n        // Broadcast the current element 'numbers[i]' into an SVE vector register\n        svfloat64_t sv_val_i = svdup_f64(numbers[i]);\n\n        // Initialize pointer and remaining count for elements to compare with numbers[i]\n        // We start comparing from numbers[i + 1] to avoid redundant checks and self-comparison\n        const double* current_ptr = &numbers[i + 1];\n        size_t remaining_elements = n - (i + 1);\n\n        // Process the remaining elements in chunks using SVE vectors\n        while (remaining_elements > 0) {\n            // Get the current vector length (number of double elements per SVE vector)\n            size_t vl = svcntd();\n\n            // Create a predicate for the current chunk of elements.\n            // This predicate will be active for 'min(vl, remaining_elements)' elements,\n            // ensuring we only process valid data up to the end of the vector.\n            svbool_t pg = svwhilelt_b64(0, remaining_elements);\n\n            // Load a chunk of elements from the vector into an SVE vector register.\n            // Inactive elements (beyond 'remaining_elements' or 'vl') will be set to zero by svld1.\n            svfloat64_t sv_val_j = svld1(pg, current_ptr);\n\n            // Calculate the absolute difference between sv_val_i and sv_val_j.\n            // svsub_f64 performs subtraction on all lanes.\n            // svabs_f64_x computes absolute values; '_x' means it's unpredicated but writes results conditionally based on 'pg'.\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64(sv_val_i, sv_val_j));\n\n            // Compare if the absolute difference is less than the threshold.\n            // This comparison is predicated by 'pg', so only active lanes are considered.\n            svbool_t cmp_res = svcmplt_f64(pg, diff, sv_threshold);\n\n            // Check if any active element in the current chunk satisfies the condition.\n            // If true, we found two close elements, so return true immediately.\n            if (svptest_any(pg, cmp_res)) {\n                return true;\n            }\n\n            // Advance the pointer to the next chunk and decrement the count of remaining elements.\n            // We advance by the full vector length (vl) as svld1 correctly handles partial loads at the end.\n            current_ptr += vl;\n            remaining_elements -= vl;\n        }\n    }\n\n    // If no two elements closer than the threshold were found after all comparisons, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // Not strictly needed for SVE abs, but good practice for general math functions\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    const size_t n = numbers.size();\n\n    if (n < 2) {\n        return false;\n    }\n\n    // Broadcast the threshold value into an SVE vector\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n\n    // Iterate through each element 'i'\n    for (size_t i = 0; i < n; ++i) {\n        // Broadcast the current element numbers[i] into an SVE vector\n        svfloat64_t sv_current_val = svdup_f64(numbers[i]);\n\n        // Iterate through elements 'j' that come after 'i'\n        // We process 'j' in chunks of SVE vector length\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            // Create a predicate for the current SVE vector load.\n            // This predicate ensures we only process valid elements up to n-1.\n            // Lanes corresponding to indices >= n will be inactive.\n            svbool_t pg = svwhilelt_b64(j, n);\n\n            // Load a vector of elements from 'numbers' starting at index 'j'\n            // Only active lanes (determined by 'pg') will load data.\n            svfloat64_t sv_other_vals = svld1_f64(pg, &numbers[j]);\n\n            // Calculate the absolute difference between sv_current_val and sv_other_vals\n            // This operation is performed only on active lanes.\n            svfloat64_t sv_diff = svabs_f64(svsub_f64(sv_current_val, sv_other_vals));\n\n            // Compare the absolute difference with the threshold.\n            // This generates a new predicate where lanes are true if diff < threshold.\n            // The comparison is only performed for active lanes (determined by 'pg').\n            svbool_t sv_close_mask = svcmplt_f64(pg, sv_diff, sv_threshold);\n\n            // Check if any lane in the sv_close_mask is true.\n            // If any active lane has a difference less than the threshold, return true.\n            if (svptest_any(sv_true(), sv_close_mask)) {\n                return true;\n            }\n        }\n    }\n\n    // No two elements were found closer than the threshold\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> \n\nbool below_zero_simd(std::vector<int> operations) {\n    int current_balance_scalar = 0; // Starting balance is zero.\n    const int N = operations.size();\n    int i = 0;\n\n    // Loop through the operations vector in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n    while (i < N) {\n        // Create a predicate for the current vector chunk.\n        // This handles the tail end of the vector where N is not a multiple of VL.\n        svbool_t pg = svwhilelt_b32(i, N); \n        \n        // Load operations into an SVE vector.\n        // Only active lanes (determined by pg) will be loaded.\n        svint32_t ops = svld1_s32(pg, &operations[i]);\n\n        // Compute prefix sums within the current vector 'ops'.\n        // For example, if ops = [a, b, c, d], prefix_sums_relative will be [a, a+b, a+b+c, a+b+c+d].\n        svint32_t prefix_sums_relative = svscan_s32(pg, ops);\n\n        // Add the scalar balance accumulated from previous chunks to each element\n        // of the prefix sums. This gives the actual balance at each step within\n        // the current SVE vector chunk.\n        svint32_t current_balances_in_chunk = svadd_s32_x(pg, prefix_sums_relative, current_balance_scalar);\n\n        // Check if any of the balances in the current chunk are less than zero.\n        svbool_t below_zero_condition = svcmplt_s32(pg, current_balances_in_chunk, 0);\n\n        // If any active lane in the current chunk has a balance below zero,\n        // then the condition is met, and we return true.\n        if (svptest_any(pg, below_zero_condition)) {\n            return true;\n        }\n\n        // Update the scalar balance for the next iteration.\n        // This is the sum of all operations processed in the current SVE vector chunk.\n        current_balance_scalar += svaddv_s32(pg, ops);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        i += svcntw(); \n    }\n\n    // If the loop completes without any balance falling below zero, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\n// Helper function for prefix sum within an SVE vector (32-bit integers)\n// This function computes the inclusive prefix sum for the elements within a single SVE vector.\n// For example, if v_in = [a, b, c, d], it returns [a, a+b, a+b+c, a+b+c+d].\nsvint32_t sve_prefix_sum_s32(svint32_t v_in) {\n    svint32_t v_pfx = v_in;\n    svbool_t pg = svptrue_b32(); // Create a full predicate for 32-bit elements\n\n    // Get the vector length (number of 32-bit elements) for the current SVE vector.\n    // This value is determined at runtime by the SVE hardware.\n    int vl = svcntw();\n\n    // Implement the parallel prefix sum (scan) algorithm using a butterfly-like pattern.\n    // This loop runs log2(VL) times, where VL is the vector length.\n    for (int i = 1; i < vl; i <<= 1) {\n        // Create an index vector for shifting elements.\n        // For an element at index 'j', we want to add the element that was at 'j - i'.\n        // So, the indices should be [0-i, 1-i, ..., VL-1-i].\n        // Elements with negative indices will be treated as 0 by svperm_s32,\n        // effectively providing the '0' for the initial elements that don't have a predecessor at 'j-i'.\n        svint32_t v_indices = svindex_s32(-i, 1);\n\n        // Permute v_pfx according to v_indices.\n        // svperm_s32(v_base, v_data, v_indices) takes elements from v_data at specified indices.\n        // If an index is out of bounds (e.g., negative), it takes the corresponding element from v_base.\n        // Here, v_base is a vector of zeros (svdup_n_s32(0)), so out-of-bounds accesses yield zero.\n        svint32_t v_shifted = svperm_s32(svdup_n_s32(0), v_pfx, v_indices);\n\n        // Add the shifted values to the current prefix sums.\n        // svadd_s32_x performs an element-wise addition under the control of the predicate 'pg'.\n        v_pfx = svadd_s32_x(pg, v_pfx, v_shifted);\n    }\n    return v_pfx;\n}\n\nbool below_zero_simd(std::vector<int> operations) {\n    // Initialize the current balance. Using 'int' assumes the total balance\n    // will not exceed the range of a 32-bit signed integer.\n    // If the balance could exceed this range, 'long long' would be necessary,\n    // which would require using svint64_t intrinsics and handling type conversions.\n    int current_balance = 0;\n\n    // Get the vector length for 32-bit integers (number of elements in an SVE vector).\n    const int vl = svcntw();\n\n    // Loop through the operations vector in chunks of 'vl' elements.\n    for (size_t i = 0; i < operations.size(); i += vl) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // where the current index (starting from 'i') is less than 'operations.size()'.\n        // This correctly handles the tail end of the vector where the remaining elements\n        // might be fewer than 'vl'.\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)operations.size());\n\n        // Load the current chunk of operations into an SVE vector.\n        // svld1_s32 loads elements from memory into a 32-bit SVE vector under predicate control.\n        svint32_t v_ops = svld1_s32(pg, &operations[i]);\n\n        // Compute the prefix sum of the loaded operations vector.\n        // This gives the running sum of operations *within this current vector chunk*.\n        svint32_t v_pfx_ops = sve_prefix_sum_s32(v_ops);\n\n        // Create an SVE vector where all elements are the current_balance.\n        svint32_t v_current_balance_dup = svdup_n_s32(current_balance);\n\n        // Add the scalar 'current_balance' (from the previous block) to each element\n        // of the prefix sum vector. This yields the actual running balances for each\n        // operation within the current block.\n        svint32_t v_block_balances = svadd_s32_x(pg, v_pfx_ops, v_current_balance_dup);\n\n        // Check if any element in 'v_block_balances' is less than zero.\n        // svcmplt_s32 performs an element-wise comparison and returns a predicate vector\n        // where elements are true if the corresponding balance is less than 0.\n        svbool_t v_below_zero_mask = svcmplt_s32(pg, v_block_balances, svdup_n_s32(0));\n\n        // Check if any element in the 'v_below_zero_mask' is true.\n        // svptest_any returns true if any active element in the predicate is true.\n        // If any balance fell below zero in this block, return true immediately.\n        if (svptest_any(pg, v_below_zero_mask)) {\n            return true;\n        }\n\n        // Update the scalar 'current_balance' for the next block.\n        // This is done by adding the sum of all active operations in the current block.\n        // svaddv_s32 performs a horizontal sum of all active elements in 'v_ops'\n        // (i.e., elements for which 'pg' is true).\n        current_balance += svaddv_s32(pg, v_ops);\n    }\n\n    // If the loop completes without the balance ever falling below zero, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": ""}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations){\n    int current_balance = 0;\n\n    // Get the SVE vector length for 32-bit integers (int)\n    const int VL = svcntw();\n\n    // Predicate for all active lanes (used for operations that apply to all lanes)\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < operations.size(); i += VL) {\n        // Create a predicate for the current chunk, handling the tail\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // where the current index (i + lane_offset) is less than operations.size().\n        svbool_t tail_pg = svwhilelt_b32((unsigned long)i, (unsigned long)operations.size());\n        \n        // If no lanes are active in the current chunk (e.g., past the end of the vector), break.\n        if (!svptest_any(pg, tail_pg)) {\n            break;\n        }\n\n        // Load a vector of operations using the tail predicate.\n        // Inactive lanes will be loaded as 0.\n        svint32_t ops_vec = svld1_s32(tail_pg, &operations[i]);\n\n        // 1. Compute inclusive prefix sums of ops_vec within the SVE vector.\n        // This uses a parallel scan (Blellock scan) algorithm.\n        svint32_t prefix_sums = ops_vec;\n        for (int k = 1; k < VL; k <<= 1) {\n            // Shift elements to the right by 'k' positions, filling with zeros.\n            // This brings elements from 'k' positions before the current element.\n            svint32_t shifted_vec = svshf_s32(prefix_sums, svdup_n_s32(k), SV_ZERO);\n            // Add the shifted elements to the current prefix sums.\n            prefix_sums = svadd_s32(prefix_sums, shifted_vec);\n        }\n\n        // 2. Add the current_balance (scalar) to each element of the prefix sums.\n        // This gives the actual account balance at each step within the current vector chunk.\n        svint32_t final_balances = svadd_s32(prefix_sums, svdup_n_s32(current_balance));\n\n        // 3. Check if any of the final_balances are less than zero.\n        // svcmplt_s32 compares elements and sets predicate lanes to true if condition is met.\n        // The comparison is only performed for active lanes as per 'tail_pg'.\n        svbool_t less_than_zero = svcmplt_s32(tail_pg, final_balances, svdup_n_s32(0));\n        \n        // svptest_any checks if any lane in the predicate is true.\n        // If any balance fell below zero, return true.\n        if (svptest_any(tail_pg, less_than_zero)) {\n            return true;\n        }\n\n        // 4. Update current_balance for the next iteration.\n        // Sum all active elements in ops_vec and add to current_balance.\n        current_balance += svaddv_s32(tail_pg, ops_vec);\n    }\n\n    // If the loop completes without the balance falling below zero, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int current_balance = 0;\n    bool below_zero_found = false;\n    const int N = operations.size();\n\n    // Iterate through the operations vector in chunks of SVE vector length (svcntw()).\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (int i = 0; i < N; i += svcntw()) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b32(start_index, total_elements) generates a predicate\n        // that is true for elements from start_index up to (but not including) total_elements.\n        // This correctly handles the tail end of the vector where fewer than svcntw() elements remain.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load the current chunk of operations into an SVE vector.\n        // svld1_s32 loads elements from memory using the predicate 'pg'.\n        svint32_t sv_ops = svld1_s32(pg, &operations[i]);\n\n        // Compute the prefix sum of operations within the current SVE vector.\n        // svscan_s32(predicate, vector, operation) performs a cumulative scan.\n        // For example, if sv_ops = {a, b, c, d}, sv_prefix_sums_relative will be {a, a+b, a+b+c, a+b+c+d}.\n        // This sum is relative to the start of the current SVE vector chunk.\n        svint32_t sv_prefix_sums_relative = svscan_s32(pg, sv_ops, svadd_s32);\n\n        // Add the 'current_balance' (which is the balance accumulated from previous chunks)\n        // to each element of the relative prefix sums.\n        // This gives the actual balance at each step within the current SVE vector chunk.\n        // sv_s32(scalar_value) creates an SVE vector where all elements are 'scalar_value'.\n        svint32_t sv_actual_balances = svadd_s32(sv_prefix_sums_relative, sv_s32(current_balance));\n\n        // Check if any of the actual balances in the current SVE vector are less than zero.\n        // svcmplt_s32(predicate, vector1, vector2) compares elements and returns a predicate\n        // where true indicates vector1[j] < vector2[j].\n        svbool_t sv_below_zero_pred = svcmplt_s32(pg, sv_actual_balances, sv_s32(0));\n\n        // If any active element in 'sv_actual_balances' is less than zero,\n        // then we have found a point where the balance falls below zero.\n        // sv_any_s32(predicate_for_elements, predicate_for_condition) returns true if any\n        // element active under 'pg' also satisfies 'sv_below_zero_pred'.\n        if (sv_any_s32(pg, sv_below_zero_pred)) {\n            below_zero_found = true;\n            break; // No need to check further, we found a negative balance.\n        }\n\n        // Update the 'current_balance' for the next iteration.\n        // This is the sum of all operations in the current SVE vector chunk.\n        // svaddv_s32(predicate, vector) computes the sum of all active elements in the vector.\n        current_balance += svaddv_s32(pg, sv_ops);\n    }\n\n    return below_zero_found;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed for SVE, but good practice for std::vector\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return 0.0;\n    }\n\n    // --- Pass 1: Calculate Mean ---\n    // Initialize SVE vector for accumulating sum\n    svfloat64_t vec_sum = svdup_f64(0.0);\n\n    size_t i = 0;\n    svbool_t pg; // Predicate register for SVE operations\n\n    // Loop to sum all elements using SVE\n    while (i < N) {\n        // Generate a predicate for the current vector chunk\n        // This handles the tail (remaining elements less than a full vector)\n        pg = svwhilelt_b64(i, N);\n\n        // Load data into an SVE vector using the predicate\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Accumulate the sum\n        vec_sum = svadd_f64(vec_sum, current_vec);\n\n        // Advance the index by the number of double elements in an SVE vector\n        i += svcntd();\n    }\n\n    // Horizontally sum the elements in the accumulator vector to get the total sum\n    // svptrue_b64() creates a predicate where all lanes are active\n    double total_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    // Calculate the mean\n    double mean = total_sum / static_cast<double>(N);\n\n    // --- Pass 2: Calculate Sum of Absolute Differences from Mean ---\n    // Initialize SVE vector for accumulating sum of absolute differences\n    svfloat64_t vec_abs_diff_sum = svdup_f64(0.0);\n\n    // Duplicate the calculated mean into an SVE vector for element-wise operations\n    svfloat64_t vec_mean = svdup_f64(mean);\n\n    i = 0; // Reset index for the second pass\n    while (i < N) {\n        // Generate predicate for the current vector chunk\n        pg = svwhilelt_b64(i, N);\n\n        // Load data into an SVE vector\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Calculate (x - mean)\n        svfloat64_t diff_vec = svsub_f64(current_vec, vec_mean);\n\n        // Calculate |x - mean|\n        svfloat64_t abs_diff_vec = svabs_f64(diff_vec);\n\n        // Accumulate the sum of absolute differences\n        vec_abs_diff_sum = svadd_f64(vec_abs_diff_sum, abs_diff_vec);\n\n        // Advance the index\n        i += svcntd();\n    }\n\n    // Horizontally sum the elements in the absolute differences accumulator vector\n    double total_abs_diff_sum = svaddv_f64(svptrue_b64(), vec_abs_diff_sum);\n\n    // --- Final Calculation ---\n    // Divide the total sum of absolute differences by N to get the Mean Absolute Deviation\n    return total_abs_diff_sum / static_cast<double>(N);\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return 0.0;\n    }\n\n    // --- Pass 1: Calculate the Mean ---\n    svfloat64_t vec_sum_mean = svdup_f64(0.0); // Accumulator for vector sums\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Loop for vector processing to sum all elements\n    do {\n        pg = svwhilelt_b64(i, N); // Predicate for current chunk\n        if (svptest_first(svptrue_b64(), pg)) { // Check if predicate is active (i.e., there are elements to process)\n            svfloat64_t current_numbers = svld1(pg, &numbers[i]); // Load elements using the predicate\n            vec_sum_mean = svadd_f64(vec_sum_mean, current_numbers); // Add to the running vector sum\n            i += svcntd(); // Advance index by the vector length\n        } else {\n            break; // No more active elements, exit loop\n        }\n    } while (i < N);\n\n    // Horizontal sum the accumulated vector sum to get the total sum\n    double total_sum = svaddv_f64(svptrue_b64(), vec_sum_mean);\n    double mean = total_sum / static_cast<double>(N);\n\n    // --- Pass 2: Calculate Sum of Absolute Differences from Mean ---\n    svfloat64_t vec_sum_abs_diff = svdup_f64(0.0); // Accumulator for vector sums of absolute differences\n    svfloat64_t vec_mean = svdup_f64(mean); // Splat the calculated mean into a vector\n\n    i = 0; // Reset index for the second pass\n\n    // Loop for vector processing to sum absolute differences\n    do {\n        pg = svwhilelt_b64(i, N); // Predicate for current chunk\n        if (svptest_first(svptrue_b64(), pg)) { // Check if predicate is active\n            svfloat64_t current_numbers = svld1(pg, &numbers[i]); // Load elements\n            svfloat64_t diff = svsub_f64(current_numbers, vec_mean); // Calculate difference from mean\n            svfloat64_t abs_diff = svabs_f64(diff); // Take absolute value\n            vec_sum_abs_diff = svadd_f64(vec_sum_abs_diff, abs_diff); // Add to the running vector sum of absolute differences\n            i += svcntd(); // Advance index\n        } else {\n            break; // No more active elements, exit loop\n        }\n    } while (i < N);\n\n    // Horizontal sum the accumulated vector sum of absolute differences\n    double total_abs_diff_sum = svaddv_f64(svptrue_b64(), vec_sum_abs_diff);\n\n    // --- Final Calculation ---\n    return total_abs_diff_sum / static_cast<double>(N);\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    long N = numbers.size();\n\n    // Handle empty vector case to prevent division by zero.\n    if (N == 0) {\n        return 0.0;\n    }\n\n    // --- Pass 1: Calculate Mean ---\n    // Initialize an SVE vector to accumulate the sum of numbers.\n    // svdup_f64(0.0) creates a vector where all elements are 0.0.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    long i = 0; // Loop index\n    svbool_t pg; // Predicate register\n\n    // Loop through the numbers vector, processing elements in SVE vector chunks.\n    while (i < N) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b64(i, N) sets predicate elements to true as long as the\n        // current index 'i' is less than 'N'. This handles tail processing.\n        pg = svwhilelt_b64(i, N);\n\n        // Load a vector of double-precision floating-point numbers from memory.\n        // Only elements for which 'pg' is true are loaded.\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Add the loaded vector to the sum accumulator.\n        // The addition is predicated, meaning only active lanes are updated.\n        sum_vec = svadd_f64(pg, sum_vec, current_vec);\n\n        // Advance the index by the number of double elements in an SVE vector.\n        // svcntd() returns the number of double elements per SVE vector.\n        i += svcntd();\n    }\n\n    // Horizontally sum all elements in the 'sum_vec' accumulator.\n    // svptrue_b64() creates a predicate where all elements are true, ensuring\n    // all lanes of the accumulator are summed.\n    double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n    // Calculate the mean.\n    double mean = total_sum / N;\n\n    // --- Pass 2: Calculate Sum of Absolute Differences from Mean ---\n    // Initialize an SVE vector to accumulate the sum of absolute differences.\n    svfloat64_t abs_diff_sum_vec = svdup_f64(0.0);\n\n    // Create an SVE vector where all elements are the calculated mean.\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    i = 0; // Reset loop index for the second pass.\n    while (i < N) {\n        pg = svwhilelt_b64(i, N); // Generate predicate for current chunk.\n\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Calculate the difference: current_vec - mean_vec (x - x_mean).\n        svfloat64_t diff_vec = svsub_f64(pg, current_vec, mean_vec);\n\n        // Calculate the absolute value of the differences: |x - x_mean|.\n        svfloat64_t abs_diff_vec = svabs_f64(pg, diff_vec);\n\n        // Add the absolute differences to the accumulator.\n        abs_diff_sum_vec = svadd_f64(pg, abs_diff_sum_vec, abs_diff_vec);\n\n        i += svcntd(); // Advance index.\n    }\n\n    // Horizontally sum all elements in the 'abs_diff_sum_vec' accumulator.\n    double total_abs_diff_sum = svaddv_f64(svptrue_b64(), abs_diff_sum_vec);\n\n    // --- Final Calculation ---\n    // Mean Absolute Deviation = (Sum of |x - x_mean|) / N\n    return total_abs_diff_sum / N;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed for SVE, but good for context\n#include <cmath>   // Not strictly needed for SVE, but good for context\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return 0.0;\n    }\n\n    // Phase 1: Calculate the mean\n    // Initialize an SVE vector to accumulate the sum of elements.\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n    // Get the number of double elements that fit into an SVE vector.\n    size_t sv_double_count = svcntd();\n\n    // Loop through the input vector, processing elements in SVE vector chunks.\n    for (i = 0; i < N; i += sv_double_count) {\n        // Generate a predicate for the current chunk, ensuring only valid elements are processed.\n        svbool_t pg = svwhilelt_b64(i, N);\n        // Load a vector of double-precision floating-point numbers from the input array.\n        svfloat64_t current_vec = svld1(pg, &numbers[i]);\n        // Accumulate the sum. The _m suffix indicates a masked operation:\n        // inactive lanes in sum_vec are passed through, active lanes are added.\n        sum_vec = svadd_f64_m(pg, sum_vec, current_vec);\n    }\n\n    // Perform a horizontal sum reduction on the accumulated vector sum to get the total sum.\n    // svptrue_b64() creates a predicate where all lanes are active.\n    double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n    // Calculate the mean.\n    double mean = total_sum / static_cast<double>(N);\n\n    // Phase 2: Calculate the sum of absolute deviations from the mean\n    // Initialize an SVE vector to accumulate the sum of absolute differences.\n    svfloat64_t abs_diff_sum_vec = svdup_f64(0.0);\n    // Create an SVE vector where all lanes are filled with the calculated mean.\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    // Reset loop counter for the second pass.\n    i = 0;\n    // Loop through the input vector again to calculate absolute deviations.\n    for (i = 0; i < N; i += sv_double_count) {\n        // Generate a predicate for the current chunk.\n        svbool_t pg = svwhilelt_b64(i, N);\n        // Load a vector of double-precision floating-point numbers.\n        svfloat64_t current_vec = svld1(pg, &numbers[i]);\n\n        // Calculate the difference between each element and the mean.\n        // Inactive lanes in current_vec are passed through.\n        svfloat64_t diff_vec = svsub_f64_m(pg, current_vec, mean_vec);\n\n        // Calculate the absolute value of these differences.\n        // Inactive lanes in diff_vec are passed through.\n        svfloat64_t abs_diff_vec = svabs_f64_m(pg, diff_vec);\n\n        // Accumulate the sum of absolute differences.\n        // Inactive lanes in abs_diff_sum_vec are passed through.\n        abs_diff_sum_vec = svadd_f64_m(pg, abs_diff_sum_vec, abs_diff_vec);\n    }\n\n    // Perform a horizontal sum reduction on the accumulated absolute differences.\n    double total_abs_diff_sum = svaddv_f64(svptrue_b64(), abs_diff_sum_vec);\n\n    // Calculate the Mean Absolute Deviation.\n    double mad = total_abs_diff_sum / static_cast<double>(N);\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return 0.0; // Mean Absolute Deviation is undefined for an empty dataset.\n                    // Returning 0.0 as a common convention for such cases.\n    }\n\n    // --- Step 1: Calculate the mean of the dataset ---\n    svfloat64_t vec_sum = svdup_f64(0.0); // Initialize a vector accumulator for the sum\n    size_t elements_per_vector = svcntd(); // Get the number of double elements per SVE vector\n\n    // Loop through the input vector, processing elements in SVE vector chunks\n    for (size_t i = 0; i < N; i += elements_per_vector) {\n        // Generate a predicate for the current chunk to handle tail elements\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Load a vector of doubles from the input array\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Accumulate the sum of elements\n        vec_sum = svadd_f64(pg, vec_sum, current_vec);\n    }\n\n    // Reduce the vector sum to a scalar sum\n    // svptrue_b64() ensures all elements in the accumulator are summed\n    double total_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    // Calculate the mean\n    double mean = total_sum / N;\n\n    // --- Step 2: Calculate the sum of absolute differences from the mean ---\n    svfloat64_t vec_abs_diff_sum = svdup_f64(0.0); // Initialize accumulator for sum of absolute differences\n\n    // Duplicate the calculated mean into an SVE vector for element-wise operations\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    // Loop through the input vector again to calculate absolute differences\n    for (size_t i = 0; i < N; i += elements_per_vector) {\n        // Generate a predicate for the current chunk\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Load a vector of doubles\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n\n        // Calculate the difference between current elements and the mean\n        svfloat64_t diff_vec = svsub_f64(pg, current_vec, mean_vec);\n\n        // Calculate the absolute value of the differences\n        svfloat64_t abs_diff_vec = svabs_f64(pg, diff_vec);\n\n        // Accumulate the sum of absolute differences\n        vec_abs_diff_sum = svadd_f64(pg, vec_abs_diff_sum, abs_diff_vec);\n    }\n\n    // Reduce the vector sum of absolute differences to a scalar sum\n    double total_abs_diff_sum = svaddv_f64(svptrue_b64(), vec_abs_diff_sum);\n\n    // Calculate the Mean Absolute Deviation\n    return total_abs_diff_sum / N;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t N = numbers.size();\n    if (N == 0) {\n        return {};\n    }\n\n    size_t output_size = 2 * N - 1;\n    std::vector<int> result(output_size);\n\n    size_t i = 0; // Current index in input 'numbers'\n    size_t k = 0; // Current index in output 'result'\n\n    // Get the SVE vector length for 32-bit integers\n    size_t VL = svcntw();\n\n    // Create a vector filled with the delimeter\n    svint32_t vec_delimeter = svdup_n_s32(delimeter);\n\n    // Process elements that will definitely be followed by a delimeter\n    // These are numbers[0] through numbers[N-2]\n    size_t num_elements_with_delimiter = N - 1;\n\n    // Process full SVE vector chunks\n    size_t num_full_chunks = num_elements_with_delimiter / VL;\n    for (size_t chunk = 0; chunk < num_full_chunks; ++chunk) {\n        svbool_t pg = svptrue_b32(); // Full predicate for VL elements\n\n        // Load a chunk of numbers\n        svint32_t current_numbers = svld1(pg, &numbers[i]);\n\n        // Generate scatter offsets for numbers (even indices)\n        svint32_t indices_for_numbers = svindex_s32(k, 2);\n        // Generate scatter offsets for delimiters (odd indices)\n        svint32_t indices_for_delimeter = svindex_s32(k + 1, 2);\n\n        // Store numbers at even positions\n        svst1_scatter_s32offset(pg, &result[0], indices_for_numbers, current_numbers);\n        // Store delimiters at odd positions\n        svst1_scatter_s32offset(pg, &result[0], indices_for_delimeter, vec_delimeter);\n\n        i += VL;\n        k += 2 * VL;\n    }\n\n    // Process the remaining elements that will be followed by a delimeter (tail)\n    size_t remaining_elements_with_delimiter = num_elements_with_delimiter % VL;\n    if (remaining_elements_with_delimiter > 0) {\n        // Predicate for the remaining elements\n        svbool_t pg = svwhilelt_b32(0, remaining_elements_with_delimiter);\n\n        // Load the remaining chunk of numbers\n        svint32_t current_numbers = svld1(pg, &numbers[i]);\n\n        // Generate scatter offsets for numbers (even indices)\n        svint32_t indices_for_numbers = svindex_s32(k, 2);\n        // Generate scatter offsets for delimiters (odd indices)\n        svint32_t indices_for_delimeter = svindex_s32(k + 1, 2);\n\n        // Store numbers at even positions\n        svst1_scatter_s32offset(pg, &result[0], indices_for_numbers, current_numbers);\n        // Store delimiters at odd positions\n        svst1_scatter_s32offset(pg, &result[0], indices_for_delimeter, vec_delimeter);\n\n        i += remaining_elements_with_delimiter;\n        k += 2 * remaining_elements_with_delimiter;\n    }\n\n    // Handle the very last element of 'numbers', which is not followed by a delimeter\n    // This applies if N > 0 (already checked at the beginning)\n    result[k] = numbers[N - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    const int N = numbers.size();\n\n    // Handle base cases for empty or single-element input vectors\n    if (N == 0) {\n        return {};\n    }\n    if (N == 1) {\n        return numbers;\n    }\n\n    // Calculate the size of the result vector.\n    // For N > 1, the result size is N (original numbers) + (N - 1) (delimiters) = 2*N - 1.\n    const int result_size = 2 * N - 1;\n    std::vector<int> result(result_size);\n\n    // Get the SVE vector length for int32_t elements.\n    // This value is determined at runtime by the SVE hardware.\n    const int VL = svcntw();\n\n    // Duplicate the delimiter value into an SVE vector.\n    // This vector will be used for scattering delimiters.\n    svint32_t vec_delimiter_val = svdup_n_s32(delimeter);\n\n    // Pre-calculate the base offset multiplier for generating scatter offsets.\n    // svindex_s32(0, 1) creates a vector [0, 1, 2, 3, ...].\n    // Multiplying by 2 gives [0, 2, 4, 6, ...], which is used for both numbers and delimiters.\n    svint32_t offsets_multiplier = svmul_n_s32(svindex_s32(0, 1), 2);\n\n    // Loop through the input 'numbers' vector in chunks of VL elements.\n    for (int i = 0; i < N; i += VL) {\n        // Create a predicate for loading numbers.\n        // `svwhilelt_b32(i, N)` generates a predicate that is true for elements\n        // where the current index `i + lane_idx` is less than `N`.\n        svbool_t pg_load = svwhilelt_b32(i, N);\n\n        // Load a chunk of numbers from the input vector using the predicate.\n        // Inactive lanes (where predicate is false) will load a default value (usually 0).\n        svint32_t vec_nums = svld1_s32(pg_load, &numbers[i]);\n\n        // --- Store numbers at even indices in the result vector ---\n        // Calculate the starting offset for numbers in the current chunk.\n        // Numbers from `numbers[i]` will go to `result[2*i]`, `numbers[i+1]` to `result[2*(i+1)]`, etc.\n        svint32_t base_offset_nums = svdup_n_s32(2 * i);\n        // Add the base offset to the pre-calculated `offsets_multiplier` to get the final scatter offsets.\n        svint32_t current_offsets_nums = svadd_s32(base_offset_nums, offsets_multiplier);\n        \n        // Scatter store the loaded numbers into the result vector.\n        // `pg_load` ensures that only active lanes (corresponding to valid input numbers) are written.\n        svst1_scatter_s32offset(pg_load, result.data(), current_offsets_nums, vec_nums);\n\n        // --- Store delimiters at odd indices in the result vector ---\n        // Create a predicate for storing delimiters.\n        // A delimiter should be placed after `numbers[k]` only if `k` is not the very last element (`N-1`)\n        // of the original `numbers` vector.\n        // `svwhilelt_b32(i, N - 1)` generates a predicate that is true for elements\n        // where `i + lane_idx` is less than `N - 1`.\n        svbool_t pg_delims = svwhilelt_b32(i, N - 1);\n        // Combine this predicate with `pg_load` to ensure we only consider active elements\n        // within the current chunk that are also not the very last number.\n        pg_delims = svand_b(pg_delims, pg_load);\n\n        // Calculate the starting offset for delimiters in the current chunk.\n        // Delimiters will go to `result[2*i + 1]`, `result[2*(i+1) + 1]`, etc.\n        svint32_t base_offset_delims = svdup_n_s32(2 * i + 1);\n        // Add the base offset to the `offsets_multiplier` to get the final scatter offsets for delimiters.\n        svint32_t current_offsets_delims = svadd_s32(base_offset_delims, offsets_multiplier);\n\n        // Scatter store the delimiter value into the result vector.\n        // `pg_delims` ensures delimiters are only placed where needed (i.e., not after the last number).\n        svst1_scatter_s32offset(pg_delims, result.data(), current_offsets_delims, vec_delimiter_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t num_elements = numbers.size();\n\n    if (num_elements == 0) {\n        return {};\n    }\n\n    // Calculate the size of the result vector.\n    // For N elements, there are N-1 delimiters.\n    // Total size = N + (N - 1) = 2N - 1.\n    size_t result_size = 2 * num_elements - 1;\n    std::vector<int> result(result_size);\n\n    int* numbers_ptr = numbers.data();\n    int* result_ptr = result.data();\n\n    // Duplicate the delimiter into an SVE vector.\n    svint32_t v_delimeter = svdup_s32(delimeter);\n\n    // Get the SVE vector length for int (32-bit).\n    size_t VL = svcntw();\n\n    // --- Pass 1: Store numbers at even indices ---\n    // Iterate through the input numbers vector.\n    for (size_t i = 0; i < num_elements; i += VL) {\n        // Create a predicate for the current chunk of numbers.\n        // This predicate will be true for active lanes (within bounds of num_elements).\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n\n        // Load a vector of numbers.\n        svint32_t v_nums = svld1_s32(pg, &numbers_ptr[i]);\n\n        // Generate scatter indices for even positions in the result vector.\n        // For input index `k`, the corresponding number is placed at output index `2*k`.\n        // Base indices: {0, 2, 4, 6, ...}\n        svint32_t v_indices_base = svindex_s32(0, 2);\n        // Offset by `2*i` for the current block to get absolute indices.\n        svint32_t v_indices = svadd_s32(v_indices_base, svdup_s32(2 * i));\n\n        // Scatter store the numbers to the result vector.\n        // Only active lanes (determined by pg) will perform the store.\n        svst1_scatter_s32index(pg, result_ptr, v_indices, v_nums);\n    }\n\n    // --- Pass 2: Store delimiters at odd indices ---\n    // Delimiters are inserted between elements, so there are `num_elements - 1` delimiters.\n    // This loop runs only if `num_elements > 1`.\n    if (num_elements > 1) {\n        size_t num_delimiters = num_elements - 1;\n        for (size_t i = 0; i < num_delimiters; i += VL) {\n            // Create a predicate for the current chunk of delimiters.\n            // This predicate will be true for active lanes (within bounds of num_delimiters).\n            svbool_t pg = svwhilelt_b32(i, num_delimiters);\n\n            // Generate scatter indices for odd positions in the result vector.\n            // For a delimiter corresponding to input index `k`, it is placed at output index `2*k + 1`.\n            // Base indices: {1, 3, 5, 7, ...}\n            svint32_t v_indices_base = svindex_s32(1, 2);\n            // Offset by `2*i` for the current block to get absolute indices.\n            svint32_t v_indices = svadd_s32(v_indices_base, svdup_s32(2 * i));\n\n            // Scatter store the delimiters to the result vector.\n            // Only active lanes will perform the store.\n            svst1_scatter_s32index(pg, result_ptr, v_indices, v_delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> \n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return {};\n    }\n\n    // The output vector will have N elements from 'numbers' and N-1 delimiters.\n    // Total size = N + (N - 1) = 2*N - 1.\n    std::vector<int> result(2 * N - 1);\n\n    // Create a vector filled with the delimeter value.\n    svint32_t delimeter_vec = svdup_n_s32(delimeter);\n\n    // Get the SVE vector length for int32_t elements.\n    // This is used to determine how many elements to process in each iteration.\n    size_t sv_vec_len = svcntw();\n\n    // Generate a base offset vector for SVE scatter operations.\n    // This vector will contain {0, 1, 2, 3, ...} up to sv_vec_len-1.\n    svint32_t base_offsets = svindex_s32(0, 1);\n\n    // Generate an offset vector for even positions (0, 2, 4, 6, ...)\n    // These are used for storing elements from the 'numbers' vector.\n    svint32_t even_pos_offsets = svmul_n_s32(base_offsets, 2);\n\n    // Generate an offset vector for odd positions (1, 3, 5, 7, ...)\n    // These are used for storing the 'delimeter' value.\n    svint32_t odd_pos_offsets = svadd_n_s32(even_pos_offsets, 1);\n\n    for (size_t i = 0; i < N; i += sv_vec_len) {\n        // Create a predicate for loading elements from 'numbers'.\n        // This predicate ensures we only process valid elements up to N-1.\n        svbool_t pg_numbers = svwhilelt_b32(i, N);\n\n        // Load a chunk of numbers from the input vector.\n        svint32_t current_nums = svld1(pg_numbers, &numbers[i]);\n\n        // Calculate the base index in the 'result' vector for the current chunk.\n        // For numbers[i], its corresponding position in 'result' is 2*i.\n        size_t base_result_idx = 2 * i;\n\n        // Calculate the absolute indices for storing 'current_nums' into 'result' at even positions.\n        svint32_t even_indices = svadd_n_s32(even_pos_offsets, base_result_idx);\n        \n        // Scatter store the numbers into the 'result' vector at the calculated even indices.\n        svst1_scatter_s32offset(pg_numbers, result.data(), even_indices, current_nums);\n\n        // Create a predicate for storing delimiters.\n        // Delimiters are inserted between elements, so we need to ensure we don't\n        // insert a delimiter after the very last element of the original 'numbers' vector.\n        // This means the predicate should be active only for elements up to N-2.\n        svbool_t pg_delimiters = svwhilelt_b32(i, N - 1);\n\n        // Calculate the absolute indices for storing 'delimeter_vec' into 'result' at odd positions.\n        svint32_t odd_indices = svadd_n_s32(odd_pos_offsets, base_result_idx);\n\n        // Scatter store the delimiters into the 'result' vector at the calculated odd indices.\n        svst1_scatter_s32offset(pg_delimiters, result.data(), odd_indices, delimeter_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return {};\n    }\n\n    // Calculate the size of the output vector.\n    // For N elements, there are N-1 gaps for delimiters.\n    // Total size = N (numbers) + (N-1) (delimiters) = 2*N - 1.\n    size_t output_size = 2 * N - 1;\n    std::vector<int> result(output_size);\n\n    // Get the SVE vector length for 32-bit integers.\n    // This is the number of 32-bit elements that fit into an SVE vector.\n    int VL = svcntw();\n\n    // Process elements that will definitely be followed by a delimiter.\n    // These are numbers[0] to numbers[N-2]. Total N-1 elements.\n    size_t N_to_process_with_delimiter = N - 1;\n    size_t current_input_idx = 0;\n    size_t current_output_idx = 0;\n\n    for (; current_input_idx < N_to_process_with_delimiter; current_input_idx += VL) {\n        // Create a predicate for loading input numbers.\n        // This predicate is true for elements within the current VL chunk that are\n        // less than N_to_process_with_delimiter.\n        svbool_t pg_load = svwhilelt_b32(current_input_idx, N_to_process_with_delimiter);\n        \n        // If no active elements in this chunk, break.\n        // This can happen if N_to_process_with_delimiter is a multiple of VL,\n        // and current_input_idx reaches N_to_process_with_delimiter exactly.\n        if (svcntp_b32(pg_load) == 0) {\n            break;\n        }\n\n        // Load a vector of numbers from the input.\n        svint32_t vec_nums = svld1_s32(pg_load, &numbers[current_input_idx]);\n        \n        // Create a vector filled with the delimiter.\n        svint32_t vec_delimiters = svdup_s32(delimeter);\n\n        // Interleave the numbers and delimiters.\n        // svzip1_s32(a, b) produces [a0, b0, a1, b1, ...]\n        // svzip2_s32(a, b) produces [a_VL/2, b_VL/2, a_VL/2+1, b_VL/2+1, ...]\n        // These two results, when concatenated, form the interleaved sequence for VL input elements.\n        svint32_t interleaved_part1 = svzip1_s32(vec_nums, vec_delimiters);\n        svint32_t interleaved_part2 = svzip2_s32(vec_nums, vec_delimiters);\n\n        // Create predicates for storing the interleaved results.\n        // For each active element 'p_i' in pg_load, we need to store two elements (number and delimiter).\n        // So, if pg_load is [p0, p1, p2, p3], the output predicate should be [p0, p0, p1, p1, p2, p2, p3, p3].\n        // svzip1_b32(pg, pg) produces [p0, p0, p1, p1, ...]\n        // svzip2_b32(pg, pg) produces [p_VL/2, p_VL/2, p_VL/2+1, p_VL/2+1, ...]\n        svbool_t pg_out_lo = svzip1_b32(pg_load, pg_load);\n        svbool_t pg_out_hi = svzip2_b32(pg_load, pg_load);\n\n        // Store the first interleaved part into the result vector.\n        // The predicate ensures only active elements are written.\n        svst1_s32(pg_out_lo, &result[current_output_idx], interleaved_part1);\n        // Update the output index by the actual number of elements stored.\n        current_output_idx += svcntp_b32(pg_out_lo);\n\n        // Store the second interleaved part.\n        svst1_s32(pg_out_hi, &result[current_output_idx], interleaved_part2);\n        // Update the output index by the actual number of elements stored.\n        current_output_idx += svcntp_b32(pg_out_hi);\n    }\n\n    // Handle the last element of the input vector, if N > 0.\n    // This element is not followed by a delimiter.\n    // It will be placed at the current_output_idx, which should be 2*(N-1) at this point.\n    if (N > 0) { // This check is technically redundant due to the initial N==0 check, but harmless.\n        result[current_output_idx] = numbers[N - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\n// Helper for horizontal product reduction for svint64_t.\n// The ACLE does not provide a direct svmulv_s64 intrinsic for horizontal product reduction.\n// This function extracts each element from the SVE vector and multiplies them.\n// It assumes a full predicate (svptrue_b64()) for the input vector.\nstatic int64_t horizontal_product_s64(svint64_t vec) {\n    int64_t result = 1;\n    // Get the number of 64-bit elements in an SVE vector for the current VL.\n    int num_elements = svcntd(); \n    \n    // Extract elements one by one and multiply them.\n    // This loop operates on a small, fixed number of elements (VL/8),\n    // which is the size of a single SVE vector.\n    for (int i = 0; i < num_elements; ++i) {\n        result *= svget_lane_s64(vec, i);\n    }\n    return result;\n}\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    // Handle the edge case of an empty input vector.\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    // Initialize SVE accumulators for sum and product.\n    // These vectors will hold partial sums/products across their lanes.\n    svint64_t sum_acc_vec = svdup_s64(0);\n    svint64_t prod_acc_vec = svdup_s64(1); // Initialize with 1 for product\n\n    long N = numbers.size();\n    long i = 0;\n\n    // Loop through the input vector using SVE intrinsics.\n    // Process elements in chunks of svcntw() (the number of 16-bit elements in a vector).\n    while (i < N) {\n        // Create a predicate for the current chunk of 16-bit elements.\n        // This predicate determines which lanes are active (within bounds of 'numbers').\n        svbool_t pg_16 = svwhilelt_b16(i, N);\n        \n        // Load a vector of 16-bit integers from the input array.\n        // Inactive lanes (beyond N) will be loaded as zeros.\n        svint16_t current_chunk_16 = svld1_s16(pg_16, &numbers[i]);\n\n        // To convert all 16-bit elements to 64-bit, we need to split the\n        // svint16_t vector into multiple parts.\n        // An svint16_t vector holds svcntw() elements.\n        // An svint64_t vector holds svcntd() elements.\n        // The ratio svcntw() / svcntd() is always 4 (e.g., VL/2 / VL/8 = 4).\n        // So, we need to split the svint16_t vector into 4 parts, each containing svcntd() elements.\n\n        // Extract 16-bit sub-vectors, each containing svcntd() elements.\n        // svget_s16(vec, index) returns a svint16_t vector containing elements\n        // from the 'index'-th part of 'vec', where each part has svcntd() elements.\n        svint16_t v_16_part0 = svget_s16(current_chunk_16, 0);\n        svint16_t v_16_part1 = svget_s16(current_chunk_16, 1);\n        svint16_t v_16_part2 = svget_s16(current_chunk_16, 2);\n        svint16_t v_16_part3 = svget_s16(current_chunk_16, 3);\n\n        // Convert each 16-bit sub-vector to a 64-bit vector.\n        // svcvt_s64_s16 converts elements from svint16_t to svint64_t,\n        // assuming both vectors have svcntd() elements.\n        svint64_t v_64_0 = svcvt_s64_s16(v_16_part0);\n        svint64_t v_64_1 = svcvt_s64_s16(v_16_part1);\n        svint64_t v_64_2 = svcvt_s64_s16(v_16_part2);\n        svint64_t v_64_3 = svcvt_s64_s16(v_16_part3);\n\n        // Extract corresponding 64-bit predicates from the original 16-bit predicate.\n        // svget_b64(pg, index) returns a svbool_t predicate for the 'index'-th\n        // part of the original predicate, where each part corresponds to svcntd() elements.\n        svbool_t pg_64_0 = svget_b64(pg_16, 0);\n        svbool_t pg_64_1 = svget_b64(pg_16, 1);\n        svbool_t pg_64_2 = svget_b64(pg_16, 2);\n        svbool_t pg_64_3 = svget_b64(pg_16, 3);\n\n        // Accumulate sums using masked addition.\n        // Only active lanes (determined by pg_64_X) are added. Inactive lanes of v_64_X (which are 0)\n        // are ignored, preventing them from affecting the sum.\n        sum_acc_vec = svadd_s64_m(pg_64_0, sum_acc_vec, v_64_0);\n        sum_acc_vec = svadd_s64_m(pg_64_1, sum_acc_vec, v_64_1);\n        sum_acc_vec = svadd_s64_m(pg_64_2, sum_acc_vec, v_64_2);\n        sum_acc_vec = svadd_s64_m(pg_64_3, sum_acc_vec, v_64_3);\n\n        // Accumulate products using masked multiplication.\n        // Only active lanes are multiplied. Inactive lanes of v_64_X (which are 0)\n        // are ignored, and the corresponding lanes in prod_acc_vec remain unchanged.\n        // This prevents the product from becoming 0 prematurely due to padding.\n        prod_acc_vec = svmul_s64_m(pg_64_0, prod_acc_vec, v_64_0);\n        prod_acc_vec = svmul_s64_m(pg_64_1, prod_acc_vec, v_64_1);\n        prod_acc_vec = svmul_s64_m(pg_64_2, prod_acc_vec, v_64_2);\n        prod_acc_vec = svmul_s64_m(pg_64_3, prod_acc_vec, v_64_3);\n\n        // Advance the index by the number of 16-bit elements processed in this chunk.\n        i += svcntw();\n    }\n\n    // Final horizontal reduction for sum: sum all elements in sum_acc_vec.\n    // svaddv_s64 performs a horizontal sum reduction.\n    int64_t total_sum = svaddv_s64(svptrue_b64(), sum_acc_vec);\n\n    // Final horizontal reduction for product: multiply all elements in prod_acc_vec.\n    // Since svmulv_s64 does not exist, we use the helper function.\n    int64_t total_product = horizontal_product_s64(prod_acc_vec);\n\n    return {total_sum, total_product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed for SVE, but good practice for vector operations.\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int N = numbers.size();\n\n    // Initialize SVE accumulators for sum and product.\n    // sum_vec is initialized with zeros.\n    // prod_vec is initialized with ones, as 1 is the multiplicative identity.\n    svint64_t sum_vec = svdup_s64(0);\n    svint64_t prod_vec = svdup_s64(1);\n\n    // Get the number of int16_t elements per SVE vector.\n    // This determines the loop increment.\n    int elements_per_vector_int16 = svcntw();\n\n    // Loop through the input vector in chunks.\n    // The loop increment is based on the number of int16_t elements processed per SVE vector.\n    for (int i = 0; i < N; i += elements_per_vector_int16) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the vector, especially for the tail end of the input.\n        svbool_t pg = svwhilelt_b16(i, N);\n\n        // Load int16_t elements from the input vector into an SVE register.\n        svint16_t current_16 = svld1_s16(pg, &numbers[i]);\n\n        // Widen the int16_t elements to int64_t.\n        // This is important to prevent overflow during sum/product accumulation\n        // and to match the target int64_t output type.\n        svint64_t current_64 = svsext_s64_s16(pg, current_16);\n\n        // Accumulate sum: Add the current widened vector to the sum accumulator.\n        // svadd_s64 performs element-wise addition.\n        sum_vec = svadd_s64(sum_vec, current_64);\n\n        // Accumulate product: Multiply the current widened vector with the product accumulator.\n        // svmul_s64_m performs a masked element-wise multiplication.\n        // For active lanes (where pg is true), prod_vec[i] = prod_vec[i] * current_64[i].\n        // For inactive lanes (where pg is false), prod_vec[i] remains unchanged (retains its value from prod_vec).\n        // This is crucial for correctly handling partial vectors at the end of the input.\n        prod_vec = svmul_s64_m(prod_vec, pg, prod_vec, current_64);\n    }\n\n    // Final reduction for sum:\n    // Use svaddv_s64 to horizontally sum all elements in the sum_vec accumulator.\n    // svptrue_b64() creates a predicate that is true for all elements in an int64_t vector.\n    int64_t final_sum = svaddv_s64(svptrue_b64(), sum_vec);\n\n    // Final reduction for product:\n    // SVE does not have a direct horizontal product reduction intrinsic (like svmulv_s64).\n    // The common approach is to store the accumulated product vector to a temporary array\n    // and then perform a scalar multiplication loop over its elements.\n    int64_t final_product = 1;\n    \n    // Get the number of int64_t elements per SVE vector.\n    int elements_per_vector_int64 = svcntd();\n    \n    // Create a temporary vector to store the SVE product accumulator.\n    // Using std::vector for dynamic sizing based on runtime VL.\n    std::vector<int64_t> temp_prod_array(elements_per_vector_int64);\n    \n    // Store the accumulated product vector from SVE register to the temporary array.\n    svst1_s64(svptrue_b64(), temp_prod_array.data(), prod_vec);\n\n    // Scalar multiply all elements in the temporary array to get the final product.\n    for (int j = 0; j < elements_per_vector_int64; ++j) {\n        final_product *= temp_prod_array[j];\n    }\n\n    // Prepare the result vector.\n    std::vector<int64_t> result;\n    result.push_back(final_sum);\n    result.push_back(final_product);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    svint64_t vec_sum_acc = svdup_s64(0);\n    svint64_t vec_prod_acc = svdup_s64(1);\n\n    size_t i = 0;\n    size_t N = numbers.size();\n\n    while (i < N) {\n        svbool_t pg = svwhilelt_b16(i, N);\n        \n        svint16_t current_numbers_16 = svld1_s16(pg, &numbers[i]);\n        \n        svint64_t current_numbers_64 = svsext_s64_s16(pg, current_numbers_16);\n        \n        vec_sum_acc = svadd_s64_x(pg, vec_sum_acc, current_numbers_64);\n        \n        vec_prod_acc = svmul_s64_x(pg, vec_prod_acc, current_numbers_64);\n        \n        i += svcnt_s16();\n    }\n\n    int64_t final_sum = svaddv_s64(svptrue_b64(), vec_sum_acc);\n    int64_t final_product = svmulv_s64(svptrue_b64(), vec_prod_acc);\n\n    return {final_sum, final_product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // For std::accumulate, though not used in final SVE version\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t total_sum = 0;\n    int64_t total_product = 1;\n\n    // Initialize SVE accumulator for sum\n    // All lanes of sum_acc_vec are initialized to 0.\n    svint64_t sum_acc_vec = svdup_n_s64(0);\n\n    size_t i = 0;\n    size_t num_elements = numbers.size();\n\n    // Loop through the input vector in chunks determined by SVE vector length\n    while (i < num_elements) {\n        // Create a predicate for the current chunk of 16-bit elements\n        // This predicate will be true for elements from index `i` up to `num_elements - 1`.\n        svbool_t pg_16 = svwhilelt_b16(i, num_elements);\n\n        // Get the actual number of active elements in this chunk\n        size_t active_elements_count = svcnt_s16(pg_16);\n\n        // If no elements are active, we've processed all data or reached the end\n        if (active_elements_count == 0) {\n            break;\n        }\n\n        // Load 16-bit integer elements into an SVE vector\n        svint16_t current_chunk_16 = svld1_s16(pg_16, &numbers[i]);\n\n        // Create a predicate for 64-bit lanes, matching the number of active 16-bit elements.\n        // This is needed because svsext_s64_s16 operates on 64-bit lanes.\n        svbool_t pg_64_for_widen = svwhilelt_b64(0, active_elements_count);\n\n        // Widen the 16-bit elements to 64-bit elements for sum and product calculations.\n        // This ensures that intermediate sums and products do not overflow 16-bit or 32-bit types.\n        svint64_t current_chunk_64 = svsext_s64_s16(pg_64_for_widen, current_chunk_16);\n\n        // Accumulate sum: Add the current 64-bit chunk to the sum accumulator vector.\n        // The addition is masked by pg_64_for_widen, ensuring only active lanes are updated.\n        sum_acc_vec = svadd_s64_m(pg_64_for_widen, sum_acc_vec, current_chunk_64);\n\n        // Product accumulation:\n        // SVE does not provide a direct horizontal product reduction intrinsic.\n        // Therefore, we perform a scalar loop to multiply elements within the current chunk.\n        // This part is not fully vectorized, but it processes a vector's worth of data.\n        int64_t current_chunk_product = 1;\n        for (size_t k = 0; k < active_elements_count; ++k) {\n            current_chunk_product *= svget_s64(current_chunk_64, k);\n        }\n        // Multiply the product of the current chunk with the total product.\n        total_product *= current_chunk_product;\n\n        // Advance the index by the number of elements processed in this chunk\n        i += active_elements_count;\n    }\n\n    // Final reduction for sum: Sum all elements in the sum accumulator vector.\n    // svptrue_b64() creates a predicate where all 64-bit lanes are true.\n    total_sum = svaddv_s64(svptrue_b64(), sum_acc_vec);\n\n    return {total_sum, total_product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": ""}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // Required for std::max if used, but svmax is used here.\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    std::vector<int> result(numbers.size());\n\n    // Initialize the rolling maximum with the first element.\n    // This value will be propagated to the first SVE vector chunk and subsequent chunks.\n    int32_t last_max_scalar = numbers[0];\n    result[0] = last_max_scalar;\n\n    // Start processing from the second element.\n    // The loop iterates through the input vector in chunks determined by the SVE vector length (VL).\n    for (size_t i = 1; i < numbers.size(); ) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements where the index\n        // is less than numbers.size(), ensuring we don't process out-of-bounds elements,\n        // especially for the tail of the vector.\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        // Get the actual number of active elements in the current SVE vector.\n        // This is the current vector length (VL) for the active predicate.\n        int32_t current_vl = svcntw(); \n\n        // Load the current chunk of numbers from the input vector into an SVE vector.\n        svint32_t current_chunk = svld1(pg, &numbers[i]);\n\n        // Create an SVE vector where all elements are initialized with the 'last_max_scalar'.\n        // This scalar represents the rolling maximum from the element just before the current chunk.\n        svint32_t prev_max_scalar_vec = svdup_n_s32(last_max_scalar);\n\n        // Initialize the result vector for this chunk.\n        // Each element is initially the maximum of itself and the 'last_max_scalar'.\n        // This ensures that the rolling maximum correctly starts from the previous chunk's max.\n        svint32_t result_vec = svmax(current_chunk, prev_max_scalar_vec);\n\n        // Perform the parallel prefix maximum scan within the current SVE vector.\n        // This loop implements a cascading maximum operation.\n        // For each step 'k' (powers of 2: 1, 2, 4, ...), it takes the maximum of the current element\n        // and the element 'k' positions to its left.\n        // The 'svslide_r_s32' intrinsic shifts the vector right by 'k' elements,\n        // filling the leftmost 'k' positions with 'last_max_scalar'. This 'last_max_scalar'\n        // acts as the initial value for the scan for elements that don't have a 'left' element\n        // within the current vector (i.e., elements whose original index `j-k` would be negative).\n        for (int k = 1; k < current_vl; k <<= 1) {\n            svint32_t shifted_vec = svslide_r_s32(result_vec, k, last_max_scalar);\n            result_vec = svmax(result_vec, shifted_vec);\n        }\n\n        // Store the computed rolling maximums from the SVE vector back to the result vector.\n        // The predicate 'pg' ensures that only active lanes are written.\n        svst1(pg, &result[i], result_vec);\n\n        // Update 'last_max_scalar' for the next iteration.\n        // This is the maximum value of the last element processed in this chunk.\n        // svlasta_s32 returns the value of the last active element in 'result_vec'\n        // according to the predicate 'pg'.\n        last_max_scalar = svlasta_s32(pg, result_vec);\n\n        // Advance the index 'i' by the number of elements processed in this chunk (current_vl).\n        i += current_vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // Required for std::max (though not directly used in SVE intrinsics, good practice)\n#include <limits>    // Required for std::numeric_limits<int>::min()\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n\n    std::vector<int> result(n);\n    \n    // Initialize current_max_scalar with the first element of the input.\n    // This value will be propagated to subsequent blocks.\n    int current_max_scalar = numbers[0];\n    result[0] = numbers[0];\n\n    // Get the SVE vector length for 32-bit integers.\n    // VL is determined at runtime and represents the number of elements\n    // that can be processed in a single SVE vector operation.\n    size_t VL = svcntw(); \n\n    // Process the input vector in chunks of VL elements.\n    // Start from index 1, as numbers[0] has already been handled.\n    for (size_t i = 1; i < n; i += VL) {\n        // Create a predicate for the current block.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the input vector, especially for the last, partial block.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current block of data from the input vector.\n        svint32_t current_block_data = svld1_s32(pg, &numbers[i]);\n\n        // Create an SVE vector where all elements are the `current_max_scalar`\n        // from the end of the previous block.\n        svint32_t prev_block_max_vec = svdup_s32(current_max_scalar);\n\n        // Combine the current block's data with the `current_max_scalar`.\n        // This ensures that every element in the current block's prefix scan\n        // starts with a value at least as large as the maximum from the previous block.\n        // For example, if current_max_scalar = 10 and current_block_data = {1, 5, 2, 7},\n        // this step makes it {10, 10, 10, 10} if 10 is greater than all elements.\n        // Or, if current_block_data = {12, 5, 2, 7}, it becomes {12, 5, 2, 7}.\n        // The prefix scan below will then correctly propagate the maximum.\n        svint32_t block_data_with_prev_max = svmax_s32(current_block_data, prev_block_max_vec);\n\n        // Perform an inclusive prefix maximum (scan) within the current SVE vector.\n        // This uses a parallel scan algorithm (similar to Blelloch or Hillis-Steele).\n        // `block_prefix_max_vec` will accumulate the maximum value seen so far within the vector.\n        svint32_t block_prefix_max_vec = block_data_with_prev_max;\n        \n        // Iterate through powers of 2 (1, 2, 4, ...) up to VL.\n        // Each iteration combines elements at increasing distances.\n        for (int k = 1; k < VL; k *= 2) {\n            // Shift the vector to the right by `k` positions.\n            // `svslide_s32` fills the newly exposed elements (from the left) with zeros.\n            svint32_t shifted_vec = svslide_s32(block_prefix_max_vec, -k);\n\n            // For a correct prefix maximum with potentially negative numbers,\n            // the \"shifted-in\" elements (the first `k` elements) should be `INT_MIN`.\n            // Create a mask that is true for the first `k` elements.\n            svbool_t fill_mask = svwhilelt_b32(0, k); \n            \n            // Use the mask to conditionally select elements:\n            // - If `fill_mask` is true (first `k` elements), use `INT_MIN`.\n            // - Otherwise, use the value from `shifted_vec`.\n            shifted_vec = svsel_s32(fill_mask, svdup_s32(std::numeric_limits<int>::min()), shifted_vec);\n            \n            // Perform element-wise maximum between the current prefix max and the shifted values.\n            block_prefix_max_vec = svmax_s32(block_prefix_max_vec, shifted_vec);\n        }\n\n        // Store the computed rolling maximums for the current block into the result vector.\n        svst1_s32(pg, &result[i], block_prefix_max_vec);\n\n        // Update `current_max_scalar` for the next block.\n        // This is the last active element of the `block_prefix_max_vec`.\n        size_t num_active_lanes = svcntp_b32(pg);\n        if (num_active_lanes > 0) {\n            current_max_scalar = svget_lane_s32(block_prefix_max_vec, num_active_lanes - 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>    // For std::numeric_limits<int>::min()\n\n// Helper function for the svscan_s32 operation.\n// This function defines the binary operation (maximum) to be applied by svscan.\n// The predicate for svmax_s32 inside this function should be svptrue_b32()\n// because svscan itself handles the overall predicate for active lanes within the scan.\nstatic svint32_t svmax_op(svint32_t a, svint32_t b) {\n    return svmax_s32(svptrue_b32(), a, b);\n}\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n\n    // Handle empty input vector\n    if (n == 0) {\n        return {};\n    }\n\n    std::vector<int> result(n);\n\n    // Initialize current_max_scalar with the smallest possible integer value.\n    // This ensures that the first element of the input vector correctly becomes\n    // the initial maximum for the first block, as max(INT_MIN, value) = value.\n    int current_max_scalar = std::numeric_limits<int>::min();\n\n    // Iterate through the input vector in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // from 'i' up to (but not including) 'n'. This handles the end\n        // of the vector where the number of remaining elements might be\n        // less than the full SVE vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current chunk of data from the input vector into an SVE vector.\n        // Only elements corresponding to true predicate lanes are loaded.\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n\n        // Perform the rolling maximum operation within the current SVE vector block.\n        // svscan_s32 computes a prefix operation (in this case, prefix maximum).\n        // - 'pg': The predicate for the current block, determining which lanes are active.\n        // - 'svmax_op': The binary operation (maximum) to apply element-wise.\n        // - 'current_max_scalar': The identity element for the operation, which also\n        //                         serves as the 'previous maximum' carried over from\n        //                         the end of the last processed block. This value is\n        //                         effectively prepended to the current vector block\n        //                         for the scan operation.\n        // - 'vec': The input vector for the current block.\n        svint32_t result_vec_block = svscan_s32(pg, svmax_op, current_max_scalar, vec);\n\n        // Store the computed rolling maximums for the current block back into the result vector.\n        // Only elements corresponding to true predicate lanes are stored.\n        svst1_s32(pg, &result[i], result_vec_block);\n\n        // Update current_max_scalar for the next block.\n        // This is the maximum value found among all active elements in the 'result_vec_block'.\n        // svmax_s32v reduces the vector to a single scalar maximum.\n        // The predicate 'pg' ensures that only valid elements are considered for the reduction.\n        // Since the loop condition `i < n` ensures `pg` will have at least one true lane\n        // for any block being processed, `current_max_scalar` will always be updated\n        // with a valid maximum from the current block.\n        current_max_scalar = svmax_s32v(pg, result_vec_block);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Required for std::max in scalar fallback if any, but not for the SVE core logic\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    int current_max_scalar = numbers[0];\n    result[0] = current_max_scalar;\n    i++; // Start processing from the second element\n\n    // Loop through the input vector in chunks determined by SVE's vector length (VL)\n    for (; i < numbers.size(); ) {\n        // Create a predicate for the current chunk.\n        // `svwhilelt_b32` generates a predicate where lanes are active as long as\n        // their index (relative to `i`) is less than `numbers.size() - i`.\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)numbers.size());\n\n        // Get the current vector length (number of active lanes)\n        int vl = svcnt_s32();\n\n        // Load the data for the current chunk into an SVE vector\n        svint32_t vec_data = svld1_s32(pg, &numbers[i]);\n\n        // Initialize the prefix maximum vector with the loaded data.\n        // This will be used to compute the inclusive prefix maximum within the current vector.\n        svint32_t vec_prefix_max = vec_data;\n\n        // Perform an inclusive prefix maximum scan within the vector using recursive doubling.\n        // This loop iterates log2(VL) times.\n        for (int k = 1; k < vl; k *= 2) {\n            // Create a predicate for lanes that can receive a value from a 'left' neighbor.\n            // Lanes with index < k will not be updated by this shift.\n            svbool_t pg_shift = svwhilelt_b32((uint32_t)k, (uint32_t)vl);\n\n            // Shift the `vec_prefix_max` vector right by `k` elements.\n            // `svindex_s32(0, 1)` creates an index vector `[0, 1, 2, ...]`.\n            // `svsub_s32(svindex_s32(0, 1), svdup_s32(k))` creates indices `[-k, 1-k, 2-k, ...]`.\n            // `svpermute_s32` uses these indices to select elements. Out-of-bounds indices result in 0.\n            svint32_t shifted_vec = svpermute_s32(vec_prefix_max, svsub_s32(svindex_s32(0, 1), svdup_s32(k)));\n\n            // Update `vec_prefix_max` by taking the maximum of its current value and the shifted value.\n            // The `pg_shift` predicate ensures only relevant lanes are updated,\n            // and handles the case where `shifted_vec` might contain 0s from out-of-bounds accesses.\n            vec_prefix_max = svmax_s32(pg_shift, vec_prefix_max, shifted_vec);\n        }\n\n        // Now, `vec_prefix_max` contains the inclusive prefix maximums for the current block,\n        // i.e., `vec_prefix_max[j] = max(numbers[i], numbers[i+1], ..., numbers[i+j])`.\n\n        // Combine the `current_max_scalar` (maximum from previous blocks) with the\n        // `vec_prefix_max` to get the final rolling maximum for the current block.\n        // `svdup_s32(current_max_scalar)` broadcasts the scalar to all lanes.\n        svint32_t vec_result = svmax_s32(pg, vec_prefix_max, svdup_s32(current_max_scalar));\n\n        // Store the computed rolling maximums back to the result vector.\n        svst1_s32(pg, &result[i], vec_result);\n\n        // Update `current_max_scalar` with the last active element of `vec_result`.\n        // This value will be used as the `current_max_scalar` for the next chunk.\n        current_max_scalar = svlasta_s32(pg, vec_result);\n\n        // Advance the index by the number of elements processed in this chunk.\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t N = numbers.size();\n\n    if (N == 0) {\n        return {};\n    }\n\n    std::vector<int> result(N);\n\n    // Handle the first element separately as the initial rolling maximum.\n    // This value will be propagated to subsequent SVE vector operations.\n    result[0] = numbers[0];\n    int current_max_scalar = numbers[0];\n\n    // Loop through the rest of the elements in SVE vector chunks.\n    // The loop starts from index 1 because result[0] is already handled.\n    // 'svcnt_s32()' returns the number of 32-bit integer elements that fit in an SVE vector.\n    for (size_t i = 1; i < N; i += svcnt_s32()) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that only valid elements (up to N-1) are processed,\n        // especially for the last, potentially partial, chunk.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load the current chunk of numbers from the input vector.\n        svint32_t vec_numbers = svld1_s32(pg, &numbers[i]);\n\n        // Broadcast the 'current_max_scalar' (the rolling maximum from the previous chunk/element)\n        // to all active lanes of an SVE vector.\n        svint32_t sv_current_max = svdup_s32(current_max_scalar);\n\n        // Compute the element-wise maximum between the broadcasted 'current_max_scalar'\n        // and the loaded 'vec_numbers'. This ensures that each element in the chunk\n        // starts its rolling maximum calculation with at least the maximum value seen so far.\n        svint32_t combined_vec = svmax_s32(sv_current_max, vec_numbers);\n\n        // Perform a scan (prefix maximum) operation on the 'combined_vec'.\n        // This intrinsic computes the rolling maximum within the current SVE vector chunk.\n        // For example, if combined_vec = {a, b, c, d}, the result will be {a, max(a,b), max(a,b,c), max(a,b,c,d)}.\n        svint32_t scanned_vec = svscan_s32(pg, SV_MAX, combined_vec);\n\n        // Store the computed rolling maximums for the current chunk back into the result vector.\n        svst1_s32(pg, &result[i], scanned_vec);\n\n        // Update 'current_max_scalar' for the next iteration.\n        // 'svlasta_s32' extracts the value of the last active element from 'scanned_vec'.\n        // This value represents the overall rolling maximum at the end of the current chunk,\n        // which will be the starting point for the next chunk's calculation.\n        current_max_scalar = svlasta_s32(pg, scanned_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, ' '); // Initialize result string with appropriate size\n\n    // Get pointers to the underlying character arrays for SVE operations\n    // Cast to uint8_t* as SVE intrinsics typically operate on unsigned integer types\n    const uint8_t* ptr_a = reinterpret_cast<const uint8_t*>(a.data());\n    const uint8_t* ptr_b = reinterpret_cast<const uint8_t*>(b.data());\n    uint8_t* ptr_res = reinterpret_cast<uint8_t*>(result.data());\n\n    size_t i = 0;\n    svbool_t pg; // Predicate register for SVE operations\n\n    // Loop through the strings in chunks determined by the SVE vector length (VL)\n    // The svwhilelt_b8 intrinsic generates a predicate that is true for elements\n    // where the current index 'i' is less than 'len'. This handles remaining elements\n    // and ensures we don't process beyond the string bounds.\n    do {\n        // Generate a predicate for the current vector chunk\n        pg = svwhilelt_b8(i, len);\n\n        // If no lanes are active in the predicate, it means we've processed all elements\n        // or the remaining elements are fewer than the minimum vector length.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load vector chunks from strings 'a' and 'b' using the generated predicate\n        svuint8_t va = svld1_u8(pg, ptr_a + i);\n        svuint8_t vb = svld1_u8(pg, ptr_b + i);\n\n        // Perform bitwise XOR on the loaded character values.\n        // For '0' (ASCII 48) and '1' (ASCII 49):\n        // '0' ^ '0' = 0\n        // '0' ^ '1' = 1\n        // '1' ^ '0' = 1\n        // '1' ^ '1' = 0\n        svuint8_t vxored = sveor_u8(va, vb);\n\n        // Convert the XOR result (0 or 1) back to ASCII '0' or '1'.\n        // Adding 48 (ASCII value of '0') achieves this:\n        // 0 + 48 = 48 ('0')\n        // 1 + 48 = 49 ('1')\n        svuint8_t vresult = svadd_u8(vxored, svdup_u8(48)); // 48 is the ASCII value for '0'\n\n        // Store the resulting vector chunk back into the result string\n        svst1_u8(pg, ptr_res + i, vresult);\n\n        // Advance the index by the number of 8-bit elements in an SVE vector (VL)\n        i += svcntb();\n    } while (i < len); // Continue as long as there are elements left to process\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Assuming a and b have the same length based on the problem description example.\n    size_t len = a.length();\n    std::string result(len, ' '); // Initialize result string with appropriate size\n\n    // Get a vector containing the ASCII value of '0' replicated across all lanes.\n    // This is used for converting '0'/'1' characters to 0/1 integers and vice-versa.\n    svuint8_t zero_char_vec = svdup_n_u8('0');\n\n    // Loop through the strings in chunks of SVE vector length.\n    // svcntb() returns the number of bytes in an SVE vector (VL).\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b8(i, len) creates a predicate that is true for elements\n        // where the current index 'i' is less than 'len'. This handles\n        // the tail elements correctly.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from string 'a' and 'b' into SVE vectors.\n        // The predicate 'pg' ensures only active lanes are loaded.\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n\n        // Convert '0'/'1' characters to 0/1 integer values.\n        // Subtracting '0' (ASCII 48) from '0' (ASCII 48) gives 0.\n        // Subtracting '0' (ASCII 48) from '1' (ASCII 49) gives 1.\n        svuint8_t va_int = svsub_u8(pg, va, zero_char_vec);\n        svuint8_t vb_int = svsub_u8(pg, vb, zero_char_vec);\n\n        // Perform bitwise XOR operation on the integer vectors.\n        svuint8_t vxored_int = sveor_u8(pg, va_int, vb_int);\n\n        // Convert the 0/1 integer results back to '0'/'1' characters.\n        // Adding '0' (ASCII 48) to 0 gives '0'.\n        // Adding '0' (ASCII 48) to 1 gives '1'.\n        svuint8_t vxored_char = svadd_u8(pg, vxored_int, zero_char_vec);\n\n        // Store the resulting characters back into the result string.\n        svst1_u8(pg, (uint8_t*)&result[i], vxored_char);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Required for std::min\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Determine the length of the operation, using the shorter string's length\n    size_t n = std::min(a.length(), b.length());\n    // Initialize the result string with the determined length\n    std::string result(n, ' ');\n\n    // Loop through the strings in chunks of SVE vector length\n    // svcntb() returns the number of bytes (characters) in an SVE vector\n    for (size_t i = 0; i < n; i += svcntb()) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b8 ensures that operations only apply to valid elements\n        // up to 'n', handling the tail end of the string correctly.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters from string 'a' into an SVE vector\n        svuint8_t va_char = svld1_u8(pg, (const uint8_t*)&a[i]);\n        // Load characters from string 'b' into an SVE vector\n        svuint8_t vb_char = svld1_u8(pg, (const uint8_t*)&b[i]);\n\n        // Convert '0'/'1' characters to 0/1 integer values.\n        // This is done by subtracting the ASCII value of '0'.\n        // The _z suffix means elements where the predicate is false are zeroed.\n        svuint8_t va_int = svsub_u8_z(pg, va_char, svdup_u8('0'));\n        svuint8_t vb_int = svsub_u8_z(pg, vb_char, svdup_u8('0'));\n\n        // Perform the bitwise XOR operation on the integer values\n        svuint8_t vx_int = sveor_u8_z(pg, va_int, vb_int);\n\n        // Convert the 0/1 integer results back to '0'/'1' characters.\n        // This is done by adding the ASCII value of '0'.\n        svuint8_t vx_char = svadd_u8_z(pg, vx_int, svdup_u8('0'));\n\n        // Store the resulting characters back into the result string\n        svst1_u8(pg, (uint8_t*)&result[i], vx_char);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length(); // Assuming a.length() == b.length()\n    std::string result(len, ' '); // Initialize result string\n\n    size_t i = 0;\n    // Get the vector length in bytes for unsigned 8-bit integers (chars)\n    // This will be dynamically determined by the SVE hardware.\n    size_t sv_len = svcntb(); \n\n    // Loop using SVE intrinsics\n    // The predicate 'pg' controls which lanes are active.\n    // svwhilelt_b8(i, len) generates a predicate that is true for elements\n    // where the current index 'i' is less than 'len'. This handles the tail.\n    for (svbool_t pg = svwhilelt_b8(i, len); sv_any_b(pg); i += sv_len, pg = svwhilelt_b8(i, len)) {\n        // Load characters from string a\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        // Load characters from string b\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n\n        // Perform XOR on the ASCII values of '0' and '1'.\n        // '0' (ASCII 48), '1' (ASCII 49)\n        // '0' ^ '0' = 0\n        // '0' ^ '1' = 1\n        // '1' ^ '0' = 1\n        // '1' ^ '1' = 0\n        svuint8_t vxored = sveor_u8(va, vb);\n\n        // Convert the 0/1 result back to '0'/'1' characters by adding ASCII '0' (48)\n        svuint8_t vresult = svadd_u8(vxored, svdup_u8(48)); // 48 is ASCII for '0'\n\n        // Store the result back into the result string\n        svst1_u8(pg, (uint8_t*)&result[i], vresult);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, ' '); // Pre-allocate result string\n\n    // Pointers to the underlying character arrays\n    const unsigned char* ptr_a = reinterpret_cast<const unsigned char*>(a.data());\n    const unsigned char* ptr_b = reinterpret_cast<const unsigned char*>(b.data());\n    unsigned char* ptr_res = reinterpret_cast<unsigned char*>(result.data());\n\n    size_t i = 0;\n    // Loop through the strings in chunks of SVE vector length\n    // svcntb() returns the number of bytes in an SVE vector (VL/8)\n    for (; i + svcntb() <= len; i += svcntb()) {\n        // Create a predicate for all elements in the vector (all true)\n        svbool_t pg = svptrue_b8();\n\n        // Load characters from strings a and b into SVE vectors\n        svuint8_t vec_a_char = svld1_u8(pg, ptr_a + i);\n        svuint8_t vec_b_char = svld1_u8(pg, ptr_b + i);\n\n        // Convert '0'/'1' characters to 0/1 integer values by subtracting '0'\n        svuint8_t vec_a_int = svsub_u8(pg, vec_a_char, '0');\n        svuint8_t vec_b_int = svsub_u8(pg, vec_b_char, '0');\n\n        // Perform element-wise XOR operation\n        svuint8_t vec_xor_int = sveor_u8(vec_a_int, vec_b_int);\n\n        // Convert 0/1 integer values back to '0'/'1' characters by adding '0'\n        svuint8_t vec_xor_char = svadd_u8(pg, vec_xor_int, '0');\n\n        // Store the result vector back into the result string\n        svst1_u8(pg, ptr_res + i, vec_xor_char);\n    }\n\n    // Handle remaining elements (tail processing)\n    if (i < len) {\n        // Create a predicate for the remaining elements\n        // svwhilelt_b8(start_index, end_limit) generates a predicate\n        // where elements from start_index up to (but not including) end_limit are true.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from strings a and b using the tail predicate\n        svuint8_t vec_a_char = svld1_u8(pg, ptr_a + i);\n        svuint8_t vec_b_char = svld1_u8(pg, ptr_b + i);\n\n        // Convert '0'/'1' characters to 0/1 integer values\n        svuint8_t vec_a_int = svsub_u8(pg, vec_a_char, '0');\n        svuint8_t vec_b_int = svsub_u8(pg, vec_b_char, '0');\n\n        // Perform element-wise XOR operation\n        svuint8_t vec_xor_int = sveor_u8(vec_a_int, vec_b_int);\n\n        // Convert 0/1 integer values back to '0'/'1' characters\n        svuint8_t vec_xor_char = svadd_u8(pg, vec_xor_int, '0');\n\n        // Store the result vector back into the result string using the tail predicate\n        svst1_u8(pg, ptr_res + i, vec_xor_char);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::vector<size_t> lengths(strings.size());\n    for (size_t i = 0; i < strings.size(); ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    size_t current_max_len = 0;\n    size_t current_max_idx = 0;\n\n    if (!lengths.empty()) {\n        current_max_len = lengths[0];\n        current_max_idx = 0;\n    } else {\n        return \"\";\n    }\n\n    for (size_t i = 0; i < lengths.size(); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, lengths.size());\n\n        svuint64_t current_lengths_vec = svld1_u64(pg, &lengths[i]);\n\n        size_t block_max_len = svmaxv_u64(pg, current_lengths_vec);\n\n        if (block_max_len > current_max_len) {\n            current_max_len = block_max_len;\n\n            svbool_t is_equal_to_block_max = svcmpeq_u64(pg, current_lengths_vec, svdup_u64(block_max_len));\n\n            size_t relative_idx_in_block = svclz_b(is_equal_to_block_max);\n\n            current_max_idx = i + relative_idx_in_block;\n        }\n    }\n\n    return strings[current_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    // Pass 1: Collect all string lengths into a contiguous vector.\n    // This step is inherently scalar as std::string::length() is a method call.\n    std::vector<size_t> string_lengths(strings.size());\n    for (size_t i = 0; i < strings.size(); ++i) {\n        string_lengths[i] = strings[i].length();\n    }\n\n    // Pass 2: Find the maximum length and its corresponding index using SVE.\n    // Initialize overall max length and index with the first string's data.\n    size_t overall_max_len = string_lengths[0];\n    size_t overall_max_idx = 0;\n\n    // Get the SVE vector length for uint64_t elements.\n    const size_t VL = svcntd();\n\n    // Initialize SVE vectors for current max lengths and their corresponding indices.\n    // These will accumulate the maximums within each logical lane across batches.\n    // Initialize with 0, as any valid string length will be >= 0.\n    svuint64_t current_max_len_vec = svdup_u64(0);\n    svuint64_t current_max_idx_vec = svdup_u64(0);\n\n    // Loop through the string_lengths vector in chunks of VL.\n    for (size_t i = 0; i < string_lengths.size(); i += VL) {\n        // Create a predicate for the current chunk, handling the tail end.\n        svbool_t pg = svwhilelt_b64(i, string_lengths.size());\n\n        // Load the lengths for the current chunk into an SVE vector.\n        svuint64_t batch_lengths = svld1_u64(pg, &string_lengths[i]);\n\n        // Generate the corresponding global indices for the current chunk.\n        svuint64_t batch_indices = svindex_u64(i, 1);\n\n        // Compare current batch lengths with the current maximum lengths stored in the vector.\n        // `svcmpgt_u64` returns a predicate where a lane is true if `batch_lengths` > `current_max_len_vec`.\n        svbool_t cmp_gt_predicate = svcmpgt_u64(pg, batch_lengths, current_max_len_vec);\n\n        // Update `current_max_len_vec`: if `cmp_gt_predicate` is true for a lane, take `batch_lengths`,\n        // otherwise keep `current_max_len_vec`.\n        current_max_len_vec = svsel_u64(cmp_gt_predicate, batch_lengths, current_max_len_vec);\n\n        // Update `current_max_idx_vec`: if `cmp_gt_predicate` is true for a lane, take `batch_indices`,\n        // otherwise keep `current_max_idx_vec`.\n        // This correctly implements the \"first one in case of multiple strings of the same length\" rule\n        // because we only update if the new length is *strictly greater*. If it's equal, we keep the\n        // existing (earlier) index.\n        current_max_idx_vec = svsel_u64(cmp_gt_predicate, batch_indices, current_max_idx_vec);\n    }\n\n    // Horizontal reduction: Find the overall maximum length and its corresponding index\n    // from the `current_max_len_vec` and `current_max_idx_vec`.\n    // This part is scalar, as SVE does not provide a direct intrinsic for\n    // \"find max value and its corresponding value from another vector at the same index\" across lanes.\n    for (size_t lane = 0; lane < VL; ++lane) {\n        size_t lane_max_len = svget_u64(current_max_len_vec, lane);\n        size_t lane_max_idx = svget_u64(current_max_idx_vec, lane);\n\n        // Apply the \"first one\" rule:\n        // If current lane's max length is greater than overall max, update.\n        if (lane_max_len > overall_max_len) {\n            overall_max_len = lane_max_len;\n            overall_max_idx = lane_max_idx;\n        } else if (lane_max_len == overall_max_len) {\n            // If lengths are equal, choose the one with the smaller index.\n            // This ensures we pick the *first* occurrence globally.\n            if (lane_max_idx < overall_max_idx) {\n                overall_max_idx = lane_max_idx;\n            }\n        }\n    }\n\n    // Return the string at the identified index.\n    return strings[overall_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    // Initialize global maximum length and index.\n    // global_max_len starts at 0.\n    // global_max_idx starts at a very large value to ensure the first valid index is chosen.\n    uint64_t global_max_len = 0;\n    int64_t global_max_idx = std::numeric_limits<int64_t>::max();\n\n    // Get the current vector length (number of 64-bit elements) for SVE.\n    // The maximum possible value for svcntd() is 32 (for a 2048-bit vector).\n    size_t vl = svcntd();\n\n    // Temporary arrays to hold lengths and absolute indices for the current SVE chunk.\n    // These are populated from the input vector before loading into SVE registers.\n    uint64_t temp_lengths[32]; // Max 32 elements for 64-bit SVE vector\n    int64_t temp_indices[32];\n\n    // Iterate through the input strings vector in chunks of `vl`.\n    for (size_t i = 0; i < strings.size(); i += vl) {\n        // Create a predicate for the current chunk. This handles partial vectors at the end\n        // of the input `strings` vector, ensuring operations only apply to valid elements.\n        svbool_t pg = svwhilelt_b64(i, strings.size());\n\n        // Populate temporary arrays with lengths and absolute indices for the current chunk.\n        // For inactive lanes (beyond strings.size()), sentinel values are used:\n        // length 0 (won't be chosen as max unless all are 0)\n        // index INT64_MAX (won't be chosen as min)\n        for (size_t j = 0; j < vl; ++j) {\n            size_t current_idx = i + j;\n            if (current_idx < strings.size()) {\n                temp_lengths[j] = strings[current_idx].length();\n                temp_indices[j] = current_idx;\n            } else {\n                temp_lengths[j] = 0;\n                temp_indices[j] = std::numeric_limits<int64_t>::max();\n            }\n        }\n\n        // Load the populated lengths and indices into SVE vectors using the predicate.\n        svuint64_t lengths_vec = svld1_u64(pg, temp_lengths);\n        svint64_t indices_vec = svld1_s64(pg, temp_indices);\n\n        // Find the maximum length within this chunk.\n        // svmax_u64_x performs a horizontal reduction (max across all active lanes)\n        // and returns a scalar value. The initial value for reduction is 0.\n        uint64_t chunk_max_len = svmax_u64_x(pg, lengths_vec, svdup_n_u64(0));\n\n        // Find the first index corresponding to this maximum length within this chunk.\n        // 1. Create a mask: true for elements in `lengths_vec` that equal `chunk_max_len`\n        //    and are active according to `pg`.\n        svbool_t max_len_mask = svcmpeq_u64(pg, lengths_vec, svdup_n_u64(chunk_max_len));\n\n        // 2. Select indices based on `max_len_mask`. For elements not matching the max length,\n        //    use INT64_MAX as a sentinel value. This ensures they won't be chosen by svmin_s64_x.\n        svint64_t masked_indices = svsel_s64(max_len_mask, indices_vec, svdup_n_s64(std::numeric_limits<int64_t>::max()));\n\n        // 3. Find the minimum index among the masked ones. This will be the first occurrence\n        //    of an element with `chunk_max_len` in the current chunk.\n        //    svmin_s64_x performs a horizontal reduction (min across all elements).\n        //    svptrue_b64() is used as the predicate because `masked_indices` already has\n        //    the relevant predicate applied via `svsel_s64`.\n        int64_t chunk_absolute_min_idx = svmin_s64_x(svptrue_b64(), masked_indices, svdup_n_s64(std::numeric_limits<int64_t>::max()));\n\n        // Update the global maximum length and index.\n        // Only proceed if a valid element was found in the current chunk (i.e., chunk_absolute_min_idx is not INT64_MAX).\n        if (chunk_absolute_min_idx != std::numeric_limits<int64_t>::max()) {\n            if (chunk_max_len > global_max_len) {\n                // If the current chunk has a new overall maximum length, update both.\n                global_max_len = chunk_max_len;\n                global_max_idx = chunk_absolute_min_idx;\n            } else if (chunk_max_len == global_max_len) {\n                // If the current chunk has a length equal to the global maximum,\n                // update only if its index is smaller (i.e., it appeared earlier).\n                if (chunk_absolute_min_idx < global_max_idx) {\n                    global_max_idx = chunk_absolute_min_idx;\n                }\n            }\n        }\n    }\n\n    // After iterating through all chunks, global_max_idx holds the index of the\n    // longest string (or the first one in case of ties).\n    // If global_max_idx is still INT64_MAX, it implies no valid string was found\n    // (e.g., if the input vector was empty, though that's handled by an early exit).\n    if (global_max_idx == std::numeric_limits<int64_t>::max()) {\n        return \"\";\n    }\n    return strings[global_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    // Step 1: Get all lengths. This part is inherently sequential as string.length()\n    // is a method call on individual string objects. For a large number of strings,\n    // this step might be the dominant factor in performance.\n    std::vector<size_t> lengths(strings.size());\n    for (size_t i = 0; i < strings.size(); ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    // Step 2: Find the overall maximum length using SVE.\n    // Initialize with the length of the first string. If all strings are empty,\n    // this will correctly initialize to 0.\n    size_t current_max_scalar_len = lengths[0];\n    \n    // Initialize SVE vector for max length reduction with the initial scalar max.\n    svuint64_t sv_max_len_vec = svdup_u64(current_max_scalar_len);\n\n    // Loop through the lengths vector in SVE vector chunks.\n    // svcntd() returns the number of 64-bit elements in an SVE vector (VL/8).\n    for (size_t i = 0; i < lengths.size(); i += svcntd()) {\n        // Create a predicate for the current chunk, handling partial vectors at the end.\n        // This ensures we only process valid elements within the bounds of the vector.\n        svbool_t pg = svwhilelt_b64(i, lengths.size());\n        \n        // Load a chunk of lengths into an SVE vector using the predicate.\n        svuint64_t sv_chunk_lengths = svld1(pg, &lengths[i]);\n        \n        // Update the maximum length vector element-wise.\n        sv_max_len_vec = svmax_u64(sv_max_len_vec, sv_chunk_lengths);\n    }\n    // Reduce the SVE vector to a single scalar maximum length.\n    current_max_scalar_len = svmax_u64_reduce(svptrue_b64(), sv_max_len_vec);\n\n\n    // Step 3: Find the first index that has this maximum length using SVE.\n    // Initialize with a value larger than any possible index to ensure the first valid\n    // index found is correctly picked as the minimum.\n    size_t final_max_idx = std::numeric_limits<size_t>::max();\n\n    // Re-iterate through the lengths vector in SVE vector chunks.\n    for (size_t i = 0; i < lengths.size(); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, lengths.size());\n        \n        svuint64_t sv_chunk_lengths = svld1(pg, &lengths[i]);\n        // Generate indices for the current chunk: i, i+1, i+2, ...\n        svuint64_t sv_indices = svindex_u64(i, 1);\n\n        // Create a predicate for elements in this chunk that are equal to the max length.\n        svbool_t p_equal = svcmpeq_u64(pg, sv_chunk_lengths, svdup_u64(current_max_scalar_len));\n\n        // Check if any element in this chunk matches the max length.\n        if (svptest_any(svptrue_b64(), p_equal)) {\n            // Select the indices where p_equal is true. For non-matching elements,\n            // use ULLONG_MAX to ensure they don't affect the minimum reduction.\n            svuint64_t sv_matching_indices = svsel_u64(p_equal, sv_indices, svdup_u64(std::numeric_limits<size_t>::max()));\n            \n            // Find the minimum index within this chunk that matches the max length.\n            size_t chunk_first_idx = svmin_u64_reduce(svptrue_b64(), sv_matching_indices);\n\n            // Update the overall minimum index found so far. Since we iterate from i=0,\n            // the first time a match is found, it will correctly set `final_max_idx`\n            // to the global first occurrence.\n            if (chunk_first_idx < final_max_idx) {\n                final_max_idx = chunk_first_idx;\n            }\n        }\n    }\n    \n    // Return the string at the identified index.\n    return strings[final_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <vector>\n#include <algorithm> // Required for std::min\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    // Phase 1: Extract lengths into a vector of size_t\n    std::vector<size_t> lengths;\n    lengths.reserve(strings.size());\n    for (const auto& s : strings) {\n        lengths.push_back(s.length());\n    }\n\n    size_t N = lengths.size();\n    size_t vl = svcntd(); // Get the number of 64-bit elements in an SVE vector\n\n    // Initialize overall maximum length and its corresponding index.\n    // According to the rule \"Return the first one in case of multiple strings of the same length\",\n    // we initialize with the first string's length and index.\n    size_t overall_max_len = lengths[0];\n    size_t overall_max_idx = 0;\n\n    // Phase 2: Iterate through lengths vector in SVE chunks to find the longest string's length and its first index.\n    for (size_t i = 0; i < N; i += vl) {\n        // Create a predicate for the current chunk, ensuring we don't go past N\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Load current chunk of lengths into an SVE vector\n        svuint64_t current_lengths_vec = svld1_u64(pg, &lengths[i]);\n\n        // Generate absolute indices for the current chunk: i, i+1, i+2, ...\n        svuint64_t current_indices_vec = svindex_u64(i, 1);\n\n        // Find the maximum length within the current SVE vector chunk\n        size_t chunk_max_len = svmax_u64_reduce(pg, current_lengths_vec);\n\n        // Find the minimum index within the current chunk that has `chunk_max_len`.\n        // 1. Create a predicate where lanes match `chunk_max_len`.\n        svbool_t matches_chunk_max_len = svcmpeq_u64(pg, current_lengths_vec, svdup_u64(chunk_max_len));\n\n        // 2. Select indices only for matching elements. For non-matching elements, set to SIZE_MAX\n        //    (which acts as infinity for a minimum reduction).\n        svuint64_t candidate_indices_for_min = svsel_u64(matches_chunk_max_len, current_indices_vec, svdup_u64(SIZE_MAX));\n\n        // 3. Reduce to find the minimum index among those matching the `chunk_max_len`.\n        size_t chunk_min_idx_for_max_len = svmin_u64_reduce(pg, candidate_indices_for_min);\n\n        // Phase 3: Combine chunk results with overall results\n        if (chunk_max_len > overall_max_len) {\n            // If a new maximum length is found, update both max_len and max_idx\n            overall_max_len = chunk_max_len;\n            overall_max_idx = chunk_min_idx_for_max_len;\n        } else if (chunk_max_len == overall_max_len) {\n            // If the current chunk's max length is equal to the overall max length,\n            // we need to pick the one with the smaller index (first occurrence rule).\n            overall_max_idx = std::min(overall_max_idx, chunk_min_idx_for_max_len);\n        }\n    }\n\n    // Return the string at the identified index\n    return strings[overall_max_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Duplicate the input scalar values 'a' and 'b' into all lanes of SVE vectors.\n    // Although we are computing the GCD for a single pair, using SVE intrinsics\n    // requires operating on vector registers. By duplicating the values, all\n    // lanes will perform the same computation, and we will extract the result\n    // from the first lane.\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    // Create a full predicate for 64-bit elements. This predicate will enable\n    // operations on all lanes of the SVE vectors.\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n\n    // Implement the Euclidean algorithm: while (b != 0)\n    // We check the value of 'b' in the first lane to control the scalar loop.\n    while (svget_lane_u64(vb, 0) != 0) {\n        // Calculate the remainder: temp_r = va % vb\n        // SVE does not have a direct modulo intrinsic for unsigned integers.\n        // We compute it using the identity: remainder = dividend - (dividend / divisor) * divisor\n        svuint64_t vquotient = svdiv_u64(pg, va, vb); // Calculate quotient: va / vb\n        svuint64_t vproduct = svmul_u64(pg, vquotient, vb); // Calculate product: (va / vb) * vb\n        svuint64_t vremainder = svsub_u64(pg, va, vproduct); // Calculate remainder: va - product\n\n        // Update va and vb for the next iteration:\n        // In the Euclidean algorithm, 'a' becomes the old 'b', and 'b' becomes the remainder.\n        // va_new = vb_old;\n        // vb_new = vremainder_calculated;\n        va = vb;\n        vb = vremainder;\n    }\n\n    // When the loop terminates, 'b' (vb) is 0, and 'a' (va) holds the GCD.\n    // Extract the result from the first lane of the 'va' vector.\n    return svget_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Predicate for the first element only, as we are performing a scalar operation\n    // using SVE intrinsics. This ensures only the first lane is active.\n    svbool_t pg = svwhilelt_b64(0, 1);\n\n    // Load 'a' and 'b' into SVE vectors.\n    // All elements of the vector will be initialized with the scalar value,\n    // but only the first element will be actively processed due to the predicate.\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n\n    // Implement the Euclidean algorithm using SVE intrinsics.\n    // The loop continues as long as the first element of 'vb' is not zero.\n    while (svget_lane_u64(vb, 0) != 0) {\n        // Store the current 'b' value (first lane) into a temporary vector.\n        svuint64_t temp_v = vb;\n\n        // Calculate 'a % b' using SVE intrinsics: a - (a / b) * b\n        // svdiv_u64 performs integer division.\n        svuint64_t quotient_v = svdiv_u64(pg, va, vb);\n        svuint64_t product_v = svmul_u64(pg, quotient_v, vb);\n        svuint64_t remainder_v = svsub_u64(pg, va, product_v);\n\n        // Update 'b' to the remainder and 'a' to the previous 'b'.\n        // Only the first lane is updated due to the predicate 'pg'.\n        vb = remainder_v;\n        va = temp_v;\n    }\n\n    // The GCD is the value of 'a' when 'b' becomes zero.\n    // Extract the result from the first lane of 'va'.\n    return svget_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // The Euclidean algorithm for GCD is inherently sequential for a single pair (a, b).\n    // SIMD (SVE) is designed for parallel operations on multiple data elements.\n    // For a single pair, true data parallelism for the GCD computation itself is not achievable.\n    //\n    // However, to fulfill the requirement of using SVE intrinsics to \"achieve parallelism\",\n    // we implement the Euclidean algorithm by duplicating 'a' and 'b' across all lanes\n    // of SVE vectors. This means the same computation is performed simultaneously\n    // on all vector lanes. While this doesn't speed up the computation for a single (a, b) pair\n    // compared to a scalar implementation, it demonstrates the use of SVE intrinsics\n    // and the parallel nature of SVE operations.\n\n    // Get a predicate that enables all lanes for 64-bit elements.\n    svbool_t pg = svptrue_b64();\n\n    // Duplicate 'a' and 'b' into SVE vectors. All lanes will hold the same value.\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n\n    // Implement the Euclidean algorithm using SVE intrinsics.\n    // The loop continues as long as 'b' (in any lane) is not zero.\n    // Since all lanes hold the same 'b' value, checking if any 'b' is non-zero\n    // effectively checks if the scalar 'b' is non-zero.\n    while (svany_u64(pg, svcmpne_u64(pg, vb, svdup_n_u64(0)))) {\n        // Calculate the remainder (a % b) for all lanes in parallel.\n        svuint64_t remainder = svmod_u64(pg, va, vb);\n\n        // Update va = vb and vb = remainder for all lanes in parallel.\n        // This effectively performs the (b, a % b) step of the Euclidean algorithm.\n        va = vb;\n        vb = remainder;\n    }\n\n    // The GCD result is now in 'va' (in all lanes).\n    // Extract the result from the first lane (or any lane, as they are all identical).\n    return svget_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Duplicate scalar inputs into all lanes of SVE vectors.\n    // This allows us to perform the Euclidean algorithm steps using SVE intrinsics,\n    // even though the computation for a single GCD pair is inherently sequential.\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n\n    // Get a predicate for all active lanes.\n    svbool_t pg = svptrue_b64();\n\n    // Implement the Euclidean algorithm using SVE intrinsics.\n    // The loop continues as long as 'b' (the scalar value duplicated across all lanes of vb) is not zero.\n    // svlasta_u64 extracts the value from the last active lane, which is sufficient\n    // since all lanes contain the same duplicated scalar value.\n    while (svlasta_u64(pg, vb) != 0) {\n        // Store the current value of 'b' into a temporary SVE vector.\n        svuint64_t vtemp = vb;\n\n        // Calculate 'a % b' for all lanes and assign the result to 'vb'.\n        // svmod_u64 performs element-wise modulo operation.\n        vb = svmod_u64(pg, va, vb);\n\n        // Assign the temporary (old 'b') to 'va'.\n        va = vtemp;\n    }\n\n    // After the loop, 'a' (now stored in 'va') holds the greatest common divisor.\n    // Extract the result from any lane (e.g., the last active lane).\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    if (a == 0) {\n        return b;\n    }\n    if (b == 0) {\n        return a;\n    }\n\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n\n    svbool_t pg = svwhilelt_b64(0, svcnt_u64());\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t a_gt_b = svcmpgt_u64(pg, va, vb);\n\n        va = svsel_u64(a_gt_b, svsub_u64(pg, va, vb), va);\n        vb = svsel_u64(a_gt_b, vb, svsub_u64(pg, vb, va));\n    }\n\n    return svget_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>   // For std::abs (though SVE intrinsics are used for vector ops)\n#include <cfloat>  // For FLT_MAX\n#include <algorithm> // Not strictly needed, but good for general utility\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t N = numbers.size();\n\n    // As per problem statement, N is at least 2.\n    // If N < 2, there are no pairs to compare.\n    if (N < 2) {\n        return {}; // Return an empty vector\n    }\n\n    float min_diff = FLT_MAX; // Initialize with the largest possible float value\n    float result_val1 = 0.0f;\n    float result_val2 = 0.0f;\n\n    // Outer loop: Iterate through each element 'val_a'\n    for (size_t i = 0; i < N; ++i) {\n        float val_a = numbers[i];\n        // Broadcast val_a to an SVE vector, so it can be compared with a vector of 'b' values\n        svfloat32_t vec_val_a = svdup_f32(val_a);\n\n        // Inner loop: Iterate through elements 'val_b' starting from i+1\n        // This loop processes elements in chunks using SVE intrinsics\n        for (size_t j = i + 1; j < N; j += svcnt_f32()) {\n            // Create a predicate for active lanes. This handles partial vectors at the end\n            // of the 'numbers' array, ensuring operations only apply to valid elements.\n            svbool_t pg = svwhilelt_b32(j, N);\n\n            // Load a vector of 'val_b' elements from numbers[j] onwards\n            svfloat32_t vec_b = svld1_f32(pg, &numbers[j]);\n\n            // Calculate the absolute difference between vec_val_a and vec_b for active lanes.\n            // _x variant ensures inactive lanes are undisturbed.\n            svfloat32_t diff_vec = svabs_f32_x(pg, svsub_f32_x(pg, vec_val_a, vec_b));\n\n            // Find the minimum difference within this SVE vector chunk.\n            // svminv_f32 reduces the vector to a single scalar minimum value across active lanes.\n            float chunk_min_diff = svminv_f32(pg, diff_vec);\n\n            // If the minimum difference found in this chunk is strictly less than\n            // the global minimum difference found so far, update the global minimum.\n            if (chunk_min_diff < min_diff) {\n                min_diff = chunk_min_diff;\n\n                // Determine the actual number of active lanes in this chunk.\n                // svcnt_f32() gives the maximum possible lanes, but the predicate might mask some.\n                // This calculation ensures we only iterate over valid elements.\n                size_t num_active_lanes = svcnt_f32();\n                if (j + num_active_lanes > N) {\n                    num_active_lanes = N - j;\n                }\n\n                // To find the specific 'val_b' that resulted in 'min_diff',\n                // we need to store the vector data back to scalar memory and iterate.\n                // This is a common pattern when SVE doesn't offer a direct \"min_value_and_index\" reduction.\n                float temp_diffs[svcnt_f32()]; // Temporary array for differences\n                float temp_bs[svcnt_f32()];    // Temporary array for 'b' values\n                svst1_f32(pg, temp_diffs, diff_vec); // Store diff_vec to temp_diffs\n                svst1_f32(pg, temp_bs, vec_b);       // Store vec_b to temp_bs\n\n                // Iterate over the active lanes of the temporary arrays to find the\n                // element that matches the new 'min_diff'.\n                for (size_t k = 0; k < num_active_lanes; ++k) {\n                    if (temp_diffs[k] == min_diff) {\n                        float current_b = temp_bs[k];\n                        // Store the pair, ensuring the smaller number comes first.\n                        if (val_a < current_b) {\n                            result_val1 = val_a;\n                            result_val2 = current_b;\n                        } else {\n                            result_val1 = current_b;\n                            result_val2 = val_a;\n                        }\n                        break; // Found the first matching pair in this chunk, no need to check further.\n                    }\n                }\n            }\n        }\n    }\n\n    // Return the two closest numbers in a std::vector<float>.\n    std::vector<float> result;\n    result.push_back(result_val1);\n    result.push_back(result_val2);\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // For std::min, std::max\n#include <limits>    // For std::numeric_limits\n#include <cmath>     // For std::abs\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    // As per problem description, the input vector length is at least two.\n    // A safeguard for empty or single-element vectors, though not strictly required by problem.\n    if (numbers.size() < 2) {\n        return {}; \n    }\n\n    float min_diff;\n    float result_a;\n    float result_b;\n\n    // Initialize min_diff and the result pair with the first two elements.\n    // This ensures that even if the closest pair is (numbers[0], numbers[1])\n    // and no other pair yields a strictly smaller difference, the results are correct.\n    min_diff = std::abs(numbers[0] - numbers[1]);\n    result_a = std::min(numbers[0], numbers[1]);\n    result_b = std::max(numbers[0], numbers[1]);\n\n    const size_t N = numbers.size();\n    const size_t sv_len = svcnt_f32(); // Number of float elements in an SVE vector\n\n    // Outer loop: iterate through each number 'i'\n    for (size_t i = 0; i < N; ++i) {\n        float current_val_i = numbers[i];\n        // Broadcast numbers[i] into an SVE vector for parallel subtraction\n        svfloat32_t vec_val_i = svdup_f32(current_val_i);\n\n        // Inner loop: iterate through numbers 'j' starting from i+1\n        // Process in SVE vector chunks to leverage parallelism\n        for (size_t j = i + 1; j < N; j += sv_len) {\n            // Create a predicate for active lanes, handling vector tails\n            svbool_t pg = svwhilelt_b32(j, N);\n\n            // Load a chunk of numbers[j...j+sv_len-1] into an SVE vector\n            svfloat32_t vec_val_j_chunk = svld1(pg, &numbers[j]);\n\n            // Calculate absolute differences: |numbers[i] - numbers[j_chunk]|\n            svfloat32_t diffs = svabs_f32(svsub_f32(vec_val_i, vec_val_j_chunk));\n\n            // Find the minimum difference within this SVE vector 'diffs'\n            float chunk_min_diff = svmin_f32_reduction(pg, diffs);\n\n            // If this chunk's minimum difference is strictly less than the current global minimum,\n            // we have found a new closest pair.\n            if (chunk_min_diff < min_diff) {\n                // Update the global minimum difference\n                min_diff = chunk_min_diff;\n\n                // Now, we need to find the specific pair (numbers[i], numbers[j_k]) that produced this new minimum.\n                // This requires a scalar loop over the elements of the current SVE chunk.\n                // This loop runs at most `sv_len` times (typically small, e.g., 4, 8, 16).\n                for (size_t k = 0; k < sv_len; ++k) {\n                    size_t current_j_idx = j + k;\n                    // Check bounds to ensure we don't access beyond the vector size\n                    if (current_j_idx < N) {\n                        float diff = std::abs(current_val_i - numbers[current_j_idx]);\n                        \n                        // If this specific difference matches the new global minimum,\n                        // update the result pair and break (as we only need one such pair).\n                        // Using `==` is generally fine here because `min_diff` was just set\n                        // from `chunk_min_diff`, and `diff` is one of the values that contributed\n                        // to `chunk_min_diff`.\n                        if (diff == min_diff) {\n                            result_a = std::min(current_val_i, numbers[current_j_idx]);\n                            result_b = std::max(current_val_i, numbers[current_j_idx]);\n                            break; // Found the first pair for this new minimum, no need to check further in this chunk\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {result_a, result_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath>     // For std::abs\n#include <algorithm> // For std::min, std::swap\n#include <cfloat>    // For FLT_MAX\n#include <arm_sve.h> // SVE intrinsics\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t N = numbers.size();\n\n    // Handle edge cases as per problem description (length at least two)\n    if (N < 2) {\n        // Or throw an exception, depending on desired error handling\n        return {}; \n    }\n\n    // If only two elements, they are the closest\n    if (N == 2) {\n        if (numbers[0] <= numbers[1]) {\n            return {numbers[0], numbers[1]};\n        } else {\n            return {numbers[1], numbers[0]};\n        }\n    }\n\n    // Initialize global minimum difference and the corresponding pair\n    float global_min_diff = FLT_MAX;\n    float global_res_a = 0.0f;\n    float global_res_b = 0.0f;\n\n    // Outer loop iterates through each element numbers[i]\n    for (size_t i = 0; i < N; ++i) {\n        // Broadcast numbers[i] to an SVE vector\n        svfloat32_t val_i_bcast = svdup_f32(numbers[i]);\n\n        // Initialize SVE vectors to track the best pair for the current numbers[i]\n        // across all subsequent numbers[j] (j > i).\n        // current_i_min_diff_vec: stores the minimum difference found so far for each lane.\n        // current_i_res_a_vec: stores the first number of the pair (numbers[i]) for each lane.\n        // current_i_res_b_vec: stores the second number of the pair (numbers[j]) for each lane.\n        svfloat32_t current_i_min_diff_vec = svdup_f32(FLT_MAX);\n        svfloat32_t current_i_res_a_vec = svdup_f32(0.0f); // Placeholder, will be numbers[i]\n        svfloat32_t current_i_res_b_vec = svdup_f32(0.0f); // Placeholder, will be numbers[j]\n\n        // Inner loop iterates through subsequent elements numbers[j] in SVE vector chunks\n        // j starts from i + 1 to avoid comparing an element with itself and duplicate pairs.\n        for (size_t j = i + 1; j < N; j += svcnt_f32()) {\n            // Create a predicate for the active lanes in the current vector chunk\n            svbool_t pg = svwhilelt_b32(j, N);\n\n            // Load a vector of numbers[j...j+VL-1]\n            svfloat32_t val_j_vec = svld1_f32(pg, &numbers[j]);\n\n            // Calculate absolute differences: |numbers[i] - numbers[j]|\n            svfloat32_t diff_vec = svabs_f32(svsub_f32(val_i_bcast, val_j_vec));\n\n            // Compare current differences with the best differences found so far for this 'i'\n            // is_new_min_for_lane will be true for lanes where diff_vec[k] < current_i_min_diff_vec[k]\n            svbool_t is_new_min_for_lane = svcmplt_f32(pg, diff_vec, current_i_min_diff_vec);\n\n            // Update current_i_min_diff_vec: select new_diff if smaller, else keep old_diff\n            current_i_min_diff_vec = svsel_f32(is_new_min_for_lane, diff_vec, current_i_min_diff_vec);\n\n            // Update current_i_res_a_vec: select val_i_bcast if new min, else keep old val_a\n            current_i_res_a_vec = svsel_f32(is_new_min_for_lane, val_i_bcast, current_i_res_a_vec);\n\n            // Update current_i_res_b_vec: select val_j_vec if new min, else keep old val_b\n            current_i_res_b_vec = svsel_f32(is_new_min_for_lane, val_j_vec, current_i_res_b_vec);\n        }\n\n        // After the inner loop, current_i_min_diff_vec contains the minimum differences\n        // for each lane relative to numbers[i].\n        // Now, find the overall minimum difference within this vector.\n        float min_diff_for_i = svminv_f32(svptrue_b32(), current_i_min_diff_vec);\n\n        // If this minimum difference is better than the global minimum, update global results\n        if (min_diff_for_i < global_min_diff) {\n            global_min_diff = min_diff_for_i;\n\n            // Create a predicate for elements in current_i_min_diff_vec that are equal to min_diff_for_i.\n            // This mask identifies the lane(s) that hold the minimum difference for the current 'i'.\n            svbool_t min_mask = svcmpeq_f32(svptrue_b32(), current_i_min_diff_vec, svdup_f32(min_diff_for_i));\n\n            // Extract the corresponding numbers from current_i_res_a_vec and current_i_res_b_vec.\n            // svlasta_f32 extracts the last active element (where the predicate is true).\n            // If multiple pairs have the same minimum difference, this picks the one corresponding\n            // to the largest index in the vector register, which is an arbitrary but valid choice.\n            global_res_a = svlasta_f32(min_mask, current_i_res_a_vec);\n            global_res_b = svlasta_f32(min_mask, current_i_res_b_vec);\n        }\n    }\n\n    // Ensure the result is in order (smaller number, larger number)\n    if (global_res_a > global_res_b) {\n        std::swap(global_res_a, global_res_b);\n    }\n\n    return {global_res_a, global_res_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Required for std::sort\n#include <limits>    // Required for std::numeric_limits\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n\n    // As per the problem description, the input vector length is at least two.\n    // Handle edge case for safety, though it should not be hit.\n    if (n < 2) {\n        return {}; // Return an empty vector or throw an exception\n    }\n\n    // Step 1: Sort the input vector.\n    // After sorting, the two closest numbers in the array must be adjacent.\n    // This transforms the problem from an O(N^2) search to an O(N) scan after sorting.\n    // std::sort is not SVE-accelerated, but it's a standard and efficient pre-processing step.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Step 2: Initialize SVE accumulators for the minimum difference and the corresponding elements.\n    // `min_diff_vec_sve` will store the minimum difference found so far for each lane.\n    // Initialize it with positive infinity so any real difference will be smaller.\n    svfloat32_t min_diff_vec_sve = svdup_f32(std::numeric_limits<float>::infinity());\n    \n    // `result_a_vec_sve` and `result_b_vec_sve` will store the elements that produced\n    // the minimum difference in each lane. Their initial values don't strictly matter\n    // as they will be overwritten by the first valid comparison.\n    svfloat32_t result_a_vec_sve = svdup_f32(0.0f);\n    svfloat32_t result_b_vec_sve = svdup_f32(0.0f);\n\n    // Get the number of float elements that fit into an SVE vector.\n    const size_t VL = svcntw();\n\n    // Step 3: Loop through the sorted array in chunks, processing adjacent pairs using SVE.\n    // We iterate up to `n - 1` because we compare `numbers[i]` with `numbers[i+1]`.\n    // The last valid index for `i` is `n - 2`, so `i + 1` accesses up to `n - 1`.\n    for (size_t i = 0; i < n - 1; i += VL) {\n        // Create a predicate (mask) for the current chunk.\n        // `svwhilelt_b32(i, n - 1)` generates a mask that is true for elements\n        // starting from `i` as long as `i` is less than `n - 1`. This ensures\n        // we only process valid indices within the array bounds.\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n\n        // Load the current elements (numbers[i], numbers[i+1], ...) into `vec_curr`.\n        svfloat32_t vec_curr = svld1(pg, &numbers[i]);\n        // Load the next elements (numbers[i+1], numbers[i+2], ...) into `vec_next`.\n        svfloat32_t vec_next = svld1(pg, &numbers[i+1]);\n\n        // Calculate the difference between adjacent elements.\n        // Since the array is sorted, `numbers[i+1]` is always greater than or equal to `numbers[i]`,\n        // so `svabs_f32_x` (absolute difference) is not needed; simple subtraction suffices.\n        svfloat32_t diff_vec = svsub_f32_x(pg, vec_next, vec_curr);\n\n        // Compare the current differences (`diff_vec`) with the accumulated minimum differences (`min_diff_vec_sve`).\n        // `cmp_mask` will have true for lanes where `diff_vec` is strictly smaller than the current `min_diff_vec_sve` value.\n        svbool_t cmp_mask = svcmplt_f32(pg, diff_vec, min_diff_vec_sve);\n\n        // Update `min_diff_vec_sve`: For lanes where `cmp_mask` is true, select `diff_vec`;\n        // otherwise, keep the old `min_diff_vec_sve` value.\n        min_diff_vec_sve = svsel_f32(cmp_mask, diff_vec, min_diff_vec_sve);\n        \n        // Update `result_a_vec_sve`: For lanes where `cmp_mask` is true, select `vec_curr`;\n        // otherwise, keep the old `result_a_vec_sve` value.\n        result_a_vec_sve = svsel_f32(cmp_mask, vec_curr, result_a_vec_sve);\n        \n        // Update `result_b_vec_sve`: For lanes where `cmp_mask` is true, select `vec_next`;\n        // otherwise, keep the old `result_b_vec_sve` value.\n        result_b_vec_sve = svsel_f32(cmp_mask, vec_next, result_b_vec_sve);\n    }\n\n    // Step 4: Extract the global minimum difference and its corresponding elements.\n    // `svminv_f32` performs a horizontal reduction to find the single minimum value\n    // across all active lanes of `min_diff_vec_sve`. `svptrue_b32()` creates a predicate\n    // with all lanes active for this reduction.\n    float final_min_diff = svminv_f32(svptrue_b32(), min_diff_vec_sve);\n\n    // Create a mask (`final_mask`) for lanes where the accumulated minimum difference\n    // exactly equals the global minimum difference found.\n    svbool_t final_mask = svcmpeq_f32(svptrue_b32(), min_diff_vec_sve, svdup_f32(final_min_diff));\n\n    // Extract the first element from `result_a_vec_sve` that corresponds to a true lane in `final_mask`.\n    // If multiple pairs have the same minimum difference, `svfirst_f32` will pick the one\n    // that appeared earliest in the vector (corresponding to the earliest index in the sorted array).\n    float final_a = svfirst_f32(final_mask, result_a_vec_sve);\n    \n    // Extract the corresponding element from `result_b_vec_sve`.\n    float final_b = svfirst_f32(final_mask, result_b_vec_sve);\n\n    // Step 5: Return the result as a vector of two floats.\n    return {final_a, final_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n#include <limits>    // For std::numeric_limits\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    const size_t N = numbers.size();\n\n    // The problem statement guarantees a length of at least two.\n    // Handle N=2 explicitly as it's a simple base case and avoids loop complexities.\n    if (N == 2) {\n        if (numbers[0] <= numbers[1]) {\n            return {numbers[0], numbers[1]};\n        } else {\n            return {numbers[1], numbers[0]};\n        }\n    }\n\n    // Step 1: Sort the input vector.\n    // In a sorted array, the two closest elements must be adjacent.\n    // This simplifies the problem from O(N^2) to O(N log N) for sorting + O(N) for scan.\n    std::sort(numbers.begin(), numbers.end());\n\n    // Initialize scalar variables to store the final result\n    float min_diff = std::numeric_limits<float>::max();\n    float result_a = 0.0f;\n    float result_b = 0.0f;\n\n    // Initialize SVE vectors for accumulating minimums across lanes.\n    // Each lane in these vectors will track the minimum difference found so far\n    // for the pairs starting at its corresponding logical index, and the 'a' and 'b' values.\n    svfloat32_t min_diff_vec = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t closest_a_vec = svdup_f32(0.0f); // Placeholder, will be updated\n    svfloat32_t closest_b_vec = svdup_f32(0.0f); // Placeholder, will be updated\n\n    // Get the number of float elements per SVE vector at runtime.\n    // This allows the code to be portable across different SVE vector lengths.\n    const size_t sv_elements = svcntw();\n\n    // Step 2: Iterate through the sorted array, processing adjacent pairs in parallel using SVE.\n    // The loop runs up to N-1 because we access numbers[i] and numbers[i+1].\n    for (size_t i = 0; i < N - 1; i += sv_elements) {\n        // Create a predicate for active lanes.\n        // A lane 'k' is active if 'i + k' is a valid index for the current chunk,\n        // meaning 'i + k < N - 1'. This ensures that 'numbers[i+k]' and 'numbers[i+k+1]'\n        // are both valid indices within the bounds of the 'numbers' vector.\n        svbool_t pg = svwhilelt_b32(i, N - 1);\n\n        // Load current elements (numbers[i], numbers[i+1], ...) into an SVE vector.\n        svfloat32_t current_elements = svld1(pg, &numbers[i]);\n\n        // Load next elements (numbers[i+1], numbers[i+2], ...) into another SVE vector.\n        // The predicate 'pg' ensures that only valid elements are loaded for active lanes.\n        svfloat32_t next_elements = svld1(pg, &numbers[i + 1]);\n\n        // Calculate differences between adjacent elements.\n        // Since the array is sorted, `next_elements - current_elements` will be non-negative.\n        svfloat32_t current_diffs = svsub_f32(next_elements, current_elements);\n\n        // Compare current differences with the accumulated minimum differences in `min_diff_vec`.\n        // `cmp_lt` will have a true bit for lanes where `current_diffs` is less than `min_diff_vec`.\n        svbool_t cmp_lt = svcmplt_f32(pg, current_diffs, min_diff_vec);\n\n        // Update `min_diff_vec`, `closest_a_vec`, and `closest_b_vec` using `svsel_f32`.\n        // For lanes where `cmp_lt` is true, update with the new smaller difference and corresponding pair.\n        // Otherwise, keep the existing values.\n        min_diff_vec = svsel_f32(cmp_lt, current_diffs, min_diff_vec);\n        closest_a_vec = svsel_f32(cmp_lt, current_elements, closest_a_vec);\n        closest_b_vec = svsel_f32(cmp_lt, next_elements, closest_b_vec);\n    }\n\n    // Step 3: Reduce the SVE vectors to find the overall minimum difference and corresponding pair.\n\n    // Find the overall minimum difference from `min_diff_vec` across all lanes.\n    // `svptrue_b32()` creates a predicate where all lanes are active for the reduction.\n    min_diff = svmin_f32_reduce(svptrue_b32(), min_diff_vec);\n\n    // Find the lane(s) that contain this overall minimum difference.\n    // This mask will have true bits for all lanes in `min_diff_vec` that hold the `min_diff`.\n    svbool_t final_min_mask = svcmpeq_f32(svptrue_b32(), min_diff_vec, svdup_f32(min_diff));\n\n    // To extract the corresponding `a` and `b` values, we can store the SVE vectors\n    // to temporary arrays and then iterate through them. This scalar loop is small\n    // (at most `svcntw()` iterations, typically 4, 8, or 16), so its overhead is minimal.\n    std::vector<float> temp_min_diff(sv_elements);\n    std::vector<float> temp_closest_a(sv_elements);\n    std::vector<float> temp_closest_b(sv_elements);\n\n    svst1(svptrue_b32(), temp_min_diff.data(), min_diff_vec);\n    svst1(svptrue_b32(), temp_closest_a.data(), closest_a_vec);\n    svst1(svptrue_b32(), temp_closest_b.data(), closest_b_vec);\n\n    // Iterate through the temporary arrays to find the first pair that matches the overall minimum difference.\n    for (size_t k = 0; k < sv_elements; ++k) {\n        // Check if this lane contains the overall minimum difference.\n        // Direct equality comparison is safe here because `min_diff` was derived directly from `min_diff_vec`.\n        if (temp_min_diff[k] == min_diff) {\n            result_a = temp_closest_a[k];\n            result_b = temp_closest_b[k];\n            break; // Found the first pair, no need to check further\n        }\n    }\n\n    // Return the two closest elements in order (smaller, larger).\n    // Since the input was sorted, `result_a` will always be <= `result_b`.\n    return {result_a, result_b};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    const size_t num_elements = numbers.size();\n    if (num_elements < 2) {\n        return numbers;\n    }\n\n    float min_val_scalar = std::numeric_limits<float>::max();\n    float max_val_scalar = std::numeric_limits<float>::lowest();\n\n    svfloat32_t min_vec_sve = svdup_f32(min_val_scalar);\n    svfloat32_t max_vec_sve = svdup_f32(max_val_scalar);\n\n    size_t i = 0;\n    while (i < num_elements) {\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        svfloat32_t current_vec = svld1(pg, &numbers[i]);\n        min_vec_sve = svmin_f32(min_vec_sve, current_vec);\n        max_vec_sve = svmax_f32(max_vec_sve, current_vec);\n\n        i += svcntw();\n    }\n\n    min_val_scalar = svminv_f32(svptrue_b32(), min_vec_sve);\n    max_val_scalar = svmaxv_f32(svptrue_b32(), max_vec_sve);\n\n    float range = max_val_scalar - min_val_scalar;\n    std::vector<float> result(num_elements);\n\n    if (range == 0.0f) {\n        std::fill(result.begin(), result.end(), 0.0f);\n        return result;\n    }\n\n    float inv_range = 1.0f / range;\n\n    svfloat32_t min_vec_dup = svdup_f32(min_val_scalar);\n    svfloat32_t inv_range_vec_dup = svdup_f32(inv_range);\n\n    i = 0;\n    while (i < num_elements) {\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        svfloat32_t current_vec = svld1(pg, &numbers[i]);\n        svfloat32_t diff_vec = svsub_f32(current_vec, min_vec_dup);\n        svfloat32_t rescaled_vec = svmul_f32(diff_vec, inv_range_vec_dup);\n        svst1(pg, &result[i], rescaled_vec);\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return {};\n    }\n    if (n == 1) {\n        return {0.0f}; // A single element is rescaled to 0.0\n    }\n\n    // --- Step 1 & 2: Find min and max values using SVE ---\n    // Get the number of 32-bit elements (floats) in an SVE vector.\n    // svcntw() returns the number of 32-bit elements.\n    // The predicate `pg` is used to control which lanes are active for the entire vector.\n    svbool_t pg_all = svwhilelt_b32(0, n);\n\n    // Initialize SVE min/max accumulators with extreme values\n    svfloat32_t min_vec_acc = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t max_vec_acc = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Loop through the input vector in SVE chunks to find min/max\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the current chunk, handling partial vectors at the end\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Load current chunk into an SVE vector\n        svfloat32_t current_vec = svld1_f32(p, &numbers[i]);\n        \n        // Update min and max accumulators\n        min_vec_acc = svmin_f32(min_vec_acc, current_vec);\n        max_vec_acc = svmax_f32(max_vec_acc, current_vec);\n    }\n\n    // Reduce the SVE min/max vectors to scalar values\n    float min_val = svminv_f32(pg_all, min_vec_acc);\n    float max_val = svmaxv_f32(pg_all, max_vec_acc);\n\n    // --- Step 3: Handle edge case (max_val == min_val) ---\n    std::vector<float> result(n);\n    float diff = max_val - min_val;\n    const float epsilon = 1e-6f; // A small epsilon for floating-point comparison\n\n    if (diff < epsilon && diff > -epsilon) { // Check if diff is close to zero\n        // All elements are the same, so they all become 0.0\n        for (size_t i = 0; i < n; ++i) {\n            result[i] = 0.0f;\n        }\n        return result;\n    }\n\n    // --- Step 4: Apply transformation using SVE ---\n    // Create SVE vectors for min_val and diff (max_val - min_val)\n    svfloat32_t min_sve = svdup_f32(min_val);\n    svfloat32_t diff_sve = svdup_f32(diff);\n\n    // Loop through the input vector again to apply the transformation\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the current chunk\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Load current chunk into an SVE vector\n        svfloat32_t current_vec = svld1_f32(p, &numbers[i]);\n\n        // Perform (current_vec - min_sve) / diff_sve\n        svfloat32_t temp_sub = svsub_f32(current_vec, min_sve);\n        svfloat32_t res_vec = svdiv_f32(temp_sub, diff_sve);\n\n        // Store the results back into the output vector\n        svst1_f32(p, &result[i], res_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n\n    if (n < 2) {\n        return numbers;\n    }\n\n    // 1. Find min and max values using SVE\n    // Initialize SVE vectors for reduction with extreme values\n    svfloat32_t min_vec = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Loop through the input vector in chunks to find global min/max\n    for (size_t i = 0; i < n; i += svcnt_f32()) {\n        svbool_t pg = svwhilelt_b32(i, n); // Predicate for current chunk\n        svfloat32_t current_chunk = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32(min_vec, current_chunk);\n        max_vec = svmax_f32(max_vec, current_chunk);\n    }\n\n    // Reduce SVE vectors to scalar min/max values\n    float min_val = svmin_f32_reduction(svptrue_b32(), min_vec);\n    float max_val = svmax_f32_reduction(svptrue_b32(), max_vec);\n\n    float range = max_val - min_val;\n\n    // Prepare output vector\n    std::vector<float> result(n);\n\n    // 2. Apply transformation\n    if (range == 0.0f) {\n        // All elements are the same, rescale to 0.0\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        for (size_t i = 0; i < n; i += svcnt_f32()) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svst1_f32(pg, &result[i], zero_vec);\n        }\n    } else {\n        // Broadcast min_val and 1.0/range to SVE vectors\n        svfloat32_t min_vec_scalar = svdup_f32(min_val);\n        svfloat32_t inv_range_vec = svdup_f32(1.0f / range);\n\n        for (size_t i = 0; i < n; i += svcnt_f32()) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svfloat32_t current_chunk = svld1_f32(pg, &numbers[i]);\n\n            // Calculate (current_chunk - min_val)\n            svfloat32_t subtracted = svsub_f32(current_chunk, min_vec_scalar);\n\n            // Calculate (subtracted) * (1.0 / range)\n            svfloat32_t transformed = svmul_f32(subtracted, inv_range_vec);\n\n            // Store the results into the output vector\n            svst1_f32(pg, &result[i], transformed);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    const size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return {};\n    }\n\n    // SVE vector length for float elements\n    const size_t sv_len = svcntf();\n\n    // 1. Find min and max values using SVE\n    float min_val = std::numeric_limits<float>::max();\n    float max_val = std::numeric_limits<float>::lowest();\n\n    // Initialize SVE accumulators for min and max\n    svfloat32_t sv_min_acc = svdup_f32(min_val);\n    svfloat32_t sv_max_acc = svdup_f32(max_val);\n\n    size_t i = 0;\n    // Loop through the vector in chunks determined by SVE vector length\n    svbool_t pg_minmax = svwhilelt_b32(i, num_elements);\n    while (svptest_any(svptrue_b32(), pg_minmax)) {\n        svfloat32_t current_vec = svld1(pg_minmax, &numbers[i]);\n\n        sv_min_acc = svmin_f32(sv_min_acc, current_vec);\n        sv_max_acc = svmax_f32(sv_max_acc, current_vec);\n\n        i += sv_len;\n        pg_minmax = svwhilelt_b32(i, num_elements);\n    }\n\n    // Reduce the SVE accumulators to scalar values\n    min_val = svminv_f32(svptrue_b32(), sv_min_acc);\n    max_val = svmaxv_f32(svptrue_b32(), sv_max_acc);\n\n    // Prepare the result vector\n    std::vector<float> result(num_elements);\n\n    // 2. Calculate range and inverse range\n    float range = max_val - min_val;\n\n    // Handle edge case: all elements are the same (range is zero)\n    if (range == 0.0f) {\n        size_t j = 0;\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        svbool_t pg_store_zero = svwhilelt_b32(j, num_elements);\n        while (svptest_any(svptrue_b32(), pg_store_zero)) {\n            svst1(pg_store_zero, &result[j], zero_vec);\n            j += sv_len;\n            pg_store_zero = svwhilelt_b32(j, num_elements);\n        }\n        return result;\n    }\n\n    float inv_range = 1.0f / range;\n\n    // Create SVE vectors for min_val and inv_range, duplicated across lanes\n    svfloat32_t sv_min_val = svdup_f32(min_val);\n    svfloat32_t sv_inv_range = svdup_f32(inv_range);\n\n    // 3. Apply the transformation using SVE\n    size_t k = 0;\n    svbool_t pg_transform = svwhilelt_b32(k, num_elements);\n    while (svptest_any(svptrue_b32(), pg_transform)) {\n        svfloat32_t current_vec = svld1(pg_transform, &numbers[k]);\n\n        // Perform (current_vec - sv_min_val) * sv_inv_range\n        svfloat32_t transformed_vec = svmul_f32(svsub_f32(current_vec, sv_min_val), sv_inv_range);\n\n        svst1(pg_transform, &result[k], transformed_vec);\n\n        k += sv_len;\n        pg_transform = svwhilelt_b32(k, num_elements);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    const size_t num_elements = numbers.size();\n\n    // According to the problem description, the vector has at least two elements.\n    // If it were empty or had one element, min/max would be trivial or undefined.\n\n    // 1. Find the minimum and maximum values using SVE.\n    // Initialize SVE vectors for min/max accumulation.\n    // Use svdup_f32 to broadcast scalar initial values to all lanes of the SVE vector.\n    svfloat32_t sve_min_val_acc = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t sve_max_val_acc = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Get the number of float elements an SVE vector can hold.\n    const size_t sv_len = svcntw();\n\n    // Predicate for full SVE vector operations (all lanes active).\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    // Process full SVE vector chunks.\n    for (; i + sv_len <= num_elements; i += sv_len) {\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n        sve_min_val_acc = svmin_f32(pg, sve_min_val_acc, current_vec);\n        sve_max_val_acc = svmax_f32(pg, sve_max_val_acc, current_vec);\n    }\n\n    // Process remaining tail elements (if any).\n    if (i < num_elements) {\n        // Create a predicate for the tail, activating only the necessary lanes.\n        svbool_t pg_tail = svwhilelt_b32(i, num_elements);\n        svfloat32_t current_vec = svld1_f32(pg_tail, &numbers[i]);\n        sve_min_val_acc = svmin_f32(pg_tail, sve_min_val_acc, current_vec);\n        sve_max_val_acc = svmax_f32(pg_tail, sve_max_val_acc, current_vec);\n    }\n\n    // Reduce the SVE accumulated min/max vectors to scalar values.\n    float min_val = svminv_f32(pg, sve_min_val_acc);\n    float max_val = svmaxv_f32(pg, sve_max_val_acc);\n\n    // Create the result vector.\n    std::vector<float> result(num_elements);\n\n    // 2. Handle the edge case where all numbers are the same (range is zero).\n    // In this case, all elements should be transformed to 0.0.\n    if (max_val - min_val == 0.0f) {\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        i = 0; // Reset index for storing results.\n        for (; i + sv_len <= num_elements; i += sv_len) {\n            svst1_f32(pg, &result[i], zero_vec);\n        }\n        if (i < num_elements) {\n            svbool_t pg_tail = svwhilelt_b32(i, num_elements);\n            svst1_f32(pg_tail, &result[i], zero_vec);\n        }\n        return result;\n    }\n\n    // 3. Apply the linear transformation: (number - min_val) / (max_val - min_val).\n    float range = max_val - min_val;\n    float inv_range = 1.0f / range;\n\n    // Broadcast min_val and inverse range to SVE vectors for element-wise operations.\n    svfloat32_t sve_min_scalar = svdup_f32(min_val);\n    svfloat32_t sve_inv_range_scalar = svdup_f32(inv_range);\n\n    i = 0; // Reset index for transformation loop.\n    // Process full SVE vector chunks.\n    for (; i + sv_len <= num_elements; i += sv_len) {\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n        // (current_vec - min_val)\n        svfloat32_t numerator_vec = svsub_f32(pg, current_vec, sve_min_scalar);\n        // (numerator_vec * inv_range)\n        svfloat32_t transformed_vec = svmul_f32(pg, numerator_vec, sve_inv_range_scalar);\n        svst1_f32(pg, &result[i], transformed_vec);\n    }\n\n    // Process remaining tail elements (if any).\n    if (i < num_elements) {\n        svbool_t pg_tail = svwhilelt_b32(i, num_elements);\n        svfloat32_t current_vec = svld1_f32(pg_tail, &numbers[i]);\n        svfloat32_t numerator_vec = svsub_f32(pg_tail, current_vec, sve_min_scalar);\n        svfloat32_t transformed_vec = svmul_f32(pg_tail, numerator_vec, sve_inv_range_scalar);\n        svst1_f32(pg_tail, &result[i], transformed_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    // Handle edge cases for n <= 2.\n    // For n=1, there is no divisor smaller than n.\n    // For n=2, the largest divisor smaller than n is 1.\n    if (n <= 2) {\n        return 1;\n    }\n\n    // Start searching for divisors from n/2 downwards.\n    // The largest possible divisor (excluding n itself) is n/2.\n    uint64_t current_k = n / 2;\n\n    // Loop while current_k is still a potential divisor (i.e., >= 1).\n    while (current_k >= 1) {\n        // Generate a vector of potential divisors in decreasing order:\n        // [current_k, current_k - 1, current_k - 2, ..., current_k - VL + 1]\n        svuint64_t v_divisors = svindex_u64(current_k, -1);\n\n        // Create a predicate to ensure we only consider divisors that are >= 1.\n        // This handles cases where current_k is small and svindex generates 0 or negative values.\n        svbool_t p_valid_divisors = svcmpge_u64(svptrue_b64(), v_divisors, svdup_u64(1));\n\n        // Duplicate 'n' into a vector for parallel modulo operations.\n        svuint64_t v_n = svdup_u64(n);\n\n        // Perform the modulo operation (n % divisor) for active lanes.\n        // Inactive lanes (where p_valid_divisors is false) will be zeroed out.\n        svuint64_t v_remainder = svmod_u64_z(p_valid_divisors, v_n, v_divisors);\n\n        // Check which remainders are zero, indicating a divisor.\n        svbool_t p_found_divisor = svcmpeq_u64(p_valid_divisors, v_remainder, svdup_u64(0));\n\n        // If any divisor is found in the current vector chunk:\n        if (svptest_any(svptrue_b64(), p_found_divisor)) {\n            // Since v_divisors was generated in decreasing order, the first true lane\n            // (from left to right) in p_found_divisor corresponds to the largest divisor\n            // found in this vector chunk.\n            // svclz_b64 counts the number of leading false bits, which is the index\n            // of the first true bit.\n            int first_true_lane_idx = svclz_b64(p_found_divisor);\n            return svget_lane_u64(v_divisors, first_true_lane_idx);\n        }\n\n        // Move to the next chunk of potential divisors.\n        // svcntd() returns the number of elements in a vector (VL).\n        current_k -= svcntd();\n    }\n\n    // If the loop completes without finding any divisor (this would only happen\n    // if n is prime, in which case the largest divisor smaller than n is 1).\n    // The loop will eventually check 1, and n % 1 will be 0, so 1 will be returned.\n    // This line should theoretically not be reached for n > 2.\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    // Handle edge cases for n <= 2. The largest divisor smaller than n is 1.\n    if (n <= 2) {\n        return 1;\n    }\n\n    // Start checking from n/2 downwards.\n    uint64_t current_val = n / 2;\n\n    // Loop while there are potential divisors (current_val >= 1).\n    while (current_val >= 1) {\n        // Get the current vector length for uint64_t elements.\n        uint64_t vl = svcntd();\n\n        // Create a predicate for active lanes.\n        // This predicate is true for values from current_val down to 1.\n        svbool_t pg = svwhilege_b64(current_val, 1);\n\n        // If no lanes are active (i.e., current_val has dropped below 1), break the loop.\n        if (!svptest_any(svptrue_b64(), pg)) {\n            break;\n        }\n\n        // Generate a vector of decreasing numbers starting from current_val.\n        // v_i will contain [current_val, current_val-1, current_val-2, ..., current_val-vl+1].\n        svuint64_t v_i = svindex_u64(current_val, -1);\n\n        // Broadcast n to all lanes of a vector.\n        svuint64_t vn = svdup_u64(n);\n\n        // Calculate remainder: n % v_i = n - (n / v_i) * v_i\n        // Use masked operations (svdiv_u64_m, svmul_u64_m, svsub_u64_m) to ensure\n        // operations are only performed on active lanes defined by 'pg'.\n        // The first predicate (svptrue_b64()) indicates that all lanes are potentially available,\n        // while 'pg' selects the active lanes for the operation.\n        svuint64_t v_quotient = svdiv_u64_m(svptrue_b64(), pg, vn, v_i);\n        svuint64_t v_product = svmul_u64_m(svptrue_b64(), pg, v_quotient, v_i);\n        svuint64_t v_remainder = svsub_u64_m(svptrue_b64(), pg, vn, v_product);\n\n        // Check which remainders are zero (i.e., which v_i elements are divisors of n).\n        svbool_t is_divisor = svcmpeq_u64(pg, v_remainder, 0);\n\n        // If any divisor is found in the current vector of potential divisors.\n        if (svptest_any(pg, is_divisor)) {\n            // We need to find the largest divisor. Since v_i is decreasing,\n            // the largest divisor corresponds to the smallest index 'k' in v_i\n            // for which is_divisor[k] is true.\n            // Create a vector of indices [0, 1, 2, ..., vl-1].\n            svuint64_t indices = svindex_u64(0, 1);\n\n            // Select the indices corresponding to divisors. For non-divisors, use a sentinel value (~0ULL).\n            svuint64_t divisor_indices = svsel_u64(is_divisor, indices, svdup_u64(~0ULL));\n\n            // Find the minimum index among the active lanes.\n            uint64_t min_idx = svmin_u64_x(pg, divisor_indices);\n\n            // If min_idx is not the sentinel value, a divisor was found.\n            if (min_idx != ~0ULL) {\n                // The largest divisor in this vector is current_val - min_idx.\n                return current_val - min_idx;\n            }\n        }\n\n        // Decrement current_val by the vector length for the next iteration.\n        // This ensures we check the next batch of potential divisors.\n        // Handle potential underflow if current_val is less than vl.\n        if (current_val < vl) {\n            current_val = 0; // Set to 0 to terminate the loop in the next iteration.\n        } else {\n            current_val -= vl;\n        }\n    }\n\n    // If the loop completes without finding any divisor (e.g., n is prime),\n    // the largest divisor smaller than n is 1. This case is implicitly handled\n    // by the loop reaching current_val=1 and finding 1 as a divisor.\n    // This return is a fallback, though it should ideally not be reached for n > 2.\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    // Handle edge case for n=1, as there's no divisor smaller than 1.\n    // The problem implies n > 1 by asking for a divisor \"smaller than n\".\n    // For n=1, the loop condition (current_val >= 1) will be false if n/2 is 0.\n    // If n=1, the largest divisor is 1, but it's not smaller than n.\n    // If the problem expects a specific return for n=1 (e.g., 0 or 1),\n    // it should be clarified. Assuming n >= 2 based on problem context.\n    if (n == 1) {\n        return 0; // Or handle as an error, or return 1 if 1 is considered the largest divisor not strictly smaller than n.\n                  // For this problem, 0 indicates no such divisor found.\n    }\n\n    uint64_t current_val = n / 2;\n    uint64_t vl = svcntd(); // Get the number of 64-bit elements in an SVE vector\n\n    // Broadcast n into an SVE vector\n    svuint64_t n_vec = svset_u64(n);\n\n    while (current_val >= 1) {\n        // Create a predicate for the current chunk of values, ensuring they are >= 1\n        // This predicate will be true for values: current_val, current_val-1, ..., 1\n        svbool_t pg = svwhilege_b64(current_val, 1);\n\n        // Generate a vector of decreasing values: current_val, current_val-1, current_val-2, ...\n        // svindex_u64(0, 1) generates [0, 1, 2, 3, ...]\n        // svset_u64(current_val) broadcasts current_val to all elements\n        svuint64_t values = svsub_u64(svset_u64(current_val), svindex_u64(0, 1));\n\n        // Calculate remainders: n % values.\n        // The operation is only performed for elements where 'pg' is true.\n        // This prevents division by zero for values that might be 0 or negative if not masked by 'pg'.\n        svuint64_t remainder_vec = svmod_u64_m(pg, n_vec, values);\n\n        // Check which elements result in a zero remainder (i.e., are divisors)\n        svbool_t is_divisor_pg = svcmpeq_u64(pg, remainder_vec, svset_u64(0));\n\n        // If any divisor is found in this chunk\n        if (svptest_any(svptrue_b64(), is_divisor_pg)) {\n            // Select the divisors from the 'values' vector, setting non-divisors to 0\n            svuint64_t divisors_in_chunk = svsel_u64(is_divisor_pg, values, svset_u64(0));\n\n            // Find the maximum value among the divisors found in this chunk.\n            // Since we are iterating downwards from n/2, the first non-zero\n            // maximum found will be the largest divisor smaller than n.\n            uint64_t max_divisor_in_chunk = svmax_u64_x(svptrue_b64(), divisors_in_chunk);\n\n            // If max_divisor_in_chunk is greater than 0, it means we found a valid divisor.\n            // Since we are searching in decreasing order, this is the largest one.\n            if (max_divisor_in_chunk > 0) {\n                return max_divisor_in_chunk;\n            }\n        }\n\n        // Move to the next chunk of values\n        // Ensure current_val doesn't underflow if vl is larger than current_val\n        if (current_val <= vl) {\n            current_val = 0; // Stop the loop\n        } else {\n            current_val -= vl;\n        }\n    }\n\n    // This part should ideally not be reached for n > 1, as 1 is always a divisor.\n    // If n=1, it returns 0 at the beginning.\n    // If n > 1, the loop will eventually reach current_val = 1, find 1 as a divisor, and return 1.\n    return 1; // Fallback: for n > 1, 1 is always the smallest positive divisor.\n              // This line would only be reached if the loop somehow failed to find 1, which it shouldn't.\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    // Handle edge cases:\n    // For n=0 or n=1, there is no divisor smaller than n.\n    // The problem implies n is a positive number.\n    if (n <= 1) {\n        return 0; \n    }\n\n    // Start searching for divisors from n/2 downwards.\n    // The largest possible divisor (excluding n itself) is n/2.\n    uint64_t current_divisor_candidate = n / 2;\n\n    // Loop while there are potential divisor candidates greater than or equal to 1.\n    // The loop will always find a divisor (at least 1) and return from within.\n    while (current_divisor_candidate >= 1) {\n        // Create a predicate for active lanes.\n        // svwhilege_b64(current_divisor_candidate, 1) generates a predicate that is true\n        // for elements starting from current_divisor_candidate down to 1, and false otherwise.\n        // This ensures we only process valid divisor candidates (>= 1).\n        svbool_t active_lanes = svwhilege_b64(current_divisor_candidate, 1);\n\n        // Generate a vector of decreasing divisor candidates.\n        // svindex_u64(start, step) generates a sequence: start, start+step, start+2*step, ...\n        // Here, it generates [current_divisor_candidate, current_divisor_candidate-1, current_divisor_candidate-2, ...]\n        svuint64_t divisors_vec = svindex_u64(current_divisor_candidate, -1);\n\n        // Duplicate 'n' into a vector so it can be used in vector operations.\n        svuint64_t n_vec = svdup_u64(n);\n\n        // Perform vector division: n_vec / divisors_vec.\n        // The _x suffix means predicated execution: operations are only performed for active lanes.\n        svuint64_t quotient = svdiv_u64_x(active_lanes, n_vec, divisors_vec);\n\n        // Calculate the product: quotient * divisors_vec.\n        svuint64_t product = svmul_u64_x(active_lanes, quotient, divisors_vec);\n\n        // Calculate the remainder: n_vec - product.\n        // If remainder is 0, the corresponding divisor_vec element is a divisor of n.\n        svuint64_t remainder = svsub_u64_x(active_lanes, n_vec, product);\n\n        // Create a predicate where the remainder is 0.\n        // This predicate identifies which elements in divisors_vec are actual divisors of n.\n        svbool_t is_divisor_pred = svcmpeq_u64(active_lanes, remainder, svdup_u64(0));\n\n        // Check if any divisor was found in the current vector chunk.\n        // svptest_any(pg, p) returns true if any element in predicate 'p' is true,\n        // considering only the lanes where 'pg' is true.\n        if (svptest_any(active_lanes, is_divisor_pred)) {\n            // A divisor was found. Since we are iterating downwards (from n/2),\n            // the first divisor found in this decreasing vector chunk will be the largest.\n            \n            // svbrka_b64(pg, p) creates a new predicate. It is true for all elements\n            // for which 'pg' is true and 'p' is false, up to and including the first\n            // element for which both 'pg' and 'p' are true. All subsequent elements are false.\n            // This effectively isolates the first (largest) divisor found in the current chunk.\n            svbool_t first_found_pred = svbrka_b64(active_lanes, is_divisor_pred);\n            \n            // svlasta_u64(pg, vec) returns the value of the last active element in 'vec'\n            // according to predicate 'pg'. With 'first_found_pred', this will be the value\n            // of the first divisor found in the current chunk (which is the largest).\n            return svlasta_u64(first_found_pred, divisors_vec);\n        }\n\n        // If no divisor was found in the current chunk, update current_divisor_candidate.\n        // We continue searching from the number just before the last element processed in this chunk.\n        // svlasta_u64(active_lanes, divisors_vec) gives the value of the last active element\n        // in the current 'divisors_vec' (e.g., if VL=4 and current_divisor_candidate=7,\n        // divisors_vec is [7,6,5,4], and this returns 4).\n        // Subtracting 1 sets the starting point for the next iteration (e.g., 3).\n        current_divisor_candidate = svlasta_u64(active_lanes, divisors_vec) - 1;\n    }\n\n    // This part of the code should theoretically be unreachable for n > 1,\n    // because 1 is always a divisor of any positive integer, and the loop\n    // will eventually check 1 and return. It's included for completeness\n    // or to satisfy compiler warnings, returning 1 as the largest divisor\n    // smaller than n (which is true for prime numbers).\n    return 1; \n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) {\n        return 0;\n    }\n\n    svuint64_t sv_n = svdup_n_u64(n);\n    uint64_t vl = svcntd();\n    uint64_t current_val = n - 1;\n\n    while (current_val >= 1) {\n        svuint64_t divisors_candidate = svindex_u64(current_val, -1);\n        svbool_t pg = svwhilege_b64(current_val, 1);\n        svuint64_t remainder = svmod_u64_z(pg, sv_n, divisors_candidate);\n        svbool_t is_divisor = svcmpeq_u64(pg, remainder, svdup_n_u64(0));\n\n        if (svptest_any(svptrue_b64(), is_divisor)) {\n            svuint64_t found_divs_in_vec = svsel_u64(is_divisor, divisors_candidate, svdup_n_u64(0));\n            uint64_t largest_found = svmax_u64_z(svptrue_b64(), found_divs_in_vec);\n            if (largest_found != 0) {\n                return largest_found;\n            }\n        }\n\n        if (current_val < vl) {\n            current_val = 0;\n        } else {\n            current_val -= vl;\n        }\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // For std::iota if needed, but svindex_s32 is better for SVE\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int temp_n = n;\n\n    // Handle factor 2: This step is inherently sequential and not easily parallelized\n    // for a single number 'n' using SVE.\n    while (temp_n % 2 == 0) {\n        factors.push_back(2);\n        temp_n /= 2;\n    }\n\n    // Get the vector length for 32-bit integers.\n    // This determines how many trial divisors can be checked in parallel.\n    const int VL = svcntw();\n\n    // Loop for odd factors.\n    // 'i' represents the starting point for a batch of trial divisors.\n    // The loop condition `i * i <= temp_n` ensures we only check up to sqrt(temp_n).\n    // We use `long long` for `i * i` to prevent potential overflow for large `i`.\n    for (long long i = 3; i * i <= temp_n; /* increment handled inside */) {\n        // Create a vector of trial divisors: [i, i+2, i+4, ..., i + 2*(VL-1)]\n        // svindex_s32(0, 1) generates [0, 1, 2, ..., VL-1].\n        // Multiplying by 2 gives [0, 2, 4, ..., 2*(VL-1)].\n        // Adding 'i' shifts this to the desired sequence.\n        svint32_t offsets = svmul_n_s32(svindex_s32(0, 1), 2);\n        svint32_t trial_divisors_vec = svadd_n_s32(offsets, i);\n\n        // Broadcast the current 'temp_n' to all lanes of a vector.\n        svint32_t current_n_vec = svdup_n_s32(temp_n);\n\n        // Predicate for active lanes (all lanes initially active).\n        svbool_t pg = svptrue_b32();\n\n        // Compute remainders for all trial divisors in the vector in parallel.\n        svint32_t remainders = svrem_s32(pg, current_n_vec, trial_divisors_vec);\n\n        // Check which divisors result in a remainder of 0 (i.e., are factors).\n        svbool_t is_divisor_mask = svcmpeq_n_s32(pg, remainders, 0);\n\n        // Filter out divisors that are too large. The outer loop condition `i * i <= temp_n`\n        // only applies to the starting divisor `i`. Individual elements in `trial_divisors_vec`\n        // might exceed `sqrt(temp_n)`.\n        svint32_t trial_divisors_squared_vec = svmul_s32(pg, trial_divisors_vec, trial_divisors_vec);\n        svbool_t too_large_mask = svcmpgt_n_s32(pg, trial_divisors_squared_vec, temp_n);\n        \n        // Combine masks: a divisor is valid if it divides temp_n AND it's not too large.\n        // svbic_b (Bitwise Clear) clears bits in `is_divisor_mask` where `too_large_mask` is true.\n        is_divisor_mask = svbic_b(pg, is_divisor_mask, too_large_mask);\n\n        // Check if any valid factor was found in this batch of trial divisors.\n        if (svptest_any(pg, is_divisor_mask)) {\n            // If factors are found, we need to process the smallest one first.\n            // Create a vector where actual divisors are kept, and non-divisors are replaced\n            // with a sentinel value (e.g., n + 1, which is guaranteed to be larger than any factor).\n            svint32_t actual_divisors = svsel_s32(is_divisor_mask, trial_divisors_vec, svdup_n_s32(n + 1));\n            \n            // Find the minimum value among the actual divisors using SVE reduction.\n            int smallest_factor_in_batch = svmin_s32(pg, actual_divisors);\n\n            // Process this smallest factor. It's guaranteed to be a factor of the current temp_n.\n            // This inner loop is sequential as temp_n changes with each division.\n            while (temp_n % smallest_factor_in_batch == 0) {\n                factors.push_back(smallest_factor_in_batch);\n                temp_n /= smallest_factor_in_batch;\n            }\n            \n            // After processing the factor, we must adjust 'i' to continue the search\n            // from this factor. Setting 'i' to `smallest_factor_in_batch` ensures that\n            // the next iteration of the outer loop will start checking from this value\n            // (or the next odd number if `smallest_factor_in_batch` was even, but we only check odds).\n            // This effectively restarts the search for the next factor from the point where the last one was found.\n            i = smallest_factor_in_batch;\n        } else {\n            // No factor found in this batch of VL trial divisors.\n            // Move to the next batch by incrementing 'i' by 2 * VL.\n            i += 2 * VL;\n        }\n    }\n\n    // If temp_n is still greater than 1 after the loop, it means the remaining temp_n\n    // is a prime factor itself (it must be greater than sqrt(original_n) or it would have been found).\n    if (temp_n > 1) {\n        factors.push_back(temp_n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath> // For std::sqrt\n#include <arm_sve.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int current_n = n;\n\n    // Handle factor 2\n    // This part is inherently sequential as 'current_n' changes with each division.\n    while (current_n % 2 == 0) {\n        factors.push_back(2);\n        current_n /= 2;\n    }\n\n    // Handle odd factors using SVE for parallel trial division\n    int d = 3; // Start checking from the first odd prime\n    \n    // Get the SVE predicate for all active lanes and the current vector length (VL)\n    svbool_t pg = svptrue_b32();\n    int vl = svcntp_b32(pg, pg); \n\n    // Loop while there's still a number to factor and potential divisors to check\n    while (current_n > 1) {\n        // Recalculate the limit for trial division (sqrt(current_n))\n        int limit = static_cast<int>(std::sqrt(current_n));\n\n        // If the current trial divisor 'd' exceeds the limit,\n        // it means 'current_n' must be prime (or 1), so we can stop.\n        if (d > limit) {\n            break;\n        }\n\n        // Create a vector of trial divisors starting from 'd' and incrementing by 2.\n        // Example: if d=3 and VL=4, trial_divisors will be [3, 5, 7, 9]\n        svint32_t offsets = svindex_s32(0, 1); // Generates [0, 1, 2, ..., VL-1]\n        svint32_t trial_divisors = svadd_s32(pg, svmul_s32(pg, offsets, svdup_s32(2)), svdup_s32(d));\n\n        // Create a predicate to only consider divisors that are less than or equal to the limit.\n        // This ensures we don't check divisors that are too large.\n        svbool_t active_divisors_pg = svcmpge_s32(pg, svdup_s32(limit), trial_divisors);\n        \n        // Duplicate 'current_n' into a vector, so we can perform parallel modulo operations.\n        svint32_t n_vec = svdup_s32(current_n);\n\n        // Compute remainders in parallel for all active lanes.\n        // remainders[i] = current_n % trial_divisors[i]\n        svint32_t remainders = svrem_s32(active_divisors_pg, n_vec, trial_divisors);\n\n        // Check which divisors result in a remainder of 0 (i.e., are factors).\n        svbool_t is_divisible = svcmpeq_s32(active_divisors_pg, remainders, 0);\n\n        // If any of the trial divisors in the current batch are factors\n        if (svptest_any(pg, is_divisible)) {\n            // Find the smallest factor found in this batch.\n            // We iterate through the lanes sequentially to find the first (smallest) one.\n            int found_factor = -1;\n            for (int i = 0; i < vl; ++i) {\n                if (svget_lane_b32(is_divisible, i)) { // If this lane's divisor is a factor\n                    found_factor = svget_lane_s32(trial_divisors, i);\n                    break; // Found the smallest factor in this batch, no need to check further\n                }\n            }\n\n            if (found_factor != -1) {\n                // We found a factor. Add it to the list and divide 'current_n' by it repeatedly.\n                // This loop is sequential as 'current_n' changes with each division.\n                while (current_n % found_factor == 0) {\n                    factors.push_back(found_factor);\n                    current_n /= found_factor;\n                }\n                // After exhausting 'found_factor', update 'd' to continue the search\n                // from the next odd number after 'found_factor'.\n                d = found_factor + 2; \n            } else {\n                // This case should ideally not be reached if svptest_any was true,\n                // but as a fallback, advance 'd' to the next batch.\n                d += 2 * vl;\n            }\n        } else {\n            // No factor found in this batch of 'vl' divisors, so advance 'd' to the next batch.\n            d += 2 * vl;\n        }\n    }\n\n    // If 'current_n' is still greater than 1 after the loop, it means the remaining\n    // 'current_n' is a prime factor itself (larger than any 'd' checked).\n    if (current_n > 1) {\n        factors.push_back(current_n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n#include <climits> // For INT_MAX\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    if (n <= 1) {\n        return factors;\n    }\n\n    // Handle factor 2 (scalar, as repeated division is inherently sequential and efficient this way)\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Handle odd factors using SVE for trial division.\n    // 'i' represents the starting point for the current vector of trial divisors.\n    // In each iteration, we check a vector of potential odd divisors:\n    // [i, i+2, i+4, ..., i + (vl-1)*2], where vl is the SVE vector length.\n    int i = 3;\n    while ((long long)i * i <= n) { // Use long long for i*i to prevent overflow\n        svbool_t pg = svptrue_b32(); // Get a full predicate for 32-bit elements\n        int vl = svcntw();           // Get the current vector length for 32-bit integers\n\n        // Create a vector of potential odd divisors starting from 'i'.\n        // svindex_s32(start, step) generates a sequence: start, start+step, start+2*step, ...\n        svint32_t current_divisors = svindex_s32(i, 2);\n\n        // Duplicate 'n' into a vector for element-wise modulo operations.\n        svint32_t n_vec = svdup_s32(n);\n\n        // Compute remainders: n % current_divisors for all lanes.\n        svint32_t remainders = svrem_s32(n_vec, current_divisors);\n\n        // Determine which elements in current_divisors are actual divisors (remainder is 0).\n        svbool_t is_divisor_pg = svcmpeq_s32(pg, remainders, svdup_s32(0));\n\n        // Additionally, mask out divisors whose square is greater than 'n'.\n        // This is crucial because 'i' is just the start of the vector, and elements further down\n        // the vector might exceed sqrt(n), making them invalid trial divisors.\n        svint32_t current_divisors_squared = svmul_s32(current_divisors, current_divisors);\n        svbool_t not_too_large_pg = svcle_s32(pg, current_divisors_squared, svdup_s32(n));\n        \n        // Combine predicates: a number is a valid candidate if it's a divisor AND its square is not too large.\n        is_divisor_pg = svand_b(is_divisor_pg, not_too_large_pg);\n\n        // Check if any valid divisor was found in this vector chunk.\n        if (svptest_any(pg, is_divisor_pg)) {\n            // Find the smallest valid divisor among the found ones.\n            // We use svsel_s32 to set non-divisors (or too large ones) to INT_MAX.\n            // This ensures they don't affect the minimum value found by svminv_s32.\n            svint32_t valid_divs_for_min = svsel_s32(is_divisor_pg, current_divisors, svdup_s32(INT_MAX));\n            int min_found_divisor = svminv_s32(pg, valid_divs_for_min);\n\n            // Process this smallest found factor repeatedly until 'n' is no longer divisible by it.\n            // This part is sequential, as 'n' changes with each division.\n            while (n % min_found_divisor == 0) {\n                factors.push_back(min_found_divisor);\n                n /= min_found_divisor;\n            }\n            // After processing the factor, reset 'i' to this factor.\n            // This ensures that we re-check this factor (if 'n' was further reduced)\n            // and then continue checking subsequent factors from this point.\n            // This is important because 'n' has changed, and smaller factors might now be relevant again,\n            // or the current factor might be a multiple factor.\n            i = min_found_divisor;\n        } else {\n            // No valid factor was found in this vector chunk.\n            // Advance 'i' to the start of the next chunk of odd numbers.\n            i += vl * 2;\n        }\n    }\n\n    // If 'n' is still greater than 1 after the loop, it means the remaining 'n' is a prime factor itself.\n    // This happens if 'n' is a prime number or the last remaining factor is prime and greater than sqrt(original_n).\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath> // For sqrt, though d*d <= n is used to avoid float\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    // Handle factor 2: repeatedly divide n by 2 until it's no longer divisible.\n    // This part is inherently sequential as n changes with each division.\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Start checking odd factors from 3.\n    // The loop continues as long as d*d <= n.\n    // We use SVE to check a block of potential odd divisors (d, d+2, d+4, ...) simultaneously.\n    int d = 3;\n    const int VL = svcntw(); // Get the number of 32-bit integer elements in an SVE vector.\n\n    while ((long long)d * d <= n) { // Use long long for d*d to prevent overflow for large d\n        // Create a vector of potential odd divisors starting from 'd'.\n        // svindex_s32(start, step) generates a sequence: start, start+step, start+2*step, ...\n        svint32_t sv_d_base = svindex_s32(d, 2); // e.g., [d, d+2, d+4, d+6] for VL=4\n\n        // Duplicate the current value of n into an SVE vector.\n        svint32_t sv_n_dup = svdup_s32(n);\n\n        // Create a predicate for active lanes. Only consider divisors d_i where d_i * d_i <= n.\n        // This ensures we don't check divisors beyond the square root of the current n.\n        svint32_t sv_d_squared = svmul_s32_z(sv_all_b, sv_d_base, sv_d_base);\n        svbool_t pg_limit = svcle_s32(sv_all_b, sv_d_squared, svdup_s32(n));\n\n        // Calculate remainders: n % d_i for each active lane.\n        // SVE does not have a direct modulo intrinsic. It's computed as n - (n / d_i) * d_i.\n        svint32_t quotients = svdiv_s32_z(pg_limit, sv_n_dup, sv_d_base);\n        svint32_t products = svmul_s32_z(pg_limit, quotients, sv_d_base);\n        svint32_t remainders = svsub_s32_z(pg_limit, sv_n_dup, products);\n\n        // Create a predicate where lanes are true if remainder is 0 (i.e., d_i is a factor).\n        svbool_t is_factor_pg = svcmpeq_s32(pg_limit, remainders, svdup_s32(0));\n\n        // Check if any factor was found in the current vector chunk.\n        if (svptest_any(sv_all_b, is_factor_pg)) {\n            // If factors are found, we must process the *smallest* one first.\n            // This requires iterating through the lanes and falling back to scalar processing.\n            bool factor_found_in_chunk = false;\n            for (int i = 0; i < VL; ++i) {\n                if (svptest_b(is_factor_pg, i)) { // Check if this specific lane is an active factor\n                    int current_factor = d + 2 * i; // Calculate the scalar value of the factor\n                    \n                    // Process this factor: repeatedly divide n by it and add to factors list.\n                    while (n % current_factor == 0) {\n                        factors.push_back(current_factor);\n                        n /= current_factor;\n                    }\n                    \n                    // Update 'd' to continue the search from this factor (or the next odd number after it).\n                    // This ensures we don't miss factors and continue efficiently.\n                    d = current_factor;\n                    factor_found_in_chunk = true;\n                    break; // Found and processed the smallest factor in this chunk, break from inner loop.\n                }\n            }\n            // After processing a factor, increment 'd' by 2 to move to the next odd number\n            // and restart the outer while loop to re-evaluate 'n' and 'd*d <= n'.\n            d += 2;\n            continue; \n        }\n\n        // If no factor was found in the current vector chunk, advance 'd' by VL * 2.\n        // This moves 'd' past all the odd numbers checked in this SVE iteration.\n        d += VL * 2;\n    }\n\n    // If 'n' is still greater than 1 after the loop, it means the remaining 'n' is a prime factor itself.\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath>   // For sqrt\n#include <climits> // For INT_MAX\n\n#include <arm_sve.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    if (n <= 1) {\n        return factors;\n    }\n\n    // Handle factor 2 using SVE intrinsics.\n    // While this is less efficient than scalar operations for a single 'n',\n    // it demonstrates the use of SVE intrinsics as required.\n    svint32_t n_sve = svdup_s32(n); // Duplicate n into all lanes\n    svint32_t two_sve = svdup_s32(2);\n    svint32_t zero_sve = svdup_s32(0);\n    svbool_t pg_all = svptrue_b32(); // Predicate for all active lanes\n\n    while (true) {\n        // Calculate remainder: n % 2 == 0\n        // SVE does not have a direct modulo intrinsic. It's computed as n - (n / 2) * 2.\n        svint32_t quotient = svdiv_s32(pg_all, n_sve, two_sve);     // n / 2\n        svint32_t product = svmul_s32(pg_all, quotient, two_sve);   // (n / 2) * 2\n        svint32_t remainder = svsub_s32(pg_all, n_sve, product);    // n - (n / 2) * 2\n\n        // Check if remainder is zero for the current 'n' value.\n        // Since 'n' is duplicated across all lanes, we can check any active lane.\n        svbool_t p_is_even = svcmpeq_s32(pg_all, remainder, zero_sve);\n\n        if (svptest_any(pg_all, p_is_even)) {\n            factors.push_back(2);\n            n /= 2;\n            n_sve = svdup_s32(n); // Update the SVE vector with the new 'n'\n        } else {\n            break; // 'n' is no longer divisible by 2\n        }\n    }\n\n    // Handle odd factors using SVE intrinsics.\n    // This part parallelizes the trial division by checking multiple candidate divisors\n    // simultaneously within a vector.\n    int current_i = 3;\n    const int VL = svcntw(); // Get the number of 32-bit elements in a vector\n\n    // Precompute offsets for divisors: {0, 2, 4, ..., (VL-1)*2}\n    // These offsets will be added to 'current_i' to form the vector of trial divisors.\n    svint32_t base_indices = svindex_s32(0, 1); // Generates 0, 1, 2, ..., VL-1\n    svint32_t offsets = svmul_s32(pg_all, base_indices, svdup_s32(2)); // Generates 0, 2, 4, ..., (VL-1)*2\n\n    while ((long long)current_i * current_i <= n) { // Use long long for i*i to prevent overflow\n        // Duplicate current 'n' into all lanes of an SVE vector\n        n_sve = svdup_s32(n);\n\n        // Create a vector of potential divisors: current_i, current_i+2, ..., current_i + (VL-1)*2\n        svint32_t divisors = svadd_s32(pg_all, svdup_s32(current_i), offsets);\n\n        // Predicate for valid divisors:\n        // 1. divisor * divisor <= n (standard optimization for trial division)\n        // 2. divisor <= n (ensures we don't check divisors larger than the current 'n')\n        svbool_t pg_limit_check_sq = svcmple_s32(pg_all, svmul_s32(pg_all, divisors, divisors), n_sve);\n        svbool_t pg_limit_check_val = svcmple_s32(pg_all, divisors, n_sve);\n        svbool_t pg_valid_divisors = svand_b(pg_limit_check_sq, pg_limit_check_val);\n\n        // Check for divisibility: n % divisor == 0\n        // Compute remainder using n - (n / divisor) * divisor\n        svint32_t quotient = svdiv_s32(pg_valid_divisors, n_sve, divisors);\n        svint32_t product = svmul_s32(pg_valid_divisors, quotient, divisors);\n        svint32_t remainder = svsub_s32(pg_valid_divisors, n_sve, product);\n        svbool_t pg_divisible = svcmpeq_s32(pg_valid_divisors, remainder, zero_sve);\n\n        // Combine predicates: a divisor is \"found\" if it's valid AND it divides 'n'\n        svbool_t pg_found = svand_b(pg_valid_divisors, pg_divisible);\n\n        if (svptest_any(pg_all, pg_found)) { // If any lane found a divisor\n            // Find the smallest divisor that was found in this vector block.\n            // Set non-found lanes to INT_MAX so they don't affect the minimum.\n            svint32_t found_divs_vec = svsel_s32(pg_found, divisors, svdup_s32(INT_MAX));\n            int smallest_found_divisor = svmin_s32(pg_all, found_divs_vec);\n\n            // Repeatedly divide 'n' by this smallest factor until it's no longer a factor.\n            // This part is inherently sequential.\n            while (n % smallest_found_divisor == 0) {\n                factors.push_back(smallest_found_divisor);\n                n /= smallest_found_divisor;\n            }\n            // After finding a factor and updating 'n', restart the search for the next factor\n            // from the current 'smallest_found_divisor'. This is crucial for correctness\n            // (e.g., for n=9, smallest_found_divisor=3, n becomes 3. The next iteration should\n            // check 3 again).\n            current_i = smallest_found_divisor;\n        } else {\n            // No factor was found in this block of VL candidates.\n            // Advance 'current_i' by 'VL * 2' to check the next block of odd numbers.\n            current_i += VL * 2;\n        }\n    }\n\n    // If 'n' is still greater than 1 after the loops, it means the remaining 'n'\n    // is a prime factor itself (and is larger than sqrt(original n)).\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // For std::min, though not strictly used in the final version\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    // Reserve space to potentially avoid multiple reallocations.\n    // In the worst case (all numbers positive), the result size will be l.size().\n    result.reserve(l.size()); \n\n    const float* data_ptr = l.data();\n    size_t total_size = l.size();\n    size_t i = 0;\n\n    // Get the vector length for float32 elements.\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n    size_t vl = svcntw(); \n\n    // Temporary buffer to store compacted elements.\n    // The maximum possible vector length (VL) for SVE is 2048 bits.\n    // For float32 (32 bits), this means a maximum of 2048/32 = 64 elements.\n    // A stack-allocated array of size 64 is safe and efficient.\n    float temp_buffer[64]; \n\n    while (i < total_size) {\n        // Create a predicate for the current chunk of data.\n        // svwhilelt_b32(current_index, total_elements) generates a predicate\n        // where lanes are true as long as (current_index + lane_offset) < total_elements.\n        // This ensures we don't read past the end of the input vector, especially for the last chunk.\n        svbool_t pg = svwhilelt_b32(i, total_size);\n\n        // Load the vector elements using the predicate.\n        // Elements corresponding to false lanes in 'pg' are not loaded (or remain unchanged).\n        svfloat32_t vec = svld1_f32(pg, data_ptr + i);\n\n        // Create a mask for positive numbers (greater than 0.0f).\n        // The comparison is performed only on active lanes defined by 'pg'.\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, 0.0f);\n\n        // Compact the positive elements to the beginning of the vector register.\n        // Elements where 'positive_mask' is true are moved to lower indices in 'compacted_vec'.\n        // Elements where 'positive_mask' is false are ignored, and their corresponding\n        // positions in 'compacted_vec' become undefined.\n        svfloat32_t compacted_vec = svcompact_f32(positive_mask, vec);\n\n        // Count the number of active (positive) elements in this vector.\n        // svcntp_b32 counts the number of true lanes in 'positive_mask'\n        // that are also true in the governing predicate (svptrue_b32() means all lanes).\n        int num_positive = svcntp_b32(svptrue_b32(), positive_mask); \n\n        if (num_positive > 0) {\n            // Create a predicate to store only the 'num_positive' elements.\n            // This predicate will have 'num_positive' true lanes starting from index 0.\n            svbool_t store_pg = svwhilelt_b32(0, num_positive);\n            \n            // Store the compacted elements from the SVE register into the temporary buffer.\n            // Only the first 'num_positive' elements of 'compacted_vec' are stored,\n            // as dictated by 'store_pg'.\n            svst1_f32(store_pg, temp_buffer, compacted_vec);\n\n            // Append these elements from the temporary buffer to the result vector.\n            // This is more efficient than individual push_back calls.\n            result.insert(result.end(), temp_buffer, temp_buffer + num_positive);\n        }\n\n        // Advance the index by the full vector length for the next iteration.\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    if (l.empty()) {\n        return result;\n    }\n\n    size_t vl = svcnt_f32();\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, zero_vec);\n\n        size_t num_pos = svcntp_b32(positive_mask, positive_mask);\n\n        if (num_pos > 0) {\n            svfloat32_t compacted_vec = svcompact_f32(positive_mask, vec);\n\n            size_t current_result_size = result.size();\n            result.resize(current_result_size + num_pos);\n\n            svbool_t store_pg = svwhilelt_b32(0, num_pos);\n            svst1_f32(store_pg, &result[current_result_size], compacted_vec);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t l_size = l.size();\n\n    if (l_size == 0) {\n        return result;\n    }\n\n    size_t VL = svcnt_f32();\n    std::vector<float> temp_buffer(VL); \n    svfloat32_t zero_vec = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < l_size; i += VL) {\n        svbool_t pg = svwhilelt_b32(i, l_size);\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, zero_vec);\n        size_t num_positives = svcntp_b32(pg, positive_mask);\n\n        if (num_positives > 0) {\n            svfloat32_t compressed_vec = svcompress_f32(positive_mask, vec);\n            svst1_f32(pg, temp_buffer.data(), compressed_vec);\n            result.insert(result.end(), temp_buffer.begin(), temp_buffer.begin() + num_positives);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    if (l.empty()) {\n        return result;\n    }\n\n    const size_t vl = svcntw();\n    result.reserve(l.size());\n    std::vector<float> temp_vec_buffer(vl);\n\n    size_t i = 0;\n    while (i < l.size()) {\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        svbool_t positive_predicate = svcmpgt_f32(pg, vec, 0.0f);\n        svfloat32_t compacted_vec = svcompact_f32(positive_predicate, vec);\n        size_t num_positive_in_chunk = svcntp_b32(svptrue_b32(), positive_predicate);\n        svst1_f32(svptrue_b32(), temp_vec_buffer.data(), compacted_vec);\n        result.insert(result.end(), temp_vec_buffer.begin(), temp_vec_buffer.begin() + num_positive_in_chunk);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // For std::min\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    if (l.empty()) {\n        return result;\n    }\n\n    // Get the vector length (number of float elements per SVE vector)\n    // VL is determined at runtime by the SVE implementation.\n    const size_t VL = svcnt_f32();\n\n    // Temporary buffer to store compacted elements from one SVE vector.\n    // This buffer must be large enough to hold VL float elements.\n    // It's allocated on the stack for efficiency.\n    float temp_buffer[VL];\n\n    // Iterate through the input vector in chunks of VL elements.\n    for (size_t i = 0; i < l.size(); i += VL) {\n        // Determine the number of elements remaining in the current chunk.\n        // This handles the case where the input vector size is not a multiple of VL.\n        size_t num_elements_in_chunk = std::min((size_t)VL, l.size() - i);\n\n        // Create a predicate for the current chunk.\n        // This predicate is true for the first 'num_elements_in_chunk' elements\n        // and false for the rest, ensuring we only process valid data and\n        // prevent out-of-bounds access for partial vectors at the end.\n        svbool_t pg_chunk = svwhilelt_b32(0, num_elements_in_chunk);\n\n        // Load a vector of float elements from the input array 'l'.\n        // The load is masked by 'pg_chunk', meaning only elements corresponding\n        // to true predicate lanes are loaded.\n        svfloat32_t sv_vec = svld1_f32(pg_chunk, &l[i]);\n\n        // Create a predicate for positive numbers.\n        // This predicate is true for elements in 'sv_vec' that are greater than 0.0f.\n        // The comparison is only performed for active lanes defined by 'pg_chunk'.\n        svbool_t pg_positive = svcmpgt_f32(pg_chunk, sv_vec, 0.0f);\n\n        // Count the number of true bits in 'pg_positive'.\n        // This gives the count of positive numbers within the current chunk.\n        // svptrue_v_f32() ensures the count is performed across the entire vector register.\n        uint64_t active_count = svcntp_b32(svptrue_v_f32(), pg_positive);\n\n        // If there are any positive numbers found in this chunk\n        if (active_count > 0) {\n            // Compact the vector: move active elements (where 'pg_positive' is true)\n            // to the front of the vector. The elements at the end of the vector\n            // (beyond 'active_count') are undefined.\n            svfloat32_t packed_vec = svcompact_f32(pg_positive, sv_vec);\n\n            // Store the compacted vector to the temporary buffer.\n            // Since 'packed_vec' has active elements at the front, storing the full vector\n            // will place these elements at the beginning of 'temp_buffer'.\n            // svptrue_v_f32() is used as the predicate to store the entire 'packed_vec'.\n            svst1_f32(svptrue_v_f32(), temp_buffer, packed_vec);\n\n            // Append the 'active_count' positive elements from the temporary buffer\n            // to the result vector.\n            result.insert(result.end(), temp_buffer, temp_buffer + active_count);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath> // For sqrt\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true; // 2 and 3 are prime\n    if (n % 2 == 0 || n % 3 == 0) return false; // Multiples of 2 or 3\n\n    int64_t limit = static_cast<int64_t>(sqrt(n));\n\n    // Broadcast n to all lanes of the SVE vector\n    svint64_t n_vec = svdup_s64(n);\n\n    // Get the number of 64-bit elements in an SVE vector for the current architecture.\n    // This determines the step size for the loop.\n    size_t vl = svcntd();\n\n    // Iterate through potential divisors using the 6k +/- 1 optimization.\n    // We check divisors of the form 6k+1 and 6k+5 (which is 6(k+1)-1).\n    // The loop variable 'i' starts at 5 and increments by 6 * vl to process 'vl' pairs of (6k+1, 6k+5) divisors.\n    for (int64_t i = 5; ; i += 6 * vl) {\n        // --- Check divisors of the form i, i+6, i+12, ... (i.e., 6k+1 type, starting from 5) ---\n        // Create a predicate for active lanes, ensuring divisors do not exceed 'limit'.\n        svbool_t pg1 = svwhilelt_b64(i, limit + 1);\n\n        // If no lanes are active for this set of divisors, we can break the loop.\n        // svptest_any(svptrue_b64(), pg1) checks if any element in pg1 is true.\n        if (svptest_any(svptrue_b64(), pg1) == 0) {\n            break;\n        }\n\n        // Generate the vector of divisors: i, i+6, i+12, ...\n        svint64_t divisors1 = svindex_s64(i, 6);\n\n        // Perform parallel modulo operation: n % divisors1\n        svint64_t remainder1 = svmod_s64_x(pg1, n_vec, divisors1);\n\n        // Check if any remainder is zero for active lanes\n        svbool_t is_divisible1 = svcmpeq_s64(pg1, remainder1, svdup_s64(0));\n\n        // If any divisor in this set divides n, then n is not prime\n        if (svptest_any(pg1, is_divisible1)) {\n            return false;\n        }\n\n        // --- Check divisors of the form i+2, i+8, i+14, ... (i.e., 6k+5 type, starting from 7) ---\n        // Create a predicate for active lanes, ensuring divisors do not exceed 'limit'.\n        svbool_t pg2 = svwhilelt_b64(i + 2, limit + 1);\n\n        // If no lanes are active for this set of divisors, we can break the loop.\n        if (svptest_any(svptrue_b64(), pg2) == 0) {\n            break;\n        }\n\n        // Generate the vector of divisors: i+2, i+8, i+14, ...\n        svint64_t divisors2 = svindex_s64(i + 2, 6);\n\n        // Perform parallel modulo operation: n % divisors2\n        svint64_t remainder2 = svmod_s64_x(pg2, n_vec, divisors2);\n\n        // Check if any remainder is zero for active lanes\n        svbool_t is_divisible2 = svcmpeq_s64(pg2, remainder2, svdup_s64(0));\n\n        // If any divisor in this set divides n, then n is not prime\n        if (svptest_any(pg2, is_divisible2)) {\n            return false;\n        }\n    }\n\n    // If no divisors were found up to sqrt(n), then n is prime\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // Required for sqrt\n\nbool is_prime_simd(int64_t n) {\n    // Handle base cases\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2 || n == 3) {\n        return true;\n    }\n    // Check if n is an even number greater than 2\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    // For odd numbers >= 3, check for odd divisors up to sqrt(n)\n    int64_t limit = (int64_t)sqrt(n);\n\n    // Start checking from the first odd divisor, 3\n    int64_t current_divisor = 3;\n\n    // Loop while the current starting divisor is within the limit\n    while (current_divisor <= limit) {\n        // Create a predicate for active lanes.\n        // Lanes are active as long as the generated divisor is less than or equal to 'limit'.\n        // svwhilelt_b64(start, end) generates a predicate for elements from 'start' up to 'end-1'.\n        // So, to include 'limit', we use 'limit + 1' as the end.\n        svbool_t pg = svwhilelt_b64(current_divisor, limit + 1);\n\n        // If no lanes are active (i.e., current_divisor has exceeded limit for all potential lanes),\n        // then all necessary checks have been performed or will be out of bounds.\n        if (svptest_n(svptrue_b64(), pg)) {\n            break; // All divisors checked or current_divisor already exceeds limit\n        }\n\n        // Generate a vector of odd divisors: current_divisor, current_divisor+2, current_divisor+4, ...\n        // sviota_s64(start, stride) generates a sequence starting at 'start' with 'stride' increments.\n        svint64_t divisors_vec = sviota_s64(current_divisor, 2);\n\n        // Duplicate 'n' into a vector for parallel modulo operations\n        svint64_t n_vec = svdup_s64(n);\n\n        // Calculate remainders: n % divisors_vec for active lanes\n        // The predicate 'pg' ensures that only valid lanes perform the operation.\n        svint64_t remainders = svrem_s64(pg, n_vec, divisors_vec);\n\n        // Check if any active lane has a zero remainder (meaning 'n' is divisible by an active divisor)\n        svint64_t zero_vec = svdup_s64(0);\n        svbool_t any_zero_remainder = svcmpeq_s64(pg, remainders, zero_vec);\n\n        // If any active lane has a zero remainder, 'n' is not prime.\n        if (svptest_any(pg, any_zero_remainder)) {\n            return false;\n        }\n\n        // Advance current_divisor for the next batch of odd numbers.\n        // svcntd() returns the number of 64-bit elements in a full SVE vector.\n        // Since each element in our vector increments by 2 (odd numbers),\n        // the next starting divisor will be 'current_divisor + (vector_length * 2)'.\n        current_divisor += svcntd() * 2;\n    }\n\n    // If no divisors were found up to sqrt(n), 'n' is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <cmath> // For sqrt\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) { // 2 and 3 are prime\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) { // Eliminate multiples of 2 and 3\n        return false;\n    }\n\n    // Check for divisors from 5 up to sqrt(n)\n    int64_t limit = (int64_t)sqrt(n);\n\n    // Start checking from 5\n    int64_t i = 5;\n\n    // Get the predicate for the first iteration.\n    // svwhilelt_b64(start, limit) generates a predicate where p[j] is true if start + j < limit.\n    svbool_t pg = svwhilelt_b64(i, limit);\n\n    // Loop while there are any active lanes in the predicate.\n    // svptest_any(svptrue_b64(), pg) checks if any element in 'pg' is true.\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Generate a vector of divisors: [i, i+1, i+2, ..., i+VL-1]\n        svint64_t divisors_vec = svindex_s64(i, 1);\n\n        // Duplicate 'n' into a vector\n        svint64_t n_vec = svdup_n_s64(n);\n\n        // Perform integer division: n / divisor\n        // _x suffix means the operation is predicated (only active lanes are computed)\n        svint64_t quotient_vec = svdiv_s64_x(pg, n_vec, divisors_vec);\n\n        // Compute product: (n / divisor) * divisor\n        svint64_t product_vec = svmul_s64_x(pg, quotient_vec, divisors_vec);\n\n        // Compute remainder: n - (n / divisor) * divisor\n        svint64_t remainder_vec = svsub_s64_x(pg, n_vec, product_vec);\n\n        // Check if any remainder is zero for active lanes\n        svbool_t is_divisible = svcmpeq_s64(pg, remainder_vec, svdup_n_s64(0));\n\n        // If any active lane found a divisor (remainder is zero), then n is not prime\n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n\n        // Increment 'i' by the vector length to process the next batch of numbers\n        i += svcntd();\n\n        // Update the predicate for the next iteration\n        pg = svwhilelt_b64(i, limit);\n    }\n\n    // If no divisors were found, n is prime\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath> // For sqrt\n\nbool is_prime_simd(int64_t n) {\n    // Handle base cases and small numbers\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2 || n == 3) {\n        return true;\n    }\n    // Check divisibility by 2 and 3\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    // Optimization: Check divisors of the form 6k \u00b1 1\n    // We only need to check divisors up to sqrt(n)\n    int64_t limit = (int64_t)sqrt(n);\n\n    // Initialize SVE vectors for constants\n    svint64_t n_vec = svdup_s64(n);\n    svint64_t six_vec = svdup_s64(6);\n    svint64_t one_vec = svdup_s64(1);\n    svint64_t five_vec = svdup_s64(5);\n    svint64_t zero_vec = svdup_s64(0);\n\n    // Start checking from 5.\n    // 'i' represents the starting value for the current vector of divisor candidates.\n    int64_t i = 5;\n\n    while (true) {\n        // Generate a predicate for active lanes based on the loop limit.\n        // `svwhilelt_b64(base, limit_val)` creates a predicate where `base + lane_idx < limit_val`.\n        // Here, `base` is `i`, and `limit_val` is `limit + 1`.\n        // So, `i + lane_idx < limit + 1` means `i + lane_idx <= limit`.\n        // This ensures we only process divisor candidates up to `limit`.\n        svbool_t pg_loop = svwhilelt_b64(i, limit + 1);\n\n        // If no lanes are active (all potential divisors in this range exceed `limit`),\n        // we've checked all relevant divisors, so `n` is prime.\n        if (svptest_any(svptrue_b64(), pg_loop) == 0) {\n            break;\n        }\n\n        // Generate a vector of consecutive divisor candidates: i, i+1, i+2, ...\n        // The step is 1 because we will filter for 6k\u00b11 pattern later.\n        svint64_t divisors_candidate = svindex_s64(i, 1);\n\n        // Filter for numbers of the form 6k+1 or 6k+5 (which is equivalent to 6k-1)\n        // Calculate (candidate % 6) for active lanes.\n        svint64_t rem_six = svrem_s64_x(pg_loop, divisors_candidate, six_vec);\n\n        // Check if remainder is 1 (6k+1)\n        svbool_t is_6k_plus_1 = svcmpeq_s64(pg_loop, rem_six, one_vec);\n        // Check if remainder is 5 (6k+5)\n        svbool_t is_6k_plus_5 = svcmpeq_s64(pg_loop, rem_six, five_vec);\n\n        // Combine predicates: (candidate % 6 == 1) || (candidate % 6 == 5)\n        svbool_t is_prime_candidate_pattern = svorr_b(is_6k_plus_1, is_6k_plus_5);\n\n        // Combine with the loop limit predicate: only consider candidates within limit AND matching pattern\n        svbool_t active_divisors_pg = svand_b(pg_loop, is_prime_candidate_pattern);\n\n        // If no active divisors remain after filtering (e.g., all candidates in this vector range\n        // are not of the form 6k\u00b11 or exceed the limit), advance 'i' and continue to the next vector.\n        if (svptest_any(svptrue_b64(), active_divisors_pg) == 0) {\n            i += svcntd(); // Advance 'i' by the number of elements in a vector\n            continue;\n        }\n\n        // Perform modulo operation: n % divisor == 0\n        // `svrem_s64_x` performs the operation only for lanes where `active_divisors_pg` is true.\n        svint64_t rem_n = svrem_s64_x(active_divisors_pg, n_vec, divisors_candidate);\n\n        // Check if any remainder is zero for the active divisors.\n        svbool_t is_divisible = svcmpeq_s64(active_divisors_pg, rem_n, zero_vec);\n\n        // If any active lane found a divisor (i.e., n is divisible by one of the candidates),\n        // then n is not prime.\n        if (svptest_any(svptrue_b64(), is_divisible)) {\n            return false;\n        }\n\n        // Advance 'i' by the number of elements processed in this vector iteration.\n        i += svcntd();\n    }\n\n    // If the loop completes without finding any divisors, n is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h> // For bool type\n#include <math.h>    // For sqrt\n\n/*\nReturn true if a given number is prime, and false otherwise.\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n) {\n    // Handle base cases for primality\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) { // 2 and 3 are prime\n        return true;\n    }\n    // If n is divisible by 2 or 3, it's not prime (for n > 3)\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    // Calculate the square root of n. We only need to check divisors up to sqrt(n).\n    // Cast to double for sqrt, then back to int64_t.\n    int64_t limit = (int64_t)sqrt((double)n);\n\n    // Get the number of 64-bit elements that fit in an SVE vector.\n    size_t vl = svcntd();\n\n    // Broadcast n to all lanes of an SVE vector.\n    svint64_t sv_n = svdup_n_s64(n);\n\n    // Loop through potential divisors starting from 5.\n    // We increment by 'vl' in each iteration to process 'vl' divisors in parallel.\n    for (int64_t i = 5; i <= limit; i += vl) {\n        // Generate a vector of consecutive divisors: {i, i+1, i+2, ..., i+vl-1}\n        svint64_t sv_divisors = svindex_s64(i, 1);\n\n        // Create a predicate 'pg' for active lanes.\n        // A lane is active if its corresponding divisor is less than or equal to 'limit'.\n        // svwhilelt_b_s64(start, end) generates a predicate for elements from 'start' up to 'end-1'.\n        // So, for divisors up to 'limit', we use 'limit + 1' as the end.\n        svbool_t pg = svwhilelt_b_s64(i, limit + 1);\n\n        // Filter divisors to only include numbers of the form 6k +/- 1.\n        // Calculate sv_divisors % 6 for all active lanes.\n        svint64_t sv_six = svdup_n_s64(6);\n        // Perform division (d / 6) and multiplication ( (d/6) * 6 ) to get remainder.\n        // The _x suffix means the operation is unpredicated, but the predicate 'pg'\n        // controls which results are written back. This is fine as long as divisors are non-zero.\n        // Since i starts at 5, divisors will always be positive.\n        svint64_t sv_div_by_six = svdiv_s64_x(pg, sv_divisors, sv_six);\n        svint64_t sv_mul_by_six = svmul_s64_x(pg, sv_div_by_six, sv_six);\n        svint64_t sv_rem_six = svsub_s64_x(pg, sv_divisors, sv_mul_by_six);\n\n        // Create predicates for remainders being 1 or 5.\n        svbool_t pg_rem1 = svcmpeq_n_s64(pg, sv_rem_six, 1);\n        svbool_t pg_rem5 = svcmpeq_n_s64(pg, sv_rem_six, 5);\n        // Combine them: a divisor is valid if its remainder modulo 6 is 1 OR 5.\n        svbool_t pg_6k_form = svorr_b(pg_rem1, pg_rem5);\n\n        // Combine all predicates: a lane is truly active if its divisor is <= limit AND is of 6k +/- 1 form.\n        svbool_t pg_active = svand_b(pg, pg_6k_form);\n\n        // Perform the modulo operation (n % d == 0) for the truly active lanes.\n        // n % d = n - (n / d) * d\n        svint64_t sv_n_div_d = svdiv_s64_x(pg_active, sv_n, sv_divisors);\n        svint64_t sv_n_div_d_mul_d = svmul_s64_x(pg_active, sv_n_div_d, sv_divisors);\n        svint64_t sv_remainder = svsub_s64_x(pg_active, sv_n, sv_n_div_d_mul_d);\n\n        // Check if any of the active lanes resulted in a remainder of zero.\n        // If n % d == 0 for any d, then n is not prime.\n        svbool_t pg_is_divisor = svcmpeq_n_s64(pg_active, sv_remainder, 0);\n\n        // Use svptest_any to check if any bit in pg_is_divisor is set (i.e., any divisor found).\n        if (svptest_any(svptrue_b(), pg_is_divisor)) {\n            return false; // Found a divisor, so n is not prime.\n        }\n    }\n\n    // If no divisors were found, n is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <string>\n#include <algorithm> // Required for std::reverse\n#include <arm_sve.h> // Required for SVE intrinsics\n\nstd::string solve_simd(const std::string & s) {\n    // Create a mutable copy of the input string.\n    // This is where the modifications will happen.\n    std::string result = s;\n    size_t n = result.length();\n\n    // If the string is empty, there's nothing to do.\n    if (n == 0) {\n        return result;\n    }\n\n    // Flag to track if any letter (uppercase or lowercase) was found in the string.\n    // This determines whether to reverse the string at the end.\n    bool found_any_letter = false;\n\n    // Get the vector length in bytes for svuint8_t.\n    // This is the number of 8-bit elements (characters) that can be processed in one SVE vector.\n    const size_t vl = svcntb();\n\n    // Loop through the string in chunks of 'vl' characters.\n    // 'i' is the starting index of the current chunk.\n    for (size_t i = 0; i < n; i += vl) {\n        // Create a predicate for the current chunk.\n        // 'svwhilelt_b8(i, n)' generates a predicate that is true for elements\n        // whose original index (starting from 'i') is less than 'n'.\n        // This handles the tail end of the string where the chunk size might be less than 'vl'.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load a vector of 8-bit unsigned integers (characters) from the string.\n        // The predicate 'pg' ensures that only valid elements within the string bounds are loaded.\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&result[i]);\n\n        // Duplicate ASCII values for comparison and arithmetic operations into SVE vectors.\n        // The '0' in svdup_u8(0, value) indicates an immediate value.\n        svuint8_t lower_a = svdup_u8(0, 'a');\n        svuint8_t lower_z = svdup_u8(0, 'z');\n        svuint8_t upper_A = svdup_u8(0, 'A');\n        svuint8_t upper_Z = svdup_u8(0, 'Z');\n        svuint8_t case_diff = svdup_u8(0, 32); // ASCII difference between 'a' and 'A'\n\n        // 1. Determine if characters are lowercase letters:\n        //    - Check if char >= 'a'\n        svbool_t is_lower_ge_a = svcmpge_u8(pg, vec, lower_a);\n        //    - Check if char <= 'z'\n        svbool_t is_lower_le_z = svcmple_u8(pg, vec, lower_z);\n        //    - Combine predicates: (char >= 'a') AND (char <= 'z')\n        svbool_t is_lower = svand_b(is_lower_ge_a, is_lower_le_z);\n\n        // 2. Determine if characters are uppercase letters:\n        //    - Check if char >= 'A'\n        svbool_t is_upper_ge_A = svcmpge_u8(pg, vec, upper_A);\n        //    - Check if char <= 'Z'\n        svbool_t is_upper_le_Z = svcmple_u8(pg, vec, upper_Z);\n        //    - Combine predicates: (char >= 'A') AND (char <= 'Z')\n        svbool_t is_upper = svand_b(is_upper_ge_A, is_upper_le_Z);\n\n        // 3. Check if any character in the current chunk is a letter (either lower or upper).\n        //    - Combine predicates: is_lower OR is_upper\n        svbool_t is_letter_in_chunk = svorr_b(is_lower, is_upper);\n\n        // If any active element in the current chunk is a letter (according to the predicate 'is_letter_in_chunk'),\n        // set the global flag 'found_any_letter' to true.\n        // 'svptest_any(pg, is_letter_in_chunk)' returns true if any element\n        // that is active in 'pg' is also true in 'is_letter_in_chunk'.\n        if (svptest_any(pg, is_letter_in_chunk)) {\n            found_any_letter = true;\n        }\n\n        // 4. Perform case conversion based on the predicates:\n        //    - If 'is_lower' is true for an element, subtract 32 to convert to uppercase.\n        //      'svsub_u8_m(vec, is_lower, vec, case_diff)' performs 'vec - case_diff'\n        //      only for elements where 'is_lower' is true.\n        vec = svsub_u8_m(vec, is_lower, vec, case_diff);\n        \n        //    - If 'is_upper' is true for an element, add 32 to convert to lowercase.\n        //      'svadd_u8_m(vec, is_upper, vec, case_diff)' performs 'vec + case_diff'\n        //      only for elements where 'is_upper' is true.\n        vec = svadd_u8_m(vec, is_upper, vec, case_diff);\n\n        // Store the modified vector back to the string.\n        // The predicate 'pg' ensures that only valid elements within the string bounds are written.\n        svst1_u8(pg, (uint8_t*)&result[i], vec);\n    }\n\n    // After processing the entire string:\n    // If no letters were found in the entire string, reverse the string.\n    if (!found_any_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s){\n    const size_t n = s.length();\n    if (n == 0) {\n        return \"\";\n    }\n\n    std::string result = s;\n\n    bool has_letters = false;\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        if (svptest_any(pg, pg) == 0) {\n            break;\n        }\n\n        svuint8_t chars = svld1(pg, (const uint8_t*)&s[i]);\n\n        svuint8_t lower_a = svdup_n_u8('a');\n        svuint8_t lower_z = svdup_n_u8('z');\n        svuint8_t upper_A = svdup_n_u8('A');\n        svuint8_t upper_Z = svdup_n_u8('Z');\n\n        svbool_t is_lower = svand_b(svcmpge(pg, chars, lower_a), svcmple(pg, chars, lower_z));\n        svbool_t is_upper = svand_b(svcmpge(pg, chars, upper_A), svcmple(pg, chars, upper_Z));\n\n        if (svptest_any(pg, is_lower) || svptest_any(pg, is_upper)) {\n            has_letters = true;\n            break;\n        }\n        i += svcntb();\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    } else {\n        i = 0;\n        while (i < n) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            if (svptest_any(pg, pg) == 0) {\n                break;\n            }\n\n            svuint8_t chars = svld1(pg, (const uint8_t*)&s[i]);\n\n            svuint8_t lower_a = svdup_n_u8('a');\n            svuint8_t lower_z = svdup_n_u8('z');\n            svuint8_t upper_A = svdup_n_u8('A');\n            svuint8_t upper_Z = svdup_n_u8('Z');\n            svuint8_t case_diff = svdup_n_u8('a' - 'A');\n\n            svbool_t is_lower = svand_b(svcmpge(pg, chars, lower_a), svcmple(pg, chars, lower_z));\n            svbool_t is_upper = svand_b(svcmpge(pg, chars, upper_A), svcmple(pg, chars, upper_Z));\n\n            chars = svsub_x(is_lower, chars, case_diff);\n            chars = svadd_x(is_upper, chars, case_diff);\n\n            svst1(pg, (uint8_t*)&result[i], chars);\n            i += svcntb();\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <arm_sve.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.length();\n    if (n == 0) {\n        return \"\";\n    }\n\n    std::string result_str(n, ' ');\n    size_t vl = svcntb();\n\n    bool has_letters = false;\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b_u64(i, n);\n\n        sv_u8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        svbool_t is_lower = svand_b(svcmpge_u8(chars, sv_set1_u8(vl, 'a')),\n                                    svcmple_u8(chars, sv_set1_u8(vl, 'z')));\n        svbool_t is_upper = svand_b(svcmpge_u8(chars, sv_set1_u8(vl, 'A')),\n                                    svcmple_u8(chars, sv_set1_u8(vl, 'Z')));\n        \n        svbool_t is_letter = svorr_b(is_lower, is_upper);\n\n        if (svptest_any(sv_ptrue_b(), is_letter)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        for (size_t i = 0; i < n; i += vl) {\n            svbool_t pg = svwhilelt_b_u64(i, n);\n\n            sv_u8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n            sv_u8_t result_vec = chars;\n\n            svbool_t is_lower = svand_b(svcmpge_u8(chars, sv_set1_u8(vl, 'a')),\n                                        svcmple_u8(chars, sv_set1_u8(vl, 'z')));\n            svbool_t is_upper = svand_b(svcmpge_u8(chars, sv_set1_u8(vl, 'A')),\n                                        svcmple_u8(chars, sv_set1_u8(vl, 'Z')));\n            \n            sv_u8_t offset_val = sv_set1_u8(vl, 32);\n\n            result_vec = svsub_u8_m(result_vec, is_lower, result_vec, offset_val);\n\n            result_vec = svadd_u8_m(result_vec, is_upper, result_vec, offset_val);\n\n            svst1_u8(pg, (uint8_t*)&result_str[i], result_vec);\n        }\n    } else {\n        for (size_t i = 0; i < n; i += vl) {\n            svbool_t pg = svwhilelt_b_u64(i, n);\n\n            sv_u8_t chunk = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n            sv_u64_t current_indices = svindex_u64(i, 1);\n\n            sv_u64_t target_indices = svsub_u64(sv_set1_u64(vl, n - 1), current_indices);\n            \n            svst1_scatter_u8offset(pg, (uint8_t*)result_str.data(), target_indices, chunk);\n        }\n    }\n\n    return result_str;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string solve_simd(const std::string & s) {\n    const size_t len = s.length();\n    if (len == 0) {\n        return \"\";\n    }\n\n    std::string result_str(len, ' '); // Create a mutable result string\n    const uint8_t* s_data = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* result_data = reinterpret_cast<uint8_t*>(result_str.data());\n\n    // 1. Check if the string contains any letters using SVE\n    bool contains_letters = false;\n    size_t i = 0;\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for current chunk\n        if (svptest_any(pg, pg) == 0) { // If no active elements in this chunk, break\n            break;\n        }\n\n        svuint8_t chars = svld1_u8(pg, s_data + i);\n\n        // Check for lowercase: (chars >= 'a') && (chars <= 'z')\n        svbool_t is_lower_ge_a = svcmpge_n_u8(pg, chars, 'a');\n        svbool_t is_lower_le_z = svcmple_n_u8(pg, chars, 'z');\n        svbool_t is_lower_pred = svand_b(is_lower_ge_a, is_lower_le_z);\n\n        // Check for uppercase: (chars >= 'A') && (chars <= 'Z')\n        svbool_t is_upper_ge_A = svcmpge_n_u8(pg, chars, 'A');\n        svbool_t is_upper_le_Z = svcmple_n_u8(pg, chars, 'Z');\n        svbool_t is_upper_pred = svand_b(is_upper_ge_A, is_upper_le_Z);\n\n        // Check for any letter: is_lower || is_upper\n        svbool_t is_letter_pred = svorr_b(is_lower_pred, is_upper_pred);\n\n        if (svptest_any(pg, is_letter_pred)) { // If any letter found in this chunk\n            contains_letters = true;\n            break; // Found a letter, no need to check further\n        }\n        i += svcntb(); // Advance by current vector length\n    }\n\n    if (contains_letters) {\n        // 2. Process string: toggle case for letters, keep others as is\n        i = 0; // Reset index for processing loop\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            if (svptest_any(pg, pg) == 0) {\n                break;\n            }\n\n            svuint8_t chars = svld1_u8(pg, s_data + i);\n\n            // Check for lowercase\n            svbool_t is_lower_ge_a = svcmpge_n_u8(pg, chars, 'a');\n            svbool_t is_lower_le_z = svcmple_n_u8(pg, chars, 'z');\n            svbool_t is_lower_pred = svand_b(is_lower_ge_a, is_lower_le_z);\n\n            // Check for uppercase\n            svbool_t is_upper_ge_A = svcmpge_n_u8(pg, chars, 'A');\n            svbool_t is_upper_le_Z = svcmple_n_u8(pg, chars, 'Z');\n            svbool_t is_upper_pred = svand_b(is_upper_ge_A, is_upper_le_Z);\n\n            // Combined letter predicate\n            svbool_t is_letter_pred = svorr_b(is_lower_pred, is_upper_pred);\n\n            // Toggle case for letters: c ^ 32 (0x20)\n            // This works for ASCII letters as 'a'-'A' = 32.\n            svuint8_t toggled_chars = svceor_n_u8(chars, 32);\n\n            // Select based on predicate: if letter, use toggled; else, use original\n            svuint8_t final_chars = svsel_u8(is_letter_pred, toggled_chars, chars);\n\n            svst1_u8(pg, result_data + i, final_chars);\n            i += svcntb();\n        }\n    } else {\n        // 3. No letters found: reverse the string using SVE scatter store\n        i = 0; // Reset index for reversal loop\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            if (svptest_any(pg, pg) == 0) {\n                break;\n            }\n\n            svuint8_t chars = svld1_u8(pg, s_data + i);\n\n            // Generate indices for current chunk: {i, i+1, i+2, ...}\n            svint32_t indices = svindex_s32(i, 1);\n            \n            // Calculate destination offsets relative to `result_data + len - 1`:\n            // {-(i), -(i+1), -(i+2), ...}\n            // This means chars[k] (which is s[i+k]) will be stored at\n            // result_data + (len - 1) - (i+k).\n            svint32_t neg_indices = svneg_s32(indices); \n\n            // Store elements using scatter operation\n            svst1_scatter_s32offset_u8(pg, result_data + len - 1, neg_indices, chars);\n            i += svcntb();\n        }\n    }\n\n    return result_str;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Required for std::reverse\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s; // Create a mutable copy of the input string\n    const uint8_t* s_data = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* result_data = reinterpret_cast<uint8_t*>(result.data());\n    long n = s.length();\n    bool has_letters = false;\n\n    // SVE vector constants for ASCII character range checks and case conversion\n    svuint8_t lower_a = svdup_u8(97);  // ASCII 'a'\n    svuint8_t lower_z = svdup_u8(122); // ASCII 'z'\n    svuint8_t upper_A = svdup_u8(65);  // ASCII 'A'\n    svuint8_t upper_Z = svdup_u8(90);  // ASCII 'Z'\n    svuint8_t case_diff = svdup_u8(32); // Difference between 'a' and 'A'\n\n    // Iterate through the string in SVE vector chunks\n    for (long i = 0; i < n; i += svcntb()) {\n        // Get the predicate for the current vector chunk\n        // This handles the tail elements of the string correctly\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1_u8(pg, s_data + i);\n\n        // Determine which characters are lowercase letters\n        svbool_t is_lower = svand_b(svcmpge_u8(pg, vec, lower_a), svcmple_u8(pg, vec, lower_z));\n        // Determine which characters are uppercase letters\n        svbool_t is_upper = svand_b(svcmpge_u8(pg, vec, upper_A), svcmple_u8(pg, vec, upper_Z));\n\n        // Check if any character in the current vector chunk is a letter\n        // svorr_b combines the lowercase and uppercase predicates\n        if (svptest_any(pg, svorr_b(is_lower, is_upper))) {\n            has_letters = true;\n        }\n\n        // Convert lowercase letters to uppercase\n        // If 'is_lower' is true for an element, subtract 'case_diff' from it.\n        // Otherwise, keep the original character value.\n        vec = svsel_u8(is_lower, svsub_u8(vec, case_diff), vec);\n\n        // Convert uppercase letters to lowercase\n        // If 'is_upper' is true for an element, add 'case_diff' to it.\n        // Otherwise, keep the current character value (which might have been\n        // modified in the previous step if it was originally lowercase).\n        vec = svsel_u8(is_upper, svadd_u8(vec, case_diff), vec);\n\n        // Store the modified vector back into the result string\n        svst1_u8(pg, result_data + i, vec);\n    }\n\n    // If no letters were found in the entire string, reverse the result string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int N = l.size();\n    if (N == 0) {\n        return {};\n    }\n\n    std::vector<int> third_elements;\n    third_elements.reserve(N / 3 + 1); \n\n    for (int i = 0; i < N; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svint32_t vec_l = svld1(pg, &l[i]);\n\n        svint32_t indices = svindex_s32(i, 1);\n        \n        svint32_t mod_3_result = svmod_s32(indices, svset1_s32(pg, 3));\n        \n        svbool_t third_mask = svcmpeq(pg, mod_3_result, svset1_s32(pg, 0));\n\n        for (int k = 0; k < svcntw(); ++k) {\n            if (svptest_b32(pg, svpdup_n_b32(true, k)) && svptest_b32(third_mask, svpdup_n_b32(true, k))) {\n                third_elements.push_back(svget_lane(vec_l, k));\n            }\n        }\n    }\n\n    std::sort(third_elements.begin(), third_elements.end());\n\n    std::vector<int> l_prime = l;\n    int current_third_idx = 0;\n\n    for (int i = 0; i < N; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svint32_t vec_l_prime = svld1(pg, &l_prime[i]);\n\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t mod_3_result = svmod_s32(indices, svset1_s32(pg, 3));\n        svbool_t third_mask = svcmpeq(pg, mod_3_result, svset1_s32(pg, 0));\n\n        svint32_t sorted_values_vec = svdup_s32(0);\n\n        for (int k = 0; k < svcntw(); ++k) {\n            if (svptest_b32(pg, svpdup_n_b32(true, k)) && svptest_b32(third_mask, svpdup_n_b32(true, k))) {\n                if (current_third_idx < third_elements.size()) {\n                    sorted_values_vec = svset_lane(third_elements[current_third_idx++], sorted_values_vec, k);\n                }\n            }\n        }\n\n        vec_l_prime = svsel(third_mask, sorted_values_vec, vec_l_prime);\n\n        svst1(pg, &l_prime[i], vec_l_prime);\n    }\n\n    return l_prime;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    std::vector<int> values_to_sort;\n\n    // Step 1: Copy elements not divisible by 3 directly, and gather elements to be sorted.\n    // This loop processes data in SVE vector chunks.\n    for (size_t i = 0; i < l.size(); ) {\n        // Create a predicate for the current SVE vector chunk, handling tail elements.\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        \n        // If no active lanes in the predicate, we've processed all elements.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Generate a vector of indices for the current chunk: {i, i+1, i+2, ...}\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // Calculate (index % 3) for each lane.\n        svint32_t mod_3_check = svmod_s32_z(pg, current_indices, svdup_s32(3));\n\n        // Create a predicate where lanes are true if (index % 3 == 0).\n        svbool_t is_divisible_by_3 = svcmpeq_s32(pg, mod_3_check, svdup_s32(0));\n\n        // Load the data chunk from the input vector 'l'.\n        svint32_t data_chunk = svld1_s32(pg, &l[i]);\n\n        // Store elements that are NOT divisible by 3 directly into the result vector.\n        // The predicate `svnot_b(is_divisible_by_3)` ensures only these elements are written.\n        svst1_s32(svnot_b(is_divisible_by_3), &result[i], data_chunk);\n\n        // Count how many elements in the current chunk are divisible by 3.\n        int active_count = svcntp_b32(pg, is_divisible_by_3);\n\n        // If there are elements divisible by 3, gather them.\n        if (active_count > 0) {\n            // Use svcompress to gather the active (divisible by 3) elements into a compact SVE vector.\n            svint32_t gathered_values = svcompress_s32(is_divisible_by_3, data_chunk);\n            \n            // Extract the gathered values from the SVE vector to a temporary C++ array.\n            // svcntw() returns the number of 32-bit elements in an SVE vector.\n            // Using a VLA (Variable Length Array) here, which is a C99 feature\n            // often supported by C++ compilers like GCC/Clang.\n            int temp_arr[svcntw()]; \n            svst1_s32(svptrue_b32(), temp_arr, gathered_values);\n\n            // Append these extracted values to the `values_to_sort` std::vector.\n            for (int k = 0; k < active_count; ++k) {\n                values_to_sort.push_back(temp_arr[k]);\n            }\n        }\n        \n        // Advance the index by the SVE vector length.\n        i += svcntw();\n    }\n\n    // Step 2: Sort the gathered elements.\n    // This part uses std::sort, which is highly optimized and may use SIMD internally,\n    // but it's not explicitly an SVE intrinsic call. For general sorting of arbitrary\n    // length data, std::sort is the most practical and efficient approach.\n    std::sort(values_to_sort.begin(), values_to_sort.end());\n\n    // Step 3: Scatter the sorted elements back into the result vector.\n    // This loop iterates sequentially through the original indices.\n    // If an index is divisible by 3, it places the next sorted value from `values_to_sort`.\n    // Elements not divisible by 3 were already copied in Step 1.\n    size_t sorted_val_idx = 0;\n    for (size_t k = 0; k < l.size(); ++k) {\n        if (k % 3 == 0) {\n            result[k] = values_to_sort[sorted_val_idx++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Required for std::sort\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int N = l.size();\n    std::vector<int> l_prime(N);\n\n    // Vectors to store elements that need sorting and their original indices\n    std::vector<int> third_elements_to_sort;\n    std::vector<int> third_elements_original_indices;\n\n    int sv_vec_size = svcntw(); // Number of 32-bit integers per SVE vector\n\n    // Temporary buffers for packing elements from SVE vectors before pushing to std::vector.\n    // These are Variable Length Arrays (VLAs), which are a C99 feature and a GCC/Clang extension in C++.\n    // They are commonly used in SVE examples for bridging SVE vectors to host memory.\n    int temp_sorted_elements_buf[sv_vec_size];\n    int temp_sorted_indices_buf[sv_vec_size];\n\n    // Phase 1: Extract elements to be sorted and copy others directly\n    int i = 0;\n    for (; i + sv_vec_size <= N; i += sv_vec_size) {\n        // Predicate for active lanes in the current SVE vector, handling vector tails\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Generate absolute indices for the current vector chunk: i, i+1, ..., i+sv_vec_size-1\n        svint32_t current_indices = svadd_n_s32(svindex_s32(i, 1), 0);\n\n        // Calculate (index % 3) for each lane\n        svint32_t mod_result = svmod_n_s32_x(pg, current_indices, 3);\n        // Create a predicate for lanes where index % 3 == 0\n        svbool_t is_divisible_by_3 = svcmpeq_n_s32(pg, mod_result, 0);\n        // Create a predicate for lanes where index % 3 != 0\n        svbool_t is_not_divisible_by_3 = svnot_b(pg, is_divisible_by_3);\n\n        // Load data from the input vector 'l'\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        // Store elements NOT divisible by 3 directly into l_prime (parallel copy)\n        svst1_s32(is_not_divisible_by_3, &l_prime[i], vec_l);\n\n        // Count how many elements in this vector chunk are divisible by 3\n        int num_packed = svcntp_b32(pg, is_divisible_by_3);\n\n        if (num_packed > 0) {\n            // Pack elements divisible by 3 and their original indices\n            svint32_t packed_elements = svcompress_s32(is_divisible_by_3, vec_l);\n            svint32_t packed_indices = svcompress_s32(is_divisible_by_3, current_indices);\n\n            // Store packed elements and indices to temporary buffers.\n            // svptrue_b32() is used as the predicate because svcompress ensures\n            // the packed data is at the beginning of the vector.\n            svst1_s32(svptrue_b32(), temp_sorted_elements_buf, packed_elements);\n            svst1_s32(svptrue_b32(), temp_sorted_indices_buf, packed_indices);\n\n            // Append from temporary buffers to std::vectors\n            for (int k = 0; k < num_packed; ++k) {\n                third_elements_to_sort.push_back(temp_sorted_elements_buf[k]);\n                third_elements_original_indices.push_back(temp_sorted_indices_buf[k]);\n            }\n        }\n    }\n\n    // Handle remaining tail elements (if N is not a multiple of sv_vec_size)\n    for (; i < N; ++i) {\n        if (i % 3 == 0) {\n            third_elements_to_sort.push_back(l[i]);\n            third_elements_original_indices.push_back(i);\n        } else {\n            l_prime[i] = l[i];\n        }\n    }\n\n    // Phase 2: Sort the collected elements\n    // This step uses std::sort, which is a CPU-based sort, not an SVE intrinsic.\n    // General-purpose sorting is not typically performed efficiently with basic SIMD intrinsics.\n    std::sort(third_elements_to_sort.begin(), third_elements_to_sort.end());\n\n    // Phase 3: Scatter sorted elements back into l_prime\n    int num_third_elements = third_elements_to_sort.size();\n    int k = 0;\n    for (; k + sv_vec_size <= num_third_elements; k += sv_vec_size) {\n        // Predicate for active lanes in the current SVE vector for scattering\n        svbool_t pg = svwhilelt_b32(k, num_third_elements);\n\n        // Load sorted values from the collected vector\n        svint32_t sorted_values_vec = svld1_s32(pg, &third_elements_to_sort[k]);\n        // Load original indices where these values should be placed\n        svint32_t original_indices_vec = svld1_s32(pg, &third_elements_original_indices[k]);\n\n        // Scatter sorted values to l_prime at their original indices.\n        // The base address for scatter is &l_prime[0], and original_indices_vec contains absolute indices.\n        svst1_scatter_s32index_s32(pg, &l_prime[0], original_indices_vec, sorted_values_vec);\n    }\n\n    // Handle remaining tail elements for scattering\n    for (; k < num_third_elements; ++k) {\n        l_prime[third_elements_original_indices[k]] = third_elements_to_sort[k];\n    }\n\n    return l_prime;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t N = l.size();\n    if (N == 0) {\n        return {};\n    }\n\n    std::vector<int> result(N);\n    std::vector<int> temp_divisible_elements;\n    std::vector<size_t> temp_divisible_indices;\n\n    temp_divisible_elements.reserve(N / 3 + 1);\n    temp_divisible_indices.reserve(N / 3 + 1);\n\n    for (size_t i = 0; i < N; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svint32_t current_indices = svaddi_s32(svindex_s32(0, 1), i);\n\n        svint32_t mod_3 = svmod_s32_m(pg, current_indices, svdup_s32(3));\n\n        svbool_t is_divisible_by_3 = svcmpeq_s32(pg, mod_3, svdup_s32(0));\n        svbool_t is_not_divisible_by_3 = svnot_b(is_divisible_by_3);\n\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        svst1_s32(is_not_divisible_by_3, &result[i], vec_l);\n\n        svint32_t compressed_values = svcompress_s32(is_divisible_by_3, vec_l);\n        svint32_t compressed_indices = svcompress_s32(is_divisible_by_3, current_indices);\n\n        int num_compressed = svcntp_b32(pg, is_divisible_by_3);\n\n        for (int k = 0; k < num_compressed; ++k) {\n            temp_divisible_elements.push_back(svq_s32(compressed_values, k));\n            temp_divisible_indices.push_back(svq_s32(compressed_indices, k));\n        }\n    }\n\n    std::sort(temp_divisible_elements.begin(), temp_divisible_elements.end());\n\n    for (size_t k = 0; k < temp_divisible_elements.size(); ++k) {\n        result[temp_divisible_indices[k]] = temp_divisible_elements[k];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> l_prime = l; // Create a copy of the input vector for the result\n\n    // 1. Collect values from the input vector 'l' that are at indices divisible by three.\n    // This step is performed on the CPU as SVE is not ideal for sparse data collection into a dense,\n    // dynamically sized structure like std::vector for subsequent sorting.\n    std::vector<int> values_to_sort;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            values_to_sort.push_back(l[i]);\n        }\n    }\n\n    // 2. Sort the collected values.\n    // std::sort is used here as implementing a full parallel sort with SVE for arbitrary\n    // data sizes and sparse subsets is significantly more complex and often not the primary\n    // use case for SVE intrinsics in such problems.\n    std::sort(values_to_sort.begin(), values_to_sort.end());\n\n    // 3. Create an intermediate vector 'sorted_aligned_values'.\n    // This vector will hold the sorted values at their original corresponding indices.\n    // For indices not divisible by three, the values in this vector are irrelevant\n    // as they will be ignored by the SVE mask during the update phase.\n    std::vector<int> sorted_aligned_values(l.size());\n    size_t current_sorted_val_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            sorted_aligned_values[i] = values_to_sort[current_sorted_val_idx++];\n        }\n    }\n\n    // 4. Update 'l_prime' using SVE intrinsics.\n    // This step leverages SVE for parallel, masked data manipulation.\n    size_t N = l.size();\n    for (size_t i = 0; i < N; i += svcntw()) {\n        // Get a predicate 'pg' for the currently active lanes within the vector length (VL).\n        // This handles cases where the remaining elements are less than VL.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Generate current indices for the vector chunk: i, i+1, i+2, ...\n        // svindex_s32(0, 1) generates a sequence 0, 1, 2, ...\n        // svadd_s32 adds the base offset 'i' to each lane to get the absolute index.\n        svint32_t current_indices_in_chunk = svadd_s32(svindex_s32(0, 1), svdup_s32(i));\n\n        // Calculate (index % 3) for each lane.\n        svint32_t mod_result = svmod_s32(current_indices_in_chunk, svdup_s32(3));\n\n        // Create a mask 'mask_divisible_by_3' for lanes where (index % 3 == 0)\n        // and which are also active according to 'pg'.\n        svbool_t mask_divisible_by_3 = svcmpeq_s32(pg, mod_result, svdup_s32(0));\n\n        // Load the original values from 'l_prime' for the current chunk.\n        svint32_t original_chunk_values = svld1_s32(pg, &l_prime[i]);\n\n        // Load the sorted values from 'sorted_aligned_values' for the current chunk.\n        // The 'mask_divisible_by_3' ensures that only relevant values are considered.\n        svint32_t sorted_chunk_values = svld1_s32(mask_divisible_by_3, &sorted_aligned_values[i]);\n\n        // Select values for the result chunk:\n        // If 'mask_divisible_by_3' is true for a lane, take the value from 'sorted_chunk_values'.\n        // Otherwise (if index is not divisible by 3), take the value from 'original_chunk_values'.\n        svint32_t result_chunk = svsel_s32(mask_divisible_by_3, sorted_chunk_values, original_chunk_values);\n\n        // Store the resulting chunk back to 'l_prime'.\n        svst1_s32(pg, &l_prime[i], result_chunk);\n    }\n\n    return l_prime;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nfloat max_element_simd(std::vector<float> l) {\n    long n = l.size();\n\n    // The problem statement guarantees a non-empty vector.\n    // If it were possible for n to be 0, appropriate error handling\n    // (e.g., throwing an exception or returning NaN) would be needed.\n\n    // Initialize the maximum vector with the smallest possible float value.\n    // This ensures that any actual element from the vector will be greater than or equal to it.\n    svfloat32_t current_max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    long i = 0;\n    // Loop through the input vector in chunks, processing elements using SVE.\n    do {\n        // Generate a predicate for the current chunk.\n        // This predicate is true for elements from 'i' up to 'n-1' that fit into the current vector.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // If the predicate is all false, it means there are no more active elements to process.\n        // svptest_n(pg, pg) returns true if all lanes in 'pg' are false.\n        if (svptest_n(pg, pg)) {\n            break; // Exit the loop\n        }\n\n        // Load data from the vector 'l' into an SVE vector using the predicate.\n        // Only active lanes (where pg is true) will load valid data.\n        svfloat32_t data_vec = svld1(pg, &l[i]);\n\n        // Perform an element-wise maximum operation between the current running maximum vector\n        // and the newly loaded data vector.\n        current_max_vec = svmax_f32(current_max_vec, data_vec);\n\n        // Increment the index by the number of float elements in an SVE vector.\n        // svcntf() returns the current vector length for float elements.\n        i += svcntf();\n    } while (true); // Continue looping until explicitly broken\n\n    // After processing all chunks, perform a horizontal reduction across the lanes\n    // of the 'current_max_vec' to find the single maximum element.\n    // svtrue_f32() creates an all-true predicate for float32, ensuring all lanes are considered.\n    float max_val = svmax_f32_reduction(svtrue_f32(), current_max_vec);\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cfloat> // Required for FLT_MIN\n\nfloat max_element_simd(std::vector<float> l) {\n    long n = l.size();\n    if (n == 0) {\n        // The problem statement guarantees non-empty vector,\n        // but it's good practice to handle this case.\n        // For float, a common approach for empty max is -infinity.\n        return -FLT_MAX; // Or throw an exception\n    }\n\n    // Initialize a vector with the smallest possible float value.\n    // This ensures that the first actual element will be greater than or equal to it.\n    svfloat32_t current_max_vec = svdup_f32(FLT_MIN);\n\n    // Iterate through the input vector in chunks of SVE vector length\n    // The loop step is determined by the actual number of elements in an SVE vector (VL).\n    for (long i = 0; i < n; i += svcnt_f32()) {\n        // Create a predicate for the current chunk.\n        // This handles the tail end of the vector where the number of remaining elements\n        // might be less than the full SVE vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the data from the input vector `l` into an SVE vector.\n        // Elements for which the predicate is false are not loaded (or remain unchanged).\n        svfloat32_t data_vec = svld1_f32(pg, &l[i]);\n\n        // Perform element-wise maximum between the current running maximum vector\n        // and the newly loaded data vector.\n        current_max_vec = svmax_f32(current_max_vec, data_vec);\n    }\n\n    // After processing all chunks, perform a horizontal reduction\n    // to find the maximum element within the `current_max_vec`.\n    // svptrue_b32() creates a predicate where all elements are active.\n    float max_val = svmax_f32_reduction(svptrue_b32(), current_max_vec);\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cfloat> // Required for FLT_MAX\n\nfloat max_element_simd(std::vector<float> l) {\n    // Initialize max_vec with the smallest possible float value.\n    // This vector will accumulate the maximums across lanes.\n    // svptrue_b32() creates a predicate with all lanes active.\n    svfloat32_t max_vec = svdup_f32(svptrue_b32(), -FLT_MAX);\n\n    size_t i = 0;\n    size_t vec_size = l.size();\n    \n    // Get the number of float elements per SVE vector.\n    // This value is determined at runtime by the SVE hardware.\n    size_t sv_elements = svcnt_f32();\n\n    // Loop through the vector in chunks of SVE vector length.\n    // The loop condition ensures we handle both full chunks and the tail.\n    while (i < vec_size) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b32(i, vec_size) generates a predicate where lanes are active\n        // as long as the current index (i + lane_offset) is less than vec_size.\n        // This correctly handles the tail of the vector.\n        svbool_t pg = svwhilelt_b32(i, vec_size);\n\n        // Load the current chunk of data into an SVE vector.\n        // Elements corresponding to inactive predicate elements are not loaded,\n        // and the corresponding elements in current_chunk are undefined.\n        svfloat32_t current_chunk = svld1_f32(pg, &l[i]);\n\n        // Perform element-wise maximum operation using a masked intrinsic.\n        // For active lanes (where pg is true), max_vec[lane] = max(max_vec[lane], current_chunk[lane]).\n        // For inactive lanes (where pg is false), max_vec[lane] remains unchanged (max_vec[lane] = max_vec[lane]).\n        // This correctly handles the tail where current_chunk has undefined values for inactive lanes.\n        max_vec = svmax_f32_m(max_vec, pg, max_vec, current_chunk);\n\n        // Increment index by the actual number of elements processed in one SVE vector.\n        i += sv_elements;\n    }\n\n    // After processing all chunks, find the maximum element across all lanes of max_vec.\n    // svmax_f32v performs a horizontal reduction (maximum across all elements in the vector).\n    // svptrue_b32() ensures all lanes are considered for the reduction.\n    float result = svmax_f32v(svptrue_b32(), max_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nfloat max_element_simd(std::vector<float> l){\n    // Get the size of the input vector\n    size_t N = l.size();\n\n    // The problem statement guarantees a \"non-empty vector\", so N > 0 is assured.\n\n    // Get a pointer to the underlying data for efficient access\n    const float* data = l.data();\n\n    // Initialize an SVE vector with the smallest possible float value.\n    // This vector will accumulate the maximum values across processed chunks.\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Get the number of float elements that fit into an SVE vector (Vector Length, VL).\n    // VL is determined at runtime by the SVE hardware.\n    svcount_t vl = svcnt_f32();\n\n    // Loop through the vector in full chunks of VL elements\n    size_t i = 0;\n    for (; i + vl <= N; i += vl) {\n        // Create a full predicate (all lanes active) for loading a complete chunk.\n        svbool_t pg = svptrue_b32();\n        \n        // Load a chunk of data from the input vector into an SVE vector.\n        svfloat32_t current_chunk = svld1_f32(pg, &data[i]);\n        \n        // Compute the element-wise maximum between the current `max_vec` and the loaded `current_chunk`.\n        // This updates `max_vec` with the maximum value for each corresponding lane.\n        max_vec = svmax_f32(max_vec, current_chunk);\n    }\n\n    // Handle any remaining tail elements that do not form a full VL chunk.\n    if (i < N) {\n        // Create a predicate for the remaining elements.\n        // `svwhilelt_b32(i, N)` generates a predicate where lanes corresponding to indices\n        // from `i` up to `N-1` are true, and subsequent lanes are false.\n        svbool_t pg = svwhilelt_b32(i, N);\n        \n        // Load the tail chunk of data. Elements corresponding to false predicate lanes\n        // will typically be loaded as zero or garbage, but their values won't affect the result\n        // due to the masked operation below.\n        svfloat32_t current_chunk = svld1_f32(pg, &data[i]);\n        \n        // Compute the element-wise maximum using a masked operation (`svmax_f32_m`).\n        // For active lanes (where `pg` is true), it computes `max(max_vec_lane, current_chunk_lane)`.\n        // For inactive lanes (where `pg` is false), it preserves the original `max_vec_lane` value.\n        // This ensures that only valid data from the tail is considered for the maximum,\n        // and previously accumulated maximums in inactive lanes are retained.\n        max_vec = svmax_f32_m(max_vec, pg, current_chunk);\n    }\n\n    // Reduce the final `max_vec` SVE vector to a single scalar maximum value.\n    // `svptrue_b32()` ensures that all elements within `max_vec` are considered for the reduction,\n    // as `max_vec` now holds the maximums across all processed data segments.\n    float result = svmax_f32v(svptrue_b32(), max_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nfloat max_element_simd(std::vector<float> l) {\n    // As per the problem description, the vector is non-empty.\n    // However, a defensive check is good practice.\n    if (l.empty()) {\n        // Return the smallest possible float value or throw an error\n        // if an empty vector is truly an invalid input.\n        return std::numeric_limits<float>::lowest();\n    }\n\n    // Get the number of float elements that fit into an SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    const size_t sv_len = svcntf();\n\n    // Initialize the SVE vector that will hold the running maximums.\n    // Each lane is initialized with the smallest possible float value,\n    // ensuring that any actual element from the input vector will be greater.\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Loop through the input vector in chunks of `sv_len`.\n    // Process full SVE vector chunks.\n    size_t i = 0;\n    for (; i + sv_len <= l.size(); i += sv_len) {\n        // Load a full chunk of data from the input vector into an SVE vector.\n        // svptrue_b32() creates a predicate where all lanes are active.\n        svfloat32_t current_chunk = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Compute the element-wise maximum between the current running maximums\n        // and the newly loaded chunk.\n        max_vec = svmax_f32(max_vec, current_chunk);\n    }\n\n    // Handle any remaining tail elements that do not form a full SVE vector.\n    if (i < l.size()) {\n        // Create a predicate for the tail elements.\n        // svwhilelt_b32(i, l.size()) generates a predicate that is true for\n        // elements from index `i` up to `l.size() - 1`.\n        svbool_t tail_pg = svwhilelt_b32(i, l.size());\n\n        // Load the tail chunk using a masked load.\n        // svld1_f32_m(merge_vec, predicate, base_ptr) loads active elements\n        // from `base_ptr` and takes inactive elements from `merge_vec`.\n        // We initialize `merge_vec` with `lowest()` so that inactive lanes\n        // do not affect the maximum calculation.\n        svfloat32_t tail_data = svld1_f32_m(svdup_f32(std::numeric_limits<float>::lowest()), tail_pg, &l[i]);\n\n        // Compute the element-wise maximum with the tail data.\n        max_vec = svmax_f32(max_vec, tail_data);\n    }\n\n    // Reduce the final SVE vector of maximums to a single scalar value.\n    // svmax_f32v(predicate, vector) finds the maximum element across all\n    // active lanes of the vector. svptrue_b32() ensures all lanes are considered.\n    return svmax_f32v(svptrue_b32(), max_vec);\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int total_sevens_count = 0;\n    int i = 0;\n    // Get the number of 32-bit elements in an SVE vector.\n    // This determines the vector length (VL).\n    int VL = svcntw();\n\n    // Duplicate scalar constants into SVE vectors\n    svint32_t eleven_vec = svdup_n_s32(11);\n    svint32_t thirteen_vec = svdup_n_s32(13);\n    svint32_t ten_vec = svdup_n_s32(10);\n    svint32_t seven_vec = svdup_n_s32(7);\n    svint32_t one_vec = svdup_n_s32(1);\n    svint32_t zero_vec = svdup_n_s32(0);\n\n    // Main loop to process numbers in chunks of VL\n    while (i < n) {\n        // Create a predicate for the current chunk, ensuring we don't go past 'n'.\n        // Lanes where i + lane_idx < n will be active.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Generate a vector of numbers: i, i+1, i+2, ..., i+VL-1\n        svint32_t numbers_chunk = sviota_s32(i, 1);\n\n        // Calculate modulo 11 for each number in the chunk\n        // quotient = numbers_chunk / 11\n        svint32_t quotient_11 = svdiv_s32_x(pg, numbers_chunk, eleven_vec);\n        // remainder = numbers_chunk - (quotient * 11)\n        svint32_t mod11 = svsub_s32_x(pg, numbers_chunk, svmul_s32_x(pg, quotient_11, eleven_vec));\n\n        // Calculate modulo 13 for each number in the chunk\n        // quotient = numbers_chunk / 13\n        svint32_t quotient_13 = svdiv_s32_x(pg, numbers_chunk, thirteen_vec);\n        // remainder = numbers_chunk - (quotient * 13)\n        svint32_t mod13 = svsub_s32_x(pg, numbers_chunk, svmul_s32_x(pg, quotient_13, thirteen_vec));\n\n        // Check if numbers are divisible by 11 (remainder is 0)\n        svbool_t div_by_11 = svcmpeq_n_s32(pg, mod11, 0);\n        // Check if numbers are divisible by 13 (remainder is 0)\n        svbool_t div_by_13 = svcmpeq_n_s32(pg, mod13, 0);\n\n        // Combine conditions: divisible by 11 OR 13\n        svbool_t condition_met = svorr_b(div_by_11, div_by_13);\n\n        // Initialize vector to store counts of '7's for each number in the chunk\n        // Only lanes where 'condition_met' is true will accumulate counts.\n        svint32_t partial_sevens_counts = svdup_n_s32(0);\n        // Make a copy of numbers_chunk to extract digits from\n        svint32_t current_numbers_for_7s = numbers_chunk;\n\n        // Predicate for the inner loop: active if condition_met is true AND number > 0\n        svbool_t inner_pg = svand_b(condition_met, svcmpgt_n_s32(pg, current_numbers_for_7s, 0));\n\n        // Loop to count occurrences of digit '7' for each number in parallel\n        // This loop runs at most ~10 times (max digits in an int)\n        while (svptest_any(pg, inner_pg)) {\n            // Calculate last_digits = current_numbers_for_7s % 10\n            svint32_t quotient_10 = svdiv_s32_x(inner_pg, current_numbers_for_7s, ten_vec);\n            svint32_t product_10 = svmul_s32_x(inner_pg, quotient_10, ten_vec);\n            svint32_t last_digits = svsub_s32_x(inner_pg, current_numbers_for_7s, product_10);\n\n            // Check if the last digit is 7\n            svbool_t is_seven = svcmpeq_s32(inner_pg, last_digits, seven_vec);\n\n            // Increment count for lanes where the digit is 7\n            // _m variant ensures only active lanes are modified\n            partial_sevens_counts = svadd_s32_m(is_seven, partial_sevens_counts, one_vec);\n\n            // Update current_numbers_for_7s = current_numbers_for_7s / 10\n            // The quotient_10 already holds the result of integer division\n            current_numbers_for_7s = quotient_10;\n\n            // Update inner_pg for the next iteration: still active if condition_met AND number > 0\n            inner_pg = svand_b(condition_met, svcmpgt_n_s32(pg, current_numbers_for_7s, 0));\n        }\n\n        // Sum up the counts of '7's from all active lanes in the current chunk\n        // The 'pg' predicate ensures only counts from numbers within [0, n-1] are summed.\n        total_sevens_count += svreduce_plus_s32(pg, partial_sevens_counts);\n\n        // Move to the next chunk of numbers\n        i += VL;\n    }\n\n    return total_sevens_count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n    int total_sevens = 0;\n\n    // Get the number of 32-bit elements in a vector (VL)\n    // This is typically a multiple of 4, e.g., 4, 8, 16, depending on the SVE implementation.\n    int sv_elements = svcntw();\n\n    // Constants used in the loop, duplicated into SVE vectors.\n    // Using svdup_n_s32(svptrue_b32(), value) ensures all lanes are set,\n    // as these constants are needed regardless of the current predicate 'pg'.\n    svint32_t eleven_vec = svdup_n_s32(svptrue_b32(), 11);\n    svint32_t thirteen_vec = svdup_n_s32(svptrue_b32(), 13);\n    svint32_t ten_vec = svdup_n_s32(svptrue_b32(), 10);\n    svint32_t seven_vec = svdup_n_s32(svptrue_b32(), 7);\n    svint32_t zero_vec = svdup_n_s32(svptrue_b32(), 0);\n\n    // Loop through numbers in chunks of VL\n    for (int i = 0; i < n; i += sv_elements) {\n        // 1. Generate a predicate for active lanes (numbers less than n)\n        //    and a vector of current numbers.\n        // svwhilelt_b32(start, end) generates a predicate where elements\n        // corresponding to values from 'start' up to 'end-1' are true.\n        svbool_t pg = svwhilelt_b32(i, n);\n        // svindex_s32(start, step) generates a vector {start, start+step, start+2*step, ...}\n        svint32_t current_numbers = svindex_s32(i, 1);\n\n        // 2. Check divisibility by 11 or 13 for active lanes.\n        // svmod_s32(predicate, dividend, divisor) performs modulo operation only for active lanes.\n        svint32_t mod11 = svmod_s32(pg, current_numbers, eleven_vec);\n        svint32_t mod13 = svmod_s32(pg, current_numbers, thirteen_vec);\n\n        // svcmpeq_s32(predicate, operand1, operand2) compares for equality for active lanes.\n        svbool_t div_by_11 = svcmpeq_s32(pg, mod11, zero_vec);\n        svbool_t div_by_13 = svcmpeq_s32(pg, mod13, zero_vec);\n\n        // Combine divisibility conditions: (num % 11 == 0) || (num % 13 == 0)\n        svbool_t condition_met = svorr_b(div_by_11, div_by_13);\n\n        // This predicate identifies lanes that are within bounds (i < n) AND meet the divisibility condition.\n        svbool_t active_and_condition = svand_b(pg, condition_met);\n\n        // 3. Count '7's for numbers that satisfy the condition.\n        // Initialize a vector to store the count of '7's for each number.\n        // svdup_n_s32(pg, 0) initializes only lanes active under 'pg' to 0.\n        // Inactive lanes (where pg is false) will have undefined values, but won't be used in reduction.\n        svint32_t seven_counts_vec = svdup_n_s32(pg, 0);\n        svint32_t num_copy = current_numbers; // Make a copy to modify during digit extraction\n\n        // Predicate for the digit extraction loop.\n        // It starts with 'active_and_condition' and is updated in each iteration.\n        svbool_t digit_loop_predicate = active_and_condition;\n\n        // Loop as long as any lane (that was initially active and met the condition)\n        // still has digits to process (i.e., num_copy > 0).\n        // svptest_any(pg, predicate) returns true if any lane active under 'pg'\n        // also has 'predicate' true.\n        while (svptest_any(pg, digit_loop_predicate)) {\n            // Extract the last digit for active lanes in this digit extraction step.\n            svint32_t digit = svmod_s32(digit_loop_predicate, num_copy, ten_vec);\n\n            // Check if the extracted digit is '7' for active lanes.\n            svbool_t is_seven = svcmpeq_s32(digit_loop_predicate, digit, seven_vec);\n\n            // Increment the count of '7's for lanes where 'is_seven' is true.\n            // svadd_n_s32_m(operand1, merge_mask, operand2, immediate)\n            // If merge_mask is true, result = operand2 + immediate. Else, result = operand1.\n            // Here, if 'is_seven' is true, seven_counts_vec[lane] += 1. Otherwise, it remains unchanged.\n            seven_counts_vec = svadd_n_s32_m(seven_counts_vec, is_seven, seven_counts_vec, 1);\n\n            // Remove the last digit (integer division by 10) for active lanes.\n            num_copy = svdiv_s32(digit_loop_predicate, num_copy, ten_vec);\n\n            // Update the loop predicate: continue for lanes where num_copy is still > 0.\n            // svcmpgt_n_s32(predicate, operand, immediate) compares for greater than.\n            digit_loop_predicate = svcmpgt_n_s32(digit_loop_predicate, num_copy, zero_vec);\n            // Crucial: Ensure we only continue for numbers that were initially valid\n            // (within n AND met divisibility criteria).\n            digit_loop_predicate = svand_b(digit_loop_predicate, active_and_condition);\n        }\n\n        // 4. Sum up the '7' counts from all active lanes in this vector block.\n        // svreduce_s32(svadd_s32_x(pg, vector)) sums elements of 'vector' where 'pg' is true.\n        // Since 'seven_counts_vec' was initialized to 0 for lanes active under 'pg' but not 'active_and_condition',\n        // and only incremented for 'active_and_condition' lanes, this sum correctly accumulates only relevant counts.\n        total_sevens += svreduce_s32(svadd_s32_x(pg, seven_counts_vec));\n    }\n\n    return total_sevens;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\n// Helper for modulo operation, as svmod_s32 is not a standard SVE intrinsic.\n// Computes a % b = a - (a / b) * b for active lanes.\nstatic inline svint32_t svmod_s32_custom(svbool_t pg, svint32_t a, svint32_t b) {\n    // Perform division only for active lanes specified by predicate 'pg'\n    svint32_t div_result = svdiv_s32(pg, a, b);\n    // Perform multiplication only for active lanes\n    svint32_t mul_result = svmul_s32(pg, div_result, b);\n    // Perform subtraction only for active lanes\n    return svsub_s32(pg, a, mul_result);\n}\n\nint fizz_buzz_simd(int n) {\n    int total_sevens_count = 0;\n\n    // Loop through numbers in chunks of SVE vector length (svcntw() returns the number of 32-bit elements)\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create a predicate 'pg' for elements within the [0, n-1] range for the current vector chunk.\n        // Elements where i + lane_index < n will have their predicate lane set to true.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Generate a vector of numbers: i, i+1, i+2, ... for the current chunk.\n        svint32_t current_numbers = svindex_s32(i, 1);\n\n        // --- Check divisibility by 11 ---\n        svint32_t eleven_vec = svdup_s32(11);\n        svint32_t mod11_result = svmod_s32_custom(pg, current_numbers, eleven_vec);\n        svbool_t divisible_by_11 = svcmpeq_s32(pg, mod11_result, svdup_s32(0));\n\n        // --- Check divisibility by 13 ---\n        svint32_t thirteen_vec = svdup_s32(13);\n        svint32_t mod13_result = svmod_s32_custom(pg, current_numbers, thirteen_vec);\n        svbool_t divisible_by_13 = svcmpeq_s32(pg, mod13_result, svdup_s32(0));\n\n        // Combine divisibility conditions: divisible by 11 OR 13\n        svbool_t condition_met = svorr_b(divisible_by_11, divisible_by_13);\n\n        // Initialize a vector to store counts of '7's for each number in the current_numbers vector.\n        // This vector will accumulate counts only for numbers that meet the divisibility condition.\n        svint32_t sevens_in_vector = svdup_s32(0);\n\n        // The mask for elements that are currently active for digit counting.\n        // Initially, it includes elements within 'n' AND meeting the divisibility condition.\n        svbool_t current_active_mask = svand_b(pg, condition_met);\n\n        // If no elements in this vector chunk meet the condition, skip digit counting and proceed to next chunk.\n        if (!svany_b(current_active_mask)) {\n            continue;\n        }\n\n        // Create a temporary copy of numbers to perform digit extraction (division by 10).\n        svint32_t temp_numbers = current_numbers;\n        svint32_t ten_vec = svdup_s32(10);\n        svint32_t seven_vec = svdup_s32(7);\n        svint32_t one_vec = svdup_s32(1);\n        svint32_t zero_vec = svdup_s32(0);\n\n        // Loop for extracting and checking digits (max 10 digits for a 32-bit integer).\n        // The loop continues as long as there are active elements that are still greater than 0.\n        for (int k = 0; k < 10; ++k) {\n            // If no elements are active (all numbers have been reduced to 0), break the digit counting loop.\n            if (!svany_b(current_active_mask)) {\n                break;\n            }\n\n            // Extract the last digit for active elements using the current_active_mask.\n            svint32_t last_digit = svmod_s32_custom(current_active_mask, temp_numbers, ten_vec);\n\n            // Check if the last digit is 7 for active elements.\n            svbool_t is_seven = svcmpeq_s32(current_active_mask, last_digit, seven_vec);\n\n            // Increment count for elements where the digit is 7.\n            // svadd_s32_m adds 1 to sevens_in_vector only where 'is_seven' is true.\n            sevens_in_vector = svadd_s32_m(sevens_in_vector, is_seven, sevens_in_vector, one_vec);\n\n            // Divide by 10 for the next digit for active elements.\n            temp_numbers = svdiv_s32(current_active_mask, temp_numbers, ten_vec);\n\n            // Update the active mask: only elements that were active AND are still greater than 0.\n            // This ensures we stop processing numbers once they become 0.\n            current_active_mask = svand_b(current_active_mask, svcmpgt_s32(current_active_mask, temp_numbers, zero_vec));\n        }\n\n        // Sum up the counts of '7's from the current vector.\n        // The 'sevens_in_vector' already contains 0 for elements that didn't meet the initial divisibility condition,\n        // so we can simply sum all elements under the original 'pg' predicate.\n        total_sevens_count += svreduce_add_s32(pg, sevens_in_vector);\n    }\n\n    return total_sevens_count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int total_sevens = 0;\n    svbool_t pg = svptrue_b32(); // Full predicate for 32-bit elements\n\n    // Get the vector length for 32-bit integers\n    int vl = svcntw();\n\n    // Pre-duplicate constants to avoid redundant operations inside loops\n    svint32_t const_0 = svdup_n_s32(0);\n    svint32_t const_1 = svdup_n_s32(1);\n    svint32_t const_7 = svdup_n_s32(7);\n    svint32_t const_10 = svdup_n_s32(10);\n    svint32_t const_11 = svdup_n_s32(11);\n    svint32_t const_13 = svdup_n_s32(13);\n    svint32_t const_n = svdup_n_s32(n); // Duplicate n once\n\n    // Loop through numbers in chunks of vector length (vl)\n    for (int i = 0; i < n; i += vl) {\n        // Create a vector of numbers starting from 'i': [i, i+1, ..., i+vl-1]\n        svint32_t current_numbers = svindex_s32(i, 1);\n\n        // Create a predicate for elements that are actually less than 'n'\n        // This ensures we only process valid numbers within the current chunk\n        svbool_t active_elements_pg = svcmplt_s32(pg, current_numbers, const_n);\n\n        // Initialize a vector to store the count of '7's for each number in the current_numbers vector\n        svint32_t sevens_in_current_chunk = const_0;\n\n        // Make a copy of current_numbers for digit extraction.\n        // Elements outside the valid range (< n) are zeroed out to simplify digit extraction logic.\n        svint32_t temp_numbers = svsel_s32(active_elements_pg, current_numbers, const_0);\n\n        // Loop to extract digits and count '7's for each number in parallel.\n        // The loop continues as long as any active number in `temp_numbers` is non-zero.\n        while (svptest_any(active_elements_pg, svcmpne_n_s32(pg, temp_numbers, 0))) {\n            // Extract the last digit of each number\n            // Using full predicate 'pg' is fine as inactive lanes are already zeroed or will be masked later.\n            svint32_t last_digits = svmod_s32_x(pg, temp_numbers, const_10);\n\n            // Check if the last digit is '7'\n            svbool_t is_seven_digit = svcmpeq_s32(pg, last_digits, const_7);\n\n            // Increment the count of '7's for elements where the digit is '7'.\n            // The increment only applies to elements that are still active and have a '7' digit.\n            sevens_in_current_chunk = svadd_m(sevens_in_current_chunk, svand_b(active_elements_pg, is_seven_digit), sevens_in_current_chunk, const_1);\n\n            // Remove the last digit (integer division by 10)\n            temp_numbers = svdiv_s32_x(pg, temp_numbers, const_10);\n        }\n\n        // Now, check divisibility by 11 or 13 for the original numbers.\n        // Operations are performed only on 'active_elements_pg' to avoid unnecessary computations.\n        svint32_t mod11 = svmod_s32_x(active_elements_pg, current_numbers, const_11);\n        svbool_t div_by_11 = svcmpeq_s32(active_elements_pg, mod11, const_0);\n\n        svint32_t mod13 = svmod_s32_x(active_elements_pg, current_numbers, const_13);\n        svbool_t div_by_13 = svcmpeq_s32(active_elements_pg, mod13, const_0);\n\n        // Combine divisibility predicates: (divisible by 11 OR divisible by 13)\n        svbool_t divisible_by_11_or_13 = svorr_b(div_by_11, div_by_13);\n\n        // Create a final predicate: (number < n) AND (divisible by 11 OR 13)\n        svbool_t final_predicate = svand_b(active_elements_pg, divisible_by_11_or_13);\n\n        // Select the counts of '7's only for numbers that satisfy the final criteria.\n        // For numbers that don't satisfy the criteria, their count is set to 0.\n        svint32_t counts_to_sum = svsel_s32(final_predicate, sevens_in_current_chunk, const_0);\n\n        // Sum all elements in the `counts_to_sum` vector and add to the total.\n        // The full predicate 'pg' is used here as we want to sum all elements in the vector,\n        // where non-relevant counts have already been zeroed out by svsel.\n        total_sevens += svaddv_s32(pg, counts_to_sum);\n    }\n\n    return total_sevens;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int total_sevens = 0;\n\n    // Iterate through numbers in chunks of SVE vector length\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (int i = 0; i < n; i += svcntw()) {\n        // 1. Generate a predicate 'pg' for active lanes.\n        // This predicate ensures that we only process numbers less than 'n'.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // 2. Generate a vector of numbers: [i, i+1, ..., i+svcntw()-1]\n        svint32_t numbers = svindex_s32(i, 1);\n\n        // 3. Perform divisibility checks: (number % 11 == 0) || (number % 13 == 0)\n        // SVE does not have a direct modulo intrinsic.\n        // We use the property: a % b == 0  <=>  a == (a / b) * b\n        \n        // Check divisibility by 11\n        svint32_t div_by_11_quotient = svdiv_s32(numbers, 11);\n        svbool_t div_by_11 = svcmpeq_s32(pg, svmul_s32(div_by_11_quotient, 11), numbers);\n\n        // Check divisibility by 13\n        svint32_t div_by_13_quotient = svdiv_s32(numbers, 13);\n        svbool_t div_by_13 = svcmpeq_s32(pg, svmul_s32(div_by_13_quotient, 13), numbers);\n\n        // Combine the divisibility conditions\n        svbool_t condition_met = svorr_b32(div_by_11, div_by_13);\n\n        // Create the final predicate for elements that satisfy both 'i < n' and the divisibility condition\n        svbool_t active_elements_for_counting = svand_b32(pg, condition_met);\n\n        // If no elements in this chunk satisfy the condition, skip digit counting and proceed to the next chunk.\n        if (!svptest_any(svptrue_b32(), active_elements_for_counting)) {\n            continue;\n        }\n\n        // 4. Count occurrences of the digit '7' for numbers that satisfy the condition.\n        svint32_t current_numbers_to_check = numbers;\n        svint32_t seven_counts_per_element = svdup_s32(0); // Initialize counts to zero for each lane\n\n        // This mask controls which lanes are still being processed for digit counting.\n        // Initially, it's set to `active_elements_for_counting`.\n        svbool_t digit_counting_mask = active_elements_for_counting;\n\n        // Loop while there are still active elements that have digits left to check (i.e., not zero).\n        // A 32-bit integer can have at most 10 digits (e.g., 2,147,483,647), so this loop runs at most 10 times.\n        while (svptest_any(svptrue_b32(), digit_counting_mask)) {\n            // Extract the last digit: digit = current_numbers_to_check % 10\n            // Again, using (a - (a/b)*b) for modulo.\n            svint32_t divided_by_10 = svdiv_s32(current_numbers_to_check, 10);\n            svint32_t digit = svsub_s32(current_numbers_to_check, svmul_s32(divided_by_10, 10));\n\n            // Check if the extracted digit is '7' for the currently active lanes.\n            svbool_t is_seven_for_active = svcmpeq_s32(digit_counting_mask, digit, 7);\n\n            // Increment the count of '7's for lanes where 'is_seven_for_active' is true.\n            // svadd_s32_m performs a masked addition.\n            seven_counts_per_element = svadd_s32_m(is_seven_for_active, seven_counts_per_element, svdup_s32(1));\n\n            // Remove the last digit by integer division: current_numbers_to_check = current_numbers_to_check / 10\n            current_numbers_to_check = divided_by_10;\n\n            // Update the digit_counting_mask: only continue for elements that are still non-zero.\n            // svcmpne_s32(svptrue_b32(), current_numbers_to_check, 0) creates a predicate for all lanes that are not zero.\n            // This is then ANDed with the existing digit_counting_mask to narrow down active lanes.\n            digit_counting_mask = svand_b32(digit_counting_mask, svcmpne_s32(svptrue_b32(), current_numbers_to_check, 0));\n        }\n\n        // 5. Accumulate the total count of '7's from the current vector chunk.\n        // svreduce_add_s32 sums all elements of the vector that are active under the given predicate.\n        // We use `active_elements_for_counting` to ensure only counts from numbers that met the initial conditions are summed.\n        total_sevens += svreduce_add_s32(active_elements_for_counting, seven_counts_per_element);\n    }\n\n    return total_sevens;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    const size_t N = l.size();\n    if (N == 0) {\n        return {};\n    }\n\n    // Determine SVE vector length for float (32-bit word)\n    const size_t vl = svcntw();\n\n    // Phase 1: Extract all even-indexed elements using SVE\n    // Pre-allocate buffer for even elements. Max N/2 elements.\n    // Using a raw array for efficient SVE stores, then construct std::vector.\n    float* even_buffer = new float[N / 2 + (N % 2)]; // Max possible even elements\n    float* current_even_ptr = even_buffer;\n\n    // Predicates for even/odd indices within a full SVE vector\n    // svindex_s32(0, 1) creates [0, 1, 2, 3, ...]\n    // svand_n_s32(indices, 1) computes (index & 1)\n    // svcmpeq_n_s32(pg, (index & 1), 0) checks if (index & 1) == 0 (i.e., even)\n    svbool_t pg_all_vl = svwhilelt_b32(0, vl); // Full predicate for VL\n    svint32_t indices_base = svindex_s32(0, 1);\n    svbool_t even_mask_in_vec = svcmpeq_n_s32(pg_all_vl, svand_n_s32(indices_base, 1), 0);\n\n    for (size_t i = 0; i < N; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, N); // Predicate for current chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]); // Load chunk from input vector\n\n        // Create predicate for even indices within the current chunk\n        svbool_t current_even_pg = svand_b(pg, even_mask_in_vec);\n\n        // Compact the even elements\n        svfloat32_t compacted_even = svcompact_f32(current_even_pg, vec);\n\n        // Count how many even elements were compacted in this chunk\n        int num_even_in_chunk = svcntp_b32(pg, current_even_pg);\n\n        // Store the compacted even elements to our temporary buffer\n        svst1_f32(svwhilelt_b32(0, num_even_in_chunk), current_even_ptr, compacted_even);\n        current_even_ptr += num_even_in_chunk;\n    }\n\n    // Create std::vector from the collected even elements\n    std::vector<float> even_elements(even_buffer, current_even_ptr);\n    delete[] even_buffer; // Clean up temporary buffer\n\n    // Phase 2: Sort the extracted even elements (using std::sort as SVE doesn't provide global sort)\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Phase 3: Recombine sorted even elements and original odd elements into the result vector\n    std::vector<float> result(N);\n    float* sorted_even_ptr = even_elements.data(); // Pointer to sorted even elements\n\n    // Predicate for odd indices within a full SVE vector\n    svbool_t odd_mask_in_vec = svcmpne_n_s32(pg_all_vl, svand_n_s32(indices_base, 1), 0);\n    \n    for (size_t i = 0; i < N; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, N); // Predicate for current chunk\n        svfloat32_t original_vec = svld1_f32(pg, &l[i]); // Load original chunk\n\n        // Store odd elements directly from original_vec to result using SVE\n        svbool_t current_odd_pg = svand_b(pg, odd_mask_in_vec);\n        svst1_f32(current_odd_pg, &result[i], original_vec);\n\n        // For even elements, iterate through the chunk and place sorted values.\n        // This part uses a scalar loop as there's no direct SVE \"uncompact\" intrinsic\n        // that efficiently places compacted data into sparse positions without complex gather/scatter setup.\n        for (size_t j = 0; j < vl; ++j) {\n            if ((i + j) < N && ((i + j) % 2 == 0)) { // If current index is even and within bounds\n                result[i + j] = *sorted_even_ptr++;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return {};\n    }\n\n    const size_t N = l.size();\n    std::vector<float> result = l; // Create a copy of the input vector to modify\n\n    // 1. Extract all even-indexed elements from the input vector 'l'\n    // Determine the total number of even-indexed elements.\n    // For N elements (0 to N-1), even indices are 0, 2, 4, ...\n    // The count is (N + 1) / 2.\n    const size_t num_even_elements = (N + 1) / 2;\n    std::vector<float> even_elements(num_even_elements);\n    size_t current_even_elements_offset = 0; // Tracks the current insertion position in 'even_elements'\n\n    // Get the SVE vector length in terms of number of float elements (e.g., 4, 8, 16)\n    const size_t sv_vec_len = svcnt_f32();\n\n    // Loop through the input vector 'l' in chunks of SVE vector length\n    for (size_t i = 0; i < N; i += sv_vec_len) {\n        // Create a predicate 'pg' to handle the tail end of the vector,\n        // ensuring we only process elements up to N.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load a vector of float elements from 'l' using the predicate 'pg'\n        svfloat32_t current_vec = svld1(pg, &l[i]);\n\n        // Create a vector of global indices for the current chunk: {i, i+1, i+2, ...}\n        svuint32_t indices = svindex_u32(i, 1);\n\n        // Create a predicate 'even_mask' for elements that correspond to even global indices.\n        // (index % 2 == 0) is equivalent to (index & 1 == 0).\n        svbool_t even_mask = svcmpeq(svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n\n        // Compact the elements that satisfy 'even_mask' to the start of a new SVE vector.\n        // This packs only the even-indexed elements from 'current_vec'.\n        svfloat32_t compacted_even_vec = svcompact(even_mask, current_vec);\n\n        // Count how many elements were compacted (i.e., how many even elements are in this chunk).\n        int num_compacted = svcntp_b32(pg, even_mask);\n\n        // If there are compacted elements, store them into the 'even_elements' vector.\n        if (num_compacted > 0) {\n            // Use a temporary fixed-size buffer to store the compacted SVE vector elements.\n            // The maximum size of an SVE vector is sv_vec_len.\n            float temp_compacted[sv_vec_len];\n            // Store the compacted vector into the temporary buffer.\n            // A predicate is used to ensure only the valid 'num_compacted' elements are stored.\n            svst1(svwhilelt_b32(0, num_compacted), temp_compacted, compacted_even_vec);\n\n            // Copy the elements from the temporary buffer to the 'even_elements' std::vector.\n            // This is a scalar loop, but it copies a contiguous block of data.\n            for (int k = 0; k < num_compacted; ++k) {\n                even_elements[current_even_elements_offset + k] = temp_compacted[k];\n            }\n            current_even_elements_offset += num_compacted;\n        }\n    }\n\n    // 2. Sort the extracted even elements using std::sort (a CPU-based sorting algorithm)\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // 3. Re-insert the sorted even elements back into their original even positions in 'result'\n    current_even_elements_offset = 0; // Reset offset for reading from the sorted 'even_elements' vector\n\n    // Loop through the 'result' vector (which is a copy of the original 'l') in SVE chunks\n    for (size_t i = 0; i < N; i += sv_vec_len) {\n        // Predicate for the current chunk\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load the current chunk from 'result'\n        svfloat32_t current_result_vec = svld1(pg, &result[i]);\n\n        // Create a vector of global indices for the current chunk\n        svuint32_t indices = svindex_u32(i, 1);\n\n        // Create a predicate for even global indices within this SVE vector chunk\n        svbool_t even_mask = svcmpeq(svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n\n        // Count how many even elements are present in this specific SVE chunk\n        int num_even_in_chunk = svcntp_b32(pg, even_mask);\n\n        if (num_even_in_chunk > 0) {\n            // Prepare an SVE vector to hold the sorted even elements, unpacked to their correct lanes.\n            // Initialize with dummy values (e.g., zeros).\n            svfloat32_t sorted_even_vec_unpacked = svdup_f32(0.0f);\n\n            // Fill 'sorted_even_vec_unpacked' by inserting elements from 'even_elements'\n            // into the lanes identified by 'even_mask'.\n            // This loop iterates over the lanes of the SVE vector.\n            for (int k = 0; k < sv_vec_len; ++k) {\n                // Check if the k-th lane is active according to 'even_mask' (and 'pg')\n                if (svqget_b32(even_mask, k)) {\n                    // Insert the next sorted even element into this specific lane 'k'\n                    sorted_even_vec_unpacked = svset_f32(sorted_even_vec_unpacked, k, even_elements[current_even_elements_offset]);\n                    current_even_elements_offset++;\n                }\n            }\n\n            // Use svsel to combine elements:\n            // If 'even_mask' is true for a lane, take the value from 'sorted_even_vec_unpacked'.\n            // Otherwise (if 'even_mask' is false, meaning it's an odd index),\n            // keep the original value from 'current_result_vec'.\n            current_result_vec = svsel(even_mask, sorted_even_vec_unpacked, current_result_vec);\n        }\n        // If num_even_in_chunk is 0, 'current_result_vec' remains unchanged,\n        // as there are no even elements in this chunk to modify.\n\n        // Store the modified SVE vector back to the 'result' vector\n        svst1(pg, &result[i], current_result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t num_elements = l.size();\n    if (num_elements == 0) {\n        return {};\n    }\n\n    std::vector<float> l_prime(num_elements);\n\n    // Calculate the number of even-indexed elements\n    // For N elements, there are ceil(N/2) even-indexed elements (0, 2, 4, ...)\n    size_t num_even_elements = (num_elements + 1) / 2;\n    std::vector<float> even_elements_storage(num_even_elements);\n    size_t even_idx_counter = 0; // Tracks current write position in even_elements_storage\n\n    // --- Step 1: Extract all even elements using SVE ---\n    // Iterate through the input vector in chunks of SVE vector length (VL)\n    for (size_t i = 0; i < num_elements; i += svcnt_f32()) {\n        // Create a predicate for the current chunk, active for elements within bounds\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n\n        // Generate global indices for the current vector chunk (i, i+1, i+2, ...)\n        svuint32_t global_indices = svindex_u32(i, 1);\n\n        // Create a predicate for even global indices within the active chunk\n        // (global_index % 2) == 0\n        svbool_t pg_even_in_chunk = svcmpeq(pg, svand_u32(global_indices, 1), 0);\n\n        // Load the data chunk from the input vector 'l'\n        svfloat32_t data_chunk = svld1(pg, &l[i]);\n\n        // Compress the even elements from 'data_chunk' into a dense SVE vector\n        svfloat32_t compressed_even = svcompress_f32(pg_even_in_chunk, data_chunk);\n\n        // Count how many even elements were compressed in this chunk\n        size_t num_even_in_this_chunk = svcntp_b32(pg_even_in_chunk);\n\n        // Store the compressed even elements into the temporary 'even_elements_storage'\n        // The predicate for storing is based on the number of elements to store,\n        // ensuring we only write up to 'num_even_in_this_chunk' elements.\n        svst1_f32(svwhilelt_b32(0, num_even_in_this_chunk), &even_elements_storage[even_idx_counter], compressed_even);\n\n        // Update the counter for the next write location in 'even_elements_storage'\n        even_idx_counter += num_even_in_this_chunk;\n    }\n\n    // --- Step 2: Sort the extracted even elements ---\n    // This step uses std::sort as SVE does not provide a general sorting intrinsic.\n    std::sort(even_elements_storage.begin(), even_elements_storage.end());\n\n    // --- Step 3: Reconstruct the output vector 'l_prime' using SVE ---\n    size_t current_even_read_idx = 0; // Tracks current read position in even_elements_storage\n\n    for (size_t i = 0; i < num_elements; i += svcnt_f32()) {\n        // Create a predicate for the current chunk, active for elements within bounds\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n\n        // Generate global indices for the current vector chunk\n        svuint32_t global_indices = svindex_u32(i, 1);\n\n        // Predicate for even global indices within the active chunk\n        svbool_t pg_even_in_chunk = svcmpeq(pg, svand_u32(global_indices, 1), 0);\n        // Predicate for odd global indices within the active chunk\n        svbool_t pg_odd_in_chunk = svcmpeq(pg, svand_u32(global_indices, 1), 1);\n\n        // Load the original data chunk from the input vector 'l'\n        svfloat32_t original_chunk = svld1(pg, &l[i]);\n\n        // Store odd elements directly from 'original_chunk' to 'l_prime'\n        // Only elements where 'pg_odd_in_chunk' is true will be written.\n        svst1_f32(pg_odd_in_chunk, &l_prime[i], original_chunk);\n\n        // Count how many even elements are needed for this chunk\n        size_t num_even_in_this_chunk = svcntp_b32(pg_even_in_chunk);\n\n        // Load the sorted even elements from 'even_elements_storage'\n        // The predicate ensures we only load up to 'num_even_in_this_chunk' elements.\n        svfloat32_t sorted_even_chunk = svld1(svwhilelt_b32(0, num_even_in_this_chunk), &even_elements_storage[current_even_read_idx]);\n\n        // Generate scatter offsets for even positions (0, 2, 4, ...) relative to the base address &l_prime[i]\n        svint32_t scatter_offsets = svindex_s32(0, 2);\n\n        // Scatter the 'sorted_even_chunk' into the even positions of 'l_prime'\n        // 'pg_even_in_chunk' ensures only active even lanes are written.\n        // 'sorted_even_chunk' is dense, and its elements are written sequentially\n        // to the addresses calculated by '&l_prime[i] + scatter_offsets[j]' for active 'j'.\n        svst1_scatter_s32offset_f32(pg_even_in_chunk, &l_prime[i], scatter_offsets, sorted_even_chunk);\n\n        // Update the counter for the next read location from 'even_elements_storage'\n        current_even_read_idx += num_even_in_this_chunk;\n    }\n\n    return l_prime;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return {};\n    }\n\n    std::vector<float> even_values;\n    // Reserve approximate size to reduce reallocations.\n    // For N elements, roughly N/2 are even.\n    even_values.reserve(l.size() / 2 + (l.size() % 2)); \n\n    const size_t VL = svcntw(); // Get the SVE vector length in terms of float elements\n\n    // Phase 1: Gather all even-indexed elements from the input vector 'l' using SVE.\n    // These elements will be stored contiguously in 'even_values'.\n    for (size_t i = 0; i < l.size(); i += VL) {\n        // Create a predicate for the current chunk, handling potential tail elements.\n        // 'pg' is true for active lanes within the current vector length.\n        svbool_t pg = svwhilelt_b32(i, l.size()); \n\n        // Load the current chunk of data from the input vector 'l'.\n        svfloat32_t current_vec = svld1_f32(pg, &l[i]);\n\n        // Generate global indices for the current chunk: [i, i+1, i+2, ..., i+VL-1]\n        svint32_t global_indices = svindex_s32(i, 1);\n\n        // Create a predicate 'p_even' that is true for elements at even global indices.\n        // (global_index % 2 == 0) is equivalent to (global_index & 1 == 0).\n        svbool_t p_even = svcmpeq_s32(pg, svand_s32(pg, global_indices, svdup_s32(pg, 1)), svdup_s32(pg, 0));\n\n        // Compact the even-indexed elements into a new SVE vector.\n        // 'packed_even' will contain only the elements where 'p_even' is true, packed to the left.\n        svfloat32_t packed_even = svcompact_f32(p_even, current_vec);\n\n        // Get the number of active (even) elements in the compacted vector.\n        size_t num_active_even = svcntp_b32(pg, p_even);\n\n        // Store the packed even elements to a temporary C array.\n        // SVE intrinsics cannot directly append to a dynamically growing std::vector.\n        // Therefore, we store to a fixed-size temporary array and then copy.\n        float temp_buffer[VL]; \n        svst1_f32(svwhilelt_b32(0, num_active_even), temp_buffer, packed_even);\n        \n        // Append the elements from the temporary array to the 'even_values' vector.\n        for (size_t k = 0; k < num_active_even; ++k) {\n            even_values.push_back(temp_buffer[k]);\n        }\n    }\n\n    // Phase 2: Sort the gathered even values.\n    // This step uses std::sort, which is typically highly optimized but not SVE-accelerated itself.\n    std::sort(even_values.begin(), even_values.end());\n\n    // Phase 3: Scatter the sorted even values back into their original even positions in the result vector.\n    std::vector<float> result = l; // Start with a copy of the original vector 'l'.\n    size_t even_values_idx = 0;    // Index to track the current position in the sorted 'even_values' vector.\n\n    for (size_t i = 0; i < l.size(); i += VL) {\n        // Create a predicate for the current chunk, handling potential tail elements.\n        svbool_t pg = svwhilelt_b32(i, l.size()); \n\n        // Load the current chunk of data from the result vector.\n        // This vector still contains the original odd values at their positions.\n        svfloat32_t current_result_vec = svld1_f32(pg, &result[i]);\n\n        // Generate local indices for the current chunk: [0, 1, 2, ..., VL-1]\n        svint32_t local_indices = svindex_s32(0, 1);\n\n        // Create a predicate 'p_even_local' that is true for elements at even local indices.\n        svbool_t p_even_local = svcmpeq_s32(pg, svand_s32(pg, local_indices, svdup_s32(pg, 1)), svdup_s32(pg, 0));\n\n        // Calculate the indices for gathering from the packed 'even_values' array.\n        // If an element is at local_index 'k' in the SVE vector, and 'k' is even,\n        // its corresponding sorted value is at 'even_values_idx + (k / 2)'.\n        svint32_t gather_indices_for_even = svdiv_s32(pg, local_indices, svdup_s32(pg, 2));\n\n        // Load the sorted even values into the correct (sparse) positions of an SVE vector.\n        // 'svld1_gather_s32index_f32' loads values from memory using a base pointer and a vector of indices.\n        // Only lanes where 'p_even_local' is true will be loaded.\n        // For example, if VL=8, local_indices=[0,1,2,3,4,5,6,7], p_even_local=[T,F,T,F,T,F,T,F],\n        // gather_indices_for_even=[0,0,1,1,2,2,3,3].\n        // Lane 0 (T): loads from &even_values[even_values_idx + 0]\n        // Lane 1 (F): untouched\n        // Lane 2 (T): loads from &even_values[even_values_idx + 1]\n        // Lane 3 (F): untouched\n        // ...\n        svfloat32_t unpacked_sorted_even = svld1_gather_s32index_f32(p_even_local, &even_values[even_values_idx], gather_indices_for_even);\n\n        // Update the index for the next chunk of sorted even values.\n        size_t num_active_even_in_chunk = svcntp_b32(pg, p_even_local);\n        even_values_idx += num_active_even_in_chunk;\n\n        // Combine the original odd elements with the new sorted even elements.\n        // 'svsel_f32(predicate, true_source, false_source)' selects elements.\n        // Where 'p_even_local' is true (even positions), take values from 'unpacked_sorted_even'.\n        // Where 'p_even_local' is false (odd positions), take values from 'current_result_vec' (which holds original odd values).\n        svfloat32_t final_chunk = svsel_f32(p_even_local, unpacked_sorted_even, current_result_vec);\n\n        // Store the final combined chunk back to the result vector.\n        svst1_f32(pg, &result[i], final_chunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::sort\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return {};\n    }\n\n    std::vector<float> l_prime(l.size());\n    \n    // Get the SVE vector length for float32. This is determined at runtime.\n    const size_t vl = svcntf32();\n\n    // Step 1: Extract Even Elements using SVE intrinsics\n    std::vector<float> temp_even_values;\n    // Reserve space to avoid frequent reallocations. Max possible even elements.\n    temp_even_values.reserve(l.size() / 2 + (l.size() % 2)); \n    size_t current_even_count = 0; // Tracks the number of even elements extracted so far\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        // Create a predicate for the current chunk, handling partial vectors at the end of the input.\n        // `svwhilelt_b32(start_index, limit)` generates a predicate where lanes are true\n        // as long as their corresponding absolute index (start_index + lane_offset) is less than limit.\n        svbool_t pg = svwhilelt_b32(i, l.size());\n\n        // Load a chunk of data from the input vector 'l' using the predicate 'pg'.\n        // Elements corresponding to false predicate lanes are not loaded (or loaded as zeros, depending on implementation).\n        svfloat32_t vec = svld1(pg, &l[i]);\n\n        // Generate absolute indices for the current chunk (i, i+1, i+2, ...)\n        svuint32_t indices = svindex_u32(i, 1);\n\n        // Create a predicate for even absolute indices within the active lanes.\n        // `svand_u32(indices, svdup_n_u32(1))` computes (index % 2).\n        // `svcmpeq(pg, ..., svdup_n_u32(0))` compares the result with 0, under predicate `pg`.\n        svbool_t pg_even_abs = svcmpeq(pg, svand_u32(indices, svdup_n_u32(1)), svdup_n_u32(0));\n\n        // Compress the vector to get only the elements at even indices.\n        // `svcompress` packs the active elements (where `pg_even_abs` is true) to the start of the vector.\n        svfloat32_t compressed_even = svcompress(pg_even_abs, vec);\n\n        // Count how many even elements are in this chunk.\n        // `svcntp_b32(pg, pg_even_abs)` counts true bits in `pg_even_abs` that are also true in `pg`.\n        size_t num_even_in_chunk = svcntp_b32(pg, pg_even_abs);\n\n        if (num_even_in_chunk > 0) {\n            // Resize `temp_even_values` to accommodate the new elements.\n            temp_even_values.resize(current_even_count + num_even_in_chunk);\n            // Store the compressed even elements contiguously into `temp_even_values`.\n            // `svptrue_v_f32()` is used as the predicate for `svst1` because `compressed_even`\n            // contains valid data packed at its beginning, up to `num_even_in_chunk` elements.\n            svst1(svptrue_v_f32(), &temp_even_values[current_even_count], compressed_even);\n            current_even_count += num_even_in_chunk;\n        }\n    }\n    // Trim `temp_even_values` to its actual size, as `reserve` might allocate more.\n    temp_even_values.resize(current_even_count);\n\n    // Step 2: Sort the extracted even elements using standard library sort.\n    // SVE intrinsics are designed for data-parallel operations, not general-purpose sorting\n    // of arbitrary-length arrays. `std::sort` is the most practical and efficient choice here.\n    std::sort(temp_even_values.begin(), temp_even_values.end());\n\n    // Step 3: Re-insert sorted even elements and original odd elements using SVE intrinsics.\n    size_t global_even_read_idx = 0; // Index for reading from `temp_even_values`\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        // Create a predicate for the current chunk, handling partial vectors.\n        svbool_t pg = svwhilelt_b32(i, l.size());\n\n        // Load a chunk of data from the original input vector 'l'.\n        svfloat32_t original_vec = svld1(pg, &l[i]);\n\n        // Generate absolute indices for the current chunk.\n        svuint32_t indices = svindex_u32(i, 1);\n\n        // Create predicates for even and odd absolute indices within the active lanes.\n        svbool_t pg_even_abs = svcmpeq(pg, svand_u32(indices, svdup_n_u32(1)), svdup_n_u32(0));\n        svbool_t pg_odd_abs = svcmpeq(pg, svand_u32(indices, svdup_n_u32(1)), svdup_n_u32(1));\n\n        // Store original odd elements into `l_prime`.\n        // `svst1(predicate, base_address, vector)` stores elements from `vector` to `base_address`\n        // only where `predicate` is true. Other memory locations remain untouched.\n        svst1(pg_odd_abs, &l_prime[i], original_vec);\n\n        // Load sorted even elements and store them into `l_prime` at even positions.\n        size_t num_even_in_chunk = svcntp_b32(pg, pg_even_abs);\n        if (num_even_in_chunk > 0) {\n            // Load the next `num_even_in_chunk` sorted even values from `temp_even_values`.\n            // `svptrue_v_f32()` is used as the predicate for `svld1` because we are loading\n            // a contiguous block of sorted data.\n            svfloat32_t sorted_even_part = svld1(svptrue_v_f32(), &temp_even_values[global_even_read_idx]);\n            global_even_read_idx += num_even_in_chunk;\n            \n            // Store these sorted even values into `l_prime` at their respective even positions.\n            // This operation will only write to the even-indexed locations within the current chunk,\n            // leaving the odd-indexed locations (which were filled by the previous `svst1`) untouched.\n            svst1(pg_even_abs, &l_prime[i], sorted_even_part);\n        }\n    }\n\n    return l_prime;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int N = l.size();\n\n    // If the vector has fewer than 3 elements, it's impossible to find three distinct elements.\n    if (N < 3) {\n        return false;\n    }\n\n    // Iterate through all possible combinations of two distinct elements (l[i], l[j])\n    // The outer loops ensure that i < j, guaranteeing distinct indices for the first two elements.\n    for (int i = 0; i < N; ++i) {\n        int val_i = l[i];\n        for (int j = i + 1; j < N; ++j) {\n            int val_j = l[j];\n            \n            // Calculate the target value for the third element (l[k])\n            // such that l[i] + l[j] + l[k] == 0.\n            int target_k = -(val_i + val_j);\n\n            // Use SVE intrinsics to efficiently search for target_k in the remaining part of the vector.\n            // The search starts from index j + 1 to ensure that k is distinct from i and j (i < j < k).\n            for (int k = j + 1; k < N; k += svcntw()) {\n                // Create a predicate vector that is true for elements within the valid bounds [k, N-1].\n                // This handles partial vectors at the end of the array.\n                svbool_t p_k = svwhilelt_b32(k, N);\n\n                // Load a vector of 32-bit integers from the input list 'l' starting at index 'k'.\n                // Only elements corresponding to active lanes in p_k will be loaded.\n                svint32_t vec_l_k = svld1_s32(p_k, &l[k]);\n\n                // Create a vector where all elements are the 'target_k' value.\n                svint32_t vec_target_k = svdup_s32(target_k);\n\n                // Compare each element in vec_l_k with vec_target_k.\n                // The comparison is performed only for active lanes defined by p_k.\n                svbool_t cmp_result = svcmpeq_s32(p_k, vec_l_k, vec_target_k);\n\n                // Check if any active lane in the comparison result is true.\n                // If true, it means we found an l[k'] such that l[k'] == target_k,\n                // and k' is a distinct index (since k' >= k > j > i).\n                if (svptest_any(p_k, cmp_result)) {\n                    return true; // Three distinct elements summing to zero found.\n                }\n            }\n        }\n    }\n\n    // No such triple was found after checking all combinations.\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> // Required for std::vector\n\n/*\ntriples_sum_to_zero takes a vector of integers as an input.\nit returns true if there are three distinct elements in the vector that\nsum to zero, and false otherwise.\n\n>>> triples_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero_simd({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero_simd({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    int N = l.size();\n\n    // A triple requires at least 3 elements.\n    if (N < 3) {\n        return false;\n    }\n\n    // Iterate through all possible combinations of i and j.\n    // i, j, and k must be distinct indices.\n    // The loops are structured such that i < j < k.\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            // Calculate the target value for the third element (k)\n            // such that l[i] + l[j] + l[k] == 0\n            // This means l[k] must be -(l[i] + l[j])\n            int val_i = l[i];\n            int val_j = l[j];\n            int target_k = -(val_i + val_j);\n\n            // Use SVE intrinsics to efficiently search for target_k in the remaining part of the vector (from index j + 1)\n            // The loop for k starts from j + 1 to ensure k > j and thus k != i, k != j.\n            for (int k = j + 1; k < N; k += svcntw()) {\n                // Create a predicate vector for the current chunk of elements starting at index k.\n                // svwhilelt_b32(k, N) generates a predicate that is true for elements\n                // whose original index is less than N, effectively handling the end of the array.\n                svbool_t pg = svwhilelt_b32(k, N);\n\n                // If the predicate is all false, it means there are no more valid elements\n                // to process in this chunk or subsequent chunks, so we can break early.\n                if (!svptest_any(svptrue_b32(), pg)) {\n                    break;\n                }\n\n                // Load a vector of 32-bit integers from the array 'l' starting at index 'k',\n                // using the predicate 'pg' to only load valid elements.\n                svint32_t vec_k = svld1_s32(pg, &l[k]);\n\n                // Compare each active element in 'vec_k' with 'target_k'.\n                // The result 'match' is a predicate vector where true indicates an equality.\n                svbool_t match = svcmpeq_n_s32(pg, vec_k, target_k);\n\n                // Check if any element in the 'match' predicate is true (i.e., a match was found).\n                // svptest_any(pg, match) checks if any lane enabled by 'pg' in 'match' is true.\n                if (svptest_any(pg, match)) {\n                    return true; // Found a triple (l[i], l[j], l[k]) that sums to zero\n                }\n            }\n        }\n    }\n\n    // If no such triple is found after checking all combinations, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t N = l.size();\n\n    if (N < 3) {\n        return false;\n    }\n\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = i + 1; j < N; ++j) {\n            int sum_ij = l[i] + l[j];\n            int target_k = -sum_ij;\n\n            for (size_t k = j + 1; k < N; k += svcntw()) {\n                svbool_t pg = svwhilelt_b32(k, N);\n\n                if (!svptest_any(pg, svptrue_b32())) {\n                    break; \n                }\n\n                svint32_t vec_k = svld1_s32(pg, &l[k]);\n                svint32_t target_vec = svdup_s32(target_k);\n\n                svbool_t cmp_result = svcmpeq_s32(pg, vec_k, target_vec);\n\n                if (svptest_any(pg, cmp_result)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t N = l.size();\n\n    // A triplet requires at least 3 elements.\n    if (N < 3) {\n        return false;\n    }\n\n    // Iterate through all possible combinations of three distinct elements (l[i], l[j], l[k])\n    // such that i < j < k. This ensures distinct indices.\n    for (size_t i = 0; i < N; ++i) {\n        int val_i = l[i];\n\n        for (size_t j = i + 1; j < N; ++j) {\n            int val_j = l[j];\n            \n            // Calculate the target value for the third element (l[k])\n            // such that val_i + val_j + l[k] == 0\n            // This means l[k] must be -(val_i + val_j)\n            int target_k = -(val_i + val_j);\n\n            // Vectorize the search for target_k in the remaining part of the array (l[j+1 ... N-1])\n            // We iterate with a step of svcntw() (the number of 32-bit integers in an SVE vector).\n            for (size_t k_idx = j + 1; k_idx < N; k_idx += svcntw()) {\n                // Create a predicate for active lanes.\n                // This predicate ensures that we only process valid elements within the array bounds.\n                svbool_t pg = svwhilelt_b32(k_idx, N);\n\n                // Load a vector of integers from the array 'l' starting at k_idx,\n                // using the predicate 'pg' to mask out-of-bounds elements.\n                svint32_t vec_k = svld1(pg, &l[k_idx]);\n\n                // Create a vector where all elements are the 'target_k' value.\n                svint32_t target_vec = svdup_n_s32(target_k);\n\n                // Compare each element in 'vec_k' with 'target_vec'.\n                // The result is a boolean vector indicating matches.\n                svbool_t match = svcmpeq(pg, vec_k, target_vec);\n\n                // Check if any of the active lanes in the 'match' predicate are true.\n                // If there's at least one match, we found a triplet that sums to zero.\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // If no such triplet is found after checking all combinations, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int N = l.size();\n\n    if (N < 3) {\n        return false;\n    }\n\n    // Outer loop for the first element 'i'\n    for (int i = 0; i < N - 2; ++i) {\n        // Middle loop for the second element 'j'\n        // 'j' must be distinct from 'i' and greater than 'i'\n        for (int j = i + 1; j < N - 1; ++j) {\n            // Calculate the sum of the first two elements\n            int sum_ij = l[i] + l[j];\n            // The target value for the third element 'k' to make the sum zero\n            int target_k = -sum_ij;\n\n            // Vectorized inner loop for the third element 'k'\n            // 'k' must be distinct from 'i' and 'j', and greater than 'j'\n            // Iterate 'k_idx' in steps of svcntw() (the number of 32-bit elements in an SVE vector)\n            for (int k_idx = j + 1; k_idx < N; k_idx += svcntw()) {\n                // Create a predicate for the current vector chunk.\n                // This predicate ensures that we only process valid elements within the vector bounds [k_idx, N-1].\n                svbool_t pg = svwhilelt_b32(k_idx, N);\n\n                // Load a vector of elements from 'l' starting at 'l[k_idx]' using the predicate.\n                svint32_t vec_k = svld1_s32(pg, &l[k_idx]);\n\n                // Duplicate the 'target_k' value into an SVE vector.\n                svint32_t target_vec = svdup_s32(target_k);\n\n                // Compare each element in 'vec_k' with 'target_vec'.\n                // The result is a predicate vector where 'true' indicates a match.\n                svbool_t cmp_result = svcmpeq(pg, vec_k, target_vec);\n\n                // Check if any element in the current chunk matched the target.\n                // svptest_any returns true if any active element in 'cmp_result' is true.\n                if (svptest_any(pg, cmp_result)) {\n                    return true; // Found three distinct elements that sum to zero\n                }\n            }\n        }\n    }\n\n    // No such triple found after checking all combinations\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n\n    if (l.empty()) {\n        return result;\n    }\n\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        // Create a predicate for the current vector chunk.\n        // 'pg' will have true for elements from 'i' up to 'l.size() - 1',\n        // and false for elements beyond 'l.size()'.\n        pg = svwhilelt_b32(i, l.size());\n\n        // Load elements from the input vector 'l' into an SVE vector register.\n        // Only active lanes (where 'pg' is true) are loaded.\n        svint32_t vec = svld1_s32(pg, &l[i]);\n\n        // Increment each active element in the vector by 1.\n        // The '_x' suffix indicates that the operation is predicated:\n        // only active lanes are modified; inactive lanes retain their original value.\n        svint32_t res_vec = svadd_s32_x(pg, vec, 1);\n\n        // Store the result back into the output vector 'result'.\n        // Only active lanes are stored.\n        svst1_s32(pg, &result[i], res_vec);\n\n        // Advance the index 'i' by the number of 32-bit elements in an SVE vector.\n        // svcntw() returns the current vector length (VL) in terms of 32-bit elements.\n        i += svcntw();\n\n    // Continue the loop as long as there were any active lanes in the last iteration.\n    // svptest_any(svptrue_b32(), pg) returns true if any lane in 'pg' is true.\n    // When 'pg' becomes all false, it means all elements have been processed.\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n == 0) {\n        return {};\n    }\n\n    std::vector<int> result(n);\n\n    // Get the number of 32-bit elements in an SVE vector\n    size_t sv_vec_len = svcntw();\n\n    // Create a vector of ones to add\n    svint32_t ones = svdup_s32(1);\n\n    for (size_t i = 0; i < n; i += sv_vec_len) {\n        // Create a predicate for the current chunk.\n        // This handles the tail elements when n is not a multiple of sv_vec_len.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a vector of integers from the input list 'l'\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        // Add 1 to each element in the loaded vector\n        svint32_t vec_result = svadd_s32(vec_l, ones);\n\n        // Store the result back into the output list 'result'\n        svst1_s32(pg, &result[i], vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> output_l(l.size());\n    size_t vec_size = l.size();\n\n    for (size_t i = 0; i < vec_size; i += svcntd()) {\n        svbool_t pg = svwhilelt_b32(i, vec_size);\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svint32_t result_vec = svadd_n_s32(vec, 1);\n        svst1_s32(pg, &output_l[i], result_vec);\n    }\n\n    return output_l;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    // Get the total number of elements in the input vector.\n    size_t n = l.size();\n\n    // Create an output vector of the same size to store the results.\n    std::vector<int> result(n);\n\n    // Iterate through the input vector in chunks, processing 'svcntw()' elements at a time.\n    // 'svcntw()' returns the number of 32-bit integer elements that fit into an SVE vector.\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b32(i, n) creates a predicate that is true for elements\n        // starting from index 'i' up to (but not including) 'n'. This correctly\n        // handles the \"tail\" elements where the remaining number of elements\n        // is less than a full SVE vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a vector of 32-bit integers from the input list 'l'.\n        // The load operation starts at 'l.data() + i'. Only elements for which\n        // the predicate 'pg' is true will be actively loaded.\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n\n        // Increment each active element in the loaded vector by 1.\n        // The 'pg' predicate ensures that only the elements corresponding to\n        // true predicate lanes are modified.\n        svint32_t result_vec = svadd_n_s32(pg, vec, 1);\n\n        // Store the resulting vector back into the 'result' vector.\n        // The store operation starts at 'result.data() + i'.\n        // Again, 'pg' ensures that only active elements are written to memory.\n        svst1_s32(pg, result.data() + i, result_vec);\n    }\n\n    // Return the vector with all elements incremented.\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t n = l.size();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        if (svcntp_b32(pg) == 0) {\n            break; \n        }\n\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svint32_t result_vec = svadd_s32_x(pg, vec, 1);\n        svst1_s32(pg, &result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) {\n        return false;\n    }\n\n    // Get the number of 32-bit integer elements that fit into an SVE vector.\n    // This value is dynamic and depends on the specific SVE implementation.\n    const size_t sv_len = svcntw();\n\n    // Iterate through each element l[i] in the vector.\n    // This loop is scalar.\n    for (size_t i = 0; i < l.size(); ++i) {\n        int val_i = l[i];\n        // The target value we are looking for is the negative of l[i].\n        // If l[i] is 0, we are looking for another 0.\n        // If l[i] is non-zero, we are looking for -l[i].\n        int target = -val_i;\n\n        // Iterate through the remaining elements l[j] where j > i.\n        // This ensures that we are checking distinct elements (l[i] and l[j]).\n        // This inner loop uses SVE intrinsics for parallelism.\n        for (size_t j = i + 1; j < l.size(); j += sv_len) {\n            // Create a predicate for the current SVE vector chunk.\n            // svwhilelt_b32 generates a predicate that is true for elements\n            // whose original index (starting from 'j') is less than 'l.size()'.\n            // This handles partial vectors at the end of the array.\n            svbool_t pg = svwhilelt_b32(j, l.size());\n\n            // Load a vector of integers from 'l' starting at index 'j'.\n            // Only elements corresponding to true predicate lanes are loaded;\n            // others remain unchanged or are zeroed depending on the intrinsic.\n            svint32_t vec_j = svld1(pg, &l[j]);\n\n            // Create an SVE vector where all elements are 'target'.\n            svint32_t vec_target = svdup_n_s32(target);\n\n            // Compare each element in 'vec_j' with 'vec_target'.\n            // 'svcmpeq' returns a predicate where a lane is true if the\n            // corresponding elements are equal.\n            svbool_t matches = svcmpeq(pg, vec_j, vec_target);\n\n            // Check if any element in the current SVE vector chunk matched 'target'.\n            // 'svptest_any' returns true if any lane in 'matches' is true,\n            // considering only the active lanes defined by 'pg'.\n            if (svptest_any(pg, matches)) {\n                // If a match is found, it means we have found two distinct elements\n                // (l[i] and l[j]) that sum to zero.\n                return true;\n            }\n        }\n    }\n\n    // If no such pair is found after checking all combinations, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n\n    // A pair requires at least two elements.\n    if (n < 2) {\n        return false;\n    }\n\n    // Iterate through each element l[i]\n    for (int i = 0; i < n; ++i) {\n        // The target value we are looking for is the negative of the current element.\n        int target = -l[i];\n\n        // Broadcast the target value into an SVE vector.\n        svint32_t sv_target = svdup_n_s32(target);\n\n        // Start searching from the element after l[i] to ensure distinct elements (j > i).\n        // This also avoids checking the same pair twice (e.g., (a,b) and (b,a)).\n        int current_idx = i + 1;\n\n        // Loop through the remaining elements in chunks using SVE.\n        // svcnt_s32() returns the number of 32-bit integers that fit in an SVE vector.\n        while (current_idx < n) {\n            // Generate a predicate mask for the current chunk.\n            // This predicate ensures we only process valid elements within the vector bounds.\n            svbool_t pg = svwhilelt_b32(current_idx, n);\n\n            // If no lanes are active in the predicate, we've processed all elements.\n            // This check is important for the last partial chunk.\n            if (!svptest_any(sv_all_s32(), pg)) {\n                break;\n            }\n\n            // Load a vector of 32-bit integers from the input list starting at current_idx,\n            // using the generated predicate mask.\n            svint32_t sv_data = svld1_s32(pg, &l[current_idx]);\n\n            // Compare the loaded data vector with the target vector.\n            // This generates a new predicate mask where lanes are active if a match is found.\n            svbool_t sv_match = svcmpeq(pg, sv_data, sv_target);\n\n            // Check if any match occurred in the current chunk.\n            // svptest_any(pg, sv_match) returns true if any lane active in 'pg' is also active in 'sv_match'.\n            if (svptest_any(pg, sv_match)) {\n                return true; // Found two distinct elements that sum to zero.\n            }\n\n            // Move to the next chunk.\n            current_idx += svcnt_s32();\n        }\n    }\n\n    // No such pair found after checking all possibilities.\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) {\n        return false;\n    }\n\n    const size_t sv_vec_len = svcntw();\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        int val_a = l[i];\n        int target_b = -val_a;\n\n        size_t j = i + 1;\n        while (j < l.size()) {\n            svbool_t pg = svwhilelt_b32(j, l.size());\n\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            svint32_t vec_b = svld1(pg, &l[j]);\n            svint32_t vec_target = svdup_n_s32(target_b);\n\n            svbool_t cmp_result = svcmpeq(pg, vec_b, vec_target);\n\n            if (svptest_any(pg, cmp_result)) {\n                return true;\n            }\n\n            j += sv_vec_len;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    long N = l.size();\n\n    // If there are fewer than two elements, no pair can be formed.\n    if (N < 2) {\n        return false;\n    }\n\n    // Outer loop iterates through each element l[i]\n    for (long i = 0; i < N; ++i) {\n        int current_val = l[i];\n        int target_complement = -current_val;\n\n        // Inner loop searches for target_complement in the remaining part of the vector (l[j] where j > i).\n        // This ensures that we are checking distinct elements (i != j) and avoids redundant checks.\n        for (long j = i + 1; j < N; ) {\n            // Create a predicate for the current SVE vector chunk.\n            // svwhilelt_b32 generates a predicate that is true for elements\n            // from 'j' up to 'N-1', and false for elements beyond 'N-1'.\n            // This handles partial vectors at the end of the array.\n            svbool_t pg = svwhilelt_b32(j, N);\n\n            // If the predicate is all false, it means we have processed all elements\n            // or there are no more elements to process from 'j' onwards.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load a vector of 32-bit integers from the input vector 'l' starting at index 'j'.\n            // The predicate 'pg' ensures that only valid elements within the bounds are loaded.\n            svint32_t vec_l_j = svld1_s32(pg, &l[j]);\n\n            // Create an SVE vector where all elements are the 'target_complement'.\n            svint32_t vec_target = svdup_s32(target_complement);\n\n            // Compare the loaded vector (vec_l_j) with the target vector (vec_target).\n            // The result is a boolean vector where true indicates a match.\n            svbool_t cmp_result = svcmpeq_s32(pg, vec_l_j, vec_target);\n\n            // Check if any element in the comparison result is true under the active predicate 'pg'.\n            // If true, it means we found a pair (l[i] and some l[j] where j > i) that sums to zero.\n            if (svptest_any(pg, cmp_result)) {\n                return true; // A pair summing to zero was found, return true immediately.\n            }\n\n            // Advance 'j' by the number of 32-bit elements in an SVE vector (svcntw()).\n            // This moves to the next chunk of elements for the next iteration.\n            j += svcntw();\n        }\n    }\n\n    // If no such pair was found after checking all possibilities, return false.\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    long n = l.size();\n\n    if (n < 2) {\n        return false;\n    }\n\n    // Step 1: Check for two distinct zeros (0 + 0 = 0)\n    // This handles the case where 0 + 0 = 0, and the two zeros must be distinct.\n    long zero_count = 0;\n    // Get the vector length for 32-bit integers (number of elements in an SVE vector)\n    long sv_len = svcntw();\n\n    for (long k = 0; k < n; k += sv_len) {\n        // Create a predicate for the current vector chunk, handling the tail\n        svbool_t pg_k = svwhilelt_b32(k, n);\n        // Load a chunk of the vector 'l' into an SVE register\n        svint32_t sv_l_k = svld1_s32(pg_k, &l[k]);\n        // Compare loaded elements with 0\n        svbool_t zero_mask_k = svcmpeq_n_s32(pg_k, sv_l_k, 0);\n        // Count the number of true elements (zeros) in this chunk\n        zero_count += svcntp_b32(pg_k, zero_mask_k);\n    }\n\n    if (zero_count >= 2) {\n        return true; // Found at least two distinct zeros\n    }\n\n    // Step 2: Check for non-zero pairs (val_i + val_j = 0 where val_i != 0)\n    // If val_i is non-zero, then target = -val_i will also be non-zero and target != val_i.\n    // Thus, if l[j] == target, it implies l[j] != l[i], which means j != i.\n    // So, the distinctness requirement (i != j) is implicitly satisfied for non-zero pairs.\n    for (long i = 0; i < n; ++i) {\n        int val_i = l[i];\n\n        // If val_i is 0, it's already handled by the zero_count check.\n        // We only need to find pairs where val_i is non-zero.\n        if (val_i == 0) {\n            continue;\n        }\n\n        int target = -val_i;\n        // Duplicate the target value into an SVE vector register\n        svint32_t sv_target = svdup_n_s32(target);\n\n        for (long j = 0; j < n; j += sv_len) {\n            // Create a predicate for the current vector chunk\n            svbool_t current_pg = svwhilelt_b32(j, n);\n            // Load a chunk of the vector 'l'\n            svint32_t sv_l_j = svld1_s32(current_pg, &l[j]);\n\n            // Compare the loaded chunk with the target value\n            svbool_t match_mask = svcmpeq_s32(current_pg, sv_l_j, sv_target);\n\n            // Check if any element in the current chunk matches the target under the predicate\n            if (svptest_any(current_pg, match_mask)) {\n                return true; // A matching pair is found\n            }\n        }\n    }\n\n    return false; // No distinct pair sums to zero\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <string>\n#include <algorithm> // For std::reverse\n#include <vector>    // For std::vector<char>\n#include <arm_sve.h> // SVE intrinsics\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::vector<char> digits;\n\n    // Load the base into an SVE vector. Since 'base' is constant within the loop,\n    // we can duplicate it into all lanes of an SVE vector once.\n    // We use svdup_s64 for 64-bit integer elements.\n    svint64_t v_base = svdup_s64(base);\n\n    // Create a predicate that enables all lanes for 64-bit elements.\n    // This ensures that our scalar operations, when performed using SVE intrinsics,\n    // are active across all lanes, effectively duplicating the scalar operation.\n    svbool_t pg = svptrue_b64();\n\n    while (x > 0) {\n        // Load the current value of 'x' into an SVE vector.\n        // This effectively broadcasts the scalar 'x' to all lanes of the vector.\n        svint64_t v_x = svdup_s64(x);\n\n        // Perform integer division using SVE intrinsic: quotient = x / base.\n        // svdiv_s64 computes the division for active lanes.\n        svint64_t v_quotient = svdiv_s64(pg, v_x, v_base);\n\n        // Calculate the remainder using SVE intrinsics: remainder = x - (quotient * base).\n        // svmul_s64 performs multiplication.\n        // svsub_s64 performs subtraction.\n        svint64_t v_remainder = svsub_s64(pg, v_x, svmul_s64(pg, v_quotient, v_base));\n\n        // Extract the scalar quotient and remainder from the SVE vectors.\n        // svlasta_s64 extracts the value from the last active lane.\n        // Since 'pg' enables all lanes, any lane would contain the correct duplicated scalar value.\n        // We update 'x' for the next iteration of the loop.\n        x = svlasta_s64(pg, v_quotient);\n        int64_t remainder = svlasta_s64(pg, v_remainder);\n\n        // Convert the remainder digit to its character representation and store it.\n        digits.push_back(static_cast<char>('0' + remainder));\n    }\n\n    // The digits are collected in reverse order (least significant digit first).\n    // Reverse the vector to get the correct numerical representation.\n    std::reverse(digits.begin(), digits.end());\n\n    // Construct and return the final string from the character vector.\n    return std::string(digits.begin(), digits.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n\n    svbool_t pg = svptrue_b64();\n    svint64_t v_base = svdup_n_s64(base, pg);\n\n    while (x > 0) {\n        svint64_t vx = svdup_n_s64(x, pg);\n        \n        svint64_t v_digit = svrem_s64(pg, vx, v_base);\n        int64_t digit = svget_lane_s64(v_digit, 0);\n        result += (char)('0' + digit);\n\n        svint64_t v_new_x = svdiv_s64(pg, vx, v_base);\n        x = svget_lane_s64(v_new_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // For std::reverse\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Maximum digits for int64_t (approx 9e18) in base 2 is 64.\n    // In base 9, it's about 20. A buffer of 64 chars is safe.\n    constexpr int MAX_DIGITS = 64;\n    char buffer[MAX_DIGITS];\n    int i = 0;\n\n    // SVE setup:\n    // Create a predicate that enables all 64-bit lanes.\n    svbool_t pg = svptrue_b64();\n    \n    // Replicate the base value across all lanes of an SVE vector.\n    svint64_t v_base = svdup_n_s64(base);\n\n    // Replicate the input number x across all lanes of an SVE vector.\n    svint64_t v_x = svdup_n_s64(x);\n\n    // Loop to perform base conversion.\n    // The loop condition `x > 0` requires extracting `x` from the SVE vector\n    // in each iteration, as the scalar `x` is updated based on the vector result.\n    while (x > 0) {\n        // Perform the modulo operation (x % base) using SVE intrinsics.\n        // All lanes compute the same result, but it uses vector hardware.\n        svint64_t v_digit = svmod_s64_z(pg, v_x, v_base);\n\n        // Perform the division operation (x / base) using SVE intrinsics.\n        // All lanes compute the same result.\n        svint64_t v_next_x = svdiv_s64_z(pg, v_x, v_base);\n\n        // Extract the computed digit from the first lane of the SVE vector.\n        // (Any lane would yield the same result as all lanes contain identical data).\n        int64_t digit = svget_lane_s64(v_digit, 0);\n\n        // Convert the digit to its character representation and store it in the buffer.\n        buffer[i++] = (char)('0' + digit);\n\n        // Update the scalar x for the next iteration's loop condition.\n        x = svget_lane_s64(v_next_x, 0);\n\n        // Update the SVE vector v_x with the new value of x, replicated across all lanes.\n        v_x = svdup_n_s64(x);\n    }\n\n    // The digits are stored in reverse order in the buffer.\n    // Create a string from the collected digits and then reverse it.\n    std::string result(buffer, i);\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Required for std::reverse\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string temp_str = \"\"; // Temporary string to build digits in reverse order\n\n    // Get a predicate that enables all lanes of the SVE vector.\n    // svcntd() returns the number of 64-bit elements in an SVE vector.\n    // svwhilelt_b64(0, svcntd()) creates a predicate where all lanes are active.\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n\n    // Duplicate the 'base' value into an SVE vector.\n    // All lanes of 'sv_base' will contain the scalar 'base' value.\n    svint64_t sv_base = svdup_s64(base);\n\n    while (x > 0) {\n        // Duplicate the current 'x' value into an SVE vector.\n        // All lanes of 'sv_x' will contain the current scalar 'x' value.\n        svint64_t sv_x = svdup_s64(x);\n\n        // Perform vector division: quotient = x / base.\n        // This operation is performed in parallel across all active lanes.\n        svint64_t sv_quotient = svdiv_s64(pg, sv_x, sv_base);\n\n        // Calculate the remainder: x % base = x - (x / base) * base.\n        // First, calculate (x / base) * base using vector multiplication.\n        svint64_t sv_product = svmul_s64(pg, sv_quotient, sv_base);\n\n        // Then, subtract the product from 'x' to get the remainder using vector subtraction.\n        svint64_t sv_remainder = svsub_s64(pg, sv_x, sv_product);\n\n        // Extract the digit (remainder) from the first lane of the SVE vector.\n        // Since all lanes contained the same 'x' and 'base', all lanes will have the same remainder.\n        int digit = svget_s64(sv_remainder, 0);\n\n        // Update 'x' for the next iteration by extracting the quotient from the first lane.\n        x = svget_s64(sv_quotient, 0);\n\n        // Convert the digit to its character representation and append it to the temporary string.\n        // String manipulation is inherently sequential and not suitable for SVE vectorization.\n        temp_str += (char)('0' + digit);\n    }\n\n    // The digits were collected in reverse order, so reverse the string to get the correct representation.\n    std::reverse(temp_str.begin(), temp_str.end());\n\n    return temp_str;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Required for std::reverse\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Maximum digits for int64_t in base 2 is 63.\n    // For base 9, it's about 20 digits.\n    // A buffer of 64 characters is sufficient for digits.\n    char buffer[64]; \n    int i = 0; // Index for storing digits\n\n    // Duplicate the scalar input 'x' and 'base' into SVE vectors.\n    // Although we are processing a single number, this allows us to use SVE intrinsics.\n    svint64_t x_vec = svdup_s64(x);\n    svint64_t base_vec = svdup_s64(base);\n\n    // Create a predicate that enables all lanes.\n    // For this scalar operation, we effectively only use the first lane (lane 0).\n    svbool_t pg = svptrue_b64();\n\n    // Loop until the number becomes zero.\n    // We extract the value from the first lane of the SVE vector for the loop condition.\n    while (svget_s64(x_vec, 0) > 0) {\n        // Compute the remainder (digit) using SVE modulo intrinsic.\n        svint64_t rem_vec = svmod_s64(pg, x_vec, base_vec);\n        int64_t digit = svget_s64(rem_vec, 0); // Extract the digit from lane 0.\n\n        // Convert the digit to its character representation and store it.\n        buffer[i++] = '0' + digit;\n\n        // Compute the new quotient using SVE division intrinsic.\n        // The result updates x_vec for the next iteration.\n        x_vec = svdiv_s64(pg, x_vec, base_vec);\n    }\n\n    // The digits are collected in reverse order (least significant first).\n    // Create a string from the collected digits and then reverse it.\n    std::string result(buffer, i);\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Required for std::min\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n\n    // An empty string or a string with a single character is a palindrome.\n    if (n <= 1) {\n        return true;\n    }\n\n    // Get a pointer to the string data, cast to uint8_t* for SVE intrinsics.\n    const uint8_t* data_ptr = reinterpret_cast<const uint8_t*>(text.data());\n\n    size_t left_idx = 0;       // Index for the left side of the string\n    size_t right_idx = n - 1;  // Index for the right side of the string\n\n    // Get the current vector length in bytes. This value is determined at runtime.\n    size_t vl = svcntb();\n\n    // Loop as long as the left index is less than the right index.\n    // This ensures we are comparing characters from opposite ends moving inwards.\n    while (left_idx < right_idx) {\n        // Calculate the number of character pairs remaining to be checked.\n        // For an odd-length string, the middle character doesn't need comparison.\n        size_t remaining_pairs = (right_idx - left_idx + 1) / 2;\n\n        // If no pairs are left (e.g., only a middle character remains or all checked), break.\n        if (remaining_pairs == 0) {\n            break;\n        }\n\n        // Determine the actual number of bytes (characters) to process in this iteration.\n        // This is limited by the SVE vector length (vl) and the remaining pairs.\n        size_t current_vl_bytes = std::min(vl, remaining_pairs);\n\n        // Create a predicate for the current vector operation.\n        // svwhilelt_b8(0, current_vl_bytes) generates a predicate that is true for\n        // the first `current_vl_bytes` elements, and false for the rest of the vector.\n        svbool_t pg = svwhilelt_b8(0, current_vl_bytes);\n\n        // Load a vector from the left side of the string.\n        svuint8_t vec_left = svld1_u8(pg, data_ptr + left_idx);\n\n        // Load a vector from the right side of the string.\n        // The starting address for the right vector is calculated to load `current_vl_bytes`\n        // characters ending at `right_idx`.\n        svuint8_t vec_right = svld1_u8(pg, data_ptr + right_idx - current_vl_bytes + 1);\n\n        // Reverse the elements within the right vector.\n        // This aligns the characters from the right end to match the order of the left vector.\n        svuint8_t vec_right_reversed = svrev_u8(vec_right);\n\n        // Compare the left vector with the reversed right vector.\n        // svcmpeq_u8 returns a predicate where each lane is true if the corresponding\n        // elements are equal, and false otherwise.\n        svbool_t cmp_result = svcmpeq_u8(pg, vec_left, vec_right_reversed);\n\n        // Check if all active elements in the comparison resulted in a match.\n        // svptest_all returns true if all active lanes in `cmp_result` are true.\n        // If any mismatch is found (i.e., svptest_all returns false), the string is not a palindrome.\n        if (!svptest_all(pg, cmp_result)) {\n            return false; // Mismatch found\n        }\n\n        // Advance the left index and decrement the right index by the number of bytes processed.\n        left_idx += current_vl_bytes;\n        right_idx -= current_vl_bytes;\n    }\n\n    // If the loop completes without finding any mismatches, the string is a palindrome.\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Required for std::min\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n\n    // Handle empty or single-character strings (always palindromes)\n    if (len <= 1) {\n        return true;\n    }\n\n    // Pointer to the start of the string data (const uint8_t* for SVE intrinsics)\n    const uint8_t* data_ptr = reinterpret_cast<const uint8_t*>(text.data());\n\n    // We only need to check up to the middle of the string.\n    // 'left_idx' tracks the current starting index for the left-side chunk.\n    size_t left_idx = 0;\n    size_t num_pairs_to_check = len / 2;\n\n    // Loop while there are still pairs of characters to check\n    while (left_idx < num_pairs_to_check) {\n        // Get the current vector length in bytes (VL)\n        size_t VL = svcntb();\n\n        // Determine how many elements to process in this chunk.\n        // This handles the case where the remaining elements for comparison\n        // are fewer than the full vector length.\n        size_t num_elements_in_chunk = std::min(VL, num_pairs_to_check - left_idx);\n\n        // Create a predicate for the active elements in the current vector.\n        // This predicate will be true for 'num_elements_in_chunk' elements,\n        // starting from the first element of the vector.\n        svbool_t pg = svwhilelt_b8(0, num_elements_in_chunk);\n\n        // Load a vector from the left side of the string.\n        // The load starts at 'data_ptr + left_idx'.\n        svuint8_t left_vec = svld1_u8(pg, data_ptr + left_idx);\n\n        // Calculate the starting address for loading the corresponding right-side chunk.\n        // For each element 'text[i]' on the left, its corresponding element on the right is 'text[len - 1 - i]'.\n        // If the left chunk covers indices [L, L+1, ..., L+N-1],\n        // the corresponding right chunk covers indices [len-1-(L+N-1), ..., len-1-L].\n        // The starting index for loading the right chunk (which will be reversed) is:\n        // (len - 1 - (left_idx + num_elements_in_chunk - 1))\n        // This simplifies to: len - left_idx - num_elements_in_chunk\n        size_t right_load_start_idx = len - left_idx - num_elements_in_chunk;\n        svuint8_t right_vec_raw = svld1_u8(pg, data_ptr + right_load_start_idx);\n\n        // Reverse the right-side vector.\n        // This aligns its elements for direct comparison with 'left_vec'.\n        // E.g., if right_vec_raw contains [c_N, c_N-1, ..., c_1],\n        // svrev_b8 makes it [c_1, ..., c_N-1, c_N].\n        svuint8_t right_vec_reversed = svrev_b8(right_vec_raw);\n\n        // Compare the two vectors element-wise under the predicate.\n        // 'cmp_result' will have a true bit for each active element that is equal.\n        svbool_t cmp_result = svcmpeq(pg, left_vec, right_vec_reversed);\n\n        // Check if all active elements in the comparison were equal.\n        // If 'svptest_all' returns false, it means at least one active pair did not match,\n        // so the string is not a palindrome.\n        if (!svptest_all(pg, cmp_result)) {\n            return false;\n        }\n\n        // Advance the left index for the next iteration by the number of elements processed.\n        left_idx += num_elements_in_chunk;\n    }\n\n    // If the loop completes, all checked pairs matched, and the string is a palindrome.\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Required for std::min\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n\n    // An empty string or a single-character string is considered a palindrome.\n    if (n <= 1) {\n        return true;\n    }\n\n    // Get a pointer to the underlying character data.\n    // Cast to unsigned char* for SVE intrinsics that typically operate on unsigned types.\n    const unsigned char* data = reinterpret_cast<const unsigned char*>(text.data());\n\n    // Initialize left and right pointers for the string.\n    size_t left = 0;\n    size_t right = n - 1;\n\n    // Get the current vector length in bytes (VL) for SVE.\n    // This value is dynamic and depends on the SVE implementation.\n    size_t VL = svcntb();\n\n    // Loop while the left pointer is less than the right pointer.\n    // This ensures we process pairs of characters from both ends, moving inwards.\n    while (left < right) {\n        // Determine the number of character pairs we can process in this iteration.\n        // This is limited by the current SVE vector length (VL) and the remaining\n        // characters between 'left' and 'right'.\n        // We need to compare `k` characters from the left with `k` characters from the right.\n        // The total number of characters remaining to be compared is `right - left + 1`.\n        // The number of pairs is `(right - left + 1) / 2`.\n        // We take the minimum of VL and this number of pairs.\n        size_t k = std::min(VL, (right - left + 1) / 2);\n\n        // If k is 0, it means there are no more pairs to compare (either 0 or 1 character\n        // left in the middle), so we can break the loop.\n        if (k == 0) {\n            break;\n        }\n\n        // Create a predicate for the 'k' elements we are processing.\n        // This predicate will be true for the first 'k' elements and false for the rest.\n        svbool_t pg = svwhilelt_b_u64(0, k);\n\n        // Load 'k' characters from the left side of the string.\n        // The predicate 'pg' ensures that only valid elements up to 'k' are loaded.\n        svuint8_t v_left = svld1_u8(pg, data + left);\n\n        // Load 'k' characters from the right side of the string.\n        // The starting address for this load is `data + right - k + 1`.\n        // This ensures that `data[right]` is the last character loaded into `v_right_raw`,\n        // and `data[right - k + 1]` is the first.\n        svuint8_t v_right_raw = svld1_u8(pg, data + right - k + 1);\n\n        // Reverse the vector loaded from the right side.\n        // This is crucial because `v_right_raw` contains characters in ascending memory order\n        // (i.e., `data[right - k + 1], ..., data[right]`), but we need to compare them\n        // with `data[left], ..., data[left + k - 1]` in reversed order.\n        svuint8_t v_right_rev = svrev_u8(v_right_raw);\n\n        // Compare the two vectors element-wise.\n        // `cmp_result` will be a predicate where each element is true if the corresponding\n        // elements in `v_left` and `v_right_rev` are equal, and false otherwise.\n        svbool_t cmp_result = svcmpeq_u8(pg, v_left, v_right_rev);\n\n        // Check if all active elements (those for which 'pg' is true) in `cmp_result` are true.\n        // If `svptest_all` returns false, it means at least one pair of characters mismatched,\n        // so the string is not a palindrome.\n        if (!svptest_all(pg, cmp_result)) {\n            return false;\n        }\n\n        // Update the pointers to move inwards by 'k' characters from both ends.\n        left += k;\n        right -= k;\n    }\n\n    // If the loop completes, it means all compared character pairs matched,\n    // so the string is a palindrome.\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n\n    // Handle empty or single-character strings, which are considered palindromes.\n    if (n <= 1) {\n        return true;\n    }\n\n    // Get the SVE vector length in bytes. This value is determined at runtime.\n    size_t vl = svcntb();\n\n    // Pointers for the left and right ends of the string.\n    // Using const char* as text.data() returns const char*.\n    const char* left_ptr = text.data();\n    const char* right_ptr = text.data() + n - 1;\n\n    // Loop for full SVE vector comparisons.\n    // This loop continues as long as there is enough space for two full vectors\n    // (one from the left, one from the right) without them overlapping or crossing the middle.\n    // The condition `left_ptr + vl - 1 < right_ptr - (vl - 1)` ensures that\n    // the end of the left vector's memory access (`left_ptr + vl - 1`) is strictly before\n    // the start of the right vector's memory access (`right_ptr - (vl - 1)`).\n    // This guarantees that both `svld1_u8` operations are within valid bounds and\n    // do not access memory beyond the string's boundaries or overlap in a way that\n    // would corrupt the comparison logic for full vectors.\n    while (left_ptr + vl - 1 < right_ptr - (vl - 1)) {\n        // Create a full predicate for the vector operations.\n        // `svptrue_b8()` creates a predicate where all elements are active.\n        svbool_t pg = svptrue_b8();\n\n        // Load a vector from the left side of the string.\n        // Cast to `const uint8_t*` as SVE intrinsics typically operate on unsigned integer types for byte data.\n        svuint8_t vec_left = svld1_u8(pg, reinterpret_cast<const uint8_t*>(left_ptr));\n\n        // Load a vector from the right side of the string.\n        // The load starts `vl-1` bytes before `right_ptr` to capture the last `vl` bytes\n        // that correspond to the current `right_ptr` position.\n        svuint8_t vec_right_raw = svld1_u8(pg, reinterpret_cast<const uint8_t*>(right_ptr - (vl - 1)));\n        \n        // Reverse the `vec_right_raw` vector.\n        // This aligns its elements with `vec_left` for a direct comparison (e.g., first element of `vec_left`\n        // is compared with the first element of `vec_right` after reversal, which was originally the last element loaded).\n        svuint8_t vec_right = svrev_u8(vec_right_raw);\n\n        // Compare the two vectors element-wise.\n        // `svcmpeq_u8` returns a predicate where each bit is set if the corresponding bytes are equal.\n        svbool_t cmp_result = svcmpeq_u8(pg, vec_left, vec_right);\n\n        // Check if all active elements in the comparison result are true.\n        // If `svptest_all` returns false, it means at least one pair of characters did not match,\n        // so the string is not a palindrome.\n        if (!svptest_all(pg, cmp_result)) {\n            return false;\n        }\n\n        // Move pointers inwards by the vector length for the next iteration.\n        left_ptr += vl;\n        right_ptr -= vl;\n    }\n\n    // Handle any remaining characters using a scalar loop.\n    // This part covers:\n    // 1. Strings that are shorter than `2 * vl`.\n    // 2. The central portion of longer strings that couldn't be processed by full SVE vectors\n    //    (i.e., the remaining characters after the SVE loop finishes).\n    while (left_ptr < right_ptr) {\n        if (*left_ptr != *right_ptr) {\n            return false;\n        }\n        left_ptr++;\n        right_ptr--;\n    }\n\n    // If all comparisons passed, the string is a palindrome.\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n\n    // Handle base cases for empty or single-character strings\n    if (n <= 1) {\n        return true;\n    }\n\n    // 'i' is the current index from the left end of the string.\n    // We only need to iterate up to the middle of the string.\n    // 'limit' defines the exclusive upper bound for 'i'.\n    size_t i = 0;\n    size_t limit = n / 2;\n\n    // Loop while 'i' is less than the middle limit.\n    // In each iteration, we process a vector's worth of characters.\n    while (i < limit) {\n        // Generate a predicate for the current SVE vector operation.\n        // This predicate ensures that we only process characters that are within\n        // the bounds of the first half of the string (up to 'limit').\n        // 'svwhilelt_b8(i, limit)' creates a predicate where lanes are active\n        // as long as their conceptual index (starting from 'i') is less than 'limit'.\n        svbool_t pg = svwhilelt_b8(i, limit);\n\n        // Determine the actual number of active lanes in this predicate.\n        // This tells us how many characters will be processed in this iteration.\n        size_t num_active_lanes = svcntp_b8(pg);\n\n        // Load a vector of characters from the left side of the string.\n        // The load is masked by 'pg', so only active lanes will be written to.\n        svuint8_t vec_left = svld1_u8(pg, (const uint8_t*)&text[i]);\n\n        // Load a vector of characters from the right side of the string.\n        // The starting address for this load is calculated to get the corresponding\n        // characters for comparison.\n        // If vec_left loads text[i]...text[i + num_active_lanes - 1],\n        // then vec_right_raw needs to load text[n - num_active_lanes - i]...text[n - 1 - i].\n        // This ensures that after reversal, vec_right will contain\n        // text[n - 1 - i]...text[n - num_active_lanes - i], which correctly aligns\n        // with the reversed order of characters from the left side.\n        svuint8_t vec_right_raw = svld1_u8(pg, (const uint8_t*)&text[n - num_active_lanes - i]);\n\n        // Reverse the elements within the 'vec_right_raw' vector.\n        // This aligns the characters from the right side to match the order of the left side.\n        svuint8_t vec_right = svrev_u8(vec_right_raw);\n\n        // Compare the left and reversed right vectors.\n        // 'svcmpeq_u8' performs an element-wise equality comparison.\n        // The comparison is also masked by 'pg', so only active lanes contribute.\n        svbool_t cmp_result = svcmpeq_u8(pg, vec_left, vec_right);\n\n        // Check if any of the active lanes resulted in a mismatch.\n        // 'svnot_b(pg, cmp_result)' inverts the comparison result for active lanes.\n        // 'svptest_any(pg, ...)' checks if any active lane in the predicate is true.\n        // If any character pair does not match, it's not a palindrome.\n        if (svptest_any(pg, svnot_b(pg, cmp_result))) {\n            return false;\n        }\n\n        // Advance the left index 'i' by the number of characters actually processed\n        // in this iteration. This ensures we move past the characters already checked.\n        i += num_active_lanes;\n    }\n\n    // If the loop completes without finding any mismatches, the string is a palindrome.\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\n// decode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\n// The requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n//\n// Assumption: The input string 's' contains only lowercase English alphabet characters ('a'-'z').\n// This assumption is based on the typical interpretation of \"shifting every character by 5 in the alphabet\"\n// and the behavior of the provided 'encode_shift' function. If 'encode_shift' processes characters\n// outside 'a'-'z', its modulo arithmetic can lead to collisions (e.g., 'A' and '`' both encode to '`'),\n// making a perfect inverse impossible for such cases. By assuming 'a'-'z' input, the decoding is a perfect inverse.\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    if (len == 0) {\n        return \"\";\n    }\n\n    std::string out;\n    out.resize(len); // Pre-allocate memory for the output string\n\n    // Get the SVE vector length in bytes (number of 8-bit elements).\n    // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector.\n    size_t sv_len_bytes = svcntb();\n\n    // Pointers to the input and output character arrays.\n    // Using unsigned char* for SVE byte operations to avoid signedness issues\n    // and ensure consistent behavior with modular arithmetic for positive values.\n    const unsigned char* in_ptr = reinterpret_cast<const unsigned char*>(s.data());\n    unsigned char* out_ptr = reinterpret_cast<unsigned char*>(out.data());\n\n    // Loop through the string in chunks of sv_len_bytes.\n    for (size_t i = 0; i < len; i += sv_len_bytes) {\n        // Create a predicate (mask) for the current vector chunk.\n        // This handles the tail end of the string where the last vector might not be full.\n        // svwhilelt_b8(start_index, end_limit) generates a mask where elements\n        // from start_index up to (but not including) end_limit are active.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input string using the predicate.\n        svuint8_t vec_chars = svld1(pg, in_ptr + i);\n\n        // Step 1: Convert characters to 0-25 alphabet indices.\n        // For example, 'a' becomes 0, 'b' becomes 1, ..., 'z' becomes 25.\n        // This is done by subtracting the ASCII value of 'a'.\n        svuint8_t vec_indices = svsub_n_u8(vec_chars, 'a');\n\n        // Step 2: Apply the decoding shift.\n        // The encoding was: `encoded_idx = (original_idx + 5) % 26`.\n        // So, to decode, `original_idx = (encoded_idx - 5) % 26`.\n        // To handle potential negative results from `encoded_idx - 5` with unsigned integers,\n        // we add 26 before the modulo: `(encoded_idx - 5 + 26) % 26`.\n        // This is equivalent to `(encoded_idx + 21) % 26`.\n        // The values in `vec_indices` are in the range [0, 25].\n        // After adding 21, `vec_shifted_val` will be in the range [21, 46].\n        svuint8_t vec_shifted_val = svadd_n_u8(vec_indices, 21);\n\n        // Step 3: Apply modulo 26.\n        // For values in the range [21, 46], if a value is >= 26, we subtract 26 to get the modulo result.\n        // Otherwise, the value itself is the modulo result.\n        // Create a mask for elements where `vec_shifted_val` is greater than or equal to 26.\n        svbool_t pg_ge_26 = svcmpge(pg, vec_shifted_val, svdup_n_u8(26));\n        \n        // Conditionally subtract 26 from elements where `pg_ge_26` is true.\n        // The `svsub_m` intrinsic performs subtraction only for active lanes (where the mask is true).\n        // For inactive lanes (where the mask is false), the original value is preserved.\n        svuint8_t vec_decoded_indices = svsub_m(pg_ge_26, vec_shifted_val, vec_shifted_val, svdup_n_u8(26));\n\n        // Step 4: Convert back to ASCII characters by adding 'a'.\n        // The values in `vec_decoded_indices` are now in the range [0, 25].\n        svuint8_t vec_decoded_chars = svadd_n_u8(vec_decoded_indices, 'a');\n\n        // Store the decoded characters back to the output string using the predicate.\n        svst1(pg, out_ptr + i, vec_decoded_chars);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\n// Constants for the shift operation\nconst uint8_t CHAR_A = 'a';\nconst uint8_t SHIFT_AMOUNT = 5;\nconst uint8_t ALPHABET_SIZE = 26;\n\nstd::string decode_shift_simd(std::string s) {\n    // Create a mutable copy of the input string to store the decoded result.\n    // This avoids reallocations and allows in-place modification of character data.\n    std::string out = s;\n    size_t len = s.length();\n\n    // Handle empty string case\n    if (len == 0) {\n        return \"\";\n    }\n\n    // Get the vector length in bytes (number of 8-bit elements) for the current SVE implementation.\n    // This value is determined at runtime by the SVE hardware.\n    size_t sv_len = svcnt_u8();\n\n    // Pointers to the character data for input and output.\n    // Using uint8_t* for byte-wise operations, which is suitable for characters.\n    const uint8_t* in_ptr = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out.data());\n\n    // Duplicate constants into SVE vectors once outside the loop.\n    // These vectors will have all their elements set to the constant value,\n    // which can be efficiently used in vector operations.\n    svuint8_t vec_char_a = svdup_u8(CHAR_A);\n    svuint8_t vec_shift_amount = svdup_u8(SHIFT_AMOUNT);\n    svuint8_t vec_alphabet_size = svdup_u8(ALPHABET_SIZE);\n\n    // Loop through the string in chunks of `sv_len` (the SVE vector length).\n    for (size_t i = 0; i < len; i += sv_len) {\n        // Generate a predicate for the current chunk.\n        // `svwhilelt_b8(i, len)` creates a predicate where elements are active\n        // as long as their index (starting from `i`) is less than `len`.\n        // This correctly handles the tail end of the string where the remaining\n        // characters might be fewer than `sv_len`.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input string using the predicate.\n        // Only elements corresponding to active predicate lanes are loaded;\n        // inactive elements (beyond string length) will remain untouched.\n        svuint8_t chars_vec = svld1_u8(pg, in_ptr + i);\n\n        // Step 1: Convert character to 0-25 range relative to 'a'.\n        // Operation: `(s[i] - 'a')`\n        svuint8_t val_0_25 = svsub_u8(pg, chars_vec, vec_char_a);\n\n        // Step 2: Subtract the shift amount (5).\n        // Operation: `(s[i] - 'a' - 5)`\n        svuint8_t shifted_val = svsub_u8(pg, val_0_25, vec_shift_amount);\n\n        // Step 3: Add ALPHABET_SIZE (26) to ensure the value is positive before the modulo operation.\n        // This handles cases where `s[i] - 'a' - 5` would be negative (e.g., 'a' - 'a' - 5 = -5).\n        // Operation: `(s[i] - 'a' - 5 + 26)`\n        svuint8_t temp_result = svadd_u8(pg, shifted_val, vec_alphabet_size);\n\n        // Step 4: Implement modulo ALPHABET_SIZE (26).\n        // Since `temp_result` is in the range [21, 46] (for input characters 'a'-'z'),\n        // `X % 26` can be implemented as: if `X >= 26`, then `X - 26`, else `X`.\n        // Create a predicate for elements where `temp_result` is greater than or equal to 26.\n        svbool_t pg_ge_alphabet_size = svcmpge_u8(pg, temp_result, vec_alphabet_size);\n        \n        // Conditionally subtract ALPHABET_SIZE from elements where `pg_ge_alphabet_size` is true.\n        // The main `pg` predicate is still active, ensuring only elements within the string bounds are modified.\n        svuint8_t final_val_0_25 = svsub_u8(pg_ge_alphabet_size, temp_result, vec_alphabet_size);\n\n        // Step 5: Add 'a' back to convert the 0-25 range value back to its corresponding character.\n        // Operation: `(result_0_25 + 'a')`\n        svuint8_t decoded_chars_vec = svadd_u8(pg, final_val_0_25, vec_char_a);\n\n        // Store the decoded characters back to the output string using the predicate.\n        // Only active elements are written, preserving existing data for inactive lanes.\n        svst1_u8(pg, out_ptr + i, decoded_chars_vec);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    // Create an output string of the same length as the input string\n    std::string out(s.length(), ' ');\n\n    // Get the length of the string\n    size_t len = s.length();\n\n    // Pointers to the input and output character arrays\n    // Using uint8_t for character data to align with SVE byte operations\n    const uint8_t* in_ptr = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* out_ptr = reinterpret_cast<uint8_t*>(out.data());\n\n    // Constants for the SVE operations, duplicated across all lanes\n    svuint8_t a_char_vec = svdup_u8('a');\n    svuint8_t five_vec = svdup_u8(5);\n    svuint8_t twenty_six_vec = svdup_u8(26);\n\n    // Loop through the string in chunks of SVE vector size (svcntb() bytes)\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Get a predicate for the active lanes. This handles the tail of the string\n        // where the remaining characters are less than the full vector length.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load the characters from the input string into an SVE vector\n        svuint8_t s_vec = svld1_u8(pg, in_ptr + i);\n\n        // Step 1: Subtract 'a' to get a 0-25 value (char_val = s_char - 'a')\n        // _x suffix means the operation is predicated: only active lanes are modified.\n        svuint8_t char_val_vec = svsub_u8_x(pg, s_vec, a_char_vec);\n\n        // Step 2: Subtract 5 (temp = char_val - 5)\n        // For example, 'a' (0) - 5 results in -5. For uint8_t, this wraps around to 251.\n        svuint8_t temp_vec = svsub_u8_x(pg, char_val_vec, five_vec);\n\n        // Step 3: Add 26 to ensure the value is positive before modulo 26.\n        // This corrects the wrap-around from the previous step and ensures the\n        // value is in the range [21, 46] before modulo.\n        svuint8_t temp_pos_vec = svadd_u8_x(pg, temp_vec, twenty_six_vec);\n\n        // Step 4: Perform modulo 26 (decoded_char_val = temp_pos % 26)\n        // This is implemented as: temp_pos - (temp_pos / 26) * 26\n        svuint8_t quotient = svdiv_u8_x(pg, temp_pos_vec, twenty_six_vec);\n        svuint8_t product = svmul_u8_x(pg, quotient, twenty_six_vec);\n        svuint8_t decoded_char_val_vec = svsub_u8_x(pg, temp_pos_vec, product);\n\n        // Step 5: Add 'a' back to convert the 0-25 value to an ASCII character\n        svuint8_t decoded_char_vec = svadd_u8_x(pg, decoded_char_val_vec, a_char_vec);\n\n        // Store the decoded characters into the output string\n        svst1_u8(pg, out_ptr + i, decoded_char_vec);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h> // Required for SVE intrinsics\n\n// decode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\n// The requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\nstd::string decode_shift_simd(std::string s){\n    const size_t N = s.length();\n    std::string out(N, '\\0'); // Pre-allocate string with null characters\n\n    size_t i = 0;\n\n    // Duplicate constants into SVE vectors once.\n    // `svdup_n_u8` creates a vector where all elements are the specified value.\n    // This is suitable for constants that are used across all active lanes.\n    svuint8_t vec_a_val = svdup_n_u8('a');\n    svuint8_t vec_5_val = svdup_n_u8(5);\n    svuint8_t vec_26_val = svdup_n_u8(26);\n\n    while (i < N) {\n        // Generate a predicate for the current chunk of data.\n        // `svwhilelt_b8(i, N)` generates a predicate that is true for elements\n        // where the current index `i + lane_idx` is less than `N`.\n        svbool_t pg = svwhilelt_b8(i, N);\n\n        // Load characters from the input string 's' into an SVE vector.\n        // `svld1_u8` loads unsigned 8-bit integers (bytes).\n        // The predicate `pg` ensures that only valid elements within bounds are loaded.\n        svuint8_t vec_s = svld1_u8(pg, (const uint8_t*)s.data() + i);\n\n        // Step 1: Normalize character to 0-25 range (e.g., 'a' -> 0, 'b' -> 1, ..., 'z' -> 25).\n        // `svsub_u8_x` performs subtraction on active elements; inactive elements are unchanged.\n        svuint8_t vec_norm = svsub_u8_x(pg, vec_s, vec_a_val);\n\n        // Step 2: Shift back by 5.\n        svuint8_t vec_shifted = svsub_u8_x(pg, vec_norm, vec_5_val);\n\n        // Step 3: Add 26 to handle potential negative results from the shift.\n        // This ensures the value is positive before the modulo operation.\n        // For example, if 'a' (0 normalized) is shifted by -5, it becomes -5.\n        // Adding 26 makes it 21.\n        svuint8_t vec_shifted_pos = svadd_u8_x(pg, vec_shifted, vec_26_val);\n\n        // Step 4: Perform modulo 26.\n        // Since `vec_shifted_pos` is in the range [21, 46] (for 'a'-'z' input),\n        // we only need to subtract 26 if the value is >= 26.\n        // Create a predicate for elements where `vec_shifted_pos` is >= 26.\n        svbool_t cmp_ge_26 = svcge_u8(pg, vec_shifted_pos, vec_26_val);\n\n        // Subtract 26 from elements where `cmp_ge_26` is true.\n        // `svsub_u8_x` ensures only active elements (where `cmp_ge_26` is true) are modified.\n        svuint8_t vec_mod_sub = svsub_u8_x(cmp_ge_26, vec_shifted_pos, vec_26_val);\n\n        // Select the final modulo result:\n        // If `cmp_ge_26` is true, use `vec_mod_sub` (value - 26).\n        // Otherwise, use `vec_shifted_pos` (original value, as it's already < 26).\n        svuint8_t vec_mod = svsel_u8(cmp_ge_26, vec_mod_sub, vec_shifted_pos);\n\n        // Step 5: Convert back to character by adding 'a'.\n        svuint8_t vec_out = svadd_u8_x(pg, vec_mod, vec_a_val);\n\n        // Store the processed characters back to the output string 'out'.\n        // The predicate `pg` ensures that only valid elements within bounds are stored.\n        svst1_u8(pg, (uint8_t*)out.data() + i, vec_out);\n\n        // Increment the loop index by the actual number of processed elements (current vector length).\n        i += svcntb();\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    // Create the output string with the same content as the input.\n    // This allows in-place modification of the characters.\n    std::string out = s;\n\n    // Get the length of the input string.\n    size_t len = s.length();\n\n    // Get the current vector length (VL) in bytes for SVE.\n    // svcntb() returns the number of 8-bit elements (bytes) that fit in an SVE vector.\n    size_t vl = svcntb();\n\n    // Loop through the string in chunks of VL.\n    // 'i' is the starting index for each vector operation.\n    for (size_t i = 0; i < len; i += vl) {\n        // Generate a predicate for the current vector.\n        // svwhilelt_b8(i, len) creates a predicate that is true for elements\n        // whose logical index (starting from 'i') is less than 'len'.\n        // This handles the tail of the string where the number of remaining characters\n        // might be less than the full vector length.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters (as unsigned 8-bit integers) from the input string.\n        // The predicate 'pg' ensures that only valid characters within the string bounds are loaded.\n        svuint8_t s_vec = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Step 1: Convert characters from 'a'-'z' to a 0-25 range.\n        // Subtract the ASCII value of 'a' from each character.\n        // svdup_u8('a') creates a vector where all elements are 'a'.\n        svuint8_t val_0_25_vec = svsub_u8(s_vec, svdup_u8('a'));\n\n        // Step 2: Determine which elements need special handling for wrap-around.\n        // The original encoding shifted by +5. Decoding shifts by -5.\n        // If a character's 0-25 value is less than 5 (i.e., 'a', 'b', 'c', 'd', 'e'),\n        // subtracting 5 will result in a negative value.\n        // For uint8_t, this negative value wraps around to a large positive number (e.g., 0-5 becomes 251).\n        // We need to identify these cases to add 26 later.\n        svbool_t pred_wrap = svcmplt_u8(val_0_25_vec, svdup_u8(5));\n\n        // Step 3: Subtract 5 from the 0-25 range values.\n        // This operation will cause wrap-around for the characters identified by 'pred_wrap'.\n        svuint8_t shifted_val_vec = svsub_u8(val_0_25_vec, svdup_u8(5));\n\n        // Step 4: Correct the wrapped-around values by conditionally adding 26.\n        // svadd_u8_m adds 26 only to the elements where 'pred_wrap' is true.\n        // For example, if 'shifted_val_vec' was 251 (from 'a'), adding 26 results in 277.\n        // As a uint8_t, 277 wraps around to 21, which is the correct decoded value for 'a' (0-25 range).\n        // For values that did not wrap (e.g., 'f' (5) -> 0), 'pred_wrap' is false, and 26 is not added.\n        svuint8_t decoded_val_0_25_vec = svadd_u8_m(shifted_val_vec, pred_wrap, svdup_u8(26));\n\n        // Step 5: Convert the 0-25 range values back to ASCII characters.\n        // Add the ASCII value of 'a' to each decoded value.\n        svuint8_t decoded_char_vec = svadd_u8(decoded_val_0_25_vec, svdup_u8('a'));\n\n        // Store the decoded characters back into the output string.\n        // The predicate 'pg' ensures that only valid positions within 'out' are written to.\n        svst1_u8(pg, (uint8_t*)&out[i], decoded_char_vec);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t i = 0;\n    size_t vec_size = l.size();\n\n    // Get the vector length for 32-bit integers (svcntw())\n    size_t sv_len = svcntw();\n\n    // Duplicate the threshold value into an SVE vector once\n    svint32_t vec_t = svdup_s32(t);\n\n    // Loop through the vector using SVE intrinsics\n    // The predicate 'pg' will handle full vectors and partial vectors at the end.\n    for (i = 0; i < vec_size; i += sv_len) {\n        // Generate a predicate for the current chunk.\n        // This predicate will be active for elements within the vector bounds.\n        // For the last (potentially partial) chunk, it will only activate\n        // elements that are actually part of the vector 'l'.\n        svbool_t pg = svwhilelt_b32(i, vec_size);\n\n        // If no elements are active in this predicate, we've processed all elements.\n        // This handles cases where vec_size is a multiple of sv_len,\n        // and the loop tries to go one step too far.\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break;\n        }\n\n        // Load a vector of integers from l using the predicate\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        // Compare: check if each active element in vec_l is less than vec_t\n        // The result is a predicate vector where true means l[x] < t\n        svbool_t cmp_result = svcmplt_s32(pg, vec_l, vec_t);\n\n        // Check if any active element in the current chunk is NOT below the threshold.\n        // svnot_b(cmp_result) gives a predicate where true means l[x] >= t.\n        // svptest_any(pg, P) returns true if any active element in P is true.\n        // If svptest_any(pg, svnot_b(cmp_result)) is true, it means at least one active element\n        // in the current chunk is >= t, so the overall condition is false.\n        if (svptest_any(pg, svnot_b(cmp_result))) {\n            return false; // Found an element not below threshold\n        }\n    }\n\n    // If the loop completes without returning false, all elements are below the threshold.\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    long N = l.size();\n    long i = 0;\n    bool all_below = true;\n\n    // Get the number of 32-bit integers per vector.\n    // This value is determined by the SVE vector length at runtime.\n    svcount_t sv_len = svcntw();\n\n    // Duplicate the threshold 't' into an SVE vector.\n    // This allows for simultaneous comparison against all elements in a loaded vector.\n    svint32_t sv_t = svdup_s32(t);\n\n    // Loop through the input vector 'l' in chunks of 'sv_len' elements.\n    while (i < N) {\n        // Create a predicate 'pg' that is true for elements within the current\n        // chunk that are still within the bounds of the input vector 'l'.\n        // This correctly handles the tail end of the vector where 'N - i' might be less than 'sv_len'.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // If the predicate 'pg' is empty (no active lanes), it means we have\n        // processed all elements or 'i' has gone past 'N'.\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break; // No more elements to process.\n        }\n\n        // Load a vector of 32-bit integers from 'l' starting at index 'i'.\n        // Only elements corresponding to active lanes in 'pg' are loaded.\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        // Compare each active element in 'vec_l' with 'sv_t'.\n        // 'cmp_result' will be a predicate where a true lane indicates that the\n        // corresponding element in 'vec_l' is strictly less than 't'.\n        svbool_t cmp_result = svcmplt_s32(pg, vec_l, sv_t);\n\n        // Check if ALL active elements in the current chunk satisfy the condition (i.e., are < t).\n        // 'svall_b32(pg, cmp_result)' returns true if all active lanes in 'cmp_result' are true.\n        // If it returns false, it means at least one active element in 'vec_l' was NOT less than 't'.\n        if (!svall_b32(pg, cmp_result)) {\n            all_below = false; // Found an element that is not below the threshold.\n            break;             // No need to check further, the condition is already false.\n        }\n\n        // Advance the index 'i' by the number of elements processed in this chunk.\n        i += sv_len;\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> // Required for std::vector\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    size_t i = 0;\n    // Loop through the vector in chunks of SVE vector length.\n    // svwhilelt_b32 generates a predicate for 32-bit elements\n    // that are within the bounds [i, l.size()). This handles both full vectors\n    // and the remaining tail elements.\n    for (; i < l.size(); ) {\n        // Generate a predicate 'pg' for the current chunk of elements.\n        // 'pg' will be true for elements from 'i' up to 'l.size() - 1'\n        // that fit into an SVE vector.\n        svbool_t pg = svwhilelt_b32(i, l.size());\n\n        // If the predicate 'pg' is empty (no active lanes), it means we have\n        // processed all elements or there are no more elements to process.\n        // This check ensures we don't attempt to load/process an empty chunk.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of 32-bit integers from the input list 'l' starting at index 'i'.\n        // The predicate 'pg' ensures that only valid elements within the bounds are loaded.\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n\n        // Compare each active element in 'vec_l' with the threshold 't'.\n        // svcmplt_s32 returns a predicate 'p_lt' where each lane is true if\n        // the corresponding element in 'vec_l' is less than 't'.\n        // The comparison is only performed for lanes active according to 'pg'.\n        svbool_t p_lt = svcmplt_s32(pg, vec_l, t);\n\n        // Check if ALL active elements in the current vector satisfy the condition\n        // (i.e., are less than 't').\n        // svptest_all(pg, p_lt) returns true if all active lanes in 'p_lt' are true.\n        // If even one active element is NOT less than 't' (meaning its corresponding\n        // lane in 'p_lt' is false), then svptest_all will return false.\n        if (!svptest_all(pg, p_lt)) {\n            return false; // Found an element that is not below the threshold.\n        }\n\n        // Advance the index 'i' by the number of 32-bit elements that fit into an SVE vector.\n        // svcntw() returns the current vector length in terms of 32-bit elements.\n        i += svcntw();\n    }\n\n    // If the loop completes without returning false, it means all elements\n    // in the vector 'l' were below the threshold 't'.\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    // Get the number of 32-bit integers (words) that fit into an SVE vector.\n    // This determines the vector length (VL).\n    size_t sv_len = svcntw();\n\n    // Loop through the vector in chunks of sv_len elements.\n    for (size_t i = 0; i < l.size(); i += sv_len) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // from 'i' up to 'l.size() - 1', effectively handling the tail.\n        svbool_t pg = svwhilelt_b32(i, l.size());\n\n        // Load a vector of integers from the input list 'l' using the predicate.\n        svint32_t vec_l = svld1(pg, &l[i]);\n\n        // Compare each loaded element with the threshold 't'.\n        // svcmplt returns a predicate where each lane is true if the corresponding\n        // element in vec_l is less than t.\n        svbool_t cmp_result = svcmplt(pg, vec_l, t);\n\n        // Check if all active elements in the current chunk satisfy the condition\n        // (i.e., are less than t).\n        // svptest_all returns true if all active elements (defined by 'pg')\n        // also have their corresponding lane true in 'cmp_result'.\n        // If it returns false, it means at least one active element is NOT less than t.\n        if (!svptest_all(pg, cmp_result)) {\n            return false; // Found an element not below the threshold.\n        }\n    }\n\n    // If the loop completes, all elements were below the threshold.\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int>l, int t){\n    int n = l.size();\n    int i = 0;\n    svbool_t pg;\n\n    int sv_len = svcntw();\n\n    while (i < n) {\n        pg = svwhilelt_b32(i, n);\n\n        svint32_t vec_l = svld1_s32(pg, &l[i]);\n        svint32_t vec_t = svdup_s32(t);\n\n        svbool_t pg_ge = svcmpge_s32(pg, vec_l, vec_t);\n\n        if (svptest_any(pg, pg_ge)) {\n            return false;\n        }\n\n        i += sv_len;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Required for std::min\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t current_balance = 0;\n    int32_t min_overall_balance = 0;\n\n    size_t len = brackets.length();\n    size_t i = 0;\n\n    do {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        if (svptest_n(svptrue_b8(), pg) == 0) {\n            break;\n        }\n\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n\n        svbool_t is_open = svcmpeq(pg, chars, '<');\n        svbool_t is_close = svcmpeq(pg, chars, '>');\n\n        svint32_t balance_changes = svdup_n_s32(0);\n        balance_changes = svsel(is_open, svdup_n_s32(1), balance_changes);\n        balance_changes = svsel(is_close, svdup_n_s32(-1), balance_changes);\n\n        svint32_t prefix_sums_in_chunk = svscan_s32(pg, balance_changes, SV_ADD);\n\n        svint32_t absolute_balances_in_chunk = svadd_s32_x(pg, prefix_sums_in_chunk, svdup_n_s32(current_balance));\n\n        int32_t min_in_current_chunk = svminv_s32(pg, absolute_balances_in_chunk);\n\n        min_overall_balance = std::min(min_overall_balance, min_in_current_chunk);\n\n        int32_t chunk_total_change = svaddv_s32(pg, balance_changes);\n\n        current_balance += chunk_total_change;\n\n        i += svcntb();\n\n    } while (i < len);\n\n    return (min_overall_balance >= 0) && (current_balance == 0);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Not strictly needed for this implementation, but often useful.\n\n/*\nbrackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool correct_bracketing_simd(std::string brackets) {\n    long long balance = 0; // Tracks the current balance, initialized to 0.\n                           // Use long long to prevent overflow for very long strings.\n\n    // Get the number of bytes in an SVE vector. This determines the chunk size for processing.\n    const size_t vl = svcntb(); \n\n    size_t i = 0;\n    while (i < brackets.length()) {\n        // Create a predicate for the current vector chunk.\n        // `svwhilelt_b8` generates a predicate where elements are true as long as \n        // `i + element_index < brackets.length()`. This handles partial vectors at the end.\n        svbool_t pg = svwhilelt_b8(i, brackets.length());\n\n        // If no elements are active in the predicate, we've processed the entire string.\n        // `svptest_any(svptrue_b8(), pg)` checks if any element in `pg` is true.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters from the string into an SVE vector (uint8_t).\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n\n        // Define SVE vectors for ASCII values of '<' and '>'.\n        svuint8_t open_bracket_val = svdup_u8(0x3C);  // ASCII for '<'\n        svuint8_t close_bracket_val = svdup_u8(0x3E); // ASCII for '>'\n\n        // Create boolean predicates for characters that are '<' or '>'.\n        svbool_t is_open = svcmpeq(pg, chars, open_bracket_val);\n        svbool_t is_close = svcmpeq(pg, chars, close_bracket_val);\n\n        // Initialize a vector to hold +1, -1, or 0 for each character.\n        // Elements corresponding to inactive predicate lanes (pg is false) will remain 0.\n        svint8_t values = svdup_s8(0); \n        // Set +1 for opening brackets.\n        values = svsel(is_open, svdup_s8(1), values);\n        // Set -1 for closing brackets.\n        values = svsel(is_close, svdup_s8(-1), values);\n        // For characters that are neither '<' nor '>', `values` remains 0.\n\n        // Compute prefix sums of `values` within the current vector.\n        // `prefix_sums[j]` will contain the sum of `values[0]` through `values[j]` \n        // for active elements. Inactive elements are undefined.\n        svint8_t prefix_sums = svscan_s8(pg, SV_ACCUMULATE, values);\n\n        // Find the minimum value among the computed prefix sums.\n        // `svminv_s8` only considers active elements defined by `pg`.\n        // This represents the lowest balance reached *relative to the start of this vector*.\n        int8_t min_local_prefix_sum = svminv_s8(pg, prefix_sums);\n\n        // Check if the global balance would drop below zero at any point within this vector.\n        // The actual balance at any point `j` in the vector is `balance + prefix_sums[j]`.\n        // So, we check if `balance + min_local_prefix_sum` is less than 0.\n        if (balance + min_local_prefix_sum < 0) {\n            return false; // Balance dropped below zero, indicating invalid bracketing.\n        }\n\n        // Calculate the total change in balance for this vector chunk.\n        // `svaddv_s8` sums all active elements in `values`.\n        int8_t vector_total_delta = svaddv_s8(pg, values);\n\n        // Update the global balance for the next iteration.\n        balance += vector_total_delta;\n\n        // Move to the next chunk in the string.\n        i += vl;\n    }\n\n    // After processing all characters, the final balance must be zero for correct bracketing.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // For std::min\n\n/*\n * Helper function to compute prefix sums for a vector using SVE.\n * This implements a parallel scan (Blelloch's algorithm).\n *\n * @param pg The governing predicate for the current vector operation.\n *           Only active lanes (determined by pg) will be processed.\n * @param vec The input vector for which to compute prefix sums.\n * @return A vector containing the prefix sums of the input vector.\n */\nstatic svint8_t sve_prefix_sum(svbool_t pg, svint8_t vec) {\n    svint8_t psum_vec = vec;\n    int vl = svcntb(); // Get the current vector length in bytes (elements)\n\n    // Iterate log2(VL) times to compute prefix sums\n    for (int i = 1; i < vl; i <<= 1) {\n        // Create indices for elements to add: [0, 1, ..., VL-1] - i\n        // This means we want to add psum_vec[j-i] to psum_vec[j]\n        svuint8_t indices = svindex_u8(0, 1); // Generates [0, 1, 2, ..., VL-1]\n        svuint8_t shifted_indices = svsub_u8(indices, svdup_u8(i));\n\n        // Create a predicate for elements where j-i >= 0.\n        // This ensures we only add values from valid previous positions.\n        svbool_t pg_valid_shift = svcmpge_u8(pg, indices, svdup_u8(i));\n\n        // Gather the values from psum_vec using shifted_indices.\n        // svtbl_s8_z returns 0 for inactive lanes of pg_valid_shift or out-of-bounds indices.\n        svint8_t shifted_val = svtbl_s8_z(pg_valid_shift, psum_vec, shifted_indices);\n        \n        // Add the shifted values to the current prefix sums.\n        // The addition is masked by the main predicate 'pg' to only update active lanes.\n        psum_vec = svadd_s8_m(psum_vec, pg, psum_vec, shifted_val);\n    }\n    return psum_vec;\n}\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n\n    // Early exit for invalid lengths or empty string\n    if (n % 2 != 0) {\n        return false; // Odd length cannot be balanced\n    }\n    if (n == 0) {\n        return true; // Empty string is balanced\n    }\n\n    int current_balance = 0;\n    int min_overall_balance = 0; // Tracks the minimum balance encountered so far\n\n    const char* ptr = brackets.data();\n    int i = 0;\n\n    // Loop through the string in SVE vector chunks\n    while (i < n) {\n        // Create a predicate for the current vector chunk, handling the tail\n        svbool_t pg = svwhilelt_b8_s64(i, n);\n        \n        // If no lanes are active, we've processed the entire string\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters into an SVE vector\n        svint8_t char_vec = svld1_s8(pg, ptr + i);\n\n        // Create predicates for '<' and '>' characters\n        svbool_t is_lt = svcmpeq_s8(pg, char_vec, '<');\n        svbool_t is_gt = svcmpeq_s8(pg, char_vec, '>');\n\n        // Create a vector of +1 for '<', -1 for '>', and 0 for others\n        svint8_t val_vec = svdup_s8(0); // Initialize all lanes to 0\n        val_vec = svsel_s8(is_lt, svdup_s8(1), val_vec);\n        val_vec = svsel_s8(is_gt, svdup_s8(-1), val_vec);\n\n        // Compute prefix sums for the current vector of values\n        svint8_t psum_vec = sve_prefix_sum(pg, val_vec);\n\n        // Add the current_balance (from previous blocks) to all prefix sums\n        // in the current block to get the absolute balance at each point.\n        svint8_t current_block_balances = svadd_s8(psum_vec, svdup_s8(current_balance));\n\n        // Find the minimum balance within this block\n        int min_in_block = svminv_s8(pg, current_block_balances);\n\n        // Update the overall minimum balance encountered across all blocks\n        min_overall_balance = std::min(min_overall_balance, min_in_block);\n\n        // Update the running balance for the next block by summing the current vector's values\n        current_balance += svaddv_s8(pg, val_vec);\n\n        // Advance the string pointer by the current vector length\n        i += svcntb();\n    }\n\n    // After processing all characters, check the final balance and the overall minimum balance\n    if (current_balance != 0) {\n        return false; // Unmatched opening or closing brackets\n    }\n    if (min_overall_balance < 0) {\n        return false; // Balance dropped below zero at some point\n    }\n\n    return true; // All conditions met, brackets are correctly balanced\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cstdint> // For int32_t\n\n/*\nbrackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing_simd(\"<\")\nfalse\n>>> correct_bracketing_simd(\"<>\")\ntrue\n>>> correct_bracketing_simd(\"<<><>>\")\ntrue\n>>> correct_bracketing_simd(\"><<>\")\nfalse\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    int balance = 0; // Current balance of brackets\n\n    // Loop through the string in chunks of SVE vector length\n    // svcntb() returns the number of bytes in an SVE vector\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b8(index, limit) generates a predicate that is true for elements\n        // where index + element_offset < limit. This handles partial vectors at the end.\n        svbool_t current_pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector of unsigned 8-bit integers.\n        // Only elements covered by current_pg will be loaded.\n        svuint8_t chars_vec = svld1_u8(current_pg, (const uint8_t*)&brackets[i]);\n\n        // Determine if each character is an opening bracket '<'.\n        // This creates a boolean predicate vector.\n        svbool_t is_open = svcmpeq_u8(current_pg, chars_vec, '<');\n\n        // Convert characters to numerical values: +1 for '<', -1 for '>'.\n        // We use svint32_t to prevent overflow for long strings, as the balance can exceed int8_t/int16_t limits.\n        svint32_t values_s32 = svsel_s32(is_open, svdup_s32(1), svdup_s32(-1));\n\n        // Compute exclusive prefix sums of the values within the current vector.\n        // svscan_s32(predicate, vector, initial_value) computes:\n        // [initial_value, initial_value + v[0], initial_value + v[0] + v[1], ...]\n        svint32_t exclusive_prefix_sums_s32 = svscan_s32(current_pg, values_s32, svdup_s32(0));\n\n        // Compute inclusive prefix sums by adding the current value to its exclusive prefix sum.\n        // This gives the balance relative to the start of the current vector chunk.\n        svint32_t inclusive_prefix_sums_s32 = svadd_s32(exclusive_prefix_sums_s32, values_s32);\n\n        // Add the running balance from previous chunks to get the actual prefix sums.\n        // This vector now contains the absolute balance at each position within the current chunk.\n        svint32_t actual_prefix_sums_s32 = svadd_s32(inclusive_prefix_sums_s32, svdup_s32(balance));\n\n        // Find the minimum value in the actual prefix sums for the current chunk.\n        // svminv_s32(predicate, vector) finds the minimum among active elements.\n        int32_t min_in_chunk = svminv_s32(current_pg, actual_prefix_sums_s32);\n\n        // If any prefix sum dropped below zero, it means a closing bracket appeared\n        // without a corresponding opening bracket, so the bracketing is incorrect.\n        if (min_in_chunk < 0) {\n            return false;\n        }\n\n        // Update the running balance for the next chunk.\n        // svaddv_s32(predicate, vector) computes the sum of all active elements in the vector.\n        // This gives the net change in balance for the current chunk.\n        balance += svaddv_s32(current_pg, values_s32);\n    }\n\n    // After processing all chunks, the final balance must be zero for correct bracketing.\n    // A non-zero balance means there are unmatched opening or closing brackets.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // For std::min\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) {\n        return true;\n    }\n\n    int64_t balance = 0;\n\n    // Get the number of 64-bit elements in an SVE vector.\n    // We will process this many characters at a time, mapping each char to an s64 delta.\n    size_t VL_s64 = svcntd();\n\n    // Loop through the string in chunks of VL_s64 characters\n    for (size_t i = 0; i < len; i += VL_s64) {\n        // Predicate for active 64-bit elements in the current vector.\n        // This predicate ensures we only process valid characters up to the string length.\n        svbool_t pg_s64 = svwhilelt_b64(i, len);\n\n        // Load characters as 8-bit values into a vector of 64-bit integers.\n        // svld1_gather_u8base_s64offset loads one 8-bit character into each 64-bit lane.\n        // The base address is `&brackets[i]`, and `svindex_s64(0, 1)` provides offsets (0, 1, 2, ...)\n        // for each lane, effectively loading `brackets[i]`, `brackets[i+1]`, etc.\n        svint64_t vec_chars_s64 = svld1_gather_u8base_s64offset(pg_s64, (const uint8_t*)&brackets[i], svindex_s64(0, 1));\n\n        // Create a delta vector (s64) where each element will be 1 for '<', -1 for '>', and 0 otherwise.\n        // Initialize all lanes to 0.\n        svint64_t delta_vec_s64 = svdup_s64_z(svptrue_b64(), 0);\n\n        // Create predicates for '<' and '>' characters.\n        // svcmpeq_s64 compares each 64-bit lane with the character value.\n        svbool_t pred_open = svcmpeq_s64(pg_s64, vec_chars_s64, '<');\n        svbool_t pred_close = svcmpeq_s64(pg_s64, vec_chars_s64, '>');\n\n        // Set delta values: 1 for opening brackets, -1 for closing brackets.\n        delta_vec_s64 = svsel_s64(pred_open, svdup_s64(1), delta_vec_s64);\n        delta_vec_s64 = svsel_s64(pred_close, svdup_s64(-1), delta_vec_s64);\n\n        // Perform parallel scan (prefix sum and prefix minimum) on delta_vec_s64.\n        // current_prefix_sum will store the running sum up to each element.\n        // min_prefix_sum_in_chunk will store the minimum running sum up to each element.\n        svint64_t current_prefix_sum = svdup_s64_z(svptrue_b64(), 0);\n        svint64_t min_prefix_sum_in_chunk = svdup_s64_z(svptrue_b64(), 0);\n\n        // Initialize the scan vectors with the delta values for active lanes.\n        current_prefix_sum = svsel_s64(pg_s64, delta_vec_s64, current_prefix_sum);\n        min_prefix_sum_in_chunk = svsel_s64(pg_s64, delta_vec_s64, min_prefix_sum_in_chunk);\n\n        // Parallel scan loop (log2(VL_s64) iterations).\n        // In each iteration, elements are shifted and added/min-ed to accumulate prefix sums/minimums.\n        for (size_t k = 1; k < VL_s64; k *= 2) {\n            // Predicate for elements that will be updated in this step (elements at index >= k).\n            svbool_t pg_shift = svwhilelt_b64(k, VL_s64);\n\n            // Shift the current prefix sums/minimums to the left by 'k' positions.\n            svint64_t shifted_sum = svslideleft_s64(current_prefix_sum, k);\n            svint64_t shifted_min = svslideleft_s64(min_prefix_sum_in_chunk, k);\n\n            // Update current_prefix_sum: add the shifted sum to the current sum.\n            current_prefix_sum = svadd_s64(pg_shift, current_prefix_sum, shifted_sum);\n\n            // Update min_prefix_sum_in_chunk:\n            // The new minimum at a position is the minimum of its current value\n            // and the sum of the shifted minimum and the shifted sum.\n            // This correctly propagates the minimum prefix sum.\n            min_prefix_sum_in_chunk = svmin_s64(pg_shift, min_prefix_sum_in_chunk, svadd_s64(pg_shift, shifted_min, shifted_sum));\n        }\n\n        // Extract the overall minimum prefix sum within this chunk.\n        // svminv_s64 reduces the vector to a single scalar minimum value.\n        int64_t min_val_in_chunk = svminv_s64(pg_s64, min_prefix_sum_in_chunk);\n\n        // Extract the final prefix sum of this chunk.\n        // svlasta_s64 returns the last active element from the vector.\n        int64_t final_val_in_chunk = svlasta_s64(pg_s64, current_prefix_sum);\n\n        // Check if the balance ever drops below zero within this chunk, considering the global balance.\n        if (balance + min_val_in_chunk < 0) {\n            return false; // Invalid bracketing\n        }\n\n        // Update the global balance with the total delta from this chunk.\n        balance += final_val_in_chunk;\n    }\n\n    // After processing all chunks, the bracketing is correct if and only if the final balance is zero.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Not strictly needed for this implementation, but good practice for std::min/max if used.\n\n// Helper function to compute prefix sums for an SVE vector of 16-bit integers.\n// P[i] = D[i] + D[i-1] + ... + D[0]\n// pg_orig: The original predicate for the vector elements. Operations should only apply to active elements.\n// deltas: The input vector of values (+1, -1, or 0 for brackets).\nsvint16_t compute_prefix_sums(svbool_t pg_orig, svint16_t deltas) {\n    svint16_t prefix_sums = deltas;\n    int vl = svcntw(); // Get current vector length in 16-bit elements (words)\n\n    // Hillis-Steele scan algorithm for parallel prefix sum.\n    // P_k[i] = P_k[i] + P_k[i - 2^j]\n    for (int shift = 1; shift < vl; shift <<= 1) {\n        // Create an index vector for the elements to be added (P[i - shift]).\n        // For element i, we want to add the value from index (i - shift).\n        // If (i - shift) < 0, we should effectively add 0.\n        svuint16_t indices = svindex_u16(0, 1); // Generates [0, 1, 2, ..., vl-1]\n        svuint16_t shifted_indices = svsub_n_u16(indices, shift); // Generates [0-shift, 1-shift, ..., vl-1-shift]\n\n        // Predicate for elements where (i - shift) is valid (i.e., i >= shift).\n        // This ensures that only valid source elements are gathered.\n        svbool_t pg_valid_shift = svwhilege_b16(indices, shift);\n\n        // Gather the values P[i - shift] using the shifted_indices.\n        // svpermute_n_s16 will return 0 for out-of-bounds indices (which occur when i < shift\n        // and shifted_indices[i] wraps around to a large unsigned value).\n        // The pg_valid_shift predicate further ensures that only valid elements are considered.\n        svint16_t values_to_add = svpermute_n_s16(pg_valid_shift, prefix_sums, shifted_indices);\n\n        // Add the gathered values to the current prefix_sums.\n        // The addition is performed only for elements active in the original predicate (pg_orig).\n        prefix_sums = svadd_s16_x(pg_orig, prefix_sums, values_to_add);\n    }\n    return prefix_sums;\n}\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0; // Scalar balance, can be int (32-bit or 64-bit)\n    size_t len = brackets.length();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(brackets.data());\n    size_t i = 0;\n\n    while (i < len) {\n        // Predicate for loading 8-bit characters.\n        // It defines which elements in the current vector are valid (within string bounds).\n        svbool_t pg_char = svwhilelt_b8(i, len);\n        \n        // If no active elements in the current vector, break the loop.\n        if (svptest_n(svptrue_b8(), pg_char) == 0) {\n            break;\n        }\n\n        // Load a vector of characters from the string.\n        svuint8_t chars = svld1(pg_char, data + i);\n\n        // Convert the 8-bit character predicate to a 16-bit predicate for sum calculations.\n        svbool_t pg_sum = svcvt_b16_b8(pg_char);\n\n        // Determine deltas: +1 for '(', -1 for ')'.\n        // These comparisons result in 8-bit predicates.\n        svbool_t is_open_char = svcmpeq(pg_char, chars, '(');\n        svbool_t is_close_char = svcmpeq(pg_char, chars, ')');\n\n        // Convert 8-bit boolean results to 16-bit boolean predicates for use with 16-bit vectors.\n        svbool_t is_open_sum = svcvt_b16_b8(is_open_char);\n        svbool_t is_close_sum = svcvt_b16_b8(is_close_char);\n\n        // Initialize a 16-bit delta vector with zeros for inactive elements.\n        svint16_t deltas = svdup_s16_z(pg_sum, 0);\n        // Set +1 for opening brackets.\n        deltas = svsel_s16(is_open_sum, svdup_s16(1), deltas);\n        // Set -1 for closing brackets.\n        deltas = svsel_s16(is_close_sum, svdup_s16(-1), deltas);\n\n        // Compute prefix sums for the current block of deltas using the helper function.\n        svint16_t current_block_prefix_sums = compute_prefix_sums(pg_sum, deltas);\n\n        // Add the global balance from previous blocks to each prefix sum in the current block.\n        // This gives the absolute balance at each point within the current block.\n        svint16_t block_balances = svadd_s16_x(pg_sum, current_block_prefix_sums, svdup_s16(balance));\n\n        // Check if any balance in this block dropped below zero.\n        // svminv_s16 finds the minimum value among the active elements.\n        int16_t min_block_balance = svminv_s16(pg_sum, block_balances);\n        if (min_block_balance < 0) {\n            return false; // Bracketing is incorrect.\n        }\n\n        // Update the global balance for the next block.\n        // The last active element of current_block_prefix_sums holds the total sum for this block.\n        int16_t block_total_sum = svlasta_s16(pg_sum, current_block_prefix_sums);\n        balance += block_total_sum;\n\n        // Advance the string index by the number of bytes processed in this vector.\n        // svcntb() returns the current vector length in bytes (for 8-bit elements).\n        i += svcntb();\n    }\n\n    // After processing all blocks, the final balance must be zero for correct bracketing.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <numeric>\n\n// Helper function to compute prefix sums for an SVE vector.\n// This implements a parallel scan (Hillis-Steele or similar) using SVE intrinsics.\n// It takes a predicate 'pg' to handle active lanes, especially for the tail end of the string.\nstatic svint32_t prefix_sum_s32(svbool_t pg, svint32_t vec) {\n    svint32_t res = vec;\n    // Get the number of 32-bit elements in a vector.\n    // svcntw() returns the number of 32-bit elements in the current SVE vector.\n    int VL_w = svcntw(); \n\n    // Iterate through log2(VL_w) steps to compute the prefix sum.\n    // In each step, elements are added with elements from 'i' positions back.\n    for (int i = 1; i < VL_w; i *= 2) {\n        // Create an index vector [0, 1, 2, ..., VL_w-1]\n        svuint32_t indices = svindex_u32(0, 1);\n        \n        // Create shifted indices [0-i, 1-i, ..., VL_w-1-i]\n        svuint32_t shifted_indices = svsub_n_u32(indices, i);\n        \n        // Create a predicate for lanes that have a valid predecessor 'i' steps back.\n        // This predicate is active only for lanes where index >= i AND the original predicate 'pg' is true.\n        svbool_t active_shifted_lanes = svcmpge_n_u32(pg, indices, i);\n        \n        // Gather elements from 'res' using 'shifted_indices'.\n        // If an index is out of range (e.g., negative), svtbl_s32 returns 0 for that element.\n        svint32_t shifted_vec = svtbl_s32(res, shifted_indices);\n        \n        // Add the shifted vector to the current result.\n        // Use svsel_s32 to only add for active shifted lanes, otherwise add 0.\n        res = svadd_s32(res, svsel_s32(active_shifted_lanes, shifted_vec, svdup_s32(0)));\n    }\n    return res;\n}\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t current_balance = 0;\n    size_t N = brackets.length();\n    size_t i = 0;\n\n    while (i < N) {\n        // Get a predicate for the current vector chunk.\n        // svwhilelt_b8 generates a predicate for 8-bit elements (bytes).\n        svbool_t pg = svwhilelt_b8(i, N);\n\n        // Load characters from the string into an SVE vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n\n        // Create predicates for '(' and ')' characters.\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '(');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, ')');\n\n        // Initialize a vector with zeros.\n        svint32_t values = svdup_s32(0);\n        // Set elements to +1 where char is '('.\n        values = svsel_s32(is_open, svdup_s32(1), values);\n        // Set elements to -1 where char is ')'.\n        values = svsel_s32(is_close, svdup_s32(-1), values);\n\n        // Compute the prefix sums of the 'values' vector within the current chunk.\n        // This gives the balance change relative to the start of the current chunk.\n        svint32_t local_prefix_sums = prefix_sum_s32(pg, values);\n\n        // Add the global 'current_balance' to each element of the local prefix sums.\n        // This gives the actual balance at each point within the current chunk.\n        svint32_t current_balance_vector = svadd_n_s32(local_prefix_sums, current_balance);\n\n        // Find the minimum balance value within the current chunk.\n        // Only consider active lanes specified by 'pg'.\n        int32_t min_in_chunk = svminv_s32(pg, current_balance_vector);\n\n        // If the minimum balance in this chunk ever dropped below zero, the bracketing is incorrect.\n        if (min_in_chunk < 0) {\n            return false;\n        }\n\n        // Add the sum of the current chunk's values to the global balance.\n        // This updates the 'current_balance' for the next chunk.\n        current_balance += svaddv_s32(pg, values);\n\n        // Advance the string index by the number of bytes processed in this vector.\n        i += svcntb();\n    }\n\n    // After processing all chunks, the final balance must be zero for correct bracketing.\n    return current_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nbool correct_bracketing_simd(std::string brackets) {\n    long current_balance = 0;\n    long min_balance_overall = 0;\n\n    const char* data = brackets.data();\n    long len = brackets.length();\n\n    for (long i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        svuint8_t char_vec = svld1_u8(pg, (const uint8_t*)(data + i));\n\n        svint8_t val_vec;\n        svint8_t ones = svdup_s8(1);\n        svint8_t neg_ones = svdup_s8(-1);\n        svint8_t zeros = svdup_s8(0);\n\n        svbool_t is_open = svcmpeq_u8(pg, char_vec, '(');\n        val_vec = svsel_s8(is_open, ones, zeros);\n\n        svbool_t is_close = svcmpeq_u8(pg, char_vec, ')');\n        val_vec = svsel_s8(is_close, neg_ones, val_vec);\n\n        int active_elements = svcntp_b8(pg, pg);\n\n        int8_t temp_vals[svcntb()];\n        svst1_s8(svptrue_b8(), temp_vals, val_vec);\n\n        long min_prefix_sum_in_chunk = 0;\n        long current_prefix_sum_in_chunk = 0;\n\n        for (int k = 0; k < active_elements; ++k) {\n            current_prefix_sum_in_chunk += temp_vals[k];\n            if (current_prefix_sum_in_chunk < min_prefix_sum_in_chunk) {\n                min_prefix_sum_in_chunk = current_prefix_sum_in_chunk;\n            }\n        }\n\n        min_balance_overall = std::min(min_balance_overall, current_balance + min_prefix_sum_in_chunk);\n\n        current_balance += svaddv_s8(pg, val_vec);\n\n        if (min_balance_overall < 0) {\n            return false;\n        }\n    }\n\n    return current_balance == 0 && min_balance_overall >= 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // For std::min\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int min_balance_overall = 0;\n    size_t len = brackets.length();\n\n    // Iterate through the string in chunks of SVE vector length (in bytes).\n    // svcntb() returns the number of 8-bit elements in an SVE vector.\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures we only process valid characters at the end of the string.\n        svbool_t pg_b8 = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector of unsigned 8-bit integers.\n        svuint8_t chars = svld1_u8(pg_b8, (const uint8_t*)&brackets[i]);\n\n        // Create predicates for '(' and ')' characters.\n        svbool_t is_open = svcmpeq(pg_b8, chars, svdup_u8('('));\n        svbool_t is_close = svcmpeq(pg_b8, chars, svdup_u8(')'));\n\n        // Convert the 8-bit predicate to a 32-bit predicate for int32_t operations.\n        svbool_t pg_32 = svcvt_b32_b8(pg_b8);\n\n        // Initialize a vector of 32-bit integers with zeros.\n        svint32_t values = svdup_s32(0);\n\n        // Set +1 for '(' characters in the 'values' vector.\n        values = svsel(is_open, svdup_s32(1), values);\n\n        // Set -1 for ')' characters in the 'values' vector.\n        values = svsel(is_close, svdup_s32(-1), values);\n\n        // --- Perform an inclusive prefix sum (scan) on 'values' within the current chunk ---\n        // This computes a vector where each element is the sum of all preceding elements\n        // in 'values' plus itself.\n        svint32_t chunk_relative_prefix_sums = values;\n        // svcntw() returns the number of 32-bit elements in an SVE vector.\n        for (int k = 1; k < svcntw(); k <<= 1) {\n            // Create an index vector for shifting elements.\n            // svindex_s32(0, 1) creates [0, 1, 2, ..., VL-1]\n            // svsub_s32(indices, svdup_s32(k)) creates [-k, 1-k, ..., VL-1-k]\n            svint32_t indices_to_add = svsub_s32(svindex_s32(0, 1), svdup_s32(k));\n\n            // Gather (shift) elements from 'chunk_relative_prefix_sums' using the calculated indices.\n            // Elements with out-of-bounds indices (negative) are set to zero by svtbl_s32.\n            svint32_t shifted_values = svtbl_s32(pg_32, chunk_relative_prefix_sums, indices_to_add);\n\n            // Add the shifted values to the current prefix sums.\n            chunk_relative_prefix_sums = svadd_s32(pg_32, chunk_relative_prefix_sums, shifted_values);\n        }\n\n        // Add the current global 'balance' (from previous chunks) to the chunk's prefix sums.\n        // This converts relative prefix sums to absolute prefix sums.\n        svint32_t absolute_prefix_sums_in_chunk = svadd_s32(pg_32, chunk_relative_prefix_sums, svdup_s32(balance));\n\n        // Find the minimum value among the absolute prefix sums in the current chunk.\n        // This tells us if the balance ever dropped below zero within this chunk.\n        int min_in_chunk = svminv_s32(pg_32, absolute_prefix_sums_in_chunk);\n\n        // Update the overall minimum balance encountered so far.\n        min_balance_overall = std::min(min_balance_overall, min_in_chunk);\n\n        // Update the global balance by summing all values in the current chunk.\n        balance += svaddv_s32(pg_32, values);\n    }\n\n    // A correct bracketing sequence must satisfy two conditions:\n    // 1. The final balance must be zero (all opening brackets have a corresponding closing bracket).\n    // 2. The balance must never drop below zero at any point (no closing bracket without a preceding opening bracket).\n    return balance == 0 && min_balance_overall >= 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <string>\n#include <algorithm> // For std::min\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t current_balance = 0;\n    int64_t min_balance_overall = 0; // Tracks the minimum balance encountered globally\n\n    size_t N = brackets.length();\n    size_t i = 0;\n\n    // Get the number of 64-bit elements in an SVE vector.\n    // This determines the loop unrolling factor for the scan.\n    const int VL_elements = svcntd(); \n\n    while (i < N) {\n        // Create a predicate for the current vector chunk.\n        // `b8` means byte predicate, as we are loading characters (uint8_t).\n        svbool_t pg = svwhilelt_b8(i, N);\n\n        // If no elements are active in the predicate, we've processed all characters.\n        if (svptest_n(svptrue_b8(), pg) == 0) {\n            break;\n        }\n\n        // Load characters into an SVE vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n\n        // Create predicates for '(' and ')'.\n        svbool_t is_open = svcmpeq(pg, chars, '(');\n        svbool_t is_close = svcmpeq(pg, chars, ')');\n\n        // Initialize a vector to store balance changes (+1 for '(', -1 for ')', 0 otherwise).\n        svint64_t balance_changes = svdup_s64(0);\n        balance_changes = svsel(is_open, svdup_s64(1), balance_changes);\n        balance_changes = svsel(is_close, svdup_s64(-1), balance_changes);\n\n        // --- Parallel Prefix Sum (Scan) and Prefix Minimum (Scan) ---\n        // This section computes for each element j in the vector:\n        // 1. The sum of balance_changes[0...j]\n        // 2. The minimum of balance_changes[0...j]\n        // The algorithm used is a Blelloch scan.\n\n        svint64_t v_current_prefix_sums = balance_changes;\n        svint64_t v_current_min_prefix_sums = balance_changes;\n\n        for (int k = 1; k < VL_elements; k <<= 1) {\n            // Generate indices for the vector elements (0, 1, 2, ...).\n            svint64_t indices = svindex_s64(0, 1);\n            // Generate shifted indices (i - k).\n            svint64_t shifted_indices = svsub_s64(indices, svdup_s64(k));\n            // Create a predicate for elements where i >= k (i.e., elements that receive a sum/min from a previous block).\n            svbool_t pg_active_scan = svcmpge(svptrue_b64(), indices, svdup_s64(k));\n\n            // Gather the sum from the block ending at index (i - k) from the current `v_current_prefix_sums`.\n            // `svtbl_s64` returns 0 for out-of-bounds indices, which is correct for this scan.\n            svint64_t sum_from_shifted_block = svtbl_s64(v_current_prefix_sums, shifted_indices);\n            // Gather the minimum from the block ending at index (i - k) from the current `v_current_min_prefix_sums`.\n            svint64_t min_from_shifted_block = svtbl_s64(v_current_min_prefix_sums, shifted_indices);\n\n            // Update prefix sums: `v_current_prefix_sums[i] = v_current_prefix_sums[i] + sum_from_shifted_block`.\n            v_current_prefix_sums = svadd_s64_m(pg_active_scan, v_current_prefix_sums, sum_from_shifted_block);\n            \n            // Update prefix minimums: `v_current_min_prefix_sums[i] = min(v_current_min_prefix_sums[i], min_from_shifted_block + sum_from_shifted_block)`.\n            // The `sum_from_shifted_block` is added to `min_from_shifted_block` because the minimum of the second block\n            // needs to be offset by the total sum of the first block to reflect the true global minimum up to that point.\n            v_current_min_prefix_sums = svmin_s64_m(pg_active_scan, v_current_min_prefix_sums, \n                                                    svadd_s64_m(pg_active_scan, min_from_shifted_block, sum_from_shifted_block));\n        }\n\n        // After the scan, `v_current_min_prefix_sums` contains the prefix minimums for this vector chunk.\n        // We need the overall minimum within this chunk, relative to the start of the chunk.\n        int64_t min_in_vector_relative = svminv_s64(pg, v_current_min_prefix_sums);\n        \n        // Update the global minimum balance encountered so far.\n        // The minimum balance within this chunk, considering the balance before this chunk, is `current_balance + min_in_vector_relative`.\n        min_balance_overall = std::min(min_balance_overall, current_balance + min_in_vector_relative);\n\n        // Get the total sum of balance changes for this vector chunk.\n        // `svlasta_s64` returns the value of the last active element in the vector.\n        // For a prefix sum, the last active element holds the total sum of the active elements.\n        int64_t sum_in_vector = svlasta_s64(pg, v_current_prefix_sums);\n        \n        // Update the running balance.\n        current_balance += sum_in_vector;\n\n        // Advance the string pointer by the number of bytes in an SVE vector.\n        // `svcntb()` returns the number of bytes in an SVE vector.\n        i += svcntb();\n    }\n\n    // Final check:\n    // 1. The total balance must be zero (all opening brackets must have a corresponding closing bracket).\n    // 2. The balance must never have dropped below zero at any point (no closing bracket without a preceding opening bracket).\n    return current_balance == 0 && min_balance_overall >= 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is an empty polynomial\n    }\n\n    size_t n_out = n - 1;\n    std::vector<float> result(n_out);\n\n    // The derivative of P(x) = c_0 + c_1*x + c_2*x^2 + ... + c_n*x^n\n    // is P'(x) = c_1 + 2*c_2*x + 3*c_3*x^2 + ... + n*c_n*x^(n-1).\n    // The new coefficients are result[k] = xs[k+1] * (k+1).\n    // k ranges from 0 to n_out - 1 (which is n - 2).\n\n    size_t i = 0;\n    svbool_t pg;\n\n    // Loop through the output coefficients using SVE vector length\n    for (i = 0; i < n_out; i += svcnt_f32()) {\n        // Generate a predicate for the current vector chunk\n        pg = svwhilelt_b32((uint32_t)i, (uint32_t)n_out);\n\n        // Load the coefficients from xs.\n        // For result[i], we need xs[i+1].\n        // So, the base address for loading is &xs[1 + i].\n        svfloat32_t coeffs = svld1_f32(pg, &xs[1 + i]);\n\n        // Generate the multipliers: (i+1), (i+2), ..., (i + svcnt_f32()).\n        // svindex_f32(start, step) generates a sequence starting from 'start' with 'step' increment.\n        svfloat32_t multipliers = svindex_f32((float)(i + 1), 1.0f);\n\n        // Perform element-wise multiplication: coeffs * multipliers\n        svfloat32_t derivatives = svmul_f32_x(pg, coeffs, multipliers);\n\n        // Store the computed derivative coefficients into the result vector\n        svst1_f32(pg, &result[i], derivatives);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t N = xs.size();\n    if (N <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is an empty polynomial\n    }\n\n    size_t N_out = N - 1;\n    std::vector<float> result(N_out);\n\n    // Get the number of 32-bit elements (floats) per SVE vector\n    size_t vl = svcntw();\n\n    // Loop variables:\n    // i: current index for the output vector (result)\n    // k: current starting index for the input vector (xs) and the multiplier value\n    size_t i = 0;\n    size_t k = 1; // The first coefficient for the derivative is xs[1] * 1\n\n    // Predicate register for controlling vector operations\n    svbool_t pg;\n\n    while (i < N_out) {\n        // Create a predicate for the current vector chunk.\n        // Elements are active as long as their logical index (i + element_offset) is less than N_out.\n        pg = svwhilelt_b32(i, N_out);\n\n        // Load coefficients from the input vector xs.\n        // The coefficients are xs[k], xs[k+1], ...\n        svfloat32_t coeffs = svld1_f32(pg, &xs[k]);\n\n        // Generate the sequence of multipliers: k, k+1, k+2, ...\n        // svindex_f32(start, step) generates a vector where the first element is 'start',\n        // the second is 'start + step', and so on.\n        svfloat32_t multipliers = svindex_f32(k, 1);\n\n        // Perform the element-wise multiplication: derivative_coeff = xs[k] * k\n        svfloat32_t derivatives = svmul_f32(pg, coeffs, multipliers);\n\n        // Store the results into the output vector\n        svst1_f32(pg, &result[i], derivatives);\n\n        // Advance the loop indices by the number of elements processed in this vector\n        i += vl;\n        k += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {};\n    }\n\n    size_t n_out = n - 1;\n    std::vector<float> result(n_out);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n_out);\n    while (svcntp_b32(pg) > 0) {\n        svfloat32_t multipliers = svindex_f32(i + 1, 1);\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n        svfloat32_t deriv_coeffs = svmul_f32_x(pg, coeffs, multipliers);\n        svst1_f32(pg, &result[i], deriv_coeffs);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n\n    // If the polynomial has 0 or 1 term (a constant), its derivative is 0,\n    // represented by an empty vector of coefficients.\n    if (n < 2) {\n        return {};\n    }\n\n    // The derivative of P(x) = c_0 + c_1*x + c_2*x^2 + ... + c_n*x^n\n    // is P'(x) = c_1 + 2*c_2*x + 3*c_3*x^2 + ... + n*c_n*x^(n-1).\n    // The new coefficients are result[k] = xs[k+1] * (k+1).\n    // The output vector will have n-1 elements.\n    std::vector<float> result(n - 1);\n\n    // Get the vector length for float (32-bit) elements.\n    size_t vl = svcnt_f32();\n\n    // Loop through the coefficients, processing 'vl' elements at a time.\n    // The loop iterates over the indices of the 'result' vector.\n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Generate a predicate for the current vector chunk.\n        // This handles the tail elements where the number of remaining elements\n        // might be less than the full vector length.\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n\n        // Load the coefficients from the input vector 'xs'.\n        // For result[i], we need xs[i+1]. So, the base address for loading\n        // is &xs[i+1].\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n\n        // Generate the multipliers. For result[i], the multiplier is (i+1).\n        // svindex_f32(start, step) creates a vector with elements: start, start+step, start+2*step, ...\n        // Here, start = i+1, step = 1.\n        svfloat32_t multipliers = svindex_f32(i + 1, 1);\n\n        // Perform the element-wise multiplication: coeffs * multipliers.\n        // The '_x' suffix means that inactive lanes (determined by 'pg') are not modified.\n        svfloat32_t deriv_coeffs = svmul_f32_x(pg, coeffs, multipliers);\n\n        // Store the computed derivative coefficients into the 'result' vector.\n        // The base address for storing is &result[i].\n        svst1_f32(pg, &result[i], deriv_coeffs);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t N_in = xs.size();\n    if (N_in <= 1) {\n        // Derivative of a constant or an empty polynomial is an empty polynomial.\n        return {}; \n    }\n\n    size_t N_out = N_in - 1;\n    std::vector<float> result(N_out);\n\n    // Get the number of float elements per SVE vector.\n    size_t sv_len = svcntw();\n\n    // Iterate through the output elements in chunks of sv_len.\n    // The i-th element of the derivative polynomial is (i+1) * xs[i+1].\n    // The loop variable 'i' corresponds to the index in the 'result' vector.\n    for (size_t i = 0; i < N_out; i += sv_len) {\n        // Create a predicate for the current vector chunk.\n        // This ensures that we only process valid elements within the bounds of N_out.\n        svbool_t pg = svwhilelt_b32(i, N_out);\n\n        // Load the coefficients from the input vector 'xs'.\n        // The coefficients needed are xs[1], xs[2], ..., xs[N_in-1].\n        // For the current chunk starting at 'i', we need xs[i+1], xs[i+2], etc.\n        // So, the base address for loading is &xs[1 + i].\n        svfloat32_t coeffs = svld1_f32(pg, &xs[1 + i]);\n\n        // Generate the multipliers: (i+1), (i+2), ... for the current chunk.\n        // svindex_s32(base, step) generates a sequence starting from 'base' with 'step' increments.\n        // Here, the base is (i+1) and the step is 1.\n        svint32_t multipliers_int = svindex_s32(i + 1, 1);\n        \n        // Convert the integer multipliers to float type for multiplication.\n        svfloat32_t multipliers_float = svcvt_f32_s32(multipliers_int);\n\n        // Perform the element-wise multiplication: coefficient * multiplier.\n        svfloat32_t deriv_coeffs = svmul_f32(coeffs, multipliers_float);\n\n        // Store the computed derivative coefficients into the 'result' vector.\n        // The base address for storing is &result[i].\n        svst1_f32(pg, &result[i], deriv_coeffs);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nint vowels_count_simd(std::string s) {\n    int total_vowels = 0;\n    size_t len = s.length();\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(s.data());\n\n    // Create SVE vectors for each vowel character (both cases)\n    svuint8_t vec_a = svdup_u8(static_cast<uint8_t>('a'));\n    svuint8_t vec_A = svdup_u8(static_cast<uint8_t>('A'));\n    svuint8_t vec_e = svdup_u8(static_cast<uint8_t>('e'));\n    svuint8_t vec_E = svdup_u8(static_cast<uint8_t>('E'));\n    svuint8_t vec_i = svdup_u8(static_cast<uint8_t>('i'));\n    svuint8_t vec_I = svdup_u8(static_cast<uint8_t>('I'));\n    svuint8_t vec_o = svdup_u8(static_cast<uint8_t>('o'));\n    svuint8_t vec_O = svdup_u8(static_cast<uint8_t>('O'));\n    svuint8_t vec_u = svdup_u8(static_cast<uint8_t>('u'));\n    svuint8_t vec_U = svdup_u8(static_cast<uint8_t>('U'));\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string\n        svuint8_t chars = svld1_u8(pg, ptr + i);\n\n        // Compare characters with each vowel (case-insensitive)\n        svbool_t is_vowel_mask = svcmpeq_u8(pg, chars, vec_a);\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_A));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_e));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_E));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_i));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_I));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_o));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_O));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_u));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, vec_U));\n\n        // Count the number of active (true) predicates in the mask\n        total_vowels += svcntp_b(pg, is_vowel_mask);\n    }\n\n    // Handle 'y' at the end of the word\n    if (len > 0) {\n        char last_char = s[len - 1];\n        if (last_char == 'y' || last_char == 'Y') {\n            total_vowels++;\n        }\n    }\n\n    return total_vowels;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstddef> // For size_t\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const unsigned char* ptr = reinterpret_cast<const unsigned char*>(s.data());\n\n    // Define SVE vectors for lowercase and uppercase vowels (a, e, i, o, u)\n    // 'y' is handled separately at the end of the word.\n    svuint8_t a_lc = svdup_n_u8('a');\n    svuint8_t e_lc = svdup_n_u8('e');\n    svuint8_t i_lc = svdup_n_u8('i');\n    svuint8_t o_lc = svdup_n_u8('o');\n    svuint8_t u_lc = svdup_n_u8('u');\n\n    svuint8_t a_uc = svdup_n_u8('A');\n    svuint8_t e_uc = svdup_n_u8('E');\n    svuint8_t i_uc = svdup_n_u8('I');\n    svuint8_t o_uc = svdup_n_u8('O');\n    svuint8_t u_uc = svdup_n_u8('U');\n\n    // Loop through the string in SVE vector chunks\n    while (len > 0) {\n        // Get a predicate for the current vector length (active elements)\n        svbool_t pg = svwhilelt_b8(0, len);\n        \n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, ptr);\n\n        // Check for lowercase vowels (a, e, i, o, u)\n        svbool_t is_vowel_lc = svcmpeq(pg, chars, a_lc);\n        is_vowel_lc = svorr_b(is_vowel_lc, svcmpeq(pg, chars, e_lc));\n        is_vowel_lc = svorr_b(is_vowel_lc, svcmpeq(pg, chars, i_lc));\n        is_vowel_lc = svorr_b(is_vowel_lc, svcmpeq(pg, chars, o_lc));\n        is_vowel_lc = svorr_b(is_vowel_lc, svcmpeq(pg, chars, u_lc));\n\n        // Check for uppercase vowels (A, E, I, O, U)\n        svbool_t is_vowel_uc = svcmpeq(pg, chars, a_uc);\n        is_vowel_uc = svorr_b(is_vowel_uc, svcmpeq(pg, chars, e_uc));\n        is_vowel_uc = svorr_b(is_vowel_uc, svcmpeq(pg, chars, i_uc));\n        is_vowel_uc = svorr_b(is_vowel_uc, svcmpeq(pg, chars, o_uc));\n        is_vowel_uc = svorr_b(is_vowel_uc, svcmpeq(pg, chars, u_uc));\n\n        // Combine lowercase and uppercase vowel checks\n        svbool_t is_any_vowel = svorr_b(is_vowel_lc, is_vowel_uc);\n\n        // Count the number of active (true) elements in the combined predicate\n        count += svcntp_b8(pg, is_any_vowel);\n\n        // Determine the number of elements processed in this iteration\n        size_t processed_len = svlen_u8(pg); \n        \n        // Move to the next chunk of the string\n        ptr += processed_len;\n        len -= processed_len;\n    }\n\n    // Handle 'y' at the end of the word\n    if (s.length() > 0) {\n        char last_char = s[s.length() - 1];\n        if (last_char == 'y' || last_char == 'Y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>   // For std::string\n#include <cstdint>  // For uint8_t\n\nint vowels_count_simd(std::string s) {\n    int total_vowels = 0;\n    size_t n = s.length();\n\n    // Handle the special case for 'y' at the end of the word.\n    // 'y' is a vowel only if it's the last character of the string.\n    if (n > 0) {\n        char last_char = s[n - 1];\n        if (last_char == 'y' || last_char == 'Y') {\n            total_vowels++;\n        }\n    }\n\n    // Process the string using SVE intrinsics for 'a', 'e', 'i', 'o', 'u'.\n    // 'y' is explicitly excluded from this loop's vowel check as per the rule.\n    for (size_t i = 0; i < n; i += svcntb()) {\n        // Create a predicate for the current vector chunk.\n        // This ensures we only process valid characters within the string bounds.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters from the string into an SVE vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Convert uppercase letters to lowercase.\n        // Check if character is between 'A' and 'Z'.\n        svbool_t is_upper = svand_b(svcmpge_u8(pg, chars, svdup_u8('A')),\n                                    svcmple_u8(pg, chars, svdup_u8('Z')));\n        // If it's uppercase, add ('a' - 'A') to convert to lowercase.\n        // ('a' - 'A') is 32 in ASCII.\n        svuint8_t lower_chars = svsel_u8(is_upper, svadd_u8(chars, svdup_u8('a' - 'A')), chars);\n\n        // Create predicates for each standard vowel ('a', 'e', 'i', 'o', 'u').\n        svbool_t is_a = svcmpeq_u8(pg, lower_chars, svdup_u8('a'));\n        svbool_t is_e = svcmpeq_u8(pg, lower_chars, svdup_u8('e'));\n        svbool_t is_i = svcmpeq_u8(pg, lower_chars, svdup_u8('i'));\n        svbool_t is_o = svcmpeq_u8(pg, lower_chars, svdup_u8('o'));\n        svbool_t is_u = svcmpeq_u8(pg, lower_chars, svdup_u8('u'));\n\n        // Combine all standard vowel predicates using logical OR.\n        svbool_t is_vowel = svorr_b(is_a, svorr_b(is_e, svorr_b(is_i, svorr_b(is_o, is_u))));\n\n        // Count the number of active (true) elements in the combined vowel predicate\n        // and add to the total count.\n        total_vowels += svcntp_b8(pg, is_vowel);\n    }\n\n    return total_vowels;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cstdint> // For uint8_t\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n\n    // Handle empty string case\n    if (len == 0) {\n        return 0;\n    }\n\n    // Iterate through the string in chunks of vector length (VL)\n    // svcnt_b() returns the number of 8-bit elements (bytes) in an SVE vector.\n    for (size_t i = 0; i < len; i += svcnt_b()) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b(start_index, end_limit) generates a predicate\n        // where elements are active as long as their conceptual index\n        // (starting from 'start_index') is less than 'end_limit'.\n        // This correctly handles partial vectors at the end of the string.\n        svbool_t pg = svwhilelt_b(i, len);\n\n        // Load characters from the string into an SVE vector.\n        // The string data is const char*, cast to const uint8_t* for svld1_u8.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Define SVE vectors for each vowel, both lowercase and uppercase.\n        // svdup_u8(pg, value) broadcasts 'value' to all active lanes of the vector.\n        svuint8_t a_lc = svdup_u8(pg, 'a');\n        svuint8_t e_lc = svdup_u8(pg, 'e');\n        svuint8_t i_lc = svdup_u8(pg, 'i');\n        svuint8_t o_lc = svdup_u8(pg, 'o');\n        svuint8_t u_lc = svdup_u8(pg, 'u');\n\n        svuint8_t a_uc = svdup_u8(pg, 'A');\n        svuint8_t e_uc = svdup_u8(pg, 'E');\n        svuint8_t i_uc = svdup_u8(pg, 'I');\n        svuint8_t o_uc = svdup_u8(pg, 'O');\n        svuint8_t u_uc = svdup_u8(pg, 'U');\n\n        // Initialize a boolean mask for vowels.\n        // svcmpeq_u8(predicate, vector1, vector2) compares elements for equality\n        // and returns a boolean mask where active lanes are true if elements are equal.\n        svbool_t is_vowel_mask = svcmpeq_u8(pg, chars, a_lc);\n        // svorr_b(mask1, mask2) performs a bitwise OR on two boolean masks.\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, a_uc));\n\n        // Combine with 'e'/'E'\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, e_lc));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, e_uc));\n\n        // Combine with 'i'/'I'\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, i_lc));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, i_uc));\n\n        // Combine with 'o'/'O'\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, o_lc));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, o_uc));\n\n        // Combine with 'u'/'U'\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, u_lc));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, u_uc));\n\n        // Count the number of active (true) elements in the combined vowel mask.\n        // svcntp_b(predicate, mask) counts the number of true bits in 'mask'\n        // only for lanes that are active according to 'predicate'.\n        count += svcntp_b(pg, is_vowel_mask);\n    }\n\n    // Handle the special case for 'y': 'y' is a vowel only when it is at the end of the word.\n    // This check must be performed on the last character of the original string,\n    // as its position relative to the end is crucial.\n    // The SVE loop above only counts 'a', 'e', 'i', 'o', 'u' (case-insensitive),\n    // so 'y' would not have been counted by the loop.\n    if (len > 0) {\n        char last_char = s[len - 1];\n        if (last_char == 'y' || last_char == 'Y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstddef> // For size_t\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const unsigned char* ptr = reinterpret_cast<const unsigned char*>(s.data());\n\n    // Loop through the string in SVE vector chunks\n    for (size_t i = 0; i < len; i += svcnt_u8()) {\n        // Get a predicate for the current chunk, handling partial vectors at the end\n        // This predicate ensures we only process valid characters within the string bounds.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, ptr + i);\n\n        // Initialize an all-false predicate mask for vowels\n        svbool_t is_vowel_mask = svbfalse_b8();\n\n        // Check for 'a' or 'A' and combine with the mask\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'a'));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'A'));\n\n        // Check for 'e' or 'E' and combine\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'e'));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'E'));\n\n        // Check for 'i' or 'I' and combine\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'i'));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'I'));\n\n        // Check for 'o' or 'O' and combine\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'o'));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'O'));\n\n        // Check for 'u' or 'U' and combine\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'u'));\n        is_vowel_mask = svorr_b(is_vowel_mask, svcmpeq_u8(pg, chars, 'U'));\n\n        // Count the number of active (true) predicates in the mask for the current chunk.\n        // svcntp_b only counts elements where both the predicate 'pg' and the 'is_vowel_mask' are true.\n        count += svcntp_b(pg, is_vowel_mask);\n    }\n\n    // Handle the special case for 'y' or 'Y' at the very end of the word.\n    // This check is done separately as 'y' is only a vowel in this specific position.\n    if (len > 0) {\n        char last_char = s[len - 1];\n        if (last_char == 'y' || last_char == 'Y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint64_t\n\nint digitSum_simd(std::string s) {\n    uint64_t total_sum = 0;\n    // Use reinterpret_cast to treat string data as unsigned 8-bit integers for SVE operations.\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Duplicate 'A' (ASCII 65) and 'Z' (ASCII 90) into SVE vectors once.\n    // These will be used for comparison.\n    svuint8_t char_A = svdup_u8('A');\n    svuint8_t char_Z = svdup_u8('Z');\n    // Duplicate 0 into an SVE vector. This will be used to zero out non-uppercase characters.\n    svuint8_t zero_u8 = svdup_u8(0);\n\n    // Loop through the string in chunks using SVE.\n    // svwhilelt_b8 generates a predicate 'pg' that is true for elements\n    // within the string bounds (i.e., less than 'len') starting from 'i'.\n    // The loop continues as long as there are active elements in the predicate (svcnth(pg) > 0).\n    // 'i' is advanced by the full vector length (svcntb()) in each iteration.\n    for (svbool_t pg = svwhilelt_b8(i, len); svcnth(pg) > 0; i += svcntb(), pg = svwhilelt_b8(i, len)) {\n        // Load characters from the string into an SVE vector.\n        // The 'pg' predicate ensures that only valid elements within string bounds are loaded;\n        // elements outside the bounds (in the tail chunk) are left undisturbed in the vector.\n        svuint8_t chars = svld1_u8(pg, data + i);\n\n        // Create predicates for checking if a character is uppercase ('A' <= char <= 'Z').\n        // The 'pg' predicate is passed to svcmpge_u8 and svcmple_u8 to ensure\n        // comparisons only apply to valid elements loaded from the string.\n        svbool_t pg_ge_A = svcmpge_u8(pg, chars, char_A);\n        svbool_t pg_le_Z = svcmple_u8(pg, chars, char_Z);\n        \n        // Combine the two predicates using logical AND to get a predicate for uppercase characters.\n        svbool_t pg_upper = svand_b(pg_ge_A, pg_le_Z);\n\n        // Select only uppercase characters. For elements where 'pg_upper' is false\n        // (either not an uppercase character or outside the string bounds),\n        // set the corresponding element in 'upper_chars_masked' to 0.\n        svuint8_t upper_chars_masked = svsel_u8(pg_upper, chars, zero_u8);\n\n        // Widen the 8-bit character values to 32-bit integers and sum them.\n        // SVE's svcvt_u32_u8 converts a quarter of the 8-bit vector elements\n        // into a new 32-bit vector. This process is repeated four times to cover the whole vector.\n        svuint32_t v32_0 = svcvt_u32_u8(upper_chars_masked, 0); // First quarter of elements\n        svuint32_t v32_1 = svcvt_u32_u8(upper_chars_masked, 1); // Second quarter\n        svuint32_t v32_2 = svcvt_u32_u8(upper_chars_masked, 2); // Third quarter\n        svuint32_t v32_3 = svcvt_u32_u8(upper_chars_masked, 3); // Fourth quarter\n\n        // Perform a horizontal sum for each of the four 32-bit vectors.\n        // svaddv_u32 sums all active elements within a svuint32_t vector into a scalar uint32_t.\n        // svptrue_b32() creates a predicate that is true for all elements in the 32-bit vector.\n        uint32_t sum0 = svaddv_u32(svptrue_b32(), v32_0);\n        uint32_t sum1 = svaddv_u32(svptrue_b32(), v32_1);\n        uint32_t sum2 = svaddv_u32(svptrue_b32(), v32_2);\n        uint32_t sum3 = svaddv_u32(svptrue_b32(), v32_3);\n\n        // Accumulate the sums from the four parts into the total sum.\n        total_sum += (uint64_t)sum0 + (uint64_t)sum1 + (uint64_t)sum2 + (uint64_t)sum3;\n    }\n\n    // The loop structure with svwhilelt_b8 and svsel_u8 implicitly handles\n    // the tail (remaining characters that don't form a full vector) by\n    // setting out-of-bounds elements to 0, so no separate scalar tail loop is needed.\n\n    // Cast the final sum to int as per the function signature.\n    // Note: For very long strings, the sum might exceed the maximum value of a 32-bit int.\n    return static_cast<int>(total_sum);\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t\n\nint digitSum_simd(std::string s) {\n    int total_sum = 0;\n    size_t n = s.length();\n    size_t i = 0;\n\n    // Loop through the string using SVE vector processing.\n    // The loop continues as long as 'i' is less than 'n'.\n    // svcntb() returns the number of bytes in an SVE vector, which for uint8_t\n    // directly corresponds to the number of elements (VL).\n    for (i = 0; i < n; i += svcntb()) {\n        // Generate a predicate for the current chunk of the string.\n        // svwhilelt_b8(i, n) creates a predicate that is true for elements\n        // from the current offset 'i' up to 'n-1'. This correctly handles\n        // both full vectors and the partial \"tail\" vector at the end of the string.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load a vector of characters from the string.\n        // Only active lanes (determined by 'pg') will be loaded.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data() + i);\n\n        // Create SVE vectors filled with the ASCII values of 'A' and 'Z'.\n        svuint8_t lower_bound = svdup_u8('A');\n        svuint8_t upper_bound = svdup_u8('Z');\n\n        // Compare characters to 'A' and 'Z' to identify uppercase letters.\n        // The predicate 'pg' ensures comparisons only happen for active lanes.\n        svbool_t is_ge_A = svcmpge_u8(pg, chars, lower_bound);\n        svbool_t is_le_Z = svcmple_u8(pg, chars, upper_bound);\n\n        // Combine the two masks to get a predicate that is true only for uppercase characters.\n        // This predicate will also be active only where 'pg' was active.\n        svbool_t is_uppercase = svand_b(is_ge_A, is_le_Z);\n\n        // Select the ASCII value of the character if it's an uppercase letter,\n        // otherwise select 0. This effectively filters out non-uppercase characters.\n        // The 'is_uppercase' predicate ensures only uppercase chars are selected.\n        // For inactive lanes (where 'pg' was false), the result of svsel_u8 is typically\n        // the 'else' value (0 in this case) or undefined, but since 'svaddv_u8'\n        // will use 'pg' as its predicate, those inactive lanes won't contribute anyway.\n        svuint8_t uppercase_values = svsel_u8(is_uppercase, chars, svdup_u8(0));\n\n        // Sum all active elements in the 'uppercase_values' vector.\n        // The 'pg' predicate ensures we sum only the elements that were actually loaded\n        // from the string and are part of the current chunk.\n        total_sum += svaddv_u8(pg, uppercase_values);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string> // Required for std::string\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n    int total_sum = 0;\n    const char* data = s.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Get the SVE vector length in bytes.\n    // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector.\n    size_t sv_len_bytes = svcntb();\n\n    // Loop through the string in chunks of sv_len_bytes.\n    // svwhilelt_b_u8 generates a predicate for elements where 'i + index < len'.\n    // This intrinsic automatically handles both full vectors and the tail (partial vector)\n    // by setting inactive lanes in the predicate to false.\n    svbool_t pg = svwhilelt_b_u8(i, len);\n\n    // The loop continues as long as there are any active elements in the predicate.\n    // svptest_any(svptrue_b8(), pg) checks if any lane in 'pg' is true.\n    // svptrue_b8() is a predicate where all 8-bit elements are true.\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters from the string into an SVE vector.\n        // Elements not covered by 'pg' (e.g., beyond the string length) are loaded as 0.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)data + i);\n\n        // Create vectors with the ASCII bounds for uppercase letters ('A' to 'Z').\n        // 'A' is ASCII 65, 'Z' is ASCII 90.\n        svuint8_t lower_bound = svdup_u8('A');\n        svuint8_t upper_bound = svdup_u8('Z');\n\n        // Generate masks for characters that are greater than or equal to 'A'\n        // and less than or equal to 'Z'. The predicate 'pg' ensures comparisons\n        // only happen for valid string characters.\n        svbool_t mask_ge_A = svcmpge_u8(pg, chars, lower_bound);\n        svbool_t mask_le_Z = svcmple_u8(pg, chars, upper_bound);\n\n        // Combine the two masks to get a final mask for uppercase characters.\n        svbool_t uppercase_mask = svand_b(mask_ge_A, mask_le_Z);\n\n        // Select only the uppercase characters. Non-uppercase characters (and those\n        // outside the string length due to 'pg' in svld1) are set to 0.\n        svuint8_t filtered_chars_u8 = svsel_u8(uppercase_mask, chars, svdup_u8(0));\n\n        // To sum the characters, we need to convert them to a wider type (e.g., uint16_t)\n        // to prevent overflow during horizontal summation, as the sum of multiple uint8_t\n        // values can exceed 255.\n        // An SVE svuint8_t vector holds svcntb() elements.\n        // An SVE svuint16_t vector holds svcntw() elements, where svcntw() = svcntb() / 2.\n        // To convert all svcntb() elements from uint8_t to uint16_t, we need two svuint16_t vectors.\n        // svuzp1_u8 and svuzp2_u8 can split a svuint8_t vector into two halves.\n        // When passed the same vector twice, svuzp1_u8 returns the lower half, and svuzp2_u8 returns the upper half.\n        svuint8_t filtered_chars_lo = svuzp1_u8(filtered_chars_u8, filtered_chars_u8); // Lower half of the 8-bit vector\n        svuint8_t filtered_chars_hi = svuzp2_u8(filtered_chars_u8, filtered_chars_u8); // Upper half of the 8-bit vector\n\n        // Convert the 8-bit halves to 16-bit vectors.\n        // Each svcvt_u16_u8 intrinsic converts svcntw() elements.\n        svuint16_t sum_vec_lo = svcvt_u16_u8(filtered_chars_lo);\n        svuint16_t sum_vec_hi = svcvt_u16_u8(filtered_chars_hi);\n\n        // Horizontally sum the elements within each 16-bit vector.\n        // svptrue_b16() is used as the predicate because all elements in sum_vec_lo/hi\n        // are either uppercase characters or 0s (from filtering/tail handling),\n        // so we want to sum all of them.\n        total_sum += svaddv_u16(svptrue_b16(), sum_vec_lo);\n        total_sum += svaddv_u16(svptrue_b16(), sum_vec_hi);\n\n        // Move the index to the next chunk of the string.\n        i += sv_len_bytes;\n        // Generate the predicate for the next chunk.\n        pg = svwhilelt_b_u8(i, len);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s) {\n    int total_sum = 0;\n    size_t len = s.length();\n    const char* data = s.data();\n\n    // Initialize SVE vector accumulators and constants\n    svuint32_t sum_acc_u32 = svdup_u32(0);\n    svuint8_t zero_u8 = svdup_u8(0);\n    svuint16_t zero_u16 = svdup_u16(0);\n\n    // ASCII values for 'A' and 'Z'\n    svuint8_t lower_bound_u8 = svdup_u8(65); // 'A'\n    svuint8_t upper_bound_u8 = svdup_u8(90); // 'Z'\n\n    // Loop through the string in chunks of svcntb() bytes\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk, handling partial vectors at the end\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an 8-bit SVE vector\n        svuint8_t chars = svld1_u8(pg, data + i);\n\n        // Check if characters are greater than or equal to 'A'\n        svbool_t is_ge_A = svcmpge(pg, chars, lower_bound_u8);\n        // Check if characters are less than or equal to 'Z'\n        svbool_t is_le_Z = svcmple(pg, chars, upper_bound_u8);\n\n        // Combine predicates to find uppercase characters ('A' <= char <= 'Z')\n        svbool_t is_uppercase = svand_b(is_ge_A, is_le_Z);\n\n        // Select only uppercase characters, setting others to 0\n        svuint8_t filtered_chars = svsel_u8(is_uppercase, chars, zero_u8);\n\n        // Widening add to zero-extend 8-bit values to 16-bit values\n        // svaddl_u16(op1_u8, op2_u8) computes (uint16_t)op1_u8[i] + (uint16_t)op2_u8[i]\n        // Using zero_u8 as op2 effectively zero-extends filtered_chars\n        svuint16_t widened_chars_u16 = svaddl_u16(filtered_chars, zero_u8);\n\n        // Widening add to zero-extend 16-bit values to 32-bit values\n        // svaddl_u32(op1_u16, op2_u16) computes (uint32_t)op1_u16[i] + (uint32_t)op2_u16[i]\n        // Using zero_u16 as op2 effectively zero-extends widened_chars_u16\n        svuint32_t widened_chars_u32 = svaddl_u32(widened_chars_u16, zero_u16);\n\n        // Accumulate the widened character values into the 32-bit sum accumulator\n        // svptrue_b32() creates a predicate for all 32-bit elements, ensuring all lanes are active\n        sum_acc_u32 = svadd_u32_m(svptrue_b32(), sum_acc_u32, widened_chars_u32);\n    }\n\n    // Perform a horizontal sum of all elements in the 32-bit accumulator vector\n    total_sum = svaddv_u32(svptrue_b32(), sum_acc_u32);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t, etc.\n\nint digitSum_simd(std::string s) {\n    int total_sum = 0;\n    const char* data = s.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Get the vector length in bytes (number of 8-bit elements)\n    size_t sv_len_b = svcntb();\n\n    // Loop through the string in chunks of sv_len_b (full vectors)\n    for (i = 0; i + sv_len_b <= len; i += sv_len_b) {\n        // Create a full predicate for the current vector length (all elements active)\n        svbool_t pg_full_b = svptrue_b8();\n\n        // Load a vector of characters (8-bit unsigned integers)\n        svuint8_t chars = svld1_u8(pg_full_b, (const uint8_t*)(data + i));\n\n        // Create predicates for 'A' <= char <= 'Z'\n        svbool_t is_ge_A = svcmpge_u8(pg_full_b, chars, 'A');\n        svbool_t is_le_Z = svcmple_u8(pg_full_b, chars, 'Z');\n\n        // Combine predicates: (char >= 'A') AND (char <= 'Z')\n        svbool_t is_uppercase = svand_b(is_ge_A, is_le_Z);\n\n        // Filter out non-uppercase characters by setting their values to 0.\n        // This ensures only uppercase characters contribute to the sum.\n        svuint8_t filtered_chars = svsel_u8(is_uppercase, chars, svdup_u8(0));\n\n        // Widen the 8-bit vector into two 16-bit vectors (lower and upper halves).\n        // This is necessary because the sum of 8-bit characters within a vector\n        // can exceed 255, which would overflow a uint8_t sum.\n        svuint16_t lower_half_w = svmovlb_u16_u8(filtered_chars);\n        svuint16_t upper_half_w = svmovlt_u16_u8(filtered_chars);\n\n        // Sum the elements of each 16-bit vector into scalar uint16_t values.\n        // Since `filtered_chars` already zeroed out irrelevant values, we can\n        // sum all elements of the widened vectors using a full 16-bit predicate.\n        svbool_t pg_full_w = svptrue_b16();\n        total_sum += svaddv_u16(pg_full_w, lower_half_w);\n        total_sum += svaddv_u16(pg_full_w, upper_half_w);\n    }\n\n    // Handle any remaining characters (tail processing)\n    // Use svwhilelt_b8 to generate a predicate for the remaining elements.\n    svbool_t pg_tail_b = svwhilelt_b8(i, len);\n\n    // Check if there are any remaining elements to process\n    if (svptest_any(svptrue_b8(), pg_tail_b)) {\n        // Load the tail vector using the tail predicate\n        svuint8_t chars_tail = svld1_u8(pg_tail_b, (const uint8_t*)(data + i));\n\n        // Create predicates for 'A' <= char <= 'Z' for the tail\n        svbool_t is_ge_A_tail = svcmpge_u8(pg_tail_b, chars_tail, 'A');\n        svbool_t is_le_Z_tail = svcmple_u8(pg_tail_b, chars_tail, 'Z');\n        svbool_t is_uppercase_tail = svand_b(is_ge_A_tail, is_le_Z_tail);\n\n        // Filter out non-uppercase characters and inactive elements from the tail\n        svuint8_t filtered_chars_tail = svsel_u8(is_uppercase_tail, chars_tail, svdup_u8(0));\n\n        // Widen the 8-bit tail vector into two 16-bit vectors\n        svuint16_t lower_half_w_tail = svmovlb_u16_u8(filtered_chars_tail);\n        svuint16_t upper_half_w_tail = svmovlt_u16_u8(filtered_chars_tail);\n\n        // Sum the elements of the widened tail vectors.\n        // As before, irrelevant elements are already zeroed out.\n        svbool_t pg_full_w = svptrue_b16();\n        total_sum += svaddv_u16(pg_full_w, lower_half_w_tail);\n        total_sum += svaddv_u16(pg_full_w, upper_half_w_tail);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <limits>   // For std::numeric_limits\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    // Handle empty input case as per problem description\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Initialize min_val to the maximum possible integer value and min_idx to -1.\n    // These will hold the smallest even value found and its corresponding index.\n    int32_t min_val = std::numeric_limits<int32_t>::max();\n    int32_t min_idx = -1;\n\n    // Duplicate INT_MAX into an SVE vector once. This vector will be used to\n    // \"mask out\" elements that do not meet the criteria (e.g., not even)\n    // by setting their value to INT_MAX, ensuring they are ignored by min operations.\n    svint32_t max_val_vec = svdup_n_s32(std::numeric_limits<int32_t>::max());\n\n    // Iterate through the input array in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector\n    // for the current vector length.\n    for (int i = 0; i < arr.size(); i += svcntw()) {\n        // Create a predicate for the active elements in the current chunk.\n        // svwhilelt_b32(start_index, end_limit) generates a predicate that is true\n        // for elements from start_index up to (but not including) end_limit.\n        // This correctly handles the tail end of the array where the number of\n        // remaining elements might be less than svcntw().\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n\n        // Load the current chunk of elements from the array into an SVE vector.\n        svint32_t current_elements = svld1(pg, &arr[i]);\n\n        // Generate global indices for the current chunk.\n        // svindex_s32(0, 1) generates a sequence {0, 1, 2, ..., svcntw()-1}.\n        // svadd_n_s32 adds the starting global index 'i' to each element,\n        // resulting in global indices for the current chunk (e.g., {i, i+1, ...}).\n        svint32_t current_indices = svadd_n_s32(svindex_s32(0, 1), i);\n\n        // Check for even numbers: value % 2 == 0 is equivalent to (value & 1) == 0\n        // for non-negative integers. svcmpeq_n_s32 compares each element with 0.\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_n_s32(current_elements, 1), 0);\n\n        // Filter out non-even numbers by replacing their values with INT_MAX.\n        // This ensures that only even numbers are considered when finding the minimum.\n        svint32_t filtered_elements = svsel_s32(is_even, current_elements, max_val_vec);\n        // Similarly, filter indices. Indices of non-even numbers are also set to INT_MAX.\n        svint32_t filtered_indices = svsel_s32(is_even, current_indices, max_val_vec);\n\n        // Find the minimum even value in the current chunk.\n        // svminv_s32 finds the minimum value among the active lanes of the vector\n        // (as determined by the predicate 'pg'). Since non-even numbers were set to INT_MAX,\n        // this will correctly find the minimum among the even numbers in the chunk.\n        int32_t chunk_min_val = svminv_s32(pg, filtered_elements);\n\n        // If a valid even number was found in this chunk (i.e., not INT_MAX)\n        if (chunk_min_val != std::numeric_limits<int32_t>::max()) {\n            // Case 1: The minimum even value found in this chunk is strictly smaller\n            // than the current global minimum even value.\n            if (chunk_min_val < min_val) {\n                min_val = chunk_min_val; // Update global minimum value.\n\n                // Find the first index of this new minimum value within the current chunk.\n                // Create a mask for elements that are equal to the new min_val AND were originally even.\n                svbool_t mask_for_min_val_indices = svcmpeq_n_s32(pg, filtered_elements, min_val);\n                // Select only the indices corresponding to the new min_val; others are set to INT_MAX.\n                svint32_t candidate_indices = svsel_s32(mask_for_min_val_indices, filtered_indices, max_val_vec);\n                // Find the minimum index among these candidates. Since indices are increasing,\n                // this will give the index of the first occurrence of `min_val` in the chunk.\n                min_idx = svminv_s32(pg, candidate_indices);\n            } \n            // Case 2: The minimum even value found in this chunk is equal to the\n            // current global minimum even value. We need to check if its index is smaller.\n            else if (chunk_min_val == min_val) {\n                // Create a mask for elements that are equal to the current min_val AND were originally even.\n                svbool_t mask_for_equal_val_indices = svcmpeq_n_s32(pg, filtered_elements, min_val);\n                // Select only the indices corresponding to the equal min_val; others are set to INT_MAX.\n                svint32_t candidate_indices = svsel_s32(mask_for_equal_val_indices, filtered_indices, max_val_vec);\n                // Find the minimum index among these candidates in the current chunk.\n                int32_t local_min_idx = svminv_s32(pg, candidate_indices);\n                \n                // If this local minimum index is smaller than the current global minimum index, update.\n                if (local_min_idx < min_idx) {\n                    min_idx = local_min_idx;\n                }\n            }\n        }\n    }\n\n    // After iterating through all chunks, if min_idx is still -1, it means no even numbers were found.\n    if (min_idx == -1) {\n        return {}; // Return an empty vector as per problem description.\n    } else {\n        // Otherwise, return the smallest even value and its first index.\n        return {min_val, min_idx};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    // Handle empty input array as per Example 3.\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Initialize overall minimum even value to the maximum possible integer value,\n    // and its index to -1 (indicating no even number found yet).\n    int overall_min_val = std::numeric_limits<int>::max();\n    int overall_min_idx = -1;\n\n    // Determine the number of 32-bit elements (int) that fit into an SVE vector.\n    // svcnt_s32() returns the SVE vector length for 32-bit integers.\n    const size_t VL = svcnt_s32();\n\n    // Iterate through the input array in chunks of SVE vector length.\n    for (size_t i = 0; i < arr.size(); i += VL) {\n        // Create a governing predicate for the current chunk.\n        // svwhilelt_b32(i, arr.size()) generates a predicate where lanes are true\n        // as long as the element index (starting from 'i') is less than arr.size().\n        // This correctly handles the tail end of the array where the number of elements\n        // might be less than VL.\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n\n        // Load current values from the array into an SVE vector.\n        // Only active lanes (determined by 'pg') will load valid data.\n        svint32_t current_values = svld1_s32(pg, &arr[i]);\n\n        // 1. Identify even numbers within the current chunk.\n        // A number 'x' is even if (x & 1) == 0.\n        // Perform bitwise AND with 1 to get the least significant bit of each element.\n        svint32_t mod_two = svand_n_s32(current_values, 1);\n        // Compare the result with 0 to get a predicate for even numbers.\n        // This predicate 'is_even_pg' is active only for lanes where 'pg' is true\n        // AND the corresponding value is even.\n        svbool_t is_even_pg = svcmpeq_n_s32(pg, mod_two, 0);\n\n        // 2. Prepare values for minimum reduction.\n        // For non-even numbers (where 'is_even_pg' is false), set their value to INT_MAX.\n        // This ensures that these values do not interfere with finding the true minimum\n        // among the even numbers when performing a horizontal minimum reduction.\n        svint32_t values_for_min_reduction = svsel_s32(is_even_pg, current_values, svdup_n_s32(std::numeric_limits<int>::max()));\n\n        // 3. Find the minimum even value within this current chunk.\n        // svminv_s32 performs a horizontal minimum reduction across the vector,\n        // considering only the lanes active under 'pg'.\n        int chunk_min_val = svminv_s32(pg, values_for_min_reduction);\n\n        // 4. If a valid even number was found in this chunk (i.e., chunk_min_val is not INT_MAX)\n        if (chunk_min_val != std::numeric_limits<int>::max()) {\n            // 5. Compare the chunk's minimum even value with the overall minimum found so far.\n            if (chunk_min_val < overall_min_val) {\n                // A new smaller even value is found. Update the overall minimum value.\n                overall_min_val = chunk_min_val;\n\n                // Find the first occurrence of this new minimum value within the current chunk.\n                // Create a predicate for lanes that contain 'overall_min_val' AND are even.\n                svbool_t is_target_val_pg = svcmpeq_n_s32(is_even_pg, current_values, overall_min_val);\n\n                // svfirst_s32 returns the index of the first active lane in 'is_target_val_pg'\n                // that is also active in the governing predicate 'pg'.\n                // This gives the offset of the first occurrence within the current chunk.\n                int first_idx_in_chunk_offset = svfirst_s32(pg, is_target_val_pg);\n\n                // Calculate the absolute index in the original array.\n                overall_min_idx = i + first_idx_in_chunk_offset;\n            }\n            // If chunk_min_val == overall_min_val, we do not update.\n            // This is because we are looking for the smallest index for a given value.\n            // Since we iterate linearly through the array, any subsequent occurrence\n            // of the same minimum value will necessarily have a larger index.\n        }\n    }\n\n    // After processing all chunks, check if an even number was found.\n    if (overall_min_idx != -1) {\n        // If an even number was found, return its value and its first index.\n        return {overall_min_val, overall_min_idx};\n    } else {\n        // If no even numbers were found in the entire array, return an empty vector.\n        return {};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits<int>::max()\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    // Initialize global minimums.\n    // min_even_value is set to the maximum possible integer value,\n    // so any valid even number will be smaller.\n    int min_even_value = std::numeric_limits<int>::max();\n    // min_even_index is initialized to -1 to indicate no even number has been found yet.\n    int min_even_index = -1;\n\n    // Get the number of 32-bit elements (ints) that fit into an SVE vector.\n    // This value (VL) is determined at runtime by the SVE hardware.\n    const size_t sv_vec_len = svcntw();\n\n    // Loop through the input array in chunks of `sv_vec_len`.\n    // `i` represents the starting index of the current chunk.\n    for (size_t i = 0; i < arr.size(); i += sv_vec_len) {\n        // Create a predicate for the current chunk.\n        // `svwhilelt_b32(i, arr.size())` generates a predicate that is true for elements\n        // from `i` up to `arr.size() - 1`, and false for elements beyond the array bounds.\n        // This handles the \"tail\" of the array where the remaining elements are fewer than `sv_vec_len`.\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n\n        // Load the current chunk of nodes into an SVE vector.\n        // Only elements where `pg` is true are loaded; others are undefined.\n        svint32_t current_nodes = svld1_s32(pg, &arr[i]);\n\n        // Generate a vector of indices for the current chunk: i, i+1, i+2, ...\n        // This is crucial for tracking the original position of each node.\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // Step 1: Identify even numbers.\n        // `svand_n_s32(current_nodes, 1)` performs a bitwise AND with 1 on each element.\n        // If the result is 0, the number is even.\n        // `svcmpeq_s32(pg, ..., 0)` compares the result with 0, generating a boolean predicate.\n        // The `pg` predicate ensures only active elements are considered for the comparison.\n        svbool_t is_even = svcmpeq_s32(pg, svand_n_s32(current_nodes, 1), 0);\n\n        // Step 2: Filter out non-even numbers and elements outside array bounds.\n        // `svsel_s32(false_value, true_value, predicate)` selects `true_value` where `predicate` is true,\n        // and `false_value` where `predicate` is false.\n        // We set non-even values (and elements outside `pg`) to `INT_MAX` so they don't affect\n        // subsequent minimum calculations.\n        svint32_t candidates_values = svsel_s32(sv_s32(std::numeric_limits<int>::max()), current_nodes, is_even);\n        svint32_t candidates_indices = svsel_s32(sv_s32(std::numeric_limits<int>::max()), current_indices, is_even);\n\n        // Step 3: Find the minimum value within the current vector of candidates.\n        // `svminv_s32(pg, vector)` performs a horizontal minimum reduction across the active elements\n        // (defined by `pg`) of the vector.\n        int local_min_val = svminv_s32(pg, candidates_values);\n\n        // If `local_min_val` is still `INT_MAX`, it means there were no valid even numbers\n        // in this chunk (or the chunk was entirely outside array bounds).\n        if (local_min_val != std::numeric_limits<int>::max()) {\n            // Step 4: Find all elements in the current vector that match this `local_min_val`.\n            // This predicate identifies all occurrences of the minimum even value within the chunk.\n            svbool_t is_local_min_val = svcmpeq_s32(pg, candidates_values, sv_s32(local_min_val));\n\n            // Step 5: From those matching elements, find the one with the smallest index.\n            // We filter the `candidates_indices` using `is_local_min_val` and then find the minimum index.\n            // This ensures that if multiple elements have the same `local_min_val`, we pick the one\n            // that appeared earliest in the original array.\n            svint32_t local_min_indices_for_val = svsel_s32(sv_s32(std::numeric_limits<int>::max()), candidates_indices, is_local_min_val);\n            int local_min_idx = svminv_s32(pg, local_min_indices_for_val);\n\n            // Step 6: Compare the best candidate from this chunk with the global minimum found so far.\n            if (local_min_val < min_even_value) {\n                // If a strictly smaller even value is found, update both value and index.\n                min_even_value = local_min_val;\n                min_even_index = local_min_idx;\n            } else if (local_min_val == min_even_value) {\n                // If an equal even value is found, update only if its index is smaller.\n                if (local_min_idx < min_even_index) {\n                    min_even_index = local_min_idx;\n                }\n            }\n        }\n    }\n\n    // After processing all chunks, return the result based on `min_even_index`.\n    if (min_even_index != -1) {\n        // If an even number was found, return its value and index.\n        return {min_even_value, min_even_index};\n    } else {\n        // If no even numbers were found or the input array was empty, return an empty vector.\n        return {};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>   // For std::numeric_limits\n#include <algorithm> // For std::min\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int global_min_val = std::numeric_limits<int>::max();\n    int global_min_idx = -1;\n\n    const int N = arr.size();\n    int i = 0;\n\n    // Loop through the array in chunks of SVE vector length (svcntw() 32-bit elements)\n    // svwhilelt_b32(i, N) generates a predicate for elements from i up to N-1,\n    // ensuring we only process valid elements within the array bounds.\n    for (; i < N; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N); // Predicate for the current vector chunk\n\n        // Load current values from the array into an SVE vector\n        svint32_t current_values = svld1_s32(pg, &arr[i]);\n\n        // Generate indices for the current chunk: i, i+1, i+2, ...\n        svint32_t current_indices = svadd_n_s32(svindex(0, 1), i);\n\n        // 1. Identify even numbers: val % 2 == 0.\n        // For non-negative integers, val & 1 == 0 is equivalent to val % 2 == 0.\n        svint32_t mod2_result = svand_n_s32(current_values, 1);\n        svbool_t is_even_mask = svcmpeq_n_s32(pg, mod2_result, 0);\n\n        // 2. Filter out non-even numbers by setting their values to INT_MAX.\n        // This ensures that non-even numbers will not be selected as the minimum.\n        svint32_t filtered_values = svsel_s32(is_even_mask, current_values, svdup_n_s32(std::numeric_limits<int>::max()));\n\n        // 3. Find the minimum value within the current vector chunk.\n        // svminv_s32 performs a horizontal minimum reduction across the vector lanes.\n        // The predicate 'pg' ensures only active lanes (within array bounds) are considered.\n        int chunk_min_val = svminv_s32(pg, filtered_values);\n\n        // If chunk_min_val is still INT_MAX, it means no even numbers were found in this chunk.\n        if (chunk_min_val == std::numeric_limits<int>::max()) {\n            continue; // Move to the next chunk\n        }\n\n        // 4. Find the index of the first occurrence of chunk_min_val within this chunk.\n        // Create a mask for elements that are equal to chunk_min_val.\n        // Since filtered_values already set non-even numbers to INT_MAX, chunk_min_val\n        // must be an even number if it's not INT_MAX.\n        svbool_t min_val_in_chunk_mask = svcmpeq_n_s32(pg, filtered_values, chunk_min_val);\n\n        // Find the minimum index among those elements that match chunk_min_val.\n        // svminv_s32 on indices with the specific mask will return the smallest index\n        // corresponding to the chunk_min_val. If min_val_in_chunk_mask is all false,\n        // svminv_s32 returns INT_MAX (which won't happen here if chunk_min_val is not INT_MAX).\n        int chunk_min_idx = svminv_s32(min_val_in_chunk_mask, current_indices);\n\n        // 5. Update the global minimum value and its index.\n        if (chunk_min_val < global_min_val) {\n            global_min_val = chunk_min_val;\n            global_min_idx = chunk_min_idx;\n        } else if (chunk_min_val == global_min_val) {\n            // If the current chunk's minimum even value is equal to the global minimum,\n            // we need to choose the one with the smaller index.\n            // Since we process chunks from left to right, the earlier chunk's index\n            // will naturally be smaller or equal.\n            global_min_idx = std::min(global_min_idx, chunk_min_idx);\n        }\n    }\n\n    // After iterating through all chunks, check if an even number was found.\n    if (global_min_idx != -1) {\n        return {global_min_val, global_min_idx};\n    } else {\n        return {}; // No even numbers found or array was empty\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits<int>::max()\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    // If the input vector is empty, return an empty vector as per requirements.\n    if (arr.empty()) {\n        return {};\n    }\n\n    // Initialize the global minimum even value to the maximum possible integer value.\n    // This ensures that the first valid even number found will be smaller.\n    int32_t current_min_val = std::numeric_limits<int>::max();\n    // Initialize the index of the global minimum even value to -1, indicating not found yet.\n    int32_t current_min_idx = -1;\n\n    // Get the SVE vector length for 32-bit integers.\n    // This determines how many elements are processed in parallel in each iteration.\n    const size_t vl = svcntw();\n\n    // Loop through the input array in chunks of 'vl' elements.\n    for (size_t i = 0; i < arr.size(); i += vl) {\n        // Create a predicate 'pg' for the current chunk.\n        // This predicate ensures that we only process elements within the array bounds\n        // for the current chunk, handling the tail end of the array.\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n\n        // Load a vector of integers from the array starting at index 'i',\n        // using 'pg' to only load active elements.\n        svint32_t vec = svld1(pg, &arr[i]);\n\n        // Prepare a vector of ones for bitwise AND operation to check for odd/even numbers.\n        svint32_t one = svdup_n_s32(1);\n        // Determine if elements are odd: (value & 1) == 1.\n        svbool_t is_odd = svcmpeq(pg, svand(vec, one), one);\n        // Determine if elements are even: NOT is_odd.\n        svbool_t is_even = svnot_b(pg, is_odd);\n\n        // Create a temporary vector initialized with INT_MAX.\n        // This vector will hold only the even numbers from 'vec', with non-even numbers\n        // being replaced by INT_MAX so they don't interfere with the minimum search.\n        svint32_t temp_values = svdup_n_s32(std::numeric_limits<int>::max());\n        // Select even numbers from 'vec' based on the 'is_even' predicate.\n        temp_values = svsel(is_even, vec, temp_values);\n\n        // Find the minimum value among the selected even numbers in the current chunk.\n        // If no even numbers are present in the active elements of the chunk,\n        // 'local_min_val' will remain INT_MAX.\n        int32_t local_min_val = svminv_s32(pg, temp_values);\n\n        // If 'local_min_val' is still INT_MAX, it means no even numbers were found\n        // in the active elements of this chunk. Continue to the next chunk.\n        if (local_min_val == std::numeric_limits<int>::max()) {\n            continue;\n        }\n\n        // Update global minimums:\n        // If the local minimum even value found in this chunk is strictly smaller\n        // than the current global minimum even value found so far.\n        // This also handles the very first time an even number is found, as\n        // 'current_min_val' starts at INT_MAX.\n        if (local_min_val < current_min_val) {\n            current_min_val = local_min_val;\n\n            // Now, find the index of this new 'current_min_val' within the current chunk.\n            // Create a predicate for elements in 'vec' that are equal to the new 'current_min_val'.\n            svbool_t local_min_val_match = svcmpeq(pg, vec, svdup_n_s32(current_min_val));\n            // Combine predicates: must be even AND match the new minimum value.\n            svbool_t final_match_predicate = svand_b(pg, is_even, local_min_val_match);\n\n            // Generate a vector of absolute indices for the current chunk: {i, i+1, i+2, ...}\n            svint32_t indices = svindex_s32(i, 1);\n            // Select indices where the 'final_match_predicate' is true.\n            // Non-matching indices will be replaced by INT_MAX.\n            svint32_t temp_indices = svdup_n_s32(std::numeric_limits<int>::max());\n            temp_indices = svsel(final_match_predicate, indices, temp_indices);\n            \n            // Find the minimum index among the selected indices.\n            // This will be the first occurrence of 'current_min_val' in the current chunk.\n            current_min_idx = svminv_s32(pg, temp_indices);\n        }\n        // If 'local_min_val' is equal to 'current_min_val', we do not update 'current_min_idx'.\n        // This is because we are iterating through the array from left to right (increasing indices).\n        // Therefore, any new occurrence of the same minimum value in a later chunk (or later in the current chunk)\n        // will necessarily have a larger index than the one already stored in 'current_min_idx'.\n        // The problem requires returning the node with the smallest index.\n    }\n\n    // After iterating through all chunks, check if an even number was found.\n    if (current_min_idx != -1) {\n        // If an even number was found, return its value and its first index.\n        return {current_min_val, current_min_idx};\n    } else {\n        // If no even numbers were found in the entire array, return an empty vector.\n        return {};\n    }\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\nint search_simd(std::vector<int> lst) {\n    // The problem states \"non-empty vector\".\n    // The maximum possible value for 'x' that could satisfy the condition\n    // (frequency >= x) is the size of the list itself.\n    // If x > lst.size(), then its frequency can be at most lst.size(),\n    // meaning frequency < x will always be true.\n    const int N = lst.size();\n\n    // Iterate 'x' from N down to 1 to find the greatest such integer.\n    // This ensures that the first 'x' found satisfying the condition is the greatest.\n    for (int x = N; x >= 1; --x) {\n        int current_freq = 0;\n        \n        // Get the number of 32-bit elements that fit into an SVE vector.\n        const int sv_vec_len = svcntw(); \n\n        // Process the input list in chunks of 'sv_vec_len' elements using SVE intrinsics.\n        for (size_t i = 0; i < N; i += sv_vec_len) {\n            // Create a predicate for the current chunk.\n            // svwhilelt_b32 ensures that we only process valid elements,\n            // handling the tail end of the vector where (N - i) < sv_vec_len.\n            svbool_t pg = svwhilelt_b32(i, N);\n\n            // Load a vector of 32-bit integers from 'lst' using the predicate.\n            svint32_t vec_data = svld1_s32(pg, &lst[i]);\n\n            // Duplicate the scalar value 'x' into all lanes of an SVE vector.\n            svint32_t vec_x = svdup_s32(x);\n\n            // Compare each active element in 'vec_data' with 'vec_x'.\n            // This creates a boolean mask where 'true' indicates a match.\n            svbool_t cmp_mask = svcmpeq_s32(pg, vec_data, vec_x);\n\n            // Count the number of 'true' elements in the comparison mask that are also active\n            // according to the predicate 'pg'. This gives the count of 'x' in the current chunk.\n            current_freq += svcntp_b32(pg, cmp_mask);\n        }\n\n        // Check if the condition (frequency >= x) is met for the current 'x'.\n        if (current_freq >= x) {\n            return x; // Found the greatest such integer, so return it.\n        }\n    }\n\n    // If the loop completes without finding any integer that satisfies the condition,\n    // return -1 as per the problem statement.\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    int n = lst.size();\n\n    int max_val = 0;\n    svint32_t sv_max_val_acc = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t sv_data = svld1(pg, &lst[i]);\n        sv_max_val_acc = svmax(pg, sv_max_val_acc, sv_data);\n    }\n    max_val = svmax_s32(sv_max_val_acc);\n\n    for (int x = max_val; x >= 1; --x) {\n        int current_freq = 0;\n        svint32_t sv_target_val = svdup_n_s32(x);\n\n        for (int i = 0; i < n; i += svcntw()) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svint32_t sv_data = svld1(pg, &lst[i]);\n            svbool_t cmp_eq = svcmpeq(pg, sv_data, sv_target_val);\n            current_freq += svcntp_b32(pg, cmp_eq);\n        }\n\n        if (current_freq >= x) {\n            return x;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm> // Not strictly needed if using SVE for max, but good practice for std::vector\n\n/*\nYou are given a non-empty vector of positive integers. Return the greatest integer that is greater than \nzero, and has a frequency greater than or equal to the value of the integer itself. \nThe frequency of an integer is the number of times it appears in the vector.\nIf no such a value exist, return -1.\nExamples:\n    search_simd({4, 1, 2, 2, 3, 1}) == 2\n    search_simd({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search_simd({5, 5, 4, 4, 4}) == -1\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint search_simd(std::vector<int> lst){\n    // Step 1: Find the maximum value in the list using SVE.\n    // This is necessary to size the frequency array.\n    // The problem states \"non-empty vector\" and \"positive integers\",\n    // so max_val will be at least 1.\n    int max_val = 0;\n    \n    // Initialize an SVE vector with 0s. This will accumulate the maximum values from chunks.\n    svint32_t current_max_vec = svdup_s32(0); \n\n    // Iterate through the list in chunks of svcntw() (SVE vector length for 32-bit integers).\n    size_t i = 0;\n    svbool_t pg; // Predicate register for SVE operations\n\n    // Process full SVE vector chunks\n    // Loop while there are enough elements for a full SVE vector load\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        pg = svptrue_b32(); // Create a full predicate (all lanes active)\n        svint32_t current_vec = svld1_s32(pg, &lst[i]); // Load a vector of elements\n        current_max_vec = svmax_s32(current_max_vec, current_vec); // Update the running maximum vector\n    }\n\n    // Process any remaining tail elements (if the list size is not a multiple of svcntw())\n    if (i < lst.size()) {\n        // Create a predicate for the tail, activating only the valid lanes\n        pg = svwhilelt_b32(i, lst.size()); \n        svint32_t current_vec = svld1_s32(pg, &lst[i]); // Load tail elements\n        current_max_vec = svmax_s32(current_max_vec, current_vec); // Update the running maximum vector\n    }\n\n    // Reduce the final maximum vector to a scalar value.\n    // svptrue_b32() ensures all active lanes in current_max_vec are considered for the reduction.\n    // The initial scalar '0' is safe as all numbers in the input list are positive.\n    max_val = svmax_s32_x(svptrue_b32(), 0, current_max_vec);\n\n    // Step 2: Count frequencies of each number.\n    // SVE does not provide direct atomic scatter-add intrinsics for general-purpose histograms.\n    // Therefore, this part is typically implemented serially for correctness and efficiency\n    // on a single CPU thread, especially for arbitrary integer values.\n    // The size of the counts array depends on max_val.\n    // counts[0] will be unused, counts[x] will store the frequency of integer x.\n    std::vector<int> counts(max_val + 1, 0); \n\n    for (int x : lst) {\n        // The problem states \"positive integers\", so x > 0.\n        // max_val was determined from lst, so x <= max_val.\n        // Thus, x is guaranteed to be a valid index for the `counts` vector.\n        counts[x]++;\n    }\n\n    // Step 3: Iterate from max_val down to 1 and check the condition.\n    // This search is inherently serial because we need to find the *greatest* integer\n    // that satisfies the condition, requiring a specific order of checking.\n    for (int i = max_val; i >= 1; --i) {\n        if (counts[i] >= i) {\n            return i; // Found the greatest integer satisfying the condition\n        }\n    }\n\n    // If no such value is found after checking all positive integers down to 1, return -1.\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Not strictly needed for the final SVE reduction, but good practice for vector operations\n\nint search_simd(std::vector<int> lst){\n    // Step 1: Find the maximum value in the list.\n    // This helps size the histogram. The problem states \"non-empty vector of positive integers\",\n    // so max_val will be at least 1.\n    int max_val = 0;\n    if (!lst.empty()) { // This condition should always be true based on problem description\n        // Initialize current_max_vec with 0. Since all elements are positive, this is safe.\n        svint32_t current_max_vec = svdup_s32(0);\n        \n        // Iterate through the input list in SVE vector chunks.\n        for (size_t i = 0; i < lst.size(); i += svcntw()) {\n            // Create a predicate to handle the tail end of the vector.\n            svbool_t pg = svwhilelt_b32(i, lst.size());\n            \n            // Load a vector of data from the list.\n            svint32_t data_vec = svld1_s32(pg, &lst[i]);\n            \n            // Update the maximum value found so far.\n            current_max_vec = svmax_s32(pg, current_max_vec, data_vec);\n        }\n        // Reduce the SVE vector to a single scalar maximum value.\n        max_val = svmax_s32_reduce_s32(svptrue_b32(), current_max_vec);\n    }\n\n    // Step 2: Create and populate the histogram (frequency counts).\n    // SVE does not directly provide a scatter-add intrinsic for general histogramming\n    // that would be efficient for arbitrary indices without complex workarounds (e.g., atomics,\n    // per-lane histograms followed by reduction).\n    // For simplicity and robustness across arbitrary integer ranges, a scalar loop is used here\n    // to populate the histogram. This is a common pragmatic choice when the core SIMD operations\n    // don't directly map to the data aggregation pattern.\n    // The `std::vector` is used as a histogram, indexed by the integer value.\n    std::vector<int> counts(max_val + 1, 0);\n    for (int x : lst) {\n        // Ensure x is within bounds and positive (problem states positive integers).\n        // The check `x <= max_val` is implicitly handled by `counts` size.\n        if (x > 0) { // Only count positive integers\n            counts[x]++;\n        }\n    }\n\n    // Step 3: Search for the greatest integer satisfying the condition using SVE.\n    // Iterate downwards from `max_val` to 1. The first value found that satisfies\n    // the condition `counts[x] >= x` will be the greatest.\n    int result = -1;\n    \n    // Get the SVE vector length for 32-bit integers.\n    const int VL = svcntw();\n\n    // Loop from max_val down to 1, processing VL elements at a time.\n    for (int i_start = max_val; i_start >= 1; i_start -= VL) {\n        // Create a predicate for the current chunk of values.\n        // This predicate ensures we only process values that are >= 1.\n        svbool_t pg = svwhilege_b32(i_start, 1);\n        \n        // Generate a vector of decreasing values: [i_start, i_start-1, i_start-2, ...]\n        svint32_t values_vec = svindex_s32(i_start, -1);\n\n        // Gather the counts for these values from the histogram.\n        // `counts.data()` is the base address, `values_vec` provides the indices.\n        svint32_t counts_vec = svld1_gather_s32index(pg, counts.data(), values_vec);\n\n        // Compare `counts_vec` with `values_vec` to check the condition: `counts[x] >= x`.\n        svbool_t condition_met_pg = svcmpge_s32(pg, counts_vec, values_vec);\n\n        // Select the values that meet the condition. Set non-matching values to 0.\n        // This allows us to find the maximum among the valid candidates.\n        svint32_t candidates_vec = svsel_s32(condition_met_pg, values_vec, svdup_s32(0));\n\n        // Find the maximum value among the candidates in the current vector.\n        // If no candidates met the condition, this will be 0.\n        int current_max_candidate = svmax_s32_reduce_s32(svptrue_b32(), candidates_vec);\n\n        // If a valid candidate (greater than 0) is found, it is the greatest\n        // because we are iterating `i_start` downwards.\n        if (current_max_candidate > 0) {\n            result = current_max_candidate;\n            break; // Found the greatest, so exit the loop.\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // For std::iota, not used here\n#include <algorithm> // For std::max_element, not used here\n\nint search_simd(std::vector<int> lst) {\n    // The problem states \"non-empty vector of positive integers\",\n    // so lst will not be empty and all elements will be > 0.\n\n    // Step 1: Determine the maximum value present in the list.\n    // This is necessary to size the frequency array.\n    // This part is performed serially. While SVE can be used for reduction (finding max),\n    // for this single value, a scalar loop is often simpler and sufficiently fast.\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) {\n            max_val = x;\n        }\n    }\n\n    // Step 2: Count frequencies of each positive integer using SVE intrinsics.\n    // A frequency array (histogram) is used. Its size depends on the maximum value.\n    // Note: If 'max_val' can be extremely large (e.g., close to INT_MAX),\n    // allocating 'std::vector<int> counts_array(max_val + 1, 0);' might lead to\n    // excessive memory usage or allocation failure. This solution assumes 'max_val'\n    // is within practical limits for array allocation (e.g., up to a few millions).\n    std::vector<int> counts_array(max_val + 1, 0);\n\n    const int N = lst.size();\n    const int* data = lst.data(); // Get a raw pointer for SVE loads\n\n    // This loop iterates through each possible integer value from 1 up to 'max_val'.\n    // For each 'val', it counts its occurrences in the input list 'lst' using SVE.\n    // The complexity of this frequency counting phase is approximately O(max_val * N / VL),\n    // where VL is the SVE vector length (svcntw()).\n    for (int val = 1; val <= max_val; ++val) {\n        int current_val_count = 0;\n        // Process the input list 'lst' in chunks of SVE vector length.\n        for (int i = 0; i < N; i += svcntw()) {\n            // Create a predicate 'pg' for active lanes. This handles the end of the array,\n            // ensuring that only valid elements are processed in the last chunk.\n            svbool_t pg = svwhilelt_b32(i, N);\n\n            // Load a vector of 32-bit integers from the input list 'data' using 'pg'.\n            svint32_t vec = svld1_s32(pg, data + i);\n\n            // Compare each element in the loaded vector 'vec' with the current 'val'.\n            // This generates a new predicate 'eq_val_pred' where lanes are true if\n            // the corresponding element in 'vec' is equal to 'val'.\n            svbool_t eq_val_pred = svcmpeq_s32(pg, vec, val);\n\n            // Count the number of true lanes in 'eq_val_pred'. This gives the count\n            // of 'val' within the current SVE vector chunk.\n            current_val_count += svcntp_b32(pg, eq_val_pred);\n        }\n        // Store the total count for 'val' in the frequency array.\n        counts_array[val] = current_val_count;\n    }\n\n    // Step 3: Search for the greatest integer satisfying the condition.\n    // We iterate downwards from 'max_val' to 1. The first integer 'i' found\n    // that satisfies the condition (counts_array[i] >= i) is the greatest one.\n    // This search phase is performed serially.\n    int result = -1;\n    for (int i = max_val; i >= 1; --i) {\n        // Check if the frequency of 'i' is greater than or equal to 'i' itself.\n        if (counts_array[i] >= i) {\n            result = i;\n            break; // Found the greatest such integer, so we can stop searching.\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed for SVE implementation, but good practice for std::vector\n\nextern \"C\" bool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n\n    // The problem states \"non-empty object q\". So n >= 1.\n    // If n == 1, it's always palindromic. Sum is q[0].\n\n    // 1. Palindrome check\n    bool is_palindromic = true;\n    if (n > 1) { // Single element vector is always palindromic\n        size_t i = 0;\n        size_t sv_len = svcntw(); // Number of 32-bit elements in an SVE vector\n\n        while (i < n / 2) {\n            // Predicate for the left chunk: active for elements from 'i' up to 'n/2 - 1'\n            svbool_t pg = svwhilelt_b32(i, n / 2);\n            \n            // Check if any lanes are active in the current predicate\n            if (!svptest_any_b32(svptrue_b32(), pg)) {\n                break; // No more elements to process for palindrome check\n            }\n\n            // Load the left chunk of elements\n            svint32_t left_chunk = svld1_s32(pg, &q[i]);\n            \n            // Generate indices for the corresponding right chunk elements.\n            // For q[i], the corresponding element is q[n-1-i].\n            // For q[i+1], it's q[n-1-(i+1)], and so on.\n            // svindex_s32(start, step) generates a vector {start, start+step, start+2*step, ...}\n            // We need {n-1-i, n-1-i-1, n-1-i-2, ...}\n            svint32_t right_indices = svindex_s32(n - 1 - i, -1);\n            \n            // Load the right chunk using gather load with the generated indices.\n            // q.data() returns a pointer to the first element of the vector.\n            // The predicate 'pg' ensures that only valid indices (within the active lanes) are accessed.\n            svint32_t right_chunk = svld1_gather_s32offset(pg, q.data(), right_indices);\n\n            // Compare the left and right chunks.\n            svbool_t cmp_result = svcmpeq_s32(pg, left_chunk, right_chunk);\n            \n            // Count the number of active lanes in the predicate 'pg'.\n            size_t num_active_lanes = svcntp_b32(svptrue_b32(), pg);\n            \n            // Check if all active lanes in 'cmp_result' are true.\n            // svptest_n_b32(pg, cmp_result) returns the number of active lanes in 'pg'\n            // for which the corresponding lane in 'cmp_result' is true.\n            if (svptest_n_b32(pg, cmp_result) != num_active_lanes) {\n                is_palindromic = false;\n                break;\n            }\n            \n            // Advance the index by the full SVE vector length\n            i += sv_len;\n        }\n    }\n\n    if (!is_palindromic) {\n        return false;\n    }\n\n    // 2. Calculate sum of elements\n    long long total_sum = 0;\n    // Initialize a 64-bit SVE vector accumulator with zeros.\n    svint64_t vec_sum_acc = svdup_s64(0); \n\n    size_t i = 0;\n    size_t sv_len_w = svcntw(); // Number of 32-bit elements per vector\n\n    while (i < n) {\n        // Predicate for loading 32-bit elements: active for elements from 'i' up to 'n-1'\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Check if any lanes are active in the current predicate\n        if (!svptest_any_b32(svptrue_b32(), pg)) {\n            break; // No more elements to process for sum\n        }\n\n        // Load a chunk of 32-bit integers\n        svint32_t data_vec_32 = svld1_s32(pg, &q[i]);\n        \n        // Convert 32-bit integers to 64-bit integers.\n        // Inactive lanes (as per 'pg') in data_vec_32 will be converted to 0 in data_vec_64.\n        svint64_t data_vec_64 = svcvt_s64_s32(data_vec_32);\n        \n        // Add the 64-bit chunk to the accumulator.\n        // We use svptrue_b64() as the predicate for the add, because svcvt_s64_s32\n        // already zeroed out the inactive lanes, so adding zeros is harmless.\n        vec_sum_acc = svadd_s64_m(svptrue_b64(), vec_sum_acc, data_vec_64);\n        \n        // Advance the index by the full 32-bit SVE vector length\n        i += sv_len_w;\n    }\n    \n    // Perform a horizontal sum of the accumulator vector to get the final total sum.\n    // svptrue_b64() creates a predicate where all 64-bit lanes are active.\n    total_sum = svaddv_s64(svptrue_b64(), vec_sum_acc);\n\n    // 3. Compare sum with maximum allowed weight 'w'\n    return total_sum <= (long long)w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed for SVE sum, but good for context\n#include <algorithm> // For std::min, though not explicitly used in final SVE loops\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    long n = q.size();\n\n    // Condition 1: Check if q is balanced (palindromic)\n    bool is_palindrome = true;\n    if (n > 1) { // A single-element vector (n=1) is always a palindrome. Non-empty is guaranteed by problem statement.\n        long vl = svcntw(); // Get vector length in elements (e.g., 4 for 32-bit ints on a 128-bit vector)\n        long limit = n / 2; // Number of pairs to compare (e.g., for n=5, limit=2; for n=4, limit=2)\n\n        // SVE loop for the main part of the vector.\n        // This loop processes blocks of `vl` elements from the left and `vl` elements from the right.\n        // To use `svrev_s32` correctly, we must load full SVE vectors (all `vl` lanes active).\n        // The loop condition `i + vl <= limit` ensures that the left block of `vl` elements\n        // is entirely within the first half of the vector `q`.\n        // The corresponding right block starts at `n - vl - i`. This ensures it's also a full `vl` block\n        // and does not overlap with the left block (or overlaps only at the exact center for even `n` and `vl` covering the whole half).\n        long i = 0;\n        for (; i + vl <= limit; i += vl) {\n            // Load `vl` elements from the left side of the vector `q`.\n            // `svptrue_b32()` is used as the predicate to ensure all `vl` lanes are active for the load.\n            svint32_t vec_left = svld1_s32(svptrue_b32(), &q[i]);\n\n            // Load `vl` elements from the right side of the vector `q`.\n            // The starting address `&q[n - vl - i]` corresponds to the block that, when reversed,\n            // should match `vec_left`.\n            svint32_t vec_right_raw = svld1_s32(svptrue_b32(), &q[n - vl - i]);\n\n            // Reverse the elements within `vec_right_raw`.\n            // `svrev_s32` operates on all lanes of the vector.\n            svint32_t vec_right = svrev_s32(vec_right_raw);\n\n            // Compare the `vec_left` with the `vec_right`.\n            // `svptrue_b32()` is used as the predicate because we are comparing full `vl` vectors.\n            svbool_t cmp_result = svcmpeq_s32(svptrue_b32(), vec_left, vec_right);\n\n            // Check if all elements in the compared `vl` lanes matched.\n            // If `svptest_all` returns false, it means at least one pair did not match, so it's not a palindrome.\n            if (!svptest_all(svptrue_b32(), cmp_result)) {\n                is_palindrome = false;\n                break;\n            }\n        }\n\n        // Handle any remaining elements (tail processing for palindrome check) using a scalar loop.\n        // This loop covers elements that were not processed by the SVE loop, typically when `n/2`\n        // is not a multiple of `vl`, or when `n` is too small for the SVE loop to execute.\n        // `i` now points to the first element in the left half that was not processed by the SVE loop.\n        if (is_palindrome) { // Only proceed with scalar check if SVE checks passed so far\n            for (long j = i; j < limit; ++j) {\n                if (q[j] != q[n - 1 - j]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    // If the vector is not a palindrome, it cannot fly.\n    if (!is_palindrome) {\n        return false;\n    }\n\n    // Condition 2: Calculate the sum of elements in q and compare with w.\n    // Use `long long` for `total_sum` to prevent potential integer overflow,\n    // as the sum of `int` elements can exceed the maximum value of an `int`.\n    long long total_sum = 0;\n    long vl = svcntw(); // Get vector length again (or reuse from above)\n\n    // Initialize an SVE vector for accumulating the sum with zeros.\n    svint32_t vec_sum_sve = svdup_s32(0);\n\n    // Loop through the vector `q`, loading elements into SVE vectors and accumulating the sum.\n    for (long i = 0; i < n; i += vl) {\n        // Create a predicate for active lanes. This handles the \"tail\" of the vector `q`\n        // if its size `n` is not a multiple of `vl`.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load elements from `q` into an SVE vector using the predicate.\n        // Only active lanes (defined by `pg`) will be loaded.\n        svint32_t vec_q = svld1_s32(pg, &q[i]);\n\n        // Add the loaded vector `vec_q` to the accumulating sum vector `vec_sum_sve`.\n        // The addition is performed only for active lanes.\n        vec_sum_sve = svadd_s32(pg, vec_sum_sve, vec_q);\n    }\n\n    // Reduce the SVE sum vector `vec_sum_sve` to a scalar `total_sum`.\n    // `svaddv_s32` sums all elements in the vector. `svptrue_b32()` ensures all lanes are considered for reduction.\n    total_sum = svaddv_s32(svptrue_b32(), vec_sum_sve);\n\n    // Return true if the total sum is less than or equal to the maximum allowed weight `w`.\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n\n    if (n == 0) {\n        return false;\n    }\n\n    // Palindrome Check\n    bool is_palindrome = true;\n    size_t i = 0;\n    size_t vl_s32 = svcnt_s32();\n\n    while (i < n / 2) {\n        svbool_t pg = svwhilelt_b32(i, n / 2);\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        svint32_t vec_front = svld1_s32(pg, &q[i]);\n        svint32_t vec_back_raw = svld1_s32(pg, &q[n - 1 - i - (vl_s32 - 1)]);\n        svint32_t vec_back_reversed = svrev_s32(vec_back_raw);\n\n        svbool_t cmp_result = svcmpeq_s32(pg, vec_front, vec_back_reversed);\n\n        if (!svptest_all(pg, cmp_result)) {\n            is_palindrome = false;\n            break;\n        }\n        i += vl_s32;\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    // Sum Calculation\n    long long total_sum = 0;\n    i = 0;\n    size_t vl_s64 = svcnt_s64();\n\n    svint64_t vec_sum_acc_s64 = svdup_s64(0);\n\n    while (i < n) {\n        svbool_t pg_s64 = svwhilelt_b64(i, n);\n        if (!svptest_any(svptrue_b64(), pg_s64)) {\n            break;\n        }\n\n        svint32_t data_vec_s32_part = svld1_s32(pg_s64, &q[i]);\n        svint64_t data_vec_s64 = svcvt_s64_s32(data_vec_s32_part);\n        vec_sum_acc_s64 = svadd_s64(pg_s64, vec_sum_acc_s64, data_vec_s64);\n\n        i += vl_s64;\n    }\n\n    total_sum = svaddv_s64(svptrue_b64(), vec_sum_acc_s64);\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n\n    if (n == 0) {\n        return false;\n    }\n\n    // Palindrome check\n    bool is_palindrome = true;\n    size_t i_pal = 0;\n    size_t j_pal = n - 1;\n    size_t sv_len = svcntw();\n\n    // Process full SVE vector pairs from both ends\n    // This loop continues as long as there are at least two full SVE vectors' worth of elements remaining\n    // between i_pal and j_pal (inclusive).\n    while (j_pal - i_pal + 1 >= 2 * sv_len) {\n        svbool_t pg_full = svptrue_b32(); // Full predicate for svcntw() elements\n\n        // Load elements from the left side\n        svint32_t vec_left = svld1_s32(pg_full, &q[i_pal]);\n\n        // Load elements from the right side, then reverse the vector\n        // The elements to load are q[j_pal], q[j_pal-1], ..., q[j_pal - sv_len + 1].\n        // These are contiguous in memory starting from q[j_pal - sv_len + 1].\n        svint32_t vec_right_raw = svld1_s32(pg_full, &q[j_pal - sv_len + 1]);\n        svint32_t vec_right_reversed = svrev_s32(vec_right_raw); // Reverse to match order of vec_left\n\n        // Compare the two vectors element-wise\n        svbool_t cmp_result = svcmpeq_s32(pg_full, vec_left, vec_right_reversed);\n\n        // If any element in the active part does not match, it's not a palindrome\n        if (!svptest_all(pg_full, cmp_result)) {\n            is_palindrome = false;\n            break;\n        }\n\n        // Advance indices for the next iteration\n        i_pal += sv_len;\n        j_pal -= sv_len;\n    }\n\n    // Handle any remaining elements sequentially (if no mismatch found yet)\n    if (is_palindrome) {\n        while (i_pal < j_pal) {\n            if (q[i_pal] != q[j_pal]) {\n                is_palindrome = false;\n                break;\n            }\n            i_pal++;\n            j_pal--;\n        }\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    // Summation of elements using SVE\n    long long total_sum = 0; // Use long long to prevent overflow for sum\n    size_t i_sum = 0;\n    svint32_t vec_sum_acc = svdup_s32(0); // Initialize SVE accumulator vector with zeros\n\n    while (i_sum < n) {\n        svbool_t pg = svwhilelt_b32(i_sum, n); // Predicate for current chunk, handles tail elements\n        svint32_t vec_data = svld1_s32(pg, &q[i_sum]); // Load data using the predicate\n\n        vec_sum_acc = svadd_s32_x(pg, vec_sum_acc, vec_data); // Add to accumulator, only for active lanes\n        i_sum += svcntw(); // Advance index by full vector length\n    }\n\n    // Horizontal sum reduction: sum all elements in the accumulator vector\n    total_sum = svaddv_s32(svptrue_b32(), vec_sum_acc);\n\n    // Compare sum with maximum allowed weight w\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Required for std::min\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n\n    // Requirement: non-empty object q\n    if (n == 0) {\n        return false;\n    }\n\n    // Part 1: Check if q is balanced (palindromic)\n    bool is_palindrome = true;\n    size_t left_idx = 0;\n    size_t right_idx = n - 1;\n\n    // Loop while there are elements to compare from both ends\n    while (left_idx < right_idx) {\n        // Determine the number of elements (pairs) we can process in this SVE vector.\n        // This is limited by the SVE vector length (svcntw()) and the remaining elements.\n        size_t num_elements_in_sve_vector = svcntw();\n        \n        // Calculate how many pairs can be processed in this chunk.\n        // (right_idx - left_idx + 1) is the total number of elements remaining.\n        // Dividing by 2 gives the number of pairs.\n        size_t pairs_in_chunk = std::min(num_elements_in_sve_vector, (right_idx - left_idx + 1) / 2);\n\n        if (pairs_in_chunk == 0) {\n            // No more pairs to compare (e.g., only a middle element left for odd-sized vectors)\n            break;\n        }\n\n        // Create a predicate for the current chunk of elements\n        svbool_t pg = svwhilelt_b32(0, pairs_in_chunk);\n\n        // Load elements from the left side of the vector\n        svint32_t vec_left = svld1_s32(pg, &q[left_idx]);\n\n        // Load elements from the right side of the vector.\n        // We load from `q[right_idx - pairs_in_chunk + 1]` to `q[right_idx]`.\n        svint32_t vec_right_raw = svld1_s32(pg, &q[right_idx - pairs_in_chunk + 1]);\n        \n        // Reverse the loaded right-side vector so its elements align correctly for comparison.\n        // E.g., if vec_left has {q[i], q[i+1], ...} and vec_right_raw has {q[j-k+1], ..., q[j]},\n        // then vec_right_rev will have {q[j], q[j-1], ..., q[j-k+1]}.\n        // This allows direct comparison of q[i] with q[j], q[i+1] with q[j-1], etc.\n        svint32_t vec_right_rev = svrevw_s32(vec_right_raw);\n\n        // Compare the two vectors element-wise\n        svbool_t cmp_result = svcmpeq_s32(pg, vec_left, vec_right_rev);\n\n        // Check if all active elements in the current chunk are equal.\n        // If not, the vector is not a palindrome.\n        if (!svptest_all(pg, cmp_result)) {\n            is_palindrome = false;\n            break;\n        }\n\n        // Advance pointers for the next chunk\n        left_idx += pairs_in_chunk;\n        right_idx -= pairs_in_chunk;\n    }\n\n    // If the vector is not a palindrome, it cannot fly.\n    if (!is_palindrome) {\n        return false;\n    }\n\n    // Part 2: Calculate the sum of elements and compare with w\n    long long total_sum = 0; // Use long long to prevent potential overflow for sum\n    size_t i = 0;\n\n    // Loop through the vector in chunks of svcntw() elements\n    while (i < n) {\n        // Create a predicate for the remaining elements in the current chunk\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load elements into an SVE vector\n        svint32_t vec = svld1_s32(pg, &q[i]);\n\n        // Perform a horizontal sum of the active elements in the vector\n        // and add it to the total sum.\n        total_sum += svaddv_s32(pg, vec);\n\n        // Advance the index by the number of elements processed in this SVE vector\n        i += svcntw();\n    }\n\n    // Return true if the total sum is less than or equal to the maximum weight w\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <numeric> \n#include <algorithm> \n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n <= 1) {\n        return 0;\n    }\n\n    int changes = 0;\n    size_t half_n = n / 2;\n    size_t svl = svcntw(); // Number of 32-bit integers per SVE vector\n\n    // Get a pointer to the underlying array data for efficient access\n    const int* arr_data = arr.data();\n\n    // Loop through the first half of the array, processing 'svl' elements at a time\n    for (size_t i = 0; i < half_n; i += svl) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that we only process elements up to 'half_n',\n        // handling the tail end of the array correctly if 'half_n' is not a multiple of 'svl'.\n        svbool_t pg = svwhilelt_b32(i, half_n);\n\n        // Load elements from the left side of the array (arr[i], arr[i+1], ...)\n        svint32_t vec_left = svld1_s32(pg, arr_data + i);\n\n        // Determine the actual number of active elements in the current predicate.\n        // This is important for calculating the correct starting index for the right-side load,\n        // especially in the last iteration where 'i + svl' might exceed 'half_n'.\n        size_t current_active_elements = svcntp_b32(pg, svptrue_b32());\n\n        // Calculate the starting memory address for loading the corresponding right-side elements.\n        // We need to compare arr[i] with arr[n-1-i], arr[i+1] with arr[n-1-(i+1)], and so on.\n        // The elements we need from the right side are arr[n-1-i], arr[n-1-(i+1)], ..., arr[n-1-(i + current_active_elements - 1)].\n        // To load these elements into an SVE vector such that svrev_s32 aligns them correctly for comparison,\n        // we must load starting from the smallest index among them: arr[n-1-(i + current_active_elements - 1)].\n        size_t right_chunk_start_idx = n - 1 - (i + current_active_elements - 1);\n        \n        // Load elements from the right side of the array.\n        // These elements are loaded in increasing memory order, which means they are in reverse order\n        // relative to how they should be compared with vec_left.\n        svint32_t vec_right_raw = svld1_s32(pg, arr_data + right_chunk_start_idx);\n\n        // Reverse the elements within the 'vec_right_raw' vector.\n        // After reversal, vec_right_reversed will contain elements in the order:\n        // [arr[n-1-i], arr[n-1-(i+1)], ..., arr[n-1-(i + current_active_elements - 1)]]\n        // This aligns them perfectly for comparison with vec_left.\n        svint32_t vec_right_reversed = svrev_s32(vec_right_raw);\n\n        // Compare the left-side vector with the reversed right-side vector.\n        // svcmpne generates a predicate mask where bits are set if corresponding elements are not equal.\n        svbool_t ne_mask = svcmpne(pg, vec_left, vec_right_reversed);\n\n        // Count the number of active elements in 'ne_mask' (i.e., elements that are not equal).\n        // This count is added to the total number of changes required.\n        changes += svcntp_b32(pg, ne_mask);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> \n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    if (n <= 1) {\n        // A vector with 0 or 1 element is always a palindrome.\n        return 0;\n    }\n\n    int total_changes = 0;\n    // The number of pairs to compare is n / 2.\n    // For example, if n=7, we compare 3 pairs (arr[0] vs arr[6], arr[1] vs arr[5], arr[2] vs arr[4]).\n    // If n=8, we compare 4 pairs (arr[0] vs arr[7], ..., arr[3] vs arr[4]).\n    long num_pairs = n / 2; \n\n    // Get the vector length (number of 32-bit elements) for the current SVE implementation.\n    int32_t sv_vl = svcntw();\n\n    // Predicate for full SVE vectors (all lanes active).\n    svbool_t pg_all = svptrue_b32();\n\n    long i = 0; // Loop counter for the front half of the array.\n\n    // Process the array in full SVE vector chunks.\n    // The loop continues as long as there are enough pairs to fill a complete SVE vector.\n    for (i = 0; i + sv_vl <= num_pairs; i += sv_vl) {\n        // Load elements from the front of the array into an SVE vector.\n        // This loads arr[i], arr[i+1], ..., arr[i+sv_vl-1].\n        svint32_t vec_front = svld1_s32(pg_all, &arr[i]);\n\n        // Generate indices for the corresponding elements from the back of the array.\n        // For arr[i], the corresponding element is arr[n-1-i].\n        // For arr[i+1], it's arr[n-1-(i+1)], and so on.\n        // This forms a decreasing sequence of indices: (n-1-i), (n-1-i-1), ..., (n-1-i-(sv_vl-1)).\n        // svindex_s32(base, step) generates a vector of indices: {base, base+step, base+2*step, ...}.\n        // By setting base to (n-1-i) and step to -1, we get the desired decreasing sequence.\n        svint32_t indices_back = svindex_s32(n - 1 - i, -1);\n\n        // Load elements from the back of the array using a gather load with the generated indices.\n        // The base pointer is &arr[0], and indices_back contains the absolute memory indices.\n        svint32_t vec_back = svld1_gather_s32index(pg_all, &arr[0], indices_back);\n\n        // Compare elements in vec_front and vec_back for inequality.\n        // svcmpne returns a predicate vector where lanes are true if the corresponding elements are not equal.\n        svbool_t cmp_result = svcmpne(pg_all, vec_front, vec_back);\n\n        // Count the number of true (differing) elements in the predicate vector.\n        // svcntp_b32 counts the number of active (true) lanes in a predicate vector.\n        total_changes += svcntp_b32(pg_all, cmp_result);\n    }\n\n    // Handle any remaining elements (tail processing).\n    // This part processes pairs that do not form a full SVE vector.\n    if (i < num_pairs) {\n        // Generate a predicate for the remaining elements.\n        // svwhilelt_b32(start, end) generates a predicate where lanes are active as long as\n        // the current lane index (relative to the start of the vector) plus 'start' is less than 'end'.\n        // This effectively activates lanes for indices from 'i' up to 'num_pairs - 1'.\n        svbool_t pg_tail = svwhilelt_b32(i, num_pairs);\n\n        // Load the remaining elements from the front using the tail predicate.\n        svint32_t vec_front = svld1_s32(pg_tail, &arr[i]);\n\n        // Generate indices for the remaining back elements.\n        // The logic for index generation remains the same. The predicate 'pg_tail' will ensure\n        // that only the relevant elements are loaded and compared, even if 'indices_back'\n        // contains indices beyond the actual number of remaining pairs.\n        svint32_t indices_back = svindex_s32(n - 1 - i, -1);\n        svint32_t vec_back = svld1_gather_s32index(pg_tail, &arr[0], indices_back);\n\n        // Compare and count for the tail elements.\n        svbool_t cmp_result = svcmpne(pg_tail, vec_front, vec_back);\n        total_changes += svcntp_b32(pg_tail, cmp_result);\n    }\n\n    return total_changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n\n    if (n <= 1) {\n        return 0;\n    }\n\n    int changes = 0;\n    int half_n = n / 2;\n\n    int vl = svcntw();\n\n    for (int i = 0; i < half_n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, half_n);\n\n        svint32_t vec_front = svld1_s32(pg, &arr[i]);\n\n        svint32_t vec_back_raw = svld1_s32(pg, &arr[n - vl - i]);\n        svint32_t vec_back = svrev_s32(vec_back_raw);\n\n        svbool_t ne_pred = svcmpne_s32(pg, vec_front, vec_back);\n\n        changes += svcntp_b32(pg, ne_pred);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>   // Required for std::vector\n#include <cstddef>  // Required for size_t\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr) {\n    int total_changes = 0;\n    size_t n = arr.size(); \n    \n    // If the vector has 0 or 1 element, it's already a palindrome.\n    // The problem states \"non-empty\", so n >= 1.\n    if (n <= 1) {\n        return 0;\n    }\n\n    // Calculate the number of elements to check in the first half of the array.\n    // For a palindrome, we only need to compare elements up to n/2 - 1.\n    size_t half_n = n / 2;\n\n    // Get the base pointer to the array data.\n    const int* arr_data = arr.data();\n\n    // Loop through the first half of the array using SVE vectors.\n    // The loop increment is determined by the SVE vector length (VL).\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (size_t i = 0; i < half_n; i += svcntw()) {\n        // Create a predicate for the current SVE vector operation.\n        // This predicate ensures that we only process elements up to 'half_n'.\n        // Elements beyond 'half_n' in the current vector are masked out.\n        // svwhilelt_b32 takes int64_t arguments, so size_t will be implicitly converted.\n        svbool_t pg = svwhilelt_b32(i, half_n);\n\n        // Load elements from the left side of the array.\n        // This is a contiguous load starting from arr_data + i.\n        svint32_t left_vec = svld1_s32(pg, arr_data + i);\n\n        // Generate offsets for loading elements from the right side.\n        // For an element at index 'i + k' on the left, its counterpart on the right\n        // is at index 'n - 1 - (i + k)'.\n        // The offsets vector will contain:\n        // { (n - 1 - i), (n - 1 - (i+1)), ..., (n - 1 - (i + svcntw() - 1)) }\n        // This is equivalent to starting at (n - 1 - i) and stepping by -1.\n        // svindex_s32 takes int32_t arguments for start and step.\n        // We cast size_t to int32_t, assuming n is not excessively large (e.g., > 2^31).\n        svint32_t right_offsets = svindex_s32(static_cast<int32_t>(n - 1 - i), -1);\n\n        // Perform a gather load for the right side of the array.\n        // This allows loading non-contiguous elements (or elements in reverse logical order)\n        // based on the generated offsets. The predicate 'pg' ensures that only\n        // valid elements within the 'half_n' range are actually loaded from memory.\n        svint32_t right_vec = svld1_gather_s32offset_s32(pg, arr_data, right_offsets);\n\n        // Compare the left and right vectors for inequality.\n        // This generates a new predicate where elements are true if they are not equal.\n        svbool_t ne_predicate = svcmpne_s32(pg, left_vec, right_vec);\n\n        // Count the number of active (true) elements in the 'ne_predicate'.\n        // This count represents the number of differing elements in the current vector chunk.\n        // The 'pg' predicate ensures that only elements within the 'half_n' range are counted.\n        total_changes += svcntp_b32(pg, ne_predicate);\n    }\n\n    return total_changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\n// Given a non-empty vector arr of integers, find the minimum number of elements that\n// need to be changed to make the vector palindromic. A palindromic vector is a vector that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\n//\n// For example:\n// smallest_change_simd({1,2,3,5,4,7,9,6}) == 4\n// smallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\n// smallest_change_simd({1, 2, 3, 2, 1}) == 0\n//\n// The requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\nint smallest_change_simd(std::vector<int> arr) {\n    long n = arr.size();\n\n    // A vector with 0 or 1 element is always palindromic, requiring 0 changes.\n    if (n <= 1) {\n        return 0;\n    }\n\n    int changes = 0;\n    // We only need to check up to the middle of the vector.\n    // For an even length vector, say N=8, we check pairs (0,7), (1,6), (2,5), (3,4). half_n = 4.\n    // For an odd length vector, say N=7, we check pairs (0,6), (1,5), (2,4). The middle element (index 3) is ignored. half_n = 3.\n    long half_n = n / 2;\n\n    // Iterate through the first half of the array using SVE vector length steps.\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n    // This value is determined at runtime by the SVE hardware.\n    for (long i = 0; i < half_n; i += svcntw()) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b32(i, half_n) generates a predicate that is true for elements\n        // whose logical index (relative to 'i') is less than 'half_n - i'.\n        // This correctly handles the tail end of the loop where 'i + svcntw()' might exceed 'half_n'.\n        svbool_t pg = svwhilelt_b32(i, half_n);\n\n        // Load a vector of elements from the front of the array.\n        // Only elements corresponding to true predicate lanes are loaded.\n        svint32_t vec_front = svld1_s32(pg, &arr[i]);\n\n        // Calculate the starting index for the corresponding elements from the back of the array.\n        // For an element at index `k` in the front vector (i.e., `arr[i+k]`),\n        // its corresponding element from the back is `arr[n - 1 - (i+k)]`.\n        // The last element in the current front vector chunk is at `arr[i + svcntw() - 1]`.\n        // Its corresponding back element is `arr[n - 1 - (i + svcntw() - 1)]`.\n        // This is the *first* element we want in the reversed back vector.\n        // So, the raw load from the back should start at `n - 1 - (i + svcntw() - 1)`.\n        long back_start_idx = n - 1 - (i + svcntw() - 1);\n\n        // Load a vector of elements from the back of the array.\n        // These elements are loaded in their natural memory order (ascending index).\n        svint32_t vec_back_raw = svld1_s32(pg, &arr[back_start_idx]);\n\n        // Reverse the loaded back vector.\n        // This aligns the elements such that `vec_front[k]` can be directly compared\n        // with `vec_back[k]` to check `arr[i+k]` against `arr[n-1-(i+k)]`.\n        svint32_t vec_back = svrev_s32(vec_back_raw);\n\n        // Compare the front and reversed back vectors for inequality.\n        // The comparison is performed only for lanes where 'pg' is true.\n        // For false lanes in 'pg', the resulting predicate 'p_diff' will also have false.\n        svbool_t p_diff = svcmpne_s32(pg, vec_front, vec_back);\n\n        // Count the number of active (true) elements in the 'p_diff' predicate.\n        // This count represents the number of differing pairs in the current vector chunk.\n        // svcntp_b32(pg, p_diff) correctly counts only those differences that fall within the active predicate 'pg'.\n        changes += svcntp_b32(pg, p_diff);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n#include <numeric> // Not strictly needed for SVE, but often useful\n\n// Helper function to calculate total characters using SVE intrinsics\nlong long calculate_total_chars_sve(const std::vector<std::string>& vec) {\n    if (vec.empty()) {\n        return 0;\n    }\n\n    // Step 1: Extract lengths into a temporary vector of uint64_t.\n    // This step is sequential as string lengths are determined one by one.\n    std::vector<uint64_t> lengths;\n    lengths.reserve(vec.size());\n    for (const auto& s : vec) {\n        lengths.push_back(static_cast<uint64_t>(s.length()));\n    }\n\n    // Step 2: Sum the lengths using SVE intrinsics.\n    long long total_chars = 0;\n    const size_t num_elements = lengths.size();\n\n    // Get the number of 64-bit elements (doubles) per SVE vector.\n    const size_t vl = svcntd();\n\n    // Initialize an SVE vector for accumulation with zeros.\n    svuint64_t sum_vec = svdup_n_u64(0);\n\n    // Loop through the lengths vector in chunks of `vl`.\n    for (size_t i = 0; i < num_elements; i += vl) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that only valid elements are processed,\n        // handling the tail end of the vector where `i + vl` might exceed `num_elements`.\n        svbool_t pg = svwhilelt_b64(i, num_elements);\n\n        // Load data into an SVE vector using the predicate.\n        // Elements outside the valid range (due to tail) will be zeroed out by the predicate.\n        svuint64_t current_lengths = svld1_u64(pg, &lengths[i]);\n\n        // Add the loaded lengths to the accumulating sum vector.\n        // The predicate ensures that only active lanes contribute to the sum.\n        sum_vec = svadd_u64(pg, sum_vec, current_lengths);\n    }\n\n    // Step 3: Perform a horizontal sum (reduction) of the SVE sum vector.\n    // svaddv_u64 sums all active elements in the vector.\n    // svptrue_b64() creates a predicate where all lanes are active for the final reduction.\n    total_chars = svaddv_u64(svptrue_b64(), sum_vec);\n\n    return total_chars;\n}\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    long long total_chars1 = calculate_total_chars_sve(lst1);\n    long long total_chars2 = calculate_total_chars_sve(lst2);\n\n    // If the two vectors have the same number of chars, return the first vector.\n    // Otherwise, return the vector with fewer total characters.\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\n// Helper function to calculate total characters using SVE\nstatic uint64_t calculate_total_chars_sve(const std::vector<std::string>& vec) {\n    uint64_t total_chars = 0;\n    size_t num_strings = vec.size();\n\n    if (num_strings == 0) {\n        return 0;\n    }\n\n    // Determine the SVE vector length for uint64_t elements\n    size_t vl = svcntd(); // Number of uint64_t elements per vector\n\n    // Accumulator for SVE sums\n    svuint64_t sum_vec = svdup_u64(0); // Initialize with zeros\n\n    // Buffer to hold string lengths for the current SVE chunk\n    // Dynamically sized based on VL\n    std::vector<uint64_t> current_lengths_buffer(vl);\n\n    // Loop through the strings, processing 'vl' strings at a time\n    for (size_t i = 0; i < num_strings; i += vl) {\n        // Create a predicate for the current chunk\n        // This predicate ensures we only process valid elements at the end of the vector\n        svbool_t pg = svwhilelt_b64(i, num_strings);\n\n        // Populate current_lengths_buffer for the current SVE chunk\n        size_t k = 0;\n        for (size_t j = i; j < i + vl && j < num_strings; ++j) {\n            current_lengths_buffer[k++] = vec[j].length();\n        }\n\n        // Load the lengths from the buffer into an SVE vector\n        // svld1_u64 loads elements from memory using the predicate\n        svuint64_t lengths_vec = svld1_u64(pg, current_lengths_buffer.data());\n\n        // Add the loaded lengths to the accumulator vector\n        // svadd_u64_m performs a masked addition: only elements where pg is true are added\n        sum_vec = svadd_u64_m(pg, sum_vec, lengths_vec);\n    }\n\n    // Perform a horizontal sum (reduction) of the accumulator vector\n    // svaddv_u64 sums all elements in the vector. svptrue_b64() creates an all-true predicate.\n    total_chars = svaddv_u64(svptrue_b64(), sum_vec);\n\n    return total_chars;\n}\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    uint64_t total_chars1 = calculate_total_chars_sve(lst1);\n    uint64_t total_chars2 = calculate_total_chars_sve(lst2);\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\n// Helper function to calculate the total number of characters in a vector of strings\n// using SVE (Scalable Vector Extension) intrinsics for parallelism.\nstatic uint64_t calculate_total_chars_sve(const std::vector<std::string>& str_vec) {\n    uint64_t total_sum = 0;\n    size_t num_strings = str_vec.size();\n\n    // If the vector is empty, return 0 immediately.\n    if (num_strings == 0) {\n        return 0;\n    }\n\n    // Step 1: Extract string lengths into a contiguous buffer of uint64_t.\n    // This step iterates through `std::string` objects and calls their `length()` method.\n    // Due to the nature of `std::string` objects and method calls, this part cannot be\n    // directly parallelized using SVE intrinsics. It serves as a preparation step\n    // to get the data into a SIMD-friendly format (a contiguous array of primitive types).\n    std::vector<uint64_t> lengths_buffer(num_strings);\n    for (size_t i = 0; i < num_strings; ++i) {\n        lengths_buffer[i] = str_vec[i].length();\n    }\n\n    // Step 2: Sum the extracted lengths using SVE intrinsics for parallelism.\n    // Initialize an SVE vector of zeros for accumulating the sum.\n    svuint64_t sum_vec = svdup_u64(0);\n\n    // Get the current vector length (number of 64-bit elements) for SVE.\n    // This value is determined by the hardware at runtime and can vary.\n    size_t vl = svcnt_u64();\n\n    // Loop through the `lengths_buffer` in chunks of `vl` (vector length).\n    // This allows processing multiple string lengths in parallel in each iteration.\n    for (size_t i = 0; i < num_strings; i += vl) {\n        // Create a predicate vector. This predicate ensures that only valid elements\n        // within the current chunk are processed, especially for the last, potentially\n        // partial, chunk of data. Elements beyond `num_strings` will be masked out.\n        svbool_t pg = svwhilelt_b64(i, num_strings);\n\n        // Load elements from the `lengths_buffer` into an SVE vector.\n        // `lengths_buffer.data()` provides a raw pointer to the underlying array.\n        svuint64_t loaded_lengths = svld1_u64(pg, lengths_buffer.data() + i);\n\n        // Add the loaded lengths to the accumulating sum vector.\n        // This performs a parallel addition across all active lanes of the SVE vector.\n        sum_vec = svadd_u64(sum_vec, loaded_lengths);\n    }\n\n    // Step 3: Perform a horizontal sum (reduction) across all lanes of the final `sum_vec`.\n    // After the loop, `sum_vec` contains partial sums in its individual lanes.\n    // `svaddv_u64` sums these partial sums into a single scalar result.\n    // `svptrue_b64()` creates a predicate that enables all lanes for the reduction.\n    total_sum = svaddv_u64(svptrue_b64(), sum_vec);\n\n    return total_sum;\n}\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    // Calculate the total number of characters for `lst1` using the SVE-accelerated helper function.\n    uint64_t total_chars1 = calculate_total_chars_sve(lst1);\n    // Calculate the total number of characters for `lst2` using the SVE-accelerated helper function.\n    uint64_t total_chars2 = calculate_total_chars_sve(lst2);\n\n    // Compare the total character counts.\n    // As per the problem description, if `total_chars1` is less than or equal to `total_chars2`,\n    // return `lst1`. Otherwise, return `lst2`.\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <arm_sve.h>\n\n// Helper function to calculate total characters using SVE\nstatic uint64_t calculate_total_chars_sve(const std::vector<uint64_t>& lengths) {\n    if (lengths.empty()) {\n        return 0;\n    }\n\n    svuint64_t sum_vec = svdup_n_u64(0); // Initialize accumulator vector\n\n    size_t vl = svcntd(); // Get vector length for uint64_t elements\n\n    const uint64_t* data_ptr = lengths.data();\n    size_t num_elements = lengths.size();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, num_elements); // Predicate for current chunk\n\n        svuint64_t current_chunk = svld1(pg, data_ptr + i); // Load data\n        sum_vec = svadd_u64(sum_vec, current_chunk); // Accumulate sum\n    }\n\n    return svaddv_u64(svptrue_b64(), sum_vec); // Horizontal sum\n}\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<uint64_t> lengths1;\n    lengths1.reserve(lst1.size());\n    for (const std::string& s : lst1) {\n        lengths1.push_back(s.length());\n    }\n\n    std::vector<uint64_t> lengths2;\n    lengths2.reserve(lst2.size());\n    for (const std::string& s : lst2) {\n        lengths2.push_back(s.length());\n    }\n\n    uint64_t total_chars_lst1 = calculate_total_chars_sve(lengths1);\n    uint64_t total_chars_lst2 = calculate_total_chars_sve(lengths2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    // Calculate total characters for lst1 using SVE\n    uint64_t total_chars_lst1 = 0;\n    if (!lst1.empty()) {\n        std::vector<uint64_t> lengths1;\n        lengths1.reserve(lst1.size());\n        for (const auto& s : lst1) {\n            lengths1.push_back(s.length());\n        }\n\n        size_t num_lengths1 = lengths1.size();\n        size_t i1 = 0;\n        svuint64_t sum_vec1 = svdup_u64(0);\n\n        while (i1 < num_lengths1) {\n            svbool_t pg1 = svwhilelt_b64(i1, num_lengths1);\n            if (svptest_any(svptrue_b64(), pg1) == 0) {\n                break;\n            }\n            svuint64_t current_lengths1 = svld1_u64(pg1, &lengths1[i1]);\n            sum_vec1 = svadd_u64_x(pg1, sum_vec1, current_lengths1);\n            i1 += svcntd();\n        }\n        total_chars_lst1 = svaddv_u64(svptrue_b64(), sum_vec1);\n    }\n\n    // Calculate total characters for lst2 using SVE\n    uint64_t total_chars_lst2 = 0;\n    if (!lst2.empty()) {\n        std::vector<uint64_t> lengths2;\n        lengths2.reserve(lst2.size());\n        for (const auto& s : lst2) {\n            lengths2.push_back(s.length());\n        }\n\n        size_t num_lengths2 = lengths2.size();\n        size_t i2 = 0;\n        svuint64_t sum_vec2 = svdup_u64(0);\n\n        while (i2 < num_lengths2) {\n            svbool_t pg2 = svwhilelt_b64(i2, num_lengths2);\n            if (svptest_any(svptrue_b64(), pg2) == 0) {\n                break;\n            }\n            svuint64_t current_lengths2 = svld1_u64(pg2, &lengths2[i2]);\n            sum_vec2 = svadd_u64_x(pg2, sum_vec2, current_lengths2);\n            i2 += svcntd();\n        }\n        total_chars_lst2 = svaddv_u64(svptrue_b64(), sum_vec2);\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Case 1: x is 0\n    if (x == 0) {\n        // If x is 0, it can only be a power of n if n is also 0 (0^k = 0 for k > 0).\n        return n == 0;\n    }\n\n    // Case 2: x is 1\n    // If x is 1, it's always a power (n^0 = 1 for any n >= 0).\n    // This covers cases like (1, 4), (1, 1), (1, 0).\n    if (x == 1) {\n        return true;\n    }\n\n    // Now x > 1.\n\n    // Case 3: n is 0\n    // If n is 0, and x > 1, it cannot be a power of n (0^k is 0 or 1).\n    if (n == 0) {\n        return false;\n    }\n\n    // Case 4: n is 1\n    // If n is 1, and x > 1, it cannot be a power of n (1^k is always 1).\n    if (n == 1) {\n        return false;\n    }\n\n    // Now x > 1 and n > 1.\n    // We repeatedly divide x by n. If at any point x is not divisible by n,\n    // it's not a power. If it successfully reduces to 1, it is.\n\n    // Predicate for all active lanes.\n    // For scalar operations, we typically use a full predicate.\n    svbool_t pg = svptrue_b64();\n\n    // Load n into an SVE vector once, as it's constant throughout the loop.\n    svuint64_t vn = svdup_n_u64(n);\n\n    // Loop while x is greater than 1.\n    // The loop control remains scalar as iterations are data-dependent.\n    // SVE intrinsics are used for the arithmetic operations within the loop.\n    while (x > 1) {\n        // Duplicate the current scalar x into an SVE vector for computation.\n        svuint64_t current_x_vec = svdup_n_u64(x);\n\n        // Calculate x % n using SVE intrinsics.\n        // Modulo operation: a % b = a - (a / b) * b\n        svuint64_t quotient_vec = svdiv_u64(pg, current_x_vec, vn); // x / n\n        svuint64_t product_vec = svmul_u64(pg, quotient_vec, vn);   // (x / n) * n\n        svuint64_t remainder_vec = svsub_u64(pg, current_x_vec, product_vec); // x - (x / n) * n\n\n        // Get the remainder from the first lane (which holds our scalar x's result).\n        uint64_t remainder = svget_lane_u64(remainder_vec, 0);\n\n        if (remainder != 0) {\n            return false; // x is not divisible by n, so it's not a simple power.\n        }\n\n        // Divide x by n using SVE intrinsics and update the scalar x.\n        svuint64_t next_x_vec = svdiv_u64(pg, current_x_vec, vn);\n        x = svget_lane_u64(next_x_vec, 0); // Update scalar x with the result from the first lane.\n    }\n\n    // If the loop finishes, it means x has been successfully reduced to 1,\n    // indicating it was a simple power of n.\n    return true;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c++\n#include <arm_sve.h> \n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    // Handle x == 1 case: 1 is a power of any n (n^0 = 1)\n    if (x == 1) {\n        return true;\n    }\n\n    // Handle n == 1 case: if x != 1, then x cannot be a power of 1 (1^k = 1)\n    // (x == 1 && n == 1) is handled by the first if statement.\n    if (n == 1) {\n        return false;\n    }\n\n    // Now x > 1 and n > 1.\n    // The core logic involves repeatedly dividing x by n.\n    // This is an inherently sequential process for a single (x, n) pair.\n    // To satisfy the requirement of using SVE intrinsics for \"parallelism\",\n    // we will perform the scalar operations using SVE vector types by duplicating\n    // the scalar values across all vector lanes. This does not provide\n    // performance parallelism for a single (x, n) pair but uses SVE instructions.\n\n    uint64_t current_x = x;\n    svuint64_t sv_n = svdup_u64(n); // Duplicate n into all vector lanes\n\n    // Predicate for active lanes (all lanes are active for a single scalar operation)\n    svbool_t pg = svptrue_b64();\n\n    while (current_x > 1) {\n        svuint64_t sv_current_x = svdup_u64(current_x); // Duplicate current_x\n\n        // Check if current_x is divisible by n: current_x % n != 0\n        // Calculate (current_x / n) * n\n        svuint64_t quotient = svdiv_u64_z(pg, sv_current_x, sv_n);\n        svuint64_t product = svmul_u64_z(pg, quotient, sv_n);\n        \n        // Compare (current_x / n) * n with current_x. If they are not equal,\n        // it means current_x is not perfectly divisible by n.\n        svbool_t remainder_not_zero = svcmpne_u64(pg, sv_current_x, product);\n\n        // If any lane indicates a non-zero remainder (which means the scalar has it)\n        if (svptest_any(pg, remainder_not_zero)) {\n            return false;\n        }\n\n        // Update current_x = current_x / n\n        // Extract the result from one of the vector lanes. Since all lanes are identical,\n        // we can take any active lane's value. svlasta_u64 is a safe choice.\n        current_x = svlasta_u64(pg, quotient);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h> // For uint64_t and UINT64_MAX\n#include <stdbool.h> // For bool\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    // Handle edge cases first\n    // If x is 1, it's n^0 for any n (including n=0, n=1).\n    if (x == 1) {\n        return true;\n    }\n\n    // If n is 1, then 1^k is always 1. Since x != 1 (from above), it cannot be a power of 1.\n    if (n == 1) {\n        return false;\n    }\n\n    // If n is 0:\n    // 0^0 = 1 (handled by x == 1 case)\n    // 0^k = 0 for k > 0. So if x is 0, it's a power of 0. Otherwise, it's not.\n    if (n == 0) {\n        return (x == 0);\n    }\n\n    // From this point, we know x > 1 and n > 1.\n    // We will generate powers of n in parallel using SVE vectors and compare them with x.\n\n    // Get the number of uint64_t elements in an SVE vector (VL)\n    const size_t VL = svcntb() / 8; \n    // Create a predicate for all active lanes\n    svbool_t pg = svwhilelt_b64(0, VL); \n\n    // Duplicate x into an SVE vector for comparison\n    svuint64_t v_x = svdup_u64(x);\n\n    // Calculate n_pow_VL = n^VL. This will be used to multiply the entire vector of powers\n    // to get the next block of powers.\n    uint64_t n_pow_VL_scalar = 1;\n    for (size_t i = 0; i < VL; ++i) {\n        // Check for overflow before multiplication\n        // Since n > 1, n_pow_VL_scalar will grow. If it exceeds UINT64_MAX / n, the next multiplication will overflow.\n        if (n_pow_VL_scalar > UINT64_MAX / n) {\n            n_pow_VL_scalar = UINT64_MAX; // Mark as overflowed\n            break;\n        }\n        n_pow_VL_scalar *= n;\n    }\n    svuint64_t v_n_pow_VL = svdup_u64(n_pow_VL_scalar);\n\n    // Initialize the first vector of powers: [n^0, n^1, ..., n^(VL-1)]\n    svuint64_t current_powers_vec;\n    uint64_t temp_powers[VL];\n    uint64_t current_val = 1; // Represents n^0\n    for (size_t i = 0; i < VL; ++i) {\n        temp_powers[i] = current_val;\n        if (i < VL - 1) { // Prepare for the next power, if not the last element in the initial vector\n            // Check for overflow before multiplication\n            if (current_val > UINT64_MAX / n) {\n                // If overflow, subsequent powers in this initial vector will also overflow.\n                // Mark them as UINT64_MAX to ensure they are handled by overflow checks later.\n                for (size_t j = i + 1; j < VL; ++j) {\n                    temp_powers[j] = UINT64_MAX;\n                }\n                break;\n            }\n            current_val *= n;\n        }\n    }\n    current_powers_vec = svld1_u64(pg, temp_powers);\n\n    // Main loop to check powers\n    while (true) {\n        // 1. Check if x matches any power in the current vector\n        svbool_t match_found = svcmpeq_u64(pg, current_powers_vec, v_x);\n        if (svptest_any(pg, match_found)) {\n            return true; // x is a simple power of n\n        }\n\n        // 2. Check for termination conditions: if any power has exceeded x or overflowed\n        // If any power in current_powers_vec is greater than x, and no match was found,\n        // then x cannot be a power of n (since n > 1, powers only increase).\n        svbool_t exceeded_x = svcmpgt_u64(pg, current_powers_vec, v_x);\n        // If any power in current_powers_vec has overflowed (reached UINT64_MAX),\n        // and x is not UINT64_MAX (which would have been caught by match_found),\n        // then x cannot be a power of n.\n        svbool_t overflowed_lane = svcmpeq_u64(pg, current_powers_vec, svdup_u64(UINT64_MAX));\n        \n        // Combine conditions: if any lane has exceeded x OR overflowed\n        svbool_t stop_condition = svorr_b(pg, exceeded_x, overflowed_lane);\n        if (svptest_any(pg, stop_condition)) {\n            return false; // x is not a simple power of n\n        }\n\n        // 3. Prepare for the next iteration: current_powers_vec = current_powers_vec * n_pow_VL\n        // This effectively shifts the block of powers by VL positions (e.g., from [n^k, ..., n^(k+VL-1)] to [n^(k+VL), ..., n^(k+2*VL-1)]).\n\n        // First, check if n_pow_VL_scalar itself overflowed during its calculation.\n        // If it did, then any further multiplication will also overflow, so we must stop.\n        if (n_pow_VL_scalar == UINT64_MAX) {\n            return false;\n        }\n\n        // Check for overflow before the next multiplication for each lane.\n        // If current_powers_vec[i] > UINT64_MAX / n_pow_VL_scalar, the next multiplication will overflow.\n        svuint64_t limit_for_next_mul = svdup_u64(UINT64_MAX / n_pow_VL_scalar);\n        svbool_t next_will_overflow = svcmpgt_u64(pg, current_powers_vec, limit_for_next_mul);\n        \n        if (svptest_any(pg, next_will_overflow)) {\n            // If any lane will overflow in the next step, we cannot proceed safely.\n            // This implies x is not a power of n (or it would have been found already).\n            return false;\n        }\n        \n        // Perform the parallel multiplication to get the next block of powers\n        current_powers_vec = svmul_u64(pg, current_powers_vec, v_n_pow_VL);\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // If x is 1, it's always a power (n^0 = 1 for any n >= 0).\n    if (x == 1) {\n        return true;\n    }\n\n    // If n is 1, then 1^k = 1. Since x is not 1 (handled above),\n    // it cannot be a power of 1.\n    if (n == 1) {\n        return false;\n    }\n\n    // If n is 0:\n    // 0^k = 0 for k > 0.\n    // Since x is not 1 (handled above), the only possibility for x to be a power of 0 is if x is 0.\n    if (n == 0) {\n        return (x == 0);\n    }\n\n    // If x is 0 (and x != 1, n != 1, n != 0):\n    // For n > 1, n^k will always be > 0. So x=0 cannot be a power of n.\n    if (x == 0) {\n        return false;\n    }\n\n    // Now, x > 1 and n > 1.\n    // Use SVE intrinsics for the division and remainder check.\n    // Duplicate x and n into SVE vectors.\n    svbool_t pg = svptrue_b64(); // Full predicate for all lanes\n\n    svuint64_t vx = svdup_n_u64(x);\n    svuint64_t vn = svdup_n_u64(n);\n    svuint64_t v_zero = svdup_n_u64(0);\n\n    // Loop while x > 1. The loop control is scalar, but operations inside use SVE.\n    while (x > 1) {\n        // Compute remainder: x % n = x - (x / n) * n\n        svuint64_t v_quotient = svdiv_u64(pg, vx, vn);\n        svuint64_t v_product = svmul_u64(pg, v_quotient, vn);\n        svuint64_t v_remainder = svsub_u64(pg, vx, v_product);\n\n        // Check if remainder is not zero (x % n != 0)\n        svbool_t p_remainder_not_zero = svcmpne_u64(pg, v_remainder, v_zero);\n\n        // If any lane has a non-zero remainder (which means our single x has a non-zero remainder),\n        // then x is not divisible by n, so it's not a simple power.\n        if (svptest_any(pg, p_remainder_not_zero)) {\n            return false;\n        }\n\n        // Update x = x / n for the next iteration.\n        vx = svdiv_u64(pg, vx, vn);\n        x = svget_lane_u64(vx, 0); // Extract the updated x from the first lane\n    }\n\n    // If the loop completes, x has been successfully reduced to 1 by repeated division by n,\n    // meaning x is a simple power of n.\n    return true;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) {\n        return true;\n    }\n\n    if (n == 1) {\n        return false;\n    }\n\n    if (n == 0) {\n        return false;\n    }\n\n    if (n > x) {\n        return false;\n    }\n\n    svuint64_t sv_n = svdup_u64(n);\n    svbool_t pg = svptrue_b64();\n\n    while (x > 1) {\n        svuint64_t sv_x = svdup_u64(x);\n\n        svuint64_t remainder_vec = svurem_u64(pg, sv_x, sv_n);\n        uint64_t remainder = svget_lane_u64(remainder_vec, 0);\n\n        if (remainder != 0) {\n            return false;\n        }\n\n        svuint64_t quotient_vec = svudiv_u64(pg, sv_x, sv_n);\n        x = svget_lane_u64(quotient_vec, 0);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t\n\nint hex_key_simd(const std::string & num) {\n    int total_primes = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Define constant vectors once outside the loop using svptrue_b8()\n    // to ensure they are duplicated across all lanes of a full vector.\n    svuint8_t zero_char_vec = svdup_n_u8(svptrue_b8(), '0');\n    svuint8_t nine_char_vec = svdup_n_u8(svptrue_b8(), '9');\n    svuint8_t A_char_vec = svdup_n_u8(svptrue_b8(), 'A');\n    svuint8_t F_char_vec = svdup_n_u8(svptrue_b8(), 'F');\n\n    svuint8_t val_2_vec = svdup_n_u8(svptrue_b8(), 2);\n    svuint8_t val_3_vec = svdup_n_u8(svptrue_b8(), 3);\n    svuint8_t val_5_vec = svdup_n_u8(svptrue_b8(), 5);\n    svuint8_t val_7_vec = svdup_n_u8(svptrue_b8(), 7);\n    svuint8_t val_11_vec = svdup_n_u8(svptrue_b8(), 11); // B\n    svuint8_t val_13_vec = svdup_n_u8(svptrue_b8(), 13); // D\n\n    // Get the number of 8-bit elements in a full SVE vector.\n    // This is used to advance the string pointer.\n    const size_t sv_vec_len = svcnt_u8();\n\n    // Loop through the string in chunks of SVE vector length.\n    while (i < len) {\n        // Create a predicate 'pg' for the current chunk.\n        // svwhilelt_b8 generates a predicate that is true for elements\n        // from 'i' up to 'len - 1', and false for elements beyond 'len'.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector.\n        // Only active lanes (defined by 'pg') will load data.\n        svuint8_t char_vec = svld1_u8(pg, (const uint8_t*)&num[i]);\n\n        // Predicates to identify digit characters ('0'-'9') and hex letter characters ('A'-'F').\n        svbool_t is_digit = svcmpge(pg, char_vec, zero_char_vec) && svcmple(pg, char_vec, nine_char_vec);\n        svbool_t is_hex_letter = svcmpge(pg, char_vec, A_char_vec) && svcmple(pg, char_vec, F_char_vec);\n\n        // Convert digit characters to their decimal values.\n        // svsub_n_u8_z performs subtraction only on active lanes and zeros out inactive ones.\n        svuint8_t digit_vals = svsub_n_u8_z(is_digit, char_vec, '0');\n\n        // Convert hex letter characters to their decimal values.\n        // First, subtract 'A', then add 10.\n        svuint8_t letter_vals_temp = svsub_n_u8_z(is_hex_letter, char_vec, 'A');\n        svuint8_t letter_vals = svadd_n_u8_z(is_hex_letter, letter_vals_temp, 10);\n\n        // Combine the converted digit and letter values into a single vector.\n        // svsel_u8 selects elements based on the predicate 'is_digit'.\n        // Since the input is guaranteed to be correct hex digits, 'is_digit' and\n        // 'is_hex_letter' are mutually exclusive and cover all valid characters.\n        svuint8_t decimal_vals = svsel_u8(is_digit, digit_vals, letter_vals);\n\n        // Create a predicate for prime hexadecimal digits (2, 3, 5, 7, 11, 13).\n        // svcmpeq compares elements for equality.\n        // svorr_b8 performs a bitwise OR on two boolean vectors.\n        svbool_t is_prime_digit = svcmpeq(pg, decimal_vals, val_2_vec);\n        is_prime_digit = svorr_b8(is_prime_digit, svcmpeq(pg, decimal_vals, val_3_vec));\n        is_prime_digit = svorr_b8(is_prime_digit, svcmpeq(pg, decimal_vals, val_5_vec));\n        is_prime_digit = svorr_b8(is_prime_digit, svcmpeq(pg, decimal_vals, val_7_vec));\n        is_prime_digit = svorr_b8(is_prime_digit, svcmpeq(pg, decimal_vals, val_11_vec));\n        is_prime_digit = svorr_b8(is_prime_digit, svcmpeq(pg, decimal_vals, val_13_vec));\n\n        // Count the number of active (true) elements in the 'is_prime_digit' predicate.\n        // svcntp_b8 counts true elements under the governing predicate 'pg'.\n        total_primes += svcntp_b8(pg, is_prime_digit);\n\n        // Advance the index by the full SVE vector length for the next chunk.\n        i += sv_vec_len;\n    }\n\n    return total_primes;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int total_primes = 0;\n    size_t i = 0;\n\n    do {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        svuint8_t chars_vec = svld1_u8(pg, (const uint8_t*)&num[i]);\n\n        svuint8_t zero_char_vec = svdup_u8(pg, '0');\n        svuint8_t A_char_vec = svdup_u8(pg, 'A');\n        svuint8_t ten_val_vec = svdup_u8(pg, 10);\n\n        svbool_t is_alpha_mask = svcmpge_u8(pg, chars_vec, A_char_vec);\n\n        svuint8_t digit_val = svsub_u8(chars_vec, zero_char_vec);\n        svuint8_t alpha_val = svadd_u8(svsub_u8(chars_vec, A_char_vec), ten_val_vec);\n\n        svuint8_t decimal_values = svsel_u8(is_alpha_mask, alpha_val, digit_val);\n\n        svuint8_t val_2 = svdup_u8(pg, 2);\n        svuint8_t val_3 = svdup_u8(pg, 3);\n        svuint8_t val_5 = svdup_u8(pg, 5);\n        svuint8_t val_7 = svdup_u8(pg, 7);\n        svuint8_t val_11 = svdup_u8(pg, 11);\n        svuint8_t val_13 = svdup_u8(pg, 13);\n\n        svbool_t p_prime_2 = svcmpeq_u8(pg, decimal_values, val_2);\n        svbool_t p_prime_3 = svcmpeq_u8(pg, decimal_values, val_3);\n        svbool_t p_prime_5 = svcmpeq_u8(pg, decimal_values, val_5);\n        svbool_t p_prime_7 = svcmpeq_u8(pg, decimal_values, val_7);\n        svbool_t p_prime_B = svcmpeq_u8(pg, decimal_values, val_11);\n        svbool_t p_prime_D = svcmpeq_u8(pg, decimal_values, val_13);\n\n        svbool_t p_primes = svorr_b8(p_prime_2, p_prime_3);\n        p_primes = svorr_b8(p_primes, p_prime_5);\n        p_primes = svorr_b8(p_primes, p_prime_7);\n        p_primes = svorr_b8(p_primes, p_prime_B);\n        p_primes = svorr_b8(p_primes, p_prime_D);\n\n        total_primes += svcntp_b8(pg, p_primes);\n\n        i += svcntb();\n    } while (true);\n\n    return total_primes;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n#include <cstddef>\n\nint hex_key_simd(const std::string & num) {\n    int total_primes = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Get the number of 8-bit elements (bytes) in an SVE vector.\n    // This determines the processing chunk size.\n    size_t sv_len = svcntb();\n\n    // Get a pointer to the underlying character data of the string.\n    const uint8_t* data_ptr = reinterpret_cast<const uint8_t*>(num.data());\n\n    // Loop through the string in chunks of `sv_len` bytes.\n    while (i < len) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the string bounds, especially for the last, partial chunk.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of 8-bit characters from the string.\n        svuint8_t chars = svld1_u8(pg, data_ptr + i);\n\n        // --- Convert hexadecimal characters to their decimal values ---\n        // Step 1: Subtract '0' from all characters.\n        // This handles '0'-'9' correctly (e.g., '5' - '0' = 5).\n        // For 'A'-'F', it results in values like 'A'-'0' = 17, 'B'-'0' = 18, etc.\n        svuint8_t vals = svsub_u8_x(pg, chars, '0');\n\n        // Step 2: Adjust values for 'A'-'F'.\n        // Create a predicate for characters that are 'A' or greater.\n        svbool_t is_alpha_pg = svcmpge_u8(pg, chars, 'A');\n        \n        // For elements where `is_alpha_pg` is true (i.e., 'A' through 'F'),\n        // subtract 7 from their current value.\n        // Example: 'A' - '0' = 17. 17 - 7 = 10 (correct decimal for 'A').\n        // Example: 'F' - '0' = 22. 22 - 7 = 15 (correct decimal for 'F').\n        vals = svsub_u8_m(vals, is_alpha_pg, vals, 7);\n\n        // --- Check if the decimal values are prime hexadecimal digits ---\n        // Prime hex digits are 2, 3, 5, 7, 11 (B), 13 (D).\n        // Initialize a predicate for prime numbers, starting with 2.\n        svbool_t is_prime_pg = svcmpeq_u8(pg, vals, 2);\n\n        // OR with checks for other prime values.\n        is_prime_pg = svorr_b(is_prime_pg, svcmpeq_u8(pg, vals, 3));\n        is_prime_pg = svorr_b(is_prime_pg, svcmpeq_u8(pg, vals, 5));\n        is_prime_pg = svorr_b(is_prime_pg, svcmpeq_u8(pg, vals, 7));\n        is_prime_pg = svorr_b(is_prime_pg, svcmpeq_u8(pg, vals, 11)); // Decimal 11 is 'B'\n        is_prime_pg = svorr_b(is_prime_pg, svcmpeq_u8(pg, vals, 13)); // Decimal 13 is 'D'\n\n        // Count the number of active elements in `is_prime_pg` (i.e., prime digits).\n        // `svcntp_b8` counts true elements in `is_prime_pg` under the control of `pg`.\n        total_primes += svcntp_b8(pg, is_prime_pg);\n\n        // Move to the next chunk in the string.\n        i += sv_len;\n    }\n\n    return total_primes;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cstdint> // For uint8_t\n\nint hex_key_simd(const std::string & num) {\n    int total_primes = 0;\n    size_t n = num.length();\n    size_t i = 0;\n\n    // Get the vector length in bytes for uint8_t elements.\n    // svcntb() returns the number of bytes in a vector register,\n    // which corresponds to the number of uint8_t elements (lanes).\n    size_t sv_len = svcntb(); \n\n    // Loop through the string in chunks of sv_len bytes\n    for (i = 0; i < n; i += sv_len) {\n        // Create a predicate for the current chunk.\n        // This predicate will be true for elements within the string bounds [i, n).\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // If no lanes are active under the predicate, it means we've processed all elements.\n        // This check is an optimization to break early if the remaining string length is 0.\n        if (svptest_any(svptrue_b8(), pg) == 0) {\n            break; \n        }\n\n        // Load characters from the string into an SVE vector (uint8_t)\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&num[i]);\n\n        // --- Convert hex characters to their decimal values ---\n\n        // Calculate potential decimal values assuming they are digits '0'-'9'.\n        // This operation is performed for all active lanes governed by 'pg'.\n        // For 'A'-'F' characters, this result will be incorrect, but will be discarded later.\n        svuint8_t digit_vals = svsub_u8(pg, chars, '0');\n\n        // Calculate potential decimal values assuming they are 'A'-'F'.\n        // This operation is performed for all active lanes governed by 'pg'.\n        // For '0'-'9' characters, this result will be incorrect, but will be discarded later.\n        svuint8_t alpha_vals = svsub_u8(pg, chars, 'A');\n        alpha_vals = svadd_u8(pg, alpha_vals, 10); // Add 10 to get values 10-15\n\n        // Create a predicate to identify '0'-'9' characters.\n        svbool_t is_digit_char = svcmple_u8(pg, chars, '9'); \n\n        // Select the correct decimal value for each character.\n        // If 'is_digit_char' is true for a lane, take the value from 'digit_vals'.\n        // Otherwise (if it's an 'A'-'F' character, based on problem assumptions),\n        // take the value from 'alpha_vals'.\n        svuint8_t decimal_values = svsel_u8(is_digit_char, digit_vals, alpha_vals);\n\n        // --- Check if the decimal values are prime (2, 3, 5, 7, 11, 13) ---\n\n        // Initialize a predicate for prime numbers, initially false for all active lanes.\n        svbool_t is_prime_pg = svdup_b8(false); \n\n        // Check for each prime number (2, 3, 5, 7, 11 (B), 13 (D)) and combine predicates using OR.\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 2));\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 3));\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 5));\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 7));\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 11)); // Decimal 11 for 'B'\n        is_prime_pg = svorr_b8(is_prime_pg, svcmpeq_u8(pg, decimal_values, 13)); // Decimal 13 for 'D'\n\n        // Count the number of active elements in the 'is_prime_pg' predicate.\n        // This gives the count of prime hex digits in the current chunk.\n        total_primes += svcntp_b8(pg, is_prime_pg);\n    }\n\n    return total_primes;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For int8_t\n\nint hex_key_simd(const std::string & num) {\n    int total_count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Get the vector length in bytes for svint8_t elements.\n    // svcntb() returns the number of 8-bit elements in a vector.\n    const size_t VL = svcntb(); \n\n    // Prepare constant vectors for character conversion and prime checks.\n    // These are duplicated across all lanes of the vector.\n    svint8_t v_const_0 = svdup_s8(svptrue_b8(), '0');\n    svint8_t v_const_9 = svdup_s8(svptrue_b8(), '9');\n    svint8_t v_const_7_sub = svdup_s8(svptrue_b8(), 7); // Value to subtract for 'A'-'F' conversion\n\n    // Prime hexadecimal digits in decimal: 2, 3, 5, 7, 11, 13\n    svint8_t v_prime_2 = svdup_s8(svptrue_b8(), 2);\n    svint8_t v_prime_3 = svdup_s8(svptrue_b8(), 3);\n    svint8_t v_prime_5 = svdup_s8(svptrue_b8(), 5);\n    svint8_t v_prime_7 = svdup_s8(svptrue_b8(), 7);\n    svint8_t v_prime_11 = svdup_s8(svptrue_b8(), 11);\n    svint8_t v_prime_13 = svdup_s8(svptrue_b8(), 13);\n\n    // Loop through the string in chunks of VL bytes (vector length)\n    while (i < len) {\n        // Create a predicate for the current chunk.\n        // This predicate is true for elements within the string bounds and false otherwise,\n        // handling the tail of the string automatically.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // If no elements are active in the predicate, it means we've processed all characters.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters from the string into an SVE vector.\n        // Cast to const int8_t* is safe for character data.\n        svint8_t v_char = svld1_s8(pg, (const int8_t*)&num[i]);\n\n        // Convert characters to their decimal values.\n        // First, subtract '0' from all characters.\n        // '0'->0, '9'->9, 'A'->17, 'B'->18, ..., 'F'->22\n        svint8_t v_val = svsub_s8(v_char, v_const_0);\n\n        // Identify characters that are 'A' through 'F' (i.e., greater than '9').\n        svbool_t is_alpha = svcmpgt_s8(pg, v_char, v_const_9);\n\n        // For 'A'-'F' characters, adjust their values.\n        // Current value for 'A' is 17, should be 10 (subtract 7).\n        // Current value for 'F' is 22, should be 15 (subtract 7).\n        // svsub_s8_z performs subtraction only where 'is_alpha' is true,\n        // otherwise it keeps the original value from v_val.\n        v_val = svsub_s8_z(is_alpha, v_val, v_const_7_sub);\n\n        // Check if the decimal values are any of the prime hexadecimal digits.\n        // This is done by creating a predicate for each prime and ORing them together.\n        svbool_t p_prime = svcmpeq_s8(pg, v_val, v_prime_2);\n        p_prime = svorr_b(p_prime, svcmpeq_s8(pg, v_val, v_prime_3));\n        p_prime = svorr_b(p_prime, svcmpeq_s8(pg, v_val, v_prime_5));\n        p_prime = svorr_b(p_prime, svcmpeq_s8(pg, v_val, v_prime_7));\n        p_prime = svorr_b(p_prime, svcmpeq_s8(pg, v_val, v_prime_11));\n        p_prime = svorr_b(p_prime, svcmpeq_s8(pg, v_val, v_prime_13));\n\n        // Count the number of active elements in the 'p_prime' predicate.\n        // 'pg' ensures that only elements within the string bounds are counted.\n        total_count += svcntp_b(pg, p_prime);\n\n        // Move the index to the beginning of the next chunk.\n        i += VL;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string> // Required for std::string\n\nbool is_happy_simd(const std::string & s) {\n    const size_t len = s.length();\n\n    // Condition 1: String length must be at least 3\n    if (len < 3) {\n        return false;\n    }\n\n    // Get a pointer to the underlying character data\n    // reinterpret_cast is safe here as char is guaranteed to be 1 byte.\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t i = 0;\n    const size_t sv_vector_len = svcntb(); // Get the SVE vector length in bytes (elements)\n\n    // Main loop: Process full SVE vectors\n    // We need to check triplets (s[k], s[k+1], s[k+2]).\n    // When loading a vector starting at index 'i', we access elements up to 'i + sv_vector_len - 1'.\n    // For the triplet check, we also need s[i+1] and s[i+2].\n    // So, the maximum index accessed by svld1_u8(&data[i+2]) for the last element in the vector\n    // would be (i + 2) + (sv_vector_len - 1) = i + sv_vector_len + 1.\n    // Therefore, the loop must ensure that 'i + sv_vector_len + 1' is less than 'len'.\n    // This translates to 'i < len - sv_vector_len - 1'.\n    while (i < len - sv_vector_len - 1) {\n        // Create a full predicate for the current vector length.\n        // svptrue_b8() sets all elements in the predicate to true.\n        svbool_t pg = svptrue_b8();\n\n        // Load current, next, and next-next characters into SVE vectors.\n        // The loads are predicated by 'pg', but since 'pg' is all true,\n        // they effectively load 'sv_vector_len' elements.\n        svuint8_t v_curr = svld1_u8(pg, &data[i]);\n        svuint8_t v_next1 = svld1_u8(pg, &data[i+1]);\n        svuint8_t v_next2 = svld1_u8(pg, &data[i+2]);\n\n        // Perform element-wise comparisons to check for distinctness:\n        // s[k] != s[k+1] AND s[k] != s[k+2] AND s[k+1] != s[k+2]\n        svbool_t cmp1 = svcmpne(pg, v_curr, v_next1); // Check v_curr[k] != v_next1[k]\n        svbool_t cmp2 = svcmpne(pg, v_curr, v_next2); // Check v_curr[k] != v_next2[k]\n        svbool_t cmp3 = svcmpne(pg, v_next1, v_next2); // Check v_next1[k] != v_next2[k]\n\n        // Combine the comparison results using logical AND.\n        // If all three conditions are true for an element, its corresponding predicate bit is true.\n        svbool_t all_distinct_pg = svand(svand(cmp1, cmp2), cmp3);\n\n        // Check if all active elements in 'all_distinct_pg' are true.\n        // If any element in the current vector window fails the distinctness check,\n        // svall() will return false, and the string is not happy.\n        if (!svall(pg, all_distinct_pg)) {\n            return false;\n        }\n\n        // Advance the index by the vector length for the next iteration.\n        i += sv_vector_len;\n    }\n\n    // Scalar tail processing: Handle remaining characters that don't form a full SVE vector\n    // or where the shifted loads (i+1, i+2) would go out of bounds for a full vector.\n    // The loop checks triplets (data[k], data[k+1], data[k+2]) up to k = len - 3.\n    for (; i < len - 2; ++i) {\n        if (data[i] == data[i+1] || data[i] == data[i+2] || data[i+1] == data[i+2]) {\n            return false;\n        }\n    }\n\n    // If all checks pass throughout the string, it is happy.\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    const unsigned char* data = reinterpret_cast<const unsigned char*>(s.data());\n    size_t N = s.length();\n\n    // A string is happy if its length is at least 3.\n    if (N < 3) {\n        return false;\n    }\n\n    // Iterate through the string using SVE intrinsics to check every 3 consecutive letters.\n    // The loop processes `svcntb()` (SVE vector length in bytes) characters at a time.\n    // The last valid starting index for a triplet (s[k], s[k+1], s[k+2]) is N - 3.\n    // So, the loop iterates 'i' from 0 up to N - 2 (exclusive), incrementing by vector length.\n    for (size_t i = 0; i < N - 2; i += svcntb()) {\n        // Predicate for the current SVE operation.\n        // It ensures that only lanes corresponding to valid triplets (s[k], s[k+1], s[k+2]) are active.\n        // A triplet starting at index 'k' is valid if 'k' is less than or equal to N - 3.\n        // For the current vector, this means `i + lane_idx < N - 2`.\n        svbool_t pg = svwhilelt_b8(i, N - 2);\n\n        // Load three consecutive vectors of characters.\n        // v0: contains s[i], s[i+1], ..., s[i+VL-1]\n        // v1: contains s[i+1], s[i+2], ..., s[i+VL]\n        // v2: contains s[i+2], s[i+3], ..., s[i+VL+1]\n        // Each load uses a predicate to ensure it does not read past the end of the string (N).\n        svuint8_t v0 = svld1_u8(svwhilelt_b8(i, N), data + i);\n        svuint8_t v1 = svld1_u8(svwhilelt_b8(i + 1, N), data + i + 1);\n        svuint8_t v2 = svld1_u8(svwhilelt_b8(i + 2, N), data + i + 2);\n\n        // Perform comparisons for distinctness for each active lane (triplet).\n        // The 'pg' predicate ensures comparisons are only done for valid triplets.\n        // p_ab: s[k] != s[k+1]\n        svbool_t p_ab = svcmpne_u8(pg, v0, v1);\n        // p_ac: s[k] != s[k+2]\n        svbool_t p_ac = svcmpne_u8(pg, v0, v2);\n        // p_bc: s[k+1] != s[k+2]\n        svbool_t p_bc = svcmpne_u8(pg, v1, v2);\n\n        // Combine the comparison results. A triplet is distinct if all three conditions are true.\n        svbool_t p_distinct = svand_b(p_ab, svand_b(p_ac, p_bc));\n\n        // Check if any active lane (valid triplet) is NOT distinct.\n        // If `svptest_all(pg, p_distinct)` is false, it means at least one active lane in `p_distinct` is false.\n        // This indicates a non-distinct triplet was found, so the string is not happy.\n        if (!svptest_all(pg, p_distinct)) {\n            return false;\n        }\n    }\n\n    // If the loop completes, all checked triplets were distinct.\n    return true; // The string is happy.\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.length();\n\n    // A string is happy if its length is at least 3.\n    if (n < 3) {\n        return false;\n    }\n\n    // Iterate through the string using SVE intrinsics.\n    // We need to check every 3 consecutive letters (s[k], s[k+1], s[k+2])\n    // for k from 0 up to n-3.\n    // The number of such starting positions 'k' is (n-3) - 0 + 1 = n-2.\n    // The loop condition for the predicate should be `i < n - 2`.\n\n    size_t i = 0;\n    // Predicate for active lanes: process elements while 'i' is less than 'n - 2'.\n    // This ensures we cover all 'k' from 0 to n-3.\n    svbool_t pg = svwhilelt_b8(i, n - 2);\n\n    // Loop while there are still active lanes in the predicate.\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into SVE vectors.\n        // current_chars: s[i], s[i+1], s[i+2], ...\n        svuint8_t current_chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // next_chars: s[i+1], s[i+2], s[i+3], ...\n        svuint8_t next_chars = svld1_u8(pg, (const uint8_t*)&s[i+1]);\n\n        // next_next_chars: s[i+2], s[i+3], s[i+4], ...\n        svuint8_t next_next_chars = svld1_u8(pg, (const uint8_t*)&s[i+2]);\n\n        // Compare s[k] with s[k+1] for inequality.\n        svbool_t cmp_k_k1 = svcmpne_u8(pg, current_chars, next_chars);\n\n        // Compare s[k] with s[k+2] for inequality.\n        svbool_t cmp_k_k2 = svcmpne_u8(pg, current_chars, next_next_chars);\n\n        // Compare s[k+1] with s[k+2] for inequality.\n        svbool_t cmp_k1_k2 = svcmpne_u8(pg, next_chars, next_next_chars);\n\n        // Combine all three comparison results.\n        // For a triplet (s[k], s[k+1], s[k+2]) to be distinct, all three comparisons must be true.\n        svbool_t all_distinct_in_lane = svand_b(svand_b(cmp_k_k1, cmp_k_k2), cmp_k1_k2);\n\n        // If any active lane in 'all_distinct_in_lane' is false, it means we found\n        // a triplet where characters are not distinct.\n        if (!svptest_all(pg, all_distinct_in_lane)) {\n            return false; // String is not happy\n        }\n\n        // Advance the loop index by the vector length (number of bytes in a vector).\n        i += svcntb();\n        // Update the predicate for the next iteration.\n        pg = svwhilelt_b8(i, n - 2);\n    }\n\n    // If the loop completes without finding any non-distinct triplets, the string is happy.\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // Required for uint8_t\n\nextern \"C\" bool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n\n    // A string is happy if its length is at least 3.\n    if (len < 3) {\n        return false;\n    }\n\n    size_t i = 0;\n    // The loop iterates for 'i' from 0 up to 'len - 3'.\n    // The predicate 'svwhilelt_b8(i, len - 2)' generates a mask\n    // for elements 'k' such that 'i + k < len - 2'.\n    // This means 'i + k' can go up to 'len - 3'.\n    // So, for each active element 'k' in the vector, we are checking\n    // the triplet (s[i+k], s[i+k+1], s[i+k+2]).\n    while (i < len - 2) {\n        // Get a predicate for the current vector chunk.\n        // This predicate ensures we only process valid characters within string bounds.\n        svbool_t pg = svwhilelt_b8(i, len - 2);\n\n        // Load three consecutive chunks of characters.\n        // vec_curr:   [s[i],   s[i+1],   s[i+2],   ...]\n        // vec_next1:  [s[i+1], s[i+2],   s[i+3],   ...]\n        // vec_next2:  [s[i+2], s[i+3],   s[i+4],   ...]\n        svuint8_t vec_curr  = svld1(pg, (const uint8_t*)&s[i]);\n        svuint8_t vec_next1 = svld1(pg, (const uint8_t*)&s[i+1]);\n        svuint8_t vec_next2 = svld1(pg, (const uint8_t*)&s[i+2]);\n\n        // Check for equality between consecutive characters in each triplet.\n        // cmp1: checks if s[i+k] == s[i+k+1] for active k\n        svbool_t cmp1 = svcmpeq(pg, vec_curr, vec_next1);\n        // cmp2: checks if s[i+k] == s[i+k+2] for active k\n        svbool_t cmp2 = svcmpeq(pg, vec_curr, vec_next2);\n        // cmp3: checks if s[i+k+1] == s[i+k+2] for active k\n        svbool_t cmp3 = svcmpeq(pg, vec_next1, vec_next2);\n\n        // Combine the comparison results: if any pair is equal, the triplet is not distinct.\n        svbool_t any_equal_in_triplet = svorr(svorr(cmp1, cmp2), cmp3);\n\n        // If any active element in 'any_equal_in_triplet' is true,\n        // it means we found at least one triplet that is not distinct.\n        if (svptest_any(pg, any_equal_in_triplet)) {\n            return false; // String is not happy\n        }\n\n        // Advance the index by the current vector length (number of processed characters).\n        i += svcntb();\n    }\n\n    // If the loop completes, all triplets were distinct.\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n{\n    size_t n = s.length();\n\n    if (n < 3) {\n        return false;\n    }\n\n    // Iterate with SVE vectors\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n\n    // Loop for processing string segments using SVE vectors.\n    // The loop iterates over the starting index 'i' of each potential triplet.\n    // The last possible starting index for a triplet is n - 3.\n    // So, we need to check triplets starting from index 0 up to n - 3.\n    // The loop condition 'i < n - 2' ensures that 'i' goes up to 'n - 3'.\n    // The predicate 'svwhilelt_b8(i, n - 2)' generates a mask for active lanes.\n    // For an active lane 'k', it means 'i + k < n - 2'.\n    // This implies 'i + k <= n - 3'.\n    // Therefore:\n    // - The first character of the triplet (s[i+k]) is at index 'i + k', which is <= n - 3, so it's valid.\n    // - The second character (s[i+k+1]) is at index 'i + k + 1', which is <= n - 2, so it's valid.\n    // - The third character (s[i+k+2]) is at index 'i + k + 2', which is <= n - 1, so it's valid.\n    // All memory accesses are guaranteed to be within the string bounds [0, n-1].\n    for (i = 0; i < n - 2; i += svcntb()) {\n        pg = svwhilelt_b8(i, n - 2);\n\n        // Load characters for current triplet positions\n        // v_curr contains s[i+k] for active lanes k\n        svuint8_t v_curr = svld1_u8(pg, (const uint8_t*)&s[i]);\n        // v_next contains s[i+k+1] for active lanes k\n        svuint8_t v_next = svld1_u8(pg, (const uint8_t*)&s[i+1]);\n        // v_next_next contains s[i+k+2] for active lanes k\n        svuint8_t v_next_next = svld1_u8(pg, (const uint8_t*)&s[i+2]);\n\n        // Check for distinctness:\n        // cmp1: true if s[i+k] == s[i+k+1] for active lanes\n        svbool_t cmp1 = svcmpeq_u8(pg, v_curr, v_next);\n        // cmp2: true if s[i+k] == s[i+k+2] for active lanes\n        svbool_t cmp2 = svcmpeq_u8(pg, v_curr, v_next_next);\n        // cmp3: true if s[i+k+1] == s[i+k+2] for active lanes\n        svbool_t cmp3 = svcmpeq_u8(pg, v_next, v_next_next);\n\n        // Combine all equality checks: if any pair is equal for any active lane\n        svbool_t any_equal = svorr_b(svorr_b(cmp1, cmp2), cmp3);\n\n        // If svptest_any returns true, it means at least one active lane\n        // has a triplet where characters are not distinct.\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n    }\n\n    // If the loop completes, all triplets in the string are distinct\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath> // For sqrt\n\nbool prime_length_simd(const std::string & str) {\n    size_t n = str.length();\n\n    // Handle base cases for primality\n    if (n <= 1) {\n        return false; // Numbers less than or equal to 1 are not prime\n    }\n    if (n == 2 || n == 3) {\n        return true; // 2 and 3 are prime\n    }\n    if (n % 2 == 0) {\n        return false; // Even numbers greater than 2 are not prime\n    }\n\n    // For n >= 5 and odd, check for odd divisors from 3 up to sqrt(n)\n    // Calculate the upper bound for divisors.\n    // Cast n to double for sqrt, then to unsigned long long for the loop variable.\n    // unsigned long long is used to safely handle the full range of size_t.\n    unsigned long long limit = static_cast<unsigned long long>(std::sqrt(static_cast<double>(n)));\n\n    // Get the number of 64-bit elements in an SVE vector.\n    // svcntd() returns the number of 64-bit elements, suitable for svuint64_t.\n    unsigned long long vl = svcntd();\n\n    // Loop through potential odd divisors using SVE intrinsics.\n    // The loop variable 'i' represents the starting divisor for each vector chunk.\n    // We increment 'i' by (vl * 2) because each vector processes 'vl' odd numbers.\n    for (unsigned long long i = 3; i <= limit; i += (vl * 2)) {\n        // Generate a vector of odd numbers starting from 'i'.\n        // svindex_u64(0, 2) creates a vector [0, 2, 4, 6, ...].\n        // svadd_n_u64 adds 'i' to each element, resulting in [i, i+2, i+4, ...].\n        svuint64_t divisors = svadd_n_u64(svindex_u64(0, 2), i);\n\n        // Create a predicate to only process divisors that are within the 'limit'.\n        // svptrue_b64() creates an all-true predicate, meaning the comparison applies to all lanes.\n        svbool_t current_pg = svcmple_n_u64(svptrue_b64(), divisors, limit);\n\n        // Duplicate 'n' into an SVE vector so it can be used in vector operations.\n        svuint64_t n_vec = svdup_n_u64(n);\n\n        // Perform the modulo operation (n % divisor) for active lanes.\n        // svmod_n_u64_x performs a masked modulo. Only lanes where current_pg is true are computed.\n        svuint64_t remainders = svmod_n_u64_x(current_pg, n_vec, divisors);\n\n        // Check if any of the remainders in the active lanes are zero.\n        // If a remainder is zero, it means 'n' is divisible by that divisor, hence not prime.\n        svbool_t any_zero = svcmpeq_n_u64(current_pg, remainders, 0);\n\n        // If svptest_any returns true, it means at least one active lane found a divisor.\n        if (svptest_any(current_pg, any_zero)) {\n            return false; // 'n' is not prime\n        }\n    }\n\n    // If no divisors were found, 'n' is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath> // For std::sqrt\n#include <vector> // Not strictly needed, but common for array-like data\n\n// Helper function to check if a number is prime using SVE intrinsics for trial division.\n// This function leverages SVE to check multiple potential divisors simultaneously,\n// which can provide parallelism for the trial division process.\nstatic bool is_prime_sve(size_t n) {\n    // Handle base cases for primality\n    if (n <= 1) return false;\n    if (n <= 3) return true; // 2 and 3 are prime\n    \n    // Eliminate multiples of 2 and 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Calculate the upper limit for trial division: sqrt(n)\n    size_t limit = static_cast<size_t>(std::sqrt(n));\n\n    // Get the number of 64-bit elements (long long) that fit in an SVE vector.\n    // SVE vector length (VL) is determined at runtime. For int64_t, VL is typically >= 2.\n    const size_t VL = svcntd();\n\n    // Duplicate 'n' into an SVE vector. This allows 'n' to be used in element-wise\n    // SVE operations (e.g., modulo) against a vector of divisors.\n    svint64_t n_vec = svdup_s64(n);\n\n    // Loop for trial division using the 6k +/- 1 optimization.\n    // We check divisors of the form `6k+5` and `6k+7`.\n    // In each iteration, `current_base_divisor` starts at 5, then 5 + 6*(VL/2), etc.\n    // We process `VL/2` pairs of `(6k+5, 6k+7)` in one SVE vector operation,\n    // effectively checking `VL` divisors in parallel.\n    for (size_t current_base_divisor = 5; current_base_divisor <= limit; current_base_divisor += 6 * (VL / 2)) {\n        // Create a temporary array to hold the `VL` divisors for the current SVE vector.\n        long long divisors_arr[VL];\n        \n        // Populate the `divisors_arr` with `VL` divisors following the `6k+5, 6k+7` pattern.\n        // For example, if VL=4: {current_base_divisor, current_base_divisor+2, current_base_divisor+6, current_base_divisor+8}\n        for (size_t j = 0; j < VL; ++j) {\n            size_t k_offset = j / 2; // Determines which `6k` block we are in\n            size_t divisor_val;\n\n            if (j % 2 == 0) { // Even index: corresponds to `6k+5` form\n                divisor_val = current_base_divisor + 6 * k_offset;\n            } else { // Odd index: corresponds to `6k+7` form\n                divisor_val = current_base_divisor + 6 * k_offset + 2;\n            }\n            divisors_arr[j] = static_cast<long long>(divisor_val);\n        }\n\n        // Load the generated divisors into an SVE vector.\n        // `svptrue_b64()` creates a predicate that is true for all lanes.\n        svint64_t divisors_vec = svld1_s64(svptrue_b64(), divisors_arr);\n\n        // Create a predicate that is true only for divisors that are within the `limit`.\n        // This ensures that modulo operations are only performed for valid divisors,\n        // and results from out-of-bounds divisors are ignored.\n        svbool_t active_divisors_pg = svcmple_s64(svptrue_b64(), divisors_vec, svdup_s64(limit));\n        \n        // Perform element-wise modulo operation: n % divisor for active lanes.\n        // The results for inactive lanes are undefined but will be ignored by subsequent predicated operations.\n        svint64_t remainders = svrem_s64(active_divisors_pg, n_vec, divisors_vec);\n\n        // Check if any of the remainders in the active lanes are zero.\n        // If a remainder is zero, it means 'n' is divisible by that divisor, and thus 'n' is not prime.\n        svbool_t any_zero_remainder = svcmpeq_s64(active_divisors_pg, remainders, svdup_s64(0));\n\n        // If `svptest_any` returns true, it means at least one active lane had a zero remainder.\n        if (svptest_any(active_divisors_pg, any_zero_remainder)) {\n            return false; // 'n' is not prime\n        }\n\n        // Check if the next `current_base_divisor` increment would exceed the limit or overflow.\n        // This prevents potential issues with `size_t` arithmetic near its maximum value.\n        if (limit - current_base_divisor < 6 * (VL / 2)) {\n            break; \n        }\n    }\n\n    return true; // No divisors found, so 'n' is prime\n}\n\n// Main function as required by the problem description.\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    return is_prime_sve(len);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cmath> // For std::sqrt\n\nbool prime_length_simd(const std::string & str) {\n    long long n = str.length();\n\n    if (n <= 1) return false;\n    if (n <= 3) return true; // 2, 3 are prime\n    if (n % 2 == 0 || n % 3 == 0) return false; // Exclude multiples of 2 and 3\n\n    long long limit = static_cast<long long>(std::sqrt(n));\n\n    // Create a scalar vector of n, where all lanes hold the value of n.\n    svuint64_t sv_n = svdup_u64(n);\n\n    // Loop for trial division, checking odd numbers from 5 up to limit.\n    // We increment 'i' by `svcntd() * 2` in each iteration to process multiple divisors in parallel.\n    for (long long i = 5; i <= limit; /* increment inside loop */) {\n        // Create a predicate for active lanes.\n        // Lanes are active as long as the current divisor candidate 'i' is less than or equal to 'limit'.\n        // svwhilelt_b64(start, end) generates a predicate for elements < end.\n        // To include 'limit', we use 'limit + 1' as the end value.\n        svbool_t pg = svwhilelt_b64(i, limit + 1);\n\n        // If no lanes are active (i.e., 'i' has exceeded 'limit' for all potential lanes),\n        // then we have checked all necessary divisors.\n        if (svptest_any(svptrue_b64(), pg) == 0) {\n            break;\n        }\n\n        // Generate a vector of divisors: i, i+2, i+4, ...\n        // svindex_u64(start, step) generates a sequence: start, start+step, start+2*step, ...\n        // Here, start is 'i' and step is 2 (to check only odd divisors).\n        svuint64_t divisors = svindex_u64(i, 2);\n\n        // Perform division: n / divisor.\n        // SVE does not have a direct modulo intrinsic. Modulo can be computed as a - (a/b)*b.\n        // Use predicated variants (_x) to only operate on active lanes defined by 'pg'.\n        svuint64_t quotient = svdiv_u64_x(pg, sv_n, divisors);\n        svuint64_t product = svmul_u64_x(pg, quotient, divisors);\n        svuint64_t remainder = svsub_u64_x(pg, sv_n, product);\n\n        // Check if any active lane has a zero remainder.\n        // svcmpeq_u64(pg, remainder, 0) creates a new predicate where remainder is 0 for active lanes.\n        svbool_t has_zero_remainder = svcmpeq_u64(pg, remainder, 0);\n\n        // If any active lane has a zero remainder, it means 'n' is divisible by one of the divisors,\n        // so 'n' is not a prime number.\n        if (svptest_any(pg, has_zero_remainder)) {\n            return false;\n        }\n\n        // Update 'i' for the next iteration.\n        // 'i' advances by the number of 64-bit elements in a vector (svcntd()) multiplied by the step (2).\n        i += svcntd() * 2;\n    }\n\n    // If the loop completes without finding any divisors, 'n' is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath> // For std::sqrt\n\nbool prime_length_simd(const std::string & str) {\n    unsigned long long n = str.length();\n\n    // Handle base cases for primality test\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) { // 2 and 3 are prime\n        return true;\n    }\n    // Check divisibility by 2 and 3\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    // Calculate the upper limit for trial division: sqrt(n)\n    // Use long double for std::sqrt to maintain precision for large n,\n    // then cast back to unsigned long long.\n    unsigned long long limit = static_cast<unsigned long long>(std::sqrt(static_cast<long double>(n)));\n\n    // Get the number of 64-bit elements in an SVE vector.\n    // This determines how many divisors can be checked in parallel.\n    int vl = svcntd();\n\n    // Broadcast the string length 'n' into an SVE vector.\n    // This allows element-wise operations with 'n' across all lanes.\n    svuint64_t n_vec = svdup_n_u64(n);\n\n    // Iterate through potential divisors starting from 5.\n    // We check divisors 'd' such that d*d <= n.\n    // The loop increments by 'vl' to process 'vl' divisors in parallel in each iteration.\n    for (unsigned long long i = 5; i <= limit; i += vl) {\n        // Generate a vector of consecutive divisors: [i, i+1, ..., i+vl-1].\n        svuint64_t divisors = svindex_u64(i, 1);\n\n        // Create a predicate to only process divisors that are less than or equal to 'limit'.\n        // svwhilelt_b64(start, end) generates a predicate for elements\n        // starting from 'start' that are strictly less than 'end'.\n        // To include 'limit', we use 'limit + 1' as the upper bound.\n        svbool_t pg = svwhilelt_b64(i, limit + 1);\n\n        // Perform element-wise modulo operation: n_vec % divisors.\n        // Only active lanes (where 'pg' is true) perform the operation; inactive lanes are zeroed.\n        svuint64_t remainders = svmod_u64_z(pg, n_vec, divisors);\n\n        // Check if any active lane has a zero remainder.\n        // svcmpeq_n_u64(pg, remainders, 0) compares remainders with 0,\n        // only for active lanes defined by 'pg'.\n        svbool_t any_zero_remainder = svcmpeq_n_u64(pg, remainders, 0);\n\n        // If any active lane resulted in a zero remainder, 'n' is not prime.\n        // svptest_any checks if any bit is set in the predicate, indicating a true condition.\n        if (svptest_any(svptrue_b64(), any_zero_remainder)) {\n            return false;\n        }\n    }\n\n    // If no divisors were found up to sqrt(n), 'n' is prime.\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstatic bool is_prime_sve(size_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(static_cast<double>(n)));\n\n    svuint64_t n_vec = svdup_n_u64(n);\n    svuint64_t limit_plus_1_vec = svdup_n_u64(limit + 1);\n\n    size_t i = 5;\n    size_t vl = svcntd();\n\n    while (true) {\n        svuint64_t current_div_a = svindex_u64(i, 6);\n        svuint64_t current_div_b = svindex_u64(i + 2, 6);\n\n        svbool_t pg_a = svcmpgt_u64(svptrue_b64(), limit_plus_1_vec, current_div_a);\n        svbool_t pg_b = svcmpgt_u64(svptrue_b64(), limit_plus_1_vec, current_div_b);\n\n        svuint64_t rem_a = svmod_u64(pg_a, n_vec, current_div_a);\n        svbool_t any_zero_a = svcmpeq_n_u64(pg_a, rem_a, 0);\n\n        svuint64_t rem_b = svmod_u64(pg_b, n_vec, current_div_b);\n        svbool_t any_zero_b = svcmpeq_n_u64(pg_b, rem_b, 0);\n\n        if (svptest_any(svptrue_b64(), any_zero_a) || svptest_any(svptrue_b64(), any_zero_b)) {\n            return false;\n        }\n\n        i += vl * 6;\n\n        if (!svptest_any(svptrue_b64(), pg_a) && !svptest_any(svptrue_b64(), pg_b)) {\n            break;\n        }\n    }\n\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    return is_prime_sve(length);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <string>\n#include <cstdio> // For sprintf\n#include <cstring> // For strlen\n\n// SVE intrinsics header\n#include <arm_sve.h> \n\nstd::string solve_simd(uint64_t N){\n    // Part 1: Calculate the sum of decimal digits of N.\n    // Convert N to its decimal string representation. This step is scalar.\n    char str_N[24]; // Max 20 digits for uint64_t + null terminator + padding\n    int num_chars = sprintf(str_N, \"%llu\", N);\n\n    uint64_t sum_digits = 0;\n\n    // Use SVE to sum the digits (characters) in parallel.\n    int i = 0;\n    while (i < num_chars) {\n        // Create a predicate for the current chunk of characters (8-bit elements).\n        svbool_t pg = svwhilelt_b8(i, num_chars);\n\n        // If no active elements are left, break the loop.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters into an SVE vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&str_N[i]);\n\n        // Convert character digits ('0'-'9') to integer digits (0-9)\n        // by subtracting the ASCII value of '0'.\n        svuint8_t digits = svsub_u8(pg, chars, svdup_u8('0'));\n\n        // Horizontally sum the digits in the current vector chunk.\n        // svaddv_u8 sums all active elements in the vector.\n        sum_digits += svaddv_u8(pg, digits);\n\n        // Advance the index by the number of elements processed in this vector.\n        i += svcntb(); // svcntb() returns the number of 8-bit elements in a vector.\n    }\n\n    // Part 2: Convert the sum of digits to its binary string representation.\n    // The maximum sum of digits for a uint64_t is 171. Converting a single\n    // small integer to binary is inherently sequential and not suitable for\n    // SVE parallelism due to overhead. A scalar loop is the most efficient.\n    if (sum_digits == 0) {\n        return \"0\";\n    }\n\n    std::string binary_str = \"\";\n    while (sum_digits > 0) {\n        binary_str = ((sum_digits % 2 == 0) ? \"0\" : \"1\") + binary_str;\n        sum_digits /= 2;\n    }\n\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <string>\n#include <algorithm> // Required for std::reverse\n#include <cstdint>   // Required for uint64_t\n\nstd::string solve_simd(uint64_t N){\n    std::string s = std::to_string(N);\n    const char* str_data = s.c_str();\n    size_t len = s.length();\n\n    uint64_t total_sum_digits = 0;\n\n    // Use SVE to sum digits\n    // Iterate through the string in chunks of svcntb() (SVE vector length for bytes)\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate to process only valid characters within the string length\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector of 8-bit unsigned integers\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str_data + i));\n\n        // Subtract ASCII '0' (48) from each character to get its digit value\n        svuint8_t digits = svsub_u8(pg, chars, sv_set1_u8(48));\n\n        // Horizontally sum the active digit values in the vector and add to total_sum_digits\n        total_sum_digits += svaddv_u8(pg, digits);\n    }\n\n    // Convert the total_sum_digits to its binary string representation\n    std::string binary_result = \"\";\n    if (total_sum_digits == 0) {\n        binary_result = \"0\";\n    } else {\n        uint64_t temp_sum = total_sum_digits;\n        while (temp_sum > 0) {\n            binary_result.push_back(((temp_sum % 2) == 0 ? '0' : '1'));\n            temp_sum /= 2;\n        }\n        // The binary digits are collected in reverse order, so reverse the string\n        std::reverse(binary_result.begin(), binary_result.end());\n    }\n\n    return binary_result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Required for std::reverse if used, but not in this specific implementation\n\n// Helper function to convert a decimal sum to its binary string representation.\n// This operation is inherently scalar for a single integer and is not parallelized with SVE.\nstatic std::string to_binary_string(uint64_t sum) {\n    if (sum == 0) {\n        return \"0\";\n    }\n    std::string binary_str = \"\";\n    while (sum > 0) {\n        binary_str = (sum % 2 == 0 ? \"0\" : \"1\") + binary_str;\n        sum /= 2;\n    }\n    return binary_str;\n}\n\nstd::string solve_simd(uint64_t N){\n    // Step 1: Convert the 64-bit integer N into its decimal string representation.\n    // This is a scalar operation, but it's a necessary preprocessing step to\n    // obtain the individual digits in a format suitable for SVE vectorization.\n    std::string s = std::to_string(N);\n\n    uint64_t total_digit_sum = 0;\n\n    // Step 2: Calculate the sum of decimal digits using SVE intrinsics.\n    // This part leverages SVE to process multiple characters (digits) in parallel.\n    size_t i = 0;\n    do {\n        // Generate a predicate for the current vector chunk.\n        // svwhilelt_b8 creates a predicate that is true for elements whose\n        // effective index (i + element_offset) is less than s.length().\n        // This correctly handles both full vectors and the tail of the string.\n        svbool_t pg = svwhilelt_b8(i, s.length());\n\n        // If no elements are active in the predicate, it means all characters\n        // have been processed, so break the loop.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters from the string into an SVE vector of unsigned 8-bit integers.\n        // The predicate 'pg' ensures that only valid characters within the string bounds are loaded.\n        svuint8_t sv_chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Create an SVE vector where all elements are duplicated with the ASCII value of '0'.\n        svuint8_t sv_zero_char = svdup_n_u8('0');\n\n        // Subtract the ASCII value of '0' from each character to convert it into its numerical digit value.\n        svuint8_t sv_digits = svsub_u8(sv_chars, sv_zero_char);\n\n        // Perform a horizontal sum of the digit values within the vector.\n        // svaddv_u8 sums all active elements (as determined by 'pg') of the svuint8_t vector\n        // into a single scalar unsigned 8-bit integer.\n        uint8_t chunk_sum = svaddv_u8(pg, sv_digits);\n\n        // Add the sum obtained from the current vector chunk to the running total.\n        total_digit_sum += chunk_sum;\n\n        // Advance the index by the number of bytes in an SVE vector (vector length).\n        i += svcntb();\n    } while (true);\n\n    // Step 3: Convert the total sum of digits (which is a single scalar integer)\n    // into its binary string representation. This part is handled by the scalar\n    // helper function `to_binary_string`.\n    return to_binary_string(total_digit_sum);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm>\n\nstd::string dec_to_bin(int n) {\n    if (n == 0) {\n        return \"0\";\n    }\n    std::string binaryString = \"\";\n    while (n > 0) {\n        binaryString = (n % 2 == 0 ? \"0\" : \"1\") + binaryString;\n        n /= 2;\n    }\n    return binaryString;\n}\n\nstd::string solve_simd(uint64_t N){\n    std::string s = std::to_string(N);\n    \n    int total_sum = 0;\n\n    size_t vl = svcntb(); \n\n    for (size_t i = 0; i < s.length(); i += vl) {\n        svbool_t current_pg = svwhilelt_b8(i, s.length());\n\n        svuint8_t chars = svld1_u8(current_pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        svuint8_t digits = svsub_n_u8(current_pg, chars, 48);\n\n        total_sum += svaddv_u8_x(current_pg, digits);\n    }\n\n    return dec_to_bin(total_sum);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string solve_simd(uint64_t N) {\n    uint8_t digits_arr[20];\n    int num_digits = 0;\n\n    if (N == 0) {\n        digits_arr[num_digits++] = 0;\n    } else {\n        uint64_t temp_N = N;\n        while (temp_N > 0) {\n            digits_arr[num_digits++] = temp_N % 10;\n            temp_N /= 10;\n        }\n    }\n\n    int sum_of_digits = 0;\n\n    if (num_digits > 0) {\n        svuint8_t vec_sum_accumulator = svdup_u8(0);\n\n        for (int i = 0; i < num_digits; i += svcntb()) {\n            svbool_t pg = svwhilelt_b8(i, num_digits);\n            svuint8_t current_digits_vec = svld1_u8(pg, &digits_arr[i]);\n            vec_sum_accumulator = svadd_u8_m(pg, vec_sum_accumulator, current_digits_vec);\n        }\n        sum_of_digits = svaddv_u8(svptrue_b8(), vec_sum_accumulator);\n    }\n\n    std::string binary_string = \"\";\n    if (sum_of_digits == 0) {\n        binary_string = \"0\";\n    } else {\n        while (sum_of_digits > 0) {\n            binary_string = (sum_of_digits % 2 == 0 ? \"0\" : \"1\") + binary_string;\n            sum_of_digits /= 2;\n        }\n    }\n\n    return binary_string;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int total_sum = 0;\n    size_t n = lst.size();\n\n    // Loop through the vector in chunks of SVE vector length\n    // svcntw() returns the number of 32-bit elements in an SVE vector\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Get the active predicate for the current chunk.\n        // This handles the tail of the vector where the number of elements\n        // might be less than the full SVE vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current chunk of data into an SVE vector\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Generate a vector of absolute indices for the current chunk.\n        // svindex_s32(0, 1) creates a sequence 0, 1, 2, ...\n        // svadd_n_s32 adds the base index 'i' to each element.\n        svint32_t indices = svadd_n_s32(svindex_s32(0, 1), i);\n\n        // Predicate for odd indices: (index % 2) != 0\n        // svand_n_s32(indices, 1) computes index % 2\n        // svcmpeq_n_s32 compares the result with 1 (true for odd)\n        svbool_t odd_idx_pred = svcmpeq_n_s32(pg, svand_n_s32(indices, 1), 1);\n\n        // Predicate for even values: (value % 2) == 0\n        // svand_n_s32(vec, 1) computes value % 2\n        // svcmpeq_n_s32 compares the result with 0 (true for even)\n        svbool_t even_val_pred = svcmpeq_n_s32(pg, svand_n_s32(vec, 1), 0);\n\n        // Combine the two predicates: (odd index) AND (even value)\n        // An element is selected only if both conditions are true.\n        svbool_t combined_pred = svand_b(odd_idx_pred, even_val_pred);\n\n        // Select elements that satisfy the combined predicate.\n        // Elements for which combined_pred is true are taken from 'vec'.\n        // Elements for which combined_pred is false are replaced with 0 (from svdup_n_s32(0)).\n        svint32_t selected_elements = svsel_s32(svdup_n_s32(0), vec, combined_pred);\n\n        // Horizontally sum the selected elements within the current SVE vector.\n        // The sum is performed only for elements active under 'pg'.\n        // Add this chunk's sum to the total scalar sum.\n        total_sum += svaddv_s32(pg, selected_elements);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    // Initialize a vector to accumulate sums. All lanes start at 0.\n    svint32_t sve_total_sum_vec = svdup_s32(0);\n\n    // Loop through the vector in chunks of SVE vector length\n    // 'i' is the starting index of the current chunk\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        // Get the predicate for the current chunk.\n        // This predicate ensures we only process valid elements, especially for the tail.\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n\n        // Load the current chunk of elements from the input list\n        svint32_t current_elements = svld1_s32(pg, &lst[i]);\n\n        // Generate global indices for the current chunk\n        // svindex_s32(start, step) generates a sequence like [start, start+step, start+2*step, ...]\n        svint32_t indices_in_chunk = svindex_s32(0, 1); // Generates [0, 1, 2, ..., VL-1]\n        // Add 'i' (broadcasted to all lanes) to each relative index to get global indices\n        svint32_t global_indices = svadd_s32(indices_in_chunk, svdup_s32(i));\n\n        // --- Condition 1: Element is even ---\n        // Calculate (element & 1) for each element to check parity\n        svint32_t element_parity = svand_s32(current_elements, svdup_s32(1));\n        // Create a predicate where true if (element & 1) == 0 (i.e., element is even)\n        // The 'pg' predicate ensures we only compare for active lanes.\n        svbool_t is_even = svcmpeq_s32(pg, element_parity, 0);\n\n        // --- Condition 2: Index is odd ---\n        // Calculate (index & 1) for each global index to check parity\n        svint32_t index_parity = svand_s32(global_indices, svdup_s32(1));\n        // Create a predicate where true if (index & 1) != 0 (i.e., index is odd)\n        // The 'pg' predicate ensures we only compare for active lanes.\n        svbool_t is_odd_index = svcmpne_s32(pg, index_parity, 0);\n\n        // --- Combine Conditions ---\n        // Combine the two predicates: true if both is_even AND is_odd_index are true\n        // This operation is also implicitly predicated by 'pg' because 'is_even' and 'is_odd_index'\n        // are already predicated by 'pg'.\n        svbool_t combined_predicate = svand_b(is_even, is_odd_index);\n\n        // Select elements that satisfy the combined predicate.\n        // For elements where combined_predicate is false, replace them with 0.\n        // For elements where combined_predicate is true, keep their original value.\n        // The 'svdup_s32(0)' provides the value for false lanes.\n        svint32_t selected_elements = svsel_s32(svdup_s32(0), current_elements, combined_predicate);\n\n        // Add the selected elements to the total sum accumulator vector.\n        // This performs an unpredicated element-wise add. Since 'selected_elements'\n        // already has zeros for elements that didn't meet the criteria (including inactive lanes\n        // from the tail), this correctly accumulates the sum across all lanes.\n        sve_total_sum_vec = svadd_s32(sve_total_sum_vec, selected_elements);\n    }\n\n    // Reduce the vector sum to a single scalar value.\n    // svaddv_s32 sums all elements in the vector.\n    // svptrue_b32() ensures all lanes are considered for the final reduction,\n    // as sve_total_sum_vec contains the accumulated sum across all lanes.\n    int final_scalar_sum = svaddv_s32(svptrue_b32(), sve_total_sum_vec);\n\n    return final_scalar_sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int total_sum = 0;\n    long int n = lst.size();\n    long int i = 0;\n\n    svbool_t pg; // Predicate register\n\n    // Loop through the vector in chunks of SVE vector length\n    for (i = 0; i < n; i += svcntw()) {\n        // Create a predicate for active lanes based on remaining elements\n        // This handles the tail end of the vector where the number of elements\n        // is less than the full SVE vector length.\n        pg = svwhilelt_b32(i, n);\n\n        // If no lanes are active, it means we've processed all elements or the vector is empty.\n        // Break the loop.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load the current chunk of data into an SVE vector\n        svint32_t data_vec = svld1_s32(pg, &lst[i]);\n\n        // Generate a vector of global indices for the current SVE vector block.\n        // svindex_s32(0, 1) creates [0, 1, 2, ..., VL-1]\n        // svdup_s32(i) creates [i, i, i, ..., i]\n        // Adding them gives [i, i+1, i+2, ..., i+VL-1]\n        svint32_t base_indices = svindex_s32(0, 1);\n        svint32_t global_indices = svadd_s32(base_indices, svdup_s32(i));\n\n        // Create a predicate for elements at odd indices.\n        // An index is odd if (index % 2) != 0, which is equivalent to (index & 1) == 1.\n        svint32_t odd_check = svand_s32_x(pg, global_indices, svdup_s32(1));\n        svbool_t odd_idx_pg = svcmpeq_s32(pg, odd_check, svdup_s32(1));\n\n        // Create a predicate for even-valued elements.\n        // A value is even if (value % 2) == 0, which is equivalent to (value & 1) == 0.\n        svint32_t even_check = svand_s32_x(pg, data_vec, svdup_s32(1));\n        svbool_t even_val_pg = svcmpeq_s32(pg, even_check, svdup_s32(0));\n\n        // Combine the two predicates: an element must be at an odd index AND be an even value.\n        svbool_t final_pg = svand_b(odd_idx_pg, even_val_pg);\n\n        // Perform a horizontal sum reduction on the elements that satisfy the final predicate.\n        // svaddv_s32 sums only the elements from data_vec where final_pg is true.\n        total_sum += svaddv_s32(final_pg, data_vec);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int total_sum = 0;\n    long n = lst.size();\n\n    // Loop through the vector in chunks of SVE vector length\n    for (long i = 0; i < n; i += svcntw()) {\n        // Get the predicate for the current chunk, handling partial vectors at the end\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current chunk of data into an SVE vector\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Generate a vector of indices for the current chunk\n        // Starts from 'i' and increments by 1 for each element\n        svint32_t indices = svindex_s32(i, 1);\n\n        // 1. Create predicate for odd indices: (index % 2 != 0)\n        //    - Compute index & 1. This will be 1 for odd, 0 for even.\n        svint32_t odd_idx_mask = svand_s32(pg, indices, svdup_s32(1));\n        //    - Compare if the result is not equal to 0 (i.e., it's 1, meaning odd)\n        svbool_t odd_idx_pred = svcmpne_s32(pg, odd_idx_mask, svdup_s32(0));\n\n        // 2. Create predicate for even values: (value % 2 == 0)\n        //    - Compute value & 1. This will be 1 for odd, 0 for even.\n        svint32_t even_val_mask = svand_s32(pg, vec, svdup_s32(1));\n        //    - Compare if the result is equal to 0 (i.e., it's 0, meaning even)\n        svbool_t even_val_pred = svcmpeq_s32(pg, even_val_mask, svdup_s32(0));\n\n        // Combine the two predicates: an element must satisfy BOTH conditions\n        svbool_t combined_pred = svand_b(pg, odd_idx_pred, even_val_pred);\n\n        // Select elements that satisfy the combined predicate.\n        // Elements that don't satisfy the predicate will be replaced with 0.\n        svint32_t selected_elements = svsel_s32(combined_pred, vec, svdup_s32(0));\n\n        // Sum the elements in the 'selected_elements' vector.\n        // Only active elements (those for which 'pg' is true) are considered.\n        total_sum += svaddv_s32(pg, selected_elements);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int total_sum = 0;\n    long n = lst.size();\n\n    // Initialize a vector sum accumulator with zeros.\n    // This accumulator will hold partial sums across vector lanes.\n    svint32_t vec_sum_acc = svdup_s32(0);\n\n    // Loop through the input vector in chunks determined by the SVE vector length (svcntw()).\n    // 'i' is the starting index for each chunk.\n    for (long i = 0; i < n; i += svcntw()) {\n        // Get a governing predicate for the current chunk.\n        // svwhilelt_b32(i, n) generates a predicate that is true for lanes\n        // where the element index (starting from 'i') is less than 'n'.\n        // This handles cases where the vector size is not a multiple of VL.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load elements from the input vector into an SVE vector.\n        // Only lanes where 'pg' is true will load valid data; others will be undisturbed.\n        svint32_t current_elements = svld1_s32(pg, &lst[i]);\n\n        // Generate a sequence of indices for the current chunk.\n        // svindex_s32(start, step) creates a vector where lane k contains (start + k * step).\n        // Here, it generates i, i+1, i+2, ... for the current chunk.\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // Predicate for even elements: (element & 1) == 0\n        // svand_s32 performs bitwise AND. svdup_s32(1) creates a vector of ones.\n        // svcmpeq_s32 compares for equality.\n        // 'pg' is used as the governing predicate to ensure comparisons only happen for valid elements.\n        svbool_t p_even = svcmpeq_s32(pg, svand_s32(current_elements, svdup_s32(1)), svdup_s32(0));\n\n        // Predicate for odd indices: (index & 1) != 0\n        // svcmpne_s32 compares for inequality.\n        // 'pg' is used as the governing predicate.\n        svbool_t p_odd_idx = svcmpne_s32(pg, svand_s32(current_indices, svdup_s32(1)), svdup_s32(0));\n\n        // Combine the two predicates: element must be even AND at an odd index.\n        // svand_b performs a bitwise AND on boolean predicates.\n        svbool_t p_active = svand_b(p_even, p_odd_idx);\n\n        // Add selected elements to the vector accumulator.\n        // svadd_s32_m(pg, op1, op2) performs op1 + op2 for lanes where 'pg' is true,\n        // otherwise, the corresponding lane in op1 is unchanged.\n        // Here, 'p_active' is used as the governing predicate, so only elements\n        // that satisfy both conditions (even and odd index) are added to vec_sum_acc.\n        vec_sum_acc = svadd_s32_m(p_active, vec_sum_acc, current_elements);\n    }\n\n    // Perform a horizontal sum of all elements in the vector accumulator.\n    // svaddv_s32 sums all active elements in a vector. svptrue_b32() ensures all lanes are active.\n    total_sum = svaddv_s32(svptrue_b32(), vec_sum_acc);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) {\n        return \"\";\n    }\n\n    std::string result = s; // Create a mutable copy of the input string\n\n    const uint8_t shift_amount = 4; // The alphabet shifts down by 2 * 2 = 4 places\n\n    // Iterate through the string in chunks of SVE vector length (svcntb() returns the number of bytes in a vector)\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b8 ensures that operations only apply to valid elements within the string bounds.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input string.\n        // Cast const char* to const uint8_t* as SVE intrinsics typically operate on unsigned types.\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Initialize the result vector for this chunk with the original characters.\n        // Characters that are not letters will retain their original value.\n        svuint8_t result_vec = vec;\n\n        // --- Process lowercase letters ---\n        // Create a mask for characters that are lowercase ('a' <= c <= 'z').\n        svbool_t lower_mask = svand_b(svcmpge_u8(pg, vec, 'a'), svcmple_u8(pg, vec, 'z'));\n\n        // Apply the shift to lowercase characters.\n        // svadd_u8_m conditionally adds 'shift_amount' to elements where 'lower_mask' is true.\n        svuint8_t shifted_lower_temp = svadd_u8_m(vec, lower_mask, shift_amount);\n\n        // Handle wrap-around for lowercase letters (e.g., 'y' + 4 should wrap to 'c').\n        // If a shifted character is greater than 'z', subtract 26 to wrap it around.\n        svbool_t lower_wrap_mask = svcmpgt_u8(lower_mask, shifted_lower_temp, 'z');\n        shifted_lower_temp = svsub_u8_m(shifted_lower_temp, lower_wrap_mask, 26);\n\n        // Select the shifted lowercase characters where 'lower_mask' is true,\n        // otherwise keep the current value in 'result_vec' (which is initially 'vec').\n        result_vec = svsel_u8(lower_mask, shifted_lower_temp, result_vec);\n\n        // --- Process uppercase letters ---\n        // Create a mask for characters that are uppercase ('A' <= c <= 'Z').\n        svbool_t upper_mask = svand_b(svcmpge_u8(pg, vec, 'A'), svcmple_u8(pg, vec, 'Z'));\n\n        // Apply the shift to uppercase characters.\n        svuint8_t shifted_upper_temp = svadd_u8_m(vec, upper_mask, shift_amount);\n\n        // Handle wrap-around for uppercase letters.\n        // If a shifted character is greater than 'Z', subtract 26.\n        svbool_t upper_wrap_mask = svcmpgt_u8(upper_mask, shifted_upper_temp, 'Z');\n        shifted_upper_temp = svsub_u8_m(shifted_upper_temp, upper_wrap_mask, 26);\n\n        // Select the shifted uppercase characters where 'upper_mask' is true,\n        // otherwise keep the current value in 'result_vec'.\n        result_vec = svsel_u8(upper_mask, shifted_upper_temp, result_vec);\n\n        // Store the processed vector back into the result string.\n        // Cast char* to uint8_t* for svst1_u8.\n        svst1_u8(pg, (uint8_t*)&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h> \n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s; // Create a mutable copy of the input string\n    size_t len = s.length();\n\n    // SVE constants for character processing\n    const svuint8_t vec_a = svdup_u8(0, 'a');\n    const svuint8_t vec_z = svdup_u8(0, 'z');\n    const svuint8_t vec_A = svdup_u8(0, 'A');\n    const svuint8_t vec_Z = svdup_u8(0, 'Z');\n    const svuint8_t vec_shift = svdup_u8(0, 4); // Shift by 2 * 2 = 4 places\n    const svuint8_t vec_26 = svdup_u8(0, 26);   // Alphabet size\n\n    // Iterate through the string in chunks of SVE vector length\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk, handling the tail end of the string\n        svbool_t pg = svwhilelt_b8(i, len); \n\n        // Load characters from the input string into an SVE vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // --- Process Lowercase Characters ---\n        // Predicate for characters that are 'a' through 'z'\n        svbool_t pg_lower = svand_b(svcmpge_u8(pg, chars, vec_a), svcmple_u8(pg, chars, vec_z));\n\n        // Calculate (char - 'a' + shift) for lowercase letters\n        svuint8_t lower_shifted_val = svadd_u8_m(pg_lower, svsub_u8_m(pg_lower, chars, vec_a), vec_shift);\n\n        // Handle wrap-around: if the shifted value is 26 or more, subtract 26\n        svbool_t lower_wrap = svcmpge_u8(pg_lower, lower_shifted_val, vec_26);\n        lower_shifted_val = svsub_u8_m(lower_wrap, lower_shifted_val, vec_26);\n\n        // Add 'a' back to get the final encrypted lowercase character\n        svuint8_t lower_final_chars = svadd_u8_m(pg_lower, lower_shifted_val, vec_a);\n\n        // --- Process Uppercase Characters ---\n        // Predicate for characters that are 'A' through 'Z'\n        svbool_t pg_upper = svand_b(svcmpge_u8(pg, chars, vec_A), svcmple_u8(pg, chars, vec_Z));\n\n        // Calculate (char - 'A' + shift) for uppercase letters\n        svuint8_t upper_shifted_val = svadd_u8_m(pg_upper, svsub_u8_m(pg_upper, chars, vec_A), vec_shift);\n\n        // Handle wrap-around: if the shifted value is 26 or more, subtract 26\n        svbool_t upper_wrap = svcmpge_u8(pg_upper, upper_shifted_val, vec_26);\n        upper_shifted_val = svsub_u8_m(upper_wrap, upper_shifted_val, vec_26);\n\n        // Add 'A' back to get the final encrypted uppercase character\n        svuint8_t upper_final_chars = svadd_u8_m(pg_upper, upper_shifted_val, vec_A);\n\n        // --- Combine Results ---\n        // Start with the original characters (non-alphabetic characters will remain unchanged)\n        svuint8_t encrypted_chars = chars;\n\n        // Selectively update characters that were identified as lowercase\n        encrypted_chars = svsel_u8(pg_lower, lower_final_chars, encrypted_chars);\n\n        // Selectively update characters that were identified as uppercase\n        // (Note: pg_lower and pg_upper are mutually exclusive, so no conflict here)\n        encrypted_chars = svsel_u8(pg_upper, upper_final_chars, encrypted_chars);\n\n        // Store the encrypted characters back to the result string\n        svst1_u8(pg, (uint8_t*)&result[i], encrypted_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstddef> // For size_t\n\n// Function to encrypt a string using SVE intrinsics\nstd::string encrypt_simd(const std::string & s) {\n    // Create a mutable copy of the input string to store the encrypted result\n    std::string result = s;\n    size_t len = s.length();\n\n    // Get raw pointers to the underlying character data for SVE operations\n    // Cast to uint8_t* as SVE intrinsics for bytes typically operate on uint8_t\n    const uint8_t* data_in = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* data_out = reinterpret_cast<uint8_t*>(result.data());\n\n    // Define the shift amount: 2 * 2 = 4\n    const uint8_t shift_amount = 4;\n\n    // Loop through the string in chunks, processing with SVE vectors\n    size_t i = 0;\n    while (i < len) {\n        // Generate a predicate for the current vector length (VL) for 8-bit elements.\n        // This predicate ensures that operations only apply to valid elements\n        // within the string's bounds, especially for the tail end.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input string\n        svuint8_t chars = svld1_u8(pg, data_in + i);\n\n        // Duplicate constants into SVE vectors for element-wise operations\n        svuint8_t a_val = svdup_n_u8('a');\n        svuint8_t z_val = svdup_n_u8('z');\n        svuint8_t A_val = svdup_n_u8('A');\n        svuint8_t Z_val = svdup_n_u8('Z');\n        svuint8_t shift_val = svdup_n_u8(shift_amount);\n        svuint8_t twenty_six = svdup_n_u8(26); // For modulo 26 arithmetic\n\n        // 1. Create predicates to identify lowercase and uppercase letters\n        // is_lower = (chars >= 'a') && (chars <= 'z')\n        svbool_t is_ge_a = svcmpge_u8(pg, chars, a_val);\n        svbool_t is_le_z = svcmple_u8(pg, chars, z_val);\n        svbool_t is_lower = svand_b(is_ge_a, is_le_z);\n\n        // is_upper = (chars >= 'A') && (chars <= 'Z')\n        svbool_t is_ge_A = svcmpge_u8(pg, chars, A_val);\n        svbool_t is_le_Z = svcmple_u8(pg, chars, Z_val);\n        svbool_t is_upper = svand_b(is_ge_A, is_le_Z);\n\n        // 2. Calculate the potential shifted value for lowercase letters\n        // This calculation is performed on all lanes, and results will be selected later.\n        // Formula: (char - 'a' + shift) % 26 + 'a'\n        svuint8_t temp_lower = svsub_u8(chars, a_val);     // char - 'a'\n        temp_lower = svadd_u8(temp_lower, shift_val);      // (char - 'a') + shift\n\n        // Apply modulo 26: if result >= 26, subtract 26\n        // Create a predicate for lanes where wrapping is needed (value >= 26)\n        svbool_t lower_wrap_cond = svcmpge_u8(pg, temp_lower, twenty_six);\n        // Apply subtraction only to the lanes identified by lower_wrap_cond\n        temp_lower = svsub_u8_x(lower_wrap_cond, temp_lower, twenty_six);\n        \n        temp_lower = svadd_u8(temp_lower, a_val);          // Add 'a' back to get the final character\n\n        // 3. Calculate the potential shifted value for uppercase letters\n        // This calculation is performed on all lanes, and results will be selected later.\n        // Formula: (char - 'A' + shift) % 26 + 'A'\n        svuint8_t temp_upper = svsub_u8(chars, A_val);     // char - 'A'\n        temp_upper = svadd_u8(temp_upper, shift_val);      // (char - 'A') + shift\n\n        // Apply modulo 26: if result >= 26, subtract 26\n        // Create a predicate for lanes where wrapping is needed (value >= 26)\n        svbool_t upper_wrap_cond = svcmpge_u8(pg, temp_upper, twenty_six);\n        // Apply subtraction only to the lanes identified by upper_wrap_cond\n        temp_upper = svsub_u8_x(upper_wrap_cond, temp_upper, twenty_six);\n        \n        temp_upper = svadd_u8(temp_upper, A_val);          // Add 'A' back to get the final character\n\n        // 4. Combine the results using conditional selection (svsel)\n        // Start with the original characters\n        svuint8_t processed_chars = chars;\n        // If a character is lowercase, replace it with its calculated 'temp_lower' value\n        processed_chars = svsel_u8(is_lower, temp_lower, processed_chars);\n        // If a character is uppercase, replace it with its calculated 'temp_upper' value\n        // (This will override if both were true, but is_lower and is_upper are mutually exclusive)\n        processed_chars = svsel_u8(is_upper, temp_upper, processed_chars);\n\n        // Store the processed characters back into the result string\n        svst1_u8(pg, data_out + i, processed_chars);\n\n        // Advance the index by the number of elements processed in this vector.\n        // svcntb() returns the current vector length in bytes (which is also the number of 8-bit elements).\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s; // Create a mutable copy of the input string\n\n    if (s.empty()) {\n        return result; // Return empty string if input is empty\n    }\n\n    // Define the shift amount (2 * 2 = 4)\n    const int shift_amount = 4;\n\n    // Duplicate scalar constants into SVE vectors for efficient use\n    // svptrue_b8() creates an all-true predicate for the current vector length\n    const svuint8_t v_shift = svdup_u8(svptrue_b8(), shift_amount);\n    const svuint8_t v_26 = svdup_u8(svptrue_b8(), 26); // For wrap-around (26 letters in alphabet)\n\n    // ASCII values for 'a', 'z', 'A', 'Z'\n    const svuint8_t v_a_lower = svdup_u8(svptrue_b8(), 'a');\n    const svuint8_t v_z_lower = svdup_u8(svptrue_b8(), 'z');\n    const svuint8_t v_a_upper = svdup_u8(svptrue_b8(), 'A');\n    const svuint8_t v_z_upper = svdup_u8(svptrue_b8(), 'Z');\n\n    // Loop through the string in chunks of SVE vector length (svcntb() bytes)\n    for (size_t i = 0; i < s.length(); i += svcntb()) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b8(i, s.length()) generates a predicate that is true for elements\n        // within the string bounds and false for elements beyond. This handles tail processing.\n        svbool_t pg = svwhilelt_b8(i, s.length());\n\n        // Load characters from the input string into an SVE vector\n        // reinterpret_cast is used to safely cast char* to uint8_t* for SVE intrinsics\n        svuint8_t v_chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Initialize the result vector with the original characters.\n        // Non-alphabetic characters will retain their original value by default.\n        svuint8_t v_res = v_chars;\n\n        // --- Process lowercase letters ---\n        // Create a predicate for lowercase letters within the current chunk.\n        // This predicate is true for elements where 'v_chars' is >= 'a' AND <= 'z'.\n        svbool_t pg_lower = svand_b(svcmpge_u8(pg, v_chars, v_a_lower), svcmple_u8(pg, v_chars, v_z_lower));\n\n        // Calculate the shifted value for all characters.\n        // This operation is performed on all lanes, but only active lanes (governed by 'pg')\n        // will have their results potentially used later.\n        svuint8_t v_shifted_lower = svadd_u8(v_chars, v_shift);\n\n        // Create a predicate for lowercase characters that need to wrap around.\n        // This predicate is true for elements that are both 'pg_lower' (lowercase)\n        // AND 'v_shifted_lower' is greater than 'z'.\n        // The 'pg_lower' as the first argument ensures this comparison only happens for lowercase letters.\n        svbool_t pg_lower_wrap = svcmpgt_u8(pg_lower, v_shifted_lower, v_z_lower);\n\n        // Apply wrap-around: subtract 26 from characters that went past 'z'.\n        // This operation is masked by 'pg_lower_wrap', meaning it only affects\n        // the elements that require wrapping.\n        v_shifted_lower = svsub_u8_m(pg_lower_wrap, v_shifted_lower, v_26);\n\n        // Select the correctly shifted values for lowercase characters.\n        // For elements where 'pg_lower' is true, take 'v_shifted_lower'.\n        // Otherwise, keep the current value in 'v_res' (which is 'v_chars' at this point).\n        v_res = svsel_u8(pg_lower, v_shifted_lower, v_res);\n\n        // --- Process uppercase letters ---\n        // Create a predicate for uppercase letters within the current chunk.\n        // Similar to lowercase, this is true for elements where 'v_chars' is >= 'A' AND <= 'Z'.\n        svbool_t pg_upper = svand_b(svcmpge_u8(pg, v_chars, v_a_upper), svcmple_u8(pg, v_chars, v_z_upper));\n\n        // Calculate the shifted value for all characters.\n        // 'v_chars' is the original input, so this calculation is independent of the lowercase processing.\n        svuint8_t v_shifted_upper = svadd_u8(v_chars, v_shift);\n\n        // Create a predicate for uppercase characters that need to wrap around.\n        // Similar to lowercase, this is true for elements that are both 'pg_upper'\n        // AND 'v_shifted_upper' is greater than 'Z'.\n        svbool_t pg_upper_wrap = svcmpgt_u8(pg_upper, v_shifted_upper, v_z_upper);\n\n        // Apply wrap-around: subtract 26 from characters that went past 'Z'.\n        // This operation is masked by 'pg_upper_wrap'.\n        v_shifted_upper = svsub_u8_m(pg_upper_wrap, v_shifted_upper, v_26);\n\n        // Select the correctly shifted values for uppercase characters.\n        // For elements where 'pg_upper' is true, take 'v_shifted_upper'.\n        // Otherwise, keep the current value in 'v_res'.\n        // Since a character cannot be both lowercase and uppercase, applying these\n        // selections sequentially is correct.\n        v_res = svsel_u8(pg_upper, v_shifted_upper, v_res);\n\n        // Store the processed characters back into the result string.\n        // The 'pg' predicate ensures that only valid characters within the string bounds are written.\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), v_res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    // Create a mutable copy of the input string to store the encrypted result\n    std::string result = s;\n    size_t len = s.length();\n\n    // Define the shift amount (2 * 2 = 4) and alphabet size\n    const uint8_t shift_amount = 4;\n    const uint8_t alphabet_size = 26;\n    const uint8_t char_a = 'a';\n    const uint8_t char_z = 'z';\n\n    // Loop through the string in SVE vector chunks\n    // svcntb() returns the number of 8-bit elements (bytes) in an SVE vector\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Get the predicate for the current vector length\n        // svwhilelt_b8 generates a predicate that is true for elements\n        // where the current index (i + element_offset) is less than 'len'.\n        // This ensures we only process valid characters within the string bounds.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector of 8-bit unsigned integers\n        svuint8_t vec_chars = svld1_u8(pg, (const uint8_t*)&result[i]);\n\n        // Duplicate constants into SVE vectors for element-wise operations\n        svuint8_t vec_char_a = svdup_u8(pg, char_a);\n        svuint8_t vec_char_z = svdup_u8(pg, char_z);\n        svuint8_t vec_shift_amount = svdup_u8(pg, shift_amount);\n        svuint8_t vec_alphabet_size = svdup_u8(pg, alphabet_size);\n\n        // 1. Create a mask for lowercase letters ('a' through 'z')\n        // svcmpge_u8: compare greater than or equal\n        // svcmple_u8: compare less than or equal\n        svbool_t is_lower_ge_a = svcmpge_u8(pg, vec_chars, vec_char_a);\n        svbool_t is_lower_le_z = svcmple_u8(pg, vec_chars, vec_char_z);\n        // svand_b: bitwise AND for boolean predicates\n        svbool_t is_lower_alpha = svand_b(is_lower_ge_a, is_lower_le_z);\n\n        // 2. Subtract 'a' to convert characters to a 0-25 range (0 for 'a', 1 for 'b', etc.)\n        // svsub_u8_m: masked subtraction. Operation only applies to elements where 'is_lower_alpha' is true.\n        // For elements where 'is_lower_alpha' is false, the original 'vec_chars' value is retained.\n        svuint8_t relative_chars = svsub_u8_m(vec_chars, is_lower_alpha, vec_char_a);\n\n        // 3. Add the shift amount to the relative character values\n        // svadd_u8_m: masked addition. Applies only to lowercase letters.\n        svuint8_t shifted_relative = svadd_u8_m(relative_chars, is_lower_alpha, vec_shift_amount);\n\n        // 4. Handle wrap-around (modulo 26) for characters that shifted past 'z'\n        // svcmpge_u8: check if shifted_relative is >= 26. This predicate is only active for lowercase letters.\n        svbool_t needs_wrap = svcmpge_u8(is_lower_alpha, shifted_relative, vec_alphabet_size);\n        // svsub_u8_m: subtract 26 from elements that need to wrap around.\n        shifted_relative = svsub_u8_m(shifted_relative, needs_wrap, vec_alphabet_size);\n\n        // 5. Add 'a' back to convert from the 0-25 range back to ASCII character codes\n        // svadd_u8_m: masked addition. Applies only to lowercase letters.\n        svuint8_t encrypted_chars = svadd_u8_m(shifted_relative, is_lower_alpha, vec_char_a);\n\n        // 6. Select between the original character and the encrypted character\n        // svsel_u8: selects elements based on the predicate.\n        // If 'is_lower_alpha' is true, take from 'encrypted_chars'; otherwise, take from 'vec_chars' (original).\n        svuint8_t final_chars = svsel_u8(is_lower_alpha, encrypted_chars, vec_chars);\n\n        // Store the processed characters back into the result string\n        // svst1_u8: stores 8-bit unsigned integers from the SVE vector to memory.\n        // The predicate 'pg' ensures that only valid string characters are written.\n        svst1_u8(pg, (uint8_t*)&result[i], final_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message; // Create a mutable copy of the input string\n    size_t len = message.length();\n\n    // Duplicate constants into SVE vectors once outside the loop\n    const svuint8_t const_32 = svdup_u8(32); // For case swapping\n    const svuint8_t const_2 = svdup_u8(2);   // For vowel replacement\n\n    // Duplicate vowel characters into SVE vectors for comparison\n    const svuint8_t char_A = svdup_u8('A');\n    const svuint8_t char_E = svdup_u8('E');\n    const svuint8_t char_I = svdup_u8('I');\n    const svuint8_t char_O = svdup_u8('O');\n    const svuint8_t char_U = svdup_u8('U');\n    const svuint8_t char_a = svdup_u8('a');\n    const svuint8_t char_e = svdup_u8('e');\n    const svuint8_t char_i = svdup_u8('i');\n    const svuint8_t char_o = svdup_u8('o');\n    const svuint8_t char_u = svdup_u8('u');\n\n    // Duplicate character range boundaries for case checking\n    const svuint8_t char_lower_a = svdup_u8('a');\n    const svuint8_t char_lower_z = svdup_u8('z');\n    const svuint8_t char_upper_A = svdup_u8('A');\n    const svuint8_t char_upper_Z = svdup_u8('Z');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Get a predicate for the current vector length, handling the tail\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the message\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        // 1. Case Swapping:\n        // Create predicate for lowercase letters ('a' through 'z')\n        svbool_t is_lower = svand_b(svcmpge_u8(pg, vec, char_lower_a), svcmple_u8(pg, vec, char_lower_z));\n        // Create predicate for uppercase letters ('A' through 'Z')\n        svbool_t is_upper = svand_b(svcmpge_u8(pg, vec, char_upper_A), svcmple_u8(pg, vec, char_upper_Z));\n\n        // Apply case swap: subtract 32 for lowercase to uppercase\n        vec = svsub_u8_x(is_lower, vec, const_32);\n        // Apply case swap: add 32 for uppercase to lowercase\n        vec = svadd_u8_x(is_upper, vec, const_32);\n\n        // 2. Vowel Replacement (applied to the potentially case-swapped characters):\n        // Create predicates for each vowel (both cases)\n        svbool_t is_vowel_A = svcmpeq_u8(pg, vec, char_A);\n        svbool_t is_vowel_E = svcmpeq_u8(pg, vec, char_E);\n        svbool_t is_vowel_I = svcmpeq_u8(pg, vec, char_I);\n        svbool_t is_vowel_O = svcmpeq_u8(pg, vec, char_O);\n        svbool_t is_vowel_U = svcmpeq_u8(pg, vec, char_U);\n        svbool_t is_vowel_a = svcmpeq_u8(pg, vec, char_a);\n        svbool_t is_vowel_e = svcmpeq_u8(pg, vec, char_e);\n        svbool_t is_vowel_i = svcmpeq_u8(pg, vec, char_i);\n        svbool_t is_vowel_o = svcmpeq_u8(pg, vec, char_o);\n        svbool_t is_vowel_u = svcmpeq_u8(pg, vec, char_u);\n\n        // Combine all vowel predicates using logical OR\n        svbool_t is_vowel_combined = svorr_b(is_vowel_A, is_vowel_E);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_I);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_O);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_U);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_a);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_e);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_i);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_o);\n        is_vowel_combined = svorr_b(is_vowel_combined, is_vowel_u);\n\n        // Apply vowel replacement: add 2 to characters identified as vowels\n        vec = svadd_u8_x(is_vowel_combined, vec, const_2);\n\n        // Store the modified vector back to the result string\n        svst1_u8(pg, (uint8_t*)&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstddef> // For size_t\n#include <stdint.h> // For uint8_t\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result = message; // Create a mutable copy for modification\n\n    // Get SVE vector length in bytes\n    size_t sv_len_bytes = svcntb();\n\n    // Constants for SVE operations, duplicated once outside the loop\n    svuint8_t thirty_two = svdup_u8(32); // For case swapping (XOR with 32)\n    svuint8_t two = svdup_u8(2);         // For vowel replacement (add 2)\n\n    // Loop through the string in chunks of sv_len_bytes\n    for (size_t i = 0; i < len; i += sv_len_bytes) {\n        // Create a predicate for the current chunk, handling the tail (remaining characters)\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load original characters from the message\n        svuint8_t chars_orig = svld1_u8(pg, (const uint8_t*)&message[i]);\n        // Initialize chars_processed with original characters; this vector will be modified\n        svuint8_t chars_processed = chars_orig;\n\n        // --- Step 1: Identify vowels in original characters ---\n        // Create predicates for each vowel (case-sensitive)\n        svbool_t is_vowel_a = svcmpeq_u8(pg, chars_orig, 'a');\n        svbool_t is_vowel_e = svcmpeq_u8(pg, chars_orig, 'e');\n        svbool_t is_vowel_i = svcmpeq_u8(pg, chars_orig, 'i');\n        svbool_t is_vowel_o = svcmpeq_u8(pg, chars_orig, 'o');\n        svbool_t is_vowel_u = svcmpeq_u8(pg, chars_orig, 'u');\n\n        svbool_t is_vowel_A = svcmpeq_u8(pg, chars_orig, 'A');\n        svbool_t is_vowel_E = svcmpeq_u8(pg, chars_orig, 'E');\n        svbool_t is_vowel_I = svcmpeq_u8(pg, chars_orig, 'I');\n        svbool_t is_vowel_O = svcmpeq_u8(pg, chars_orig, 'O');\n        svbool_t is_vowel_U = svcmpeq_u8(pg, chars_orig, 'U');\n\n        // Combine all vowel predicates into a single 'is_vowel_orig' predicate\n        svbool_t is_vowel_orig = svorr_b(is_vowel_a, is_vowel_e);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_i);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_o);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_u);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_A);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_E);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_I);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_O);\n        is_vowel_orig = svorr_b(is_vowel_orig, is_vowel_U);\n\n        // --- Step 2: Perform case swapping on all letters in chars_processed ---\n        // Identify uppercase letters in the current chars_processed vector\n        svbool_t is_alpha_upper = svand_b(pg, svcmpge_u8(pg, chars_processed, 'A'), svcmple_u8(pg, chars_processed, 'Z'));\n        // Identify lowercase letters in the current chars_processed vector\n        svbool_t is_alpha_lower = svand_b(pg, svcmpge_u8(pg, chars_processed, 'a'), svcmple_u8(pg, chars_processed, 'z'));\n        // Combine to get a predicate for all letters (both upper and lower case)\n        svbool_t is_letter = svorr_b(is_alpha_upper, is_alpha_lower);\n\n        // Apply XOR with 32 to swap case for characters identified as letters\n        // Characters not identified as letters (e.g., spaces) remain unchanged\n        chars_processed = svxor_u8_x(is_letter, chars_processed, thirty_two);\n\n        // --- Step 3: Apply vowel replacement to chars_processed if it was an original vowel ---\n        // Add 2 to characters that were identified as original vowels.\n        // This operation is applied to the *already case-swapped* characters.\n        chars_processed = svadd_u8_x(is_vowel_orig, chars_processed, two);\n\n        // Store the processed characters back into the result string\n        svst1_u8(pg, (uint8_t*)&result[i], chars_processed);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message; // Create a mutable copy of the message\n\n    size_t len = message.length();\n    if (len == 0) {\n        return result;\n    }\n\n    // Define SVE vector constants for operations\n    const svuint8_t val_2 = svdup_u8(2);\n    const svuint8_t val_32 = svdup_u8(32); // ASCII difference between upper/lower case\n\n    // Define SVE vector constants for vowel checks\n    const svuint8_t char_a = svdup_u8(97);  // 'a'\n    const svuint8_t char_e = svdup_u8(101); // 'e'\n    const svuint8_t char_i = svdup_u8(105); // 'i'\n    const svuint8_t char_o = svdup_u8(111); // 'o'\n    const svuint8_t char_u = svdup_u8(117); // 'u'\n\n    const svuint8_t char_A = svdup_u8(65);  // 'A'\n    const svuint8_t char_E = svdup_u8(69);  // 'E'\n    const svuint8_t char_I = svdup_u8(73);  // 'I'\n    const svuint8_t char_O = svdup_u8(79);  // 'O'\n    const svuint8_t char_U = svdup_u8(85);  // 'U'\n\n    // Define SVE vector constants for letter range checks\n    const svuint8_t char_lower_min = svdup_u8(97);  // 'a'\n    const svuint8_t char_lower_max = svdup_u8(122); // 'z'\n    const svuint8_t char_upper_min = svdup_u8(65);  // 'A'\n    const svuint8_t char_upper_max = svdup_u8(90);  // 'Z'\n\n    // Loop through the string in chunks of SVE vector length (VL)\n    // svcntb() returns the number of bytes in an SVE vector\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Get the active predicate for the current chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the string bounds, handling the tail end of the string.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the message into an SVE vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        // --- Step 1: Vowel Replacement ---\n        // Identify lowercase vowels using equality comparisons\n        svbool_t is_a = svcmpeq_u8(pg, chars, char_a);\n        svbool_t is_e = svcmpeq_u8(pg, chars, char_e);\n        svbool_t is_i = svcmpeq_u8(pg, chars, char_i);\n        svbool_t is_o = svcmpeq_u8(pg, chars, char_o);\n        svbool_t is_u = svcmpeq_u8(pg, chars, char_u);\n        // Combine all lowercase vowel predicates using OR operations\n        svbool_t is_lower_vowel = svorr_b(is_a, svorr_b(is_e, svorr_b(is_i, svorr_b(is_o, is_u))));\n\n        // Identify uppercase vowels\n        svbool_t is_A = svcmpeq_u8(pg, chars, char_A);\n        svbool_t is_E = svcmpeq_u8(pg, chars, char_E);\n        svbool_t is_I = svcmpeq_u8(pg, chars, char_I);\n        svbool_t is_O = svcmpeq_u8(pg, chars, char_O);\n        svbool_t is_U = svcmpeq_u8(pg, chars, char_U);\n        // Combine all uppercase vowel predicates\n        svbool_t is_upper_vowel = svorr_b(is_A, svorr_b(is_E, svorr_b(is_I, svorr_b(is_O, is_U))));\n\n        // Combine predicates for all vowels (case-insensitive)\n        svbool_t is_vowel = svorr_b(is_lower_vowel, is_upper_vowel);\n\n        // Add 2 to the ASCII value of characters identified as vowels.\n        // This effectively replaces the vowel with the letter 2 places ahead.\n        // The operation is predicated by 'is_vowel', so only vowels are modified.\n        chars = svadd_u8_m(chars, is_vowel, val_2);\n\n        // --- Step 2: Case Swapping ---\n        // IMPORTANT: The predicates for case swapping must be calculated based on the\n        // character's state *after* vowel replacement but *before* any case changes.\n        // 'chars' now holds the potentially vowel-replaced values.\n\n        // Identify lowercase letters (e.g., 'a' through 'z')\n        svbool_t is_lower_after_vowel_replace = svand_b(svcmpge_u8(pg, chars, char_lower_min),\n                                                        svcmple_u8(pg, chars, char_lower_max));\n\n        // Identify uppercase letters (e.g., 'A' through 'Z')\n        svbool_t is_upper_after_vowel_replace = svand_b(svcmpge_u8(pg, chars, char_upper_min),\n                                                        svcmple_u8(pg, chars, char_upper_max));\n\n        // Convert lowercase letters to uppercase: subtract 32 from ASCII value.\n        // This operation is predicated by 'is_lower_after_vowel_replace'.\n        chars = svsub_u8_m(chars, is_lower_after_vowel_replace, val_32);\n\n        // Convert uppercase letters to lowercase: add 32 to ASCII value.\n        // This operation is predicated by 'is_upper_after_vowel_replace'.\n        chars = svadd_u8_m(chars, is_upper_after_vowel_replace, val_32);\n\n        // Store the modified characters back into the result string\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <string>\n#include <arm_sve.h>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    if (len == 0) {\n        return \"\";\n    }\n\n    // Pre-allocate result string with the same length as the input message.\n    std::string result(len, ' ');\n\n    // Get the vector length for 8-bit elements (characters).\n    size_t sv_len = svcntb();\n\n    // Initialize SVE vector constants once outside the loop.\n    // These will be broadcast to all lanes of the vector.\n    svuint8_t A_val = svdup_u8('A');\n    svuint8_t Z_val = svdup_u8('Z');\n    svuint8_t a_val = svdup_u8('a');\n    svuint8_t z_val = svdup_u8('z');\n    svuint8_t case_diff = svdup_u8(32); // ASCII difference between 'A'/'a'\n    svuint8_t two_val = svdup_u8(2);   // Value to add for vowel replacement\n\n    // Vowel constants for comparison\n    svuint8_t val_A = svdup_u8('A');\n    svuint8_t val_E = svdup_u8('E');\n    svuint8_t val_I = svdup_u8('I');\n    svuint8_t val_O = svdup_u8('O');\n    svuint8_t val_U = svdup_u8('U');\n    svuint8_t val_a = svdup_u8('a');\n    svuint8_t val_e = svdup_u8('e');\n    svuint8_t val_i = svdup_u8('i');\n    svuint8_t val_o = svdup_u8('o');\n    svuint8_t val_u = svdup_u8('u');\n\n    // Loop through the message in chunks of SVE vector length.\n    for (size_t i = 0; i < len; i += sv_len) {\n        // Create a predicate for the current chunk.\n        // This handles the tail end of the string where the number of elements\n        // might be less than the full vector length.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load original characters from the message into an SVE vector.\n        svuint8_t orig_vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        // Step 1: Detect vowels in their original case.\n        // Initialize a predicate to false for all lanes.\n        svbool_t is_vowel_orig = svdup_b(false);\n\n        // Use logical OR to combine predicates for each vowel.\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_A));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_E));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_I));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_O));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_U));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_a));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_e));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_i));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_o));\n        is_vowel_orig = svorr_b(is_vowel_orig, svcmpeq_u8(pg, orig_vec, val_u));\n\n        // Start with the original vector for subsequent processing steps.\n        svuint8_t processed_vec = orig_vec;\n\n        // Step 2: Swap case of all letters.\n        // Create predicates for uppercase and lowercase letters.\n        svbool_t is_upper = svand_b(svcmpge_u8(pg, processed_vec, A_val), svcmple_u8(pg, processed_vec, Z_val));\n        svbool_t is_lower = svand_b(svcmpge_u8(pg, processed_vec, a_val), svcmple_u8(pg, processed_vec, z_val));\n\n        // Apply case swap:\n        // If a character is uppercase, add 32 to make it lowercase.\n        processed_vec = svadd_u8_m(processed_vec, is_upper, processed_vec, case_diff);\n        // If a character is lowercase, subtract 32 to make it uppercase.\n        processed_vec = svsub_u8_m(processed_vec, is_lower, processed_vec, case_diff);\n\n        // Step 3: If the character was an original vowel, add 2 to its value.\n        // This applies to the character after its case has been swapped.\n        processed_vec = svadd_u8_m(processed_vec, is_vowel_orig, processed_vec, two_val);\n\n        // Store the processed characters back into the result string.\n        svst1_u8(pg, (uint8_t*)&result[i], processed_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cstdint> // For uint8_t\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message; // Create a mutable copy of the message\n    size_t len = message.length();\n    size_t i = 0;\n\n    // Get the vector length in bytes for char (8-bit)\n    size_t sv_len = svcntb();\n\n    // Define constant vectors once outside the loop for efficiency\n    const svuint8_t const_2 = svdup_u8(2);\n    const svuint8_t const_32 = svdup_u8(32);\n\n    // Vowel constants\n    const svuint8_t const_a = svdup_u8('a');\n    const svuint8_t const_e = svdup_u8('e');\n    const svuint8_t const_i = svdup_u8('i');\n    const svuint8_t const_o = svdup_u8('o');\n    const svuint8_t const_u = svdup_u8('u');\n\n    const svuint8_t const_A = svdup_u8('A');\n    const svuint8_t const_E = svdup_u8('E');\n    const svuint8_t const_I = svdup_u8('I');\n    const svuint8_t const_O = svdup_u8('O');\n    const svuint8_t const_U = svdup_u8('U');\n\n    // Letter range constants\n    const svuint8_t const_lower_a = svdup_u8('a');\n    const svuint8_t const_lower_z = svdup_u8('z');\n    const svuint8_t const_upper_A = svdup_u8('A');\n    const svuint8_t const_upper_Z = svdup_u8('Z');\n\n    while (i < len) {\n        // 1. Create a predicate for the current chunk\n        // This predicate ensures we only process valid characters up to the string end.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // If no elements are active under the predicate, we've processed the entire string.\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // 2. Load the characters into an SVE vector\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        // --- Vowel Replacement Logic ---\n        // Create predicates for lowercase vowels\n        svbool_t is_a_lc = svcmpeq(pg, vec, const_a);\n        svbool_t is_e_lc = svcmpeq(pg, vec, const_e);\n        svbool_t is_i_lc = svcmpeq(pg, vec, const_i);\n        svbool_t is_o_lc = svcmpeq(pg, vec, const_o);\n        svbool_t is_u_lc = svcmpeq(pg, vec, const_u);\n        svbool_t is_vowel_lc = svorr_b(svorr_b(is_a_lc, is_e_lc), svorr_b(svorr_b(is_i_lc, is_o_lc), is_u_lc));\n\n        // Create predicates for uppercase vowels\n        svbool_t is_A_uc = svcmpeq(pg, vec, const_A);\n        svbool_t is_E_uc = svcmpeq(pg, vec, const_E);\n        svbool_t is_I_uc = svcmpeq(pg, vec, const_I);\n        svbool_t is_O_uc = svcmpeq(pg, vec, const_O);\n        svbool_t is_U_uc = svcmpeq(pg, vec, const_U);\n        svbool_t is_vowel_uc = svorr_b(svorr_b(is_A_uc, is_E_uc), svorr_b(svorr_b(is_I_uc, is_O_uc), is_U_uc));\n\n        // Combine predicates to identify any vowel (lowercase or uppercase)\n        svbool_t is_vowel_overall = svorr_b(is_vowel_lc, is_vowel_uc);\n\n        // Add 2 to characters identified as vowels.\n        // svadd_u8_m(inactive, predicate, op1, op2) performs: result = predicate ? (op1 + op2) : inactive\n        // Here, if 'is_vowel_overall' is true, add 'const_2' to 'vec'; otherwise, keep 'vec' unchanged.\n        svuint8_t shifted_vec = svadd_u8_m(vec, is_vowel_overall, vec, const_2);\n\n        // --- Case Swapping Logic ---\n        // Identify lowercase letters in the 'shifted_vec'\n        svbool_t is_lc_shifted = svand_b(svcmpge(pg, shifted_vec, const_lower_a), svcmple(pg, shifted_vec, const_lower_z));\n        // Identify uppercase letters in the 'shifted_vec'\n        svbool_t is_uc_shifted = svand_b(svcmpge(pg, shifted_vec, const_upper_A), svcmple(pg, shifted_vec, const_upper_Z));\n\n        // Apply case swap conditionally.\n        // If 'is_lc_shifted' is true, subtract 32 to convert to uppercase.\n        // Otherwise, keep 'shifted_vec' unchanged.\n        svuint8_t final_vec = svsub_u8_m(shifted_vec, is_lc_shifted, shifted_vec, const_32);\n        \n        // If 'is_uc_shifted' is true, add 32 to convert to lowercase.\n        // This operation uses the result of the previous step ('final_vec') as its base.\n        // Since a character cannot be both lowercase and uppercase, these two operations are independent.\n        final_vec = svadd_u8_m(final_vec, is_uc_shifted, final_vec, const_32);\n\n        // 3. Store the result back to the string\n        svst1_u8(pg, (uint8_t*)&result[i], final_vec);\n\n        // 4. Advance the index by the vector length\n        i += sv_len;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\n// Enum to categorize string case type\nenum StringCaseType {\n    ALL_LOWER,\n    ALL_UPPER,\n    MIXED_OR_NON_ALPHA\n};\n\n// Helper function to determine the case type of a single string using SVE\nstatic StringCaseType get_string_case_type(const std::string& s) {\n    if (s.empty()) {\n        return MIXED_OR_NON_ALPHA; // Empty string is not considered all lower or all upper\n    }\n\n    bool has_lower = false;\n    bool has_upper = false;\n    bool has_non_alpha = false;\n\n    size_t vl = svcntb(); // Get SVE vector length in bytes (number of 8-bit elements)\n    size_t len = s.length();\n\n    for (size_t i = 0; i < len; i += vl) {\n        // Create a predicate for the current chunk of characters\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters into an SVE vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data() + i);\n\n        // --- Check for lowercase characters ---\n        svuint8_t lower_a = svdup_u8(pg, 'a');\n        svuint8_t upper_z = svdup_u8(pg, 'z');\n        svbool_t is_lower_char = svand_b(svcmpge(pg, chars, lower_a), svcmple(pg, chars, upper_z));\n        if (svptest_any(pg, is_lower_char)) {\n            has_lower = true;\n        }\n\n        // --- Check for uppercase characters ---\n        svuint8_t lower_A = svdup_u8(pg, 'A');\n        svuint8_t upper_Z = svdup_u8(pg, 'Z');\n        svbool_t is_upper_char = svand_b(svcmpge(pg, chars, lower_A), svcmple(pg, chars, upper_Z));\n        if (svptest_any(pg, is_upper_char)) {\n            has_upper = true;\n        }\n\n        // --- Check for non-alphabetic characters ---\n        // A character is alphabetic if it's either lowercase or uppercase\n        svbool_t is_alpha_char = svor_b(is_lower_char, is_upper_char);\n        // A character is non-alphabetic if it's NOT alphabetic (within the active predicate)\n        svbool_t is_non_alpha_char = svnot_b(pg, is_alpha_char);\n        if (svptest_any(pg, is_non_alpha_char)) {\n            has_non_alpha = true;\n        }\n    }\n\n    // Determine the overall string case type based on flags\n    if (has_non_alpha || (has_lower && has_upper)) {\n        return MIXED_OR_NON_ALPHA;\n    } else if (has_lower) {\n        return ALL_LOWER;\n    } else if (has_upper) {\n        return ALL_UPPER;\n    } else {\n        // This path is reached if the string contains no alphabetic characters\n        // (e.g., \"123\", \"!@#\"). Based on examples, these are considered invalid.\n        return MIXED_OR_NON_ALPHA;\n    }\n}\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_keys_are_lower = true;\n    bool all_keys_are_upper = true;\n\n    for (const auto& pair : dict) {\n        StringCaseType key_case = get_string_case_type(pair.first);\n\n        if (key_case == MIXED_OR_NON_ALPHA) {\n            // If any key is mixed case or contains non-alphabetic characters,\n            // then neither \"all lower\" nor \"all upper\" condition can be met.\n            return false;\n        } else if (key_case == ALL_LOWER) {\n            // If we found a lowercase key, it cannot be \"all upper\"\n            all_keys_are_upper = false;\n        } else if (key_case == ALL_UPPER) {\n            // If we found an uppercase key, it cannot be \"all lower\"\n            all_keys_are_lower = false;\n        }\n\n        // Optimization: if both flags become false, we can stop early\n        if (!all_keys_are_lower && !all_keys_are_upper) {\n            return false;\n        }\n    }\n\n    // Return true if either all keys were lowercase OR all keys were uppercase\n    return all_keys_are_lower || all_keys_are_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\n// Helper function to check the case of a single string using SVE intrinsics.\n// It determines if a string is entirely lowercase, entirely uppercase, or invalid (mixed case,\n// contains non-alphabetic characters, or is empty).\n// Returns true if the key is valid (all lower or all upper), and sets is_lower_out/is_upper_out accordingly.\n// Returns false if the key is invalid.\nbool check_key_case_sve(const std::string& key, bool& is_lower_out, bool& is_upper_out) {\n    is_lower_out = true; // Assume the key is all lowercase until proven otherwise\n    is_upper_out = true; // Assume the key is all uppercase until proven otherwise\n\n    size_t len = key.length();\n    if (len == 0) {\n        return false; // An empty key is considered invalid for this problem's criteria\n    }\n\n    // Cast string data to uint8_t* for SVE byte-wise operations\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(key.data());\n    size_t i = 0;\n    // Create a predicate for byte-wise processing, active for elements within the string's length\n    svbool_t pg = svwhilelt_b8(i, len);\n\n    // Loop while there are active elements in the predicate (i.e., more characters to process)\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into an SVE vector using the current predicate\n        svuint8_t chars = svld1_u8(pg, data + i);\n\n        // Create a mask for characters that are within the 'a'-'z' range (lowercase)\n        svbool_t is_lower_char_mask = svand_b(svcmpge_u8(pg, chars, 'a'), svcmple_u8(pg, chars, 'z'));\n        // Create a mask for characters that are within the 'A'-'Z' range (uppercase)\n        svbool_t is_upper_char_mask = svand_b(svcmpge_u8(pg, chars, 'A'), svcmple_u8(pg, chars, 'Z'));\n\n        // Combine masks to identify all alphabetic characters\n        svbool_t is_alpha_char_mask = svorr_b(is_lower_char_mask, is_upper_char_mask);\n\n        // Check if any active character is NOT alphabetic (e.g., a digit, symbol, or space)\n        // svnot_b(is_alpha_char_mask) inverts the predicate bits.\n        // svptest_any(pg, ...) checks if any bit is set in the inverted mask AND the corresponding bit in 'pg' is also set.\n        if (svptest_any(pg, svnot_b(is_alpha_char_mask))) {\n            return false; // Found a non-alphabetic character, so the key is invalid\n        }\n\n        // If any active character is uppercase, then the key cannot be considered entirely lowercase\n        if (svptest_any(pg, is_upper_char_mask)) {\n            is_lower_out = false;\n        }\n        // If any active character is lowercase, then the key cannot be considered entirely uppercase\n        if (svptest_any(pg, is_lower_char_mask)) {\n            is_upper_out = false;\n        }\n\n        i += svcntb(); // Advance the index by the number of bytes in an SVE vector (VL)\n        pg = svwhilelt_b8(i, len); // Update the predicate for the next iteration\n    }\n\n    // After processing all characters, return true if the key is either all lowercase or all uppercase.\n    // If it's mixed case (both is_lower_out and is_upper_out became false), this will return false.\n    return is_lower_out || is_upper_out;\n}\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false; // An empty map does not satisfy the condition\n    }\n\n    bool overall_all_lower = true; // Flag to track if all keys encountered so far are consistently lowercase\n    bool overall_all_upper = true; // Flag to track if all keys encountered so far are consistently uppercase\n\n    // Iterate through each key-value pair in the map\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool current_key_is_lower;\n        bool current_key_is_upper;\n\n        // Use the SVE helper function to check the case of the current key\n        if (!check_key_case_sve(key, current_key_is_lower, current_key_is_upper)) {\n            // If the current key itself is invalid (empty, mixed case, or contains non-alphabetic chars),\n            // the entire map fails the condition.\n            return false;\n        }\n\n        // Update the overall flags based on the current key's case\n        if (current_key_is_lower) {\n            overall_all_upper = false; // If a lowercase key is found, the collection cannot be ALL uppercase\n        }\n        if (current_key_is_upper) {\n            overall_all_lower = false; // If an uppercase key is found, the collection cannot be ALL lowercase\n        }\n\n        // Short-circuit: If we've already determined that the collection is neither all lowercase nor all uppercase\n        // (i.e., we've encountered both a lowercase key AND an uppercase key), then we can return false immediately.\n        if (!overall_all_lower && !overall_all_upper) {\n            return false;\n        }\n    }\n\n    // After checking all keys, return true if all keys were consistently lowercase OR consistently uppercase.\n    return overall_all_lower || overall_all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\n// Helper function to check if a string is all lowercase using SVE intrinsics.\n// Returns true if all characters are lowercase English letters ('a'-'z'), false otherwise.\n// An empty string is considered not all lowercase.\nstatic bool is_all_lower_sve(const std::string& s) {\n    if (s.empty()) {\n        return false;\n    }\n    size_t len = s.length();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n\n    // Define SVE vectors for 'a' and 'z' characters\n    svuint8_t lower_a = svdup_u8('a');\n    svuint8_t lower_z = svdup_u8('z');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk of characters\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // If no active elements in the predicate, we've processed all characters\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, data + i);\n\n        // Check if characters are greater than or equal to 'a'\n        svbool_t is_ge_a = svcmpge_u8(pg, chars, lower_a);\n        // Check if characters are less than or equal to 'z'\n        svbool_t is_le_z = svcmple_u8(pg, chars, lower_z);\n\n        // Combine conditions: (char >= 'a') AND (char <= 'z')\n        svbool_t is_lower_char = svand_b(is_ge_a, is_le_z);\n\n        // If any active character is NOT a lowercase letter, return false\n        if (!svall_b(pg, is_lower_char)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper function to check if a string is all uppercase using SVE intrinsics.\n// Returns true if all characters are uppercase English letters ('A'-'Z'), false otherwise.\n// An empty string is considered not all uppercase.\nstatic bool is_all_upper_sve(const std::string& s) {\n    if (s.empty()) {\n        return false;\n    }\n    size_t len = s.length();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n\n    // Define SVE vectors for 'A' and 'Z' characters\n    svuint8_t upper_A = svdup_u8('A');\n    svuint8_t upper_Z = svdup_u8('Z');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk of characters\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // If no active elements in the predicate, we've processed all characters\n        if (!svptest_any(svptrue_b8(), pg)) {\n            break;\n        }\n\n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, data + i);\n\n        // Check if characters are greater than or equal to 'A'\n        svbool_t is_ge_A = svcmpge_u8(pg, chars, upper_A);\n        // Check if characters are less than or equal to 'Z'\n        svbool_t is_le_Z\n         = svcmple_u8(pg, chars, upper_Z);\n\n        // Combine conditions: (char >= 'A') AND (char <= 'Z')\n        svbool_t is_upper_char = svand_b(is_ge_A, is_le_Z);\n\n        // If any active character is NOT an uppercase letter, return false\n        if (!svall_b(pg, is_upper_char)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    // If the map is empty, return false as per requirements.\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Flags to track if all keys encountered so far are consistently lowercase or uppercase.\n    bool all_lower_case_keys = true;\n    bool all_upper_case_keys = true;\n\n    // Iterate through each key in the map.\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        // If we still assume all keys could be lowercase, check the current key.\n        // If it's not all lowercase, invalidate the 'all_lower_case_keys' flag.\n        if (all_lower_case_keys && !is_all_lower_sve(key)) {\n            all_lower_case_keys = false;\n        }\n\n        // If we still assume all keys could be uppercase, check the current key.\n        // If it's not all uppercase, invalidate the 'all_upper_case_keys' flag.\n        if (all_upper_case_keys && !is_all_upper_sve(key)) {\n            all_upper_case_keys = false;\n        }\n\n        // Optimization: If both possibilities (all lowercase or all uppercase) have been\n        // invalidated by the keys encountered so far, we can return false immediately.\n        if (!all_lower_case_keys && !all_upper_case_keys) {\n            return false;\n        }\n    }\n\n    // After checking all keys, return true if either all keys were consistently lowercase\n    // OR all keys were consistently uppercase.\n    return all_lower_case_keys || all_upper_case_keys;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n#include <cstdint>\n\nstatic bool is_string_all_lower_sve(const std::string& s) {\n    if (s.empty()) {\n        return false; \n    }\n    const char* data = s.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    svuint8_t lower_a = svdup_u8(static_cast<uint8_t>('a'));\n    svuint8_t lower_z = svdup_u8(static_cast<uint8_t>('z'));\n\n    svbool_t all_chars_are_lower = svptrue_b8(); \n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len); \n\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(data + i));\n\n        svbool_t ge_a = svcmpge(pg, chars, lower_a);\n        svbool_t le_z = svcmple(pg, chars, lower_z);\n\n        svbool_t is_lower_chunk = svand_b(ge_a, le_z);\n\n        all_chars_are_lower = svand_b(all_chars_are_lower, is_lower_chunk);\n\n        i += svcntb(); \n    }\n\n    return svptest_all(svptrue_b8(), all_chars_are_lower);\n}\n\nstatic bool is_string_all_upper_sve(const std::string& s) {\n    if (s.empty()) {\n        return false;\n    }\n    const char* data = s.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    svuint8_t upper_A = svdup_u8(static_cast<uint8_t>('A'));\n    svuint8_t upper_Z = svdup_u8(static_cast<uint8_t>('Z'));\n\n    svbool_t all_chars_are_upper = svptrue_b8();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(data + i));\n\n        svbool_t ge_A = svcmpge(pg, chars, upper_A);\n        svbool_t le_Z = svcmple(pg, chars, upper_Z);\n\n        svbool_t is_upper_chunk = svand_b(ge_A, le_Z);\n\n        all_chars_are_upper = svand_b(all_chars_are_upper, is_upper_chunk);\n\n        i += svcntb();\n    }\n\n    return svptest_all(svptrue_b8(), all_chars_are_upper);\n}\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_keys_are_lower = true;\n    bool all_keys_are_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        bool current_key_is_lower = is_string_all_lower_sve(key);\n        bool current_key_is_upper = is_string_all_upper_sve(key);\n\n        if (!current_key_is_lower && !current_key_is_upper) {\n            return false;\n        }\n\n        if (!current_key_is_lower) {\n            all_keys_are_lower = false;\n        }\n        if (!current_key_is_upper) {\n            all_keys_are_upper = false;\n        }\n\n        if (!all_keys_are_lower && !all_keys_are_upper) {\n            return false;\n        }\n    }\n\n    return all_keys_are_lower || all_keys_are_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cstring> // For strlen, though std::string::length() is preferred\n\n// Helper function: Returns true if the string contains no uppercase alphabetic characters.\n// Digits and symbols are considered neutral and do not cause a return of false.\n// This function uses SVE intrinsics for character-level processing.\nstatic bool is_no_upper_chars_sve(const std::string& s) {\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Loop through the string in chunks of SVE vector length\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk, handling string boundaries\n        svbool_t pg = svwhilelt_b_u64(i, len);\n\n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)str + i);\n\n        // Define SVE vectors for 'A' and 'Z' bounds\n        svuint8_t upper_lower_bound = svdup_n_u8('A');\n        svuint8_t upper_upper_bound = svdup_n_u8('Z');\n\n        // Check if characters are greater than or equal to 'A'\n        svbool_t is_ge_A = svcmpge_u8(chars, upper_lower_bound);\n        // Check if characters are less than or equal to 'Z'\n        svbool_t is_le_Z = svcmple_u8(chars, upper_upper_bound);\n\n        // Combine conditions: (char >= 'A') AND (char <= 'Z')\n        svbool_t is_upper_char = svand_b(is_ge_A, is_le_Z);\n\n        // If any character in the current chunk is an uppercase letter (under the predicate)\n        if (svptest_any(pg, is_upper_char)) {\n            return false; // Found an uppercase character, so it's not \"all lower compatible\"\n        }\n    }\n    return true; // No uppercase characters found in the entire string\n}\n\n// Helper function: Returns true if the string contains no lowercase alphabetic characters.\n// Digits and symbols are considered neutral and do not cause a return of false.\n// This function uses SVE intrinsics for character-level processing.\nstatic bool is_no_lower_chars_sve(const std::string& s) {\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Loop through the string in chunks of SVE vector length\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk, handling string boundaries\n        svbool_t pg = svwhilelt_b_u64(i, len);\n\n        // Load characters into an SVE vector using the predicate\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)str + i);\n\n        // Define SVE vectors for 'a' and 'z' bounds\n        svuint8_t lower_lower_bound = svdup_n_u8('a');\n        svuint8_t lower_upper_bound = svdup_n_u8('z');\n\n        // Check if characters are greater than or equal to 'a'\n        svbool_t is_ge_a = svcmpge_u8(chars, lower_lower_bound);\n        // Check if characters are less than or equal to 'z'\n        svbool_t is_le_z = svcmple_u8(chars, lower_upper_bound);\n\n        // Combine conditions: (char >= 'a') AND (char <= 'z')\n        svbool_t is_lower_char = svand_b(is_ge_a, is_le_z);\n\n        // If any character in the current chunk is a lowercase letter (under the predicate)\n        if (svptest_any(pg, is_lower_char)) {\n            return false; // Found a lowercase character, so it's not \"all upper compatible\"\n        }\n    }\n    return true; // No lowercase characters found in the entire string\n}\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    // If the map is empty, return false as per the problem description.\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Check if all keys are compatible with being \"all lowercase\".\n    // A key is \"all lowercase compatible\" if it contains no uppercase alphabetic characters.\n    // This allows for keys with digits or symbols (e.g., \"a\", \"123\", \"a123\").\n    bool all_keys_are_lower_compatible = true;\n    for (const auto& pair : dict) {\n        if (!is_no_upper_chars_sve(pair.first)) {\n            all_keys_are_lower_compatible = false;\n            break; // Found a key that contains an uppercase character, so it cannot be all lowercase\n        }\n    }\n    if (all_keys_are_lower_compatible) {\n        return true; // All keys are compatible with being lowercase (or are neutral), so the condition is met.\n    }\n\n    // If not all keys were \"all lowercase compatible\", check if all keys are \"all uppercase compatible\".\n    // A key is \"all uppercase compatible\" if it contains no lowercase alphabetic characters.\n    // This allows for keys with digits or symbols (e.g., \"A\", \"123\", \"A123\").\n    bool all_keys_are_upper_compatible = true;\n    for (const auto& pair : dict) {\n        if (!is_no_lower_chars_sve(pair.first)) {\n            all_keys_are_upper_compatible = false;\n            break; // Found a key that contains a lowercase character, so it cannot be all uppercase\n        }\n    }\n    // Return true if all keys are compatible with being uppercase.\n    // If neither condition is met, return false.\n    return all_keys_are_upper_compatible;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath> // For sqrt\n\n// Helper function to check if a number is prime using SVE intrinsics\nstatic bool is_prime_sve_helper(int n_val) {\n    if (n_val <= 1) return false;\n    if (n_val <= 3) return true; // 2, 3 are prime\n    if (n_val % 2 == 0 || n_val % 3 == 0) return false; // Optimization for 2 and 3\n\n    int limit = static_cast<int>(sqrt(n_val));\n    if (limit < 5) return true; // Already checked up to 3\n\n    // SVE part\n    int vl = svcntw(); // Number of 32-bit elements in a vector\n\n    // Loop through potential divisors starting from 5\n    // We generate sequences like [d_start, d_start+1, d_start+2, ...] and filter for odd numbers and within limit.\n    for (int d_start = 5; d_start <= limit; d_start += vl) {\n        // Generate a vector of potential divisors: d_start, d_start+1, ..., d_start+vl-1\n        svuint32_t divisors_vec = svindex_u32(d_start, 1);\n\n        // Predicate for lanes where divisor is <= limit\n        svbool_t pg_limit = svwhilelt_b32(d_start, limit + 1);\n\n        // Predicate for lanes where divisor is odd (divisor % 2 != 0)\n        svuint32_t two_vec = svdup_u32(2);\n        svuint32_t zero_vec = svdup_u32(0);\n\n        // Calculate remainder: divisors_vec % 2\n        // rem = val - (val / divisor) * divisor\n        svuint32_t q_div2 = svdiv_u32_x(pg_limit, divisors_vec, two_vec);\n        svuint32_t p_div2 = svmul_u32_x(pg_limit, q_div2, two_vec);\n        svuint32_t rem_div2 = svsub_u32_x(pg_limit, divisors_vec, p_div2);\n\n        // Predicate for odd numbers: rem_div2 != 0\n        svbool_t pg_odd = svcmpne_u32(pg_limit, rem_div2, zero_vec);\n\n        // Combine predicates: (divisor <= limit) AND (divisor is odd)\n        svbool_t pg_active = svand_b(pg_limit, pg_odd);\n\n        // If no active lanes in this block, continue to next block\n        // svptest_any(svptrue_b32(), pg_active) checks if any lane in pg_active is true.\n        if (svptest_any(svptrue_b32(), pg_active) == 0) {\n            continue;\n        }\n\n        // Perform the actual divisibility check for n_val\n        // n_val % divisor == 0\n        svuint32_t n_val_vec = svdup_u32(n_val);\n\n        // Calculate remainder: n_val % divisors_vec\n        svuint32_t q_n_div_d = svdiv_u32_x(pg_active, n_val_vec, divisors_vec);\n        svuint32_t p_n_div_d = svmul_u32_x(pg_active, q_n_div_d, divisors_vec);\n        svuint32_t rem_n_div_d = svsub_u32_x(pg_active, n_val_vec, p_n_div_d);\n\n        // Check if any remainder is zero for active lanes\n        svbool_t is_divisible = svcmpeq_u32(pg_active, rem_n_div_d, zero_vec);\n\n        if (svptest_any(pg_active, is_divisible)) {\n            return false; // Found a divisor\n        }\n    }\n    return true; // No divisors found\n}\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> result;\n    if (n <= 2) {\n        return result;\n    }\n\n    // Iterate from 2 up to n-1 and check primality for each number\n    for (int i = 2; i < n; ++i) {\n        if (is_prime_sve_helper(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath> // For std::sqrt\n#include <arm_sve.h> \n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n\n    // Handle edge cases: no primes less than or equal to 2\n    if (n <= 2) {\n        return primes;\n    }\n\n    // Use std::vector<char> for the sieve array to save memory and allow SVE byte operations.\n    // Initialize all elements to true (1)\n    std::vector<char> is_prime(n, 1); \n\n    // 0 and 1 are not prime numbers\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    // Get the SVE vector length for 32-bit elements (words).\n    // The scatter operation `svst1_scatter_s32offset_s8` uses 32-bit offsets,\n    // so `svcntw()` determines how many elements are processed in parallel.\n    int vl_elements = svcntw(); \n    // Create a predicate for the full vector length, used as a base for active lanes.\n    svbool_t pg_all = svwhilelt_b32(0, vl_elements); \n\n    // Sieve of Eratosthenes algorithm\n    // Iterate 'p' from 2 up to sqrt(n)\n    for (long long p = 2; p * p < n; ++p) {\n        // If is_prime[p] is true, then p is a prime number\n        if (is_prime[p]) {\n            // Mark all multiples of p as not prime, starting from p*p.\n            // We process 'vl_elements' multiples at a time using SVE intrinsics.\n            for (long long current_multiple_base = p * p; current_multiple_base < n; current_multiple_base += (long long)vl_elements * p) {\n                // Generate a vector of indices for the current block of multiples:\n                // {current_multiple_base, current_multiple_base + p, ..., current_multiple_base + (vl_elements-1)*p}\n                // svindex_s32(0, 1) creates a vector {0, 1, 2, ..., vl_elements-1}\n                // svmul_s32(svindex_s32(0, 1), svdup_s32(p)) creates {0, p, 2p, ..., (vl_elements-1)*p}\n                svint32_t offsets = svmul_s32(svindex_s32(0, 1), svdup_s32(p));\n                svint32_t indices = svadd_s32(svdup_s32(current_multiple_base), offsets);\n\n                // Create a predicate to only process elements whose indices are within the [0, n) bounds.\n                // This prevents out-of-bounds memory access for the last partial vector.\n                svbool_t active_pg = svcmplt_s32(pg_all, indices, svdup_s32(n));\n\n                // Store 0 (false) at these calculated indices in the 'is_prime' array.\n                // is_prime.data() provides the base address of the char array.\n                // 'indices' provides the 32-bit offsets from the base.\n                // svdup_s8(0) creates a vector of zeros (char type) to store.\n                svst1_scatter_s32offset_s8(active_pg, is_prime.data(), indices, svdup_s8(0));\n            }\n        }\n    }\n\n    // Collect all prime numbers from the 'is_prime' array\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Not strictly needed, svindex_s32 replaces std::iota for SVE\n\nstd::vector<int> count_up_to_simd(int n) {\n    // Handle edge cases where no primes exist or n is too small\n    if (n <= 2) {\n        return {}; // No primes less than or equal to 2\n    }\n\n    // Use a boolean array (represented by char for SVE compatibility) for the Sieve of Eratosthenes.\n    // is_prime_flags[i] = 1 if i is prime, 0 otherwise.\n    std::vector<char> is_prime_flags(n, 1); // Initialize all to true (1)\n\n    // 0 and 1 are not prime\n    is_prime_flags[0] = 0;\n    is_prime_flags[1] = 0;\n\n    // Sieve of Eratosthenes\n    // Iterate from p = 2 up to sqrt(n)\n    for (int p = 2; p * p < n; ++p) {\n        // If is_prime_flags[p] is still 1, then p is a prime number\n        if (is_prime_flags[p]) {\n            // Mark all multiples of p (starting from p*p) as not prime.\n            // This is where SVE intrinsics are used for parallelization.\n\n            // Get the vector length for 32-bit elements (offsets)\n            // Although we store 8-bit elements, the offsets are 32-bit.\n            svbool_t pg_all = svwhilelt_b32(0, svcntw()); // Full predicate for vector operations\n\n            // Create a vector of zeros to store (mark as not prime)\n            svint8_t zeros = svdup_n_s8(0);\n\n            // Iterate through multiples of p, advancing by vector length * p\n            for (int current_idx = p * p; current_idx < n; ) {\n                // Generate a vector of indices: {current_idx, current_idx+p, current_idx+2p, ...}\n                // 1. Generate base indices {0, 1, 2, ...}\n                svint32_t v_base_indices = svindex_s32(0, 1);\n                // 2. Multiply by p to get offsets {0, p, 2p, ...}\n                svint32_t v_offsets = svmul_s32_x(pg_all, v_base_indices, svdup_n_s32(p));\n                // 3. Add current_idx to get final indices {current_idx, current_idx+p, ...}\n                svint32_t v_indices = svadd_s32_x(pg_all, v_offsets, svdup_n_s32(current_idx));\n\n                // Create a predicate for indices that are within the bounds [0, n-1)\n                svbool_t current_pg = svcmplt_n_s32(pg_all, v_indices, n);\n\n                // Scatter store: write '0' (not prime) to is_prime_flags at the calculated indices\n                // The base address is is_prime_flags.data(), offsets are in v_indices.\n                svst1_scatter_s32offset_s8(current_pg, is_prime_flags.data(), v_indices, zeros);\n\n                // Advance current_idx for the next SVE iteration\n                // We processed svcntw() elements, each separated by 'p'.\n                current_idx += svcntw() * p;\n            }\n        }\n    }\n\n    // Collect all prime numbers into the result vector\n    std::vector<int> result;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime_flags[i]) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath> // For std::sqrt, though p*p < n avoids it.\n\n// SVE intrinsics header\n#include <arm_sve.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n\n    // Handle edge cases: no primes less than or equal to 2\n    if (n <= 2) {\n        return primes;\n    }\n\n    // Use a vector of uint8_t to represent boolean flags for SVE compatibility.\n    // 1 means prime, 0 means not prime.\n    // Initialize all numbers up to n-1 as potentially prime.\n    std::vector<uint8_t> is_prime(n, 1);\n\n    // 0 and 1 are not prime\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    // Sieve of Eratosthenes with SVE optimization\n    // Iterate p from 2 up to sqrt(n)\n    // The loop condition p * p < n is equivalent to p < sqrt(n)\n    for (int p = 2; p * p < n; ++p) {\n        // If is_prime[p] is true, then p is a prime number\n        if (is_prime[p]) {\n            // Mark all multiples of p (starting from p*p) as not prime.\n            // We use SVE to mark multiple elements in parallel.\n\n            // Get the vector length for int32 elements (number of elements per SVE vector)\n            // This determines how many multiples are processed in one SVE operation.\n            int vl = svcntw();\n\n            // Create a vector of zeros to store into the is_prime array\n            // This vector will be scattered to mark non-prime numbers.\n            svuint8_t zero_vec = svdup_u8(0);\n\n            // Loop through multiples of p, starting from p*p.\n            // The loop increment is vl * p because each SVE scatter operation\n            // will mark 'vl' multiples, each separated by 'p'.\n            for (int current_start_idx = p * p; current_start_idx < n; current_start_idx += vl * p) {\n                // Generate a vector of indices for the current block of multiples.\n                // For example, if p=3, vl=4, current_start_idx=9:\n                // indices will be {9, 12, 15, 18}\n                svint32_t indices = svindex_s32(current_start_idx, p);\n\n                // Create a predicate (mask) for elements whose index is less than n.\n                // This ensures we don't write out of bounds and only process valid indices.\n                svbool_t pg = svwhilelt_s32(indices, n);\n\n                // Perform a scatter store operation:\n                // Store the 'zero_vec' (all zeros) into the 'is_prime' array\n                // at the addresses calculated from 'is_prime.data()' plus 'indices' offsets.\n                // Only elements where 'pg' is true will be written.\n                svst1_scatter_s32offset_u8(pg, is_prime.data(), indices, zero_vec);\n            }\n        }\n    }\n\n    // Collect all numbers that are marked as prime into the result vector.\n    // This part is sequential as the collection pattern is not easily vectorizable\n    // into a compact output vector without complex gather/compress operations,\n    // and the number of primes is variable.\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <arm_sve.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n\n    if (n <= 2) {\n        return primes;\n    }\n\n    // Use a char array to represent boolean flags (0 for false, 1 for true).\n    // This is suitable for SVE u8 operations.\n    std::vector<char> is_prime(n, 1); // Initialize all to true (1)\n    is_prime[0] = 0; // 0 is not prime\n    is_prime[1] = 0; // 1 is not prime\n\n    // Sieve of Eratosthenes\n    // Iterate p from 2 up to sqrt(n)\n    // The loop condition p * p < n is equivalent to p < sqrt(n)\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            // p is a prime number. Mark its multiples as not prime.\n            // Start marking from p*p, with a step of p.\n            // This inner loop is vectorized using SVE.\n            // current_multiple_start iterates through the starting indices of SVE vector chunks.\n            for (int current_multiple_start = p * p; current_multiple_start < n; ) {\n                // Create a predicate for active lanes.\n                // Lanes are active if their corresponding index (current_multiple_start + lane_idx * p) is less than n.\n                svbool_t pg = svwhilelt_b32(current_multiple_start, n);\n\n                // Check if any lane is active. If not, we've processed all relevant multiples.\n                if (svptest_any(svptrue_b32(), pg) == 0) {\n                    break;\n                }\n\n                // Generate a vector of indices: current_multiple_start, current_multiple_start + p, current_multiple_start + 2*p, ...\n                svuint32_t indices = svindex_u32(current_multiple_start, p);\n\n                // Create a vector of zeros (representing 'false' for is_prime).\n                svuint8_t zero_vec = svdup_u8(0);\n\n                // Scatter store: store 0 at is_prime[index] for all active lanes.\n                // The base pointer is `&is_prime[0]` (cast to uint8_t*).\n                // The indices are `svuint32_t` offsets.\n                // The data to store is `svuint8_t`.\n                svst1_scatter_u8base_u32(pg, (uint8_t*)&is_prime[0], indices, zero_vec);\n\n                // Advance current_multiple_start for the next SVE chunk.\n                // We processed svcntw() elements, each separated by 'p'.\n                current_multiple_start += svcntw() * p;\n            }\n        }\n    }\n\n    // Collect all prime numbers into the result vector.\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string> // Required for std::string\n#include <cstdint> // Required for uint8_t\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n    int total_count = 0;\n    size_t n = s.length();\n    size_t i = 0;\n\n    // Duplicate uppercase vowel characters into SVE vectors for comparison\n    svuint8_t A_vec = svdup_u8('A');\n    svuint8_t E_vec = svdup_u8('E');\n    svuint8_t I_vec = svdup_u8('I');\n    svuint8_t O_vec = svdup_u8('O');\n    svuint8_t U_vec = svdup_u8('U');\n\n    // Duplicate 0 and 1 for even index check (index % 2 == 0)\n    svuint8_t zero_vec = svdup_u8(0);\n    svuint8_t one_vec = svdup_u8(1);\n\n    // Get the vector length in bytes for 8-bit elements\n    size_t sv_vl = svcntb();\n\n    while (i < n) {\n        // Create a predicate for the current chunk of the string\n        // This predicate ensures we only process valid characters up to 'n'\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters from the string into an SVE vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Generate a vector of indices relative to the start of the string\n        // e.g., if i=0, generates [0, 1, 2, ...]; if i=16, generates [16, 17, 18, ...]\n        svuint8_t indices_in_vector = svindex_u8(i, 1);\n\n        // Check if the index is even: (index % 2 == 0)\n        // Bitwise AND with 1 effectively computes modulo 2.\n        // Then compare the result with 0.\n        svbool_t is_even_index = svcmpeq_u8(pg, svand_u8(indices_in_vector, one_vec), zero_vec);\n\n        // Check for uppercase vowels\n        svbool_t is_A = svcmpeq_u8(pg, chars, A_vec);\n        svbool_t is_E = svcmpeq_u8(pg, chars, E_vec);\n        svbool_t is_I = svcmpeq_u8(pg, chars, I_vec);\n        svbool_t is_O = svcmpeq_u8(pg, chars, O_vec);\n        svbool_t is_U = svcmpeq_u8(pg, chars, U_vec);\n\n        // Combine all vowel checks using OR\n        svbool_t is_vowel = svorr_b8(is_A, is_E);\n        is_vowel = svorr_b8(is_vowel, is_I);\n        is_vowel = svorr_b8(is_vowel, is_O);\n        is_vowel = svorr_b8(is_vowel, is_U);\n\n        // Combine the even index predicate with the vowel predicate using AND\n        // Only elements that are both at an even index AND are an uppercase vowel will be true\n        svbool_t final_predicate = svand_b8(is_even_index, is_vowel);\n\n        // Count the number of true elements in the final predicate\n        // The 'pg' predicate ensures we only count elements that are actually part of the string\n        total_count += svcnt_u8(pg, final_predicate);\n\n        // Advance the string pointer by the SVE vector length\n        i += sv_vl;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    long total_count = 0;\n    long len = s.length();\n    const unsigned char *ptr = reinterpret_cast<const unsigned char *>(s.data());\n    long i = 0;\n\n    svbool_t pg_all_true = svptrue_b8(); // Predicate for all elements active in a vector\n\n    while (i < len) {\n        // Create a predicate for the current chunk, handling end of string\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load the characters from the string\n        svuint8_t chars = svld1_u8(pg, ptr + i);\n\n        // --- Predicate for even indices ---\n        // Generate a vector of absolute indices: [i, i+1, i+2, ..., i+VL-1]\n        svuint8_t indices = svindex_u8(i, 1);\n        // Check if (index & 1) == 0 to identify even indices\n        svbool_t even_idx_pg = svcmpeq_u8(pg, svand_u8_z(pg_all_true, indices, 1), 0);\n\n        // --- Predicate for uppercase vowels ---\n        svbool_t is_A = svcmpeq_u8(pg, chars, 'A');\n        svbool_t is_E = svcmpeq_u8(pg, chars, 'E');\n        svbool_t is_I = svcmpeq_u8(pg, chars, 'I');\n        svbool_t is_O = svcmpeq_u8(pg, chars, 'O');\n        svbool_t is_U = svcmpeq_u8(pg, chars, 'U');\n\n        // Combine all vowel predicates using OR\n        svbool_t is_vowel_pg = svorr_b(is_A, svorr_b(is_E, svorr_b(is_I, svorr_b(is_O, is_U))));\n\n        // --- Combine all conditions: (even_idx AND is_vowel) ---\n        svbool_t final_match_pg = svand_b(even_idx_pg, is_vowel_pg);\n\n        // Count the number of active elements in the final predicate\n        total_count += svcnt_u8(final_match_pg);\n\n        // Move to the next chunk based on the current vector length\n        i += svcntb(); \n    }\n\n    return static_cast<int>(total_count);\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    size_t n = s.length();\n    int total_count = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    // Get the vector length in bytes for u8 (number of 8-bit elements)\n    size_t vl = svcntb();\n\n    // Duplicate constants into SVE vectors for comparisons and operations\n    svuint8_t val_A = svdup_u8(svptrue_b8(), 'A');\n    svuint8_t val_Z = svdup_u8(svptrue_b8(), 'Z');\n    svuint8_t val_0 = svdup_u8(svptrue_b8(), 0); // For checking (index & 1) == 0\n    svuint8_t val_1 = svdup_u8(svptrue_b8(), 1); // For (index & 1)\n\n    // Duplicate uppercase vowel characters\n    svuint8_t char_A = svdup_u8(svptrue_b8(), 'A');\n    svuint8_t char_E = svdup_u8(svptrue_b8(), 'E');\n    svuint8_t char_I = svdup_u8(svptrue_b8(), 'I');\n    svuint8_t char_O = svdup_u8(svptrue_b8(), 'O');\n    svuint8_t char_U = svdup_u8(svptrue_b8(), 'U');\n\n    // Loop through the string in chunks of VL bytes\n    for (size_t i = 0; i < n; i += vl) {\n        // 1. Create a predicate for the current chunk of data.\n        //    This predicate is true for elements within the string bounds [i, n).\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // If no active elements in this predicate, we've processed the entire string.\n        if (svptest_any(svptrue_b8(), pg) == 0) {\n            break;\n        }\n\n        // 2. Load characters from the string using the predicate.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data() + i);\n\n        // 3. Generate a vector of indices for the current chunk: [i, i+1, i+2, ..., i+VL-1]\n        svuint8_t current_indices = svindex_u8(i, 1);\n\n        // 4. Create a mask for even indices: (index % 2) == 0, which is equivalent to (index & 1) == 0.\n        svuint8_t and_result = svand_u8(pg, current_indices, val_1); // Compute (current_indices & 1)\n        svbool_t even_idx_mask = svcmpeq_u8(pg, and_result, val_0); // Check if (result == 0)\n\n        // 5. Combine the main predicate (pg) with the even index mask.\n        //    This predicate is true only for elements that are within bounds AND at an even index.\n        svbool_t active_even_pg = svand_b(pg, even_idx_mask);\n\n        // If no active even elements in this chunk, continue to the next chunk.\n        if (svptest_any(svptrue_b8(), active_even_pg) == 0) {\n            continue;\n        }\n\n        // 6. Check if characters are uppercase ('A' through 'Z').\n        //    The active_even_pg predicate ensures we only check relevant characters.\n        svbool_t is_upper = svcmpge_u8(active_even_pg, chars, val_A);\n        is_upper = svand_b(is_upper, svcmple_u8(active_even_pg, chars, val_Z));\n\n        // 7. Check if characters are uppercase vowels ('A', 'E', 'I', 'O', 'U').\n        //    Combine individual equality checks using logical OR.\n        svbool_t is_A = svcmpeq_u8(active_even_pg, chars, char_A);\n        svbool_t is_E = svcmpeq_u8(active_even_pg, chars, char_E);\n        svbool_t is_I = svcmpeq_u8(active_even_pg, chars, char_I);\n        svbool_t is_O = svcmpeq_u8(active_even_pg, chars, char_O);\n        svbool_t is_U = svcmpeq_u8(active_even_pg, chars, char_U);\n\n        svbool_t is_vowel = svorr_b(is_A, is_E);\n        is_vowel = svorr_b(is_vowel, is_I);\n        is_vowel = svorr_b(is_vowel, is_O);\n        is_vowel = svorr_b(is_vowel, is_U);\n\n        // 8. Combine all conditions: (is_upper AND is_vowel) AND active_even_pg.\n        //    The final_mask will be true only for characters that are:\n        //    - Within string bounds\n        //    - At an even index\n        //    - Uppercase\n        //    - A vowel\n        svbool_t final_mask = svand_b(is_upper, is_vowel);\n        final_mask = svand_b(final_mask, active_even_pg);\n\n        // 9. Count the number of true predicates in the final mask and add to total.\n        total_count += svcntp_b8(svptrue_b8(), final_mask);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstddef> // For size_t\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t n = s.length();\n    const unsigned char *s_ptr = reinterpret_cast<const unsigned char *>(s.data());\n\n    // Get the vector length in bytes for u8\n    size_t vl = svcntb();\n\n    // Define constants for uppercase vowels\n    // These can be duplicated once outside the loop as they are constant.\n    svuint8_t A_vec = svdup_u8(65); // 'A'\n    svuint8_t E_vec = svdup_u8(69); // 'E'\n    svuint8_t I_vec = svdup_u8(73); // 'I'\n    svuint8_t O_vec = svdup_u8(79); // 'O'\n    svuint8_t U_vec = svdup_u8(85); // 'U'\n\n    // Pre-calculate a vector of relative indices (0, 1, 2, ..., VL-1)\n    // This can be done once outside the loop.\n    svuint8_t relative_indices = svindex_u8(0, 1);\n\n    size_t i = 0;\n    // Loop through the string in chunks of VL bytes\n    while (i < n) {\n        // Create a predicate for the current chunk, handling end-of-string\n        // `pg` will be true for elements within string bounds and false otherwise.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters from the string using the predicate `pg`\n        svuint8_t chars = svld1_u8(pg, s_ptr + i);\n\n        // Generate a vector of absolute indices for the current chunk: i, i+1, i+2, ..., i+VL-1\n        // `svadd_u8_x` performs addition only for active elements defined by `pg`.\n        svuint8_t absolute_indices = svadd_u8_x(pg, relative_indices, i);\n\n        // Predicate for even indices: (index % 2 == 0) or (index & 1 == 0)\n        // `svand_u8_x` performs bitwise AND only for active elements defined by `pg`.\n        // `svcmpeq_u8` compares for equality only for active elements defined by `pg`.\n        svbool_t p_even_idx = svcmpeq_u8(pg, svand_u8_x(pg, absolute_indices, 1), 0);\n\n        // Predicate for uppercase vowels\n        // `svcmpeq_u8` compares characters against each vowel constant.\n        svbool_t p_is_A = svcmpeq_u8(pg, chars, A_vec);\n        svbool_t p_is_E = svcmpeq_u8(pg, chars, E_vec);\n        svbool_t p_is_I = svcmpeq_u8(pg, chars, I_vec);\n        svbool_t p_is_O = svcmpeq_u8(pg, chars, O_vec);\n        svbool_t p_is_U = svcmpeq_u8(pg, chars, U_vec);\n\n        // Combine vowel predicates using logical OR\n        svbool_t p_is_vowel = svorr_b(p_is_A, svorr_b(p_is_E, svorr_b(p_is_I, svorr_b(p_is_O, p_is_U))));\n\n        // Combine predicates: (even index) AND (is vowel)\n        // `svand_b` performs logical AND on predicates.\n        svbool_t p_final = svand_b(p_even_idx, p_is_vowel);\n\n        // Count active elements in the final predicate under the main predicate `pg`\n        // `svcntp_b8` counts the number of true elements in `p_final` where `pg` is also true.\n        count += svcntp_b8(pg, p_final);\n\n        // Move to the next chunk\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint> // For uint8_t\n\nint count_upper_simd(const std::string & s) {\n    int total_count = 0;\n    size_t n = s.length();\n    size_t i = 0;\n\n    // Get the vector length in bytes (number of 8-bit elements)\n    size_t vl = svcntb();\n\n    // Duplicate constant characters for comparison\n    svuint8_t A_char = svdup_u8('A');\n    svuint8_t E_char = svdup_u8('E');\n    svuint8_t I_char = svdup_u8('I');\n    svuint8_t O_char = svdup_u8('O');\n    svuint8_t U_char = svdup_u8('U');\n\n    // Constants for parity check (1 for odd, 0 for even)\n    svuint8_t one_u8 = svdup_u8(1);\n    svuint8_t zero_u8 = svdup_u8(0);\n\n    // Create an index vector [0, 1, 2, ..., VL-1]\n    // This vector represents the offset within the current SVE chunk.\n    svuint8_t base_indices = svindex_u8(0, 1);\n\n    while (i < n) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures we only process valid elements within the string bounds.\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters from the string into an SVE vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // 1. Check for even indices: (absolute_index % 2 == 0)\n        // Calculate the absolute index for each character in the current chunk: i + [0, 1, ..., VL-1]\n        svuint8_t current_absolute_indices = svadd_u8_x(pg, base_indices, svdup_u8(i));\n\n        // Check if the absolute index is even by checking its least significant bit.\n        // (value & 1) == 0 means even.\n        svuint8_t parity_check = svand_u8_x(pg, current_absolute_indices, one_u8);\n        svbool_t even_idx_mask = svcmpeq_u8(pg, parity_check, zero_u8);\n\n        // 2. Check for uppercase vowels\n        svbool_t is_A = svcmpeq_u8(pg, chars, A_char);\n        svbool_t is_E = svcmpeq_u8(pg, chars, E_char);\n        svbool_t is_I = svcmpeq_u8(pg, chars, I_char);\n        svbool_t is_O = svcmpeq_u8(pg, chars, O_char);\n        svbool_t is_U = svcmpeq_u8(pg, chars, U_char);\n\n        // Combine all vowel checks using logical OR operations\n        svbool_t is_vowel = svorr_b(is_A, is_E);\n        is_vowel = svorr_b(is_vowel, is_I);\n        is_vowel = svorr_b(is_vowel, is_O);\n        is_vowel = svorr_b(is_vowel, is_U);\n\n        // 3. Combine both conditions: (even_idx_mask AND is_vowel)\n        // The governing predicate 'pg' is implicitly applied as both 'even_idx_mask' and 'is_vowel'\n        // were generated under 'pg'.\n        svbool_t final_mask = svand_b(even_idx_mask, is_vowel);\n\n        // Count the number of active elements (where final_mask is true)\n        // svcntp_b counts elements where the predicate 'p' is true, under the governing predicate 'pg'.\n        total_count += svcntp_b(pg, final_mask);\n\n        // Move to the next chunk of the string\n        i += vl;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <vector> \n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        int current_start_val = n + 2 * i;\n        svint32_t values = svindex_s32(current_start_val, 2);\n        svst1_s32(pg, &result[i], values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n\n    // Get the vector length for 32-bit integers\n    int vl = svcntw();\n\n    // Loop through the elements, processing 'vl' elements at a time\n    for (int i = 0; i < n; i += vl) {\n        // Create a predicate for the current chunk\n        // This predicate ensures we don't write past 'n' elements\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Calculate the starting value for this chunk: n + 2*i\n        int start_val = n + 2 * i;\n\n        // Generate an index sequence: 0, 1, 2, ..., (vl-1)\n        svint32_t indices = svindex_s32(0, 1);\n\n        // Multiply indices by 2: {0, 2, 4, ...}\n        svint32_t offsets = svmul_s32(pg, indices, svdup_s32(2));\n\n        // Add the starting value to the offsets\n        // This gives: {start_val + 0, start_val + 2, start_val + 4, ...}\n        svint32_t current_values = svadd_s32(pg, svdup_s32(start_val), offsets);\n\n        // Store the results into the vector\n        svst1_s32(pg, result.data() + i, current_values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    svbool_t pg;\n\n    // Loop through the elements in chunks of SVE vector length\n    do {\n        // Get the predicate for the current chunk, ensuring we don't go past 'n'\n        pg = svwhilelt_b32(i, n);\n\n        // Calculate the base value for the current vector chunk.\n        // The formula for the k-th element (0-indexed) is n + 2*k.\n        // For a chunk starting at global index 'i', the local index 'j' (0 to VL-1)\n        // corresponds to global index 'i + j'.\n        // So, the value is n + 2 * (i + j) = (n + 2*i) + 2*j.\n        // (n + 2*i) is the constant base for this vector.\n        svint32_t current_base_val = svdup_s32(n + 2 * i);\n\n        // Generate increments: 0, 2, 4, 6, ... for each lane\n        svint32_t increments = svindex_s32(0, 2);\n\n        // Add the base value and increments to get the final pile values\n        // The '_x' suffix means the operation is performed only on active lanes (controlled by pg)\n        svint32_t pile_values = svadd_s32_x(pg, current_base_val, increments);\n\n        // Store the computed values into the result vector\n        // The '_s32' suffix indicates 32-bit integer elements\n        svst1_s32(pg, &result[i], pile_values);\n\n        // Increment the global index 'i' by the number of elements processed in this vector (VL)\n        i += svcntw();\n    } while (i < n); // Continue as long as there are elements left to process\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a vector, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile_simd(3)\n{3, 5, 7}\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n\n    // Get a pointer to the underlying data for SVE stores\n    int* data_ptr = result.data();\n\n    // Iterate through the vector in chunks of SVE vector length\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of 'n', especially for the last partial vector.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Generate a vector of increasing indices: i, i+1, i+2, ...\n        // These indices correspond to the 'i' in the formula n + 2*i.\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Calculate 2 * indices for the active lanes.\n        // _x suffix means \"unpredicated, inactive lanes are unchanged\".\n        // Since the result is immediately used in another predicated operation\n        // or stored, this is an efficient choice.\n        svint32_t two_times_indices = svmul_s32_x(pg, indices, 2);\n\n        // Calculate n + (2 * indices) for the active lanes.\n        svint32_t current_pile_values = svadd_s32_x(pg, two_times_indices, n);\n\n        // Store the calculated values into the result vector.\n        // svst1_s32 stores only the active lanes defined by 'pg'.\n        svst1_s32(pg, data_ptr + i, current_pile_values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n\n    // Loop through the vector in chunks determined by the SVE vector length (svcntw())\n    // 'i' represents the global starting index for the current SVE vector operation\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create a predicate 'pg' that is true for elements within the current chunk\n        // that are less than 'n'. This handles the tail end of the vector if 'n' is\n        // not a multiple of the SVE vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Generate a sequence of increasing numbers starting from 0 for the current vector lanes.\n        // This represents the local index 'j' within the SVE vector: {0, 1, 2, ...}\n        svint32_t j_vec = svindex_s32(0, 1);\n\n        // Calculate '2 * j' for each lane.\n        // This gives the incremental part of the formula: {0, 2, 4, ...}\n        // The '_x' suffix means the operation is predicated (only active lanes are computed).\n        svint32_t two_j_vec = svmul_s32_x(pg, j_vec, svdup_s32(2));\n\n        // Calculate the base value for the current chunk: 'n + 2 * i'.\n        // This value is constant across all active lanes of the current SVE vector.\n        // 'svdup_s32' duplicates the scalar value into all lanes of an SVE vector.\n        svint32_t base_val_vec = svdup_s32(n + 2 * i);\n\n        // Add the base value to '2 * j' to get the final values for the current chunk.\n        // The formula for the k-th element (0-indexed) is n + 2 * k.\n        // Here, k = i + j, so the value is n + 2 * (i + j) = (n + 2 * i) + 2 * j.\n        // This results in values like {n + 2*i, n + 2*i + 2, n + 2*i + 4, ...}\n        svint32_t values = svadd_s32_x(pg, base_val_vec, two_j_vec);\n\n        // Store the computed SVE vector 'values' into the 'result' vector starting at index 'i'.\n        // The predicate 'pg' ensures that only the active lanes are written to memory,\n        // preventing out-of-bounds writes for the tail end.\n        svst1_s32(pg, &result[i], values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <string>\n#include <algorithm> // Required for std::reverse\n#include <arm_sve.h> // Required for SVE intrinsics\n\n// Helper function to convert a decimal integer to a binary string\n// This function is not part of the SVE implementation requirement.\nstd::string toBinary(int64_t n) {\n    if (n == 0) {\n        return \"0\";\n    }\n    std::string binaryString = \"\";\n    // Convert to binary by repeatedly taking modulo 2 and dividing by 2\n    while (n > 0) {\n        binaryString += (n % 2 == 0 ? '0' : '1');\n        n /= 2;\n    }\n    // The binary string is built in reverse order, so reverse it\n    std::reverse(binaryString.begin(), binaryString.end());\n    return binaryString;\n}\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    // If n is greater than m, return \"-1\" as per the problem statement.\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the average (n + m) / 2 using SVE intrinsics.\n    // The average of an arithmetic series (n to m) is simply (n + m) / 2.\n    // Integer division naturally performs floor for positive results,\n    // which corresponds to \"round the answer to the nearest integer (smaller one)\".\n\n    // 1. Broadcast n and m into SVE vectors.\n    // svdup_s64 creates a vector where all elements are initialized with the scalar value.\n    svint64_t sv_n = svdup_s64(n);\n    svint64_t sv_m = svdup_s64(m);\n\n    // 2. Perform vector addition: sv_sum_nm = sv_n + sv_m.\n    // svadd_s64 performs element-wise addition on two SVE int64_t vectors.\n    svint64_t sv_sum_nm = svadd_s64(sv_n, sv_m);\n\n    // 3. Broadcast the divisor (2) into an SVE vector.\n    svint64_t sv_two = svdup_s64(2);\n\n    // 4. Perform vector division: sv_avg = sv_sum_nm / sv_two.\n    // svdiv_s64 performs element-wise division on two SVE int64_t vectors.\n    // This results in a vector where each element holds the calculated average.\n    // Since n and m were broadcast, all elements in sv_avg will be identical.\n    svint64_t sv_avg = svdiv_s64(sv_sum_nm, sv_two);\n\n    // 5. Extract the scalar result from the SVE vector.\n    // To get a single scalar value from the vector, we can sum all elements\n    // and then divide by the number of elements. This is a common SVE reduction pattern.\n    // svptrue_b64() creates a predicate that enables all elements in the vector.\n    svbool_t pg_all = svptrue_b64();\n    // svaddv_s64 sums all active int64_t elements in the vector.\n    int64_t sum_of_avgs = svaddv_s64(pg_all, sv_avg);\n    // svcntd() returns the number of int64_t elements in an SVE vector (vector length).\n    int64_t num_elements = svcntd();\n\n    // The final rounded average is the sum of identical averages divided by the count.\n    int64_t rounded_average = sum_of_avgs / num_elements;\n\n    // 6. Convert the rounded average to its binary string representation.\n    return toBinary(rounded_average);\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    svbool_t pg = svptrue_b64();\n\n    svint64_t sv_n = svdup_s64(n);\n    svint64_t sv_m = svdup_s64(m);\n\n    svint64_t sv_sum = svadd_s64(pg, sv_n, sv_m);\n\n    svint64_t sv_avg_vec = svlsr_s64(pg, sv_sum, 1);\n\n    int64_t average = svget_s64(sv_avg_vec, 0);\n\n    if (average == 0) {\n        return \"0\";\n    }\n\n    std::string binaryString = \"\";\n    while (average > 0) {\n        binaryString += (average % 2 == 0 ? '0' : '1');\n        average /= 2;\n    }\n\n    std::reverse(binaryString.begin(), binaryString.end());\n\n    return binaryString;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    // Helper lambda to convert an integer to its binary string representation\n    auto to_binary_string = [](int64_t val) -> std::string {\n        if (val == 0) {\n            return \"0\";\n        }\n        std::string binaryString = \"\";\n        while (val > 0) {\n            binaryString = (val % 2 == 0 ? \"0\" : \"1\") + binaryString;\n            val /= 2;\n        }\n        return binaryString;\n    };\n\n    // Handle n > m case as per requirement\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate average using SVE intrinsics\n    // Get a full predicate for 64-bit elements.\n    // svptrue_b64() creates a predicate where all elements are active.\n    svbool_t pg = svptrue_b64();\n\n    // Duplicate n and m into SVE vectors.\n    // svdup_s64(value) creates a vector where all elements are 'value'.\n    svint64_t vn = svdup_s64(n);\n    svint64_t vm = svdup_s64(m);\n\n    // Perform vector addition: vsum = vn + vm.\n    // svadd_s64(predicate, operand1, operand2) performs element-wise addition\n    // for active elements.\n    svint64_t vsum = svadd_s64(pg, vn, vm);\n\n    // Duplicate 2 into an SVE vector for division.\n    svint64_t vtwo = svdup_s64(2);\n\n    // Perform vector division: vavg_vec = vsum / vtwo.\n    // svdiv_s64 performs integer division, which truncates towards zero.\n    // For positive numbers, this is equivalent to floor division,\n    // matching the \"round the answer to the nearest integer (smaller one)\" requirement.\n    svint64_t vavg_vec = svdiv_s64(pg, vsum, vtwo);\n\n    // Extract the result from the first element of the vector.\n    // Since all elements in the vector hold the same calculated average,\n    // we can extract any element (e.g., the first one at index 0).\n    int64_t avg_result = svget_s64(vavg_vec, 0);\n\n    // Convert the rounded average to a binary string\n    return to_binary_string(avg_result);\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm> // Not strictly needed for the chosen binary conversion method, but often useful.\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    // Handle the case where n is greater than m as per the problem description.\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Use SVE intrinsics to calculate the average (n + m) / 2.\n    // First, duplicate the scalar inputs n and m into SVE vectors.\n    svint64_t sv_n = svdup_s64(n);\n    svint64_t sv_m = svdup_s64(m);\n\n    // Perform vector addition: sv_sum_nm = sv_n + sv_m\n    svint64_t sv_sum_nm = svadd_s64(sv_n, sv_m);\n\n    // Perform vector division by 2.\n    // For positive integers, a right shift by 1 (svsr_s64) is equivalent to integer division by 2,\n    // and is typically more efficient than svdiv_s64.\n    svint64_t sv_avg_vec = svsr_s64(sv_sum_nm, svdup_s64(1));\n\n    // Extract the scalar result from the SVE vector.\n    // Since all elements in the vector are identical (due to svdup_s64),\n    // we can extract any element. svlasta_s64 retrieves the last active element.\n    int64_t rounded_avg = svlasta_s64(sv_avg_vec);\n\n    // Convert the rounded average to its binary string representation.\n    if (rounded_avg == 0) {\n        return \"0\";\n    }\n\n    std::string binaryString = \"\";\n    while (rounded_avg > 0) {\n        // Prepend '0' or '1' based on the least significant bit.\n        binaryString = (rounded_avg % 2 == 0 ? \"0\" : \"1\") + binaryString;\n        // Right shift to process the next bit.\n        rounded_avg /= 2;\n    }\n\n    return binaryString;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <algorithm> // Required for std::reverse\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    // Handle the case where n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Use SVE intrinsics for the arithmetic calculation.\n    // For scalar inputs, we duplicate them across all lanes of an SVE vector\n    // and then extract the result from the first lane.\n    // This satisfies the requirement to use SVE intrinsics, although for a single\n    // scalar calculation, it doesn't provide performance benefits over scalar code.\n\n    // Create a predicate for all active lanes.\n    // svptrue_b64() creates a predicate where all 64-bit lanes are active.\n    svbool_t pg = svptrue_b64();\n\n    // Duplicate scalar inputs 'n' and 'm' into SVE vectors.\n    svint64_t vn = svdup_s64(n);\n    svint64_t vm = svdup_s64(m);\n\n    // Calculate 'count' = m - n + 1 using SVE intrinsics.\n    // v_diff = m - n\n    svint64_t v_diff = svsub_s64_x(pg, vm, vn);\n    // v_count = (m - n) + 1\n    svint64_t v_count = svadd_s64_x(pg, v_diff, svdup_s64(1));\n\n    // Calculate 'sum_terms' = n + m using SVE intrinsics.\n    svint64_t v_sum_terms = svadd_s64_x(pg, vn, vm);\n\n    // Calculate 'numerator' = count * sum_terms using SVE intrinsics.\n    svint64_t v_numerator = svmul_s64_x(pg, v_count, v_sum_terms);\n\n    // Calculate 'sum' = numerator / 2 using SVE intrinsics.\n    svint64_t v_sum = svdiv_s64_x(pg, v_numerator, svdup_s64(2));\n\n    // Calculate 'average' = sum / count using SVE intrinsics.\n    // Integer division naturally performs floor for positive numbers,\n    // which corresponds to \"round to the nearest integer (smaller one)\".\n    svint64_t v_avg = svdiv_s64_x(pg, v_sum, v_count);\n\n    // Extract the final rounded average from the first lane of the SVE vector.\n    // Since all lanes performed the same calculation on duplicated scalar inputs,\n    // all lanes will hold the same result.\n    int64_t rounded_avg = svget_lane_s64(v_avg, 0);\n\n    // Convert the rounded average to a binary string.\n    // This part is inherently scalar and is not suitable for SVE vectorization\n    // for a single number conversion.\n    std::string binaryString = \"\";\n    if (rounded_avg == 0) {\n        binaryString = \"0\";\n    } else {\n        while (rounded_avg > 0) {\n            binaryString += (rounded_avg % 2 == 0 ? '0' : '1');\n            rounded_avg /= 2;\n        }\n        // The binary string is built in reverse order, so reverse it.\n        std::reverse(binaryString.begin(), binaryString.end());\n    }\n    return binaryString;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n// Factorial lookup table for i! % 10000\n// Index 0 corresponds to 0!, index i to i!\n// For i >= 20, i! % 10000 is 0 because 20! contains factors 2^4 and 5^4,\n// making it divisible by 10000.\nstatic const int factorial_mod_10000[] = {\n    1,      // 0! (not used as i starts from 1 in problem)\n    1,      // 1!\n    2,      // 2!\n    6,      // 3!\n    24,     // 4!\n    120,    // 5!\n    720,    // 6!\n    5040,   // 7!\n    320,    // 8! (40320 % 10000)\n    2880,   // 9! (320 * 9)\n    8800,   // 10! (28800 % 10000)\n    6800,   // 11! (96800 % 10000)\n    1600,   // 12! (81600 % 10000)\n    800,    // 13! (20800 % 10000)\n    1200,   // 14! (11200 % 10000)\n    8000,   // 15! (18000 % 10000)\n    8000,   // 16! (128000 % 10000)\n    6000,   // 17! (136000 % 10000)\n    8000,   // 18! (108000 % 10000)\n    2000,   // 19! (152000 % 10000)\n    0       // 20! (400000 % 10000) and all subsequent factorials\n};\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n\n    // Loop variable 'i' represents the starting 1-based index for the current SVE vector chunk.\n    // The loop continues as long as 'i' is less than or equal to 'n'.\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Generate a predicate 'pg' that is true for active lanes within the current vector.\n        // It ensures that we only process elements up to 'n'.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of 1-based indices for the current chunk: {i, i+1, i+2, ...}\n        // svindex_s32(0, 1) creates {0, 1, 2, ...}, then we add 'i' to shift it.\n        svint32_t indices = svadd_n_s32(svindex_s32(0, 1), i);\n\n        // Create predicates for even and odd indices.\n        // (index & 1) is 0 for even, 1 for odd.\n        svbool_t is_even_pred = svcmpeq_n_s32(pg, svand_n_s32(indices, 1), 0);\n        svbool_t is_odd_pred = svcmpne_n_s32(pg, svand_n_s32(indices, 1), 0);\n\n        // --- Calculate values for odd indices (sum of numbers from 1 to i) ---\n        // The formula for sum of numbers from 1 to i is i * (i + 1) / 2.\n        svint32_t i_plus_1 = svadd_n_s32(indices, 1);\n        svint32_t sum_val_numerator = svmul_s32(indices, i_plus_1);\n        svint32_t odd_results = svdiv_n_s32(sum_val_numerator, 2);\n\n        // --- Calculate values for even indices (factorial of i modulo 10000) ---\n        // Cap the indices at 20 for lookup, as i! % 10000 is 0 for i >= 20.\n        svint32_t fact_indices_capped = svmin_n_s32(indices, 20);\n        // Gather factorial values from the precomputed lookup table.\n        // The 'pg' predicate ensures that only active lanes perform the gather.\n        svint32_t even_results = svld1_gather_s32offset(pg, factorial_mod_10000, fact_indices_capped);\n\n        // Combine the results: select 'even_results' where 'is_even_pred' is true,\n        // otherwise select 'odd_results'.\n        svint32_t final_chunk_results = svsel_s32(is_even_pred, even_results, odd_results);\n\n        // Store the computed results into the 'result' vector.\n        // The 'result' vector is 0-indexed, so we store at &result[i-1].\n        // The 'pg' predicate ensures that only valid elements within the chunk are written.\n        svst1_s32(pg, &result[i-1], final_chunk_results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n// Precomputed factorial values modulo 10000 for i from 0 to 19.\n// For i >= 20, i! % 10000 is 0.\n// The array is 0-indexed, but problem states i starts from 1.\n// factorial_mod_10000[k] stores k! % 10000.\n// Index 0 is for 0!, which is 1.\nstatic const int factorial_mod_10000[] = {\n    1,    // 0! (not used for i >= 1)\n    1,    // 1!\n    2,    // 2!\n    6,    // 3!\n    24,   // 4!\n    120,  // 5!\n    720,  // 6!\n    5040, // 7!\n    320,  // 8! (40320 % 10000)\n    2880, // 9! (28800 % 10000)\n    8800, // 10! (28800 % 10000)\n    6800, // 11! (96800 % 10000)\n    1600, // 12! (81600 % 10000)\n    800,  // 13! (20800 % 10000)\n    1200, // 14! (11200 % 10000)\n    8000, // 15! (18000 % 10000)\n    8000, // 16! (128000 % 10000)\n    6000, // 17! (136000 % 10000)\n    8000, // 18! (108000 % 10000)\n    2000  // 19! (152000 % 10000)\n};\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> results(n);\n\n    if (n <= 0) {\n        return results;\n    }\n\n    // Get the vector length for 32-bit integers\n    // This determines how many elements are processed in parallel.\n    int svl = svcntw();\n\n    // Loop through the elements in chunks of svl\n    // 'i' represents the starting index (1-based) for the current SVE vector.\n    for (int i = 1; i <= n; i += svl) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b32(base, limit) generates a predicate that is true for\n        // elements from 'base' up to 'limit - 1'.\n        // We need to process elements up to 'n', so 'limit' is 'n + 1'.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of current indices: [i, i+1, ..., i+svl-1]\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // --- Calculate for even indices (factorial) ---\n        // Predicate for even indices: (current_indices % 2 == 0)\n        // svand_s32(pg, current_indices, svdup_s32(1)) checks the least significant bit.\n        // If LSB is 0, the number is even.\n        svbool_t pg_even = svcmpeq_s32(pg, svand_s32(pg, current_indices, svdup_s32(1)), svdup_s32(0));\n\n        // Predicate for small factorials (i < 20) within the even indices.\n        // For i >= 20, i! % 10000 is 0.\n        svbool_t pg_small_fact = svcmplt_s32(pg_even, current_indices, svdup_s32(20));\n\n        // Initialize factorial results vector with 0. This handles the case where i >= 20.\n        svint32_t fact_res_vec = svdup_s32(0);\n\n        // Load factorial values from the lookup table for small even indices.\n        // svld1_gather_s32offset performs a gather load, using 'current_indices' as offsets\n        // from the base address 'factorial_mod_10000'.\n        // The 'pg_small_fact' predicate ensures that only elements corresponding to\n        // small even indices are loaded; others remain 0.\n        fact_res_vec = svld1_gather_s32offset(pg_small_fact, factorial_mod_10000, current_indices);\n\n        // --- Calculate for odd indices (sum of numbers) ---\n        // Predicate for odd indices: (current_indices % 2 != 0)\n        svbool_t pg_odd = svcmpne_s32(pg, svand_s32(pg, current_indices, svdup_s32(1)), svdup_s32(0));\n\n        // Calculate sum: i * (i + 1) / 2\n        // Operations are predicated by pg_odd to only affect odd indices.\n        svint32_t i_plus_1 = svadd_s32(pg_odd, current_indices, svdup_s32(1));\n        svint32_t sum_numerator = svmul_s32(pg_odd, current_indices, i_plus_1);\n        svint32_t sum_res_vec = svdiv_s32(pg_odd, sum_numerator, svdup_s32(2));\n\n        // --- Combine results ---\n        // Select between the factorial result (if even) and the sum result (if odd).\n        // svsel_s32(predicate, true_value, false_value)\n        svint32_t final_results = svsel_s32(pg_even, fact_res_vec, sum_res_vec);\n\n        // Store the results into the output vector.\n        // The vector 'results' is 0-indexed, so we store at 'results[i - 1]'.\n        // The 'pg' predicate ensures that only valid elements within the [1, n] range\n        // are written, handling the tail case.\n        svst1_s32(pg, &results[i - 1], final_results);\n    }\n\n    return results;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n// Precompute factorials modulo 10000 up to 20.\n// For i >= 20, factorial(i) % 10000 is 0.\nstatic int factorials_mod_10000[21]; // Array to store factorials from index 0 to 20\nstatic bool precomputed_factorials = false;\n\n// Function to precompute factorials, called once.\nvoid precompute_factorials_once() {\n    if (precomputed_factorials) {\n        return;\n    }\n    factorials_mod_10000[0] = 1; // Conventionally 0! = 1\n    factorials_mod_10000[1] = 1; // 1! = 1\n    for (int k = 2; k <= 20; ++k) {\n        factorials_mod_10000[k] = (factorials_mod_10000[k - 1] * k) % 10000;\n    }\n    precomputed_factorials = true;\n}\n\nstd::vector<int> func_simd(int n) {\n    precompute_factorials_once(); // Ensure factorials are precomputed\n\n    std::vector<int> result(n);\n    int i = 1; // Logical index, starts from 1 as per problem description\n\n    // Loop through the elements, processing svcntw() elements at a time\n    for (; i <= n; i += svcntw()) {\n        // 1. Create an active predicate for the current vector chunk.\n        // This predicate is true for elements whose logical index is <= n.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // 2. Generate a vector of current logical indices: {i, i+1, i+2, ...}\n        svint32_t v_current_idx = svindex_s32(i, 1);\n\n        // 3. Calculate results for odd indices: sum of numbers from 1 to i (i * (i + 1) / 2)\n        //    These calculations are performed for all active lanes, and later selected.\n        svint32_t v_idx_plus_1 = svadd_s32_z(pg, v_current_idx, svdup_s32(1));\n        svint32_t v_product = svmul_s32_z(pg, v_current_idx, v_idx_plus_1);\n        svint32_t v_sum_results = svdiv_s32_z(pg, v_product, svdup_s32(2)); // Integer division\n\n        // 4. Calculate results for even indices: factorial(i) % 10000\n        //    First, create predicates for even and odd indices within the current vector chunk.\n        svbool_t pg_even = svcmpeq_s32(pg, svand_s32_z(pg, v_current_idx, svdup_s32(1)), svdup_s32(0)); // (idx & 1) == 0\n        // svbool_t pg_odd = svcmpne_s32(pg, svand_s32_z(pg, v_current_idx, svdup_s32(1)), svdup_s32(0)); // (idx & 1) != 0\n\n        svint32_t v_fact_results;\n\n        // Create a predicate for even indices that are >= 20. For these, the result is 0.\n        svbool_t pg_even_ge_20 = svand_b(pg_even, svcmpge_s32(pg, v_current_idx, svdup_s32(20)));\n\n        // Create a predicate for even indices that are < 20. For these, we use the lookup table.\n        svbool_t pg_even_lt_20 = svand_b(pg_even, svcmplt_s32(pg, v_current_idx, svdup_s32(20)));\n\n        // Gather factorial values from the precomputed table for indices < 20.\n        // The v_current_idx directly serves as the offset for the gather load.\n        v_fact_results = svld1_gather_s32offset(pg_even_lt_20, factorials_mod_10000, v_current_idx);\n\n        // For even indices >= 20, set the result to 0.\n        v_fact_results = svsel_s32(pg_even_ge_20, svdup_s32(0), v_fact_results);\n\n        // 5. Combine results based on the even/odd predicate.\n        // If pg_even is true, select from v_fact_results; otherwise, select from v_sum_results.\n        svint32_t v_final_results = svsel_s32(pg_even, v_fact_results, v_sum_results);\n\n        // 6. Store the computed SVE vector into the output std::vector.\n        // (i - 1) is used because result vector is 0-indexed while i is 1-indexed.\n        svst1_s32(pg, result.data() + (i - 1), v_final_results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n// Precomputed factorial values modulo 10000\n// factorial_mod_10000_table[i] stores i! % 10000\n// For i >= 20, i! % 10000 is 0.\nstatic const int factorial_mod_10000_table[] = {\n    0,    // 0! (dummy, as i starts from 1)\n    1,    // 1!\n    2,    // 2!\n    6,    // 3!\n    24,   // 4!\n    120,  // 5!\n    720,  // 6!\n    5040, // 7!\n    320,  // 8! (40320 % 10000)\n    2880, // 9! (362880 % 10000)\n    8800, // 10! (3628800 % 10000)\n    6800, // 11! (39916800 % 10000)\n    1600, // 12! (479001600 % 10000)\n    800,  // 13! (6227020800 % 10000)\n    1200, // 14! (87178291200 % 10000)\n    8000, // 15! (1307674368000 % 10000)\n    8000, // 16!\n    6000, // 17!\n    8000, // 18!\n    2000  // 19!\n};\nstatic const int FACTORIAL_TABLE_SIZE = sizeof(factorial_mod_10000_table) / sizeof(factorial_mod_10000_table[0]);\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 1; // Current starting index for the SVE vector, corresponds to problem's 'i'\n\n    while (i <= n) {\n        // Generate a predicate for active lanes, covering indices from 'i' up to 'n'.\n        // svwhilelt_b32(start, end) generates a predicate for elements < end.\n        // So, for indices i, i+1, ..., n, we use svwhilelt_b32(i, n + 1).\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n        \n        // If no lanes are active, we've processed all elements.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Generate a vector of current indices: i, i+1, i+2, ...\n        svint32_t indices = svindex_s32(i, 1);\n\n        // --- Determine even/odd predicates ---\n        // Calculate (indices % 2). Result is 0 for even, 1 for odd.\n        svint32_t indices_mod_2 = svand_n_s32(pg, indices, 1);\n        \n        // Predicate for even indices: (indices % 2 == 0)\n        svbool_t even_pred = sveq_n_s32(pg, indices_mod_2, 0);\n        \n        // Predicate for odd indices: (indices % 2 != 0)\n        svbool_t odd_pred = svneq_n_s32(pg, indices_mod_2, 0);\n\n        // Initialize a vector to accumulate results for the current chunk.\n        // Values for inactive lanes or lanes not covered by a specific calculation will remain 0.\n        svint32_t current_results = svdup_n_s32(0);\n\n        // --- Calculate for odd indices: sum_from_1_to_i(i) = i * (i + 1) / 2 ---\n        // Only perform these operations for lanes where odd_pred is true.\n        svint32_t i_plus_1 = svadd_n_s32(odd_pred, indices, 1);\n        svint32_t sum_values = svmul_s32_x(odd_pred, indices, i_plus_1);\n        // Integer division by 2 can be done with right shift.\n        sum_values = svasr_n_s32_x(odd_pred, sum_values, 1);\n\n        // Select sum_values for odd indices into current_results.\n        current_results = svsel(odd_pred, sum_values, current_results);\n\n        // --- Calculate for even indices: factorial(i) % 10000 ---\n        // For i >= 20, factorial(i) % 10000 is 0.\n        // We use a lookup table for i < 20.\n        \n        // Create a predicate for indices that are within the lookup table range (1 to 19).\n        // This predicate is combined with `even_pred` to ensure we only look up for even indices\n        // that are also within the table's valid range.\n        svbool_t table_lookup_pred = svcmplt_n_s32(even_pred, indices, FACTORIAL_TABLE_SIZE);\n\n        // Gather values from the precomputed table.\n        // svld1_gather_s32offset(predicate, base_pointer, offsets_vector)\n        // It loads base_pointer[offsets_vector[lane]] for active lanes.\n        svint32_t factorial_values = svld1_gather_s32offset(table_lookup_pred, factorial_mod_10000_table, indices);\n\n        // Select factorial_values for even indices into current_results.\n        // For even indices >= 20, `table_lookup_pred` will be false, so `factorial_values` for that lane\n        // will remain 0 (from the gather operation on an inactive lane), which is the correct result.\n        current_results = svsel(even_pred, factorial_values, current_results);\n\n        // Store the computed results from the SVE vector back into the std::vector.\n        // The `pg` predicate ensures only valid elements within the 'n' range are written.\n        svst1_s32(pg, &result[i - 1], current_results);\n\n        // Advance the starting index for the next iteration by the number of elements processed.\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n// Precomputed factorial values modulo 10000\n// Index k corresponds to k! % 10000.\n// Note: 0! is 1, but the problem states 'i' starts from 1.\n// For i >= 20, i! % 10000 is 0.\n// The table is 0-indexed, so factorial_mod_10000_table[k] stores k! % 10000.\n// We need values for i from 1 up to 19.\nstatic const int factorial_mod_10000_table[] = {\n    1,    // 0! (not used as i starts from 1)\n    1,    // 1!\n    2,    // 2!\n    6,    // 3!\n    24,   // 4!\n    120,  // 5!\n    720,  // 6!\n    5040, // 7!\n    320,  // 8! (40320 % 10000)\n    2880, // 9!\n    8800, // 10!\n    6800, // 11!\n    1600, // 12!\n    800,  // 13!\n    1200, // 14!\n    8000, // 15!\n    8000, // 16!\n    6000, // 17!\n    8000, // 18!\n    2000  // 19!\n};\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n\n    // Get the vector length for 32-bit integers.\n    // This is the number of 32-bit elements an SVE vector can hold.\n    const int VL = svcntw();\n\n    // Loop through the vector in chunks of VL.\n    // 'i' represents the starting logical index (1-based) for the current SVE vector.\n    for (int i = 1; i <= n; i += VL) {\n        // Create a predicate for the current vector chunk.\n        // This predicate is true for active lanes (i.e., within bounds of 'n').\n        // svwhilelt_b32(start, end) generates a predicate that is true for elements\n        // starting from 'start' up to (but not including) 'end'.\n        // Since 'i' is 1-based and 'n' is the maximum index, we use 'n + 1' as the exclusive upper bound.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of 1-based indices: {i, i+1, i+2, ..., i+VL-1}.\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // --- Calculate for even indices (factorial) ---\n        // Predicate for even indices: (index % 2 == 0).\n        // svand_s32(current_indices, svdup_s32(1)) computes index & 1 (the least significant bit).\n        // If the LSB is 0, the number is even.\n        // The 'pg' predicate ensures we only consider active lanes.\n        svbool_t even_pred = svcmpeq(pg, svand_s32(current_indices, svdup_s32(1)), svdup_s32(0));\n\n        // Clamp indices for factorial lookup: min(index, 19).\n        // This maps any index >= 19 to 19, preventing out-of-bounds access for the lookup table.\n        // The actual correction for i >= 20 (result 0) is handled in the next step.\n        svint32_t clamped_indices = svmin_s32(current_indices, svdup_s32(19));\n\n        // Gather factorial values from the lookup table.\n        // svld1_gather_s32offset loads elements from memory using a base address and a vector of offsets.\n        // The 'even_pred' ensures that only lanes corresponding to even indices are loaded.\n        svint32_t factorial_results = svld1_gather_s32offset(even_pred, factorial_mod_10000_table, clamped_indices);\n\n        // Correct factorial results for indices >= 20 (set to 0).\n        // Create a predicate for lanes that are both active, even, AND have an index >= 20.\n        // The 'even_pred' ensures this comparison only happens for relevant lanes.\n        svbool_t ge20_pred = svcmpge(even_pred, current_indices, svdup_s32(20));\n        // Use svsel_s32 to conditionally select 0 for these lanes, otherwise keep the loaded value.\n        factorial_results = svsel_s32(ge20_pred, svdup_s32(0), factorial_results);\n\n        // --- Calculate for odd indices (sum 1 to i) ---\n        // Predicate for odd indices: (index % 2 != 0).\n        // If the LSB is 1, the number is odd.\n        // The 'pg' predicate ensures we only consider active lanes.\n        svbool_t odd_pred = svcmpeq(pg, svand_s32(current_indices, svdup_s32(1)), svdup_s32(1));\n\n        // Calculate sum: i * (i + 1) / 2.\n        svint32_t i_plus_1 = svadd_s32(current_indices, svdup_s32(1));\n        svint32_t sum_results = svmul_s32(current_indices, i_plus_1);\n        sum_results = svdiv_s32(sum_results, svdup_s32(2));\n\n        // --- Combine results based on predicates ---\n        // Use svsel_s32 to select between 'factorial_results' and 'sum_results'.\n        // If 'even_pred' is true for a lane, take 'factorial_results'; otherwise, take 'sum_results'.\n        // This implicitly handles the 'odd' case for the 'else' branch.\n        svint32_t final_results = svsel_s32(even_pred, factorial_results, sum_results);\n\n        // Store the results back to the std::vector.\n        // The offset in the vector is (i - 1) because 'i' is 1-based, but std::vector is 0-indexed.\n        // The 'pg' predicate ensures that only active lanes are written to memory.\n        svst1_s32(pg, &result[i - 1], final_results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // For std::iota, though not strictly used in the final version\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Static lookup table for palindrome status, initialized once.\n    // Using uint8_t to store boolean (0 or 1) for efficient SVE gather loads.\n    static std::vector<uint8_t> is_pal_lookup;\n    static bool initialized = false;\n\n    if (!initialized) {\n        // Resize to n+1, as numbers are 1-indexed up to 1024.\n        // Max n is 1024, so lookup table size 1025 (indices 0 to 1024).\n        is_pal_lookup.resize(1025);\n        for (int i = 1; i <= 1024; ++i) {\n            int original_num = i;\n            int reversed_num = 0;\n            int temp_num = i;\n            while (temp_num > 0) {\n                int digit = temp_num % 10;\n                reversed_num = reversed_num * 10 + digit;\n                temp_num /= 10;\n            }\n            is_pal_lookup[i] = (original_num == reversed_num) ? 1 : 0;\n        }\n        initialized = true;\n    }\n\n    long long total_even_palindromes = 0;\n    long long total_odd_palindromes = 0;\n\n    // Loop through numbers from 1 to n in chunks determined by SVE vector length.\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Create a predicate for the current batch of numbers.\n        // This predicate ensures we only process numbers up to 'n' (inclusive).\n        // svwhilelt_b32(start, end) generates a predicate where lanes are active\n        // as long as the current index (starting from 'start' and incrementing)\n        // is less than 'end'. Here, 'end' is n + 1.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of numbers: i, i+1, i+2, ...\n        // svindex_s32(start, step) generates a vector with elements start, start+step, start+2*step, ...\n        svint32_t current_numbers = svadd_s32_x(pg, svindex_s32(i, 1), svdup_s32(0));\n        svuint32_t current_numbers_u32 = svreinterpret_u32(current_numbers); // Cast to unsigned for gather load offset\n\n        // Load palindrome status (0 or 1) from the lookup table for the current numbers.\n        // svld1_gather_u32offset_u8 loads 8-bit values using 32-bit offsets.\n        svuint8_t pal_status_u8 = svld1_gather_u32offset_u8(pg, is_pal_lookup.data(), current_numbers_u32);\n\n        // Create a boolean predicate where lanes are true if the corresponding number is a palindrome.\n        // svcmpne_u8(pg, a, b) compares elements of 'a' and 'b' for inequality,\n        // only for lanes active in 'pg'.\n        svbool_t is_palindrome_mask = svcmpne_u8(pg, pal_status_u8, svdup_u8(0));\n\n        // Check parity (even/odd) for the numbers that are palindromes.\n        // A number is even if its LSB (Least Significant Bit) is 0, odd if LSB is 1.\n        // LSB can be obtained by `number & 1`.\n        // svand_s32_x(pg, a, b) performs bitwise AND for active lanes in 'pg'.\n        svint32_t lsb_values = svand_s32_x(is_palindrome_mask, current_numbers, svdup_s32(1));\n\n        // Create masks for even and odd palindromes.\n        // These masks are active only for lanes that are palindromes AND satisfy the parity condition.\n        // svcmpeq_s32(pg, a, b) compares elements of 'a' and 'b' for equality,\n        // svcmpne_s32(pg, a, b) compares elements of 'a' and 'b' for inequality,\n        // both only for lanes active in 'pg'.\n        svbool_t is_even_palindrome_mask = svcmpeq_s32(is_palindrome_mask, lsb_values, svdup_s32(0)); // LSB is 0 (even)\n        svbool_t is_odd_palindrome_mask = svcmpne_s32(is_palindrome_mask, lsb_values, svdup_s32(0)); // LSB is 1 (odd)\n\n        // Count the number of active lanes in the even and odd palindrome masks.\n        // svcntp_b32(pg, mask) counts the number of true bits in 'mask' where 'pg' is also true.\n        total_even_palindromes += svcntp_b32(pg, is_even_palindrome_mask);\n        total_odd_palindromes += svcntp_b32(pg, is_odd_palindrome_mask);\n    }\n\n    return {(int)total_even_palindromes, (int)total_odd_palindromes};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n// Helper function to check if a vector of numbers contains palindromes\n// This function operates on a vector of integers 'v' using the predicate 'pg'\n// It returns a boolean vector indicating which elements are palindromes.\nstatic svbool_t is_palindrome_vec(svbool_t pg, svint32_t v) {\n    // Condition for 1-digit numbers (1-9)\n    // All 1-digit numbers are palindromes.\n    svbool_t is_1_digit = svcmplt_n_s32(pg, v, 10);\n\n    // Condition for 2-digit numbers (10-99)\n    // A 2-digit number 'xy' is a palindrome if x == y.\n    // This means (number % 10) == (number / 10).\n    svbool_t is_2_digit_range = svand_b(svcmpge_n_s32(pg, v, 10), svcmplt_n_s32(pg, v, 100));\n    svint32_t ones_2 = svmod_n_s32(pg, v, 10);\n    svint32_t tens_2 = svdiv_n_s32(pg, v, 10);\n    svbool_t is_2_digit_pal = svcmpeq_s32(pg, ones_2, tens_2);\n    svbool_t pal_2_digits = svand_b(is_2_digit_range, is_2_digit_pal);\n\n    // Condition for 3-digit numbers (100-999)\n    // A 3-digit number 'xyz' is a palindrome if x == z.\n    // This means (number % 10) == (number / 100).\n    svbool_t is_3_digit_range = svand_b(svcmpge_n_s32(pg, v, 100), svcmplt_n_s32(pg, v, 1000));\n    svint32_t ones_3 = svmod_n_s32(pg, v, 10);\n    svint32_t hundreds_3 = svdiv_n_s32(pg, v, 100);\n    svbool_t is_3_digit_pal = svcmpeq_s32(pg, ones_3, hundreds_3);\n    svbool_t pal_3_digits = svand_b(is_3_digit_range, is_3_digit_pal);\n\n    // Condition for 4-digit numbers (1000-1024, given n <= 2^10)\n    // A 4-digit number 'xyzw' is a palindrome if x == w and y == z.\n    // This means (number % 10) == (number / 1000) AND ((number / 10) % 10) == ((number / 100) % 10).\n    svbool_t is_4_digit_range = svand_b(svcmpge_n_s32(pg, v, 1000), svcmplt_n_s32(pg, v, 10000));\n    svint32_t ones_4 = svmod_n_s32(pg, v, 10);\n    svint32_t thousands_4 = svdiv_n_s32(pg, v, 1000);\n    svint32_t tens_4 = svmod_n_s32(pg, svdiv_n_s32(pg, v, 10), 10);\n    svint32_t hundreds_4 = svmod_n_s32(pg, svdiv_n_s32(pg, v, 100), 10);\n    svbool_t cond1_4 = svcmpeq_s32(pg, ones_4, thousands_4);\n    svbool_t cond2_4 = svcmpeq_s32(pg, tens_4, hundreds_4);\n    svbool_t is_4_digit_pal = svand_b(cond1_4, cond2_4);\n    svbool_t pal_4_digits = svand_b(is_4_digit_range, is_4_digit_pal);\n\n    // Combine all palindrome conditions using logical OR\n    svbool_t total_palindromes = svorr_b(is_1_digit, pal_2_digits);\n    total_palindromes = svorr_b(total_palindromes, pal_3_digits);\n    total_palindromes = svorr_b(total_palindromes, pal_4_digits);\n\n    return total_palindromes;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Get the number of 32-bit elements in an SVE vector (Vector Length)\n    int VL = svcntw();\n\n    // Loop through numbers from 1 to n in chunks of VL\n    for (int i = 1; i <= n; i += VL) {\n        // Create a predicate to activate lanes only for numbers within the range [1, n]\n        // svwhilelt_b32(start_value, limit) generates a predicate that is true\n        // for elements starting from start_value as long as they are less than limit.\n        // Here, it's for numbers i, i+1, ..., up to n.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of current numbers: i, i+1, i+2, ...\n        // svindex_s32(start, step) generates a vector with elements start, start+step, ...\n        svint32_t current_numbers = svindex_s32(i, 1);\n\n        // Determine which numbers in the current vector are palindromes\n        svbool_t is_pal_mask = is_palindrome_vec(pg, current_numbers);\n\n        // Check parity for the current numbers\n        svint32_t mod_2_result = svmod_n_s32(pg, current_numbers, 2);\n        svbool_t is_even_mask = svcmpeq_n_s32(pg, mod_2_result, 0);\n        svbool_t is_odd_mask = svcmpeq_n_s32(pg, mod_2_result, 1);\n\n        // Combine palindrome mask with parity masks to get final counts\n        // Only count if the number is a palindrome AND has the desired parity\n        svbool_t even_pal_final_mask = svand_b(is_pal_mask, is_even_mask);\n        svbool_t odd_pal_final_mask = svand_b(is_pal_mask, is_odd_mask);\n\n        // Count the number of active (true) elements in the final masks\n        even_count += svcntp_b32(pg, even_pal_final_mask);\n        odd_count += svcntp_b32(pg, odd_pal_final_mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nHelper function to check if numbers in a vector are palindromes using SVE.\nIt takes a vector of integers and a predicate, and returns a boolean vector\nwhere 'true' indicates the corresponding number is a palindrome.\n*/\nstatic svbool_t is_palindrome_vec(svint32_t sv_original_nums, svbool_t pg) {\n    svint32_t sv_nums_to_reverse = sv_original_nums;\n    svint32_t sv_reversed_nums = svdup_n_s32(0);\n    svint32_t sv_ten = svdup_n_s32(10);\n    svint32_t sv_zero = svdup_n_s32(0);\n\n    // The maximum value of n is 1024. The largest number to check is 1024.\n    // The maximum number of digits for numbers up to 1024 is 4 (e.g., 1001).\n    // The loop iterates a fixed maximum number of times (4) to reverse digits.\n    // The 'active_lanes' predicate ensures operations only apply to lanes\n    // where the number has not yet been fully reversed (i.e., is still > 0).\n    for (int k = 0; k < 4; ++k) {\n        svbool_t active_lanes = svcmpgt_s32(pg, sv_nums_to_reverse, sv_zero);\n        \n        // If no lanes are active (all numbers have been reversed), break early.\n        if (svptest_any(pg, active_lanes) == 0) {\n            break;\n        }\n\n        // Extract the last digit: digit = num % 10\n        svint32_t sv_digits = svmod_s32(active_lanes, sv_nums_to_reverse, sv_ten);\n        \n        // Build the reversed number: reversed_num = reversed_num * 10 + digit\n        sv_reversed_nums = svadd_s32(active_lanes, svmul_s32(active_lanes, sv_reversed_nums, sv_ten), sv_digits);\n        \n        // Remove the last digit from the original number: num = num / 10\n        sv_nums_to_reverse = svdiv_s32(active_lanes, sv_nums_to_reverse, sv_ten);\n    }\n\n    // Compare the original numbers with their reversed counterparts to find palindromes.\n    return svcmpeq_s32(pg, sv_original_nums, sv_reversed_nums);\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_palindromes = 0;\n    int odd_palindromes = 0;\n\n    // Get the vector length in terms of 32-bit integers (words).\n    int vl = svcntw();\n\n    // Iterate through numbers from 1 to n in chunks of VL.\n    for (int i = 1; i <= n; i += vl) {\n        // Create a predicate for the current batch of numbers.\n        // This predicate handles the tail end of the loop, ensuring we only process\n        // numbers up to 'n' (inclusive).\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of numbers: [i, i+1, ..., i+vl-1].\n        // svindex_s32(0, 1) generates a sequence [0, 1, 2, ...].\n        // Adding 'i' to this sequence creates the desired batch.\n        svint32_t sv_current_nums = svadd_s32(pg, svdup_n_s32(i), svindex_s32(0, 1));\n\n        // Determine which numbers in the current batch are palindromes.\n        svbool_t sv_palindromes_mask = is_palindrome_vec(sv_current_nums, pg);\n\n        // Check for even/odd property of numbers.\n        // A number is odd if its least significant bit (LSB) is 1.\n        // svand_s32(pg, sv_current_nums, svdup_n_s32(1)) isolates the LSB.\n        svint32_t sv_one = svdup_n_s32(1);\n        svbool_t sv_is_odd = svcmpeq_s32(pg, svand_s32(pg, sv_current_nums, sv_one), sv_one);\n        svbool_t sv_is_even = svnot_b(pg, sv_is_odd); // Even if not odd.\n\n        // Combine masks to find even palindromes and odd palindromes.\n        svbool_t sv_even_palindromes = svand_b(pg, sv_palindromes_mask, sv_is_even);\n        svbool_t sv_odd_palindromes = svand_b(pg, sv_palindromes_mask, sv_is_odd);\n\n        // Count the number of true predicates (palindromes) in each category.\n        even_palindromes += svcntp_b(pg, sv_even_palindromes);\n        odd_palindromes += svcntp_b(pg, sv_odd_palindromes);\n    }\n\n    return {even_palindromes, odd_palindromes};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Get the number of 32-bit elements in an SVE vector\n    // This determines the vector length (VL) for svint32_t\n    int vl = svcntw();\n\n    // Loop through numbers from 1 to n in chunks of VL\n    for (int i = 1; i <= n; i += vl) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that operations are only performed on valid numbers\n        // within the range [1, n], especially for the last partial vector.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of numbers: {i, i+1, i+2, ..., i+vl-1}\n        svint32_t numbers = svadd_s32(svdup_s32(i), svindex_s32(0, 1));\n\n        // Extract digits for palindrome check using SVE intrinsics\n        // d0_v: units digit (N % 10)\n        // d1_v: tens digit ((N / 10) % 10)\n        // d2_v: hundreds digit ((N / 100) % 10)\n        // d3_v: thousands digit ((N / 1000) % 10)\n        svint32_t d0_v = svmod_s32(pg, numbers, 10);\n        svint32_t d1_v = svmod_s32(pg, svdiv_s32(pg, numbers, 10), 10);\n        svint32_t d2_v = svmod_s32(pg, svdiv_s32(pg, numbers, 100), 10);\n        svint32_t d3_v = svmod_s32(pg, svdiv_s32(pg, numbers, 1000), 10);\n\n        // Create masks for numbers based on their digit count\n        svbool_t p_1_digit = svcmplt_s32(pg, numbers, 10); // N < 10\n        svbool_t p_2_digit = svand_b(svcmpge_s32(pg, numbers, 10), svcmplt_s32(pg, numbers, 100)); // 10 <= N < 100\n        svbool_t p_3_digit = svand_b(svcmpge_s32(pg, numbers, 100), svcmplt_s32(pg, numbers, 1000)); // 100 <= N < 1000\n        // For N up to 1024, only 1001 is a 4-digit palindrome.\n        svbool_t p_4_digit = svand_b(svcmpge_s32(pg, numbers, 1000), svcmplt_s32(pg, numbers, 10000)); // 1000 <= N < 10000\n\n        // Palindrome conditions for each digit count\n        // 2-digit: tens digit == units digit (e.g., 11, 22)\n        svbool_t pal_cond_2 = svcmpeq_s32(pg, d1_v, d0_v);\n        // 3-digit: hundreds digit == units digit (e.g., 101, 121)\n        svbool_t pal_cond_3 = svcmpeq_s32(pg, d2_v, d0_v);\n        // 4-digit: thousands digit == units digit AND hundreds digit == tens digit (e.g., 1001)\n        svbool_t pal_cond_4_part1 = svcmpeq_s32(pg, d3_v, d0_v);\n        svbool_t pal_cond_4_part2 = svcmpeq_s32(pg, d2_v, d1_v);\n        svbool_t pal_cond_4 = svand_b(pal_cond_4_part1, pal_cond_4_part2);\n\n        // Combine all palindrome conditions using logical OR\n        // A number is a palindrome if it's 1-digit OR (2-digit AND pal_cond_2) OR ...\n        svbool_t is_palindrome_mask = svorr_b(\n            p_1_digit,\n            svorr_b(\n                svand_b(p_2_digit, pal_cond_2),\n                svorr_b(\n                    svand_b(p_3_digit, pal_cond_3),\n                    svand_b(p_4_digit, pal_cond_4)\n                )\n            )\n        );\n\n        // Check if numbers are even or odd\n        svbool_t is_even_mask = svcmpeq_s32(pg, svmod_s32(pg, numbers, 2), 0);\n        svbool_t is_odd_mask = svnot_b(pg, is_even_mask); // Odd is simply not even\n\n        // Combine palindrome and even/odd masks\n        svbool_t even_palindrome_mask = svand_b(is_palindrome_mask, is_even_mask);\n        svbool_t odd_palindrome_mask = svand_b(is_palindrome_mask, is_odd_mask);\n\n        // Count the number of active (true) elements in the combined masks\n        even_count += svcntp_b32(pg, even_palindrome_mask);\n        odd_count += svcntp_b32(pg, odd_palindrome_mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Loop through numbers in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Get the predicate for active lanes.\n        // svwhilelt_b32(base, limit) generates a predicate that is true for elements\n        // starting from 'base' and incrementing by 1, as long as the value is less than 'limit'.\n        // Here, it ensures we only process numbers up to 'n'.\n        svbool_t pg = svwhilelt_b32(i, n + 1);\n\n        // Generate a vector of numbers: [i, i+1, i+2, ..., i+VL-1].\n        // svindex_s32(start, step) generates a vector where element k is start + k * step.\n        svint32_t nums = svindex_s32(i, 1);\n\n        // Predicate to mark palindromes. Initialize to all false.\n        svbool_t is_pal_pred = svfalse_b();\n\n        // --- Palindrome Check Logic ---\n\n        // Case 1: 1-digit numbers (1 to 9) are always palindromes.\n        // Condition: nums < 10\n        svbool_t cond1_range = svcmplt_s32(pg, nums, 10);\n        is_pal_pred = svorr_b(is_pal_pred, cond1_range); // Add these to the palindrome predicate\n\n        // Case 2: 2-digit numbers (10 to 99).\n        // Condition: 10 <= nums < 100 AND (first_digit == last_digit)\n        svbool_t cond2_range = svand_b(svcmpge_s32(pg, nums, 10), svcmplt_s32(pg, nums, 100));\n        svint32_t d1_2 = svdiv_s32(pg, nums, 10); // First digit (e.g., 11 -> 1, 23 -> 2)\n        svint32_t d2_2 = svmod_s32(pg, nums, 10); // Last digit (e.g., 11 -> 1, 23 -> 3)\n        svbool_t cond2_match = svcmpeq_s32(cond2_range, d1_2, d2_2); // Compare only for numbers in this range\n        is_pal_pred = svorr_b(is_pal_pred, cond2_match); // Add these to the palindrome predicate\n\n        // Case 3: 3-digit numbers (100 to 999).\n        // Condition: 100 <= nums < 1000 AND (first_digit == last_digit)\n        svbool_t cond3_range = svand_b(svcmpge_s32(pg, nums, 100), svcmplt_s32(pg, nums, 1000));\n        svint32_t d1_3 = svdiv_s32(pg, nums, 100); // First digit (e.g., 121 -> 1, 234 -> 2)\n        svint32_t d3_3 = svmod_s32(pg, nums, 10);  // Last digit (e.g., 121 -> 1, 234 -> 4)\n        svbool_t cond3_match = svcmpeq_s32(cond3_range, d1_3, d3_3); // Compare only for numbers in this range\n        is_pal_pred = svorr_b(is_pal_pred, cond3_match); // Add these to the palindrome predicate\n\n        // Case 4: 4-digit numbers (1000 to 1024).\n        // Only 1001 is a palindrome in this specific range.\n        // Condition: nums == 1001\n        svbool_t cond4_match = svcmpeq_s32(pg, nums, 1001); // Compare only for numbers within 'n' limit\n        is_pal_pred = svorr_b(is_pal_pred, cond4_match); // Add this to the palindrome predicate\n\n        // At this point, 'is_pal_pred' is true for all numbers in 'nums' that are palindromes\n        // and are within the 'n' limit (due to 'pg' being used in all comparisons).\n\n        // --- Parity Check and Counting ---\n\n        // Compute nums % 2 only for lanes where 'is_pal_pred' is true.\n        // The 'is_pal_pred' acts as the governing predicate for this operation.\n        svint32_t parity_result = svmod_s32(is_pal_pred, nums, 2);\n\n        // Create predicates for even and odd palindromes.\n        // These predicates are true only if 'is_pal_pred' was true AND the parity matches.\n        svbool_t even_pal_final_pred = svcmpeq_s32(is_pal_pred, parity_result, 0); // Palindrome AND even\n        svbool_t odd_pal_final_pred = svcmpne_s32(is_pal_pred, parity_result, 0); // Palindrome AND odd\n\n        // Count the number of active lanes in each final predicate.\n        // svcntp_b(governing_predicate, data_predicate) counts elements where both are true.\n        // Since even_pal_final_pred and odd_pal_final_pred are already derived from 'pg'\n        // and 'is_pal_pred', using 'pg' as the governing predicate here is correct.\n        even_count += svcntp_b(pg, even_pal_final_pred);\n        odd_count += svcntp_b(pg, odd_pal_final_pred);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric> // Required for std::accumulate or similar if a scalar tail loop was used\n#include <cmath>   // Required for std::abs in a scalar context, but not directly used with SVE intrinsics\n\nint count_nums_simd(std::vector<int> n) {\n    long long total_count = 0; // Use long long for total count to avoid overflow for very large vectors\n\n    if (n.empty()) {\n        return 0;\n    }\n\n    // Get the vector length for SVE (number of 32-bit elements)\n    size_t sv_len = svcntw();\n\n    // Process the input vector in chunks of sv_len elements\n    for (size_t i = 0; i < n.size(); i += sv_len) {\n        // Create a predicate for the current chunk.\n        // This handles the tail end of the vector where the number of elements\n        // might be less than sv_len.\n        svbool_t p_active_lanes = svwhilelt_b32((uint32_t)i, (uint32_t)n.size());\n\n        // Load the current chunk of data into an SVE vector\n        svint32_t numbers = svld1_s32(p_active_lanes, &n[i]);\n\n        // Step 1: Calculate the absolute value of each number.\n        // Note: svabs_s32(INT_MIN) typically results in INT_MIN itself.\n        // This implementation assumes inputs are within (-INT_MAX, INT_MAX].\n        svint32_t abs_numbers = svabs_s32_x(p_active_lanes, numbers);\n\n        // Step 2: Calculate the sum of absolute digits for each absolute number.\n        svint32_t sum_abs_digits_vec = svdup_s32(0);\n        svint32_t current_nums_for_sum = abs_numbers;\n        // Predicate for lanes where current_nums_for_sum is still greater than 0\n        svbool_t p_sum_loop_active = svcmpgt_s32(p_active_lanes, current_nums_for_sum, svdup_s32(0));\n\n        // Loop up to 10 times (maximum digits for a 32-bit integer)\n        for (int k = 0; k < 10; ++k) {\n            // Extract the last digit (current_nums_for_sum % 10) for active lanes\n            svint32_t digit = svmod_s32_x(p_sum_loop_active, current_nums_for_sum, svdup_s32(10));\n            // Add the digit to the sum for active lanes\n            sum_abs_digits_vec = svadd_s32_x(p_sum_loop_active, sum_abs_digits_vec, digit);\n            // Remove the last digit (current_nums_for_sum / 10) for active lanes\n            current_nums_for_sum = svdiv_s32_x(p_sum_loop_active, current_nums_for_sum, svdup_s32(10));\n            // Update the predicate: a lane is active if its number is still > 0\n            p_sum_loop_active = svcmpgt_s32(p_active_lanes, current_nums_for_sum, svdup_s32(0));\n            // If no lanes are active, we can break early\n            if (svptest_any(p_active_lanes, p_sum_loop_active) == 0) {\n                break;\n            }\n        }\n\n        // Step 3: Calculate the most significant digit (MSD) of each absolute number.\n        svint32_t msd_vec = abs_numbers; // Initialize MSD with the number itself (for single-digit numbers)\n        svint32_t temp_abs_nums_for_msd = abs_numbers;\n        // Predicate for lanes where the number has more than one digit (i.e., >= 10)\n        svbool_t p_msd_loop_active = svcmpgt_s32(p_active_lanes, temp_abs_nums_for_msd, svdup_s32(9));\n\n        // Loop up to 9 times (to get MSD for a 10-digit number)\n        for (int k = 0; k < 9; ++k) {\n            // Divide by 10 for active lanes\n            temp_abs_nums_for_msd = svdiv_s32_x(p_msd_loop_active, temp_abs_nums_for_msd, svdup_s32(10));\n            // Update msd_vec only for active lanes (where division occurred).\n            // For inactive lanes (single-digit numbers), msd_vec retains its initial value.\n            msd_vec = svsel_s32(p_msd_loop_active, temp_abs_nums_for_msd, msd_vec);\n            // Update the predicate: a lane is active if its number is still >= 10\n            p_msd_loop_active = svcmpgt_s32(p_active_lanes, temp_abs_nums_for_msd, svdup_s32(9));\n            // If no lanes are active, we can break early\n            if (svptest_any(p_active_lanes, p_msd_loop_active) == 0) {\n                break;\n            }\n        }\n        \n        // Handle the special case of 0: sum of digits is 0, msd is 0.\n        // The loops above correctly yield 0 for sum_abs_digits_vec and msd_vec if abs_numbers was 0.\n        // So no explicit special handling for 0 is needed here.\n\n        // Step 4: Identify negative numbers.\n        svbool_t p_negative = svcmplt_s32(p_active_lanes, numbers, svdup_s32(0));\n\n        // Step 5: Calculate the final sum of digits for each number.\n        // Initialize final_sum_digits with sum_abs_digits_vec (this is correct for positive numbers).\n        svint32_t final_sum_digits = sum_abs_digits_vec;\n\n        // For negative numbers, apply the adjustment:\n        // sum_digits = sum_abs_digits - 2 * (most_significant_digit_of_abs_N).\n        // Calculate 2 * MSD for all active lanes.\n        svint32_t adjustment = svmul_s32_x(p_active_lanes, msd_vec, svdup_s32(2));\n        // Subtract the adjustment only for lanes where p_negative is true.\n        // For lanes where p_negative is false (positive numbers), final_sum_digits remains unchanged.\n        final_sum_digits = svsub_s32_x(p_negative, final_sum_digits, adjustment);\n\n        // Step 6: Count elements where the final sum of digits is greater than 0.\n        svbool_t p_greater_than_zero = svcmpgt_s32(p_active_lanes, final_sum_digits, svdup_s32(0));\n        total_count += svcntp_b32(p_active_lanes, p_greater_than_zero);\n    }\n\n    return static_cast<int>(total_count);\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int total_count = 0;\n    size_t i = 0;\n    // Get the number of 32-bit integer elements that fit in an SVE vector.\n    // This determines the vector length (VL) at runtime.\n    size_t vec_len = svcnt_s32();\n\n    // Loop through the input vector in chunks of `vec_len`.\n    for (i = 0; i < n.size(); i += vec_len) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the vector, especially handling the tail end of the input vector.\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)n.size());\n\n        // Load a vector of integers from the input array `n`.\n        svint32_t v_n = svld1_s32(pg, &n[i]);\n\n        // Calculate the absolute value of each number in the vector.\n        svint32_t v_abs_n = svabs_s32(v_n);\n\n        // --- Calculate the sum of digits for the absolute values (v_sum_digits_abs) ---\n        svint32_t v_sum_digits_abs = svdup_n_s32(0); // Initialize sum to 0 for all lanes\n        svint32_t v_current_n_for_sum = v_abs_n;    // Copy absolute values for digit extraction\n\n        // Create a mask for lanes that still have digits to sum (i.e., current_n is not 0).\n        svbool_t sum_loop_mask = svcmpne_n_s32(pg, v_current_n_for_sum, 0);\n\n        // Loop until all active lanes have processed all their digits.\n        // svptest_any(pg, sum_loop_mask) checks if any element within the current predicate 'pg'\n        // still needs processing according to 'sum_loop_mask'.\n        while (svptest_any(pg, sum_loop_mask)) {\n            // Extract the last digit (current_n % 10) for active lanes.\n            svint32_t v_digit = svmod_s32(sum_loop_mask, v_current_n_for_sum, svdup_n_s32(10));\n            // Add the extracted digit to the running sum for active lanes.\n            v_sum_digits_abs = svadd_s32(sum_loop_mask, v_sum_digits_abs, v_digit);\n            // Remove the last digit (current_n / 10) for active lanes.\n            v_current_n_for_sum = svdiv_s32(sum_loop_mask, v_current_n_for_sum, svdup_n_s32(10));\n            // Update the mask for the next iteration.\n            sum_loop_mask = svcmpne_n_s32(pg, v_current_n_for_sum, 0);\n        }\n\n        // --- Calculate the most significant digit (MSD) for the absolute values (v_msd_abs) ---\n        svint32_t v_msd_abs = v_abs_n; // Start with the absolute value itself\n\n        // Create a mask for lanes whose MSD is not yet found (i.e., number is >= 10).\n        svbool_t msd_loop_mask = svcmpge_n_s32(pg, v_msd_abs, 10);\n\n        // Loop until all active lanes have their MSD found (i.e., number becomes a single digit).\n        while (svptest_any(pg, msd_loop_mask)) {\n            // Divide by 10 for active lanes to strip off the last digit.\n            v_msd_abs = svdiv_s32(msd_loop_mask, v_msd_abs, svdup_n_s32(10));\n            // Update the mask for the next iteration.\n            msd_loop_mask = svcmpge_n_s32(pg, v_msd_abs, 10);\n        }\n\n        // --- Calculate the final digit sum based on the original number's sign ---\n        svint32_t v_final_digit_sum = v_sum_digits_abs; // Start with the sum of digits of the absolute value\n\n        // Create a mask for negative numbers in the original input vector.\n        svbool_t v_is_negative_mask = svcmplt_n_s32(pg, v_n, 0);\n        \n        // For negative numbers, the rule is: sum_digits(abs(x)) - 2 * MSD(abs(x)).\n        // Calculate 2 * MSD for all lanes.\n        svint32_t v_msd_doubled = svmul_n_s32(v_msd_abs, 2);\n        // Subtract 2 * MSD only for lanes corresponding to negative numbers.\n        v_final_digit_sum = svsub_s32(v_is_negative_mask, v_final_digit_sum, v_msd_doubled);\n\n        // Note: Numbers that are 0 will correctly result in a final digit sum of 0\n        // because both v_sum_digits_abs and v_msd_abs will be 0 for those lanes.\n        // No special handling for 0 is needed beyond the general logic.\n\n        // --- Count elements where the final digit sum is greater than 0 ---\n        // Create a mask for lanes where the final digit sum is greater than 0.\n        svbool_t v_count_mask = svcmpgt_n_s32(pg, v_final_digit_sum, 0);\n        // Count the number of active elements in the current predicate 'pg'\n        // that satisfy 'v_count_mask' and add to the total count.\n        total_count += svcntp_b32(pg, v_count_mask);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int total_count = 0;\n    size_t i = 0;\n    size_t vec_len = svcntw(); // Number of int elements in a vector\n\n    // Process full SVE vectors\n    svbool_t pg = svptrue_b32(); // Predicate for all active lanes\n\n    for (; i + vec_len <= n.size(); i += vec_len) {\n        svint32_t numbers = svld1_s32(pg, &n[i]);\n\n        // Create a mask for original negative numbers\n        svbool_t neg_mask = svcmplt_s32(pg, numbers, 0);\n\n        // Take absolute values for digit extraction\n        svint32_t abs_numbers = svabs_s32_x(pg, numbers);\n\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t first_digits = svdup_s32(0); // To store the Most Significant Digit (MSD) of abs_numbers\n\n        svint32_t current_numbers_for_sum = abs_numbers;\n\n        // Loop to extract digits and sum them, and find the MSD\n        // An int can have up to 10 digits (e.g., 2,147,483,647).\n        // 11 iterations are sufficient to process all digits and handle the case of 0.\n        for (int k = 0; k < 11; ++k) {\n            // Active mask for lanes that still have non-zero numbers\n            svbool_t active_mask_sum = svcmpne_s32(pg, current_numbers_for_sum, 0);\n\n            // If no lanes are active, all numbers have been reduced to 0, so break\n            if (svcntp_b32(pg, active_mask_sum) == 0) {\n                break;\n            }\n\n            // Extract the last digit (remainder when divided by 10)\n            svint32_t last_digit = svmod_s32_x(active_mask_sum, current_numbers_for_sum, svdup_s32(10));\n            // Add the last digit to the sum\n            sum_digits = svadd_s32_x(active_mask_sum, sum_digits, last_digit);\n            // Remove the last digit (integer division by 10)\n            current_numbers_for_sum = svdiv_s32_x(active_mask_sum, current_numbers_for_sum, svdup_s32(10));\n\n            // Determine if the current last_digit was the MSD for any number\n            // This happens when the number becomes 0 after the division\n            svbool_t is_msd_mask = svcmpeq_s32(active_mask_sum, current_numbers_for_sum, 0);\n            // Update first_digits for lanes where the MSD was just found\n            first_digits = svsel_s32(is_msd_mask, last_digit, first_digits);\n        }\n\n        // Apply sign correction for negative numbers as per problem description:\n        // \"If a number is negative, then its first signed digit will be negative:\n        // e.g. -123 has signed digits -1, 2, and 3.\"\n        // This means the sum of digits for N < 0 is (sum of abs digits) - 2 * (MSD of abs(N)).\n        svint32_t correction = svmul_s32_x(neg_mask, first_digits, svdup_s32(2));\n        sum_digits = svsub_s32_x(neg_mask, sum_digits, correction);\n\n        // Count numbers where the sum of digits is greater than 0\n        svbool_t count_mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0));\n        total_count += svcntp_b32(pg, count_mask);\n    }\n\n    // Process remaining elements (tail)\n    size_t remaining = n.size() - i;\n    if (remaining > 0) {\n        svbool_t tail_pg = svwhilelt_b32((uint32_t)0, (uint32_t)remaining);\n        svint32_t numbers = svld1_s32(tail_pg, &n[i]);\n\n        svbool_t neg_mask = svcmplt_s32(tail_pg, numbers, 0);\n\n        svint32_t abs_numbers = svabs_s32_x(tail_pg, numbers);\n\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t first_digits = svdup_s32(0);\n\n        svint32_t current_numbers_for_sum = abs_numbers;\n\n        for (int k = 0; k < 11; ++k) {\n            svbool_t active_mask_sum = svcmpne_s32(tail_pg, current_numbers_for_sum, 0);\n            if (svcntp_b32(tail_pg, active_mask_sum) == 0) {\n                break;\n            }\n\n            svint32_t last_digit = svmod_s32_x(active_mask_sum, current_numbers_for_sum, svdup_s32(10));\n            sum_digits = svadd_s32_x(active_mask_sum, sum_digits, last_digit);\n            current_numbers_for_sum = svdiv_s32_x(active_mask_sum, current_numbers_for_sum, svdup_s32(10));\n\n            svbool_t is_msd_mask = svcmpeq_s32(active_mask_sum, current_numbers_for_sum, 0);\n            first_digits = svsel_s32(is_msd_mask, last_digit, first_digits);\n        }\n\n        svint32_t correction = svmul_s32_x(neg_mask, first_digits, svdup_s32(2));\n        sum_digits = svsub_s32_x(neg_mask, sum_digits, correction);\n\n        svbool_t count_mask = svcmpgt_s32(tail_pg, sum_digits, svdup_s32(0));\n        total_count += svcntp_b32(tail_pg, count_mask);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\n// Function to count numbers with sum of digits > 0 using SVE intrinsics\nint count_nums_simd(std::vector<int> n) {\n    int total_count = 0;\n    long N = n.size();\n    long i = 0;\n\n    // Loop through the input vector in chunks determined by SVE vector length\n    // svwhilelt_b32 generates a predicate for elements where the index is less than N\n    svbool_t pg = svwhilelt_b32(i, N);\n\n    // Continue looping as long as there are active elements in the predicate\n    // svptest_any(svptrue_b32(), pg) checks if any element in the current predicate 'pg' is true.\n    // svptrue_b32() creates a predicate where all elements are true, effectively checking 'pg' itself.\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of integers from the input array 'n' using the predicate 'pg'\n        svint32_t current_nums = svld1_s32(pg, &n[i]);\n\n        // 1. Calculate absolute values of the numbers\n        // svabs_s32_x: absolute value, _x means predicated, inactive elements are unchanged.\n        svint32_t abs_nums = svabs_s32_x(pg, current_nums);\n\n        // 2. Calculate the sum of absolute digits for each number\n        svint32_t sum_abs_digits = svdup_s32(0); // Initialize sum to 0 for all elements\n        svint32_t temp_nums_for_sum = abs_nums; // Working copy for digit extraction\n\n        // Predicate for elements that still have digits to sum (i.e., > 0)\n        svbool_t p_sum_active = svcmpgt_s32(pg, temp_nums_for_sum, 0);\n\n        // Iterate up to 10 times, as an int32_t has at most 10 decimal digits\n        for (int k = 0; k < 10; ++k) {\n            // If no elements are active under the main predicate 'pg', break early\n            if (svptest_any(pg, p_sum_active) == 0) break;\n\n            // Extract the last digit (modulo 10) for active elements\n            svint32_t digit = svmod_s32_x(p_sum_active, temp_nums_for_sum, svdup_s32(10));\n            // Add the digit to the sum for active elements\n            sum_abs_digits = svadd_s32_x(p_sum_active, sum_abs_digits, digit);\n            // Remove the last digit (integer division by 10) for active elements\n            temp_nums_for_sum = svdiv_s32_x(p_sum_active, temp_nums_for_sum, svdup_s32(10));\n            // Update the predicate for elements that still have remaining digits\n            p_sum_active = svcmpgt_s32(pg, temp_nums_for_sum, 0);\n        }\n\n        // 3. Calculate the most significant digit (MSD) for each number\n        svint32_t msd_vec = abs_nums; // Start with the absolute number\n        // Predicate for elements where msd_vec is still >= 10 (needs further division to find MSD)\n        svbool_t p_msd_active = svcmpge_s32(pg, msd_vec, svdup_s32(10));\n\n        // Repeatedly divide by 10 until the number is a single digit (the MSD)\n        while (svptest_any(pg, p_msd_active)) {\n            msd_vec = svdiv_s32_x(p_msd_active, msd_vec, svdup_s32(10));\n            p_msd_active = svcmpge_s32(pg, msd_vec, svdup_s32(10));\n        }\n        // Note: If abs_nums was 0, msd_vec remains 0, which is correct.\n\n        // 4. Calculate the final sum of digits based on the problem's rule\n        // Rule: If N < 0, final_sum = sum_abs_digits - 2 * msd\n        //       If N >= 0, final_sum = sum_abs_digits\n        svint32_t final_sum_vec = sum_abs_digits;\n        // Predicate for negative numbers\n        svbool_t p_negative = svcmplt_s32(pg, current_nums, svdup_s32(0));\n\n        // Calculate 2 * msd for negative numbers, only for elements where p_negative is true\n        svint32_t two_msd = svmul_s32_x(p_negative, svdup_s32(2), msd_vec);\n        // Subtract 2 * msd from the sum_abs_digits for negative numbers\n        final_sum_vec = svsub_s32_x(p_negative, final_sum_vec, two_msd);\n\n        // 5. Count how many elements in final_sum_vec are greater than 0\n        svbool_t p_count = svcmpgt_s32(pg, final_sum_vec, svdup_s32(0));\n        // svcntp_b32 counts the number of true elements in the predicate 'p_count'\n        // under the governing predicate 'pg'.\n        total_count += svcntp_b32(pg, p_count);\n\n        // Move to the next chunk of data\n        i += svcntw(); // svcntw() returns the number of 32-bit elements in an SVE vector\n        // Update the predicate for the next chunk\n        pg = svwhilelt_b32(i, N);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int total_count = 0;\n    size_t num_elements = n.size();\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Number of 32-bit integers in an SVE vector\n\n    svint32_t ten_vec = svdup_s32(10);\n    svint32_t zero_vec = svdup_s32(0);\n    svint32_t two_vec = svdup_s32(2);\n    svint32_t nine_vec = svdup_s32(9);\n\n    // Process the vector in chunks of vector_length\n    for (i = 0; i + vector_length <= num_elements; i += vector_length) {\n        // Load a vector of integers\n        svint32_t numbers_vec = svld1_s32(svptrue_b32(), &n[i]);\n\n        // Calculate absolute values for digit sum calculation\n        svint32_t abs_numbers_vec = svabs_s32(numbers_vec);\n\n        // Initialize sum of digits vector\n        svint32_t sum_digits_vec = svdup_s32(0);\n\n        // Calculate sum of digits for each number (iterative approach)\n        // Max 10 iterations for 32-bit integers (e.g., 2,147,483,647 has 10 digits)\n        svbool_t pg_digit_sum = svwhilegt_s32(abs_numbers_vec, zero_vec);\n\n        for (int k = 0; k < 10; ++k) {\n            // If no lanes are active, break\n            if (svptest_any(svptrue_b32(), pg_digit_sum) == 0) {\n                break;\n            }\n\n            // digit = abs_numbers_vec % 10\n            // digit_vec = abs_numbers_vec - (abs_numbers_vec / 10) * 10\n            svint32_t div_by_ten = svdiv_s32_m(pg_digit_sum, abs_numbers_vec, ten_vec);\n            svint32_t mul_by_ten = svmul_s32_m(pg_digit_sum, div_by_ten, ten_vec);\n            svint32_t digit_vec = svsub_s32_m(pg_digit_sum, abs_numbers_vec, mul_by_ten);\n\n            // sum_digits_vec += digit_vec\n            sum_digits_vec = svadd_s32_m(pg_digit_sum, sum_digits_vec, digit_vec);\n\n            // abs_numbers_vec /= 10\n            abs_numbers_vec = svdiv_s32_m(pg_digit_sum, abs_numbers_vec, ten_vec);\n\n            // Update predicate for next iteration\n            pg_digit_sum = svwhilegt_s32(abs_numbers_vec, zero_vec);\n        }\n\n        // Calculate Most Significant Digit (MSD) for correction\n        svint32_t msd_vec = svabs_s32(numbers_vec); // Start with absolute value\n        svbool_t pg_msd_calc = svwhilegt_s32(msd_vec, nine_vec); // While > 9 (i.e., multiple digits)\n\n        for (int k = 0; k < 10; ++k) {\n            if (svptest_any(svptrue_b32(), pg_msd_calc) == 0) {\n                break;\n            }\n            msd_vec = svdiv_s32_m(pg_msd_calc, msd_vec, ten_vec);\n            pg_msd_calc = svwhilegt_s32(msd_vec, nine_vec);\n        }\n\n        // Apply correction for negative numbers: sum_digits -= 2 * MSD\n        svbool_t is_negative_pg = svcmplt_s32(numbers_vec, zero_vec); // Predicate for negative numbers\n        svint32_t two_times_msd = svmul_s32_m(is_negative_pg, two_vec, msd_vec);\n        sum_digits_vec = svsub_s32_m(is_negative_pg, sum_digits_vec, two_times_msd);\n\n        // Count elements where sum of digits > 0\n        svbool_t count_pg = svcmpgt_s32(sum_digits_vec, zero_vec);\n        total_count += svcntp_b32(svptrue_b32(), count_pg);\n    }\n\n    // Handle remaining elements (tail processing)\n    if (i < num_elements) {\n        svbool_t pg_tail = svwhilelt_b32(i, num_elements); // Predicate for the remaining elements\n\n        svint32_t numbers_vec = svld1_s32(pg_tail, &n[i]);\n\n        svint32_t abs_numbers_vec = svabs_s32(numbers_vec);\n        svint32_t sum_digits_vec = svdup_s32(0);\n\n        // Digit sum calculation for tail, combining with pg_tail\n        svbool_t current_pg_digit_sum = svwhilegt_s32(abs_numbers_vec, zero_vec);\n        svbool_t combined_pg_digit_sum = svand_b(pg_tail, current_pg_digit_sum);\n\n        for (int k = 0; k < 10; ++k) {\n            if (svptest_any(svptrue_b32(), combined_pg_digit_sum) == 0) {\n                break;\n            }\n            svint32_t div_by_ten = svdiv_s32_m(combined_pg_digit_sum, abs_numbers_vec, ten_vec);\n            svint32_t mul_by_ten = svmul_s32_m(combined_pg_digit_sum, div_by_ten, ten_vec);\n            svint32_t digit_vec = svsub_s32_m(combined_pg_digit_sum, abs_numbers_vec, mul_by_ten);\n            sum_digits_vec = svadd_s32_m(combined_pg_digit_sum, sum_digits_vec, digit_vec);\n            abs_numbers_vec = svdiv_s32_m(combined_pg_digit_sum, abs_numbers_vec, ten_vec);\n\n            current_pg_digit_sum = svwhilegt_s32(abs_numbers_vec, zero_vec);\n            combined_pg_digit_sum = svand_b(pg_tail, current_pg_digit_sum);\n        }\n\n        // MSD calculation for tail, combining with pg_tail\n        svint32_t msd_vec = svabs_s32(numbers_vec);\n        svbool_t current_pg_msd_calc = svwhilegt_s32(msd_vec, nine_vec);\n        svbool_t combined_pg_msd_calc = svand_b(pg_tail, current_pg_msd_calc);\n\n        for (int k = 0; k < 10; ++k) {\n            if (svptest_any(svptrue_b32(), combined_pg_msd_calc) == 0) {\n                break;\n            }\n            msd_vec = svdiv_s32_m(combined_pg_msd_calc, msd_vec, ten_vec);\n            current_pg_msd_calc = svwhilegt_s32(msd_vec, nine_vec);\n            combined_pg_msd_calc = svand_b(pg_tail, current_pg_msd_calc);\n        }\n\n        // Apply correction for negative numbers in tail\n        svbool_t is_negative_pg = svcmplt_s32(numbers_vec, zero_vec);\n        svbool_t combined_neg_pg = svand_b(pg_tail, is_negative_pg);\n        svint32_t two_times_msd = svmul_s32_m(combined_neg_pg, two_vec, msd_vec);\n        sum_digits_vec = svsub_s32_m(combined_neg_pg, sum_digits_vec, two_times_msd);\n\n        // Count elements where sum of digits > 0 in tail\n        svbool_t count_pg = svcmpgt_s32(sum_digits_vec, zero_vec);\n        svbool_t combined_count_pg = svand_b(pg_tail, count_pg);\n        total_count += svcntp_b32(svptrue_b32(), combined_count_pg);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    long N = arr.size();\n\n    // If the vector is empty or has only one element, it is considered sorted.\n    if (N <= 1) {\n        return true;\n    }\n\n    long descent_count = 0;\n    long i = 0;\n\n    // Iterate through the array using SVE intrinsics to count descents.\n    // A descent is defined as arr[k] > arr[k+1].\n    // This loop covers comparisons from arr[0] vs arr[1] up to arr[N-2] vs arr[N-1].\n    // The predicate `svwhilelt_b32(i, N - 1)` ensures that we only process elements\n    // where `i + k` (the current element's index) is less than `N - 1`.\n    // This means `i + k + 1` (the next element's index) will always be less than or equal to `N - 1`,\n    // preventing out-of-bounds access for `&arr[i+1]`.\n    for (i = 0; i < N - 1; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N - 1); // Predicate for active elements in the current vector\n        \n        // Load current elements starting from arr[i]\n        svint32_t current_vec = svld1_s32(pg, &arr[i]);\n        \n        // Load next elements starting from arr[i+1]\n        svint32_t next_vec = svld1_s32(pg, &arr[i+1]);\n        \n        // Compare current_vec > next_vec element-wise\n        svbool_t cmp_pred = svcmpgt_s32(pg, current_vec, next_vec);\n        \n        // Count the number of true predicates (descents) in the current vector chunk\n        descent_count += svcntp_b(pg, cmp_pred);\n    }\n\n    // Handle the cyclic comparison: arr[N-1] > arr[0].\n    // This is the last comparison needed to determine if the array is cyclically sorted.\n    if (arr[N-1] > arr[0]) {\n        descent_count++;\n    }\n\n    // An array can be sorted by right shifts if and only if it has at most one descent\n    // when considered cyclically.\n    return descent_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    long N = arr.size();\n\n    // Handle empty or single-element vectors, which are considered sorted.\n    if (N <= 1) {\n        return true;\n    }\n\n    int descent_count = 0;\n\n    // Get the SVE vector length for 32-bit integers.\n    // This determines how many elements are processed in parallel.\n    size_t VL = svcntw();\n\n    // Iterate through the array in chunks of VL elements.\n    // The loop processes comparisons of arr[i] with arr[i+1].\n    // The last comparison needed is arr[N-2] with arr[N-1].\n    // So, the loop variable 'i' represents the starting index of the first element\n    // in a pair (arr[i], arr[i+1]), and it goes up to N-2.\n    for (long i = 0; i < N - 1; i += VL) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that we only process elements arr[k] where k < N-1.\n        // This correctly handles the tail of the array where a full vector might not fit.\n        svbool_t pg_curr = svwhilelt_b32(i, N - 1);\n\n        // If no lanes are active in the predicate, it means we have processed all\n        // relevant elements, so we can break the loop.\n        if (!svptest_any(svptrue_b32(), pg_curr)) {\n            break;\n        }\n\n        // Load the current elements into an SVE vector.\n        // Only active lanes (determined by pg_curr) will be loaded from arr[i...].\n        svint32_t vec_curr = svld1_s32(pg_curr, &arr[i]);\n\n        // Load the next elements into another SVE vector.\n        // Since we are comparing arr[k] with arr[k+1], the 'next' elements start\n        // one position after the 'current' elements.\n        // The same predicate `pg_curr` is used to ensure that only valid comparisons\n        // (where both arr[k] and arr[k+1] are within bounds and part of a pair) are considered.\n        svint32_t vec_next = svld1_s32(pg_curr, &arr[i+1]);\n\n        // Perform the comparison: check if arr[k] > arr[k+1] for active lanes.\n        // The result is a predicate where true indicates a descent.\n        svbool_t cmp_result = svcmpgt_s32(pg_curr, vec_curr, vec_next);\n\n        // Count the number of active lanes in `cmp_result`.\n        // `svptrue_b32()` as the first argument means count all active lanes in `cmp_result`.\n        descent_count += svcntp_b32(svptrue_b32(), cmp_result);\n\n        // Early exit: If more than one descent is found, it's impossible to sort\n        // by cyclic shifts, so we can return false immediately.\n        if (descent_count > 1) {\n            return false;\n        }\n    }\n\n    // After processing all elements, check the total descent count.\n    if (descent_count == 0) {\n        // If no descents, the array is already sorted.\n        return true;\n    } else if (descent_count == 1) {\n        // If exactly one descent, check the cyclic condition:\n        // The last element must be less than the first element for it to be a\n        // valid cyclic shift of a sorted array (given unique elements).\n        return arr[N-1] < arr[0];\n    } else {\n        // If more than one descent (this case should ideally be caught by the early exit),\n        // it's not possible to sort by cyclic shifts.\n        return false;\n    }\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n\n    if (N == 0) {\n        return true;\n    }\n\n    int descent_count = 0;\n    int i = 0;\n\n    // Loop through the array to find descents (arr[k] > arr[k+1])\n    // The loop iterates as long as 'i' is less than N-1,\n    // ensuring that arr[i] and arr[i+1] are valid indices for comparison.\n    svbool_t pg_loop = svwhilelt_b32(i, N - 1);\n\n    do {\n        // Predicate for loading 'current' elements (arr[i] to arr[i+VL-1]).\n        // This predicate ensures that we only attempt to load elements that are within the array bounds.\n        svbool_t pg_curr = svwhilelt_b32(i, N);\n        svint32_t vec_curr = svld1_s32(pg_curr, &arr[i]);\n\n        // Predicate for loading 'next' elements (arr[i+1] to arr[i+VL]).\n        // This predicate also ensures array bounds safety for the 'next' elements.\n        svbool_t pg_next = svwhilelt_b32(i + 1, N);\n        svint32_t vec_next = svld1_s32(pg_next, &arr[i + 1]);\n\n        // Compare elements: vec_curr > vec_next.\n        // The comparison is performed only for active lanes determined by pg_loop.\n        // pg_loop ensures that we only compare arr[k] with arr[k+1] where k < N-1.\n        svbool_t cmp_gt = svcmpgt_s32(pg_loop, vec_curr, vec_next);\n\n        // Count the number of true predicates (descents) in the current vector chunk.\n        descent_count += svcntp_b32(svptrue_b32(), cmp_gt);\n\n        // Move to the next chunk of elements.\n        i += svcntw();\n        // Update the loop predicate for the next iteration.\n        pg_loop = svwhilelt_b32(i, N - 1);\n\n    } while (svptest_any(svptrue_b32(), pg_loop)); // Continue loop as long as there are active lanes in pg_loop.\n\n    // Based on the number of descents, determine if the array can be sorted by right shifts.\n    if (descent_count == 0) {\n        // If there are no descents, the array is already sorted.\n        return true;\n    } else if (descent_count == 1) {\n        // If there is exactly one descent, it must be a rotated sorted array.\n        // This means the last element must be less than the first element.\n        // Example: {3, 4, 5, 1, 2} -> 5 > 1 is the only descent. 2 < 3. True.\n        // Example: {1, 3, 2} -> 3 > 2 is the only descent. 2 < 1 is false. False.\n        return arr[N - 1] < arr[0];\n    } else {\n        // If there is more than one descent, it's not a rotated sorted array.\n        return false;\n    }\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    long N = arr.size();\n\n    if (N <= 1) {\n        return true;\n    }\n\n    long num_descents = 0;\n    long i = 0;\n\n    // Iterate through the array in chunks of SVE vector length\n    // to compare arr[i] with arr[i+1] for i from 0 to N-2.\n    // The loop condition `i < N - 1` ensures we only process valid pairs.\n    for (i = 0; i < N - 1; i += svcntw()) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that we only process elements up to N-2,\n        // preventing out-of-bounds access for arr[i+1].\n        svbool_t p = svwhilelt_b32(i, N - 1);\n\n        // Load current elements: arr[i], arr[i+1], ..., arr[i+VL-1]\n        svint32_t v_curr = svld1_s32(p, &arr[i]);\n\n        // Load next elements: arr[i+1], arr[i+2], ..., arr[i+VL]\n        // The predicate 'p' ensures that only valid elements within the N-1 boundary\n        // are considered for loading and comparison.\n        svint32_t v_next = svld1_s32(p, &arr[i+1]);\n\n        // Compare v_curr > v_next to find descents\n        svbool_t cmp_gt = svcmpgt_s32(p, v_curr, v_next);\n\n        // Count the number of true predicates (descents) in the current chunk\n        num_descents += svcntp_b32(svptrue_b32(), cmp_gt);\n\n        // Early exit if more than one descent is found, as it's not sortable\n        if (num_descents > 1) {\n            return false;\n        }\n    }\n\n    // After the loop, evaluate the total number of descents\n    if (num_descents == 0) {\n        // If no descents, the array is already sorted\n        return true;\n    } else if (num_descents == 1) {\n        // If exactly one descent, check the wrap-around condition: arr[N-1] <= arr[0]\n        // For the array to be sortable by shifts, the last element must be less than or equal to the first element.\n        // (Since elements are unique, it must be strictly less than if a shift is needed).\n        if (arr[N-1] <= arr[0]) {\n            return true;\n        } else {\n            // One internal break and one wrap-around break means two breaks in total\n            return false;\n        }\n    } else { // num_descents > 1\n        // More than one internal descent means it's not sortable by shifts\n        return false;\n    }\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n\n    // Handle empty or single-element vectors, which are considered sorted.\n    if (N <= 1) {\n        return true;\n    }\n\n    int total_descent_count = 0;\n\n    // Loop through the array using SVE intrinsics to count descents\n    // for arr[i] > arr[i+1] where i ranges from 0 to N-2.\n    // The loop iterates in steps of svcntw() (SVE vector length in elements).\n    for (int i = 0; i < N - 1; i += svcntw()) {\n        // Predicate for current elements: active lanes for indices < N-1.\n        // This ensures that comparisons are only performed for valid arr[i] and arr[i+1] pairs.\n        svbool_t pg_current = svwhilelt_b32(i, N - 1);\n\n        // Predicate for next elements: active lanes for indices < N.\n        // This ensures we don't attempt to load past arr[N-1].\n        svbool_t pg_next = svwhilelt_b32(i + 1, N);\n\n        // Load a vector of current elements starting from arr[i].\n        svint32_t current_vec = svld1(pg_current, &arr[i]);\n\n        // Load a vector of next elements starting from arr[i+1].\n        svint32_t next_vec = svld1(pg_next, &arr[i+1]);\n\n        // Compare current_vec > next_vec.\n        // The comparison is only active for lanes where pg_current is true.\n        svbool_t cmp_gt = svcmpgt(pg_current, current_vec, next_vec);\n\n        // Count the number of active (true) lanes in the comparison result.\n        // svptrue_b32() as the governing predicate means all lanes of cmp_gt are considered for counting.\n        int current_block_descents = svcntp_b32(svptrue_b32(), cmp_gt);\n        \n        total_descent_count += current_block_descents;\n\n        // If more than one descent is found in the main part of the array (arr[0]...arr[N-2]),\n        // it's impossible to sort by rotation.\n        if (total_descent_count > 1) {\n            return false;\n        }\n    }\n\n    // Check the wrap-around condition: arr[N-1] > arr[0].\n    bool is_wrap_around_descent = (arr[N-1] > arr[0]);\n\n    // Apply the logic based on the total number of descents and the wrap-around descent.\n    if (total_descent_count == 0) {\n        // If there are no descents in arr[0...N-2], the array is already sorted.\n        // An already sorted array is considered sortable by rotation.\n        return true;\n    } else { // total_descent_count == 1\n        // If there is exactly one descent in arr[0...N-2],\n        // it is sortable by rotation if and only if arr[N-1] <= arr[0].\n        // This means the wrap-around descent (arr[N-1] > arr[0]) must be false.\n        return !is_wrap_around_descent;\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    long long total_even_count = 0;\n    size_t N = lst1.size();\n    size_t M = lst2.size();\n\n    // Pre-broadcast scalar values for parity check\n    svint32_t one = svdup_s32(1);\n    svint32_t zero = svdup_s32(0);\n    \n    // Get the current vector length in 32-bit elements\n    // This value is constant for a given execution context.\n    size_t sv_vl = svcntw();\n\n    // Process lst1 to count even numbers\n    size_t i = 0;\n    svbool_t pg; // Predicate register\n    while (i < N) {\n        // Generate a predicate for the current chunk, handling tail elements\n        pg = svwhilelt_b32(i, N); \n        \n        // Load a vector from lst1 using the generated predicate\n        svint32_t vec_lst1 = svld1_s32(pg, &lst1[i]);\n        \n        // Check if elements are even: (value & 1) == 0\n        // 1. Perform bitwise AND with 1 to get the LSB\n        svint32_t val_and_one = svand_s32(pg, vec_lst1, one);\n        // 2. Compare the result with 0 to identify even numbers\n        svbool_t is_even_mask = svcmpeq_s32(pg, val_and_one, zero);\n        \n        // Count the number of active (true) elements in the is_even_mask\n        total_even_count += svcntp_b32(pg, is_even_mask);\n        \n        // Advance the index by the vector length\n        i += sv_vl;\n    }\n\n    // Process lst2 to count even numbers\n    i = 0; // Reset index for lst2\n    while (i < M) {\n        // Generate a predicate for the current chunk, handling tail elements\n        pg = svwhilelt_b32(i, M); \n        \n        // Load a vector from lst2 using the generated predicate\n        svint32_t vec_lst2 = svld1_s32(pg, &lst2[i]);\n        \n        // Check if elements are even: (value & 1) == 0\n        // 1. Perform bitwise AND with 1 to get the LSB\n        svint32_t val_and_one = svand_s32(pg, vec_lst2, one);\n        // 2. Compare the result with 0 to identify even numbers\n        svbool_t is_even_mask = svcmpeq_s32(pg, val_and_one, zero);\n        \n        // Count the number of active (true) elements in the is_even_mask\n        total_even_count += svcntp_b32(pg, is_even_mask);\n        \n        // Advance the index by the vector length\n        i += sv_vl;\n    }\n\n    // Determine if enough even numbers are available to fill lst1\n    if (total_even_count >= N) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\n// Function to count odd numbers in a vector using SVE intrinsics\nstatic int count_odd_sve(const std::vector<int>& vec) {\n    int total_odd_count = 0;\n    int i = 0;\n    int n = vec.size();\n\n    // Get the number of 32-bit elements in a full SVE vector\n    const int VEC_LEN = svcntw(); \n\n    while (i < n) {\n        // Create a predicate for the current chunk of elements\n        // This predicate handles tail processing automatically\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // If the predicate is all false, it means we have processed all elements\n        // or there are no more elements to process.\n        if (svptest_n_b32(pg, pg)) { \n            break; \n        }\n\n        // Load a vector of integers using the predicate\n        svint32_t current_vec = svld1_s32(pg, &vec[i]);\n\n        // Check if elements are odd: (x & 1) != 0\n        // Duplicate the scalar value 1 into all lanes of an SVE vector\n        svint32_t one_vec = svdup_s32(1);\n        // Perform bitwise AND with 1. _z suffix means lanes where pg is false are zeroed.\n        svint32_t and_result = svand_s32_z(pg, current_vec, one_vec);\n\n        // Duplicate the scalar value 0 into all lanes of an SVE vector\n        svint32_t zero_vec = svdup_s32(0);\n        // Compare if the result of (x & 1) is equal to 0 (i.e., the number is even)\n        svbool_t is_even_predicate = svcmpeq_s32(pg, and_result, zero_vec); \n        \n        // Invert the predicate to get true for odd numbers\n        svbool_t is_odd_predicate = svnot_b(pg, is_even_predicate); \n\n        // Count the number of true predicates (odd numbers)\n        total_odd_count += svcntp_b32(pg, is_odd_predicate);\n\n        // Move to the next chunk of elements\n        i += VEC_LEN; \n    }\n    return total_odd_count;\n}\n\n// Function to count even numbers in a vector using SVE intrinsics\nstatic int count_even_sve(const std::vector<int>& vec) {\n    int total_even_count = 0;\n    int i = 0;\n    int n = vec.size();\n\n    const int VEC_LEN = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        if (svptest_n_b32(pg, pg)) {\n            break;\n        }\n\n        svint32_t current_vec = svld1_s32(pg, &vec[i]);\n\n        // Check if elements are even: (x & 1) == 0\n        svint32_t one_vec = svdup_s32(1);\n        svint32_t and_result = svand_s32_z(pg, current_vec, one_vec);\n\n        // Compare if the result of (x & 1) is equal to 0 (i.e., the number is even)\n        svint32_t zero_vec = svdup_s32(0);\n        svbool_t is_even_predicate = svcmpeq_s32(pg, and_result, zero_vec); \n\n        // Count the number of true predicates (even numbers)\n        total_even_count += svcntp_b32(pg, is_even_predicate);\n\n        i += VEC_LEN;\n    }\n    return total_even_count;\n}\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // To make lst1 a vector of only even numbers, every odd number in lst1\n    // must be replaced by an even number from lst2.\n    // We need to count the number of odd elements in lst1.\n    int odd_count_lst1 = count_odd_sve(lst1);\n    \n    // We also need to count the number of even elements available in lst2.\n    int even_count_lst2 = count_even_sve(lst2);\n\n    // If the number of odd elements in lst1 is less than or equal to\n    // the number of even elements in lst2, then it's possible to perform\n    // the exchanges.\n    if (odd_count_lst1 <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <vector>\n#include <string>\n\n// Helper function to count even numbers in a vector using SVE intrinsics\nstatic int count_even_sve(const std::vector<int>& vec) {\n    int even_count = 0;\n    size_t i = 0;\n    size_t n = vec.size();\n\n    // As per problem statement, input vectors are non-empty, so n > 0.\n    // This check handles potential empty vectors gracefully, though not strictly required by problem.\n    if (n == 0) {\n        return 0;\n    }\n\n    // Get the effective vector length (VL) for 32-bit integers.\n    // This is used to advance the loop index.\n    const size_t sv_vl = svcntw();\n\n    while (i < n) {\n        // Generate a predicate for the current chunk of elements.\n        // `pg` will be true for elements from `i` up to `n-1` within the current vector length.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a vector of integers from `vec[i]` using the predicate.\n        svint32_t data = svld1_s32(pg, &vec[i]);\n\n        // Create a vector of 1s for the bitwise AND operation (x & 1).\n        // svdup_n_s32 duplicates a scalar into all elements of a vector.\n        svint32_t one_vec = svdup_n_s32(1);\n\n        // Perform bitwise AND with 1. Result is 0 for even numbers, 1 for odd numbers.\n        svint32_t odd_check_result = svand_s32(data, one_vec);\n\n        // Create a vector of 0s for comparison.\n        svint32_t zero_vec = svdup_n_s32(0);\n\n        // Compare the result with 0 to identify even numbers.\n        // `evens_mask` will have true where `odd_check_result` is 0 (i.e., even).\n        svbool_t evens_mask = svcmpeq_s32(pg, odd_check_result, zero_vec);\n\n        // Count the number of true predicates (i.e., even numbers) in the current chunk.\n        // `svcntp_b32(pg, evens_mask)` counts elements where both `pg` and `evens_mask` are true.\n        even_count += svcntp_b32(pg, evens_mask);\n\n        // Advance the index by the number of elements processed in this iteration,\n        // which is the effective vector length for 32-bit integers.\n        i += sv_vl;\n    }\n    return even_count;\n}\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Calculate total even numbers in lst1 and lst2 combined using SVE.\n    int total_even_count = count_even_sve(lst1) + count_even_sve(lst2);\n\n    // If the total number of available even numbers is greater than or equal to\n    // the required number of elements for lst1, then it's possible to make lst1\n    // entirely even.\n    if (total_even_count >= static_cast<int>(lst1.size())) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    long long total_even_count = 0;\n    size_t i = 0;\n    size_t N1 = lst1.size();\n    size_t N2 = lst2.size();\n\n    // Process lst1 to count even numbers\n    while (i < N1) {\n        svbool_t pg = svwhilelt_b32(i, N1);\n        svint32_t vec = svld1_s32(pg, &lst1[i]);\n        \n        // Check if elements are even: (x % 2 == 0) is equivalent to ((x & 1) == 0)\n        svint32_t mod_vec = svand_s32_z(pg, vec, svdup_s32(1)); // Compute x & 1\n        svbool_t even_mask = svcmpeq_s32(pg, mod_vec, 0);       // Check if (x & 1) == 0\n        \n        total_even_count += svcntp_b32(pg, even_mask); // Count active even elements\n        i += svcntw(); // Advance index by vector length\n    }\n\n    i = 0; // Reset index for lst2\n    // Process lst2 to count even numbers\n    while (i < N2) {\n        svbool_t pg = svwhilelt_b32(i, N2);\n        svint32_t vec = svld1_s32(pg, &lst2[i]);\n        \n        svint32_t mod_vec = svand_s32_z(pg, vec, svdup_s32(1));\n        svbool_t even_mask = svcmpeq_s32(pg, mod_vec, 0);\n        \n        total_even_count += svcntp_b32(pg, even_mask);\n        i += svcntw();\n    }\n\n    // If the total count of even numbers from both lists is greater than or equal\n    // to the size of lst1, it's possible to make lst1 all even.\n    if (total_even_count >= N1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    long long odd_in_lst1_count = 0;\n    long long even_in_lst2_count = 0;\n\n    size_t N1 = lst1.size();\n    size_t N2 = lst2.size();\n\n    // Process lst1 to count odd numbers\n    for (size_t i = 0; i < N1; ) {\n        // Generate a predicate for the current vector chunk\n        // This handles the tail elements correctly by activating only valid lanes\n        svbool_t pg = svwhilelt_b32(i, N1); \n        \n        // Load a vector of integers from lst1\n        svint32_t vec = svld1_s32(pg, &lst1[i]);\n\n        // Check for odd numbers: (val & 1) != 0\n        // svand_s32 performs bitwise AND with 1 for each element\n        // svcmpne compares each result with 0, generating a predicate for odd numbers\n        svbool_t p_odd = svcmpne(pg, svand_s32(vec, svdup_s32(1)), svdup_s32(0));\n        \n        // Count the number of active elements in p_odd (i.e., odd numbers)\n        odd_in_lst1_count += svcntp_b32(pg, p_odd);\n\n        // Advance the loop counter by the number of elements processed in this vector\n        i += svcntw(); \n    }\n\n    // Process lst2 to count even numbers\n    for (size_t i = 0; i < N2; ) {\n        // Generate a predicate for the current vector chunk\n        svbool_t pg = svwhilelt_b32(i, N2); \n        \n        // Load a vector of integers from lst2\n        svint32_t vec = svld1_s32(pg, &lst2[i]);\n\n        // Check for even numbers: (val & 1) == 0\n        // svand_s32 performs bitwise AND with 1 for each element\n        // svcmpeq compares each result with 0, generating a predicate for even numbers\n        svbool_t p_even = svcmpeq(pg, svand_s32(vec, svdup_s32(1)), svdup_s32(0));\n        \n        // Count the number of active elements in p_even (i.e., even numbers)\n        even_in_lst2_count += svcntp_b32(pg, p_even);\n\n        // Advance the loop counter\n        i += svcntw(); \n    }\n\n    // The condition for possibility is that the number of odd elements in lst1\n    // must be less than or equal to the number of even elements in lst2.\n    if (odd_in_lst1_count <= even_in_lst2_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\n// Helper function to count odd digits in a single string using SVE intrinsics.\n// This function processes the string in chunks, leveraging SVE's vector operations\n// to efficiently count odd digits.\nstatic int count_odd_digits_sve(const std::string& s) {\n    int total_odd_count = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Loop through the string, processing chunks of `svcntb()` bytes (vector length for uint8_t).\n    // `svwhilelt_b8(i, len)` generates a predicate that is true for elements\n    // where the current index `i` is less than `len`. This handles both full vectors\n    // and the remaining tail elements efficiently.\n    for (i = 0; i < len; i += svcntb()) {\n        // Create a predicate for the current chunk.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector.\n        // `svld1_u8` loads bytes (characters) into an unsigned 8-bit integer vector.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n        // Convert characters to digit values (0-9).\n        // Subtract '0' (ASCII value 48) from each character.\n        svuint8_t digits = svsub_n_u8(pg, chars, '0');\n\n        // Check if each digit is odd.\n        // Performing a bitwise AND with 1 (`digit & 1`) will result in 1 for odd digits\n        // and 0 for even digits.\n        svuint8_t odd_flags = svand_n_u8(pg, digits, 1);\n\n        // Horizontally sum the `odd_flags` vector.\n        // `svaddv_u8` sums all active elements in the vector. Since `odd_flags` contains\n        // 1s for odd digits and 0s for even digits, this sum directly gives the count\n        // of odd digits in the current chunk.\n        total_odd_count += svaddv_u8(pg, odd_flags);\n    }\n\n    return total_odd_count;\n}\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    result.reserve(lst.size()); // Pre-allocate memory to improve performance\n\n    // Iterate through each string in the input list.\n    for (const std::string& s : lst) {\n        // Count the number of odd digits in the current string using the SVE helper function.\n        int odd_count = count_odd_digits_sve(s);\n        \n        // Convert the odd count to a string.\n        std::string count_str = std::to_string(odd_count);\n\n        // Construct the output string based on the specified template.\n        // The template is: 'the number of odd elements Xn the strXng X of the Xnput.\"\n        // where 'X' is replaced by the `count_str`.\n        std::string output_s = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\";\n        \n        // Add the constructed string to the result vector.\n        result.push_back(output_s);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size()); // Pre-allocate memory for efficiency\n\n    // Scalar values duplicated into SVE vectors\n    const svuint8_t zero_char_vec = svdup_u8(48); // ASCII value of '0'\n    const svuint8_t one_val_vec = svdup_u8(1);   // For checking oddness (digit & 1)\n\n    for (const std::string& s : lst) {\n        int n = s.length();\n        uint64_t total_odd_count = 0;\n\n        // Process the string using SVE intrinsics\n        // The loop iterates over the string in chunks of svcntb() (SVE vector length in bytes)\n        for (int i = 0; i < n; i += svcntb()) {\n            // Create a predicate for the current chunk\n            // This predicate ensures we only process valid characters within the string bounds\n            svbool_t pg = svwhilelt_b8(i, n);\n\n            // If no elements are active in the predicate, break the loop\n            // (This check is technically redundant with the for loop condition but good practice for SVE loops)\n            if (!svptest_any(svptrue_b8(), pg)) {\n                break;\n            }\n\n            // Load characters from the string into an SVE vector\n            // The predicate 'pg' ensures only valid characters are loaded\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n            // Convert characters to their integer digit values\n            // Subtract '0' (ASCII 48) from each character\n            svuint8_t digits = svsub_u8_z(pg, chars, zero_char_vec);\n\n            // Check for odd digits: a digit is odd if (digit & 1) is 1\n            // This operation results in 1 for odd digits and 0 for even digits\n            svuint8_t odd_flags = svand_u8_z(pg, digits, one_val_vec);\n\n            // Sum the '1's (odd flags) in the vector\n            // svaddv_u8 sums all active elements in the vector, giving the count of odd digits in this chunk\n            total_odd_count += svaddv_u8(pg, odd_flags);\n        }\n        \n        int odd_count = static_cast<int>(total_odd_count);\n\n        // Construct the output string based on the template\n        // String manipulation is typically a scalar operation and not vectorized by SVE\n        std::string output_str = \"the number of odd elements Xn the strXng X of the Xnput.\";\n        std::string count_str = std::to_string(odd_count);\n\n        // Replace all occurrences of 'X' with the calculated odd_count\n        size_t pos = 0;\n        while ((pos = output_str.find('X', pos)) != std::string::npos) {\n            output_str.replace(pos, 1, count_str);\n            // Advance position by the length of the replacement string to avoid re-processing\n            // the newly inserted characters and to find the next 'X' correctly.\n            pos += count_str.length();\n        }\n        result.push_back(output_str);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <numeric> // Not strictly needed, but good for general utility\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size()); // Pre-allocate memory for efficiency\n\n    for (const std::string& s : lst) {\n        long long odd_count = 0;\n        size_t s_len = s.length();\n        size_t i = 0;\n\n        // Initialize the predicate for the first SVE vector chunk\n        // svwhilelt_b8 generates a predicate for bytes (8-bit elements)\n        // that are less than s_len, starting from index i.\n        svbool_t pg = svwhilelt_b8(i, s_len);\n\n        // Loop while there are active lanes in the predicate (i.e., more characters to process)\n        // svptest_any(svptrue_b8(), pg) checks if any element in 'pg' is true.\n        while (svptest_any(svptrue_b8(), pg)) {\n            // Load characters from the string into an SVE vector.\n            // Cast s.data() to const uint8_t* as svld1_u8 expects a pointer to unsigned 8-bit integers.\n            svuint8_t chars_vec = svld1_u8(pg, (const uint8_t*)s.data() + i);\n\n            // Convert character digits to their integer values.\n            // '0' (ASCII 48) is subtracted from each character.\n            // svdup_u8 creates a vector where all elements are '0'.\n            svuint8_t digits_vec = svsub_u8(chars_vec, svdup_u8(pg, '0'));\n\n            // Check for oddness: A digit is odd if its least significant bit (LSB) is 1.\n            // Perform bitwise AND with 1 to isolate the LSB.\n            svuint8_t lsb_vec = svand_u8(digits_vec, svdup_u8(pg, 1));\n\n            // Create a new predicate where elements are true if their LSB is 1 (i.e., the digit is odd).\n            // svcmpeq_u8 compares elements for equality, returning a predicate.\n            svbool_t odd_predicate = svcmpeq_u8(pg, lsb_vec, svdup_u8(pg, 1));\n\n            // Count the number of active (true) elements in the 'odd_predicate'\n            // that are also active in the current 'pg' (main loop predicate).\n            odd_count += svcntp_b8(pg, odd_predicate);\n\n            // Advance the index by the vector length (number of bytes processed in one SVE operation).\n            i += svcntb(); // svcntb() returns the current vector length in bytes.\n\n            // Update the predicate for the next iteration.\n            pg = svwhilelt_b8(i, s_len);\n        }\n\n        // Construct the output string based on the calculated odd_count.\n        std::string odd_count_str = std::to_string(odd_count);\n        std::string template_str = \"the number of odd elements Xn the strXng X of the Xnput.\";\n        \n        // Replace all occurrences of 'X' with the odd_count_str.\n        std::string formatted_str = template_str;\n        size_t pos = formatted_str.find('X');\n        while (pos != std::string::npos) {\n            formatted_str.replace(pos, 1, odd_count_str);\n            pos = formatted_str.find('X', pos + odd_count_str.length());\n        }\n        result.push_back(formatted_str);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const std::string& s : lst) {\n        long long odd_count = 0;\n        size_t len = s.length();\n\n        // Initialize SVE predicate for the first chunk of bytes\n        svbool_t pg = svwhilelt_b8(0, len);\n        size_t i = 0;\n\n        // Loop through the string in SVE vector chunks\n        do {\n            // Load characters into an SVE vector\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n\n            // Create a vector with all elements set to 1 (for bitwise AND operation)\n            svuint8_t one_u8 = svdup_u8(1);\n\n            // Perform bitwise AND with 1 to check the LSB of each character's ASCII value.\n            // For digit characters ('0' through '9'), their ASCII values have LSB=1 for odd digits\n            // ('1', '3', '5', '7', '9') and LSB=0 for even digits ('0', '2', '4', '6', '8').\n            svuint8_t lsb_values = svand_u8(chars, one_u8);\n\n            // Compare the LSB values with 1 to identify odd digits\n            svbool_t is_odd_digit = svcmpeq_u8(pg, lsb_values, one_u8);\n\n            // Count the number of active (true) elements in the predicate\n            odd_count += svcntp_b8(pg, is_odd_digit);\n\n            // Advance the index by the SVE vector length (number of bytes)\n            i += svcntb();\n\n            // Update the predicate for the next chunk\n            pg = svwhilelt_b8(i, len);\n\n        } while (svptest_any(svptrue_b8(), pg)); // Continue as long as there are active elements in the predicate\n\n        // Construct the output string based on the count\n        std::string count_str = std::to_string(odd_count);\n        std::string output_str = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\";\n        result.push_back(output_str);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <vector>\n#include <algorithm> // For std::replace if used, but manual loop is fine\n\n/*\nHelper function to count odd digits in a single string using SVE intrinsics.\nThis function parallelizes the character processing within a string.\n*/\nstatic int count_odd_digits_sve_helper(const std::string& s) {\n    const char* data = s.c_str();\n    size_t len = s.length();\n    int total_odd_count = 0;\n\n    // Get the SVE vector length for bytes (svcntb() returns the number of 8-bit elements)\n    size_t sv_len_bytes = svcntb();\n\n    // Loop through the string in chunks of sv_len_bytes\n    for (size_t i = 0; i < len; i += sv_len_bytes) {\n        // Create a governing predicate for the current chunk.\n        // svwhilelt_b8 generates a predicate where lanes are active as long as the\n        // current index 'i' plus the lane offset is less than 'len'.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters into an 8-bit unsigned integer vector.\n        // Only active lanes (determined by 'pg') are loaded from memory.\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(data + i));\n\n        // Convert character ASCII values to digit integer values (e.g., '1' -> 1).\n        // This operation applies to all lanes, but only active lanes produce meaningful results.\n        svuint8_t digits = svsub_u8(chars, svdup_u8('0'));\n\n        // Check for oddness: a digit is odd if its least significant bit is 1 (digit & 1 == 1).\n        // svand_u8 performs bitwise AND between 'digits' and a vector of all '1's.\n        // svcmpeq_u8 compares the result of the AND operation with a vector of all '1's.\n        // The predicate 'pg' ensures that comparisons only happen for valid elements.\n        svbool_t odd_predicate = svcmpeq_u8(pg, svand_u8(digits, svdup_u8(1)), svdup_u8(1));\n\n        // Count the number of true lanes in the 'odd_predicate'.\n        // svcntp_b counts the number of active elements in the predicate 'odd_predicate'\n        // that are also active in the governing predicate 'pg'.\n        total_odd_count += svcntp_b(pg, odd_predicate);\n    }\n    return total_odd_count;\n}\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    result.reserve(lst.size()); // Pre-allocate memory to improve performance\n\n    // Iterate through each string in the input vector\n    for (const std::string& s : lst) {\n        // Use the SVE helper function to count odd digits in the current string\n        int odd_count = count_odd_digits_sve_helper(s);\n\n        // Convert the odd_count to a string\n        std::string count_str = std::to_string(odd_count);\n\n        // Define the template string for the output\n        std::string output_template = \"the number of odd elements Xn the strXng X of the Xnput.\";\n        \n        // Build the final formatted string by replacing 'X' with the count_str\n        std::string formatted_output = \"\";\n        formatted_output.reserve(output_template.length() + count_str.length() * 3); // Estimate size\n        for (char c : output_template) {\n            if (c == 'X') {\n                formatted_output += count_str;\n            } else {\n                formatted_output += c;\n            }\n        }\n        result.push_back(formatted_output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::min\n#include <limits>    // For std::numeric_limits\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nThis problem is solved using a variant of Kadane's algorithm.\nThe recurrence relation for the minimum sum ending at the current position `k` is:\ncurrent_min[k] = nums[k] + min(0LL, current_min[k-1])\nThe overall minimum sum is the minimum of all current_min values.\n\nDue to the sequential dependency in the `current_min` calculation (current_min[k] depends on current_min[k-1]),\na fully parallel SVE scan for this specific operation is not directly available via a single intrinsic.\nTherefore, this implementation uses SVE intrinsics to efficiently load data in chunks and\nperform element-wise operations where possible, while handling the sequential dependency\nwithin each chunk using a scalar loop. This approach leverages SVE for data parallelism\n(loading multiple elements) and some instruction-level parallelism, even if the core\nKadane's recurrence remains sequential across elements.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    const int N = nums.size();\n\n    if (N == 0) {\n        // As per problem description, find minimum sum of any NON-EMPTY sub-vector.\n        // If the input vector is empty, there are no non-empty sub-vectors.\n        // Returning 0 or throwing an exception are common conventions.\n        // For this problem, let's return 0 for an empty input.\n        return 0;\n    }\n\n    // Initialize global_min to the largest possible 64-bit integer.\n    int64_t global_min = std::numeric_limits<int64_t>::max();\n    // Initialize current_min_scalar to 0. This represents the minimum sum ending\n    // at the previous position, or 0 if starting a new sub-vector is better.\n    int64_t current_min_scalar = 0;\n\n    // Loop through the array in chunks of SVE vector length.\n    // 'i' tracks the current index in the input array.\n    for (int i = 0; i < N; ) {\n        // Get the predicate for active lanes.\n        // `svwhilelt_b64(i, N)` generates a predicate that is true for lanes\n        // where the element index (starting from 'i') is less than 'N'.\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Get the number of active lanes in the current vector.\n        // This tells us how many elements are valid in the current chunk.\n        int count = svcntp_b64(pg);\n\n        // Load a vector of 64-bit integers from the input array.\n        // Only active lanes (determined by 'pg') will load data.\n        svint64_t v_nums = svld1_s64(pg, &nums[i]);\n\n        // Process elements within the current SVE vector.\n        // Due to the sequential dependency of Kadane's algorithm (current_min[k] depends on current_min[k-1]),\n        // we iterate through the elements of the loaded vector.\n        // This loop processes 'count' elements, which is at most the SVE vector length (VL).\n        for (int k = 0; k < count; ++k) {\n            // Extract the k-th element from the loaded SVE vector.\n            int64_t val = svget_s64(v_nums, k);\n\n            // Apply the Kadane's recurrence for minimum sum:\n            // current_min = current_element + min(0, current_min_from_previous_step)\n            // If current_min_from_previous_step is positive, it's better to start a new sub-vector (effectively adding 0).\n            // If current_min_from_previous_step is negative, extending the sub-vector might yield a smaller sum.\n            current_min_scalar = val + std::min(0LL, current_min_scalar);\n\n            // Update the overall minimum sum found so far.\n            global_min = std::min(global_min, current_min_scalar);\n        }\n\n        // Advance the index 'i' by the number of elements processed in this chunk.\n        i += count;\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm> // For std::min\n#include <climits>   // For LLONG_MAX\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    const int N = nums.size();\n\n    // If the input array is empty, there are no non-empty sub-vectors.\n    // The minimum sum in this case is typically considered positive infinity.\n    if (N == 0) {\n        return LLONG_MAX;\n    }\n\n    int64_t min_overall = LLONG_MAX;\n    int64_t current_min_scalar = 0; // Represents the sum of the current subarray ending at the last processed element.\n                                    // This is reset to 0 if it becomes positive, following Kadane's algorithm for minimum sum.\n\n    // Get the vector length for int64_t elements.\n    const int VL = svcntd();\n\n    // Loop through the array in chunks of VL elements.\n    for (int i = 0; i < N; i += VL) {\n        // Create a predicate to handle the tail end of the array where fewer than VL elements remain.\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Load a vector of elements from the input array.\n        // Inactive lanes (beyond N) will not be loaded or processed due to the predicate.\n        svint64_t data_vec = svld1_s64(pg, &nums[i]);\n\n        // Calculate inclusive prefix sums within the current vector chunk.\n        // For example, if data_vec = {a, b, c, d}, partial_sums_in_vec will be {a, a+b, a+b+c, a+b+c+d}.\n        svint64_t partial_sums_in_vec = svscan_s64(pg, svadd_s64_x, data_vec);\n\n        // Add the 'current_min_scalar' (sum from previous chunks) to each partial sum.\n        // This transforms the partial sums into actual subarray sums ending at each position within the current chunk.\n        // For example, if current_min_scalar = S, then actual_sums_ending_here will be {S+a, S+a+b, S+a+b+c, S+a+b+c+d}.\n        svint64_t actual_sums_ending_here = svadd_s64_x(pg, partial_sums_in_vec, svdup_n_s64(current_min_scalar));\n\n        // Find the minimum value within 'actual_sums_ending_here' (considering only active lanes).\n        int64_t min_in_chunk = svmin_s64_x(pg, actual_sums_ending_here);\n\n        // Update the overall minimum sum found so far.\n        min_overall = std::min(min_overall, min_in_chunk);\n\n        // Update 'current_min_scalar' for the next iteration.\n        // This involves summing up the elements in the current chunk and applying the Kadane's reset logic.\n        int64_t sum_of_chunk = svaddv_s64(pg, data_vec);\n        current_min_scalar = current_min_scalar + sum_of_chunk;\n        current_min_scalar = std::min(current_min_scalar, (int64_t)0);\n    }\n\n    return min_overall;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <limits> // For LLONG_MAX\n#include <algorithm> // For std::max\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    const size_t N = nums.size();\n\n    if (N == 0) {\n        // As per problem description, \"non-empty sub-vector\", implying nums is non-empty.\n        // Returning 0 for an empty input, or could throw an exception.\n        return 0; \n    }\n\n    // Initialize overall minimum sum to a very large value.\n    svint64_t min_vec_across_chunks = svdup_s64(std::numeric_limits<int64_t>::max());\n\n    // Scalar variables to maintain state across vector chunks.\n    // current_prefix_sum: The sum of elements up to the end of the previous chunk (P[i-1]).\n    // max_prefix_so_far: The maximum prefix sum encountered up to the end of the previous chunk (max(P[-1], P[0], ..., P[i-1])).\n    int64_t current_prefix_sum = 0; // Corresponds to P[-1]\n    int64_t max_prefix_so_far = 0;  // Corresponds to max(P[-1])\n\n    // Get the vector length (VL) for the current SVE implementation.\n    const size_t VL = svcntd();\n\n    for (size_t i = 0; i < N; i += VL) {\n        // Create a predicate for the current chunk, handling partial vectors at the end.\n        svbool_t pg = svwhilelt_b64(i, N);\n\n        // Load the data into an SVE vector. Inactive lanes are zeroed out by default for masked loads.\n        svint64_t data_vec = svld1_s64(pg, &nums[i]);\n\n        // 1. Compute inclusive prefix sums for the current chunk.\n        // This is a parallel scan (Blelloch scan variant) using svtbl_s64 for shifts.\n        svint64_t chunk_prefix_sums = data_vec;\n        for (size_t k = 1; k < VL; k *= 2) {\n            // Create indices for elements to be added (i.e., elements k positions before current).\n            // Indices less than 0 or greater than VL-1 will result in 0 when used with svtbl_s64.\n            svint64_t indices = svsub_s64_x(svptrue_b64(), svindex_s64(0, 1), svdup_s64(k));\n            svint64_t shifted_elements = svtbl_s64(chunk_prefix_sums, indices);\n            chunk_prefix_sums = svadd_s64_x(pg, chunk_prefix_sums, shifted_elements);\n        }\n        // Add the prefix sum from the previous chunk to all elements in the current chunk's prefix sums.\n        chunk_prefix_sums = svadd_s64_x(pg, chunk_prefix_sums, svdup_s64(current_prefix_sum));\n\n        // 2. Compute exclusive prefix maximums for the current chunk.\n        // This finds max(max_prefix_so_far, P[i], P[i+1], ..., P[j-1]) for each P[j] in the chunk.\n        svint64_t temp_max_scan = chunk_prefix_sums; // Start with inclusive prefix max of chunk_prefix_sums\n        for (size_t k = 1; k < VL; k *= 2) {\n            svint64_t indices = svsub_s64_x(svptrue_b64(), svindex_s64(0, 1), svdup_s64(k));\n            svint64_t shifted_elements = svtbl_s64(temp_max_scan, indices);\n            temp_max_scan = svmax_s64_x(pg, temp_max_scan, shifted_elements);\n        }\n        // Now `temp_max_scan` holds the inclusive prefix maximums of `chunk_prefix_sums`.\n        // To get exclusive prefix maximums, we shift `temp_max_scan` and combine with `max_prefix_so_far`.\n        svint64_t exclusive_chunk_prefix_max = svtbl_s64(temp_max_scan, svsub_s64_x(svptrue_b64(), svindex_s64(0, 1), svdup_s64(1)));\n        \n        // The first element of `exclusive_chunk_prefix_max` should be `max_prefix_so_far`.\n        // For other elements, it should be max of `max_prefix_so_far` and previous prefix sums in the chunk.\n        exclusive_chunk_prefix_max = svmax_s64_x(pg, exclusive_chunk_prefix_max, svdup_s64(max_prefix_so_far));\n        if (svqget_s64(pg, 0)) { // If the first lane is active, set its value explicitly.\n            exclusive_chunk_prefix_max = svset_s64(exclusive_chunk_prefix_max, 0, max_prefix_so_far);\n        }\n\n        // 3. Compute the difference: P[k] - max_P_before[k].\n        svint64_t diff_vec = svsub_s64_x(pg, chunk_prefix_sums, exclusive_chunk_prefix_max);\n\n        // 4. Update the overall minimum sum by finding the minimum within `diff_vec`.\n        min_vec_across_chunks = svmin_s64_x(pg, min_vec_across_chunks, diff_vec);\n\n        // 5. Update scalar `current_prefix_sum` and `max_prefix_so_far` for the next chunk.\n        // Get the last active element of `chunk_prefix_sums` for `current_prefix_sum`.\n        current_prefix_sum = svqget_s64(svlasta_s64(pg, chunk_prefix_sums), 0);\n        // Get the maximum value from `temp_max_scan` (which holds inclusive prefix max of chunk_prefix_sums).\n        // This is the maximum prefix sum encountered *within* this chunk.\n        max_prefix_so_far = std::max(max_prefix_so_far, svmax_s64_x(pg, temp_max_scan));\n    }\n\n    // Perform a final horizontal reduction to get the overall minimum sum.\n    return svmin_s64_x(svptrue_b64(), min_vec_across_chunks);\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::min, though SVE intrinsics will be used\n#include <limits>    // For std::numeric_limits<int64_t>::max()\n\n// The problem asks for a SIMD implementation using SVE intrinsics to enable parallelism.\n// Kadane's algorithm for minimum subarray sum is inherently sequential.\n// A common parallel approach for this type of problem (segment sum/min/max)\n// is a divide-and-conquer strategy, often implemented as a segment tree or parallel reduction.\n// Each segment stores:\n// - total_sum: The sum of all elements in the segment.\n// - min_prefix_sum: The minimum sum of any prefix of the segment.\n// - min_suffix_sum: The minimum sum of any suffix of the segment.\n// - min_subarray_sum: The minimum sum of any subarray entirely within the segment.\n\n// When combining two adjacent segments (left and right):\n// - new_total_sum = left.total_sum + right.total_sum\n// - new_min_prefix_sum = min(left.min_prefix_sum, left.total_sum + right.min_prefix_sum)\n// - new_min_suffix_sum = min(right.min_suffix_sum, right.total_sum + left.min_suffix_sum)\n// - new_min_subarray_sum = min(left.min_subarray_sum, right.min_subarray_sum, left.min_suffix_sum + right.min_prefix_sum)\n\n// This combine operation can be vectorized using SVE, processing multiple pairs of segments in parallel.\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t N = nums.size();\n\n    if (N == 0) {\n        // As per problem statement, \"non-empty sub-vector\".\n        // If the input vector is empty, there are no non-empty sub-vectors.\n        // Returning 0 or throwing an exception would be valid.\n        // Given the examples, assume non-empty input for practical purposes.\n        // If it must return a sum, 0 is a reasonable default for no elements.\n        return 0; \n    }\n\n    // Initialize vectors for the leaf level of the segment tree (each element is a segment)\n    // Using separate vectors for each property to facilitate SVE loads/stores.\n    std::vector<int64_t> current_total_sums(N);\n    std::vector<int64_t> current_min_prefix_sums(N);\n    std::vector<int64_t> current_min_suffix_sums(N);\n    std::vector<int64_t> current_min_subarray_sums(N);\n\n    // Populate the leaf level\n    for (size_t i = 0; i < N; ++i) {\n        current_total_sums[i] = nums[i];\n        current_min_prefix_sums[i] = nums[i];\n        current_min_suffix_sums[i] = nums[i];\n        current_min_subarray_sums[i] = nums[i]; // A single element is a valid non-empty sub-vector\n    }\n\n    size_t current_N = N;\n\n    // Perform parallel reduction (tree-like combination of segments)\n    while (current_N > 1) {\n        size_t next_N = (current_N + 1) / 2; // Number of segments in the next level\n        \n        std::vector<int64_t> next_total_sums(next_N);\n        std::vector<int64_t> next_min_prefix_sums(next_N);\n        std::vector<int64_t> next_min_suffix_sums(next_N);\n        std::vector<int64_t> next_min_subarray_sums(next_N);\n\n        // Process pairs of segments using SVE\n        // k iterates over the indices of the *next* level, which correspond to pairs in the current level.\n        for (size_t k = 0; k < current_N / 2; k += svcntd()) {\n            svbool_t pg_combine = svwhilelt_b64(k, current_N / 2); // Predicate for active lanes\n\n            // Load left parts of the pairs (at indices 2*k, 2*k+2, ...)\n            svint64_t sv_total_sum_left = svld1_s64(pg_combine, &current_total_sums[2 * k]);\n            svint64_t sv_min_prefix_sum_left = svld1_s64(pg_combine, &current_min_prefix_sums[2 * k]);\n            svint64_t sv_min_suffix_sum_left = svld1_s64(pg_combine, &current_min_suffix_sums[2 * k]);\n            svint64_t sv_min_subarray_sum_left = svld1_s64(pg_combine, &current_min_subarray_sums[2 * k]);\n\n            // Load right parts of the pairs (at indices 2*k+1, 2*k+3, ...)\n            svint64_t sv_total_sum_right = svld1_s64(pg_combine, &current_total_sums[2 * k + 1]);\n            svint64_t sv_min_prefix_sum_right = svld1_s64(pg_combine, &current_min_prefix_sums[2 * k + 1]);\n            svint64_t sv_min_suffix_sum_right = svld1_s64(pg_combine, &current_min_suffix_sums[2 * k + 1]);\n            svint64_t sv_min_subarray_sum_right = svld1_s64(pg_combine, &current_min_subarray_sums[2 * k + 1]);\n\n            // Perform combine operations using SVE intrinsics\n            svint64_t sv_new_total_sum = svadd_s64(sv_total_sum_left, sv_total_sum_right);\n            \n            svint64_t sv_new_min_prefix_sum = svmin_s64(sv_min_prefix_sum_left, svadd_s64(sv_total_sum_left, sv_min_prefix_sum_right));\n            \n            svint64_t sv_new_min_suffix_sum = svmin_s64(sv_min_suffix_sum_right, svadd_s64(sv_total_sum_right, sv_min_suffix_sum_left));\n            \n            svint64_t sv_new_min_subarray_sum = svmin_s64(sv_min_subarray_sum_left, sv_min_subarray_sum_right);\n            sv_new_min_subarray_sum = svmin_s64(sv_new_min_subarray_sum, svadd_s64(sv_min_suffix_sum_left, sv_min_prefix_sum_right));\n\n            // Store results to the next level vectors\n            svst1_s64(pg_combine, &next_total_sums[k], sv_new_total_sum);\n            svst1_s64(pg_combine, &next_min_prefix_sums[k], sv_new_min_prefix_sum);\n            svst1_s64(pg_combine, &next_min_suffix_sums[k], sv_new_min_suffix_sum);\n            svst1_s64(pg_combine, &next_min_subarray_sums[k], sv_new_min_subarray_sum);\n        }\n\n        // If current_N is odd, the last segment has no pair; copy it directly to the next level\n        if (current_N % 2 != 0) {\n            size_t last_idx = current_N - 1;\n            next_total_sums[next_N - 1] = current_total_sums[last_idx];\n            next_min_prefix_sums[next_N - 1] = current_min_prefix_sums[last_idx];\n            next_min_suffix_sums[next_N - 1] = current_min_suffix_sums[last_idx];\n            next_min_subarray_sums[next_N - 1] = current_min_subarray_sums[last_idx];\n        }\n\n        // Move to the next level\n        current_total_sums = std::move(next_total_sums);\n        current_min_prefix_sums = std::move(next_min_prefix_sums);\n        current_min_suffix_sums = std::move(next_min_suffix_sums);\n        current_min_subarray_sums = std::move(next_min_subarray_sums);\n        current_N = next_N;\n    }\n\n    // The final result is in the first element of the min_subarray_sums vector\n    return current_min_subarray_sums[0];\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": ""}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_lowers = 0; // Use long long to prevent potential overflow for large sums\n\n    // Iterate over each row (representing a single well) in the grid\n    for (const auto& row : grid) {\n        long long row_water_count = 0;\n\n        // Process the current row using SVE intrinsics if it's not empty\n        if (!row.empty()) {\n            // Initialize an SVE vector with all elements set to 0.\n            // This vector will accumulate the sum of water units (1s) in the current row.\n            svint32_t sum_vec = svdup_s32(0);\n\n            // Loop through the row in chunks of SVE vector length.\n            // svcntw() returns the number of 32-bit elements (int) that fit in an SVE vector.\n            for (size_t i = 0; i < row.size(); i += svcntw()) {\n                // Create a predicate for the current chunk.\n                // svwhilelt_b32 generates a predicate that is true for elements\n                // where 'i' is less than 'row.size()', effectively handling\n                // the tail (partial vector) of the row correctly.\n                svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)row.size());\n\n                // Load elements from the current chunk of the row into an SVE vector.\n                // svld1_s32 loads 32-bit signed integers.\n                svint32_t vec = svld1_s32(pg, &row[i]);\n\n                // Add the loaded vector to the accumulating sum_vec.\n                // svadd_s32_z performs a predicated addition. Elements where the predicate\n                // is false (i.e., beyond the end of the row) are zeroed out before addition,\n                // ensuring only valid elements contribute to the sum.\n                sum_vec = svadd_s32_z(pg, sum_vec, vec);\n            }\n\n            // Reduce the sum_vec to a single scalar value.\n            // svreduce_s32 performs a reduction operation (here, sum) across all elements\n            // of the vector. svadd_s32 specifies the addition operation.\n            row_water_count = svreduce_s32(svadd_s32, sum_vec);\n        }\n\n        // Calculate the number of times the bucket needs to be lowered for this specific row.\n        // This is equivalent to ceil(row_water_count / capacity).\n        // The formula (a + b - 1) / b is a common way to compute ceil(a/b) using integer division.\n        long long lowers_for_row = (row_water_count + capacity - 1) / capacity;\n        \n        // Add the calculated lowers for this row to the overall total.\n        total_lowers += lowers_for_row;\n    }\n\n    // Cast the final result to int as per the function signature.\n    // Note: If the total_lowers exceeds the maximum value of an int, this cast will result in an overflow.\n    return static_cast<int>(total_lowers);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> // Required for std::vector\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_lowerings = 0LL; // Use long long to prevent overflow during accumulation\n\n    // Handle empty grid case\n    if (grid.empty()) {\n        return 0;\n    }\n\n    // Get the number of 32-bit elements an SVE vector can hold.\n    // This value is determined at runtime by the SVE hardware.\n    const size_t sv_vec_len = svcntw();\n\n    // Iterate through each row (well) in the grid\n    for (const auto& row : grid) {\n        long long current_row_water_sum = 0LL;\n        const size_t row_length = row.size();\n\n        // If the row is empty, no water, no lowerings needed for this row.\n        if (row_length == 0) {\n            continue;\n        }\n\n        // Initialize an SVE vector to accumulate the sum of water units for the current row.\n        // All lanes are initialized to 0.\n        svint32_t row_sum_vec = svdup_n_s32(0);\n\n        // Process the row in chunks of `sv_vec_len` elements using SVE intrinsics.\n        for (size_t i = 0; i < row_length; i += sv_vec_len) {\n            // Generate a predicate for active lanes.\n            // This handles the case where the remaining elements are fewer than `sv_vec_len`.\n            svbool_t pg = svwhilelt_b32(i, row_length);\n\n            // Load a vector of 32-bit integers from the current chunk of the row.\n            // `&row[i]` provides a pointer to the start of the current chunk.\n            svint32_t data_vec = svld1_s32(pg, &row[i]);\n\n            // Add the loaded data vector to the accumulator vector.\n            row_sum_vec = svadd_s32(row_sum_vec, data_vec);\n        }\n\n        // Horizontally sum all elements in the `row_sum_vec` to get the total water\n        // for the current row. `svptrue_b32()` creates an all-true predicate,\n        // ensuring all elements in `row_sum_vec` are included in the sum.\n        current_row_water_sum = svaddv_s32(svptrue_b32(), row_sum_vec);\n\n        // Calculate the number of times buckets need to be lowered for this row.\n        // This is equivalent to ceil(current_row_water_sum / capacity).\n        // Using integer division: (A + B - 1) / B for positive A, B.\n        if (current_row_water_sum > 0) { // Only add lowerings if there's water\n            total_lowerings += (current_row_water_sum + capacity - 1) / capacity;\n        }\n    }\n\n    // The problem signature requires an `int` return type.\n    // Cast the accumulated `long long` sum to `int`.\n    // Note: If the total lowerings exceed the maximum value of `int` (e.g., 2*10^9 for 32-bit int),\n    // this cast will truncate. The problem constraints (10^5 * 10^5 = 10^10) suggest a larger\n    // result is possible, implying a potential mismatch with the `int` return type.\n    // However, the implementation adheres to the specified function signature.\n    return static_cast<int>(total_lowerings);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> // Required for std::vector\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    long long total_bucket_lowers = 0;\n\n    // Iterate through each row (well) in the grid\n    for (const auto& row : grid) {\n        long long water_in_current_well = 0;\n\n        // Use SVE intrinsics to sum the '1's (water units) in the current row.\n        // The elements are 'int' (0 or 1), which typically corresponds to 32-bit integers.\n        // Initialize a vector register to accumulate the sum.\n        svint32_t sum_vec = svdup_s32(0);\n\n        // Get a pointer to the underlying data of the std::vector<int>.\n        // This pointer is used for SVE load operations.\n        const int* row_data_ptr = row.data();\n        size_t row_size = row.size();\n\n        // Loop through the row in chunks determined by SVE's vector length (VL).\n        // svcntw() returns the number of 32-bit elements that fit in a vector register.\n        for (size_t i = 0; i < row_size; i += svcntw()) {\n            // Create a predicate for the current chunk.\n            // svwhilelt_b32(i, row_size) generates a predicate that is true for elements\n            // from 'i' up to 'row_size - 1', and false otherwise.\n            svbool_t current_pg = svwhilelt_b32(i, row_size);\n\n            // Check if the predicate is empty (i.e., no more active elements to process).\n            // This handles cases where row_size is not a multiple of svcntw() and\n            // ensures we don't try to load past the end of the row.\n            if (!svptest_any(svptrue_b32(), current_pg)) {\n                break;\n            }\n\n            // Load a vector of 32-bit integers from memory using the current predicate.\n            // reinterpret_cast is used because svld1_s32 expects a pointer to int32_t.\n            svint32_t data_vec = svld1_s32(current_pg, reinterpret_cast<const int32_t*>(row_data_ptr + i));\n            \n            // Add the loaded vector to the sum accumulator.\n            sum_vec = svadd_s32(sum_vec, data_vec);\n        }\n\n        // Perform a horizontal sum (reduction) of the sum_vec to get the total water\n        // for the current well. svptrue_b32() ensures all active lanes in sum_vec are included.\n        water_in_current_well = svaddv_s32(svptrue_b32(), sum_vec);\n\n        // Calculate the number of times buckets need to be lowered for this well.\n        // This is equivalent to ceil(water_in_current_well / capacity).\n        // The formula (a + b - 1) / b works for positive integers a and b.\n        // If water_in_current_well is 0, this correctly evaluates to 0.\n        if (water_in_current_well > 0) {\n            total_bucket_lowers += (water_in_current_well + capacity - 1) / capacity;\n        }\n    }\n\n    // The problem signature requires an 'int' return type.\n    // Cast the long long sum to int. This might truncate the result if it exceeds INT_MAX.\n    return static_cast<int>(total_bucket_lowers);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n// The function signature provided by the user.\n// Note: The return type is 'int'. Given the constraints (e.g., 10^5 rows * 10^5 columns * 1 unit/cell / 1 capacity = 10^10 lowers),\n// the total number of lowers can potentially exceed the maximum value of a 32-bit integer (approx 2*10^9).\n// A 'long long' return type would be more appropriate based on the constraints.\n// For this implementation, the internal sum will use 'long long' to prevent overflow during calculation,\n// and the final result will be cast to 'int' as per the function signature.\n// This implies that test cases are expected to produce results that fit within an 'int',\n// or that the overflow behavior is acceptable/expected.\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_lowers = 0;\n\n    // Handle edge case: empty grid\n    if (grid.empty()) {\n        return 0;\n    }\n\n    // Iterate through each row (well) in the grid\n    for (const auto& row : grid) {\n        long long water_in_row = 0;\n        // Get a pointer to the underlying data of the row vector.\n        // This is crucial for SVE intrinsics that operate on raw pointers.\n        const int* row_data = row.data(); \n        // Get the length of the current row.\n        int row_len = row.size();         \n\n        // If the row is empty, there's no water, so continue to the next row\n        if (row_len == 0) {\n            continue;\n        }\n\n        // Initialize an SVE vector to accumulate the sum of water units in the current row.\n        // svdup_s32(0) creates a vector where all elements are 0.\n        svint32_t sum_vec = svdup_s32(0); \n        \n        // Initialize the SVE predicate register.\n        // svwhilelt_b32(start, end) generates a predicate where elements are true\n        // as long as the current index (starting from 'start') is less than 'end'.\n        // This predicate controls which elements are active in SVE operations,\n        // ensuring we don't read past the end of the row.\n        svbool_t pg = svwhilelt_b32(0, row_len); \n\n        // Loop through the row using SVE intrinsics.\n        // svptest_any(pg, pg) checks if any element in the predicate 'pg' is true.\n        // If no elements are true, it means we have processed all elements in the row.\n        // svcntw() returns the number of 32-bit elements that fit in an SVE vector (VL).\n        for (int i = 0; svptest_any(pg, pg); i += svcntw()) {\n            // Load a vector of 32-bit integers from memory starting at row_data + i.\n            // Only elements corresponding to true predicates in 'pg' are loaded.\n            svint32_t current_elements = svld1_s32(pg, row_data + i);\n            \n            // Add the loaded elements to the sum_vec accumulator.\n            // This performs element-wise addition.\n            sum_vec = svadd_s32(sum_vec, current_elements);\n            \n            // Update the predicate for the next iteration.\n            // This ensures that we only process the remaining elements in the row.\n            pg = svwhilelt_b32(i + svcntw(), row_len); \n        }\n        \n        // Perform a horizontal sum of all elements in the sum_vec.\n        // svptrue_b32() creates a predicate where all elements are true, ensuring all elements in sum_vec are included\n        // in the final reduction sum.\n        water_in_row = svaddv_s32(svptrue_b32(), sum_vec);\n\n        // Calculate the number of times the bucket needs to be lowered for this row.\n        // This is equivalent to ceil(water_in_row / capacity) using integer arithmetic:\n        // (a + b - 1) / b for positive integers a, b.\n        long long lowers_for_row = (water_in_row + capacity - 1) / capacity;\n        \n        // Add the lowers for the current row to the total count.\n        total_lowers += lowers_for_row;\n    }\n\n    // Cast the final result to 'int' as per the function signature.\n    // Be aware of potential overflow if total_lowers exceeds INT_MAX.\n    return static_cast<int>(total_lowers);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector> \n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    long long total_bucket_lowers = 0;\n\n    // Iterate over each row (well) in the grid.\n    for (const auto& row : grid) {\n        // water_in_well stores the total units of water in the current well.\n        // It can be up to 10^5, which fits within a 32-bit integer.\n        int water_in_well = 0; \n        int row_len = row.size();\n\n        // If the row is empty, there's no water, so no bucket lowers are needed for this well.\n        if (row_len == 0) {\n            continue;\n        }\n\n        // Initialize an SVE vector of 32-bit integers to zeros for accumulating the sum of water units.\n        svint32_t sum_vec = svdup_s32(0); \n        \n        // Loop through the row in chunks determined by the SVE vector length (svcntw() returns the number of 32-bit elements in an SVE vector).\n        for (int k = 0; k < row_len; k += svcntw()) {\n            // Create a predicate to handle partial vectors at the end of the row.\n            // svwhilelt_b32 generates a predicate that is true for elements where the current index 'k' is less than 'row_len'.\n            svbool_t pg = svwhilelt_b32(k, row_len);\n            \n            // Load elements from the current chunk of the row into an SVE vector.\n            // svld1 loads elements using the predicate; elements corresponding to inactive lanes of the predicate are not loaded from memory.\n            svint32_t current_elements = svld1(pg, &row[k]);\n            \n            // Add the loaded elements to the sum vector.\n            // svadd_s32_x performs addition only for active lanes (controlled by the predicate 'pg').\n            // Inactive lanes of sum_vec remain unchanged.\n            sum_vec = svadd_s32_x(pg, sum_vec, current_elements);\n        }\n        \n        // Horizontally sum all elements in the sum_vec into a scalar value.\n        // svptrue_b32() creates an all-true predicate, ensuring all elements in sum_vec are included in the final sum.\n        water_in_well = svaddv_s32(svptrue_b32(), sum_vec);\n\n        // Calculate the number of times the bucket needs to be lowered for this well.\n        // This is an integer ceiling division: ceil(A/B) = (A + B - 1) / B for positive A, B.\n        // If water_in_well is 0, this correctly results in 0 lowers.\n        // We cast water_in_well to long long to ensure the numerator calculation (water_in_well + capacity - 1)\n        // is performed using long long arithmetic, preventing potential overflow if water_in_well was very large\n        // (though for current constraints, int would suffice for the numerator).\n        long long lowers_for_this_well = (static_cast<long long>(water_in_well) + capacity - 1) / capacity;\n        \n        // Add the calculated lowers for this well to the total count.\n        total_bucket_lowers += lowers_for_this_well;\n    }\n\n    // Cast the final result to int as per the function signature.\n    // Note: Given the constraints (grid.length up to 10^5, grid[i].length up to 10^5),\n    // the total_bucket_lowers can theoretically exceed the maximum value for a 32-bit int (INT_MAX).\n    // This cast might result in truncation/overflow if the actual sum is too large.\n    // The problem statement implies the result will fit in an int for test cases.\n    return static_cast<int>(total_bucket_lowers);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    const int N = lst.size();\n\n    // Initialize a vector for accumulating partial sums.\n    // Using int64_t for accumulation to prevent overflow.\n    svint64_t sum_vec = svdup_n_s64(0);\n\n    // Get the vector length for 16-bit and 64-bit elements.\n    // svcntw() returns the number of 16-bit elements per vector (VL/16).\n    // svcntd() returns the number of 64-bit elements per vector (VL/64).\n    // For SVE, VL is determined at runtime.\n    int16_t vl_16 = svcntw();\n    int64_t vl_64 = svcntd(); // vl_16 is typically 4 * vl_64\n\n    // Iterate through the input vector in chunks of vl_16 (16-bit elements).\n    for (int i = 0; i < N; i += vl_16) {\n        // Get the predicate for the current chunk, handling the tail elements.\n        // `pg_b16` is a predicate for 16-bit elements.\n        svbool_t pg_b16 = svwhilelt_b16(i, N);\n\n        // Load the current chunk of 16-bit integers.\n        svint16_t current_elements = svld1_s16(pg_b16, &lst[i]);\n\n        // Generate indices for the current chunk (starting from global index `i`).\n        svint16_t indices = svindex_s16(i, 1);\n\n        // Predicate for even positions: (index % 2 == 0) or (index & 1) == 0.\n        // `svand_n_s16(indices, 1)` computes `index & 1` for each element.\n        // `svcmpeq_n_s16(pg_b16, ..., 0)` compares the result with 0, masked by `pg_b16`.\n        svbool_t even_pos_pg_b16 = svcmpeq_n_s16(pg_b16, svand_n_s16(indices, 1), 0);\n\n        // Predicate for odd elements: (element % 2 != 0) or (element & 1) != 0.\n        // `svcmpne_n_s16(pg_b16, ..., 0)` compares the result with 0, masked by `pg_b16`.\n        svbool_t odd_val_pg_b16 = svcmpne_n_s16(pg_b16, svand_n_s16(current_elements, 1), 0);\n\n        // Combine the two predicates: (even position AND odd value).\n        svbool_t combined_pg_b16 = svand_b(even_pos_pg_b16, odd_val_pg_b16);\n\n        // Filter elements: set elements that do not satisfy `combined_pg_b16` to zero.\n        // This ensures that only relevant elements contribute to the sum after widening.\n        svint16_t filtered_elements = svsel_s16(combined_pg_b16, current_elements, svdup_n_s16(0));\n\n        // Split the `filtered_elements` vector (which has `vl_16` elements)\n        // into 4 sub-vectors, each containing `vl_64` elements.\n        // This is necessary because `svsext_s64_s16` operates on `vl_64` elements at a time.\n        // `svuzp1` and `svuzp2` de-interleave elements.\n        // First de-interleave into even/odd lanes:\n        svint16_t p01 = svuzp1_s16(filtered_elements, filtered_elements); // Contains elements at original indices 0, 2, 4, ...\n        svint16_t p23 = svuzp2_s16(filtered_elements, filtered_elements); // Contains elements at original indices 1, 3, 5, ...\n\n        // Then de-interleave again to get 4 distinct sub-vectors:\n        svint16_t p0 = svuzp1_s16(p01, p01); // Elements at original indices 0, 4, 8, ...\n        svint16_t p1 = svuzp2_s16(p01, p01); // Elements at original indices 2, 6, 10, ...\n        svint16_t p2 = svuzp1_s16(p23, p23); // Elements at original indices 1, 5, 9, ...\n        svint16_t p3 = svuzp2_s16(p23, p23); // Elements at original indices 3, 7, 11, ...\n\n        // Also split the `combined_pg_b16` predicate accordingly.\n        svbool_t pg01_b16 = svuzp1_b(combined_pg_b16, combined_pg_b16);\n        svbool_t pg23_b16 = svuzp2_b(combined_pg_b16, combined_pg_b16);\n        svbool_t pg0_b16 = svuzp1_b(pg01_b16, pg01_b16);\n        svbool_t pg1_b16 = svuzp2_b(pg01_b16, pg01_b16);\n        svbool_t pg2_b16 = svuzp1_b(pg23_b16, pg23_b16);\n        svbool_t pg3_b16 = svuzp2_b(pg23_b16, pg23_b16);\n\n        // Convert the 16-bit predicates to 64-bit predicates for `svadd_s64_m`.\n        svbool_t pg0_b64 = svcvt_b64_b16(pg0_b16);\n        svbool_t pg1_b64 = svcvt_b64_b16(pg1_b16);\n        svbool_t pg2_b64 = svcvt_b64_b16(pg2_b16);\n        svbool_t pg3_b64 = svcvt_b64_b16(pg3_b16);\n\n        // Widen each sub-vector to 64-bit integers and accumulate into `sum_vec`.\n        // `svsext_s64_s16` sign-extends 16-bit elements to 64-bit.\n        // `svadd_s64_m` performs masked addition: only active elements (where predicate is true) are added.\n        sum_vec = svadd_s64_m(sum_vec, pg0_b64, svsext_s64_s16(pg0_b16, p0));\n        sum_vec = svadd_s64_m(sum_vec, pg1_b64, svsext_s64_s16(pg1_b16, p1));\n        sum_vec = svadd_s64_m(sum_vec, pg2_b64, svsext_s64_s16(pg2_b16, p2));\n        sum_vec = svadd_s64_m(sum_vec, pg3_b64, svsext_s64_s16(pg3_b16, p3));\n    }\n\n    // Horizontally sum all elements in the `sum_vec` accumulator.\n    // `svptrue_b64()` creates a predicate where all 64-bit lanes are active.\n    total_sum = svaddv_s64(svptrue_b64(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    size_t n = lst.size();\n\n    // Loop through the vector in chunks of svcntw() (number of 16-bit elements per vector)\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // 1. Create a predicate for the active elements in the current chunk\n        //    This handles the tail end of the vector where the number of elements\n        //    might be less than the full vector length.\n        svbool_t pg = svwhilelt_b16(i, n);\n\n        // 2. Load the data from the input vector\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n\n        // 3. Generate a vector of indices for position checking\n        //    Starts from 'i' and increments by 1 for each lane: {i, i+1, i+2, ...}\n        svint16_t current_indices = svindex_s16(i, 1);\n        svint16_t one_vec16 = svdup_s16(1);\n        svint16_t zero_vec16 = svdup_s16(0);\n\n        // 4. Create a predicate for elements at even positions\n        //    An index 'x' is even if (x & 1) == 0.\n        svbool_t even_pos_pg = svcmpeq_s16(pg, svand_s16(current_indices, one_vec16), zero_vec16);\n\n        // 5. Create a predicate for odd-valued elements\n        //    A value 'v' is odd if (v & 1) == 1.\n        svbool_t odd_val_pg = svcmpeq_s16(pg, svand_s16(vec, one_vec16), one_vec16);\n\n        // 6. Combine the two predicates: an element must be at an even position AND have an odd value\n        svbool_t combined_pg = svand_b(even_pos_pg, odd_val_pg);\n\n        // 7. Select only the elements that satisfy the combined predicate, setting others to zero\n        //    This prepares the vector for summation, ensuring only relevant values contribute.\n        svint16_t selected_elements = svsel_s16(combined_pg, vec, zero_vec16);\n\n        // 8. Widen and sum the selected elements into a 32-bit accumulator vector.\n        //    Since svint16_t has twice as many lanes as svint32_t (e.g., 8 vs 4 for VL=128),\n        //    we split the 16-bit vector into two halves (even and odd indexed elements within the vector)\n        //    using svuzp1/svuzp2, convert each half to 32-bit, and then sum them.\n        svint16_t vec_low_half = svuzp1_s16(selected_elements, selected_elements);  // Elements at even indices within the 16-bit vector\n        svint16_t vec_high_half = svuzp2_s16(selected_elements, selected_elements); // Elements at odd indices within the 16-bit vector\n\n        svint32_t current_sum_vec32 = svdup_s32(0);\n        current_sum_vec32 = svadd_s32(current_sum_vec32, svcnv_s32_s16(vec_low_half));\n        current_sum_vec32 = svadd_s32(current_sum_vec32, svcnv_s32_s16(vec_high_half));\n\n        // 9. Horizontally sum the 32-bit accumulator vector and add the result to the total_sum.\n        //    The predicate for svaddv_s32 should cover the number of 32-bit lanes, which is svcntw()/2.\n        total_sum += svaddv_s32(svwhilelt_b32(0, svcntw() / 2), current_sum_vec32);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint> // For int16_t, int64_t\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    size_t i = 0;\n    size_t list_size = lst.size();\n\n    // Loop through the vector in chunks of SVE vector length for 16-bit integers.\n    // svcntw() returns the number of 16-bit elements in an SVE vector.\n    while (i < list_size) {\n        // 1. Create a predicate for the current chunk.\n        //    svwhilelt_b16(start_index, end_limit) generates a predicate\n        //    where elements from start_index up to (but not including) end_limit are true.\n        svbool_t pg = svwhilelt_b16(i, list_size);\n\n        // If no lanes are active in the predicate, it means we've processed all elements.\n        // This check ensures correct loop termination, especially for the last partial chunk.\n        if (svptest_n_b16(svptrue_b16(), pg)) {\n            break; \n        }\n\n        // 2. Load the 16-bit integer data into an SVE vector using the predicate.\n        //    Elements corresponding to false predicate lanes will be undefined,\n        //    but subsequent operations using the predicate will handle this.\n        svint16_t current_elements = svld1_s16(pg, &lst[i]);\n\n        // 3. Generate a vector of indices for the current chunk.\n        //    svindex_s16(start_value, step) generates a vector like {start_value, start_value+step, ...}\n        //    For example, if i=0, it generates {0, 1, 2, ...}. If i=svcntw(), it generates {svcntw(), svcntw()+1, ...}.\n        svint16_t indices = svindex_s16(i, 1);\n\n        // 4. Create a predicate for \"even positions\".\n        //    An index 'idx' is even if (idx % 2 == 0), which is equivalent to (idx & 1 == 0).\n        //    svand_s16_x performs bitwise AND on active lanes, others are unchanged.\n        svint16_t indices_and_1 = svand_s16_x(pg, indices, svdup_s16(1)); // Calculate (index & 1)\n        //    svcmpeq_s16 compares if (index & 1) is equal to 0 for active lanes.\n        svbool_t even_pos_pg = svcmpeq_s16(pg, indices_and_1, svdup_s16(0));\n\n        // 5. Create a predicate for \"odd values\".\n        //    A value 'val' is odd if (val % 2 != 0), which is equivalent to (val & 1 != 0).\n        svint16_t values_and_1 = svand_s16_x(pg, current_elements, svdup_s16(1)); // Calculate (value & 1)\n        //    svcmpeq_s16 compares if (value & 1) is equal to 1 for active lanes.\n        svbool_t odd_val_pg = svcmpeq_s16(pg, values_and_1, svdup_s16(1));\n\n        // 6. Combine the two predicates: an element must be at an even position AND have an odd value.\n        //    svand_b performs a bitwise AND on the boolean predicates.\n        svbool_t combined_pg = svand_b(even_pos_pg, odd_val_pg);\n\n        // 7. Convert the selected 16-bit elements to 64-bit integers.\n        //    svcvt_s64_s16(predicate, source_vector) converts elements where the predicate is true.\n        //    Crucially, elements where the predicate is false are set to zero in the result vector.\n        //    This makes it easy to sum only the desired elements.\n        svint64_t selected_elements_64 = svcvt_s64_s16(combined_pg, current_elements);\n\n        // 8. Horizontally sum all elements in the 64-bit vector.\n        //    Since non-selected elements were converted to 0, we can sum all elements in\n        //    'selected_elements_64' using a true predicate for the 64-bit lanes (svptrue_b64()).\n        total_sum += svaddv_s64(svptrue_b64(), selected_elements_64);\n\n        // Advance the loop index by the number of 16-bit elements processed in this chunk.\n        i += svcntw();\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    size_t N = lst.size();\n    size_t i = 0;\n\n    // Initialize a vector accumulator for 64-bit sums.\n    // This will hold partial sums for each lane, preventing overflow.\n    svint64_t vec_sum_acc = svdup_s64(0);\n\n    // Get the vector length for 16-bit elements.\n    // This is the number of int16_t elements that fit in one SVE vector.\n    size_t sv_vl = svcntw();\n\n    // Loop through the input vector in chunks of sv_vl.\n    for (i = 0; i < N; i += sv_vl) {\n        // Create a predicate for the current chunk, handling the tail of the vector.\n        // This predicate is true for active lanes within the current vector.\n        svbool_t pg = svwhilelt_b16(i, N);\n\n        // Load the current chunk of 16-bit integers from the input list.\n        svint16_t current_data = svld1_s16(pg, &lst[i]);\n\n        // Generate a sequence of indices for the current chunk: i, i+1, i+2, ...\n        svint16_t indices = svindex_s16(i, 1);\n\n        // --- Predicate for even positions ---\n        // Calculate (index % 2) for active lanes. Inactive lanes are zeroed.\n        svint16_t indices_mod_2 = svmod_s16_z(pg, indices, svdup_s16(2));\n        // Create a predicate where (indices % 2) == 0 (i.e., even positions).\n        svbool_t pg_even_pos = svcmpeq_s16(pg, indices_mod_2, svdup_s16(0));\n\n        // --- Predicate for odd elements ---\n        // Calculate (current_data & 1) for active lanes. Inactive lanes are zeroed.\n        // An odd number will have its least significant bit (LSB) set to 1.\n        svint16_t data_and_1 = svand_s16_z(pg, current_data, svdup_s16(1));\n        // Create a predicate where (current_data & 1) == 1 (i.e., odd elements).\n        svbool_t pg_odd_val = svcmpeq_s16(pg, data_and_1, svdup_s16(1));\n\n        // --- Combine predicates ---\n        // An element is selected if it's at an even position AND its value is odd.\n        svbool_t pg_combined = svand_b(pg_even_pos, pg_odd_val);\n\n        // --- Conditional Summation ---\n        // Select elements that satisfy the combined predicate.\n        // Elements not satisfying the predicate will be replaced with 0.\n        svint16_t selected_elements = svsel_s16(pg_combined, current_data, svdup_s16(0));\n\n        // Promote the selected 16-bit elements to 64-bit elements.\n        // This is crucial to prevent overflow during summation within the vector,\n        // as the sum of multiple int16_t values can exceed int16_t max.\n        // Only active lanes (determined by 'pg') are promoted; others become 0.\n        svint64_t promoted_elements = svsext_s64_s16(pg, selected_elements);\n\n        // Accumulate the promoted elements into the 64-bit vector accumulator.\n        // svptrue_b64() ensures all lanes of vec_sum_acc are updated.\n        vec_sum_acc = svadd_s64_x(svptrue_b64(), vec_sum_acc, promoted_elements);\n    }\n\n    // After processing all chunks, horizontally sum the elements in the 64-bit\n    // accumulator vector to get the final total sum.\n    total_sum = svaddv_s64(svptrue_b64(), vec_sum_acc);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint> // For int16_t, int64_t\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    const size_t size = lst.size();\n\n    // Scalar constants for SVE operations, duplicated to vector registers\n    svint16_t zero_16 = svdup_s16(0);\n    svint16_t one_16 = svdup_s16(1);\n    \n    // Full predicate for 32-bit operations, used for horizontal sum\n    // (since selected_elements are zeroed out, we sum all lanes of sum_32_part)\n    svbool_t pg_32_all = svptrue_b32(); \n\n    // Loop through the input vector in chunks of SVE vector length (svcntw() 16-bit elements)\n    for (size_t i = 0; i < size; i += svcntw()) {\n        // 1. Create a predicate for the current vector chunk.\n        //    This handles the tail end of the vector where the number of elements\n        //    might be less than the full SVE vector length.\n        svbool_t pg_16 = svwhilelt_b16(i, size);\n\n        // 2. Load data from the input list into an SVE vector.\n        //    Only active lanes (determined by pg_16) are loaded; inactive lanes are zeroed.\n        svint16_t data_vec = svld1_s16(pg_16, &lst[i]);\n\n        // 3. Generate a vector of absolute indices for the current chunk.\n        //    For example, if i=0, indices = {0, 1, 2, 3, ...}\n        //    If i=svcntw(), indices = {svcntw(), svcntw()+1, ...}\n        svint16_t indices = svindex_s16(i, 1);\n\n        // 4. Create a predicate for elements at even positions: (index % 2 == 0) <=> (index & 1 == 0)\n        svbool_t even_pos_pg = svcmpeq_s16(pg_16, svand_s16(indices, one_16), zero_16);\n\n        // 5. Create a predicate for odd elements: (element % 2 != 0) <=> (element & 1 != 0)\n        svbool_t odd_element_pg = svcmpne_s16(pg_16, svand_s16(data_vec, one_16), zero_16);\n\n        // 6. Combine the two predicates: element must be at an even position AND be odd.\n        svbool_t combined_pg = svand_b(even_pos_pg, odd_element_pg);\n\n        // 7. Select elements that satisfy the combined predicate, zeroing out others.\n        //    This is important because subsequent widening operations (svuzp1/2) operate on all lanes,\n        //    so non-selected elements must be zero to not affect the sum.\n        svint16_t selected_elements = svsel_s16(combined_pg, data_vec, zero_16);\n\n        // 8. Widen and sum the selected elements into a 32-bit vector accumulator.\n        //    SVE's svcntw() (number of 16-bit elements) is typically twice svcntd() (number of 32-bit elements).\n        //    - svuzp1_s16(vec, vec) extracts elements at even positions within the vector (0, 2, 4, ...)\n        //    - svuzp2_s16(vec, vec) extracts elements at odd positions within the vector (1, 3, 5, ...)\n        //    Each of these results in an svint16_t vector of length svcntd().\n        //    - svcvt_s32_s16 converts these svint16_t vectors to svint32_t vectors (also length svcntd()).\n        //    - svadd_s32 sums these into a temporary svint32_t accumulator.\n        svint32_t sum_32_part = svdup_s32(0);\n        sum_32_part = svadd_s32(sum_32_part, svcvt_s32_s16(svuzp1_s16(selected_elements, selected_elements)));\n        sum_32_part = svadd_s32(sum_32_part, svcvt_s32_s16(svuzp2_s16(selected_elements, selected_elements)));\n\n        // 9. Horizontally sum the 32-bit vector accumulator and add to the total_sum.\n        //    svaddv_s32 returns an int32_t, which is sufficient for the sum of elements\n        //    within a single SVE vector (max sum for 4 int16_t values is 4 * 32767 = 131068, fits in int32_t).\n        //    The total_sum is int64_t to prevent overflow across the entire input list.\n        total_sum += svaddv_s32(pg_32_all, sum_32_part);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svint32_t sum_vec = svdup_s32(0); // Initialize a vector to accumulate sums, all lanes set to 0\n    int i = 0; // Loop counter for array index\n\n    // Loop through the first k elements of the array using SVE vector processing\n    while (i < k) {\n        // Generate a predicate for the current vector chunk.\n        // svwhilelt_b32(i, k) creates a predicate where lanes are active (true)\n        // as long as the logical element index (starting from i) is less than k.\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // If no lanes are active in the predicate, it means we have processed\n        // all elements up to k, or k has been exhausted. Break the loop.\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break;\n        }\n\n        // Load elements from the array into an SVE vector.\n        // The predicate 'pg' ensures that only valid elements within the k-limit are loaded.\n        // Elements corresponding to inactive lanes in 'pg' will not be loaded (their values are undefined).\n        svint32_t current_elements = svld1_s32(pg, &arr[i]);\n\n        // Create predicates for the two conditions:\n        // 1. Element value is greater than or equal to -99\n        svbool_t cond_ge_neg99 = svcmpge_s32(pg, current_elements, -99);\n        // 2. Element value is less than or equal to 99\n        svbool_t cond_le_99 = svcmple_s32(pg, current_elements, 99);\n\n        // Combine the two conditions using a logical AND.\n        // A lane in 'final_cond' will be true only if both 'cond_ge_neg99' and 'cond_le_99' are true for that lane.\n        svbool_t final_cond = svand_b(cond_ge_neg99, cond_le_99);\n\n        // Conditionally add elements to the sum_vec.\n        // For lanes where 'final_cond' is true, the corresponding element from 'current_elements'\n        // is added to the corresponding element in 'sum_vec'.\n        // For lanes where 'final_cond' is false, the corresponding element in 'sum_vec' remains unchanged.\n        sum_vec = svadd_s32_m(sum_vec, final_cond, current_elements);\n\n        // Increment the loop counter by the number of 32-bit elements (integers)\n        // that an SVE vector can hold. This moves to the next vector chunk.\n        i += svcntw();\n    }\n\n    // Perform a horizontal sum of all elements in the 'sum_vec' to get the final scalar result.\n    // svptrue_b32() creates a predicate where all lanes are true, ensuring all accumulated\n    // sums in 'sum_vec' are included in the final reduction.\n    int total_sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int current_sum = 0;\n\n    // Get a pointer to the underlying data for efficient access\n    const int* arr_ptr = arr.data();\n\n    // Loop through the array in SVE vector chunks.\n    // The loop counter 'i' is incremented by the number of 32-bit elements\n    // an SVE vector can hold (svcntw()).\n    for (long long i = 0; i < k; i += svcntw()) {\n        // Create a predicate 'pg' that is true for lanes within the current vector\n        // that are also within the 'k' limit. This handles partial vectors at the end.\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // If no lanes are active in the predicate, it means we have processed\n        // all relevant elements up to 'k', so we can break the loop.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of 32-bit integers from 'arr_ptr + i'.\n        // Only elements corresponding to active lanes in 'pg' are loaded.\n        svint32_t vec = svld1_s32(pg, arr_ptr + i);\n\n        // Create SVE vectors for the lower and upper bounds of the two-digit check.\n        svint32_t lower_bound = svdup_s32(-99);\n        svint32_t upper_bound = svdup_s32(99);\n\n        // Compare elements in 'vec' to the lower bound (-99).\n        // 'cond_ge_neg99' will have true for lanes where vec[j] >= -99 (and are active in 'pg').\n        svbool_t cond_ge_neg99 = svcmpge_s32(pg, vec, lower_bound);\n        \n        // Compare elements in 'vec' to the upper bound (99).\n        // 'cond_le_99' will have true for lanes where vec[j] <= 99 (and are active in 'pg').\n        svbool_t cond_le_99 = svcmple_s32(pg, vec, upper_bound);\n\n        // Combine the two conditions using a logical AND.\n        // 'final_cond' will be true only for lanes that are active in 'pg'\n        // AND satisfy both (value >= -99) AND (value <= 99).\n        svbool_t final_cond = svand_b32(cond_ge_neg99, cond_le_99);\n\n        // Select elements based on 'final_cond'.\n        // For lanes where 'final_cond' is true, the original 'vec' element is kept.\n        // For lanes where 'final_cond' is false (even if active in 'pg'), the element is replaced with 0.\n        svint32_t selected_elements = svsel_s32(final_cond, vec, svdup_s32(0));\n\n        // Horizontally sum the elements in 'selected_elements'.\n        // The predicate 'pg' ensures that only the elements corresponding to the\n        // original 'k' limit are considered for the sum. Since 'selected_elements'\n        // already contains zeros for non-matching values, this correctly accumulates the sum.\n        current_sum += svaddv_s32(pg, selected_elements);\n    }\n\n    return current_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    // Initialize an SVE vector to accumulate the sum.\n    // All lanes are set to 0.\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Define the bounds for \"at most two digits\": -99 to 99.\n    svint32_t lower_bound = svdup_s32(-99);\n    svint32_t upper_bound = svdup_s32(99);\n\n    // Loop through the first 'k' elements of the array.\n    // 'i' is the current index in the array.\n    // 'svcntw()' returns the number of 32-bit elements (words) in an SVE vector.\n    // The loop iterates by the vector length, processing chunks of data.\n    for (long i = 0; i < k; i += svcntw()) {\n        // Generate a predicate 'pg' for the current vector chunk.\n        // This predicate is true for elements within the range [i, k)\n        // and false for elements beyond 'k' or beyond the current vector length.\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // Load data from the array into an SVE vector 'data_vec'.\n        // Only elements corresponding to true lanes in 'pg' are loaded.\n        // Inactive lanes of 'data_vec' remain unchanged.\n        svint32_t data_vec = svld1_s32(pg, &arr[i]);\n\n        // Create predicates for the two conditions:\n        // 1. data_vec >= -99 (lower bound check)\n        svbool_t cond_ge_lower = svcmpge(pg, data_vec, lower_bound);\n        // 2. data_vec <= 99 (upper bound check)\n        svbool_t cond_le_upper = svcmple(pg, data_vec, upper_bound);\n\n        // Combine the two predicates using logical AND.\n        // 'digit_cond' will be true only for elements that satisfy both\n        // the lower and upper bound conditions AND are active according to 'pg'.\n        svbool_t digit_cond = svand_b(cond_ge_lower, cond_le_upper);\n\n        // Conditionally add elements to 'sum_vec'.\n        // svadd_s32_m(operand1, mask, operand2, operand3) performs:\n        // operand1[lane] = mask[lane] ? (operand2[lane] + operand3[lane]) : operand2[lane];\n        // Here, 'sum_vec' is both operand1 and operand2 (accumulator),\n        // 'digit_cond' is the mask, and 'data_vec' is operand3.\n        // This means 'data_vec' elements are added to 'sum_vec' only where 'digit_cond' is true.\n        sum_vec = svadd_s32_m(sum_vec, digit_cond, sum_vec, data_vec);\n    }\n\n    // Perform a horizontal sum reduction on 'sum_vec'.\n    // This sums all elements within the 'sum_vec' into a single scalar integer.\n    // svptrue_b32() creates a predicate where all lanes are active (true),\n    // ensuring all elements in 'sum_vec' are included in the final sum.\n    int total_sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    // Initialize a scalar sum to accumulate the results.\n    // The problem constraints (k <= 2^24, elements up to 99) imply the sum\n    // can fit within a 32-bit signed integer (max sum approx 1.6 * 10^9).\n    int total_sum = 0;\n\n    // Get a pointer to the underlying data of the vector.\n    const int* arr_ptr = arr.data();\n\n    // Get the number of 32-bit elements that fit into an SVE vector.\n    // This value is determined at runtime by the SVE implementation.\n    int sv_len = svcntw();\n\n    // Initialize an SVE vector to accumulate partial sums.\n    // All lanes are set to 0.\n    svint32_t vec_sum = svdup_s32(0);\n\n    // Loop through the array in chunks of `sv_len` elements.\n    // The loop continues as long as the current index `i` is less than `k`.\n    for (int i = 0; i < k; i += sv_len) {\n        // Create a predicate for the current vector segment.\n        // `svwhilelt_b32(i, k)` generates a predicate that is true for lanes\n        // where `i + lane_index < k`, and false otherwise. This correctly handles\n        // the main loop and the tail elements.\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // Load elements from `arr_ptr + i` into an SVE vector.\n        // Only lanes where `pg` is true are loaded; inactive lanes are undefined.\n        svint32_t current_vec = svld1_s32(pg, arr_ptr + i);\n\n        // Calculate the absolute value of each element in `current_vec`.\n        // The `_x` suffix indicates that the operation is performed on all active lanes\n        // (defined by `pg`), and inactive lanes are left unchanged.\n        svint32_t abs_vec = svabs_s32_x(pg, current_vec);\n\n        // Create a mask for elements that have at most two digits (i.e., absolute value < 100).\n        // `svcmplt_s32(pg, abs_vec, 100)` compares each active lane of `abs_vec` with 100.\n        // The resulting predicate `two_digit_mask` is true for lanes where the condition holds.\n        svbool_t two_digit_mask = svcmplt_s32(pg, abs_vec, 100);\n\n        // Select elements based on the `two_digit_mask`.\n        // If `two_digit_mask` is true for a lane, the corresponding element from `current_vec` is selected.\n        // Otherwise (if `two_digit_mask` is false), 0 is selected for that lane.\n        // This effectively zeros out elements that do not meet the \"at most two digits\" criteria.\n        svint32_t selected_elements = svsel_s32(two_digit_mask, current_vec, svdup_s32(0));\n\n        // Add the `selected_elements` to the running `vec_sum`.\n        // The `_x` suffix means the addition is performed for all active lanes (defined by `pg`).\n        // Inactive lanes of `vec_sum` remain unchanged.\n        vec_sum = svadd_s32_x(pg, vec_sum, selected_elements);\n    }\n\n    // Horizontally sum all elements in the final `vec_sum` vector.\n    // `svptrue_b32()` creates a predicate where all lanes are true, ensuring all\n    // elements in `vec_sum` are included in the final reduction.\n    total_sum = svaddv_s32(svptrue_b32(), vec_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n    // Initialize an SVE vector for accumulating sums.\n    // All lanes are initialized to 0.\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Loop through the array in chunks of SVE vector length.\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (int i = 0; i < k; i += svcntw()) {\n        // Create a governing predicate for the current chunk.\n        // svwhilelt_b32(i, k) generates a predicate that is true for lanes\n        // where the element index (starting from i) is less than k.\n        // This handles the tail elements correctly.\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // Load elements from the array into an SVE vector using the governing predicate.\n        // Elements corresponding to false predicate lanes are not loaded (or become unpredictable).\n        svint32_t current_elements = svld1_s32(pg, &arr[i]);\n\n        // Calculate the absolute values of the loaded elements.\n        svint32_t abs_elements = svabs_s32(current_elements);\n\n        // Create an SVE vector where all lanes contain the constant 99.\n        // This is used for the comparison (at most two digits means abs(x) <= 99).\n        svint32_t limit = svdup_s32(99);\n\n        // Create a condition predicate: true for elements where abs(element) <= 99.\n        // The governing predicate 'pg' ensures that only active lanes are considered for the comparison.\n        svbool_t cond_pred = svcmple_s32(pg, abs_elements, limit);\n\n        // Select elements that satisfy the condition.\n        // If cond_pred is true for a lane, the element from current_elements is chosen.\n        // Otherwise, 0 is chosen for that lane.\n        svint32_t selected_elements = svsel_s32(cond_pred, current_elements, svdup_s32(0));\n\n        // Accumulate the sum of selected elements.\n        // This performs an element-wise addition of selected_elements to sum_vec.\n        // Each lane in sum_vec accumulates the sum of qualifying elements from its corresponding lane position\n        // across different chunks.\n        sum_vec = svadd_s32(sum_vec, selected_elements);\n    }\n\n    // Horizontally sum all elements in the sum_vec.\n    // After the loop, sum_vec contains partial sums in each lane.\n    // svaddv_s32 reduces the vector to a single scalar sum.\n    // svptrue_b32() creates a predicate where all lanes are true, ensuring all partial sums are included.\n    int total_sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n\n    // Handle small cases explicitly\n    if (n <= 1) {\n        return true;\n    }\n    if (n == 2) {\n        return lst[0] <= lst[1];\n    }\n    if (n == 3) {\n        // Check sorted order\n        if (!(lst[0] <= lst[1] && lst[1] <= lst[2])) {\n            return false;\n        }\n        // Check for triple duplicates\n        if (lst[0] == lst[1] && lst[1] == lst[2]) {\n            return false;\n        }\n        return true;\n    }\n\n    // SVE loop\n    size_t i = 0;\n    size_t sv_len = svcntw(); // Number of 32-bit integers in an SVE vector\n\n    // The loop iterates with a stride of sv_len.\n    // The predicates `svwhilelt_b32` ensure that operations only apply to valid elements\n    // within the bounds of the array for each specific check (sorted or duplicate).\n    // The loop continues as long as there's at least one element left for the sorted check (n-1).\n    for (i = 0; i < n - 1; i += sv_len) {\n        // --- Sorted check: lst[k] <= lst[k+1] ---\n        // This check requires elements up to index n-1.\n        // The predicate `pg_sorted` is active for lanes `k` where `i + k < n - 1`.\n        // This means it covers comparisons `lst[i]<=lst[i+1]` up to `lst[n-2]<=lst[n-1]`.\n        svbool_t pg_sorted = svwhilelt_b32(i, n - 1);\n        if (svptest_any(svptrue_b32(), pg_sorted)) { // Only proceed if there are active lanes for this check\n            svint32_t v_curr = svld1(pg_sorted, &lst[i]);\n            svint32_t v_next = svld1(pg_sorted, &lst[i+1]);\n            \n            svbool_t cmp_le = svcmple(pg_sorted, v_curr, v_next);\n            if (!svptest_all(pg_sorted, cmp_le)) {\n                return false; // Found an unsorted pair\n            }\n        }\n\n        // --- Duplicate check: !(lst[k] == lst[k+1] && lst[k+1] == lst[k+2]) ---\n        // This check requires elements up to index n-1 (specifically, lst[k+2] where k=n-3).\n        // The predicate `pg_dup` is active for lanes `k` where `i + k < n - 2`.\n        // This means it covers triple duplicate checks `lst[i]==lst[i+1]==lst[i+2]` up to `lst[n-3]==lst[n-2]==lst[n-1]`.\n        svbool_t pg_dup = svwhilelt_b32(i, n - 2);\n        if (svptest_any(svptrue_b32(), pg_dup)) { // Only proceed if there are active lanes for this check\n            svint32_t v_curr = svld1(pg_dup, &lst[i]);\n            svint32_t v_next = svld1(pg_dup, &lst[i+1]);\n            svint32_t v_next2 = svld1(pg_dup, &lst[i+2]);\n\n            svbool_t cmp_eq1 = svcmeq(pg_dup, v_curr, v_next);   // Check lst[k] == lst[k+1]\n            svbool_t cmp_eq2 = svcmeq(pg_dup, v_next, v_next2); // Check lst[k+1] == lst[k+2]\n            \n            // Combine to find if (lst[k] == lst[k+1] && lst[k+1] == lst[k+2])\n            svbool_t triple_dup = svand_b(cmp_eq1, cmp_eq2);\n\n            if (svptest_any(pg_dup, triple_dup)) {\n                return false; // Found a triple duplicate\n            }\n        }\n    }\n\n    return true; // All checks passed\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n\n    // Handle empty or single-element vectors, which are considered sorted.\n    if (n <= 1) {\n        return true;\n    }\n\n    // --- Condition 1: Check for ascending order (lst[i] <= lst[i+1]) ---\n    // This check needs to be performed for i from 0 to n-2.\n    // The loop iterates with a stride of VL (vector length in elements).\n    // svcntw() returns the number of 32-bit elements in a vector.\n    size_t k = 0;\n    while (k < n - 1) { // Loop until k reaches n-1, ensuring lst[k+1] is valid\n        // Create a predicate for the current vector block.\n        // It's active for elements where the index 'k' is less than 'n - 1'.\n        svbool_t pg_asc = svwhilelt_b32(k, n - 1);\n\n        // If no elements are active in this predicate (i.e., k >= n-1), break the loop.\n        if (svptest_first(svptrue_b32(), pg_asc) == 0) {\n            break;\n        }\n\n        // Load current elements and next elements into SVE vectors.\n        // Elements are loaded under the control of the predicate 'pg_asc'.\n        svint32_t v_curr = svld1_s32(pg_asc, &lst[k]);\n        svint32_t v_next = svld1_s32(pg_asc, &lst[k+1]);\n\n        // Compare v_curr with v_next. We want v_curr <= v_next.\n        // svcmpge_s32(pg, op1, op2) returns true if op1 >= op2.\n        // So, svcmpge_s32(pg_asc, v_next, v_curr) checks if v_next >= v_curr.\n        svbool_t cmp_le = svcmpge_s32(pg_asc, v_next, v_curr);\n\n        // If any active element fails the comparison (i.e., v_next < v_curr),\n        // then the list is not sorted in ascending order.\n        if (!svptest_all(pg_asc, cmp_le)) {\n            return false;\n        }\n\n        // Advance the index by the vector length.\n        k += svcntw();\n    }\n\n    // --- Condition 2: Check for no more than one duplicate (no three consecutive identical numbers) ---\n    // This check needs to be performed for i from 0 to n-3.\n    // (i.e., !(lst[i] == lst[i+1] && lst[i+1] == lst[i+2]))\n    k = 0;\n    while (k < n - 2) { // Loop until k reaches n-2, ensuring lst[k+2] is valid\n        // Create a predicate for the current vector block.\n        // It's active for elements where the index 'k' is less than 'n - 2'.\n        svbool_t pg_dup = svwhilelt_b32(k, n - 2);\n\n        // If no elements are active in this predicate, break the loop.\n        if (svptest_first(svptrue_b32(), pg_dup) == 0) {\n            break;\n        }\n\n        // Load three consecutive blocks of elements.\n        svint32_t v_a = svld1_s32(pg_dup, &lst[k]);\n        svint32_t v_b = svld1_s32(pg_dup, &lst[k+1]);\n        svint32_t v_c = svld1_s32(pg_dup, &lst[k+2]);\n\n        // Check if v_a == v_b\n        svbool_t eq_ab = svcmpeq_s32(pg_dup, v_a, v_b);\n        // Check if v_b == v_c\n        svbool_t eq_bc = svcmpeq_s32(pg_dup, v_b, v_c);\n\n        // Combine the two equality checks: (v_a == v_b) AND (v_b == v_c)\n        svbool_t both_eq = svand_b(eq_ab, eq_bc);\n\n        // If any active element satisfies 'both_eq' (meaning three consecutive duplicates),\n        // then the list violates the condition.\n        if (svptest_any(pg_dup, both_eq)) {\n            return false;\n        }\n\n        // Advance the index by the vector length.\n        k += svcntw();\n    }\n\n    // If both checks pass for all elements, the list is sorted according to the rules.\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n\n    if (n <= 1) {\n        return true;\n    }\n\n    // Get the SVE vector length in terms of 32-bit integers.\n    // This determines how many elements are processed in parallel.\n    size_t sv_len = svcntw();\n\n    // Loop through the vector in chunks of `sv_len`.\n    // The loop condition `i < n - 1` ensures that `lst[i+1]` is always a potentially valid access\n    // for the ascending order check. The SVE predicates will handle out-of-bounds accesses\n    // for the tail elements correctly.\n    for (size_t i = 0; i < n - 1; i += sv_len) {\n        // Predicate for loading current elements (lst[k]).\n        // Active for lanes where `i + lane_idx < n`.\n        svbool_t pg_curr_load = svwhilelt_b32(i, n);\n\n        // Predicate for comparisons involving `lst[k]` and `lst[k+1]`.\n        // Active for lanes where `i + lane_idx < n - 1`, ensuring `lst[k+1]` is in bounds.\n        svbool_t pg_sorted_check = svwhilelt_b32(i, n - 1);\n        \n        // Predicate for comparisons involving `lst[k]`, `lst[k+1]`, and `lst[k+2]`.\n        // Active for lanes where `i + lane_idx < n - 2`, ensuring `lst[k+2]` is in bounds.\n        svbool_t pg_duplicate_check = svwhilelt_b32(i, n - 2);\n\n        // Load current elements: lst[i], lst[i+1], ...\n        // Only active lanes (where pg_curr_load is true) will be loaded.\n        svint32_t v_curr = svld1_s32(pg_curr_load, &lst[i]);\n\n        // Load next elements: lst[i+1], lst[i+2], ...\n        // The predicate `pg_sorted_check` ensures that `lst[i+1]` is within bounds for the active lanes.\n        svint32_t v_next = svld1_s32(pg_sorted_check, &lst[i+1]);\n\n        // 1. Check for ascending order: lst[k] <= lst[k+1]\n        // Compare v_curr with v_next. The comparison is only meaningful for lanes where both are valid.\n        // `pg_sorted_check` is the correct predicate for this comparison, as it ensures `lst[k+1]` exists.\n        svbool_t cmp_sorted = svcmple(pg_sorted_check, v_curr, v_next);\n        \n        // If any active lane in `cmp_sorted` is false, then the list is not sorted.\n        // `svnot_b(pg_sorted_check, cmp_sorted)` inverts the predicate for active lanes.\n        // `svptest_any` checks if any active lane in the first predicate is also active in the second.\n        if (svptest_any(pg_sorted_check, svnot_b(pg_sorted_check, cmp_sorted))) {\n            return false;\n        }\n\n        // 2. Check for more than one duplicate: !(lst[k] == lst[k+1] && lst[k+1] == lst[k+2])\n        // This check requires `lst[k+2]` to exist.\n        // So, `pg_duplicate_check` is the predicate for this check.\n        \n        // Load next-next elements: lst[i+2], lst[i+3], ...\n        // Only active lanes (where pg_duplicate_check is true) will be loaded.\n        svint32_t v_next_next = svld1_s32(pg_duplicate_check, &lst[i+2]);\n\n        // Compare lst[k] == lst[k+1] for the duplicate check window\n        svbool_t cmp_dup1 = svcmpeq(pg_duplicate_check, v_curr, v_next);\n        // Compare lst[k+1] == lst[k+2] for the duplicate check window\n        svbool_t cmp_dup2 = svcmpeq(pg_duplicate_check, v_next, v_next_next);\n\n        // Combine the two duplicate checks: (lst[k] == lst[k+1]) AND (lst[k+1] == lst[k+2])\n        // The `pg_duplicate_check` predicate ensures we only consider valid comparisons.\n        svbool_t dup_violation = svand_b(pg_duplicate_check, cmp_dup1, cmp_dup2);\n\n        // If any active lane in `dup_violation` is true, then we have more than one duplicate.\n        if (svptest_any(pg_duplicate_check, dup_violation)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n// Function to check if a vector of integers is sorted in ascending order\n// with no more than one duplicate of the same number.\n//\n// Examples:\n// is_sorted_simd({}) \u279e true\n// is_sorted_simd({5}) \u279e true\n// is_sorted_simd({1, 2, 3, 4, 5}) \u279e true\n// is_sorted_simd({1, 3, 2, 4, 5}) \u279e false\n// is_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\n// is_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false (three consecutive 2s)\nbool is_sorted_simd(const std::vector<int> & lst) {\n    const size_t size = lst.size();\n\n    // Handle base cases for small vector sizes\n    if (size <= 1) {\n        return true; // Empty or single-element list is considered sorted and has no duplicates.\n    }\n\n    // Get the SVE vector length in terms of 32-bit integers (words)\n    const size_t vec_len = svcntw();\n\n    // Loop through the vector using SVE intrinsics\n    // The loop iterates `i` as the starting index of each SVE vector chunk.\n    // For each element `k` within a vector chunk, we need to access `lst[k]`, `lst[k+1]`, and `lst[k+2]`.\n    // The loop condition `i + 2 < size` ensures that `lst[i+2]` is a valid access for the first element\n    // of the current vector chunk. The predicate `pg` will handle the remaining elements in the chunk,\n    // ensuring all accesses are within bounds.\n    size_t i = 0;\n    for (i = 0; i + 2 < size; i += vec_len) {\n        // Create a predicate `pg` that is true for elements `k` such that `i <= k < size - 2`.\n        // This ensures that `lst[k+2]` will be a valid memory access for all active lanes.\n        svbool_t pg = svwhilelt_b32(i, size - 2);\n\n        // If no lanes are active in the current predicate, it means we've processed all relevant elements\n        // that require `lst[k+2]` access. This check is important for the tail end of the loop where `i`\n        // might exceed `size - 2`.\n        if (svptest_any(svwhilelt_b32(0, vec_len), pg) == 0) {\n            break;\n        }\n\n        // Load three overlapping vectors:\n        // v_curr:      [lst[i],   lst[i+1], ..., lst[i+vec_len-1]]\n        // v_next:      [lst[i+1], lst[i+2], ..., lst[i+vec_len]]\n        // v_next_next: [lst[i+2], lst[i+3], ..., lst[i+vec_len+1]]\n        // All loads are masked by `pg`, so only valid elements within the bounds are loaded.\n        svint32_t v_curr = svld1_s32(pg, &lst[i]);\n        svint32_t v_next = svld1_s32(pg, &lst[i+1]);\n        svint32_t v_next_next = svld1_s32(pg, &lst[i+2]);\n\n        // Condition 1: Check if `lst[k] <= lst[k+1]` for all active `k`.\n        // `svcmple` performs element-wise less than or equal comparison.\n        svbool_t le_pred = svcmple(pg, v_curr, v_next);\n        // If any active lane in `le_pred` is false (i.e., `lst[k] > lst[k+1]`), then the list is not sorted.\n        if (svptest_any(pg, svnot_b(pg, le_pred))) {\n            return false;\n        }\n\n        // Condition 2: Check if `!(lst[k] == lst[k+1] && lst[k+1] == lst[k+2])` for all active `k`.\n        // This checks for three consecutive identical numbers.\n        svbool_t eq1_pred = svcmpeq(pg, v_curr, v_next);       // Check lst[k] == lst[k+1]\n        svbool_t eq2_pred = svcmpeq(pg, v_next, v_next_next);   // Check lst[k+1] == lst[k+2]\n        svbool_t triple_eq_pred = svand_b(pg, eq1_pred, eq2_pred); // Combine the two equality checks\n        // If any active lane in `triple_eq_pred` is true, then three consecutive identical numbers were found.\n        if (svptest_any(pg, triple_eq_pred)) {\n            return false;\n        }\n    }\n\n    // Scalar cleanup for the remaining elements.\n    // The SVE loop processes elements `k` such that `k+2 < size`. This means the loop covers `k` from `0` up to `size - 3`.\n    // Therefore, the condition `!(lst[k] == lst[k+1] && lst[k+1] == lst[k+2])` is fully covered by the SVE loop.\n    // The only remaining check for sortedness is `lst[size-2] <= lst[size-1]`, which applies if `size >= 2`.\n    if (size >= 2) {\n        if (lst[size - 2] > lst[size - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n\n    // Handle edge cases for small vector sizes\n    if (size <= 1) {\n        return true; // An empty or single-element list is considered sorted.\n    }\n\n    // Condition 1: Check if sorted in ascending order (lst[i] <= lst[i+1])\n    // Iterate through the list, comparing adjacent elements using SVE vectors.\n    // The loop runs up to size - 1 because we compare lst[i] with lst[i+1].\n    for (int i = 0; i < size - 1; i += svcntw()) {\n        // Create a predicate for the current SVE vector chunk.\n        // The predicate is true for elements where (i + lane_index) < (size - 1).\n        // This ensures we don't read past lst[size-1] when loading lst[i+1].\n        svbool_t pg = svwhilelt_b32(i, size - 1);\n\n        // If no elements are active in this chunk (e.g., i is beyond size-1), break.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load current elements (lst[i], lst[i+1], ...)\n        svint32_t current_vec = svld1_s32(pg, &lst[i]);\n        // Load next elements (lst[i+1], lst[i+2], ...)\n        svint32_t next_vec = svld1_s32(pg, &lst[i+1]);\n\n        // Compare if current_vec <= next_vec for all active lanes.\n        svbool_t cmp_le = svcmple(pg, current_vec, next_vec);\n\n        // If any comparison fails (i.e., lst[k] > lst[k+1] for some k), return false.\n        if (!svptest_all(pg, cmp_le)) {\n            return false;\n        }\n    }\n\n    // Condition 2: Check for no more than 1 duplicate (i.e., !(lst[i] == lst[i+1] && lst[i+1] == lst[i+2]))\n    // This means sequences like {X, Y, Y, Y, Z} are forbidden, but {X, Y, Y, Z} is allowed.\n    // The loop runs up to size - 2 because we compare lst[i], lst[i+1], and lst[i+2].\n    if (size >= 3) { // This condition only applies if there are at least 3 elements.\n        for (int i = 0; i < size - 2; i += svcntw()) {\n            // Create a predicate for the current SVE vector chunk.\n            // The predicate is true for elements where (i + lane_index) < (size - 2).\n            // This ensures we don't read past lst[size-1] when loading lst[i+2].\n            svbool_t pg = svwhilelt_b32(i, size - 2);\n\n            // If no elements are active in this chunk, break.\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n\n            // Load three consecutive vectors of elements.\n            svint32_t vec_i = svld1_s32(pg, &lst[i]);\n            svint32_t vec_i_plus_1 = svld1_s32(pg, &lst[i+1]);\n            svint32_t vec_i_plus_2 = svld1_s32(pg, &lst[i+2]);\n\n            // Check if lst[k] == lst[k+1] for active lanes.\n            svbool_t cmp_eq1 = svcmpeq(pg, vec_i, vec_i_plus_1);\n            // Check if lst[k+1] == lst[k+2] for active lanes.\n            svbool_t cmp_eq2 = svcmpeq(pg, vec_i_plus_1, vec_i_plus_2);\n\n            // Combine the two equality checks: (lst[k] == lst[k+1]) && (lst[k+1] == lst[k+2])\n            svbool_t combined_eq = svand_b(cmp_eq1, cmp_eq2);\n\n            // If any active lane in combined_eq is true, it means we found three consecutive equal elements.\n            // In this case, return false.\n            if (svptest_any(pg, combined_eq)) {\n                return false;\n            }\n        }\n    }\n\n    // If both conditions are met throughout the list, return true.\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    long long total_magnitude = 0;\n    long long total_negative_count = 0;\n    bool has_zero = false;\n\n    size_t i = 0;\n    size_t n = arr.size();\n\n    size_t vl = svcntw();\n\n    for (i = 0; i + vl <= n; i += vl) {\n        svbool_t pg = svptrue_b32();\n\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n\n        svint32_t abs_vec = svabs_s32(pg, vec);\n        total_magnitude += svaddv_s32(pg, abs_vec);\n\n        if (!has_zero) {\n            svbool_t p_zero = svcmpeq_s32(pg, vec, 0);\n            if (svptest_any(pg, p_zero)) {\n                has_zero = true;\n            }\n        }\n\n        if (!has_zero) {\n            svbool_t p_neg = svclt_s32(pg, vec, 0);\n            total_negative_count += svcntp_b32(pg, p_neg);\n        }\n    }\n\n    if (i < n) {\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)n);\n\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n\n        svint32_t abs_vec = svabs_s32(pg, vec);\n        total_magnitude += svaddv_s32(pg, abs_vec);\n\n        if (!has_zero) {\n            svbool_t p_zero = svcmpeq_s32(pg, vec, 0);\n            if (svptest_any(pg, p_zero)) {\n                has_zero = true;\n            }\n        }\n\n        if (!has_zero) {\n            svbool_t p_neg = svclt_s32(pg, vec, 0);\n            total_negative_count += svcntp_b32(pg, p_neg);\n        }\n    }\n\n    int final_sign_product;\n    if (has_zero) {\n        final_sign_product = 0;\n    } else if (total_negative_count % 2 == 1) {\n        final_sign_product = -1;\n    } else {\n        final_sign_product = 1;\n    }\n\n    return static_cast<int>(total_magnitude) * final_sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    long arr_size = arr.size();\n    const int *ptr = arr.data();\n\n    int total_sum_magnitudes = 0;\n    int neg_count = 0;\n    bool has_zero = false;\n\n    long i = 0;\n    // Loop through the array in chunks determined by SVE vector length (VL)\n    // svwhilelt_b32 generates a predicate for elements from 'i' up to 'arr_size - 1'.\n    // svcnt_b32 returns the number of active elements in the predicate.\n    for (svbool_t pg = svwhilelt_b32(i, arr_size); svcnt_b32(pg) > 0; i += svcnt_b32(pg), pg = svwhilelt_b32(i, arr_size)) {\n        // Load a vector of integers from the array using the predicate 'pg'\n        svint32_t vec = svld1_s32(pg, ptr + i);\n\n        // Calculate the absolute value of each element in the vector\n        svint32_t abs_vec = svabs_s32(pg, vec);\n        // Horizontally sum the absolute values and add to the total sum\n        total_sum_magnitudes += svaddv_s32(pg, abs_vec);\n\n        // Check if any element in the current vector chunk is zero\n        svbool_t current_has_zero = svcmeq_s32(pg, vec, 0);\n        // If any active element in the predicate 'pg' is zero, set has_zero flag\n        if (svptest_any(pg, current_has_zero)) {\n            has_zero = true;\n        }\n\n        // Count the number of negative elements in the current vector chunk\n        svbool_t current_is_neg = svcmplt_s32(pg, vec, 0);\n        // Add the count of negative elements to the total negative count\n        neg_count += svcnt_b32(current_is_neg);\n    }\n\n    int final_prod_signs;\n    if (has_zero) {\n        // If any zero was found, the product of signs is 0\n        final_prod_signs = 0;\n    } else if (neg_count % 2 == 0) {\n        // If an even number of negative signs, the product is 1\n        final_prod_signs = 1;\n    } else {\n        // If an odd number of negative signs, the product is -1\n        final_prod_signs = -1;\n    }\n\n    // Return the sum of magnitudes multiplied by the product of signs\n    return total_sum_magnitudes * final_prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    const int N = arr.size();\n\n    svint32_t v_total_mag_sum = svdup_s32(0);\n    svint32_t v_total_sign_prod = svdup_s32(1);\n\n    for (int i = 0; i < N; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svint32_t v_val = svld1_s32(pg, &arr[i]);\n\n        svint32_t v_mag = svabs_s32(v_val);\n        v_total_mag_sum = svadd_s32_m(pg, v_total_mag_sum, v_mag);\n\n        svbool_t pg_gt = svcmpgt_s32(pg, v_val, 0);\n        svbool_t pg_lt = svcmplt_s32(pg, v_val, 0);\n\n        svint32_t v_one = svdup_s32(1);\n        svint32_t v_zero = svdup_s32(0);\n\n        svint32_t v_sign_pos = svsel_s32(pg_gt, v_one, v_zero);\n        svint32_t v_sign_neg = svsel_s32(pg_lt, v_one, v_zero);\n\n        svint32_t v_current_sign = svsub_s32(v_sign_pos, v_sign_neg);\n\n        v_total_sign_prod = svmul_s32_m(pg, v_total_sign_prod, v_current_sign);\n    }\n\n    int final_mag_sum = svaddv_s32(svptrue_b32(), v_total_mag_sum);\n    int final_sign_prod = svmulv_s32(svptrue_b32(), v_total_sign_prod);\n\n    return final_mag_sum * final_sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Initialize SVE accumulators for sum of magnitudes and product of signs.\n    // total_sum_magnitudes accumulates the sum of absolute values.\n    svint32_t total_sum_magnitudes = svdup_s32(0);\n    // total_product_signs accumulates the product of signs (1, -1, or 0).\n    // Initialize with 1, the multiplicative identity.\n    svint32_t total_product_signs = svdup_s32(1);\n\n    const int* data = arr.data();\n    long count = arr.size();\n    long i = 0;\n\n    // Loop through the array using SVE vector operations.\n    // svwhilelt_b32 generates a predicate for the remaining elements,\n    // handling full vectors and the partial tail vector.\n    while (i < count) {\n        // Get a predicate for the current vector length.\n        // This predicate ensures operations only apply to valid elements.\n        svbool_t pg = svwhilelt_b32(i, count);\n\n        // Load the current vector of integers from the array.\n        svint32_t current_vec = svld1_s32(pg, &data[i]);\n\n        // 1. Calculate and accumulate magnitudes.\n        // Compute absolute values for elements in current_vec.\n        svint32_t abs_vec = svabs_s32(current_vec);\n        // Add absolute values to the total sum of magnitudes accumulator.\n        total_sum_magnitudes = svadd_s32(total_sum_magnitudes, abs_vec);\n\n        // 2. Calculate and accumulate product of signs.\n        // Determine predicates for elements equal to 0 and less than 0.\n        svbool_t pg_eq0 = svcmpeq_s32(pg, current_vec, 0);  // Predicate for elements equal to 0\n        svbool_t pg_lt0 = svcmplt_s32(pg, current_vec, 0);  // Predicate for elements less than 0\n\n        // Initialize a vector for signs: default to 1.\n        svint32_t signs_vec = svdup_s32(1);\n        // If an element is negative, set its sign to -1.\n        signs_vec = svsel_s32(pg_lt0, svdup_s32(-1), signs_vec);\n        // If an element is zero, set its sign to 0. This takes precedence over negative.\n        // If any element is 0, the corresponding lane in signs_vec will be 0,\n        // causing the total_product_signs to become 0 in that lane, and\n        // subsequent multiplications will propagate the 0, which is correct.\n        signs_vec = svsel_s32(pg_eq0, svdup_s32(0), signs_vec);\n\n        // Multiply the current vector of signs into the total product of signs accumulator.\n        total_product_signs = svmul_s32(total_product_signs, signs_vec);\n\n        // Advance the loop counter by the current vector length (VL).\n        // svcntw() returns the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n    }\n\n    // Perform horizontal reduction to get scalar results.\n    // svptrue_b32() creates a predicate where all lanes are true,\n    // ensuring the reduction operates on all lanes of the accumulator.\n    \n    // Sum all elements in total_sum_magnitudes.\n    int final_sum_magnitudes = svaddv_s32(svptrue_b32(), total_sum_magnitudes);\n    // Multiply all elements in total_product_signs.\n    int final_product_signs = svmulv_s32(svptrue_b32(), total_product_signs);\n\n    // Return the final result: sum of magnitudes multiplied by product of signs.\n    return final_sum_magnitudes * final_product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    // Handle the empty array case as specified.\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    // Initialize scalar accumulators.\n    // Use long long for total_sum_magnitudes to prevent potential overflow\n    // if the sum of absolute values exceeds the maximum value of an int.\n    // The final result is cast back to int as per the function signature.\n    long long total_sum_magnitudes = 0;\n\n    // total_num_negatives will store the count of negative numbers.\n    int total_num_negatives = 0;\n\n    // has_zero_flag will be true if any zero is encountered in the array.\n    bool has_zero_flag = false;\n\n    // Get the number of 32-bit elements in an SVE vector. This is dynamic.\n    const size_t VEC_LEN = svcntw();\n    const size_t arr_size = arr.size();\n\n    // Loop through the array in chunks of VEC_LEN.\n    for (size_t i = 0; i < arr_size; i += VEC_LEN) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b32 generates a predicate that is true for elements\n        // from 'i' up to 'arr_size - 1', and false otherwise.\n        svbool_t pg = svwhilelt_b32(i, arr_size);\n\n        // Load a vector of integers from the array using the predicate.\n        // Only active lanes (where pg is true) will load data.\n        svint32_t current_vec = svld1(pg, &arr[i]);\n\n        // 1. Calculate sum of magnitudes:\n        // Compute absolute values of active elements in current_vec.\n        svint32_t abs_vec = svabs_s32(pg, current_vec);\n        // Horizontally sum the active absolute values and add to the scalar accumulator.\n        // Note: svaddv_s32 returns int, so we add it to long long.\n        total_sum_magnitudes += svaddv_s32(pg, abs_vec);\n\n        // 2. Check for zeros and count negatives for product of signs:\n        // Predicate for elements equal to 0.\n        svbool_t pg_eq_0 = svcmpeq(pg, current_vec, svdup_s32(0));\n        // If any active element is 0, set the has_zero_flag.\n        if (svptest_any(pg, pg_eq_0)) {\n            has_zero_flag = true;\n        }\n\n        // Predicate for elements less than 0.\n        svbool_t pg_lt_0 = svcmplt(pg, current_vec, svdup_s32(0));\n        // Count the number of active negative elements and add to the scalar accumulator.\n        total_num_negatives += svcnt_b32(pg, pg_lt_0);\n    }\n\n    // Calculate the final product of signs.\n    int final_prod_signs;\n    if (has_zero_flag) {\n        // If any zero was found, the product of signs is 0.\n        final_prod_signs = 0;\n    } else {\n        // If no zero was found, the product of signs depends on the parity of negative numbers.\n        if (total_num_negatives % 2 == 0) {\n            // Even number of negatives means product is 1.\n            final_prod_signs = 1;\n        } else {\n            // Odd number of negatives means product is -1.\n            final_prod_signs = -1;\n        }\n    }\n\n    // Return the sum of magnitudes multiplied by the product of signs.\n    // Cast the result to int as per the function signature.\n    return static_cast<int>(total_sum_magnitudes * final_prod_signs);\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstruct NeighborInfo {\n    int value;\n    int r;\n    int c;\n};\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result_path;\n\n    if (k == 0) {\n        return result_path;\n    }\n\n    svint32_t overall_min_vec = svdup_s32(std::numeric_limits<int>::max());\n    int min_val_overall;\n\n    int svl = svcntw();\n\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; c += svl) {\n            svbool_t pg = svwhilelt_b32(c, N);\n            if (!svptest_any(svptrue_b32(), pg)) {\n                break;\n            }\n            svint32_t row_values = svld1_s32(pg, &grid[r][c]);\n            overall_min_vec = svmin_s32(pg, overall_min_vec, row_values);\n        }\n    }\n    min_val_overall = svminv_s32(svptrue_b32(), overall_min_vec);\n\n    int current_r = -1;\n    int current_c = -1;\n    bool found_start = false;\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            if (grid[r][c] == min_val_overall) {\n                current_r = r;\n                current_c = c;\n                found_start = true;\n                break;\n            }\n        }\n        if (found_start) {\n            break;\n        }\n    }\n\n    result_path.push_back(grid[current_r][current_c]);\n\n    for (int i = 1; i < k; ++i) {\n        NeighborInfo neighbors_data[4];\n        int num_neighbors = 0;\n\n        if (current_r > 0) {\n            neighbors_data[num_neighbors] = {grid[current_r-1][current_c], current_r-1, current_c};\n            num_neighbors++;\n        }\n        if (current_r < N-1) {\n            neighbors_data[num_neighbors] = {grid[current_r+1][current_c], current_r+1, current_c};\n            num_neighbors++;\n        }\n        if (current_c > 0) {\n            neighbors_data[num_neighbors] = {grid[current_r][current_c-1], current_r, current_c-1};\n            num_neighbors++;\n        }\n        if (current_c < N-1) {\n            neighbors_data[num_neighbors] = {grid[current_r][current_c+1], current_r, current_c+1};\n            num_neighbors++;\n        }\n        \n        svint32_t current_neighbor_values_vec = svdup_s32(std::numeric_limits<int>::max());\n        svint32_t neighbor_indices_vec = svdup_s32(std::numeric_limits<int>::max());\n\n        for (int j = 0; j < num_neighbors; ++j) {\n            current_neighbor_values_vec = svset_s32(current_neighbor_values_vec, j, neighbors_data[j].value);\n            neighbor_indices_vec = svset_s32(neighbor_indices_vec, j, j);\n        }\n        \n        svbool_t pg_neighbors = svwhilelt_b32(0, num_neighbors);\n        \n        int next_val = svminv_s32(pg_neighbors, current_neighbor_values_vec);\n\n        svbool_t eq_mask = svcmpeq_s32(pg_neighbors, current_neighbor_values_vec, svdup_s32(next_val));\n        \n        svint32_t selected_indices_for_min = svdup_s32(std::numeric_limits<int>::max());\n        selected_indices_for_min = svsel_s32(eq_mask, neighbor_indices_vec, selected_indices_for_min);\n\n        int next_idx_in_neighbors_array = svminv_s32(svptrue_b32(), selected_indices_for_min);\n\n        current_r = neighbors_data[next_idx_in_neighbors_array].r;\n        current_c = neighbors_data[next_idx_in_neighbors_array].c;\n        result_path.push_back(grid[current_r][current_c]);\n    }\n\n    return result_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <vector>\n#include <algorithm> // For std::min, std::fill, etc. (though not strictly needed with SVE helpers)\n#include <limits>    // For std::numeric_limits (though max_val is custom)\n\n#include <arm_sve.h>\n\n// Helper function to compare two paths lexicographically using SVE\n// Returns true if path_A is lexicographically less than path_B\n// Assumes path_A_ptr and path_B_ptr point to arrays of at least current_len integers.\nbool is_lex_less_sve(const int* path_A_ptr, const int* path_B_ptr, int current_len) {\n    int i = 0;\n    // Predicate for active lanes, starting from 0 up to current_len\n    svbool_t pg = svwhilelt_b32(0, current_len);\n\n    while (svptest_any(pg, pg)) {\n        // Load vector chunks from both paths\n        svint32_t vec_A = svld1_s32(pg, &path_A_ptr[i]);\n        svint32_t vec_B = svld1_s32(pg, &path_B_ptr[i]);\n\n        // Compare elements: A < B\n        svbool_t lt_mask = svcmplt_s32(pg, vec_A, vec_B);\n        // Compare elements: A > B\n        svbool_t gt_mask = svcmpgt_s32(pg, vec_A, vec_B);\n\n        // If any element in A is less than corresponding in B\n        if (svptest_any(pg, lt_mask)) {\n            return true;\n        }\n        // If any element in A is greater than corresponding in B\n        if (svptest_any(pg, gt_mask)) {\n            return false;\n        }\n        // If all elements in this chunk are equal, move to the next chunk\n        i += svcntw(); // Advance index by the number of elements in a vector\n        pg = svwhilelt_b32(i, current_len); // Update predicate for the next chunk\n    }\n    return false; // Paths are equal up to current_len elements\n}\n\n// Helper function to copy a path using SVE\n// Assumes dest_ptr points to an array of at least current_len integers.\n// Assumes src_ptr points to an array of at least current_len integers.\nvoid copy_path_sve(int* dest_ptr, const int* src_ptr, int current_len) {\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(0, current_len);\n\n    while (svptest_any(pg, pg)) {\n        svint32_t vec_src = svld1_s32(pg, &src_ptr[i]);\n        svst1_s32(pg, &dest_ptr[i], vec_src);\n        i += svcntw();\n        pg = svwhilelt_b32(i, current_len);\n    }\n}\n\n// Helper function to fill a path with a value using SVE\nvoid fill_path_sve(int* dest_ptr, int value, int current_len) {\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(0, current_len);\n    svint32_t fill_val = svdup_s32(value);\n\n    while (svptest_any(pg, pg)) {\n        svst1_s32(pg, &dest_ptr[i], fill_val);\n        i += svcntw();\n        pg = svwhilelt_b32(i, current_len);\n    }\n}\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    int max_grid_val = N * N;\n    int infinity_val = max_grid_val + 1; // A value larger than any possible grid value\n\n    // min_path_at_len[r][c] stores the lexicographically smallest path of length 'l' ending at (r,c)\n    // We pre-allocate all vectors to size k to avoid reallocations and allow direct pointer access.\n    std::vector<std::vector<std::vector<int>>> min_path_at_len(N, std::vector<std::vector<int>>(N, std::vector<int>(k)));\n    std::vector<std::vector<std::vector<int>>> next_min_path_at_len(N, std::vector<std::vector<int>>(N, std::vector<int>(k)));\n\n    // Buffer to construct candidate paths before comparison/copy. Re-used to avoid repeated allocations.\n    std::vector<int> candidate_path_buffer(k);\n\n    // Stores the overall lexicographically smallest path of length k found so far\n    std::vector<int> overall_min_path(k);\n    fill_path_sve(overall_min_path.data(), infinity_val, k); // Initialize with \"infinity\" values\n\n    // Directions for neighbors: up, down, left, right\n    int dr[] = {-1, 1, 0, 0};\n    int dc[] = {0, 0, -1, 1};\n\n    // Initialize for paths of length 1\n    // For l=1, the path is just the cell's value.\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            min_path_at_len[r][c][0] = grid[r][c];\n        }\n    }\n\n    // Dynamic programming loop for path length l from 1 to k\n    for (int l = 1; l <= k; ++l) {\n        // For l=1, min_path_at_len is already initialized.\n        // For l > 1, min_path_at_len holds paths of length l-1.\n        // We compute next_min_path_at_len for paths of length l.\n\n        // Initialize next_min_path_at_len with \"infinity\" paths for current length l\n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                fill_path_sve(next_min_path_at_len[r][c].data(), infinity_val, l);\n            }\n        }\n\n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                // Current cell (r, c) will be the last cell in the path of length l.\n                // Its value is grid[r][c].\n                // The path of length l-1 must end at a neighbor (pr, pc).\n\n                // Iterate over neighbors (pr, pc)\n                for (int i = 0; i < 4; ++i) {\n                    int pr = r + dr[i];\n                    int pc = c + dc[i];\n\n                    // Check if neighbor is within grid bounds\n                    if (pr >= 0 && pr < N && pc >= 0 && pc < N) {\n                        // Construct candidate path: min_path_at_len[pr][pc] + {grid[r][c]}\n                        // This path has length l.\n                        // The first l-1 elements are from min_path_at_len[pr][pc].\n                        // The l-th element is grid[r][c].\n\n                        // Copy first l-1 elements from min_path_at_len[pr][pc] to candidate_path_buffer\n                        if (l > 1) { // Only copy if path length is greater than 1\n                            copy_path_sve(candidate_path_buffer.data(), min_path_at_len[pr][pc].data(), l - 1);\n                        }\n                        // Append the current cell's value\n                        candidate_path_buffer[l - 1] = grid[r][c];\n\n                        // Compare with current best for (r, c) at length l\n                        // next_min_path_at_len[r][c] currently holds the best path of length l ending at (r,c)\n                        if (is_lex_less_sve(candidate_path_buffer.data(), next_min_path_at_len[r][c].data(), l)) {\n                            copy_path_sve(next_min_path_at_len[r][c].data(), candidate_path_buffer.data(), l);\n                        }\n                    }\n                }\n            }\n        }\n\n        // After computing all next_min_path_at_len for length l, update min_path_at_len\n        // and overall_min_path.\n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                // Copy the newly computed best paths of length l to min_path_at_len\n                copy_path_sve(min_path_at_len[r][c].data(), next_min_path_at_len[r][c].data(), l);\n\n                // If this is the final length k, update overall_min_path\n                if (l == k) {\n                    if (is_lex_less_sve(min_path_at_len[r][c].data(), overall_min_path.data(), k)) {\n                        copy_path_sve(overall_min_path.data(), min_path_at_len[r][c].data(), k);\n                    }\n                }\n            }\n        }\n    }\n\n    return overall_min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> flat_grid(N * N);\n    int curr_r = -1, curr_c = -1;\n\n    // Flatten the 2D grid into a 1D vector for efficient SVE gather loads\n    // Also, find the starting position (cell containing value 1)\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            flat_grid[r * N + c] = grid[r][c];\n            if (grid[r][c] == 1) {\n                curr_r = r;\n                curr_c = c;\n            }\n        }\n    }\n\n    std::vector<int> min_path_values(k);\n    min_path_values[0] = 1; // The first element of the path is always 1\n\n    // Pre-define neighbor offsets for rows and columns.\n    // These are constant and can be loaded into SVE vectors once per iteration.\n    int dr_arr[] = {-1, 1, 0, 0}; // Up, Down, Stay, Stay\n    int dc_arr[] = {0, 0, -1, 1}; // Stay, Stay, Left, Right\n\n    // Main loop to build the path of length k\n    for (int i = 1; i < k; ++i) {\n        // Load neighbor offsets into SVE vectors.\n        // svptrue_b32() creates a predicate where all lanes are active.\n        svint32_t dr_vec = svld1_s32(svptrue_b32(), dr_arr);\n        svint32_t dc_vec = svld1_s32(svptrue_b32(), dc_arr);\n\n        // Broadcast current row, current column, and grid dimension N into SVE vectors.\n        svint32_t curr_r_bcast = svdup_s32(curr_r);\n        svint32_t curr_c_bcast = svdup_s32(curr_c);\n        svint32_t N_bcast = svdup_s32(N);\n\n        // Calculate potential neighbor coordinates (nr, nc) using vector addition.\n        svint32_t nr_vec = svadd_s32_x(svptrue_b32(), curr_r_bcast, dr_vec);\n        svint32_t nc_vec = svadd_s32_x(svptrue_b32(), curr_c_bcast, dc_vec);\n\n        // Check bounds for each potential neighbor using SVE comparisons.\n        // A neighbor (nr, nc) is valid if 0 <= nr < N and 0 <= nc < N.\n        svbool_t pg_valid_r = svand_b(svcmpge_s32(svptrue_b32(), nr_vec, svdup_s32(0)), svcmplt_s32(svptrue_b32(), nr_vec, N_bcast));\n        svbool_t pg_valid_c = svand_b(svcmpge_s32(svptrue_b32(), nc_vec, svdup_s32(0)), svcmplt_s32(svptrue_b32(), nc_vec, N_bcast));\n        svbool_t pg_valid_neighbor = svand_b(pg_valid_r, pg_valid_c);\n\n        // Calculate 1D indices for valid neighbors: index = r * N + c.\n        // This is done using vector multiplication and addition.\n        svint32_t indices = svadd_s32_x(svptrue_b32(), svmul_s32_x(svptrue_b32(), nr_vec, N_bcast), nc_vec);\n\n        // Gather neighbor values from the flat_grid using the calculated indices.\n        // The `pg_valid_neighbor` predicate ensures that only values from valid\n        // coordinates are loaded. For invalid lanes, the loaded value is undefined.\n        svint32_t neighbor_values = svld1_gather_s32index(pg_valid_neighbor, flat_grid.data(), indices);\n        \n        // For invalid lanes (where pg_valid_neighbor is false), set their values\n        // to a very large number (max int) so they are ignored when finding the minimum.\n        neighbor_values = svsel_s32(pg_valid_neighbor, neighbor_values, svdup_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value among the valid neighbors using a horizontal minimum reduction.\n        int min_neighbor_val_sve = svmin_s32_x(svptrue_b32(), neighbor_values);\n\n        // Find the index (0-3) of the neighbor that holds this minimum value.\n        // Since all grid values are unique, there will be exactly one such neighbor.\n        svbool_t pg_min_found = svcmpeq_s32(svptrue_b32(), neighbor_values, svdup_s32(min_neighbor_val_sve));\n        \n        int min_idx = -1;\n        // Iterate through the first 4 lanes (corresponding to the 4 neighbors)\n        // to find which one contains the minimum value.\n        // svq_b32 extracts the boolean value of a specific lane from a predicate.\n        for (int lane = 0; lane < 4; ++lane) {\n            if (svq_b32(pg_min_found, lane)) {\n                min_idx = lane;\n                break;\n            }\n        }\n\n        // Update current position (curr_r, curr_c) to the coordinates of the chosen neighbor.\n        // svq_s32 extracts the integer value of a specific lane from an SVE vector.\n        curr_r = svq_s32(nr_vec, min_idx);\n        curr_c = svq_s32(nc_vec, min_idx);\n\n        // Store the minimum value found in the path.\n        min_path_values[i] = min_neighbor_val_sve;\n    }\n\n    return min_path_values;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <queue>\n#include <limits> // For std::numeric_limits\n\n// Helper function to compare two paths lexicographically using SVE\n// Returns true if path_a is lexicographically smaller than path_b\n// Assumes path_a and path_b have the same length 'k'\nstatic bool is_path_smaller_sve(const std::vector<int>& path_a, const std::vector<int>& path_b, int k) {\n    int i = 0;\n    while (i < k) {\n        // Create a predicate for the current vector chunk, ensuring we don't go past 'k'\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // Load elements from path_a and path_b into SVE vectors\n        svint32_t va = svld1_s32(pg, &path_a[i]);\n        svint32_t vb = svld1_s32(pg, &path_b[i]);\n\n        // Compare va and vb element-wise\n        svbool_t lt_mask = svcmplt_s32(pg, va, vb); // va < vb\n        svbool_t gt_mask = svcmpgt_s32(pg, va, vb); // va > vb\n\n        // Check if any active element in this chunk makes path_a smaller\n        if (svptest_any(pg, lt_mask)) {\n            return true; // path_a is smaller\n        }\n\n        // Check if any active element in this chunk makes path_b smaller\n        if (svptest_any(pg, gt_mask)) {\n            return false; // path_b is smaller\n        }\n\n        // If we reach here, all active elements in this chunk are equal.\n        // Move to the next chunk.\n        i += svcntw(); // Advance by the current vector length\n    }\n    return false; // Paths are equal (or path_a is not strictly smaller)\n}\n\n// Struct to represent a path state for the priority queue\nstruct PathState {\n    std::vector<int> values; // The sequence of values in the path\n    int r, c;                 // Current cell coordinates (row, column)\n\n    // Custom comparison for priority queue (min-heap behavior)\n    // std::priority_queue is a max-heap by default, so we overload operator>\n    // to make it behave like a min-heap for lexicographical comparison.\n    // A path is \"greater\" if it is lexicographically larger.\n    bool operator>(const PathState& other) const {\n        return is_path_smaller_sve(other.values, this->values, this->values.size());\n    }\n};\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n\n    // Initialize min_path_found with a path of 'k' maximum integer values.\n    // This serves as an initial \"worst\" path to be easily beaten.\n    std::vector<int> min_path_found(k, std::numeric_limits<int>::max());\n\n    // A sentinel path used for initializing the 'dist' table.\n    std::vector<int> sentinel_path(k, std::numeric_limits<int>::max());\n\n    // 'dist[r][c][len]' stores the lexicographically smallest path of length 'len'\n    // found so far, ending at cell (r, c).\n    // This table is crucial for pruning the search space in Dijkstra's algorithm.\n    std::vector<std::vector<std::vector<std::vector<int>>>> dist(\n        N, std::vector<std::vector<std::vector<int>>>(\n            N, std::vector<std::vector<int>>(\n                k + 1, sentinel_path\n            )\n        )\n    );\n\n    // Priority queue to store PathState objects, ordered by their lexicographical path values.\n    std::priority_queue<PathState, std::vector<PathState>, std::greater<PathState>> pq;\n\n    // Initialize the priority queue with all possible starting cells (paths of length 1).\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            PathState initial_state;\n            initial_state.values.push_back(grid[r][c]); // Path starts with the cell's value\n            initial_state.r = r;\n            initial_state.c = c;\n\n            pq.push(initial_state);\n            dist[r][c][1] = initial_state.values; // Update the best path for length 1\n        }\n    }\n\n    // Define directions for moving to neighbor cells (Up, Down, Left, Right)\n    int dr[] = {-1, 1, 0, 0}; // Row offsets\n    int dc[] = {0, 0, -1, 1}; // Column offsets\n\n    // Dijkstra's algorithm main loop\n    while (!pq.empty()) {\n        PathState current = pq.top();\n        pq.pop();\n\n        int current_len = current.values.size();\n\n        // Pruning step: If we have already found a lexicographically smaller path\n        // to this cell with the same length, skip processing this path.\n        if (is_path_smaller_sve(dist[current.r][current.c][current_len], current.values, current_len)) {\n            continue;\n        }\n\n        // If the current path has reached the desired length 'k'\n        if (current_len == k) {\n            // Compare it with the overall minimum path found so far.\n            // If this path is smaller, update min_path_found.\n            if (is_path_smaller_sve(current.values, min_path_found, k)) {\n                min_path_found = current.values;\n            }\n            continue; // Paths of length 'k' are terminal, no need to extend further.\n        }\n\n        // Extend the current path to its neighbors\n        for (int i = 0; i < 4; ++i) {\n            int nr = current.r + dr[i];\n            int nc = current.c + dc[i];\n\n            // Check if the neighbor cell is within grid boundaries\n            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                PathState next_state;\n                next_state.values = current.values; // Copy the current path values\n                next_state.values.push_back(grid[nr][nc]); // Append the neighbor's value\n                next_state.r = nr;\n                next_state.c = nc;\n\n                int next_len = current_len + 1;\n\n                // If this new path is lexicographically smaller than the best path\n                // found so far for (nr, nc) with length 'next_len', update and push to PQ.\n                if (is_path_smaller_sve(next_state.values, dist[nr][nc][next_len], next_len)) {\n                    dist[nr][nc][next_len] = next_state.values; // Update the best path\n                    pq.push(next_state); // Add the new state to the priority queue\n                }\n            }\n        }\n    }\n\n    return min_path_found;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::min, std::fill, std::swap\n#include <limits>    // For std::numeric_limits\n#include <tuple>     // For std::tuple\n\n// Helper function for lexicographical comparison of paths stored in a flat array.\n// Compares path starting at path1_start_idx with path starting at path2_start_idx.\n// Both paths are of length 'len'.\n// Returns true if path1 < path2.\n// Uses SVE for segment-wise comparison.\nbool is_lex_less_sve(const int* paths_data, int path1_start_idx, int path2_start_idx, int len) {\n    svbool_t pg_all = svptrue_b(); // Predicate for all active lanes\n    svbool_t path_is_less_overall = svfalse_b();\n    svbool_t path_is_equal_overall = svptrue_b(); // Assume equal until proven otherwise\n\n    for (int i = 0; i < len; i += svcntw()) {\n        svbool_t pg_segment = svwhilelt_b32(i, len); // Predicate for current segment length\n\n        // Only process lanes that are still considered equal\n        svbool_t current_pg = svand_b(pg_segment, path_is_equal_overall);\n\n        // If no lanes are active, break early\n        if (svptest_any(pg_all, current_pg) == 0) {\n            break;\n        }\n\n        svint32_t segment1 = svld1_s32(current_pg, paths_data + path1_start_idx + i);\n        svint32_t segment2 = svld1_s32(current_pg, paths_data + path2_start_idx + i);\n\n        svbool_t less_mask_segment = svcmplt_s32(current_pg, segment1, segment2);\n        svbool_t equal_mask_segment = svcmpeq_s32(current_pg, segment1, segment2);\n\n        path_is_less_overall = svorr_b(path_is_less_overall, svand_b(path_is_equal_overall, less_mask_segment));\n        path_is_equal_overall = svand_b(path_is_equal_overall, equal_mask_segment);\n    }\n    \n    return svptest_any(pg_all, path_is_less_overall);\n}\n\n// Directions for neighbors\nconst int DR[] = {-1, 1, 0, 0};\nconst int DC[] = {0, 0, -1, 1};\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    int N_squared = N * N;\n    const int INF_VAL = std::numeric_limits<int>::max();\n\n    // Flatten the grid for SVE gather operations\n    std::vector<int> flat_grid(N_squared);\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            flat_grid[r * N + c] = grid[r][c];\n        }\n    }\n    const int* grid_ptr = flat_grid.data();\n\n    // Path storage: Two buffers to alternate between current and next paths.\n    // Each buffer stores N_squared paths, each of length k.\n    std::vector<int> paths_buffer1(N_squared * k);\n    std::vector<int> paths_buffer2(N_squared * k);\n\n    // Pointers to current and next path buffers\n    int* current_paths_data = paths_buffer1.data();\n    int* next_paths_data = paths_buffer2.data();\n\n    // current_path_exists[r*N+c] is true if a path exists to (r,c) for current length\n    std::vector<bool> current_path_exists(N_squared, false);\n    std::vector<bool> next_path_exists(N_squared, false);\n\n    // If k=1, find the minimum value and return it.\n    if (k == 1) {\n        int min_val = INF_VAL;\n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                min_val = std::min(min_val, grid[r][c]);\n            }\n        }\n        return {min_val};\n    }\n\n    // Initialize for length 1\n    // Each cell (r,c) has path {grid[r][c]}\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            int cell_idx = r * N + c;\n            int path_start_offset = cell_idx * k; // Each cell gets a dedicated slot\n            current_paths_data[path_start_offset] = grid[r][c]; // Store the first value\n            // Fill remaining k-1 elements with INF_VAL for proper lexicographical comparison\n            std::fill(current_paths_data + path_start_offset + 1, current_paths_data + path_start_offset + k, INF_VAL);\n            current_path_exists[cell_idx] = true;\n        }\n    }\n\n    // Main loop for path length from 2 to k\n    for (int len = 2; len <= k; ++len) {\n        // Initialize next_paths_data with INF_VALs and next_path_exists to false\n        std::fill(next_paths_data, next_paths_data + N_squared * k, INF_VAL);\n        std::fill(next_path_exists.begin(), next_path_exists.end(), false);\n\n        // Iterate over all cells (r,c) that had a path of length (len-1)\n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                int current_cell_idx = r * N + c;\n                int current_path_start_offset = current_cell_idx * k; // Path starts at this offset in current_paths_data\n\n                if (current_path_exists[current_cell_idx]) { // If a path exists to (r,c)\n                    // Explore neighbors\n                    for (int i = 0; i < 4; ++i) {\n                        int nr = r + DR[i];\n                        int nc = c + DC[i];\n\n                        // Check bounds\n                        if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                            int next_cell_idx = nr * N + nc;\n                            \n                            // Create the new candidate path in a temporary buffer\n                            std::vector<int> temp_candidate_path(k);\n                            \n                            // Copy current path (len-1 elements) to temp_candidate_path using SVE\n                            svbool_t pg_temp_copy = svptrue_b();\n                            for (int j = 0; j < len - 1; j += svcntw()) {\n                                svbool_t pg_segment = svwhilelt_b32(j, len - 1);\n                                svint32_t segment_val = svld1_s32(pg_segment, current_paths_data + current_path_start_offset + j);\n                                svst1_s32(pg_segment, temp_candidate_path.data() + j, segment_val);\n                            }\n                            // Append new value\n                            temp_candidate_path[len - 1] = grid[nr][nc];\n                            // Fill remaining elements (if any) with INF_VAL\n                            std::fill(temp_candidate_path.data() + len, temp_candidate_path.data() + k, INF_VAL);\n\n                            // Compare temp_candidate_path with current best path for (nr, nc) in next_paths_data\n                            // The current best path for (nr,nc) is at next_paths_data[next_cell_idx * k]\n                            bool is_better_final = is_lex_less_sve(temp_candidate_path.data(), 0, next_cell_idx * k, len);\n\n                            if (is_better_final) {\n                                // Copy temp_candidate_path to next_paths_data[next_cell_idx * k] using SVE\n                                svbool_t pg_final_copy = svptrue_b();\n                                for (int j = 0; j < k; j += svcntw()) {\n                                    svbool_t pg_segment = svwhilelt_b32(j, k);\n                                    svint32_t segment_val = svld1_s32(pg_segment, temp_candidate_path.data() + j);\n                                    svst1_s32(pg_segment, next_paths_data + next_cell_idx * k, segment_val);\n                                }\n                                next_path_exists[next_cell_idx] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Swap current and next buffers for the next iteration\n        std::swap(current_paths_data, next_paths_data);\n        std::swap(current_path_exists, next_path_exists);\n    }\n\n    // Find the overall minimum path from current_paths_data (which now holds paths of length k)\n    std::vector<int> min_overall_path_values;\n    int min_overall_path_start_offset = -1;\n\n    for (int r_idx = 0; r_idx < N_squared; ++r_idx) {\n        if (current_path_exists[r_idx]) {\n            int path_start_offset = r_idx * k;\n            if (min_overall_path_start_offset == -1 || \n                is_lex_less_sve(current_paths_data, path_start_offset, min_overall_path_start_offset, k)) {\n                min_overall_path_start_offset = path_start_offset;\n            }\n        }\n    }\n\n    // Copy the best path to the result vector\n    if (min_overall_path_start_offset != -1) {\n        min_overall_path_values.resize(k);\n        svbool_t pg_copy_final = svptrue_b();\n        for (int j = 0; j < k; j += svcntw()) {\n            svbool_t pg_segment = svwhilelt_b32(j, k);\n            svint32_t segment_val = svld1_s32(pg_segment, current_paths_data + min_overall_path_start_offset + j);\n            svst1_s32(pg_segment, min_overall_path_values.data() + j, segment_val);\n        }\n    }\n\n    return min_overall_path_values;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n\n    uint8_t digits[20];\n    int num_digits = 0;\n    uint64_t temp_n = n;\n\n    while (temp_n > 0) {\n        digits[num_digits++] = temp_n % 10;\n        temp_n /= 10;\n    }\n\n    uint64_t product = 1;\n    bool has_odd_digit = false;\n\n    size_t vl = svcntb();\n\n    for (int i = 0; i < num_digits; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, num_digits);\n        svuint8_t current_digits = svld1_u8(pg, &digits[i]);\n\n        svuint8_t one_u8 = svdup_u8(1);\n        svbool_t is_odd = svcmpeq_u8(pg, svand_u8(current_digits, one_u8), one_u8);\n\n        if (svptest_any(svptrue_b8(), is_odd)) {\n            has_odd_digit = true;\n\n            uint8_t temp_digits_buffer[vl];\n            svst1_u8(pg, temp_digits_buffer, current_digits);\n\n            for (size_t j = 0; j < vl && (i + j) < num_digits; ++j) {\n                if (temp_digits_buffer[j] % 2 != 0) {\n                    product *= temp_digits_buffer[j];\n                }\n            }\n        }\n    }\n\n    if (!has_odd_digit) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nuint64_t digits_simd(uint64_t n){\n    if (n == 0) {\n        return 0;\n    }\n\n    char s_n[21]; // Max 20 digits for uint64_t + null terminator\n    int len = sprintf(s_n, \"%llu\", n);\n\n    uint64_t total_product = 1;\n    bool found_odd = false;\n\n    // Get the vector length for uint8_t elements (characters)\n    size_t sv_elems_u8 = svcntb();\n\n    // Loop through the string in chunks of vector length\n    for (int i = 0; i < len; i += sv_elems_u8) {\n        // Create a predicate for the current chunk\n        svbool_t pg_u8 = svwhilelt_b8(i, len);\n\n        // Load characters into an SVE vector of uint8_t\n        svuint8_t v_chars = svld1_u8(pg_u8, (const uint8_t*)&s_n[i]);\n\n        // Convert characters to digits (subtract '0')\n        svuint8_t v_digits_u8 = svsub_n_u8(v_chars, '0');\n\n        // Check for oddness: digit % 2 != 0, which is (digit & 1)\n        svuint8_t v_is_odd_u8 = svand_n_u8(v_digits_u8, 1);\n\n        // Create a predicate for odd digits\n        svbool_t p_odd_u8 = svcmpne_n_u8(pg_u8, v_is_odd_u8, 0);\n\n        // Iterate through the lanes of the SVE vector to accumulate the product.\n        // This loop extracts elements processed in parallel by SVE.\n        for (size_t k = 0; k < sv_elems_u8; ++k) {\n            // Check if this lane is active (within the string length)\n            if (svget_lane_b8(pg_u8, k)) {\n                uint8_t digit = svget_lane_u8(v_digits_u8, k);\n                if (digit % 2 != 0) {\n                    total_product *= digit;\n                    found_odd = true;\n                }\n            }\n        }\n    }\n\n    if (!found_odd) {\n        return 0;\n    }\n    return total_product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h> // Required for bool type\n\nuint64_t digits_simd(uint64_t n) {\n    // Handle the case where n is 0. As per the example (digits_simd(4) == 0),\n    // if no odd digits are found, the function should return 0.\n    // For n=0, there are no digits, so 0 is the correct result.\n    if (n == 0) {\n        return 0;\n    }\n\n    // Initialize an SVE vector for product accumulation.\n    // Each lane will accumulate the product of odd digits.\n    // Since the digit is broadcast to all lanes, all lanes will hold the same product.\n    svuint64_t v_product_acc = svdup_u64(1);\n\n    // Initialize an SVE boolean predicate to track if any odd digit has been found.\n    // All lanes start as false.\n    svbool_t pg_found_odd_mask = svdup_b(false);\n\n    // Define constant SVE vectors for common operations outside the loop for efficiency.\n    svuint64_t v_ten = svdup_u64(10);\n    svuint64_t v_two = svdup_u64(2);\n    svuint64_t v_zero = svdup_u64(0);\n\n    // Get the full predicate for 64-bit elements. This predicate is used\n    // when an operation should apply to all active lanes.\n    svbool_t pg_all_active = svptrue_b64();\n\n    // Loop through the digits of n, from least significant to most significant.\n    while (n > 0) {\n        uint64_t digit = n % 10; // Extract the last digit\n\n        // Broadcast the current scalar digit to all lanes of an SVE vector.\n        svuint64_t v_digit = svdup_u64(digit);\n\n        // Check if the digit is odd using SVE intrinsics: (digit % 2) != 0.\n        // 1. Calculate digit % 2 for all lanes.\n        svuint64_t v_mod_two = svmod_u64(pg_all_active, v_digit, v_two);\n        // 2. Compare the result with 0 to get a predicate (mask) indicating oddness.\n        //    If (digit % 2) is not 0, the digit is odd.\n        svbool_t pg_is_odd = svcmpne_u64(pg_all_active, v_mod_two, v_zero);\n\n        // Conditionally multiply the digit into the product accumulator.\n        // For lanes where 'pg_is_odd' is true (i.e., the current digit is odd),\n        // v_product_acc[i] = v_product_acc[i] * v_digit[i].\n        // For lanes where 'pg_is_odd' is false, v_product_acc[i] remains unchanged.\n        v_product_acc = svmul_u64_m(v_product_acc, pg_is_odd, v_product_acc, v_digit);\n\n        // Update the overall 'found_odd' mask.\n        // If the current digit is odd (meaning 'pg_is_odd' is all true, as v_digit is broadcast),\n        // then 'pg_found_odd_mask' will become all true. This ensures we track if any\n        // odd digit was encountered throughout the entire number.\n        pg_found_odd_mask = svorr_b(pg_found_odd_mask, pg_is_odd);\n\n        // Move to the next digit by removing the last one.\n        n /= 10;\n    }\n\n    // After the loop, all active lanes of 'v_product_acc' will hold the final product\n    // of all odd digits found. We can extract the result from any lane (e.g., the first).\n    uint64_t final_product = svget_lane_u64(v_product_acc, 0);\n\n    // Check if any odd digit was found during the entire process.\n    // 'svptest_any' returns true if any bit in the predicate is set to true.\n    bool any_odd_found = svptest_any(pg_all_active, pg_found_odd_mask);\n\n    // Return the calculated product if at least one odd digit was found,\n    // otherwise return 0 as per the problem description.\n    return any_odd_found ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string.h> // For strlen\n#include <stdio.h>  // For sprintf\n#include <stdbool.h> // For bool\n\nuint64_t digits_simd(uint64_t n){\n    if (n == 0) {\n        // As per example, digits_simd(4) == 0.\n        // If n=0, there are no odd digits, so product is 0.\n        return 0;\n    }\n\n    // Convert the uint64_t number to a string of digits.\n    // Max 20 digits for uint64_t (2^64 - 1) + null terminator.\n    char s[21]; \n    sprintf(s, \"%llu\", n);\n    int len = strlen(s);\n\n    uint64_t total_product = 1;\n    bool has_odd_digit = false;\n\n    // Get the vector length for uint8_t elements.\n    // This determines how many digits can be processed in parallel.\n    int vl = svcntb();\n\n    // Process the digits in chunks of 'vl' (vector length).\n    for (int i = 0; i < len; i += vl) {\n        // Create a predicate for the current chunk.\n        // This predicate ensures we only process valid digits within the string length.\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string into an SVE vector.\n        svuint8_t v_chars = svld1_u8(pg, (const uint8_t*)(s + i));\n\n        // Convert character digits to numeric digits (e.g., '0' -> 0, '1' -> 1).\n        // ASCII value of '0' is subtracted from each character.\n        svuint8_t v_digits = svsub_u8(pg, v_chars, svdup_u8('0'));\n\n        // Check for odd digits: a digit is odd if (digit & 1) is not 0.\n        svuint8_t v_odd_check = svand_u8(pg, v_digits, svdup_u8(1));\n        svbool_t pg_odd = svcmpne_u8(pg, v_odd_check, svdup_u8(0));\n\n        // Select odd digits. For even digits, substitute with 1 so they don't affect the product.\n        svuint8_t v_selected_digits = svsel_u8(pg_odd, v_digits, svdup_u8(1));\n\n        // Update the flag if any odd digit was found in this chunk.\n        if (svptest_any(pg, pg_odd)) {\n            has_odd_digit = true;\n        }\n\n        // Perform a horizontal product on v_selected_digits.\n        // SVE does not have a direct integer horizontal product intrinsic (like svmulv_u8).\n        // This is implemented using a reduction tree pattern with svmul_u8 and svperm_u8.\n        svuint8_t v_chunk_product_acc = v_selected_digits;\n\n        // Loop for reduction: repeatedly multiply elements with elements from a shifted part of the vector.\n        // This loop performs log2(vl) steps to reduce the vector to a single product.\n        for (int offset = vl / 2; offset > 0; offset /= 2) {\n            // Generate indices for the elements to be multiplied with.\n            // For example, if offset is 8, indices will be [8, 9, 10, ..., 8+vl-1].\n            svuint8_t indices = svindex_u8(offset, 1);\n\n            // Create a predicate for the active lanes in this reduction step.\n            // Only the first 'vl - offset' elements will have a partner to multiply with.\n            svbool_t mul_pg = svwhilelt_b8(0, vl - offset);\n\n            // Multiply the current accumulator with elements from the shifted part of the vector.\n            // svperm_u8 fetches elements based on 'indices'.\n            // The 'mul_pg' predicate ensures that only relevant lanes are updated.\n            v_chunk_product_acc = svmul_u8(mul_pg, v_chunk_product_acc, svperm_u8(mul_pg, v_chunk_product_acc, indices));\n        }\n\n        // The final product for this chunk is now in the first element (index 0) of the accumulator vector.\n        // Extract this scalar value and multiply it into the total product.\n        total_product *= svget_u8(v_chunk_product_acc, 0);\n    }\n\n    // Return the total product if at least one odd digit was found, otherwise return 0.\n    return has_odd_digit ? total_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h> // Required for memset if used, but not strictly needed here.\n\nuint64_t digits_simd(uint64_t n) {\n    // Handle special case for n=0. The digit 0 is even, so the product of odd digits is 0.\n    if (n == 0) {\n        return 0;\n    }\n\n    // A uint64_t can have at most 20 decimal digits (e.g., 2^64-1 is 18,446,744,073,709,551,615, which has 20 digits).\n    uint8_t digits[20];\n    int num_digits = 0;\n\n    // Extract digits serially. This part is inherently serial and cannot be easily vectorized with SVE.\n    // Digits are stored in reverse order (e.g., for 235, digits = [5, 3, 2]).\n    uint64_t temp_n = n;\n    while (temp_n > 0) {\n        digits[num_digits++] = temp_n % 10;\n        temp_n /= 10;\n    }\n\n    uint64_t product = 1;\n    bool found_odd = false;\n\n    // Get the SVE vector length for byte elements. This determines how many digits are processed in parallel.\n    size_t vl_bytes = svcntb();\n\n    // Loop through the digits array in chunks of VL (vector length).\n    for (int i = 0; i < num_digits; i += vl_bytes) {\n        // Create a predicate for the current chunk. This handles full vectors and partial vectors at the end\n        // by ensuring operations only apply to valid elements within the bounds of `num_digits`.\n        svbool_t current_pg = svwhilelt_b_u64(i, num_digits);\n\n        // Load a vector of digits from the array using the current predicate.\n        // Elements outside the active predicate are not loaded/modified.\n        svuint8_t current_digits = svld1_u8(current_pg, &digits[i]);\n\n        // Check if each digit in the vector is odd.\n        // A digit 'd' is odd if (d & 1) == 1.\n        svuint8_t one = svdup_u8(1);\n        svbool_t is_odd = svcmpeq(current_pg, svand_u8(current_digits, one), one);\n\n        // If any odd digit is found in this chunk, update 'found_odd'.\n        // svptest_any checks if any active lane in the predicate is true.\n        // We use svptrue_b() as the governing predicate for svptest_any because 'is_odd' itself is already\n        // masked by 'current_pg', so we just need to check if any bit is set in 'is_odd'.\n        if (svptest_any(svptrue_b(), is_odd)) {\n            found_odd = true;\n        }\n\n        // Prepare digits for multiplication: replace even digits with 1.\n        // This ensures that even digits do not affect the product when multiplied.\n        // The selection is done in parallel for all active lanes.\n        svuint8_t masked_digits = svsel_u8(is_odd, current_digits, svdup_u8(1));\n\n        // Accumulate the product.\n        // SVE does not have a direct horizontal product reduction intrinsic.\n        // Therefore, we iterate through the active lanes of the vector and multiply them into the scalar product.\n        // While this loop is serial for the reduction, the preceding operations (loading, masking, conditional selection)\n        // are performed in parallel using SVE intrinsics.\n        for (size_t j = 0; j < vl_bytes; ++j) {\n            // Check if this lane is active based on the current predicate.\n            if (svptest_b(current_pg, j)) {\n                product *= svget_lane_u8(masked_digits, j);\n            }\n        }\n    }\n\n    // If no odd digits were found throughout the process, return 0 as per the problem description.\n    // Otherwise, return the calculated product.\n    if (!found_odd) {\n        return 0;\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint> // For uint64_t\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t N = lst.size();\n    size_t i = 0;\n\n    // Get the number of 32-bit elements per SVE vector\n    // This is equivalent to svcntw() but can be used in loop increment\n    // and for predicate generation.\n    // For float (32-bit), svcntw() is appropriate.\n    const size_t sv_elements = svcntw();\n\n    for (i = 0; i < N; i += sv_elements) {\n        // Create a predicate for the current chunk of data\n        // This handles the tail end of the vector where N is not a multiple of sv_elements\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load float values from the input vector\n        svfloat32_t vec_f32 = svld1_f32(pg, &lst[i]);\n\n        // Apply ceiling operation to each float element\n        svfloat32_t vec_ceil_f32 = svceil_f32(vec_f32);\n\n        // Convert the ceilinged float values to 64-bit integers\n        svint64_t vec_s64 = svcvt_s64_f32(vec_ceil_f32);\n\n        // Square each 64-bit integer element\n        svint64_t vec_sq_s64 = svmul_s64(vec_s64, vec_s64);\n\n        // Horizontally sum the squared 64-bit integer elements in the vector\n        // and add to the total sum.\n        // The predicate 'pg' ensures only active elements are summed.\n        total_sum += svaddv_s64(pg, vec_sq_s64);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    // Get the number of float elements that fit in an SVE vector.\n    // This determines the loop stride.\n    size_t sv_float_count = svcnt_f32();\n\n    // Process the vector in full SVE chunks\n    for (i = 0; i + sv_float_count <= n; i += sv_float_count) {\n        // Create a full predicate for 32-bit elements (float)\n        svbool_t pg_f32 = svptrue_b32();\n\n        // Load float values into an SVE vector\n        svfloat32_t vec_f32 = svld1(pg_f32, &lst[i]);\n\n        // Apply ceiling to each float element\n        svfloat32_t vec_ceil_f32 = svceil_f32(pg_f32, vec_f32);\n\n        // Convert the ceiled float values to signed 64-bit integers.\n        // This intrinsic converts each active 32-bit element to a 64-bit element.\n        svint64_t vec_s64 = svcvt_s64_f32(pg_f32, vec_ceil_f32);\n\n        // Square the 64-bit integer values\n        svint64_t vec_sq_s64 = svmul_s64(pg_f32, vec_s64, vec_s64);\n\n        // Convert the 32-bit predicate to a 64-bit predicate for the reduction operation.\n        // This is necessary because svaddv_u64 operates on 64-bit elements.\n        svbool_t pg_u64 = svcvt_b64_b32(pg_f32);\n\n        // Perform horizontal sum of the squared values within the vector.\n        // Reinterpret svint64_t as svuint64_t for svaddv_u64, which is safe as squared values are non-negative.\n        uint64_t segment_sum = svaddv_u64(pg_u64, svreinterpret_u64(vec_sq_s64));\n        \n        // Accumulate to the total sum\n        total_sum += segment_sum;\n    }\n\n    // Handle any remaining elements (tail processing)\n    if (i < n) {\n        // Create a predicate for the remaining 32-bit elements\n        svbool_t pg_f32 = svwhilelt_b32(i, n);\n\n        // Load remaining float values\n        svfloat32_t vec_f32 = svld1(pg_f32, &lst[i]);\n\n        // Apply ceiling\n        svfloat32_t vec_ceil_f32 = svceil_f32(pg_f32, vec_f32);\n\n        // Convert to signed 64-bit integers\n        svint64_t vec_s64 = svcvt_s64_f32(pg_f32, vec_ceil_f32);\n\n        // Square the 64-bit integer values\n        svint64_t vec_sq_s64 = svmul_s64(pg_f32, vec_s64, vec_s64);\n\n        // Convert the 32-bit predicate to a 64-bit predicate for reduction\n        svbool_t pg_u64 = svcvt_b64_b32(pg_f32);\n\n        // Perform horizontal sum and accumulate\n        uint64_t segment_sum = svaddv_u64(pg_u64, svreinterpret_u64(vec_sq_s64));\n        total_sum += segment_sum;\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // Required for std::ceil in general, though SVE intrinsic svceil_f32 is used.\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Get the number of 32-bit elements (floats or int32_t) that fit in an SVE vector.\n    // This is equivalent to VL / 32 bits, or VL / sizeof(float).\n    const size_t sv_float_count = svcntw(); \n\n    // Initialize the predicate for the first chunk of elements.\n    // svwhilelt_b32 generates a predicate where elements at index 'k' are true if k < n.\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    // Loop while there are any active elements in the predicate (i.e., not all elements processed).\n    while (svptest_any(svptrue_b32(), pg)) {\n        // 1. Load float values from the input list into an SVE vector.\n        // Elements corresponding to false predicate lanes will be loaded as 0.0f.\n        svfloat32_t vec_f32 = svld1_f32(pg, &lst[i]);\n\n        // 2. Apply the ceiling operation to each active element.\n        // Inactive elements (0.0f) remain 0.0f.\n        svfloat32_t vec_f32_ceiled = svceil_f32(pg, vec_f32);\n\n        // 3. Convert the ceiled float values to signed 32-bit integers.\n        // Inactive elements (0.0f) convert to 0.\n        svint32_t vec_s32 = svcvt_s32_f32(pg, vec_f32_ceiled);\n\n        // 4. Widen the 32-bit integers to 64-bit integers before squaring.\n        // This is crucial to prevent potential overflow if the squared values exceed the range of int32_t.\n        // svunpklo_s32 unpacks the lower half of the svint32_t vector into an svint64_t vector,\n        // sign-extending each 32-bit element to 64-bit.\n        // svunpkhi_s32 unpacks the upper half similarly.\n        // These intrinsics do not take a predicate; they operate on the entire input vector.\n        // Since inactive elements in vec_s32 are 0, they will be unpacked as 0LL.\n        svint64_t vec_s64_lo = svunpklo_s32(vec_s32);\n        svint64_t vec_s64_hi = svunpkhi_s32(vec_s32);\n\n        // 5. Square the 64-bit integer elements.\n        // We use svptrue_b64() as the predicate because the unpacked vectors (vec_s64_lo, vec_s64_hi)\n        // already contain zeros for elements that were inactive in the original float vector.\n        // Squaring these zeros correctly results in zeros.\n        svint64_t sq_lo = svmul_s64(svptrue_b64(), vec_s64_lo, vec_s64_lo);\n        svint64_t sq_hi = svmul_s64(svptrue_b64(), vec_s64_hi, vec_s64_hi);\n\n        // 6. Horizontally sum the squared 64-bit integer elements within each vector.\n        // The results are added to the total_sum.\n        // svptrue_b64() is used as the predicate for the same reason as in squaring.\n        total_sum += svaddv_s64(svptrue_b64(), sq_lo);\n        total_sum += svaddv_s64(svptrue_b64(), sq_hi);\n\n        // Advance the index for the next chunk of elements.\n        i += sv_float_count;\n        // Generate the predicate for the next iteration.\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // For std::ceil in case of scalar fallback, though SVE has its own intrinsic\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t N = lst.size();\n    size_t i = 0;\n\n    // Get the number of 32-bit elements (float) that fit in an SVE vector.\n    // This is the Vector Length (VL) for float32_t.\n    size_t sv_float_vec_len = svcntw();\n\n    // Loop through the vector in chunks of SVE vector length\n    for (i = 0; i < N; i += sv_float_vec_len) {\n        // Create a predicate for the current chunk.\n        // This handles the tail end of the vector where 'i + sv_float_vec_len' might exceed N.\n        // Only active lanes (elements within bounds) will be processed.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // 1. Load float values from the input list into an SVE float vector.\n        svfloat32_t vec_f32 = svld1_f32(pg, &lst[i]);\n\n        // 2. Round each element up to the nearest integer (ceiling).\n        svfloat32_t vec_ceil_f32 = svceil_f32(pg, vec_f32);\n\n        // 3. Convert the ceiling-ed float values to 64-bit signed integers.\n        // This is important because squaring can lead to values exceeding 32-bit integer limits.\n        svint64_t vec_s64 = svcvt_s64_f32(pg, vec_ceil_f32);\n\n        // 4. Square each 64-bit integer value.\n        svint64_t vec_squared_s64 = svmul_s64(pg, vec_s64, vec_s64);\n\n        // 5. Horizontally sum the squared 64-bit integer values within the SVE vector.\n        // The predicate 'pg' ensures only active lanes contribute to the sum.\n        total_sum += svaddv_s64(pg, vec_squared_s64);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t N = lst.size();\n    size_t i = 0;\n\n    for (i = 0; i < N; /* increment inside loop */) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svfloat32_t v_float = svld1(pg, &lst[i]);\n\n        svfloat32_t v_ceil_float = svceil_f32(pg, v_float);\n\n        svint64_t v_int64 = svcvt_s64_f32(pg, v_ceil_float);\n\n        svint64_t v_squared_int64 = svmul_s64(pg, v_int64, v_int64);\n\n        int64_t chunk_sum = svaddv_s64(pg, v_squared_int64);\n\n        total_sum += (uint64_t)chunk_sum;\n\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int N = arr.size();\n\n    if (N <= 1) {\n        return -1;\n    }\n\n    int last_found_idx = -1;\n    const int* data_ptr = arr.data();\n\n    for (int k = 1; k < N; k += svcntw()) {\n        svbool_t pg = svwhilelt_b32(k, N);\n\n        svint32_t current_vec = svld1_s32(pg, &data_ptr[k]);\n        svint32_t previous_vec = svld1_s32(pg, &data_ptr[k-1]);\n\n        svbool_t cmp_result = svcmplt_s32(pg, current_vec, previous_vec);\n\n        if (svptest_any(pg, cmp_result)) {\n            int32_t last_true_offset_in_vec = svclastb_s32(pg, cmp_result);\n            if (last_true_offset_in_vec != -1) {\n                last_found_idx = k + last_true_offset_in_vec;\n            }\n        }\n    }\n\n    return last_found_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t N = arr.size();\n\n    if (N < 2) {\n        return -1;\n    }\n\n    int max_found_idx = -1;\n\n    size_t VL = svcntw();\n\n    size_t num_comparisons = N - 1;\n    size_t limit_k = (num_comparisons / VL) * VL;\n\n    for (size_t k = 0; k < limit_k; k += VL) {\n        svbool_t pg = svptrue_b32();\n\n        svint32_t v_prev = svld1_s32(pg, &arr[k]);\n        svint32_t v_curr = svld1_s32(pg, &arr[k+1]);\n\n        svbool_t cmp_mask = svcmplt_s32(pg, v_curr, v_prev);\n\n        if (svptest_any(pg, cmp_mask)) {\n            svint32_t current_indices = svadd_s32(svindex_s32(0, 1), svdup_s32(k + 1));\n            svint32_t masked_indices = svsel_s32(cmp_mask, current_indices, svdup_s32(-1));\n            int32_t max_in_vector = svmax_s32_z(pg, masked_indices);\n            max_found_idx = std::max(max_found_idx, max_in_vector);\n        }\n    }\n\n    for (size_t k = limit_k; k < num_comparisons; ++k) {\n        if (arr[k+1] < arr[k]) {\n            max_found_idx = k + 1;\n        }\n    }\n\n    return max_found_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    long N = arr.size();\n\n    // Handle base cases: an array with 0 or 1 element cannot have arr[i] < arr[i-1]\n    if (N <= 1) {\n        return -1;\n    }\n\n    int max_idx = -1; // Initialize with -1 as per problem statement\n\n    // Iterate through the array starting from index 1.\n    // `k` represents the current index `i` in `arr[i] < arr[i-1]`.\n    // The loop continues as long as `k` is less than `N`.\n    for (long k = 1; k < N; ) {\n        // Create a predicate for the current SVE vector.\n        // `svwhilelt_b32(k, N)` generates a predicate that is true for elements\n        // starting from `k` as long as their absolute index is less than `N`.\n        // This ensures we don't process elements beyond the array bounds.\n        svbool_t pg = svwhilelt_b32(k, N);\n\n        // Load the current elements: arr[k], arr[k+1], ...\n        // The load is masked by `pg` to only load valid elements.\n        svint32_t current_vals = svld1(pg, &arr[k]);\n\n        // Load the previous elements: arr[k-1], arr[k], ...\n        // This load is also masked by `pg`.\n        svint32_t prev_vals = svld1(pg, &arr[k-1]);\n\n        // Perform the comparison: current_vals < prev_vals\n        // This generates a predicate where bits are set if the condition is true.\n        svbool_t cmp_result = svcmplt(pg, current_vals, prev_vals);\n\n        // Check if any element in the current vector satisfies the condition.\n        if (svptest_any(pg, cmp_result)) {\n            // If there are matches, we need to find the largest index among them.\n            // 1. Create a vector of relative indices: [0, 1, 2, ..., VL-1].\n            svint32_t indices = svindex_s32(0, 1);\n\n            // 2. Select the relative index if the comparison was true, otherwise -1.\n            //    `svdup_s32(-1)` creates a vector where all elements are -1.\n            //    `svsel(cmp_result, indices, svdup_s32(-1))` selects `indices` where `cmp_result` is true,\n            //    and `-1` where `cmp_result` is false.\n            svint32_t selected_indices = svsel(cmp_result, indices, svdup_s32(-1));\n\n            // 3. Find the maximum value among the selected indices.\n            //    `svmaxv_s32(pg, selected_indices)` finds the maximum value only among\n            //    the elements active according to `pg`. If no elements satisfy `cmp_result`\n            //    within the active range, `svmaxv_s32` will return -1 (from the `svdup_s32(-1)`).\n            int max_j_in_block = svmaxv_s32(pg, selected_indices);\n\n            // If a valid index was found in this block (i.e., not -1)\n            if (max_j_in_block != -1) {\n                // Calculate the absolute array index: base_index (k) + relative_index (max_j_in_block)\n                int current_block_max_idx = k + max_j_in_block;\n                // Update the overall maximum index found so far.\n                if (current_block_max_idx > max_idx) {\n                    max_idx = current_block_max_idx;\n                }\n            }\n        }\n\n        // Advance the base index `k` by the number of elements processed in this iteration.\n        // `svcntp_b32(pg)` returns the number of active elements in the predicate `pg`.\n        k += svcntp_b32(pg);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::max\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t n = arr.size();\n\n    // If the array has less than 2 elements, no comparison arr[i] < arr[i-1] is possible.\n    if (n < 2) {\n        return -1;\n    }\n\n    const int* data = arr.data();\n\n    // Iterate backwards over the array in chunks of SVE vector length (VL).\n    // 'k_end' represents the highest index (for arr[k]) in the current SVE vector chunk.\n    // We are looking for the largest 'k' such that arr[k] < arr[k-1].\n    // The loop starts from n-1 (the last possible index for arr[k]) down to 1.\n    for (long k_end = n - 1; k_end >= 1; k_end -= svcntw()) {\n        // Calculate the starting index for the current SVE vector chunk.\n        // This ensures that the chunk starts at index 1 at the earliest,\n        // as arr[0] is the smallest valid index for arr[k-1].\n        long k_start = std::max(1L, k_end - (long)svcntw() + 1);\n\n        // Create a predicate for the elements within this chunk that are valid for comparison.\n        // The predicate 'pg' will be true for indices from 'k_start' up to 'k_end'.\n        // svwhilelt_b32(start, limit) generates a predicate for [start, limit-1].\n        svbool_t pg = svwhilelt_b32(k_start, k_end + 1);\n\n        // Load the 'current' values (arr[k]) for the active elements.\n        // These are arr[k_start], arr[k_start+1], ..., arr[k_end].\n        svint32_t current_vals = svld1_s32(pg, data + k_start);\n\n        // Load the 'previous' values (arr[k-1]) for the active elements.\n        // These are arr[k_start-1], arr[k_start], ..., arr[k_end-1].\n        svint32_t prev_vals = svld1_s32(pg, data + k_start - 1);\n\n        // Perform the comparison: current_vals < prev_vals.\n        // 'cmp_mask' will have bits set where the condition is true.\n        svbool_t cmp_mask = svcmplt_s32(pg, current_vals, prev_vals);\n\n        // Check if any element in this chunk satisfies the condition.\n        if (svptest_any(pg, cmp_mask)) {\n            // If a match is found, it means we have found the largest such index\n            // because we are iterating backwards.\n            // We need to find the exact index of the last (highest) true bit within 'cmp_mask'.\n\n            // svlastb_b32 returns a predicate with only the last (highest index) true bit set\n            // from the input 'cmp_mask', considering only elements active in 'pg'.\n            svbool_t last_match_pred = svlastb_b32(pg, cmp_mask);\n\n            // svbrkb_b32(pg, last_match_pred) creates a predicate that is true for all elements\n            // *before* the first true element in 'last_match_pred'.\n            // Since 'last_match_pred' has only one true element, this effectively marks\n            // all elements before the single true element.\n            // svcntp_b32 then counts the number of true elements in this new predicate,\n            // which gives us the offset of the last match within the current vector chunk.\n            size_t idx_offset = svcntp_b32(pg, svbrkb_b32(pg, last_match_pred));\n\n            // The actual index in the original array is the starting index of the chunk\n            // plus the calculated offset.\n            return k_start + idx_offset;\n        }\n    }\n\n    // If no such element is found after checking all chunks, return -1.\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // Required for std::max if scalar fallback was used, but not strictly for this SVE approach.\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    long N = arr.size();\n\n    // If the array has less than 2 elements, no comparison arr[i] < arr[i-1] is possible.\n    if (N < 2) {\n        return -1;\n    }\n\n    int result_idx = -1;\n    long vl = svcntd(); // Get the SVE vector length in terms of number of 32-bit elements.\n\n    // Iterate through the array in chunks of 'vl' elements.\n    // The loop variable 'i' represents the starting index of the 'current' vector (arr[i], arr[i+1], ...).\n    // The comparisons are arr[i] < arr[i-1], arr[i+1] < arr[i], etc.\n    // So, for each 'v_curr' (loaded from &arr[i]), we need a corresponding 'v_prev' (loaded from &arr[i-1]).\n    for (long i = 1; i < N; i += vl) {\n        // Predicate for the current vector elements (arr[i], arr[i+1], ...).\n        // It ensures we only process valid elements up to arr[N-1].\n        svbool_t pg_curr = svwhilelt_b32((uint64_t)i, (uint64_t)N);\n\n        // Load the current vector: {arr[i], arr[i+1], ..., arr[i+vl-1]}\n        svint32_t v_curr = svld1(pg_curr, &arr[i]);\n\n        // Predicate for the previous vector elements (arr[i-1], arr[i], ...).\n        // It ensures we only process valid elements up to arr[N-2] for the 'previous' values.\n        svbool_t pg_prev = svwhilelt_b32((uint64_t)i - 1, (uint64_t)N - 1);\n\n        // Load the previous vector: {arr[i-1], arr[i], ..., arr[i+vl-2]}\n        svint32_t v_prev = svld1(pg_prev, &arr[i-1]);\n\n        // Perform the comparison: v_curr < v_prev.\n        // The 'pg_curr' predicate governs which lanes are active for the comparison.\n        svbool_t cmp_lt = svcmplt(pg_curr, v_curr, v_prev);\n\n        // Check if any lane in the current vector satisfies the condition.\n        if (svptest_any(svptrue_b32(), cmp_lt)) {\n            // If there are elements satisfying the condition, find the highest index among them.\n            // 1. Generate a vector of indices: {i, i+1, i+2, ...}\n            svint32_t current_indices = svindex_s32(i, 1);\n\n            // 2. Select indices where the condition is true, otherwise set to -1.\n            svint32_t selected_indices = svsel_s32(cmp_lt, current_indices, svdup_n_s32(-1));\n\n            // 3. Find the maximum value in 'selected_indices' using a reduction.\n            //    The 'pg_curr' predicate ensures only active lanes are considered for the reduction.\n            int max_in_vec = svmax_s32_x(pg_curr, selected_indices);\n\n            // Update the overall result_idx if a larger index is found.\n            if (max_in_vec > result_idx) {\n                result_idx = max_in_vec;\n            }\n        }\n    }\n\n    return result_idx;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // For std::numeric_limits\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    // Initialize scalar results with sentinel values\n    int32_t largest_neg_scalar = std::numeric_limits<int32_t>::min();\n    int32_t smallest_pos_scalar = std::numeric_limits<int32_t>::max();\n\n    // Handle empty list or list with only 0s as per examples\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    // Initialize SVE vectors with sentinel values\n    // These vectors will accumulate the largest negative and smallest positive values across lanes.\n    svint32_t current_largest_neg_vec = svdup_s32(std::numeric_limits<int32_t>::min());\n    svint32_t current_smallest_pos_vec = svdup_s32(std::numeric_limits<int32_t>::max());\n\n    // Pre-calculate sentinel values as SVE vectors for efficiency inside the loop\n    const svint32_t min_int_vec = svdup_s32(std::numeric_limits<int32_t>::min());\n    const svint32_t max_int_vec = svdup_s32(std::numeric_limits<int32_t>::max());\n\n    const int32_t* data_ptr = lst.data();\n    size_t i = 0;\n    size_t list_size = lst.size();\n\n    // Loop through the vector in chunks using SVE's gather-load pattern\n    while (i < list_size) {\n        // Create a predicate for the current chunk, handling partial vectors at the end\n        svbool_t pg = svwhilelt_b32(i, list_size);\n\n        // If no active elements in this chunk (e.g., i >= list_size), break\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of integers from the input list\n        svint32_t vec = svld1_s32(pg, data_ptr + i);\n\n        // --- Process negative numbers ---\n        // Create a predicate for elements that are negative (< 0)\n        svbool_t pg_neg = svcmplt_s32(pg, vec, 0);\n        // Select negative numbers from 'vec' where 'pg_neg' is true.\n        // For lanes where 'pg_neg' is false, use 'min_int_vec' (INT_MIN).\n        // This ensures that non-negative numbers do not affect the maximum negative value\n        // when 'svmax_s32' is applied.\n        current_largest_neg_vec = svmax_s32(current_largest_neg_vec, svsel(pg_neg, vec, min_int_vec));\n\n        // --- Process positive numbers ---\n        // Create a predicate for elements that are positive (> 0)\n        svbool_t pg_pos = svcmsgt_s32(pg, vec, 0);\n        // Select positive numbers from 'vec' where 'pg_pos' is true.\n        // For lanes where 'pg_pos' is false, use 'max_int_vec' (INT_MAX).\n        // This ensures that non-positive numbers do not affect the minimum positive value\n        // when 'svmin_s32' is applied.\n        current_smallest_pos_vec = svmin_s32(current_smallest_pos_vec, svsel(pg_pos, vec, max_int_vec));\n\n        // Advance the index by the number of elements in an SVE vector (vector length)\n        i += svcntw();\n    }\n\n    // Reduce the SVE vectors to scalar values\n    // svptrue_b32() creates a predicate where all lanes are active for the reduction.\n    largest_neg_scalar = svmax_s32_reducd(svptrue_b32(), current_largest_neg_vec);\n    smallest_pos_scalar = svmin_s32_reducd(svptrue_b32(), current_smallest_pos_vec);\n\n    // Handle cases where no negative or positive numbers were found in the entire list.\n    // If 'largest_neg_scalar' is still INT_MIN, it means no negative numbers were encountered.\n    if (largest_neg_scalar == std::numeric_limits<int32_t>::min()) {\n        largest_neg_scalar = 0;\n    }\n    // If 'smallest_pos_scalar' is still INT_MAX, it means no positive numbers were encountered.\n    if (smallest_pos_scalar == std::numeric_limits<int32_t>::max()) {\n        smallest_pos_scalar = 0;\n    }\n\n    return {largest_neg_scalar, smallest_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm> // For std::min and std::max\n#include <limits>    // For std::numeric_limits\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    // Initialize largest_negative to the smallest possible integer value\n    // and smallest_positive to the largest possible integer value.\n    // These will be updated if corresponding numbers are found in the list.\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Loop through the input vector in chunks, processing with SVE intrinsics.\n    // svwhilelt_b32 generates a predicate for the current chunk, ensuring\n    // we don't read past the end of the vector.\n    for (; i < n; ) {\n        // Create a predicate 'pg' for the current SVE vector length (VL)\n        // that is active for elements from 'i' up to 'n-1'.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a chunk of data from the input list into an SVE vector.\n        // Only elements corresponding to active lanes in 'pg' are loaded.\n        svint32_t current_vec = svld1_s32(pg, &lst[i]);\n\n        // --- Process for finding the largest negative integer ---\n        // Create a predicate 'pg_neg' for elements in 'current_vec' that are less than 0 (negative).\n        // This predicate is only active where 'pg' is also active.\n        svbool_t pg_neg = svcmplt_s32(pg, current_vec, 0);\n\n        // Check if there are any negative numbers in the current chunk.\n        // svptest_any returns true if any lane in 'pg_neg' is active under 'pg'.\n        if (svptest_any(pg, pg_neg)) {\n            // Find the maximum value among the negative numbers in 'current_vec'.\n            // svmax_s32_x performs a horizontal maximum reduction on active lanes.\n            int chunk_largest_negative = svmax_s32_x(pg_neg, current_vec);\n            \n            // Update the overall largest_negative found so far.\n            largest_negative = std::max(largest_negative, chunk_largest_negative);\n        }\n\n        // --- Process for finding the smallest positive integer ---\n        // Create a predicate 'pg_pos' for elements in 'current_vec' that are greater than 0 (positive).\n        // This predicate is only active where 'pg' is also active.\n        svbool_t pg_pos = svcmpgt_s32(pg, current_vec, 0);\n\n        // Check if there are any positive numbers in the current chunk.\n        if (svptest_any(pg, pg_pos)) {\n            // Find the minimum value among the positive numbers in 'current_vec'.\n            // svmin_s32_x performs a horizontal minimum reduction on active lanes.\n            int chunk_smallest_positive = svmin_s32_x(pg_pos, current_vec);\n\n            // Update the overall smallest_positive found so far.\n            smallest_positive = std::min(smallest_positive, chunk_smallest_positive);\n        }\n\n        // Advance the index 'i' by the number of 32-bit elements in an SVE vector (VL).\n        // svcntw() returns the current vector length in 32-bit elements.\n        i += svcntw();\n    }\n\n    // Finalize results: If no negative/positive numbers were found, set them to 0.\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    // Return the results as a std::vector<int>.\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    // Initialize scalar results with sentinel values.\n    // These will be updated by SVE reductions.\n    // If no negative numbers are found, max_neg_scalar will remain INT_MIN.\n    // If no positive numbers are found, min_pos_scalar will remain INT_MAX.\n    int max_neg_scalar = std::numeric_limits<int>::min();\n    int min_pos_scalar = std::numeric_limits<int>::max();\n\n    // Flags to track if any negative or positive numbers were encountered.\n    // This is necessary because the reduction intrinsics will return the sentinel\n    // value if no actual numbers were processed (i.e., if the SVE vectors\n    // current_max_neg_vec and current_min_pos_vec remain at their initial sentinel values).\n    bool found_neg = false;\n    bool found_pos = false;\n\n    // Initialize SVE vectors for accumulating the global maximum negative and minimum positive.\n    // These are initialized with sentinel values that won't affect the min/max operations.\n    // For finding the maximum, initialize with the smallest possible value (INT_MIN).\n    // For finding the minimum, initialize with the largest possible value (INT_MAX).\n    svint32_t current_max_neg_vec = svdup_s32(std::numeric_limits<int>::min());\n    svint32_t current_min_pos_vec = svdup_s32(std::numeric_limits<int>::max());\n\n    // Get the vector length for 32-bit integers. This determines how many elements\n    // an SVE vector can hold, which can vary at runtime.\n    const size_t sv_vec_len = svcntw();\n\n    // Loop through the input list in chunks of SVE vector length.\n    for (size_t i = 0; i < lst.size(); i += sv_vec_len) {\n        // Create a predicate for the current chunk. svwhilelt_b32 generates a predicate\n        // that is true for elements from 'i' up to 'lst.size() - 1', handling partial\n        // vectors at the end of the list correctly.\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n\n        // Load the current chunk of data into an SVE vector using the predicate.\n        // Elements for which the predicate is false will not be loaded (or will be zeroed depending on context,\n        // but for svld1_s32, they are effectively ignored).\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // --- Process negative numbers ---\n        // Create a predicate for elements in 'vec' that are less than 0 (negative).\n        svbool_t neg_pred = svcmplt_s32(pg, vec, 0);\n\n        // Check if any negative numbers exist in the current chunk under the active predicate 'pg'.\n        if (svptest_any(pg, neg_pred)) {\n            found_neg = true; // Mark that at least one negative number was found in the entire list.\n            // Select only the negative numbers from 'vec'. For non-negative elements (where neg_pred is false),\n            // replace them with INT_MIN. This ensures that these non-negative values do not interfere\n            // with finding the maximum negative value when svmax_s32 is applied.\n            svint32_t neg_elements = svsel_s32(neg_pred, vec, svdup_s32(std::numeric_limits<int>::min()));\n            // Update the global maximum negative vector by taking the element-wise maximum.\n            current_max_neg_vec = svmax_s32(current_max_neg_vec, neg_elements);\n        }\n\n        // --- Process positive numbers ---\n        // Create a predicate for elements in 'vec' that are greater than 0 (positive).\n        svbool_t pos_pred = svcmsgt_s32(pg, vec, 0);\n\n        // Check if any positive numbers exist in the current chunk under the active predicate 'pg'.\n        if (svptest_any(pg, pos_pred)) {\n            found_pos = true; // Mark that at least one positive number was found in the entire list.\n            // Select only the positive numbers from 'vec'. For non-positive elements (where pos_pred is false),\n            // replace them with INT_MAX. This ensures that these non-positive values do not interfere\n            // with finding the minimum positive value when svmin_s32 is applied.\n            svint32_t pos_elements = svsel_s32(pos_pred, vec, svdup_s32(std::numeric_limits<int>::max()));\n            // Update the global minimum positive vector by taking the element-wise minimum.\n            current_min_pos_vec = svmin_s32(current_min_pos_vec, pos_elements);\n        }\n    }\n\n    // After processing all chunks, reduce the SVE vectors to scalar values.\n    // svptrue_b32 creates a predicate where all elements are true, ensuring the reduction\n    // considers all lanes of the accumulated SVE vector.\n    svbool_t full_pg = svptrue_b32();\n    max_neg_scalar = svmax_s32_reduction(full_pg, current_max_neg_vec);\n    min_pos_scalar = svmin_s32_reduction(full_pg, current_min_pos_vec);\n\n    // Final adjustments based on whether any negative/positive numbers were actually found.\n    // If 'found_neg' is false, it means no negative numbers were present in the input list.\n    // In this case, the problem requires returning 0 for the largest negative.\n    if (!found_neg) {\n        max_neg_scalar = 0;\n    }\n\n    // If 'found_pos' is false, it means no positive numbers were present in the input list.\n    // In this case, the problem requires returning 0 for the smallest positive.\n    if (!found_pos) {\n        min_pos_scalar = 0;\n    }\n\n    // Return the results as a std::vector<int> of size 2.\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    // Initialize SVE vectors for tracking the largest negative and smallest positive.\n    // current_largest_neg_vec is initialized with INT_MIN so any actual negative number will be greater.\n    // current_smallest_pos_vec is initialized with INT_MAX so any actual positive number will be smaller.\n    svint32_t current_largest_neg_vec = svdup_s32(std::numeric_limits<int>::min());\n    svint32_t current_smallest_pos_vec = svdup_s32(std::numeric_limits<int>::max());\n\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Loop through the input vector in chunks determined by the SVE vector length (svcntw())\n    while (i < n) {\n        // Get a predicate for the current chunk of elements.\n        // svwhilelt_b32 ensures that we only process valid elements,\n        // especially for the tail end of the vector where n is not a multiple of svcntw().\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current chunk of data from the input list into an SVE vector.\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // --- Process for finding the largest negative integer ---\n        // Create a predicate for elements that are strictly negative (< 0).\n        svbool_t neg_pred = svcmplt_s32(pg, vec, 0);\n\n        // Check if there are any active negative elements in this vector chunk.\n        if (svptest_any(pg, neg_pred)) {\n            // Select only the negative values from 'vec'. For non-negative elements,\n            // replace them with INT_MIN. This ensures that non-negative values do not\n            // incorrectly affect the svmax_s32 operation.\n            svint32_t neg_values = svsel_s32(neg_pred, vec, svdup_s32(std::numeric_limits<int>::min()));\n            // Update current_largest_neg_vec by taking the element-wise maximum\n            // between its current state and the new negative values.\n            current_largest_neg_vec = svmax_s32(current_largest_neg_vec, neg_values);\n        }\n\n        // --- Process for finding the smallest positive integer ---\n        // Create a predicate for elements that are strictly positive (> 0).\n        // svcmlt_s32(pg, a, b) generates a predicate where a < b is true.\n        // So, svcmlt_s32(pg, 0, vec) means 0 < vec, which is equivalent to vec > 0.\n        svbool_t pos_pred = svcmlt_s32(pg, 0, vec);\n\n        // Check if there are any active positive elements in this vector chunk.\n        if (svptest_any(pg, pos_pred)) {\n            // Select only the positive values from 'vec'. For non-positive elements,\n            // replace them with INT_MAX. This ensures that non-positive values do not\n            // incorrectly affect the svmin_s32 operation.\n            svint32_t pos_values = svsel_s32(pos_pred, vec, svdup_s32(std::numeric_limits<int>::max()));\n            // Update current_smallest_pos_vec by taking the element-wise minimum\n            // between its current state and the new positive values.\n            current_smallest_pos_vec = svmin_s32(current_smallest_pos_vec, pos_values);\n        }\n\n        // Advance the index by the number of elements processed in this SVE vector.\n        i += svcntw();\n    }\n\n    // Perform horizontal reduction to get the final scalar results from the SVE vectors.\n    // svptrue_b32() is used as the predicate to ensure all lanes are considered in the reduction.\n    int largest_neg_scalar = svmax_s32_x(svptrue_b32(), current_largest_neg_vec);\n    int smallest_pos_scalar = svmin_s32_x(svptrue_b32(), current_smallest_pos_vec);\n\n    // Handle cases where no negative or positive integers were found in the input list.\n    // If largest_neg_scalar is still INT_MIN, it means no negative numbers were encountered.\n    if (largest_neg_scalar == std::numeric_limits<int>::min()) {\n        largest_neg_scalar = 0;\n    }\n    // If smallest_pos_scalar is still INT_MAX, it means no positive numbers were encountered.\n    if (smallest_pos_scalar == std::numeric_limits<int>::max()) {\n        smallest_pos_scalar = 0;\n    }\n\n    // Return the results as a std::vector<int> of size 2.\n    return {largest_neg_scalar, smallest_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits> // Required for std::numeric_limits\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    // Initialize SVE vectors for accumulating the largest negative and smallest positive values.\n    // We use the minimum and maximum limits of int to ensure that any valid number\n    // found in the input list will be an improvement over these initial values.\n    svint32_t current_largest_neg_vec = svdup_s32(std::numeric_limits<int>::min());\n    svint32_t current_smallest_pos_vec = svdup_s32(std::numeric_limits<int>::max());\n\n    // Get the number of 32-bit integer elements that fit into an SVE vector register.\n    const size_t sv_elements = svcntw();\n    const size_t num_elements = lst.size();\n\n    // Loop through the input list in chunks, processing `sv_elements` at a time.\n    for (size_t i = 0; i < num_elements; i += sv_elements) {\n        // Create a predicate for the current chunk. This handles the tail elements\n        // by ensuring that only valid elements within the list bounds are processed.\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n\n        // Load the data from the input list into an SVE vector using the generated predicate.\n        svint32_t data_vec = svld1_s32(pg, &lst[i]);\n\n        // --- Find the largest negative integer ---\n        // Create a predicate for elements that are strictly negative (< 0).\n        svbool_t neg_pred = svcmplt_s32(pg, data_vec, 0);\n        // Select only the negative values from `data_vec`. For elements that are not negative\n        // (i.e., zero or positive), substitute `std::numeric_limits<int>::min()`.\n        // This ensures that these non-negative values do not interfere with the `svmax_s32`\n        // operation, allowing it to correctly find the maximum among only the negative numbers.\n        svint32_t neg_values = svsel_s32(neg_pred, data_vec, svdup_s32(std::numeric_limits<int>::min()));\n        // Update the accumulating largest negative vector by taking the element-wise maximum.\n        current_largest_neg_vec = svmax_s32(current_largest_neg_vec, neg_values);\n\n        // --- Find the smallest positive integer ---\n        // Create a predicate for elements that are strictly positive (> 0).\n        svbool_t pos_pred = svcmpgt_s32(pg, data_vec, 0);\n        // Select only the positive values from `data_vec`. For elements that are not positive\n        // (i.e., zero or negative), substitute `std::numeric_limits<int>::max()`.\n        // This ensures that these non-positive values do not interfere with the `svmin_s32`\n        // operation, allowing it to correctly find the minimum among only the positive numbers.\n        svint32_t pos_values = svsel_s32(pos_pred, data_vec, svdup_s32(std::numeric_limits<int>::max()));\n        // Update the accumulating smallest positive vector by taking the element-wise minimum.\n        current_smallest_pos_vec = svmin_s32(current_smallest_pos_vec, pos_values);\n    }\n\n    // After processing all chunks, perform a horizontal reduction on the accumulating vectors.\n    // `svptrue_b32()` creates a predicate where all lanes are active, ensuring all elements\n    // in the final SVE vector are considered for the reduction.\n    int final_largest_neg = svmaxv_s32(svptrue_b32(), current_largest_neg_vec);\n    int final_smallest_pos = svminv_s32(svptrue_b32(), current_smallest_pos_vec);\n\n    // Handle cases where no negative or positive integers were found in the input list.\n    // If `final_largest_neg` is still `std::numeric_limits<int>::min()`, it means no\n    // negative numbers were present in the list. In this case, set it to 0 as per requirements.\n    if (final_largest_neg == std::numeric_limits<int>::min()) {\n        final_largest_neg = 0;\n    }\n    // If `final_smallest_pos` is still `std::numeric_limits<int>::max()`, it means no\n    // positive numbers were present in the list. In this case, set it to 0 as per requirements.\n    if (final_smallest_pos == std::numeric_limits<int>::max()) {\n        final_smallest_pos = 0;\n    }\n\n    // Return the result as a std::vector<int> containing the largest negative and smallest positive.\n    return {final_largest_neg, final_smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n){\n    // The problem implies that 'n' will be small enough for the result\n    // to fit within a uint64_t. Based on calculations, this means n <= 8.\n    // We need an array to store factorials from 1! up to n!.\n    // Since max n is 8, we need indices up to 8.\n    // fact_values[0] can be used for 0! (which is 1) or simply be unused.\n    uint64_t fact_values[9]; \n\n    // Step 1: Calculate factorials 1! to n! using a scalar loop.\n    // This part cannot be easily vectorized with SVE due to the inherent\n    // data dependency (k! depends on (k-1)!).\n    // The problem statement specifies n > 0.\n    fact_values[0] = 1; // 0! = 1 (though not directly used for n > 0)\n    fact_values[1] = 1; // 1! = 1\n    for (uint64_t i = 2; i <= n; ++i) {\n        fact_values[i] = fact_values[i-1] * i;\n    }\n\n    // Step 2: Multiply all calculated factorials (1! * 2! * ... * n!) using SVE.\n    // Initialize an SVE vector with ones for product accumulation.\n    svuint64_t v_total_product = svdup_u64(1);\n\n    // Get the vector length in terms of uint64_t elements.\n    // This value is dynamic and depends on the SVE implementation.\n    uint64_t current_idx = 1;\n    uint64_t vl = svcntd(); // Number of uint64_t elements per vector\n\n    // Loop through the fact_values array, loading chunks into SVE vectors\n    // and accumulating the product.\n    while (current_idx <= n) {\n        // Create a predicate for the current chunk.\n        // It will be true for elements from 'current_idx' up to 'n' (inclusive).\n        svbool_t pg = svwhilelt_b64(current_idx, n + 1);\n\n        // Load a vector of factorial values using the predicate.\n        // Elements where 'pg' is false will not be loaded from memory;\n        // their corresponding lanes in 'v_data' will be undefined.\n        svuint64_t v_data = svld1_u64(pg, &fact_values[current_idx]);\n\n        // Multiply the accumulated product vector by the loaded data vector.\n        // Use svmul_u64_m to only update active lanes (where 'pg' is true).\n        // Inactive lanes in 'v_total_product' retain their previous values (which are 1).\n        v_total_product = svmul_u64_m(v_total_product, pg, v_total_product, v_data);\n\n        // Move to the next chunk of elements.\n        current_idx += vl;\n    }\n\n    // Step 3: Perform a horizontal product reduction on the final SVE vector\n    // to get the scalar result.\n    // svptrue_b64() creates a predicate where all lanes are true, ensuring all\n    // elements in v_total_product are included in the final reduction.\n    uint64_t result = svmul_u64_x(svptrue_b64(), v_total_product);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\n// Helper function to perform a horizontal product reduction on an SVE vector.\n// This function multiplies all active elements within the vector.\n// It uses a tree-reduction approach with svmul_u64_x and svtbl_u64 for parallelism.\nstatic inline uint64_t horizontal_product_u64(svuint64_t vec, svbool_t pg_initial) {\n    size_t vl = svcntd();\n    svbool_t pg = pg_initial;\n\n    // Perform a tree reduction: in each iteration, multiply elements with elements\n    // from a shifted version of the vector, effectively halving the number of active elements.\n    for (size_t i = vl / 2; i > 0; i /= 2) {\n        // Create an index vector for svtbl_u64 to get elements at (lane_idx + i)\n        // This effectively shifts the vector by 'i' positions.\n        svuint64_t indices = svindex_u64(i, 1);\n        svuint64_t shifted_vec = svtbl_u64(vec, indices);\n\n        // Multiply the current vector with the shifted vector.\n        // The predicate 'pg' ensures only active lanes are processed.\n        vec = svmul_u64_x(pg, vec, shifted_vec);\n\n        // Update the predicate to narrow down to the first 'i' elements for the next iteration.\n        // This ensures we only consider the relevant part of the vector that holds partial products.\n        pg = svwhilelt_b64(0, i);\n    }\n\n    // The final product is in the first active lane (lane 0) of the vector.\n    // svqget_lane_u64 extracts the value from the specified lane, respecting the predicate.\n    return svqget_lane_u64(pg, vec, 0);\n}\n\nuint64_t special_factorial_simd(uint64_t n) {\n    // As per problem definition, n > 0.\n    // For uint64_t return type, n is practically limited to 8,\n    // as special_factorial(9) overflows uint64_t.\n    // special_factorial(8) = 5,054,799,974,400,000 (fits in uint64_t)\n    // special_factorial(9) = 1,833,504,820,790,400,000,000 (overflows uint64_t)\n\n    if (n == 0) {\n        return 1; // Or handle as an error if n must be strictly > 0\n    }\n    if (n == 1) {\n        return 1;\n    }\n\n    // Step 1: Calculate factorials 1! through n! sequentially.\n    // This part is inherently sequential and cannot be parallelized with SVE efficiently.\n    uint64_t current_factorial = 1;\n    // Array to store factorials. Max n is 8, so size 9 is sufficient (index 0 unused).\n    uint64_t factorials[9]; \n    factorials[0] = 1; // Placeholder, not used for actual calculation (1! is at index 1)\n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        factorials[i] = current_factorial;\n    }\n\n    // Step 2: Multiply all calculated factorials (1! * 2! * ... * n!) using SVE.\n    uint64_t overall_product = 1;\n    size_t vl = svcntd(); // Get the number of uint64_t elements per SVE vector.\n\n    // Iterate through the factorials array in chunks of 'vl'.\n    for (uint64_t i = 1; i <= n; i += vl) {\n        // Create a temporary buffer for the current chunk to ensure safe memory access.\n        // This is a C99 Variable Length Array (VLA), commonly supported.\n        uint64_t temp_chunk[vl];\n\n        // Populate the temporary buffer. Pad with 1s if the chunk extends beyond 'n'.\n        // Padding with 1s ensures that multiplication by inactive lanes does not change the product.\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j <= n) {\n                temp_chunk[j] = factorials[i + j];\n            } else {\n                temp_chunk[j] = 1; // Pad with 1s for multiplication\n            }\n        }\n\n        // Create a predicate for the current chunk.\n        // This predicate is true for elements from 'i' up to 'n' (inclusive).\n        svbool_t pg_chunk = svwhilelt_b64(i, n + 1);\n\n        // Load the chunk data into an SVE vector using the predicate.\n        // Only active lanes (where pg_chunk is true) will be loaded with meaningful data.\n        svuint64_t current_vec = svld1_u64(pg_chunk, temp_chunk);\n\n        // Perform horizontal product reduction on the current SVE vector.\n        uint64_t chunk_product = horizontal_product_u64(current_vec, pg_chunk);\n\n        // Multiply the overall product by the product of the current chunk.\n        overall_product *= chunk_product;\n    }\n\n    return overall_product;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    // The problem implies that 'n' will be small enough for the final result\n    // to fit into a uint64_t. For reference, the Brazilian factorial for n=9\n    // (9! * 8! * ... * 1!) overflows uint64_t. Thus, 'n' is effectively limited to 8.\n    // This small 'n' value influences the choice of SVE strategy.\n\n    // Step 1: Calculate individual factorials (1!, 2!, ..., n!)\n    // This is a prefix product calculation (k! = (k-1)! * k).\n    // For small 'n' (max 8), a scalar loop is efficient and straightforward.\n    // SVE does not have a direct instruction for prefix products, and a custom\n    // SVE implementation for this specific part would likely be less efficient\n    // than a scalar loop due to the inherent data dependency and small 'n'.\n    // We store these factorials in a temporary array.\n    uint64_t factorials_arr[8]; // Max 'n' is 8, so max 8 elements are needed.\n\n    uint64_t current_fact = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        current_fact *= i;\n        factorials_arr[i-1] = current_fact;\n    }\n\n    // Step 2: Multiply all calculated factorials together using SVE for parallelism.\n    // This is a product reduction operation.\n\n    // Initialize the SVE accumulator vector with ones.\n    // This is crucial because svmul_u64_m (masked multiplication) will preserve\n    // the original value of inactive lanes. By initializing with 1s, these\n    // inactive lanes will not affect the final product.\n    svuint64_t acc_vec = svdup_u64(1);\n\n    // Get the current vector length (VL) for uint64_t elements.\n    size_t vl = svcntd();\n\n    // Loop through the 'factorials_arr' in chunks of 'vl'.\n    // A predicate 'pg' is used to handle partial vectors at the end of the array\n    // (when 'n' is not a multiple of 'vl').\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, n); // Predicate for the first chunk\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load elements from 'factorials_arr' into an SVE vector.\n        // 'svld1_u64' loads elements based on the predicate 'pg'.\n        // Inactive elements in the loaded vector will be zero, but they are\n        // masked out by 'svmul_u64_m'.\n        svuint64_t current_elements = svld1_u64(pg, &factorials_arr[i]);\n\n        // Perform element-wise multiplication.\n        // 'svmul_u64_m(pg, acc_vec, current_elements)' performs multiplication\n        // only for elements where the corresponding predicate lane is true.\n        // For inactive lanes, 'acc_vec' retains its original value (which is 1).\n        acc_vec = svmul_u64_m(pg, acc_vec, current_elements);\n\n        // Move to the next chunk of elements.\n        i += vl;\n        // Update the predicate for the next chunk.\n        pg = svwhilelt_b64(i, n);\n    }\n\n    // Step 3: Reduce the SVE accumulator vector to a single scalar product.\n    // SVE does not provide a direct horizontal product reduction instruction\n    // (like svaddv_u64 for sum reduction).\n    // Therefore, we extract the elements from the SVE vector to a temporary\n    // scalar array and then perform a scalar multiplication.\n    uint64_t temp_arr[vl];\n    // Store the accumulated vector 'acc_vec' into the temporary scalar array.\n    svst1_u64(svptrue_b64(), temp_arr, acc_vec);\n\n    uint64_t total_product = 1;\n    for (size_t k = 0; k < vl; ++k) {\n        total_product *= temp_arr[k];\n    }\n\n    return total_product;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    // The Brazilian factorial is defined as: n! * (n-1)! * ... * 1!\n    // This can be rewritten as: product_{k=1 to n} (k^(n-k+1))\n    // For example: special_factorial(4) = 1^4 * 2^3 * 3^2 * 4^1 = 1 * 8 * 9 * 4 = 288\n\n    // Handle base cases.\n    // The problem states n > 0.\n    if (n == 0) {\n        return 1; // Consistent with product of empty set or 0! = 1\n    }\n    if (n == 1) {\n        return 1; // 1! = 1\n    }\n\n    // Note on overflow: The result grows extremely fast.\n    // For n=9, the result (1.833 * 10^21) overflows a uint64_t (max ~1.844 * 10^19).\n    // The problem implies the result fits in uint64_t, so 'n' is expected to be small (e.g., n <= 8).\n    // No explicit error handling for overflow is requested, assuming valid input within uint64_t limits.\n\n    // Get the vector length (number of uint64_t elements) for the current SVE implementation.\n    // This determines how many elements can be processed in parallel.\n    size_t vl = svcntd();\n\n    // Initialize the total product accumulator.\n    uint64_t total_product = 1;\n\n    // Loop through segments of 'n' values.\n    // 'k' represents the starting value for the current vector segment (e.g., 1, 1+vl, 1+2*vl, ...).\n    for (uint64_t k = 1; k <= n; k += vl) {\n        // Create a predicate for active lanes within the current segment.\n        // This predicate ensures SVE operations only apply to valid elements up to 'n'.\n        // svwhilelt_b64(start, end) generates a predicate where elements are active as long as\n        // (start + index) < end. Here, (k + index) < (n + 1), meaning k + index <= n.\n        svbool_t pg = svwhilelt_b64(k, n + 1);\n\n        // Generate a vector of bases: [k, k+1, k+2, ..., k+vl-1]\n        // svindex_u64(start, step) generates a vector where lane i contains (start + i * step).\n        svuint64_t bases = svindex_u64(k, 1);\n\n        // Generate a vector of exponents: [(n-k+1), (n-(k+1)+1), ..., (n-(k+vl-1)+1)]\n        // This is equivalent to (n+1) - base for each lane.\n        svuint64_t exponents = svsub_u64_x(pg, svdup_u64(n + 1), bases);\n\n        // Initialize a vector to store the results of base^exponent for this segment.\n        // Each active lane starts with 1, as it's a multiplicative accumulation.\n        svuint64_t segment_powers = svdup_u64_x(pg, 1);\n\n        // Determine the maximum exponent value in the current vector segment.\n        // This is (n - k + 1) for the first element in the segment.\n        // The loop for power calculation needs to run up to this maximum value.\n        uint64_t max_exp_in_segment = n - k + 1;\n\n        // Loop to compute powers (base^exponent) for all active lanes in parallel.\n        // This loop iterates 'max_exp_in_segment' times.\n        for (uint64_t exp_iter = 1; exp_iter <= max_exp_in_segment; ++exp_iter) {\n            // Create a predicate for lanes where the current exponent is still active (i.e., >= exp_iter).\n            // Only these lanes will perform multiplication in this iteration.\n            svbool_t active_exp_lanes = svcmpge_u64(pg, exponents, svdup_u64(exp_iter));\n            \n            // Perform parallel multiplication: segment_powers[i] *= bases[i]\n            // This happens only for lanes where active_exp_lanes is true.\n            segment_powers = svmul_u64_x(active_exp_lanes, segment_powers, bases);\n        }\n\n        // Perform a horizontal product reduction for the 'segment_powers' vector.\n        // SVE does not have a direct horizontal product intrinsic (like svaddv_u64 for sum).\n        // Therefore, we extract elements from the vector and multiply them sequentially.\n        // Given that 'n' is small and 'vl' is typically not excessively large,\n        // this sequential reduction is acceptable and often efficient enough.\n        for (size_t i = 0; i < vl; ++i) {\n            // Check if this lane was active in the SVE operations (i.e., it holds a valid result).\n            if (svq_b64(pg, i)) { \n                total_product *= svq_u64(segment_powers, i);\n            }\n        }\n    }\n\n    return total_product;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    // As per problem description, n > 0.\n    // If n is 0, the behavior is undefined by the problem statement,\n    // but a common convention for empty product is 1.\n    // However, for n > 0, the smallest n is 1.\n    // brazilian_factorial(1) = 1! = 1.\n\n    // Calculate individual factorials up to n!.\n    // This part is inherently sequential due to data dependencies (k! = (k-1)! * k).\n    // Given that the result must fit in uint64_t, n cannot be very large (n <= 8).\n    // Thus, a simple loop for this part is efficient enough.\n    uint64_t factorials[n]; // VLA, C99 feature, supported by GCC/Clang\n    uint64_t current_factorial = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        factorials[i - 1] = current_factorial;\n    }\n\n    // Now, multiply all these calculated factorials using SVE intrinsics.\n    // This is a reduction operation that can be parallelized.\n\n    // Get the number of uint64_t elements that fit in an SVE vector.\n    // This value (VL) is determined at runtime.\n    size_t vl = svcntd();\n\n    // Initialize an SVE vector with ones. This vector will accumulate the product.\n    // All elements are initialized to 1 because 1 is the multiplicative identity.\n    svuint64_t sv_total_product = svdup_n_u64(1);\n\n    // Loop through the 'factorials' array in chunks of 'vl' elements.\n    // The loop processes 'vl' elements at a time, or fewer for the last chunk.\n    for (uint64_t i = 0; i < n; i += vl) {\n        // Create a predicate for the current chunk.\n        // svwhilelt_b64(i, n) generates a predicate where lanes are true\n        // as long as their logical index (starting from 'i') is less than 'n'.\n        // This handles partial vectors at the end of the array correctly,\n        // ensuring we don't read out of bounds or process invalid data.\n        svbool_t pg = svwhilelt_b64(i, n);\n\n        // Load a vector of factorials from the array using the predicate.\n        // Only elements corresponding to true predicate lanes are loaded.\n        svuint64_t sv_factorials = svld1_u64(pg, &factorials[i]);\n\n        // Perform element-wise multiplication.\n        // svmul_u64_m(pg, op1, op2) multiplies op1 by op2 only for active lanes (where pg is true).\n        // For inactive lanes, the corresponding elements in sv_total_product remain unchanged.\n        sv_total_product = svmul_u64_m(pg, sv_total_product, sv_factorials);\n    }\n\n    // Perform a horizontal reduction (multiplication) on the accumulated vector.\n    // svmulv_u64 multiplies all active elements within the sv_total_product vector\n    // to produce a single uint64_t scalar result.\n    // Since sv_total_product was accumulated using masked operations,\n    // only the relevant partial products are present in its active lanes.\n    uint64_t final_result = svmulv_u64(sv_total_product);\n\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    const long N = lst.size();\n\n    // Initialize a vector to accumulate partial sums.\n    // svdup_s32(0) creates a vector where all elements are 0.\n    svint32_t current_sum_vec = svdup_s32(0);\n\n    // Loop through the input vector in chunks of SVE vector length (VL).\n    // svcntw() returns the number of 32-bit integers that fit in an SVE vector.\n    for (long i = 0; i < N; i += svcntw()) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b32(i, N) creates a predicate that is true for elements\n        // whose logical index (starting from 'i') is less than N.\n        // This handles the tail of the vector correctly.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load the current chunk of data from the input list into an SVE vector.\n        // svld1_s32(pg, &lst[i]) loads elements only where 'pg' is true.\n        svint32_t original_data_vec = svld1_s32(pg, &lst[i]);\n\n        // Generate a vector of indices for the current chunk.\n        // svindex_s32(i, 1) creates a vector [i, i+1, i+2, ..., i+VL-1].\n        svint32_t current_indices = svindex_s32(i, 1);\n\n        // --- Predicate generation for conditional operations ---\n\n        // Condition 1: index % 3 == 0 (for squaring)\n        // Calculate (index % 3) for all elements in the current_indices vector.\n        svint32_t mod3_result = svmod_s32(current_indices, 3);\n        // Compare (index % 3) with 0 to get the predicate for squaring.\n        // svcmpeq_s32(pg, mod3_result, 0) generates a predicate where 'pg' is true\n        // AND (mod3_result == 0) for each element.\n        svbool_t pg_square = svcmpeq_s32(pg, mod3_result, 0);\n\n        // Condition 2: index % 4 == 0 && index % 3 != 0 (for cubing)\n        // Calculate (index % 4).\n        svint32_t mod4_result = svmod_s32(current_indices, 4);\n        // Predicate for (index % 4 == 0).\n        svbool_t pg_mod4 = svcmpeq_s32(pg, mod4_result, 0);\n        // Predicate for (index % 3 != 0).\n        svbool_t pg_not_mod3 = svcmpne_s32(pg, mod3_result, 0);\n        // Combine the two predicates using logical AND.\n        svbool_t pg_cube = svand_b(pg_mod4, pg_not_mod3);\n\n        // --- Perform operations ---\n\n        // Calculate squared values for all elements.\n        svint32_t squared_val = svmul_s32(original_data_vec, original_data_vec);\n        // Calculate cubed values for all elements.\n        svint32_t cubed_val = svmul_s32(original_data_vec, svmul_s32(original_data_vec, original_data_vec));\n\n        // Initialize the result vector with the original data.\n        svint32_t result_vec = original_data_vec;\n\n        // Apply squaring: if pg_square is true for an element, select its squared_val;\n        // otherwise, keep the current value in result_vec (which is original_data_vec).\n        result_vec = svsel_s32(pg_square, squared_val, result_vec);\n\n        // Apply cubing: if pg_cube is true for an element, select its cubed_val;\n        // otherwise, keep the current value in result_vec.\n        // This works correctly because the conditions for squaring and cubing are mutually exclusive.\n        result_vec = svsel_s32(pg_cube, cubed_val, result_vec);\n\n        // Accumulate the modified values into the sum vector.\n        // svadd_s32_x(pg, current_sum_vec, result_vec) adds elements from result_vec\n        // to current_sum_vec only where 'pg' is true. For inactive elements,\n        // the corresponding element in current_sum_vec remains unchanged.\n        current_sum_vec = svadd_s32_x(pg, current_sum_vec, result_vec);\n    }\n\n    // After the loop, perform a horizontal sum of all elements in the accumulated vector.\n    // svptrue_b32() creates a predicate where all lanes are active, ensuring all\n    // accumulated partial sums are included in the final reduction.\n    int total_sum = svaddv_s32(svptrue_b32(), current_sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int total_sum = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    // Iterate through the vector in chunks of SVE vector length (VL).\n    // svcntw() returns the number of 32-bit elements in an SVE vector.\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that operations only apply to valid elements\n        // within the bounds of the input vector, especially for the tail end.\n        svbool_t pg = svwhilelt_b32((uint64_t)i, (uint64_t)n);\n\n        // Load the current chunk of data from the input vector.\n        svint32_t current_vec = svld1_s32(pg, &lst[i]);\n\n        // Initialize the result vector with the original values.\n        // This vector will be modified based on the conditions.\n        svint32_t result_vec = current_vec;\n\n        // Generate a vector of global indices for the current chunk.\n        // This is crucial for index-based operations.\n        // svindex_s32(start, step) generates a sequence: {start, start+step, start+2*step, ...}\n        svint32_t indices = svindex_s32(i, 1); // Generates {i, i+1, i+2, ..., i+VL-1}\n\n        // Calculate modulo 3 and modulo 4 for the indices.\n        svint32_t mod3_indices = svmod_s32(pg, indices, svdup_s32(3));\n        svint32_t mod4_indices = svmod_s32(pg, indices, svdup_s32(4));\n\n        // Create masks based on the problem's conditions.\n\n        // Condition 1: index % 3 == 0 (for squaring)\n        svbool_t mask_square = svcmpeq_s32(pg, mod3_indices, 0);\n\n        // Condition 2: index % 4 == 0 AND index % 3 != 0 (for cubing)\n        svbool_t mask_mod4_eq_0 = svcmpeq_s32(pg, mod4_indices, 0);\n        svbool_t mask_mod3_ne_0 = svcmpne_s32(pg, mod3_indices, 0);\n        svbool_t mask_cube = svand_b(pg, mask_mod4_eq_0, mask_mod3_ne_0);\n\n        // Apply operations based on the generated masks.\n        // The conditions (mask_square and mask_cube) are mutually exclusive,\n        // so we can apply them sequentially to `result_vec`.\n\n        // Apply squaring: if mask_square is true, square the element.\n        // svmul_s32_x performs predicated multiplication, only affecting active lanes.\n        svint32_t squared_val = svmul_s32_x(mask_square, current_vec, current_vec);\n        // svsel_s32 selects elements: if mask_square is true, take from squared_val,\n        // otherwise (mask_square is false), keep the value from result_vec.\n        result_vec = svsel_s32(mask_square, squared_val, result_vec);\n\n        // Apply cubing: if mask_cube is true, cube the element.\n        // We need to cube the *original* value, so we use `current_vec` for multiplication.\n        svint32_t cubed_val_temp = svmul_s32_x(mask_cube, current_vec, current_vec); // First square the original value\n        svint32_t cubed_val = svmul_s32_x(mask_cube, cubed_val_temp, current_vec);   // Then multiply by original value again to cube\n        result_vec = svsel_s32(mask_cube, cubed_val, result_vec);\n\n        // Horizontally sum the elements of the processed vector chunk.\n        // svaddv_s32 sums all active elements in the vector based on the predicate `pg`.\n        total_sum += svaddv_s32(pg, result_vec);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    // Initialize the total sum to 0.\n    // The problem specifies the return type as int, so we assume the sum fits within an int.\n    int final_sum = 0;\n\n    // Get the size of the input vector.\n    size_t n = lst.size();\n\n    // Handle empty vector case.\n    if (n == 0) {\n        return 0;\n    }\n\n    // Get the number of 32-bit integer elements that fit into an SVE vector.\n    // This value (VL) can vary at runtime.\n    size_t vl = svcntw();\n\n    // Initialize an SVE vector to accumulate partial sums.\n    // All lanes are set to 0.\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Loop through the input vector in chunks of `vl` elements.\n    for (size_t i = 0; i < n; i += vl) {\n        // Create a predicate (mask) for the current SVE vector operation.\n        // `svwhilelt_b32` generates a predicate that is true for elements\n        // whose original index `i + lane_idx` is less than `n`.\n        // This correctly handles the tail (remaining elements) of the vector.\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)n);\n\n        // Load a chunk of data from the input vector into an SVE vector.\n        // Only active lanes (determined by `pg`) are loaded; inactive lanes are undefined.\n        svint32_t current_data = svld1_s32(pg, &lst[i]);\n\n        // Generate a sequence of indices for the current SVE vector.\n        // For a chunk starting at `i`, indices will be `i, i+1, i+2, ...`\n        svint32_t indices = svindex_s32((int32_t)i, 1);\n\n        // --- Predicate for squaring: index % 3 == 0 ---\n        // Calculate (index % 3) for all active lanes.\n        svint32_t mod3_result = svmod_s32(indices, svdup_s32(3));\n        // Create a predicate where lanes are true if (mod3_result == 0) and active.\n        svbool_t p_square = svcmpeq_s32(pg, mod3_result, svdup_s32(0));\n\n        // --- Predicate for cubing: index % 4 == 0 && index % 3 != 0 ---\n        // Calculate (index % 4) for all active lanes.\n        svint32_t mod4_result = svmod_s32(indices, svdup_s32(4));\n        // Create predicates for sub-conditions.\n        svbool_t p_cube_mod4_eq_0 = svcmpeq_s32(pg, mod4_result, svdup_s32(0));\n        svbool_t p_cube_mod3_ne_0 = svcmpne_s32(pg, mod3_result, svdup_s32(0));\n        // Combine sub-conditions using logical AND.\n        svbool_t p_cube = svand_b(p_cube_mod4_eq_0, p_cube_mod3_ne_0);\n\n        // Create a temporary vector to store the modified values.\n        // Initialize it with the original data.\n        svint32_t modified_data = current_data;\n\n        // Apply squaring operation: if p_square is true, replace with current_data * current_data.\n        // Otherwise, keep the value in modified_data.\n        svint32_t squared_val = svmul_s32(current_data, current_data);\n        modified_data = svsel_s32(p_square, squared_val, modified_data);\n\n        // Apply cubing operation: if p_cube is true, replace with current_data * current_data * current_data.\n        // Otherwise, keep the value in modified_data.\n        // Note: The conditions for squaring and cubing are mutually exclusive.\n        // Therefore, applying them sequentially with `svsel` using the original `current_data` for calculations\n        // ensures correctness. If a lane was squared, it won't be cubed, and vice-versa.\n        svint32_t cubed_val = svmul_s32(current_data, svmul_s32(current_data, current_data));\n        modified_data = svsel_s32(p_cube, cubed_val, modified_data);\n\n        // Accumulate the modified data into the sum vector.\n        // `svadd_s32_z` adds `modified_data` to `sum_vec` only for active lanes (`pg`).\n        // Inactive lanes of `modified_data` are treated as zero for the addition.\n        sum_vec = svadd_s32_z(pg, sum_vec, modified_data);\n    }\n\n    // Perform a horizontal sum reduction on the `sum_vec` to get the final scalar sum.\n    // `svptrue_b32()` creates a predicate where all lanes are true, ensuring all lanes of `sum_vec` are summed.\n    final_sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int total_sum = 0;\n    size_t i = 0;\n    size_t list_size = lst.size();\n\n    // Initialize sum vector to zeros\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Get the vector length for 32-bit integers\n    size_t sv_len = svcntw();\n\n    // Loop through the vector in chunks\n    while (i < list_size) {\n        // Create a predicate for the current chunk\n        // This predicate will be true for active elements and false for padding\n        svbool_t pg = svwhilelt_b32(i, list_size);\n\n        // Load current elements from the list\n        svint32_t current_elements = svld1_s32(pg, &lst[i]);\n\n        // Generate indices for the current chunk: i, i+1, ..., i + sv_len - 1\n        svint32_t indices = svindex_s32(i, 1);\n\n        // --- Condition 1: index % 3 == 0 (square) ---\n        // Calculate (indices % 3)\n        svint32_t mod3_result = svmod_s32_z(pg, indices, svdup_s32(3));\n        // Create predicate for (indices % 3 == 0)\n        svbool_t p_mod3_zero = svcmpeq_s32(pg, mod3_result, svdup_s32(0));\n\n        // Calculate squared values for elements where p_mod3_zero is true\n        svint32_t squared_val = svmul_s32_x(p_mod3_zero, current_elements, current_elements);\n        \n        // Select between squared_val and original current_elements based on p_mod3_zero\n        // This updates current_elements for the next condition\n        current_elements = svsel_s32(p_mod3_zero, squared_val, current_elements);\n\n        // --- Condition 2: index % 4 == 0 AND index % 3 != 0 (cube) ---\n        // Calculate (indices % 4)\n        svint32_t mod4_result = svmod_s32_z(pg, indices, svdup_s32(4));\n        // Create predicate for (indices % 4 == 0)\n        svbool_t p_mod4_zero = svcmpeq_s32(pg, mod4_result, svdup_s32(0));\n        \n        // Create predicate for (indices % 3 != 0)\n        svbool_t p_mod3_nonzero = svcmpne_s32(pg, mod3_result, svdup_s32(0));\n\n        // Combine predicates: (index % 4 == 0) AND (index % 3 != 0)\n        svbool_t p_cube = svand_b(p_mod4_zero, p_mod3_nonzero);\n\n        // Calculate cubed values for elements where p_cube is true\n        // current_elements already holds potentially squared values from the previous step.\n        // If p_cube is true, then p_mod3_zero must have been false, so current_elements\n        // at this point would still hold the original value.\n        svint32_t cubed_val = svmul_s32_x(p_cube, current_elements, svmul_s32_x(p_cube, current_elements, current_elements));\n        \n        // Select between cubed_val and (potentially squared or original) current_elements based on p_cube\n        current_elements = svsel_s32(p_cube, cubed_val, current_elements);\n\n        // Accumulate the processed elements into the sum vector\n        sum_vec = svadd_s32_x(pg, sum_vec, current_elements);\n\n        // Move to the next chunk\n        i += sv_len;\n    }\n\n    // Horizontal sum of the accumulated vector\n    total_sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    // Use long long for the total sum to prevent potential overflow during accumulation,\n    // as intermediate sums might exceed the range of int, even if the final result fits.\n    long long total_sum = 0;\n\n    if (lst.empty()) {\n        return 0;\n    }\n\n    const int *data = lst.data();\n    int n = lst.size();\n\n    // Get the vector length for 32-bit integers (svcntw() returns the number of 32-bit elements)\n    int svl = svcntw();\n\n    // Loop through the vector in chunks of svl elements\n    for (int i = 0; i < n; i += svl) {\n        // Create a predicate for the active elements in the current vector chunk.\n        // This handles the tail end of the vector where 'i + svl' might exceed 'n'.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load the current vector chunk from the input list\n        svint32_t current_vec = svld1_s32(pg, &data[i]);\n\n        // Generate a vector of indices for the current chunk: [i, i+1, i+2, ..., i+svl-1]\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Constants for modulo operations\n        svint32_t zero_vec = svdup_s32(0);\n        svint32_t three_vec = svdup_s32(3);\n        svint32_t four_vec = svdup_s32(4);\n\n        // --- Calculate predicate for indices where (index % 3 == 0) ---\n        // rem3 = indices - (indices / 3) * 3\n        svint32_t div3 = svdiv_s32(pg, indices, three_vec);\n        svint32_t mul3 = svmul_s32(pg, div3, three_vec);\n        svint32_t rem3 = svsub_s32(pg, indices, mul3);\n        svbool_t p_mult3 = svcmpeq_s32(pg, rem3, zero_vec);\n\n        // --- Calculate predicate for indices where (index % 4 == 0) ---\n        // rem4 = indices - (indices / 4) * 4\n        svint32_t div4 = svdiv_s32(pg, indices, four_vec);\n        svint32_t mul4 = svmul_s32(pg, div4, four_vec);\n        svint32_t rem4 = svsub_s32(pg, indices, mul4);\n        svbool_t p_mult4 = svcmpeq_s32(pg, rem4, zero_vec);\n\n        // --- Calculate predicate for indices where (index % 4 == 0 && index % 3 != 0) ---\n        svbool_t p_not_mult3 = svcmpne_s32(pg, rem3, zero_vec);\n        svbool_t p_mult4_not3 = svand_b(p_mult4, p_not_mult3);\n\n        // --- Perform calculations for squared and cubed values ---\n        svint32_t squared_vec = svmul_s32(pg, current_vec, current_vec);\n        svint32_t cubed_vec = svmul_s32(pg, squared_vec, current_vec); // current_vec * current_vec * current_vec\n\n        // --- Apply conditional operations using svsel based on the rules ---\n        // Rule precedence:\n        // 1. If index is a multiple of 3, square it.\n        // 2. Else if index is a multiple of 4 AND not a multiple of 3, cube it.\n        // 3. Else, keep the original value.\n\n        // Step 1: Handle Rule 2 (cube if multiple of 4 and not 3) or Rule 3 (keep original)\n        // If p_mult4_not3 is true, use cubed_vec; otherwise, use the original current_vec.\n        svint32_t temp_vec = svsel_s32(p_mult4_not3, cubed_vec, current_vec);\n\n        // Step 2: Handle Rule 1 (square if multiple of 3) or the result from Step 1\n        // If p_mult3 is true, use squared_vec; otherwise, use the result from temp_vec.\n        // This correctly implements the precedence: if p_mult3 is true, it overrides p_mult4_not3.\n        svint32_t final_vec = svsel_s32(p_mult3, squared_vec, temp_vec);\n\n        // Accumulate the sum of the processed vector elements into total_sum\n        total_sum += svaddv_s32(pg, final_vec);\n    }\n\n    // Cast the final sum to int as per the function signature.\n    return static_cast<int>(total_sum);\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1 \nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums){\n    int total_count = 0;\n    size_t num_elements = nums.size();\n    size_t i = 0;\n\n    // Loop through the vector in chunks of svcntw() elements\n    for (i = 0; i < num_elements; i += svcntw()) {\n        // Create a predicate for the current chunk, handling partial vectors at the end\n        svbool_t current_pg = svwhilelt_b32(i, num_elements);\n\n        // If no elements are active in this chunk, break the loop\n        if (!svptest_any(svptrue_b32(), current_pg)) {\n            break;\n        }\n\n        // Load the current chunk of data into an SVE vector register\n        svint32_t vec_nums = svld1(current_pg, &nums[i]);\n\n        // Condition 1: number > 10\n        svbool_t cond1 = svcmpgt_s32(current_pg, vec_nums, svdup_s32(10));\n\n        // Get absolute values for digit extraction.\n        // svabs_s32_z applies abs to active lanes and zeros out inactive lanes.\n        svint32_t abs_vec_nums = svabs_s32_z(current_pg, vec_nums);\n\n        // --- Condition 2: First digit is odd ---\n        svint32_t first_digits = abs_vec_nums;\n        // Iteratively divide by 10 until the number is a single digit (the first digit)\n        // This loop continues as long as there are any active lanes where the number is >= 10\n        svbool_t active_first_digit_lanes = svcmpge_s32(current_pg, first_digits, svdup_s32(10));\n        while (svptest_any(current_pg, active_first_digit_lanes)) {\n            // For active lanes, divide by 10. For inactive lanes, preserve the value.\n            first_digits = svdiv_s32_m(first_digits, active_first_digit_lanes, first_digits, svdup_s32(10));\n            // Update the predicate for lanes that still need division\n            active_first_digit_lanes = svcmpge_s32(current_pg, first_digits, svdup_s32(10));\n        }\n        // Check if the first digit is odd (remainder when divided by 2 is not 0)\n        svbool_t cond2 = svcmpne_s32(current_pg, svmod_s32(current_pg, first_digits, svdup_s32(2)), svdup_s32(0));\n\n        // --- Condition 3: Last digit is odd ---\n        // Get the last digit by taking modulo 10 of the absolute value\n        svint32_t last_digits = svmod_s32(current_pg, abs_vec_nums, svdup_s32(10));\n        // Check if the last digit is odd\n        svbool_t cond3 = svcmpne_s32(current_pg, svmod_s32(current_pg, last_digits, svdup_s32(2)), svdup_s32(0));\n\n        // Combine all three conditions using logical AND\n        svbool_t combined_mask = svand_b(cond1, svand_b(cond2, cond3));\n\n        // Count the number of elements that satisfy all conditions within the current chunk\n        total_count += svcntp_b(current_pg, combined_mask);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\n/*\nWrite a function that takes a vector of numbers as input and returns\nthe number of elements in the vector that are greater than 10 and both\nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1\nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums) {\n    int total_count = 0;\n    const int N = nums.size();\n    int i = 0;\n\n    // Loop through the vector in chunks of VL (Vector Length)\n    // svwhilelt_b32 generates a predicate for active lanes, handling both full vectors and the tail.\n    for (; i < N; i += svcntw()) {\n        // Get a predicate for the current chunk, ensuring we don't process beyond N.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load the current chunk of data into an SVE vector.\n        svint32_t v_x = svld1_s32(pg, &nums[i]);\n\n        // Condition 1: The number is greater than 10.\n        svbool_t p_gt_10 = svcmpgt(pg, v_x, svdup_n_s32(pg, 10));\n\n        // Condition 3: The last digit of the number is odd.\n        // Use absolute value for last digit calculation (e.g., last digit of -73 is 3).\n        svint32_t v_abs_x_for_last_digit = svabs_s32(pg, v_x);\n        svint32_t v_last_digit = svrem_s32(pg, v_abs_x_for_last_digit, svdup_n_s32(pg, 10));\n        // Check if the last digit is odd (i.e., (digit & 1) == 1).\n        svbool_t p_last_digit_odd = svcmpeq(pg, svand_s32(pg, v_last_digit, svdup_n_s32(pg, 1)), svdup_n_s32(pg, 1));\n\n        // Condition 2: The first digit of the number is odd.\n        // This is the most complex part. We need to find the largest power of 10\n        // that is less than or equal to the number, then divide by it.\n        // Since `v_x > 10` is a prerequisite, numbers will have at least two digits.\n        svint32_t v_divisor = svdup_n_s32(pg, 1); // Initialize divisor to 1\n        svbool_t p_current_active = pg; // Predicate for lanes still needing a divisor update\n\n        // Iterate through powers of 10 from largest possible (10^9 for int) down to 10^1.\n        // For each power, if a number is greater than or equal to it and hasn't found its divisor yet,\n        // set its divisor to that power of 10 and deactivate its lane from further checks.\n\n        // 10^9 (1,000,000,000)\n        svbool_t p_ge_1e9 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 1000000000));\n        v_divisor = svsel(p_ge_1e9, svdup_n_s32(p_current_active, 1000000000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e9); // Deactivate lanes that matched\n\n        // 10^8 (100,000,000)\n        svbool_t p_ge_1e8 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 100000000));\n        v_divisor = svsel(p_ge_1e8, svdup_n_s32(p_current_active, 100000000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e8);\n\n        // 10^7 (10,000,000)\n        svbool_t p_ge_1e7 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 10000000));\n        v_divisor = svsel(p_ge_1e7, svdup_n_s32(p_current_active, 10000000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e7);\n\n        // 10^6 (1,000,000)\n        svbool_t p_ge_1e6 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 1000000));\n        v_divisor = svsel(p_ge_1e6, svdup_n_s32(p_current_active, 1000000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e6);\n\n        // 10^5 (100,000)\n        svbool_t p_ge_1e5 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 100000));\n        v_divisor = svsel(p_ge_1e5, svdup_n_s32(p_current_active, 100000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e5);\n\n        // 10^4 (10,000)\n        svbool_t p_ge_1e4 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 10000));\n        v_divisor = svsel(p_ge_1e4, svdup_n_s32(p_current_active, 10000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e4);\n\n        // 10^3 (1,000)\n        svbool_t p_ge_1e3 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 1000));\n        v_divisor = svsel(p_ge_1e3, svdup_n_s32(p_current_active, 1000), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e3);\n\n        // 10^2 (100)\n        svbool_t p_ge_1e2 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 100));\n        v_divisor = svsel(p_ge_1e2, svdup_n_s32(p_current_active, 100), v_divisor);\n        p_current_active = svbic_b(p_current_active, p_ge_1e2);\n\n        // 10^1 (10) - For numbers like 10-99.\n        // Any remaining active lanes (where v_x >= 10 and no higher power matched)\n        // should have their divisor set to 10.\n        svbool_t p_ge_1e1 = svcmpge(p_current_active, v_x, svdup_n_s32(p_current_active, 10));\n        v_divisor = svsel(p_ge_1e1, svdup_n_s32(p_current_active, 10), v_divisor);\n        // No need to update p_current_active further as this is the last check.\n\n        // Calculate the first digit by dividing the number by its determined divisor.\n        svint32_t v_first_digit = svdiv_s32(pg, v_x, v_divisor);\n        // Check if the first digit is odd.\n        svbool_t p_first_digit_odd = svcmpeq(pg, svand_s32(pg, v_first_digit, svdup_n_s32(pg, 1)), svdup_n_s32(pg, 1));\n\n        // Combine all three conditions using logical AND.\n        svbool_t p_all_conditions = svand_b(p_gt_10, svand_b(p_last_digit_odd, p_first_digit_odd));\n\n        // Count the number of active lanes (elements) that satisfy all conditions.\n        total_count += svcntp_b(pg, p_all_conditions);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\n/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1 \nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums){\n    int total_count = 0;\n    size_t i = 0;\n    size_t num_elements = nums.size();\n\n    // Get the number of 32-bit elements in an SVE vector\n    size_t sv_len = svcntw(); \n\n    // Loop through the vector in chunks of sv_len\n    while (i < num_elements) {\n        // Create a predicate for the current chunk, handling partial vectors at the end\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)num_elements);\n\n        // Load the data into an SVE vector\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n\n        // Condition 1: Number > 10\n        svbool_t p_gt_10 = svcmpgt_s32(pg, vec, svdup_s32(10));\n\n        // Get absolute value for digit extraction (first and last digits are based on magnitude)\n        svint32_t abs_vec = svabs_s32(vec);\n\n        // Condition 2: Last digit is odd\n        // Calculate last digit: abs_vec % 10\n        svint32_t last_digit = svmod_s32(pg, abs_vec, svdup_s32(10));\n        // Check if last_digit is odd (last_digit & 1 == 1)\n        svbool_t p_last_odd = svcmpeq_s32(pg, svand_s32(last_digit, svdup_s32(1)), svdup_s32(1));\n\n        // Condition 3: First digit is odd\n        svint32_t first_digit_val = abs_vec;\n        // Predicate for elements that still need division (value >= 10)\n        svbool_t p_needs_division = svcmpge_s32(pg, first_digit_val, svdup_s32(10));\n\n        // Repeatedly divide by 10 until the value is a single digit\n        while (svptest_any(pg, p_needs_division)) {\n            first_digit_val = svdiv_s32(p_needs_division, first_digit_val, svdup_s32(10));\n            // Update the predicate for elements that still need division\n            p_needs_division = svcmpge_s32(pg, first_digit_val, svdup_s32(10));\n        }\n        // Check if first_digit_val is odd (first_digit_val & 1 == 1)\n        svbool_t p_first_odd = svcmpeq_s32(pg, svand_s32(first_digit_val, svdup_s32(1)), svdup_s32(1));\n\n        // Combine all three conditions using logical AND\n        svbool_t final_predicate = svand_b(p_gt_10, svand_b(p_last_odd, p_first_odd));\n\n        // Count the number of active elements that satisfy all conditions\n        total_count += svcntp_b32(pg, final_predicate);\n\n        // Move to the next chunk of elements\n        i += sv_len;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstddef> // For size_t\n\n/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1 \nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t i = 0;\n    size_t num_elements = nums.size();\n\n    // Loop through the vector in SVE vector chunks.\n    // svwhilelt_b32 generates a predicate for the current chunk,\n    // ensuring that only valid elements within the vector bounds are processed,\n    // and automatically handles the tail elements.\n    svbool_t pg = svwhilelt_b32(i, num_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit integers from the input array.\n        // Inactive lanes (beyond num_elements) will be loaded as 0.\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n\n        // Condition 1: Number is greater than 10.\n        // This comparison uses the original value of the number.\n        svbool_t cond1_gt_10 = svcmpgt_s32(pg, vec, 10);\n\n        // For digit extraction (first and last), we need to work with absolute values.\n        // For example, the first digit of -15 is 1, and the last is 5.\n        // svabs_s32_x computes the absolute value for active lanes.\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n\n        // Condition 2: Last digit is odd.\n        // Calculate the last digit using modulo 10.\n        svint32_t last_digit = svmod_s32_x(pg, abs_vec, 10);\n        // Check if the last digit is odd (not equal to 0 when modulo 2).\n        svbool_t cond2_last_digit_odd = svcmpne_s32(pg, svmod_s32_x(pg, last_digit, 2), 0);\n\n        // Condition 3: First digit is odd.\n        // This is more complex as it requires repeatedly dividing by 10 until the number is a single digit.\n        svint32_t first_digit_vec = abs_vec;\n        svint32_t ten_sve = svdup_s32(10);\n        // Use a separate predicate for the first digit calculation loop.\n        // This predicate tracks which elements still need division.\n        svbool_t current_pg_for_first_digit = pg;\n\n        // Loop for a maximum of 9 divisions (sufficient for a 10-digit int like 2,000,000,000).\n        for (int k = 0; k < 9; ++k) {\n            // Determine which elements in the current active set are still greater than 9.\n            // These are the ones that need further division.\n            svbool_t gt_9_mask = svcmpgt_s32(current_pg_for_first_digit, first_digit_vec, 9);\n\n            // If no elements among the currently active ones are greater than 9,\n            // all numbers have been reduced to their first digit, so we can break early.\n            if (!svptest_any(current_pg_for_first_digit, gt_9_mask)) {\n                break;\n            }\n\n            // For elements where gt_9_mask is true, divide by 10.\n            // For elements where it's false, keep the current value (it's already a single digit).\n            first_digit_vec = svsel_s32(gt_9_mask, svdiv_s32_x(current_pg_for_first_digit, first_digit_vec, ten_sve), first_digit_vec);\n\n            // Update the predicate for the next iteration: only continue processing\n            // elements that were just divided (i.e., were > 9).\n            current_pg_for_first_digit = svand_b(current_pg_for_first_digit, gt_9_mask);\n        }\n        // Check if the extracted first digit is odd.\n        svbool_t cond3_first_digit_odd = svcmpne_s32(pg, svmod_s32_x(pg, first_digit_vec, 2), 0);\n\n        // Combine all three conditions using logical AND operations on predicates.\n        // The main predicate 'pg' is used to ensure only valid elements are considered.\n        svbool_t final_cond = svand_b(pg, cond1_gt_10, svand_b(pg, cond2_last_digit_odd, cond3_first_digit_odd));\n\n        // Count the number of active elements that satisfy all combined conditions.\n        count += svcntp_b32(pg, final_cond);\n\n        // Move to the next chunk of elements. svcntw() returns the number of 32-bit elements in an SVE vector.\n        i += svcntw();\n        // Generate the predicate for the next chunk.\n        pg = svwhilelt_b32(i, num_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int total_count = 0;\n    const int N = nums.size();\n    int i = 0;\n\n    // Constants as SVE vectors\n    svint32_t s32_10 = svdup_s32(10);\n    svint32_t s32_1 = svdup_s32(1);\n    svint32_t s32_2 = svdup_s32(2);\n\n    // Main loop for SVE processing\n    // Predicate for active lanes, covering elements from 'i' up to 'N'\n    svbool_t pg = svwhilelt_b32(i, N);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load data into an SVE vector\n        svint32_t numbers_vec = svld1_s32(pg, &nums[i]);\n\n        // Condition 1: number > 10\n        svbool_t cond1_pred = svcmpgt_s32(pg, numbers_vec, s32_10);\n\n        // Get absolute values for digit extraction (first and last digits are based on absolute value)\n        svint32_t abs_numbers_vec = svabs_s32(numbers_vec);\n\n        // Condition 3: Last digit is odd\n        // Calculate last digit: abs_number % 10\n        svint32_t last_digit_vec = svrem_s32(abs_numbers_vec, s32_10);\n        // Check if last_digit_vec is odd (last_digit_vec % 2 == 1)\n        svbool_t cond3_pred = svcmpeq_s32(pg, svrem_s32(last_digit_vec, s32_2), s32_1);\n\n        // Condition 2: First digit is odd\n        svint32_t first_digit_vec = abs_numbers_vec;\n        // Loop to repeatedly divide by 10 until the number is a single digit.\n        // The loop continues as long as any active element in 'first_digit_vec' is >= 10.\n        svbool_t first_digit_loop_pred = svcmpge_s32(pg, first_digit_vec, s32_10);\n        while (svptest_any(pg, first_digit_loop_pred)) {\n            // Divide only the lanes where first_digit_loop_pred is true\n            first_digit_vec = svdiv_s32(first_digit_loop_pred, first_digit_vec, s32_10);\n            // Update the predicate for the next iteration of the inner loop\n            first_digit_loop_pred = svcmpge_s32(pg, first_digit_vec, s32_10);\n        }\n        // Check if first_digit_vec is odd\n        svbool_t cond2_pred = svcmpeq_s32(pg, svrem_s32(first_digit_vec, s32_2), s32_1);\n\n        // Combine all three conditions using logical AND\n        svbool_t combined_pred = svand_b(cond1_pred, svand_b(cond2_pred, cond3_pred));\n\n        // Count the number of elements that satisfy all conditions\n        total_count += svcntp_b32(pg, combined_pred);\n\n        // Move to the next chunk of elements\n        i += svcntw(); // Increment by the actual vector length for int (word)\n        pg = svwhilelt_b32(i, N); // Update predicate for the next iteration\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c++\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count0 = 0;\n    uint64_t count1 = 0;\n\n    uint64_t i = 1;\n    svbool_t pg = svwhilelt_b64(i, n + 1);\n    do {\n        svuint64_t indices = svindex_u64(i, 1);\n\n        svuint64_t div3 = svdiv_u64_x(pg, indices, svdup_u64(3));\n        svuint64_t mul3 = svmul_u64_x(pg, div3, svdup_u64(3));\n        svuint64_t rem3 = svsub_u64_x(pg, indices, mul3);\n\n        svbool_t p_rem0 = svcmpeq_u64(pg, rem3, svdup_u64(0));\n        svbool_t p_rem1 = svcmpeq_u64(pg, rem3, svdup_u64(1));\n        svbool_t p_rem2 = svcmpeq_u64(pg, rem3, svdup_u64(2));\n\n        count0 += svcntp_b64(pg, p_rem2);\n        count1 += svcntp_b64(pg, p_rem0);\n        count1 += svcntp_b64(pg, p_rem1);\n\n        i += svcnt_u64();\n        pg = svwhilelt_b64(i, n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    auto combinations = [](uint64_t N) -> uint64_t {\n        if (N < 3) {\n            return 0;\n        }\n        return N * (N - 1) * (N - 2) / 6;\n    };\n\n    uint64_t total_triples = combinations(count0) + combinations(count1);\n\n    return total_triples;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n    // If n is less than 3, no triples can be formed.\n    if (n < 3) {\n        return 0;\n    }\n\n    // Analyze a[i] % 3:\n    // a[i] = i * i - i + 1 = i * (i - 1) + 1\n    //\n    // Let's examine a[i] modulo 3 based on i modulo 3:\n    // If i % 3 == 0: a[i] = (3m) * (3m - 1) + 1  => a[i] % 3 = 1\n    // If i % 3 == 1: a[i] = (3m + 1) * (3m) + 1  => a[i] % 3 = 1\n    // If i % 3 == 2: a[i] = (3m + 2) * (3m + 1) + 1 = (9m^2 + 9m + 2) + 1 = 9m^2 + 9m + 3 => a[i] % 3 = 0\n    //\n    // So, a[i] % 3 is 0 if i % 3 == 2.\n    // And a[i] % 3 is 1 if i % 3 == 0 or i % 3 == 1.\n\n    // We are looking for triples (a[i], a[j], a[k]) such that (a[i] + a[j] + a[k]) % 3 == 0.\n    // This is equivalent to (a[i]%3 + a[j]%3 + a[k]%3) % 3 == 0.\n    // Since a[x]%3 can only be 0 or 1, the only combinations of remainders that sum to 0 (mod 3) are:\n    // 1. (0, 0, 0) - all three elements have a remainder of 0 when divided by 3.\n    // 2. (1, 1, 1) - all three elements have a remainder of 1 when divided by 3.\n\n    // We need to count how many elements a[x] have remainder 0 (mod 3) and how many have remainder 1 (mod 3).\n    // Let count_rem0 be the number of a[x] such that a[x] % 3 == 0 (i.e., x % 3 == 2).\n    // Let count_rem1 be the number of a[x] such that a[x] % 3 == 1 (i.e., x % 3 == 0 or x % 3 == 1).\n\n    uint64_t count_rem0 = 0;\n    uint64_t count_rem1 = 0;\n\n    // Iterate through indices from 1 to n using SVE intrinsics to count in parallel.\n    // svcntd() returns the number of 64-bit elements in an SVE vector.\n    for (uint64_t i = 1; i <= n; /* i is updated inside the loop */) {\n        // Create a predicate for active lanes, covering indices from 'i' up to 'n'.\n        // svwhilelt_b64(base, limit) generates a predicate where lanes are active as long as base + lane_offset < limit.\n        // Here, base is 'i', and limit is 'n + 1' to include 'n'.\n        svbool_t pg = svwhilelt_b64(i, n + 1);\n\n        // If no lanes are active (i.e., 'i' has exceeded 'n'), we have processed all elements.\n        if (!svptest_any(svptrue_b64(), pg)) {\n            break;\n        }\n\n        // Generate a vector of indices starting from 'i': [i, i+1, i+2, ..., i + svcntd() - 1]\n        svuint64_t indices = svindex_u64(i, 1);\n\n        // Calculate (index % 3) for each active lane in parallel.\n        svuint64_t indices_mod_3 = svrem_u64(indices, svdup_u64(3));\n\n        // Create predicates for each remainder type (0, 1, or 2).\n        // svcmpeq_u64(predicate, vector_a, vector_b) compares elements of vector_a and vector_b\n        // under the control of 'predicate', returning a new predicate.\n        svbool_t p_mod_0 = svcmpeq_u64(pg, indices_mod_3, svdup_u64(0)); // Indices where i % 3 == 0\n        svbool_t p_mod_1 = svcmpeq_u64(pg, indices_mod_3, svdup_u64(1)); // Indices where i % 3 == 1\n        svbool_t p_mod_2 = svcmpeq_u64(pg, indices_mod_3, svdup_u64(2)); // Indices where i % 3 == 2\n\n        // Count elements for each remainder category based on the derived property:\n        // a[x] % 3 == 0 when x % 3 == 2\n        // svcntp_b64(predicate_all, predicate_specific) counts active elements in predicate_specific\n        // that are also active in predicate_all.\n        count_rem0 += svcntp_b64(pg, p_mod_2);\n        \n        // a[x] % 3 == 1 when x % 3 == 0 or x % 3 == 1\n        count_rem1 += svcntp_b64(pg, p_mod_0);\n        count_rem1 += svcntp_b64(pg, p_mod_1);\n\n        // Advance the starting index for the next vector chunk by the number of elements processed.\n        i += svcntd();\n    }\n\n    uint64_t total_triples = 0;\n\n    // Calculate combinations for (0, 0, 0) type triples: C(count_rem0, 3)\n    // The formula for combinations C(N, K) is N! / (K! * (N-K)!). For K=3, it's N * (N - 1) * (N - 2) / 6.\n    // Ensure count_rem0 is at least 3 to form a triple.\n    if (count_rem0 >= 3) {\n        total_triples += count_rem0 * (count_rem0 - 1) * (count_rem0 - 2) / 6;\n    }\n\n    // Calculate combinations for (1, 1, 1) type triples: C(count_rem1, 3)\n    // Ensure count_rem1 is at least 3 to form a triple.\n    if (count_rem1 >= 3) {\n        total_triples += count_rem1 * (count_rem1 - 1) * (count_rem1 - 2) / 6;\n    }\n\n    return total_triples;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\n// Helper function to calculate combinations C(N, 3)\n// This function is designed to prevent intermediate overflow for uint64_t\n// as long as the final result fits within uint64_t.\nstatic uint64_t combinations(uint64_t n_val) {\n    if (n_val < 3) {\n        return 0;\n    }\n    // C(N, 3) = N * (N - 1) * (N - 2) / (3 * 2 * 1)\n    // We divide by 3 and 2 strategically to avoid intermediate overflow.\n    // One of N, N-1, N-2 is divisible by 3.\n    // At least one of N, N-1 is divisible by 2.\n    \n    uint64_t term1 = n_val;\n    uint64_t term2 = n_val - 1;\n    uint64_t term3 = n_val - 2;\n\n    // Divide by 3\n    if (term1 % 3 == 0) {\n        term1 /= 3;\n    } else if (term2 % 3 == 0) {\n        term2 /= 3;\n    } else { // term3 % 3 == 0\n        term3 /= 3;\n    }\n\n    // Divide by 2\n    if (term1 % 2 == 0) {\n        term1 /= 2;\n    } else if (term2 % 2 == 0) {\n        term2 /= 2;\n    } else { // term3 % 2 == 0\n        term3 /= 2;\n    }\n\n    return term1 * term2 * term3;\n}\n\nuint64_t get_max_triples_simd(uint64_t n){\n    // Based on the analysis of a[i] = i*i - i + 1 modulo 3:\n    // a[i] % 3 = 1 if i % 3 == 0 or i % 3 == 1\n    // a[i] % 3 = 0 if i % 3 == 2\n    // There are no a[i] such that a[i] % 3 == 2.\n\n    // For a triple (a[i], a[j], a[k]) to sum to a multiple of 3,\n    // (a[i] % 3 + a[j] % 3 + a[k] % 3) % 3 must be 0.\n    // Given the possible remainders (0 and 1), the only valid combinations are:\n    // 1. (0, 0, 0) -> sum % 3 = 0\n    // 2. (1, 1, 1) -> sum % 3 = 3 -> sum % 3 = 0\n\n    // We need to count how many a[x] have remainder 0 and how many have remainder 1.\n    uint64_t count0 = 0; // Count of a[x] such that a[x] % 3 == 0 (i.e., x % 3 == 2)\n    uint64_t count1 = 0; // Count of a[x] such that a[x] % 3 == 1 (i.e., x % 3 == 0 or x % 3 == 1)\n\n    // Use SVE intrinsics to count efficiently\n    uint64_t i = 1;\n    while (i <= n) {\n        // Get a predicate for active lanes (up to n)\n        svbool_t pg = svwhilelt_b64(i, n + 1);\n        \n        // Get the current vector length (number of active lanes)\n        // This is not strictly needed for the loop control but useful for understanding.\n        // uint64_t vl = svcntd(); \n\n        // Generate a vector of indices: [i, i+1, i+2, ..., i+VL-1]\n        svuint64_t indices = svindex_u64(i, 1);\n\n        // Calculate indices % 3 for each element in the vector.\n        // SVE does not have a direct modulo intrinsic, so we use division, multiplication, and subtraction.\n        svuint64_t div_by_3 = svdiv_u64(pg, indices, svdup_u64(3));\n        svuint64_t mul_by_3 = svmul_u64(pg, div_by_3, svdup_u64(3));\n        svuint64_t rem_idx = svsub_u64(pg, indices, mul_by_3);\n\n        // Create a mask for indices where (index % 3 == 2), which corresponds to a[index] % 3 == 0\n        svbool_t mask_i_rem2 = svcmpeq_u64(pg, rem_idx, svdup_u64(2));\n        count0 += svcntp_b(pg, mask_i_rem2); // Add count of active lanes in this mask\n\n        // Create masks for indices where (index % 3 == 0) or (index % 3 == 1),\n        // which corresponds to a[index] % 3 == 1\n        svbool_t mask_i_rem0 = svcmpeq_u64(pg, rem_idx, svdup_u64(0));\n        svbool_t mask_i_rem1 = svcmpeq_u64(pg, rem_idx, svdup_u64(1));\n        svbool_t mask_i_rem0_or_rem1 = svorr_b(mask_i_rem0, mask_i_rem1);\n        count1 += svcntp_b(pg, mask_i_rem0_or_rem1); // Add count of active lanes in this mask\n\n        // Advance the starting index for the next vector iteration\n        i += svcntd(); // Use svcntd() to get the actual vector length\n    }\n\n    // Calculate the number of ways to choose 3 elements from count0 and count1\n    // and sum them up.\n    return combinations(count0) + combinations(count1);\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0; // Not enough elements to form a triple\n    }\n\n    uint64_t count_mod_0 = 0; // Count of a[i] such that a[i] % 3 == 0\n    uint64_t count_mod_1 = 0; // Count of a[i] such that a[i] % 3 == 1\n\n    // Loop through indices i from 1 to n using SVE\n    for (uint64_t i = 1; i <= n; ) {\n        // Get a predicate for the current vector length, processing up to n\n        svbool_t pg = svwhilelt_b64(i, n + 1);\n        uint64_t vl = svcntp_b64(pg); // Number of active lanes in the current vector\n\n        if (vl == 0) {\n            break; // No more elements to process\n        }\n\n        // Generate a vector of indices: i, i+1, i+2, ...\n        svuint64_t indices = svindex_u64(i, 1);\n\n        // Calculate a[idx] = idx * idx - idx + 1 for each index in the vector\n        // This is equivalent to idx * (idx - 1) + 1\n        svuint64_t idx_minus_1 = svsub_u64_x(pg, indices, svdup_u64(1));\n        svuint64_t term_product = svmul_u64_x(pg, indices, idx_minus_1);\n        svuint64_t a_values = svadd_u64_x(pg, term_product, svdup_u64(1));\n\n        // Calculate a_values % 3 for each element\n        svuint64_t remainders = svmod_u64_x(pg, a_values, svdup_u64(3));\n\n        // Count elements where remainder is 0\n        svbool_t is_zero_mod_3 = svcmpeq_u64(pg, remainders, svdup_u64(0));\n        count_mod_0 += svcntp_b64(is_zero_mod_3);\n\n        // Count elements where remainder is 1\n        svbool_t is_one_mod_3 = svcmpeq_u64(pg, remainders, svdup_u64(1));\n        count_mod_1 += svcntp_b64(is_one_mod_3);\n\n        // Advance the starting index for the next iteration\n        i += vl;\n    }\n\n    // The sum (a[i] + a[j] + a[k]) is a multiple of 3 if:\n    // 1. All three a[x] are 0 mod 3 (0+0+0 = 0 mod 3)\n    // 2. All three a[x] are 1 mod 3 (1+1+1 = 3 = 0 mod 3)\n    // Other combinations (e.g., 0+0+1, 0+1+1) do not sum to 0 mod 3.\n\n    uint64_t total_triples = 0;\n\n    // Calculate combinations for elements that are 0 mod 3\n    if (count_mod_0 >= 3) {\n        total_triples += count_mod_0 * (count_mod_0 - 1) * (count_mod_0 - 2) / 6;\n    }\n\n    // Calculate combinations for elements that are 1 mod 3\n    if (count_mod_1 >= 3) {\n        total_triples += count_mod_1 * (count_mod_1 - 1) * (count_mod_1 - 2) / 6;\n    }\n\n    return total_triples;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0; // Not enough elements to form a triple\n    }\n\n    uint64_t count0 = 0; // Count of a[i] such that a[i] % 3 == 0\n    uint64_t count1 = 0; // Count of a[i] such that a[i] % 3 == 1\n\n    // Pre-duplicate scalar values into SVE vectors for efficiency\n    svuint64_t one_vec = svdup_u64(1);\n    svuint64_t three_vec = svdup_u64(3);\n    svuint64_t zero_vec = svdup_u64(0);\n\n    // Loop through i from 1 to n using SVE intrinsics\n    for (uint64_t i = 1; i <= n; i += svcntd()) {\n        // Create a predicate for elements within bounds [i, n]\n        svbool_t pg = svwhilelt_b64(i, n + 1);\n\n        // Generate a vector of indices: [i, i+1, ..., i+VL-1]\n        svuint64_t current_indices = svindex_u64(i, 1);\n\n        // Calculate a[idx] = idx * idx - idx + 1 for each active index\n        // a[idx] = idx * (idx - 1) + 1\n        svuint64_t idx_minus_1 = svsub_u64_z(pg, current_indices, one_vec);\n        svuint64_t term_i_i_minus_1 = svmul_u64_z(pg, current_indices, idx_minus_1);\n        svuint64_t a_val_vec = svadd_u64_z(pg, term_i_i_minus_1, one_vec);\n\n        // Calculate a_val_vec % 3 for each active element\n        svuint64_t a_val_div_3 = svdiv_u64_z(pg, a_val_vec, three_vec);\n        svuint64_t a_val_mod_3 = svsub_u64_z(pg, a_val_vec, svmul_u64_z(pg, a_val_div_3, three_vec));\n\n        // Create predicates for a_val_vec % 3 == 0 and a_val_vec % 3 == 1\n        svbool_t p_mod0 = svcmpeq_u64(pg, a_val_mod_3, zero_vec);\n        svbool_t p_mod1 = svcmpeq_u64(pg, a_val_mod_3, one_vec);\n\n        // Count active elements for each remainder category\n        count0 += svcntp_b(pg, p_mod0);\n        count1 += svcntp_b(pg, p_mod1);\n    }\n\n    // Calculate the number of triples (N choose 3) for each count\n    uint64_t result = 0;\n\n    // C(N, 3) = N * (N - 1) * (N - 2) / 6\n    if (count0 >= 3) {\n        result += count0 * (count0 - 1) * (count0 - 2) / 6;\n    }\n    if (count1 >= 3) {\n        result += count1 * (count1 - 1) * (count1 - 2) / 6;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>   // For sqrt\n#include <stdbool.h> // For bool type\n\n// Helper function to check primality using SVE for trial division\nstatic bool is_prime_sve_helper(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true; // 2 and 3 are prime\n\n    // Check divisibility by 2 and 3 (scalar check)\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Optimized trial division using SVE\n    // Check divisors of the form 6k +/- 1\n    int limit = (int)sqrt(n);\n    int current_divisor_base = 5; // Start with 5 (for 6k-1 and 6k+1 sequence)\n\n    // Duplicate n into a vector for SVE operations\n    svint32_t vn = svdup_s32(n);\n\n    while (true) {\n        // Generate a vector of divisors starting from current_divisor_base with a step of 6\n        // This covers divisors of the form 6k-1 (e.g., 5, 11, 17, ...)\n        svint32_t v_divisors_6k_minus_1 = svindex_s32(current_divisor_base, 6);\n\n        // Create a predicate for active lanes for the first set of divisors.\n        // Only lanes where the divisor is less than or equal to the limit are active.\n        svbool_t pg_active_div1 = svwhilelt_b32(v_divisors_6k_minus_1, svdup_s32(limit + 1));\n        \n        // If no lanes are active in this batch, it means all relevant divisors have been checked.\n        if (!svptest_any(svptrue_b32(), pg_active_div1)) {\n            break;\n        }\n\n        // Perform parallel modulo check for the first set of divisors: (n / divisor) * divisor == n\n        svint32_t v_div_res1 = svdiv_s32(pg_active_div1, vn, v_divisors_6k_minus_1);\n        svint32_t v_mul_res1 = svmul_s32(pg_active_div1, v_div_res1, v_divisors_6k_minus_1);\n        svbool_t p_rem_zero1 = svcmpeq_s32(pg_active_div1, v_mul_res1, vn);\n\n        // If any active lane has a remainder of zero, n is not prime\n        if (svptest_any(pg_active_div1, p_rem_zero1)) {\n            return false;\n        }\n\n        // Generate the second set of divisors (6k+1 form) by adding 2 to the first set.\n        // This covers divisors like 7, 13, 19, ...\n        svint32_t v_divisors_6k_plus_1 = svadd_s32_x(pg_active_div1, v_divisors_6k_minus_1, svdup_s32(2));\n\n        // Create a predicate for active lanes for the second set of divisors.\n        svbool_t pg_active_div2 = svwhilelt_b32(v_divisors_6k_plus_1, svdup_s32(limit + 1));\n        \n        // Perform parallel modulo check for the second set of divisors\n        svint32_t v_div_res2 = svdiv_s32(pg_active_div2, vn, v_divisors_6k_plus_1);\n        svint32_t v_mul_res2 = svmul_s32(pg_active_div2, v_div_res2, v_divisors_6k_plus_1);\n        svbool_t p_rem_zero2 = svcmpeq_s32(pg_active_div2, v_mul_res2, vn);\n\n        // If any active lane has a remainder of zero, n is not prime\n        if (svptest_any(pg_active_div2, p_rem_zero2)) {\n            return false;\n        }\n\n        // Advance current_divisor_base for the next batch of divisors.\n        // Each iteration processes `svcntw()` divisors of the 6k-1 form and `svcntw()` of the 6k+1 form.\n        // The step for the base is `svcntw() * 6`.\n        current_divisor_base += svcntw() * 6;\n    }\n\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    if (is_prime_sve_helper(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\n#include <cmath> // Required for sqrt\n\nint x_or_y_simd(int n, int x, int y) {\n    bool is_prime = true;\n\n    if (n <= 1) {\n        is_prime = false;\n    } else if (n <= 3) { // 2 and 3 are prime\n        is_prime = true;\n    } else if (n % 2 == 0 || n % 3 == 0) { // Handle multiples of 2 and 3\n        is_prime = false;\n    } else {\n        // For n > 3 and not divisible by 2 or 3, check odd divisors from 5 up to sqrt(n)\n        // using SVE intrinsics.\n        svint32_t sv_n_vec = svdup_n_s32(n);\n        svint32_t sv_zero = svdup_n_s32(0);\n        int limit = static_cast<int>(sqrt(n));\n\n        // Loop through potential divisors in batches using SVE.\n        // The loop condition (long long)i * i <= n is more robust against overflow\n        // and ensures we only check up to sqrt(n).\n        for (int i = 5; (long long)i * i <= n; i += svcntw() * 2) {\n            // Generate a vector of odd divisors: i, i+2, i+4, ...\n            svint32_t sv_divisors = svindex_s32(i, 2);\n\n            // Create a predicate for active elements (divisors <= limit).\n            // Only elements within the sqrt(n) bound are relevant.\n            svbool_t pg = svcmple_s32(svptrue_b32(), sv_divisors, svdup_n_s32(limit));\n\n            // Compute n % divisor for active elements.\n            // _z variant zeros out inactive elements, which is fine for comparison.\n            svint32_t sv_rem = svrem_s32_z(pg, sv_n_vec, sv_divisors);\n\n            // Check if any active remainder is zero.\n            svbool_t sv_is_divisible = svcmpeq_s32(pg, sv_rem, sv_zero);\n\n            // If any divisor results in a zero remainder, n is not prime.\n            if (svptest_any(sv_is_divisible)) {\n                is_prime = false;\n                break;\n            }\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>   // Required for sqrt\n#include <stdbool.h> // Required for bool type\n\n// Helper function to determine if a number is prime using SVE intrinsics.\n// This function parallelizes the divisor checking loop.\nstatic bool is_prime_sve_impl(int n) {\n    // Handle base cases for primality\n    if (n <= 1) return false;\n    if (n <= 3) return true; // 2 and 3 are prime\n\n    // Quickly eliminate multiples of 2 and 3\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Broadcast the number 'n' into an SVE vector of 32-bit integers\n    svint32_t sv_n = svdup_n_s32(n);\n\n    // Determine the maximum divisor to check.\n    // For primality test, we only need to check divisors up to sqrt(n).\n    // Cast n to double for sqrt function, then cast result back to int.\n    int max_divisor = (int)sqrt((double)n);\n\n    // Get the number of 32-bit elements (lanes) in an SVE vector for the current system.\n    int vl = svcntw();\n\n    // Loop through potential divisors in chunks of 'vl' (vector length).\n    // Start checking from 5, as 2 and 3 have already been handled.\n    for (int i = 5; i <= max_divisor; i += vl) {\n        // Generate a vector of consecutive integers starting from 'i'.\n        // For example, if i=5 and vl=4, sv_divisors will be [5, 6, 7, 8].\n        svint32_t sv_divisors = svindex_s32(i, 1);\n\n        // Create a predicate for active lanes.\n        // A lane is active if its corresponding divisor is less than or equal to max_divisor.\n        // svwhilelt_b32(a, b) generates a predicate where elements are active as long as a[i] < b.\n        // So, `divisor <= max_divisor` is equivalent to `divisor < max_divisor + 1`.\n        svbool_t pg = svwhilelt_b32(sv_divisors, svdup_n_s32(max_divisor + 1));\n\n        // If no lanes are active under this predicate, it means all relevant divisors\n        // have been checked or are beyond the current 'i' range.\n        if (svptest_n(svptrue_b32(), pg) == 0) {\n            break; // No more divisors to check within the limit\n        }\n\n        // Perform vectorized integer division: sv_n / sv_divisors.\n        // This operation is masked by 'pg', meaning only active lanes perform the division.\n        svint32_t sv_quotient = svdiv_s32(pg, sv_n, sv_divisors);\n\n        // Perform vectorized integer multiplication: sv_quotient * sv_divisors.\n        // This calculates (n / divisor) * divisor for each active lane.\n        svint32_t sv_product = svmul_s32(pg, sv_quotient, sv_divisors);\n\n        // Check if n == (n / divisor) * divisor for any active lane.\n        // This condition is true if 'n' is perfectly divisible by 'divisor' (i.e., n % divisor == 0).\n        svbool_t sv_is_divisor = svcmpeq_s32(pg, sv_n, sv_product);\n\n        // If svptest_any returns true, it means at least one active lane found a divisor.\n        // In this case, 'n' is not a prime number.\n        if (svptest_any(svptrue_b32(), sv_is_divisor)) {\n            return false;\n        }\n    }\n\n    // If the loop completes without finding any divisors, 'n' is prime.\n    return true;\n}\n\n// Main function as per the problem description.\n// It returns x if n is prime, and y otherwise, using the SVE-accelerated primality test.\nint x_or_y_simd(int n, int x, int y) {\n    if (is_prime_sve_impl(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Step 1: Determine if n is a prime number (scalar operation)\n    // This part is inherently scalar as we are checking a single integer 'n'.\n    // SVE is designed for data parallelism, operating on multiple data elements.\n    // For a single scalar 'n', the primality test itself cannot be fully vectorized\n    // in a meaningful way to achieve performance benefits over a scalar loop.\n    bool is_prime;\n    if (n <= 1) {\n        is_prime = false;\n    } else if (n <= 3) { // 2 and 3 are prime\n        is_prime = true;\n    } else if (n % 2 == 0 || n % 3 == 0) { // Multiples of 2 or 3 (for n > 3)\n        is_prime = false;\n    } else {\n        // Check for divisors from 5 onwards, incrementing by 6 (i.e., i, i+2)\n        // This optimization skips multiples of 2 and 3.\n        is_prime = true; // Assume prime until a divisor is found\n        for (int i = 5; (long long)i * i <= n; i = i + 6) {\n            if (n % i == 0 || n % (i + 2) == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    }\n\n    // Step 2: Use SVE intrinsics for the conditional selection of x or y.\n    // This part demonstrates the use of SVE for conditional logic, even for a scalar result.\n\n    // Duplicate x into all lanes of an SVE vector.\n    svint32_t sv_x = svdup_s32(x);\n\n    // Duplicate y into all lanes of an SVE vector.\n    svint32_t sv_y = svdup_s32(y);\n\n    // Create an SVE predicate based on the 'is_prime' boolean.\n    // If 'is_prime' is true, the predicate will have all lanes active (true).\n    // If 'is_prime' is false, the predicate will have all lanes inactive (false).\n    svbool_t prime_predicate = is_prime ? svptrue_b32() : svpfalse_b32();\n\n    // Use svsel_s32 to select elements.\n    // Where 'prime_predicate' is true, select from sv_x.\n    // Where 'prime_predicate' is false, select from sv_y.\n    // Since the predicate is uniform (all true or all false), the resulting vector\n    // 'final_vec' will contain either all 'x's or all 'y's.\n    svint32_t final_vec = svsel_s32(prime_predicate, sv_x, sv_y);\n\n    // Extract the scalar result from the first lane of the 'final_vec'.\n    // Since all lanes of 'final_vec' contain the same value (either x or y),\n    // extracting any lane will yield the correct result.\n    return svqdups_s32(final_vec, 0);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h> // Required for sqrt\n\n// Helper function to check if a number is prime (scalar implementation)\nstatic bool is_prime_scalar(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true; // 2 and 3 are prime\n    if (num % 2 == 0 || num % 3 == 0) return false; // Multiples of 2 or 3 are not prime\n\n    // Check for divisors from 5 onwards, skipping multiples of 2 and 3\n    // (i.e., check numbers of the form 6k \u00b1 1)\n    for (int i = 5; (long long)i * i <= num; i = i + 6) {\n        if (num % i == 0 || num % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    // Determine if n is a prime number using the scalar helper function\n    bool n_is_prime = is_prime_scalar(n);\n\n    // Broadcast x and y into SVE vectors\n    svint32_t sv_x = svdup_s32(x);\n    svint32_t sv_y = svdup_s32(y);\n\n    // Create an SVE predicate based on the primality of n\n    // If n is prime, the predicate will be all true.\n    // If n is not prime, the predicate will be all false.\n    svbool_t pg;\n    if (n_is_prime) {\n        pg = svptrue_b32(); // All lanes active and true\n    } else {\n        pg = svpfalse_b32(); // All lanes active and false\n    }\n\n    // Use svsel to conditionally select elements from sv_x or sv_y based on the predicate.\n    // If a lane's predicate is true, the corresponding element from sv_x is chosen.\n    // If a lane's predicate is false, the corresponding element from sv_y is chosen.\n    // Since the predicate is uniform (all true or all false), all lanes of result_vec\n    // will contain either x or y.\n    svint32_t result_vec = svsel_s32(pg, sv_x, sv_y);\n\n    // Extract the final scalar result from the first lane of the SVE vector.\n    return svget_lane_s32(result_vec, 0);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    // Initialize an SVE vector for accumulating sums.\n    // All lanes are initialized to 0.0f.\n    svfloat32_t sum_vec = svdup_f32(svptrue_b32(), 0.0f);\n\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Loop through the input vector in chunks of SVE vector length (VL).\n    // svwhilelt_b32 generates a predicate for the current chunk,\n    // ensuring we don't read past the end of the vector.\n    do {\n        // Generate a predicate for the current chunk of elements.\n        // `pg` will be true for elements within the vector bounds [i, n).\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // If no lanes are active (i.e., we've processed all elements), break the loop.\n        if (!svptest_any(svptrue_b32(), pg)) {\n            break;\n        }\n\n        // Load a vector of float values from the input list using the generated predicate.\n        svfloat32_t current_vec = svld1_f32(pg, &lst[i]);\n\n        // --- Predicate generation for filtering elements ---\n\n        // 1. Check if the number is positive (> 0.0f).\n        svbool_t pg_positive = svcmpgt_f32(pg, current_vec, svdup_f32(svptrue_b32(), 0.0f));\n\n        // 2. Check if the number is an integer (x == truncf(x)).\n        // svrintz_f32 performs truncation (rounds towards zero).\n        svfloat32_t truncated_vec = svrintz_f32(pg, current_vec);\n        svbool_t pg_is_integer = svcmpeq_f32(pg, current_vec, truncated_vec);\n\n        // 3. Check if the integer number is odd ((int)x % 2 != 0).\n        // Convert float to signed 32-bit integer.\n        svint32_t int_vec = svcvt_s32_f32(pg, current_vec);\n        // Perform bitwise AND with 1 to check the least significant bit.\n        // For odd numbers, (x & 1) will be 1. For even numbers, it will be 0.\n        svint32_t odd_check_result = svand_s32(pg, int_vec, svdup_s32(svptrue_b32(), 1));\n        // Compare the result with 1 to identify odd numbers.\n        svbool_t pg_is_odd = svcmpeq_s32(pg, odd_check_result, svdup_s32(svptrue_b32(), 1));\n\n        // Combine all predicates: (positive AND is_integer AND is_odd).\n        svbool_t pg_combined = svand_b(pg_positive, svand_b(pg_is_integer, pg_is_odd));\n\n        // --- Calculate squares for qualifying elements and accumulate ---\n\n        // Calculate the square of each number in the current vector.\n        svfloat32_t squared_values = svmul_f32(current_vec, current_vec);\n\n        // Select the squared value if the combined predicate is true for a lane,\n        // otherwise, select 0.0f for that lane.\n        svfloat32_t masked_squared_values = svsel_f32(pg_combined, squared_values, svdup_f32(svptrue_b32(), 0.0f));\n\n        // Add the masked squared values to the accumulating sum vector.\n        sum_vec = svadd_f32(sum_vec, masked_squared_values);\n\n        // Advance the index by the number of 32-bit elements (floats) in an SVE vector.\n        i += svcntw();\n\n    } while (i < n); // Continue as long as there are elements left to process.\n\n    // Horizontally sum all elements in the accumulation vector to get the final float sum.\n    // svptrue_b32() ensures all lanes in sum_vec are included in the reduction.\n    float final_float_sum = svaddv_f32(svptrue_b32(), sum_vec);\n\n    // Convert the final float sum to uint64_t as required by the function signature.\n    // Note: This cast truncates any fractional part and assumes the sum fits in uint64_t.\n    uint64_t total_scalar_sum = static_cast<uint64_t>(final_float_sum);\n\n    return total_scalar_sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector> // Required for std::vector\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Initialize an SVE vector for accumulating sums of squares.\n    // Use svuint64_t to match the final return type and handle potentially large sums.\n    svuint64_t sum_vec = svdup_u64(0);\n\n    // Loop through the input vector in chunks determined by SVE vector length for 32-bit elements.\n    // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n    while (i < n) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b32(i, n) generates a predicate where lanes are active\n        // as long as the element index (starting from i) is less than n.\n        // This correctly handles the tail (remaining elements) of the vector.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a vector of float values from the input list.\n        svfloat32_t vec_f32 = svld1_f32(pg, &lst[i]);\n\n        // 1. Create a predicate for positive numbers (value > 0).\n        svbool_t p_positive = svcmpgt_f32(pg, vec_f32, svdup_f32(0.0f));\n\n        // 2. Create a predicate for integer numbers.\n        // An efficient way to check if a float is an integer is to compare it\n        // with its truncated value (round towards zero). If they are equal, it's an integer.\n        svfloat32_t rounded_f32 = svrintz_f32(pg, vec_f32);\n        svbool_t p_is_integer = svcmpeq_f32(pg, vec_f32, rounded_f32);\n\n        // 3. Create a predicate for odd integers.\n        // First, convert the float values to signed 32-bit integers.\n        // svcvtzs_s32_f32 truncates towards zero.\n        svint32_t int_val = svcvtzs_s32_f32(pg, vec_f32);\n        // An integer is odd if its least significant bit is 1.\n        // Perform bitwise AND with 1 and compare the result with 1.\n        svbool_t p_is_odd = svcmpeq_s32(pg, svand_s32(pg, int_val, svdup_s32(1)), svdup_s32(1));\n\n        // Combine all conditions into a single active predicate:\n        // (positive AND is_integer) AND is_odd\n        svbool_t p_active = svand_b(pg, p_positive, p_is_integer);\n        p_active = svand_b(pg, p_active, p_is_odd);\n\n        // Square the numbers for lanes where p_active is true.\n        // For inactive lanes, the result will be 0.0f due to the predicate.\n        svfloat32_t squared_f32 = svmul_f32(p_active, vec_f32, vec_f32);\n\n        // Convert the squared float values to uint64_t for accumulation.\n        // SVE ACLE does not provide a direct float32 to uint64_t conversion.\n        // Promote to float64 first, then convert to uint64_t.\n        // For inactive lanes, squared_f32 is 0.0f, so squared_f64 will be 0.0, and squared_u64_converted will be 0.\n        svfloat64_t squared_f64 = svcvtf_f64_f32(p_active, squared_f32);\n        svuint64_t squared_u64_converted = svcvtzs_u64_f64(p_active, squared_f64);\n\n        // Accumulate the squared uint64_t values into the sum_vec.\n        // We use the original predicate 'pg' for the addition, as 'squared_u64_converted'\n        // already contains zeros for elements that did not meet the criteria.\n        sum_vec = svadd_u64_x(pg, sum_vec, squared_u64_converted);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        i += svcntw();\n    }\n\n    // Perform a horizontal reduction (summation) of all elements in the sum_vec.\n    // svptrue_b64() creates a predicate where all 64-bit lanes are active.\n    total_sum = svaddv_u64(svptrue_b64(), sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // For floorf, fmodf if needed, but SVE intrinsics handle conversion.\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    // Initialize SVE accumulator for 64-bit unsigned integers\n    svuint64_t sv_sum_acc = svdup_n_u64(0);\n\n    // Loop through the input vector in chunks of svcntw() (number of 32-bit elements per SVE vector).\n    // svcntw() is VL/4 (Vector Length / 4 bytes per 32-bit element).\n    // svcntd() is VL/8 (Vector Length / 8 bytes per 64-bit element).\n    // Therefore, svcntw() is 2 * svcntd().\n    // We process svcntw() floats at a time, then split them into two halves for 64-bit operations.\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        // 1. Generate predicate for the current chunk of float elements.\n        // This predicate ensures we only process valid elements up to lst.size().\n        svbool_t pg_f32 = svwhilelt_b32(i, lst.size());\n\n        // 2. Load float data into an SVE vector.\n        svfloat32_t sv_data = svld1(pg_f32, &lst[i]);\n\n        // 3. Filter: Check if numbers are positive (x > 0).\n        svfloat32_t sv_zero_f32 = svdup_n_f32(0.0f);\n        svbool_t is_positive = svcmpgt(pg_f32, sv_data, sv_zero_f32);\n\n        // 4. Filter: Check if numbers are integers (x == (float)(int)x).\n        // Convert float to int32_t (this truncates decimal parts).\n        svint32_t sv_int_data = svcvt_s32_f32_x(pg_f32, sv_data);\n        // Convert the int32_t back to float.\n        svfloat32_t sv_float_from_int = svcvt_f32_s32_x(pg_f32, sv_int_data);\n        // Compare the original float with the float converted from int. If they are equal, it was an exact integer.\n        svbool_t is_integer = svcmpeq(pg_f32, sv_data, sv_float_from_int);\n\n        // Combine positive and integer predicates.\n        svbool_t combined_pred_b32 = svand_b(is_positive, is_integer);\n\n        // 5. Filter: Check if numbers are odd (x % 2 != 0).\n        svint32_t sv_one_s32 = svdup_n_s32(1);\n        svint32_t sv_two_s32 = svdup_n_s32(2);\n        // Calculate modulo 2 for elements that passed the combined predicate.\n        svint32_t sv_mod_two = svmod_s32_x(combined_pred_b32, sv_int_data, sv_two_s32);\n        // Check if the result of modulo 2 is 1 (indicating an odd number).\n        svbool_t is_odd = svcmpeq(combined_pred_b32, sv_mod_two, sv_one_s32);\n\n        // Final predicate for elements that are positive, integer, AND odd.\n        svbool_t final_pred_b32 = svand_b(combined_pred_b32, is_odd);\n\n        // 6. Process in two halves.\n        // An svint32_t vector contains svcntw() elements (VL/4).\n        // An svuint64_t vector contains svcntd() elements (VL/8).\n        // Since svcntw() is twice svcntd(), we need to process the svint32_t vector in two parts\n        // to convert to svuint64_t and perform 64-bit operations.\n        // svget_s32 and svget_b32 extract sub-vectors of svcntd() elements.\n\n        // Part 1: Process the first half of the 32-bit elements.\n        // Extract the first sub-vector of int32_t data.\n        svint32_t sv_int_data_part1 = svget_s32(sv_int_data, 0);\n        // Extract the corresponding predicate for this sub-vector.\n        svbool_t final_pred_b32_part1 = svget_b32(final_pred_b32, 0);\n        \n        // Convert the active int32_t elements to uint64_t.\n        // The predicate (final_pred_b32_part1) applies to the 32-bit input elements.\n        svuint64_t sv_u64_data_part1 = svcvt_u64_s32_x(final_pred_b32_part1, sv_int_data_part1);\n        \n        // Reinterpret the 32-bit predicate (for VL/8 elements) as a 64-bit predicate (for VL/8 elements).\n        // This is valid as the bitmask for the active lanes is the same.\n        svbool_t pg_u64_part1 = svreinterpret_b64_b32(final_pred_b32_part1);\n        \n        // Calculate squares (x*x) for the active uint64_t elements.\n        svuint64_t sv_squares_part1 = svmul_u64_x(pg_u64_part1, sv_u64_data_part1, sv_u64_data_part1);\n        \n        // Accumulate the squares to the running sum vector.\n        sv_sum_acc = svadd_u64_x(pg_u64_part1, sv_sum_acc, sv_squares_part1);\n\n        // Part 2: Process the second half of the 32-bit elements.\n        // Extract the second sub-vector of int32_t data.\n        svint32_t sv_int_data_part2 = svget_s32(sv_int_data, 1);\n        // Extract the corresponding predicate for this sub-vector.\n        svbool_t final_pred_b32_part2 = svget_b32(final_pred_b32, 1);\n\n        // Convert the active int32_t elements to uint64_t.\n        svuint64_t sv_u64_data_part2 = svcvt_u64_s32_x(final_pred_b32_part2, sv_int_data_part2);\n        \n        // Reinterpret the 32-bit predicate as a 64-bit predicate.\n        svbool_t pg_u64_part2 = svreinterpret_b64_b32(final_pred_b32_part2);\n        \n        // Calculate squares for the active uint64_t elements.\n        svuint64_t sv_squares_part2 = svmul_u64_x(pg_u64_part2, sv_u64_data_part2, sv_u64_data_part2);\n        \n        // Accumulate the squares to the running sum vector.\n        sv_sum_acc = svadd_u64_x(pg_u64_part2, sv_sum_acc, sv_squares_part2);\n    }\n\n    // 7. Horizontal reduction: Sum all elements in the accumulator vector to get the final scalar sum.\n    // The predicate for svaddv_u64 should cover all active lanes in the accumulator vector.\n    // svcntd() is the number of elements in an svuint64_t vector.\n    total_sum = svaddv_u64(svwhilelt_b64(0, svcntd()), sv_sum_acc);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint> // For uint64_t\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    // If the input vector is empty, return 0 as per the requirement.\n    if (lst.empty()) {\n        return 0;\n    }\n\n    // Initialize an SVE vector for accumulating the sum of squares.\n    // We use svuint64_t to accumulate the sum, as the final result is uint64_t.\n    svuint64_t final_sum_vec = svdup_u64(0ULL);\n\n    size_t i = 0;\n    size_t N = lst.size();\n\n    // Loop through the input vector in chunks determined by the SVE vector length.\n    // svcntw() returns the number of 32-bit elements (like float) in an SVE vector.\n    while (i < N) {\n        // Create a predicate for the current chunk of elements.\n        // svwhilelt_b32 generates a predicate for 32-bit elements, ensuring we don't\n        // process elements beyond the vector's bounds.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load a vector of float32 elements from the input list.\n        svfloat32_t vec_f32 = svld1(pg, &lst[i]);\n\n        // --- Filtering Conditions ---\n\n        // 1. Check if the number is positive (x > 0).\n        svbool_t is_positive = svcmpgt(pg, vec_f32, svdup_f32(0.0f));\n\n        // 2. Check if the number is an integer.\n        // Convert the float to a signed 32-bit integer, truncating towards zero.\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec_f32);\n        // Convert the integer back to a float.\n        svfloat32_t reconverted_vec_f32 = svcvt_f32_s32_z(pg, int_vec);\n        // Compare the original float with the reconverted float. If they are equal,\n        // it means the original float was an integer representable by int32_t.\n        svbool_t is_integer = svcmpeq(pg, vec_f32, reconverted_vec_f32);\n\n        // 3. Check if the integer is odd.\n        // Perform a bitwise AND with 1 on the integer representation.\n        // If the result is not zero, the number is odd.\n        svbool_t is_odd = svcmpne(pg, svand(int_vec, svdup_s32(1)), svdup_s32(0));\n\n        // Combine all conditions: the number must be positive AND an integer AND odd.\n        svbool_t combined_pred = svand_b(is_positive, svand_b(is_integer, is_odd));\n\n        // --- Conditional Square and Accumulate ---\n\n        // Convert the float32 vector to float64 for higher precision during squaring.\n        // The _z suffix means that lanes where the predicate 'combined_pred' is false\n        // will have their corresponding elements in 'vec_f64' set to 0.0.\n        svfloat64_t vec_f64 = svcvt_f64_f32_z(combined_pred, vec_f32);\n\n        // Square the numbers conditionally.\n        // The _x suffix means that the operation is performed only where 'combined_pred' is true.\n        // For false predicate lanes, the result will be 0.0 (since vec_f64 was zeroed).\n        svfloat64_t squared_val_f64 = svmul_f64_x(combined_pred, vec_f64, vec_f64);\n\n        // Convert the squared float64 values to uint64_t.\n        // Again, _z ensures that lanes where 'combined_pred' is false result in 0ULL.\n        svuint64_t squared_u64 = svcvt_u64_f64_z(combined_pred, squared_val_f64);\n\n        // Accumulate the squared uint64_t values into the sum vector.\n        // svptrue_b64() creates an all-true predicate for 64-bit elements.\n        // We add unconditionally because `squared_u64` already contains 0 for elements\n        // that did not meet the filtering criteria.\n        final_sum_vec = svadd_u64_x(svptrue_b64(), final_sum_vec, squared_u64);\n\n        // Advance the index by the number of 32-bit elements processed in this iteration.\n        i += svcntw();\n    }\n\n    // Reduce the SVE sum vector to a single scalar uint64_t sum.\n    // svaddv_u64 sums all elements of the svuint64_t vector.\n    uint64_t total_sum = svaddv_u64(svptrue_b64(), final_sum_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath> // For truncf\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t N = lst.size();\n    if (N == 0) {\n        return 0;\n    }\n\n    // Initialize a scalable vector register for accumulating the sum of squares.\n    // This vector will hold partial sums for each lane.\n    // svuint64_t has VL/8 elements.\n    svuint64_t total_sum_vec = svdup_u64(0);\n\n    // Get the number of 32-bit elements (floats) that fit in a vector.\n    // This is VL/4.\n    size_t sv_float_vec_len = svcntw();\n\n    // Loop through the input list in chunks of sv_float_vec_len floats.\n    for (size_t i = 0; i < N; i += sv_float_vec_len) {\n        // Create a predicate for loading floats.\n        // This predicate determines which lanes are active based on remaining elements.\n        svbool_t pg_f32 = svwhilelt_b32(i, N);\n\n        // Load a vector of floats from the list.\n        svfloat32_t current_vec = svld1_f32(pg_f32, &lst[i]);\n\n        // --- Condition 1: Number must be positive (x > 0.0f) ---\n        svbool_t pg_positive = svcmpgt_f32(pg_f32, current_vec, 0.0f);\n\n        // --- Condition 2: Number must be an integer (x == truncf(x)) ---\n        // svtrunc_f32 truncates the floating-point value towards zero.\n        svfloat32_t truncated_vec = svtrunc_f32(pg_f32, current_vec);\n        svbool_t pg_is_integer = svcmpeq_f32(pg_f32, current_vec, truncated_vec);\n\n        // --- Combine predicates for positive integers ---\n        svbool_t pg_positive_integer = svand_b(pg_positive, pg_is_integer);\n\n        // --- Convert selected floats to signed 64-bit integers ---\n        // The svcvt_s64_f32 intrinsic converts each active 32-bit float element\n        // to a 64-bit integer element. The resulting svint64_t vector will\n        // conceptually contain the same number of elements as the input svfloat32_t (VL/4).\n        svint64_t int_vec_64 = svcvt_s64_f32(pg_positive_integer, current_vec);\n\n        // --- Condition 3: Number must be odd ((int)x % 2 != 0) ---\n        // Use the 64-bit integer vector for modulo operation.\n        // Create a vector with value 2 for modulo.\n        svint64_t two_vec = svdup_s64(2);\n        svint64_t mod_2_vec = svrem_s64(pg_positive_integer, int_vec_64, two_vec);\n        svbool_t pg_is_odd = svcmpne_s64(pg_positive_integer, mod_2_vec, 0);\n\n        // --- Final predicate: positive, integer, and odd ---\n        // This predicate applies to VL/4 elements.\n        svbool_t pg_final = svand_b(pg_positive_integer, pg_is_odd);\n\n        // --- Square the selected integer values ---\n        // Reinterpret signed 64-bit integers as unsigned 64-bit integers for squaring.\n        // Since we only consider positive numbers, this reinterpretation is safe.\n        // The result 'squared_values' will also conceptually have VL/4 elements.\n        // Inactive elements (where pg_final is false) will be set to zero.\n        svuint64_t uint_vec_64 = svreinterpret_u64_s64(int_vec_64);\n        svuint64_t squared_values = svmul_u64(pg_final, uint_vec_64, uint_vec_64);\n\n        // --- Reduce 'squared_values' (VL/4 elements) to 'svuint64_t' (VL/8 elements) ---\n        // This performs a horizontal sum of pairs of elements.\n        // For example, if VL=128, svcntw=4, svcntd=2.\n        // squared_values = {s0, s1, s2, s3}\n        // svuzp1_u64(squared_values, squared_values) extracts {s0, s2}\n        // svuzp2_u64(squared_values, squared_values) extracts {s1, s3}\n        // Then these two vectors are added element-wise.\n        // The predicate for these operations is svptrue_b64() because inactive elements\n        // in 'squared_values' were already zeroed out by 'pg_final' in svmul_u64.\n        svuint64_t reduced_squared_values = svadd_u64_x(svptrue_b64(),\n                                                        svuzp1_u64(squared_values, squared_values),\n                                                        svuzp2_u64(squared_values, squared_values));\n\n        // --- Accumulate the reduced squared values into total_sum_vec ---\n        // Both total_sum_vec and reduced_squared_values now have VL/8 elements.\n        // The predicate for this addition is svptrue_b64() as all elements from\n        // reduced_squared_values (which already contain zeros for non-contributing values)\n        // should be added to the running sum.\n        total_sum_vec = svadd_u64_x(svptrue_b64(), total_sum_vec, reduced_squared_values);\n    }\n\n    // --- Final reduction: Sum all elements in total_sum_vec to a scalar ---\n    // svaddv_u64 takes svuint64_t (VL/8 elements) and returns a scalar uint64_t.\n    uint64_t final_scalar_sum = svaddv_u64(svptrue_b64(), total_sum_vec);\n\n    return final_scalar_sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t N = game.size();\n    std::vector<int> result(N);\n\n    size_t i = 0;\n    while (i < N) {\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff_vec = svsub_s32(game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32(diff_vec);\n\n        svst1_s32(pg, &result[i], abs_diff_vec);\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstddef> // For size_t\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    const size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Get raw pointers to the underlying data for SVE operations\n    const int* game_ptr = game.data();\n    const int* guess_ptr = guess.data();\n    int* result_ptr = result.data();\n\n    size_t i = 0;\n    // Loop through the vectors using SVE intrinsics.\n    // svwhilelt_b32 generates a predicate for 32-bit elements (int)\n    // that is true for elements from 'i' up to 'n-1'.\n    // svcnt_b32(pg) returns the number of active (true) lanes in the predicate.\n    // The loop continues as long as there are active lanes to process.\n    // svcntw() returns the number of 32-bit elements in an SVE vector (Vector Length).\n    for (svbool_t pg = svwhilelt_b32(i, n); svcnt_b32(pg) > 0; i += svcntw(), pg = svwhilelt_b32(i, n)) {\n        // Load a vector of 32-bit integers from 'game_ptr + i' using the predicate 'pg'.\n        // Elements corresponding to inactive lanes in 'pg' will be loaded as zero.\n        svint32_t game_vec = svld1_s32(pg, game_ptr + i);\n        \n        // Load a vector of 32-bit integers from 'guess_ptr + i' using the predicate 'pg'.\n        // Elements corresponding to inactive lanes in 'pg' will be loaded as zero.\n        svint32_t guess_vec = svld1_s32(pg, guess_ptr + i);\n        \n        // Perform element-wise subtraction: game_vec - guess_vec.\n        // The operation is only performed for active lanes defined by 'pg'.\n        // The values in inactive lanes of the result vector are undefined.\n        svint32_t diff_vec = svsub_s32(game_vec, guess_vec);\n        \n        // Calculate the absolute value of each element in 'diff_vec'.\n        // The operation is only performed for active lanes defined by 'pg'.\n        // The values in inactive lanes of the result vector are undefined.\n        svint32_t abs_diff_vec = svabs_s32(diff_vec);\n        \n        // Store the resulting vector 'abs_diff_vec' back into 'result_ptr + i'\n        // using the predicate 'pg'. Only active lanes are stored.\n        svst1_s32(pg, result_ptr + i, abs_diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath> // Not strictly needed for svabs, but good practice for general math functions\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t i = 0;\n    // Loop through the vectors in chunks determined by the SVE vector length\n    while (i < n) {\n        // Create a predicate for the current vector chunk.\n        // This predicate ensures that we only process valid elements,\n        // especially for the last chunk which might be partial.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load elements from 'game' and 'guess' vectors into SVE vector registers\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        // Calculate the difference between corresponding elements\n        svint32_t diff_vec = svsub_s32(game_vec, guess_vec);\n\n        // Calculate the absolute value of the differences.\n        // If game[i] == guess[i], diff_vec will have 0, and svabs_s32(0) is 0.\n        // This directly satisfies the requirement \"if they have guessed correctly, the value is 0\".\n        svint32_t abs_diff_vec = svabs_s32(diff_vec);\n\n        // Store the results back into the 'result' vector\n        svst1_s32(pg, &result[i], abs_diff_vec);\n\n        // Increment the loop counter by the number of elements processed in this SVE vector.\n        // svcntw() returns the number of 32-bit elements (words) in an SVE vector.\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t N = game.size();\n    std::vector<int> result(N);\n\n    // Iterate through the vectors in chunks of SVE vector length\n    // svcntw() returns the number of 32-bit elements that fit in an SVE vector.\n    for (size_t i = 0; i < N; i += svcntw()) {\n        // Create a predicate for the current vector chunk.\n        // svwhilelt_b32(i, N) generates a predicate that is true for elements\n        // from the current index 'i' up to 'N-1', effectively handling\n        // full vectors and the tail (partial vector) at the end.\n        svbool_t pg = svwhilelt_b32(i, N);\n\n        // Load data from the 'game' vector into an SVE vector register.\n        // The predicate 'pg' ensures that only valid elements are loaded.\n        svint32_t game_vec = svld1_s32(pg, &game[0] + i);\n\n        // Load data from the 'guess' vector into another SVE vector register.\n        svint32_t guess_vec = svld1_s32(pg, &guess[0] + i);\n\n        // Calculate the difference between corresponding elements.\n        svint32_t diff_vec = svsub_s32(game_vec, guess_vec);\n\n        // Calculate the absolute difference.\n        // svabs_s32 computes the absolute value of each element in the vector.\n        svint32_t abs_diff_vec = svabs_s32(diff_vec);\n\n        // Store the result back into the 'result' vector.\n        // The predicate 'pg' ensures that results are stored only for valid elements.\n        svst1_s32(pg, &result[0] + i, abs_diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Loop through the vectors in chunks of SVE vector length\n    // 'i' is the current index in the arrays\n    for (size_t i = 0; i < n; ) {\n        // Generate a predicate for the current chunk.\n        // svwhilelt_b32(i, n) creates a predicate that is true for elements\n        // starting from 'i' up to 'n-1'. This handles the tail of the array correctly.\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load elements from 'game' vector into an SVE vector register\n        // Only active lanes (where pg is true) are loaded.\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n\n        // Load elements from 'guess' vector into another SVE vector register\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        // Calculate the difference: game_vec - guess_vec\n        // svsub_s32_z: Subtracts with zeroing inactive lanes.\n        // For inactive lanes (where pg is false), the result element is set to 0.\n        svint32_t diff_vec = svsub_s32_z(pg, game_vec, guess_vec);\n\n        // Calculate the absolute difference\n        // svabs_s32_z: Computes absolute value with zeroing inactive lanes.\n        svint32_t abs_diff_vec = svabs_s32_z(pg, diff_vec);\n\n        // Store the result back into the 'result' vector\n        // svst1_s32: Stores elements only for active lanes (where pg is true).\n        svst1_s32(pg, &result[i], abs_diff_vec);\n\n        // Increment the index 'i' by the number of elements processed in this iteration.\n        // svcntw() returns the number of 32-bit elements in an SVE vector (VL).\n        // This advances 'i' by the full vector length, and the predicate handles the boundary.\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}

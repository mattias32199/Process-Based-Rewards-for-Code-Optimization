{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t src_data = vld1q_u64((const uint64_t*)&src[i]);\n        uint64x2_t mask_data = vld1q_u64((const uint64_t*)&mask[i]);\n        \n        uint64x2_t result = vbslq_u64(vreinterpretq_u64_u64(mask_data), src_data, vld1q_u64((const uint64_t*)&dst[i]));\n        \n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t src_data = vld1q_u64((const uint64_t*)(src + i));\n        uint64x2_t mask_data = vld1q_u64((const uint64_t*)(mask + i));\n        uint64x2_t result = vbslq_u64(vreinterpretq_u64_u8(vmovn_u8(vreinterpretq_u8_u64(mask_data))), src_data, vld1q_u64(dst + i));\n        vst1q_u64(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t src_data = vld1q_u64((const uint64_t*)(src + i));\n        uint64x2_t mask_data = vld1q_u64((const uint64_t*)(mask + i));\n        uint64x2_t result = vandq_u64(src_data, vmovq_n_u64(-mask_data));\n        vst1q_u64((uint64_t*)(dst + i), result);\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    uint64x1_t mask_val;\n    int64x1_t src_val, dst_val;\n\n    for (i = 0; i < length; i++) {\n        mask_val = vdup_n_u64(mask[i]);\n        src_val = vld1_s64(&src[i]);\n        dst_val = vld1_s64(&dst[i]);\n        dst_val = vbsl_s64(mask_val, src_val, dst_val);\n        vst1_s64(&dst[i], dst_val);\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    uint64x1_t mask_val;\n    int64x1_t src_val, dst_val;\n\n    for (i = 0; i < length; i++) {\n        mask_val = vdup_n_u64(mask[i]);\n        src_val = vld1_s64(&src[i]);\n        dst_val = vld1_s64(&dst[i]);\n        dst_val = vbsl_s64(mask_val, src_val, dst_val);\n        vst1_s64(&dst[i], dst_val);\n    }\n}\n```  "}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    int32x4_t shift_right = vdupq_n_s32(3);\n    int32x4_t shift_left = vdupq_n_s32(-3);\n    int32x4_t div_by_7 = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(&src[i]);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(src_v, scale_v), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(src_v, scale_v), 3);\n        \n        int32x4_t result = vshrq_n_s32(vaddq_s32(vmulq_s32(src_v, scale_v), vmulq_s32(tmp1, tmp2)), 3);\n        result = vshrq_n_s32(vaddq_s32(result, div_by_7), 3);\n        \n        vst1q_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    int32x4_t shift_right = vdupq_n_s32(3);\n    int32x4_t shift_left = vdupq_n_s32(-3);\n    int32x4_t divide_by = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(&src[i]);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(src_v, scale_v), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(src_v, scale_v), 3);\n        \n        int32x4_t result = vshrq_n_s32(vaddq_s32(vmulq_s32(src_v, scale_v), vmulq_s32(tmp1, tmp2)), 3);\n        result = vshrq_n_s32(vaddq_s32(result, divide_by), 3);\n        \n        vst1q_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    int32x4_t shift_right = vdupq_n_s32(3);\n    int32x4_t shift_left = vdupq_n_s32(-3);\n    int32x4_t divide_by = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(src + i);\n\n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(src_v, scale_v), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(src_v, scale_v), 3);\n\n        int32x4_t result = vshrq_n_s32(vaddq_s32(vmulq_s32(src_v, scale_v), vmulq_s32(tmp1, tmp2)), 3);\n        result = vshrq_n_s32(vmulq_s32(result, divide_by), 3);\n\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    int32x4_t shift_right = vdupq_n_s32(3);\n    int32x4_t shift_left = vdupq_n_s32(-3);\n    int32x4_t divide_by = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(src + i);\n\n        int32x4_t tmp1 = vshrq_n_s32(vqdmulhq_s32(src_v, scale_v), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vqdmulhq_s32(src_v, scale_v), 3);\n\n        int32x4_t result = vqdmulhq_s32(src_v, scale_v);\n        result = vmlaq_s32(result, tmp1, tmp2);\n        result = vshrq_n_s32(result, 3);\n        result = vqdmulhq_s32(result, divide_by);\n\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    int32x4_t shift_right = vdupq_n_s32(3);\n    int32x4_t shift_left = vdupq_n_s32(-3);\n    int32x4_t divide_by = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(src + i);\n\n        int32x4_t tmp1 = vshrq_n_s32(vqdmulhq_s32(src_v, scale_v), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vqdmulhq_s32(src_v, scale_v), 3);\n\n        int32x4_t result = vqdmulhq_s32(src_v, scale_v);\n        result = vmlaq_s32(result, tmp1, tmp2);\n        result = vshrq_n_s32(result, 3);\n        result = vqdmulhq_s32(result, divide_by);\n\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        double64x2_t src_val = vld1q_f64(&src[r * cols + stride]);\n        vst1q_f64(&dst[r], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        size_t dst_index = r;\n        \n        float64x2_t src_val = vld1q_f64(&src[src_index]);\n        vst1q_f64(&dst[dst_index], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        size_t dst_index = r;\n        \n        float64x2_t src_val = vld1q_f64(&src[src_index]);\n        vst1q_f64(&dst[dst_index], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t src_index = r * cols + stride;\n        size_t dst_index = r;\n        \n        float64x2_t src_val = vld1q_f64(&src[src_index]);\n        vst1q_f64(&dst[dst_index], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        size_t dst_index = r;\n        \n        float64x2_t src_val = vld1q_f64(&src[src_index]);\n        vst1q_f64(&dst[dst_index], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    uint32x4_t index_v;\n    float32x4_t src_v, dst_v;\n\n    for (size_t i = 0; i < length; i += 4) {\n        index_v = vld1q_u32((const uint32_t*)&indices[i]);\n        src_v = vld1q_f32(&src[i]);\n\n        dst_v = vld1q_f32(dst);\n\n        dst_v = vld1q_f32(dst);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 0)), dst_v, 0);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 1)), dst_v, 1);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 2)), dst_v, 2);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 3)), dst_v, 3);\n\n        vst1q_f32(dst, dst_v);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    uint32x4_t index_v;\n    float32x4_t src_v, dst_v;\n\n    for (size_t i = 0; i < length; i += 4) {\n        index_v = vld1q_u32((const uint32_t*)&indices[i]);\n        src_v = vld1q_f32(&src[i]);\n\n        dst_v = vld1q_f32(dst);\n        dst_v = vld1q_f32(dst);\n\n        vst1q_f32(&dst_v, vld1q_f32(src, vqtbl1q_u32(src_v, index_v)));\n        vst1q_f32(dst, dst_v);\n    }\n}\n```  "}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    uint32x4_t index;\n    float32x4_t value;\n\n    for (size_t i = 0; i < length; i += 4) {\n        index = vld1q_u32((const uint32_t*)&indices[i]);\n        value = vld1q_f32(&src[vgetq_lane_u32(index, 0)]);\n        vst1q_f32(&dst[i], value);\n\n        index = vld1q_u32((const uint32_t*)&indices[i]);\n        value = vld1q_f32(&src[i]);\n        vst1q_f32(&dst[vgetq_lane_u32(index, 0)], value);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    uint32x4_t index_vec;\n    float32x4_t src_vec, dst_vec;\n\n    for (size_t i = 0; i < length; i += 4) {\n        index_vec = vld1q_u32(indices + i);\n        src_vec = vld1q_f32(src + i);\n\n        dst_vec = vld1q_f32(dst);\n\n        dst_vec = vld1q_f32(dst);\n        dst_vec = vsetq_lane_f32(vgetq_lane_f32(src_vec, vgetq_lane_u32(index_vec, 0)), dst_vec, 0);\n        dst_vec = vsetq_lane_f32(vgetq_lane_f32(src_vec, vgetq_lane_u32(index_vec, 1)), dst_vec, 1);\n        dst_vec = vsetq_lane_f32(vgetq_lane_f32(src_vec, vgetq_lane_u32(index_vec, 2)), dst_vec, 2);\n        dst_vec = vsetq_lane_f32(vgetq_lane_f32(src_vec, vgetq_lane_u32(index_vec, 3)), dst_vec, 3);\n\n        vst1q_f32(dst, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    uint32x4_t index_v;\n    float32x4_t src_v, dst_v;\n\n    for (size_t i = 0; i < length; i += 4) {\n        index_v = vld1q_u32((const uint32_t *)&indices[i]);\n        src_v = vld1q_f32(&src[i]);\n\n        dst_v = vld1q_f32(dst);\n\n        dst_v = vld1q_f32(dst);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 0)), dst_v, 0);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 1)), dst_v, 1);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 2)), dst_v, 2);\n        dst_v = vsetq_lane_f32(vgetq_lane_f32(src_v, vgetq_lane_u32(index_v, 3)), dst_v, 3);\n\n        vst1q_f32(dst, dst_v);\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    int16x8_t tmp;\n    int16_t *ptr_start = arr + start;\n    int16_t *ptr_end = arr + end;\n    \n    while (ptr_start < ptr_end) {\n        tmp = vld1q_s16(ptr_start);\n        int16x8_t tmp_rev = vrev64q_s16(tmp);\n        vst1q_s16(ptr_start, tmp_rev);\n        \n        ptr_start += 8;\n        ptr_end -= 8;\n    }\n}\n```  "}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    int16x8_t tmp;\n    int16_t *ptr_start = arr + start;\n    int16_t *ptr_end = arr + end;\n\n    while (ptr_start < ptr_end) {\n        tmp = vld1q_s16(ptr_start);\n        int16x8_t rev_tmp = vrev64q_s16(tmp);\n        vst1q_s16(ptr_start, rev_tmp);\n        ptr_start += 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    int16x8_t tmp;\n    int16_t *ptr_start = arr + start;\n    int16_t *ptr_end = arr + end;\n    \n    while (ptr_start < ptr_end) {\n        tmp = vld1q_s16(ptr_start);\n        int16x8_t rev_tmp = vrev64q_s16(tmp);\n        vst1q_s16(ptr_start, rev_tmp);\n        \n        ptr_start += 8;\n        ptr_end -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    int16x8_t tmp;\n    int16_t *ptr_start = arr + start;\n    int16_t *ptr_end = arr + end;\n    \n    while (ptr_start < ptr_end) {\n        tmp = vld1q_s16(ptr_start);\n        int16x8_t rev_tmp = vrev64q_s16(tmp);\n        vst1q_s16(ptr_start, rev_tmp);\n        \n        ptr_start += 8;\n        ptr_end -= 8;\n    }\n}\n```  "}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t num_vectors = len / 8;\n    uint64_t remaining_elements = len % 8;\n\n    int16x8_t *ptr = (int16x8_t *)(arr + start);\n\n    for (uint64_t i = 0; i < num_vectors; i++) {\n        int16x8_t vec = vld1q_s16((arr + start) + i * 8);\n        vec = vrev64q_s16(vec);\n        vst1q_s16((arr + start) + i * 8, vec);\n    }\n\n    if (remaining_elements > 0) {\n        int16_t temp[8];\n        int16x8_t vec = vld1q_s16((arr + start) + num_vectors * 8);\n        vst1q_s16(temp, vec);\n        for (uint64_t i = 0; i < remaining_elements / 2; i++) {\n            int16_t tmp = temp[i];\n            temp[i] = temp[remaining_elements - i - 1];\n            temp[remaining_elements - i - 1] = tmp;\n        }\n        vst1q_s16((arr + start) + num_vectors * 8, vld1q_s16(temp));\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j += 16) {\n            uint8x16_t slice_data = vld1q_u8(&tensor[start_idx + i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], slice_data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t tensor_offset = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; j += 16) {\n            uint8x16_t vdata = vld1q_u8(&tensor[tensor_offset + i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], vdata);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; j += 16) {\n            uint8x16_t data = vld1q_u8(&tensor[start_idx + i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], data);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j += 8) {\n            uint8x8x3_t data = vld3_u8(tensor + start_idx + i * dim2 * dim3 + j * dim3);\n            vst1_u8(slice + i * dim2 + j, data.val[2]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    \n    uint8x8x3_t data;\n    const uint8_t *src_ptr = tensor + slice_idx * slice_size * dim3;\n    uint8_t *dst_ptr = slice;\n    \n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            data = vld3_u8(src_ptr);\n            vst1_u8(dst_ptr, data.val[2]);\n            src_ptr += 3;\n            dst_ptr += 1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    int16x8_t v = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], v);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    int16x8_t vsrc = vld1q_s16(&src[ii * cols + jj]);\n                    int16x8_t vdst = vld1q_s16(&dst[jj * rows + ii]);\n                    vst1q_s16(&dst[jj * rows + ii], vsrc);\n                    vst1q_s16(&src[ii * cols + jj], vdst);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    int16x8_t v_src = vld1q_s16(&src[ii * cols + jj]);\n                    int16x8_t v_dst = vld1q_s16(&dst[jj * rows + ii]);\n                    vst1q_s16(&dst[jj * rows + ii], v_src);\n                    vst1q_s16(&src[ii * cols + jj], v_dst);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    int16x8_t data = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], data);\n                }\n            }\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    int16x8_t data = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i++) {\n        for (size_t j = 0; j < dim; j++) {\n            for (size_t k = 0; k < dim; k += 4) {\n                float32x4_t values = vld1q_f32(&array[(i * dim * dim) + (j * dim) + k]);\n                sum = vaddq_f32(sum, values);\n            }\n        }\n    }\n    \n    float result = vgetq_lane_f32(sum, 0) + vgetq_lane_f32(sum, 1) + vgetq_lane_f32(sum, 2) + vgetq_lane_f32(sum, 3);\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < dim; ++i) {\n        size_t idx = i * dim * dim + i * dim + i;\n        float32x4_t val = vld1q_f32(&array[idx]);\n        sum = vaddq_f32(sum, val);\n    }\n    \n    float result;\n    float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    vst1_f32(&result, vpadd_f32(sum_low, sum_low));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < dim; i++) {\n        for (size_t j = 0; j < dim; j++) {\n            for (size_t k = 0; k < dim; k += 4) {\n                float32x4_t values = vld1q_f32(&array[(i * dim * dim) + (j * dim) + k]);\n                sum = vaddq_f32(sum, values);\n            }\n        }\n    }\n    \n    float result = vgetq_lane_f32(sum, 0) + vgetq_lane_f32(sum, 1) + vgetq_lane_f32(sum, 2) + vgetq_lane_f32(sum, 3);\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t size = dim * dim * dim;\n    \n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i]);\n        sum += vgetq_lane_f32(values, 0) + vgetq_lane_f32(values, 1) + vgetq_lane_f32(values, 2) + vgetq_lane_f32(values, 3);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        float32x4_t values = vld1q_f32(&array[index]);\n        sum = vaddq_f32(sum, values);\n    }\n    \n    float result = vgetq_lane_f32(sum, 0) + vgetq_lane_f32(sum, 1) + vgetq_lane_f32(sum, 2) + vgetq_lane_f32(sum, 3);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        float64x2_t v_src = vld1q_f64(src + i);\n        uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_result = vbslq_f64(mask, vmulq_f64(v_src, v_scale), v_src);\n        vst1q_f64(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_size = rows * cols;\n    size_t neon_size = cols / 2;\n\n    double64x2_t v_threshold = vdupq_n_f64(threshold);\n    double64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < total_size; i += cols) {\n        const double *src_ptr = src + i;\n        double *dst_ptr = dst + i;\n\n        for (size_t j = 0; j < neon_size; ++j) {\n            double64x2_t v_src = vld1q_f64(src_ptr);\n            uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n            double64x2_t v_result = vbslq_f64(v_mask, vmulq_f64(v_src, v_scale), v_src);\n            vst1q_f64(dst_ptr, v_result);\n\n            src_ptr += 2;\n            dst_ptr += 2;\n        }\n\n        for (size_t j = neon_size * 2; j < cols; ++j) {\n            dst_ptr[j] = (src_ptr[j] > threshold) ? src_ptr[j] * scale : src_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t elements = rows * cols;\n    size_t neon_elements = elements / 2;\n\n    double64x2_t v_threshold = vdupq_n_f64(threshold);\n    double64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < neon_elements; i++) {\n        double64x2_t v_src = vld1q_f64(src);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        double64x2_t v_result = vbslq_f64(v_mask, vmulq_f64(v_src, v_scale), v_src);\n        vst1q_f64(dst, v_result);\n\n        src += 2;\n        dst += 2;\n    }\n\n    for (size_t i = neon_elements * 2; i < elements; i++) {\n        *dst = (*src > threshold) ? (*src * scale) : *src;\n\n        src++;\n        dst++;\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        float64x2_t v_src = vld1q_f64(src + i);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_result = vbslq_f64(v_mask, vmulq_f64(v_src, v_scale), v_src);\n        vst1q_f64(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t elements = rows * cols;\n    size_t neon_elements = elements / 2;\n\n    double64x2_t v_threshold = vdupq_n_f64(threshold);\n    double64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < neon_elements; i++) {\n        double64x2_t v_src = vld1q_f64(src);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        double64x2_t v_result = vbslq_f64(v_mask, vmulq_f64(v_src, v_scale), v_src);\n        vst1q_f64(dst, v_result);\n\n        src += 2;\n        dst += 2;\n    }\n\n    for (size_t i = neon_elements * 2; i < elements; i++) {\n        *dst = (*src > threshold) ? (*src * scale) : *src;\n\n        src++;\n        dst++;\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i];\n        size_t idx2 = indices[i + 1];\n\n        const double *src_row1 = src + idx1 * cols;\n        const double *src_row2 = src + idx2 * cols;\n\n        double *dst_row1 = dst + i * cols;\n        double *dst_row2 = dst + (i + 1) * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t val1 = vld1q_f64(src_row1 + j);\n            float64x2_t val2 = vld1q_f64(src_row2 + j);\n\n            vst1q_f64(dst_row1 + j, val1);\n            vst1q_f64(dst_row2 + j, val2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    for (i = 0; i < rows; i += 2) {\n        uint64x2_t vindex = vld1q_u64(&indices[i]);\n        for (j = 0; j < cols; j += 2) {\n            uint64x2_t vsrc1 = vld1q_u64(&src[(vgetq_lane_u64(vindex, 0) * cols) + j]);\n            uint64x2_t vsrc2 = vld1q_u64(&src[(vgetq_lane_u64(vindex, 1) * cols) + j]);\n            vst1q_u64(&dst[(i * cols) + j], vsrc1);\n            vst1q_u64(&dst[((i + 1) * cols) + j], vsrc2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i];\n        size_t idx2 = indices[i + 1];\n        \n        const double *src_row1 = src + idx1 * cols;\n        const double *src_row2 = src + idx2 * cols;\n        \n        double *dst_row1 = dst + i * cols;\n        double *dst_row2 = dst + (i + 1) * cols;\n        \n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t v1 = vld1q_f64(src_row1 + j);\n            float64x2_t v2 = vld1q_f64(src_row2 + j);\n            \n            vst1q_f64(dst_row1 + j, v1);\n            vst1q_f64(dst_row2 + j, v2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i];\n        size_t idx2 = indices[i + 1];\n\n        const double *src_row1 = src + idx1 * cols;\n        const double *src_row2 = src + idx2 * cols;\n\n        double *dst_row1 = dst + i * cols;\n        double *dst_row2 = dst + (i + 1) * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t v1 = vld1q_f64(src_row1 + j);\n            float64x2_t v2 = vld1q_f64(src_row2 + j);\n\n            vst1q_f64(dst_row1 + j, v1);\n            vst1q_f64(dst_row2 + j, v2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    for (i = 0; i < rows; i += 2) {\n        uint64x2_t vindex = vld1q_u64(&indices[i]);\n        for (j = 0; j < cols; j += 2) {\n            uint64x2_t vsrc1 = vld1q_u64(&src[vgetq_lane_u64(vindex, 0) * cols + j]);\n            uint64x2_t vsrc2 = vld1q_u64(&src[vgetq_lane_u64(vindex, 1) * cols + j]);\n            vst1q_u64(&dst[i * cols + j], vsrc1);\n            vst1q_u64(&dst[(i + 1) * cols + j], vsrc2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_v = vdupq_n_s64(scalar);\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t src1_v = vld1q_s64(&src1[i]);\n        int64x2_t src2_v = vld1q_s64(&src2[i]);\n        int64x2_t result = vaddq_s64(src1_v, src2_v);\n        result = vaddq_s64(result, scalar_v);\n        result = vshrq_n_s64(result, 1);\n        vst1q_s64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_v = vdupq_n_s64(scalar);\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t src1_v = vld1q_s64(&src1[i]);\n        int64x2_t src2_v = vld1q_s64(&src2[i]);\n        int64x2_t result = vaddq_s64(src1_v, src2_v);\n        result = vaddq_s64(result, scalar_v);\n        result = vshrq_n_s64(result, 1);\n        vst1q_s64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_v = vdupq_n_s64(scalar);\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t src1_v = vld1q_s64(&src1[i]);\n        int64x2_t src2_v = vld1q_s64(&src2[i]);\n        int64x2_t result = vaddq_s64(src1_v, src2_v);\n        result = vaddq_s64(result, scalar_v);\n        result = vshrq_n_s64(result, 1);\n        vst1q_s64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_v = vdupq_n_s64(scalar);\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t src1_v = vld1q_s64(&src1[i]);\n        int64x2_t src2_v = vld1q_s64(&src2[i]);\n        int64x2_t result = vaddq_s64(src1_v, src2_v);\n        result = vaddq_s64(result, scalar_v);\n        result = vshrq_n_s64(result, 1);\n        vst1q_s64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_v = vdupq_n_s64(scalar);\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t src1_v = vld1q_s64(&src1[i]);\n        int64x2_t src2_v = vld1q_s64(&src2[i]);\n        int64x2_t result = vaddq_s64(src1_v, src2_v);\n        result = vaddq_s64(result, scalar_v);\n        result = vshrq_n_s64(result, 1);\n        vst1q_s64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n    \n    int32x4_t min_values = vld1q_s32(src);\n    \n    for (size_t i = 4; i < length; i += 4) {\n        int32x4_t current_values = vld1q_s32(src + i);\n        min_values = vminq_s32(min_values, current_values);\n    }\n    \n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_values), vget_high_s32(min_values));\n    int32x2_t min_pair_final = vpmin_s32(min_pair, min_pair);\n    \n    int32_t result[2];\n    vst1_s32(result, min_pair_final);\n    \n    return result[0];\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_values = vld1q_s32(&src[0]);\n    for (size_t i = 4; i < length; i += 4) {\n        int32x4_t current_values = vld1q_s32(&src[i]);\n        min_values = vminq_s32(min_values, current_values);\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_values), vget_high_s32(min_values));\n    int32x2_t min_result = vpmin_s32(min_pair, min_pair);\n\n    int32_t result[2];\n    vst1_s32(result, min_result);\n\n    return result[0];\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n    \n    int32x4_t min_values = vld1q_s32(src);\n    \n    for (size_t i = 4; i < length; i += 4) {\n        int32x4_t current_values = vld1q_s32(src + i);\n        min_values = vminq_s32(min_values, current_values);\n    }\n    \n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_values), vget_high_s32(min_values));\n    int32x2_t min_pair_final = vpmin_s32(min_pair, min_pair);\n    \n    int32_t result[2];\n    vst1_s32(result, min_pair_final);\n    \n    return result[0];\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_values = vld1q_s32(src);\n    for (size_t i = 4; i < length; i += 4) {\n        int32x4_t current_values = vld1q_s32(src + i);\n        min_values = vminq_s32(min_values, current_values);\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_values), vget_high_s32(min_values));\n    int32x2_t min_pair_final = vpmin_s32(min_pair, min_pair);\n    \n    int32x2_t result = vext_s32(min_pair_final, min_pair_final, 1);\n    \n    return vget_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_values = vld1q_s32(&src[0]);\n    for (size_t i = 4; i < length; i += 4) {\n        int32x4_t values = vld1q_s32(&src[i]);\n        min_values = vminq_s32(min_values, values);\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_values), vget_high_s32(min_values));\n    int32x2_t min_pair_final = vpmin_s32(min_pair, min_pair);\n\n    int32x2_t result = vext_s32(min_pair_final, min_pair_final, 1);\n    return vget_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    uint8x16_t v_shift = vdupq_n_u8(shift);\n    int32x4_t v_shift_arith = vdupq_n_s32(-shift);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t v_src = vld1q_s32(src + i);\n        \n        int32x4_t v_arith_shifted = vshlq_s32(v_src, v_shift_arith);\n        \n        uint32x4_t v_src_uint = vreinterpretq_u32_s32(v_src);\n        uint32x4_t v_log_shifted = vshlq_u32(v_src_uint, v_shift);\n        int32x4_t v_log_shifted_int = vreinterpretq_s32_u32(v_log_shifted);\n        \n        int32x4_t v_result = vaddq_s32(v_arith_shifted, v_log_shifted_int);\n        \n        vst1q_s32(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    int32x4_t v_shift = vdupq_n_s32(shift);\n    int32x4_t v_src, v_arith, v_logical, v_result;\n\n    for (size_t i = 0; i < length; i += 4) {\n        v_src = vld1q_s32(src + i);\n\n        v_arith = vshrq_n_s32(v_src, v_shift);\n\n        uint32x4_t v_src_uint = vreinterpretq_u32_s32(v_src);\n        uint32x4_t v_logical_uint = vshrq_n_u32(v_src_uint, v_shift);\n        v_logical = vreinterpretq_s32_u32(v_logical_uint);\n\n        v_result = vaddq_s32(v_arith, v_logical);\n\n        vst1q_s32(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    int32x4_t shift_v = vdupq_n_s32(shift);\n    int32x4_t mask = vdupq_n_s32(0xFFFFFFFF);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(src + i);\n\n        int32x4_t arith_shift = vshrq_n_s32(src_v, shift);\n        int32x4_t uint_src_v = vreinterpretq_s32_u32(vandq_u32(vreinterpretq_u32_s32(src_v), mask));\n        int32x4_t logical_shift = vreinterpretq_s32_u32(vshrq_n_u32(uint_src_v, shift));\n\n        int32x4_t result = vaddq_s32(arith_shift, logical_shift);\n\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    int32x4_t arith_shift_val = vdupq_n_s32(shift);\n    int32x4_t logical_shift_val = vdupq_n_s32(shift);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_val = vld1q_s32(src + i);\n\n        int32x4_t arith_result = vshrq_n_s32(src_val, shift);\n        int32x4_t logical_src_val = vreinterpretq_s32_u32(vshrq_n_u32(vreinterpretq_u32_s32(src_val), shift));\n        int32x4_t logical_result = vreinterpretq_s32_u32(vshrq_n_u32(vreinterpretq_u32_s32(logical_src_val), shift));\n\n        int32x4_t final_result = vaddq_s32(arith_result, logical_result);\n\n        vst1q_s32(dst + i, final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    int32x4_t shift_v = vdupq_n_s32(shift);\n    int32x4_t mask = vdupq_n_s32(0xFFFFFFFF >> shift);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t src_v = vld1q_s32(src + i);\n\n        int32x4_t arith_shift = vshrq_n_s32(src_v, shift);\n        int32x4_t uint_src_v = vreinterpretq_s32_u32(vandq_u32(vreinterpretq_u32_s32(src_v), vreinterpretq_u32_s32(mask)));\n        int32x4_t log_shift = vreinterpretq_s32_u32(vshrq_n_u32(vreinterpretq_u32_s32(uint_src_v), shift));\n\n        int32x4_t result = vaddq_s32(arith_shift, log_shift);\n\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64x2_t sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        int32x2_t data = vld1_s32(&matrix[i]);\n        sum = vpadalq_s32(sum, data);\n    }\n\n    int64x1_t sum_scalar = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    int64_t result;\n    vst1_s64(&result, sum_scalar);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64x2_t sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        int32x2_t data = vld1_s32(&matrix[i]);\n        sum = vpadalq_s32(sum, data);\n    }\n\n    int64x1_t sum_scalar = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    int64_t result;\n    vst1_s64(&result, sum_scalar);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64x2_t sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        int32x2_t data = vld1_s32(&matrix[i]);\n        sum = vpadalq_s32(sum, data);\n    }\n\n    int64x1_t sum_scalar = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    int64_t result;\n    vst1_s64(&result, sum_scalar);\n\n    return result;\n}\n```  "}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64x2_t sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        int32x2_t data = vld1_s32(&matrix[i]);\n        sum = vpadalq_s32(sum, data);\n    }\n\n    int64x1_t sum_scalar = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    int64_t result = vget_lane_s64(sum_scalar, 0);\n\n    return result;\n}\n```  "}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64x2_t sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < rows * cols; i += 2) {\n        int32x2_t data = vld1_s32(&matrix[i]);\n        sum = vpadalq_s32(sum, data);\n    }\n\n    int64x1_t sum_scalar = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    int64_t result = vget_lane_s64(sum_scalar, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8x16_t vmax_values = vdupq_n_s8(INT8_MIN);\n    int8x16_t max_indexes = vdupq_n_s8(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t src_values = vld1q_s8(src + i);\n        uint8x16_t cmp_mask = vcgtq_s8(src_values, vmax_values);\n        vmax_values = vmaxq_s8(vmax_values, src_values);\n        max_indexes = vbslq_s8(cmp_mask, vdupq_n_s8(i), max_indexes);\n    }\n\n    int8x8_t max_values_low = vget_low_s8(vmax_values);\n    int8x8_t max_values_high = vget_high_s8(vmax_values);\n    int8x8_t max_values_final = vpmax_s8(max_values_low, max_values_high);\n\n    int8x8_t max_indexes_low = vget_low_s8(max_indexes);\n    int8x8_t max_indexes_high = vget_high_s8(max_indexes);\n    int8x8_t max_indexes_final = vpmax_s8(max_indexes_low, max_indexes_high);\n\n    int8x8_t max_values_perm = vext_s8(max_values_final, max_values_final, 1);\n    int8x8_t max_indexes_perm = vext_s8(max_indexes_final, max_indexes_final, 1);\n\n    int8x8_t final_values = vpmax_s8(max_values_final, max_values_perm);\n    int8x8_t final_indexes = vpmax_s8(max_indexes_final, max_indexes_perm);\n\n    int8x8_t result_values = vpmax_s8(final_values, final_values);\n    int8x8_t result_indexes = vpmax_s8(final_indexes, final_indexes);\n\n    return vget_lane_s8(result_indexes, 0);\n}\n```  "}
{"task_id": "SimdBench_14_Neon", "completion": "```\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    uint8x8_t max_val = vdup_n_u8(0);\n    uint8x8_t max_idx = vdup_n_u8(0);\n    uint8x8_t step = vdup_n_u8(8);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint8x8_t data = vld1_u8(src + i);\n        uint8x8_t cmp = vcgt_u8(data, max_val);\n        max_val = vmax_u8(data, max_val);\n        max_idx = vadd_u8(max_idx, step);\n        max_idx = vbsl_u8(cmp, max_idx, max_idx);\n    }\n\n    uint8x8_t max_val_final = vpmax_u8(max_val, max_val);\n    uint8x8_t max_idx_final = vpmax_u8(max_idx, max_idx);\n    max_val_final = vpmax_u8(max_val_final, max_val_final);\n    max_idx_final = vpmax_u8(max_idx_final, max_idx_final);\n\n    uint8_t max_val_scalar;\n    uint8_t max_idx_scalar;\n    vst1_lane_u8(&max_val_scalar, max_val_final, 0);\n    vst1_lane_u8(&max_idx_scalar, max_idx_final, 0);\n\n    return max_idx_scalar;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    uint8x8_t max_val = vdup_n_u8(0);\n    uint8x8_t max_idx = vdup_n_u8(0);\n    uint8x8_t cur_val, cur_idx;\n    uint8x8_t cmp_mask;\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        cur_val = vld1_u8(&src[i]);\n        cur_idx = vld1_u8((uint8_t *)&i);\n\n        cmp_mask = vcgt_u8(cur_val, max_val);\n        max_val = vmax_u8(max_val, cur_val);\n        max_idx = vbsl_u8(cmp_mask, cur_idx, max_idx);\n    }\n\n    uint8_t max_val_arr[8];\n    uint8_t max_idx_arr[8];\n    vst1_u8(max_val_arr, max_val);\n    vst1_u8(max_idx_arr, max_idx);\n\n    uint8_t max_val_final = max_val_arr[0];\n    uint8_t max_idx_final = max_idx_arr[0];\n    for (int j = 1; j < 8; j++) {\n        if (max_val_arr[j] > max_val_final) {\n            max_val_final = max_val_arr[j];\n            max_idx_final = max_idx_arr[j];\n        }\n    }\n\n    return (size_t)max_idx_final;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    uint8x8_t max_val = vdup_n_u8(0);\n    uint8x8_t max_index = vdup_n_u8(0);\n    uint8x8_t current_val;\n    uint8x8_t current_index = vdup_n_u8(0);\n\n    for (size_t i = 0; i < length; i += 8) {\n        current_val = vld1_u8(src + i);\n        current_index = vcreate_u8(i);\n\n        uint8x8_t cmp_mask = vcgt_u8(current_val, max_val);\n        max_val = vmax_u8(max_val, current_val);\n        max_index = vbsl_u8(cmp_mask, current_index, max_index);\n    }\n\n    uint8_t result[8];\n    vst1_u8(result, max_index);\n\n    size_t max_index_value = 0;\n    uint8_t max_value = 0;\n    for (int i = 0; i < 8; i++) {\n        if (result[i] > max_value) {\n            max_value = result[i];\n            max_index_value = i;\n        }\n    }\n\n    return max_index_value;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    uint8x8_t max_val = vdup_n_u8(0);\n    uint8x8_t max_index = vdup_n_u8(0);\n    uint8x8_t current_val;\n    uint8x8_t current_index = vdup_n_u8(0);\n\n    for (size_t i = 0; i < length; i += 8) {\n        current_val = vld1_u8(src + i);\n        current_index = vcreate_u8(i);\n\n        uint8x8_t cmp_mask = vcgt_u8(current_val, max_val);\n        max_val = vmax_u8(max_val, current_val);\n        max_index = vbsl_u8(cmp_mask, current_index, max_index);\n    }\n\n    uint8x8_t max_val_final = vpmax_u8(max_val, max_val);\n    uint8x8_t max_index_final = vpmax_u8(max_index, max_index);\n\n    uint8x8_t max_val_final_perm = vext_u8(max_val_final, max_val_final, 7);\n    uint8x8_t max_index_final_perm = vext_u8(max_index_final, max_index_final, 7);\n\n    return vget_lane_u8(max_index_final_perm, 0);\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16x8_t mask_v = vdupq_n_u16(mask);\n    uint16x8_t src1_v, src2_v, result_v;\n\n    for (size_t i = 0; i < length; i += 8) {\n        src1_v = vld1q_u16(src1 + i);\n        src2_v = vld1q_u16(src2 + i);\n\n        uint16x8_t index_v = vld1q_u16((const uint16_t*)&i);\n        uint16x8_t index_mask = vandq_u16(index_v, mask_v);\n\n        uint16x8_t src1_masked = vbslq_u16(index_mask, src1_v, src2_v);\n\n        vst1q_u16(dst + i, src1_masked);\n    }\n}\n```  "}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16x8_t mask_v = vdupq_n_u16(mask);\n    uint16x8_t src1_v, src2_v, result_v;\n\n    for (size_t i = 0; i < length; i += 8) {\n        src1_v = vld1q_u16(src1 + i);\n        src2_v = vld1q_u16(src2 + i);\n\n        uint16x8_t index_v = vld1q_u16((const uint16_t*)&i);\n        uint16x8_t and_result = vandq_u16(index_v, mask_v);\n        uint8x8_t mask_result = vreinterpret_u8_u16(vshrq_n_u16(and_result, 8));\n\n        result_v = vbslq_u16(mask_result, src1_v, src2_v);\n\n        vst1q_u16(dst + i, result_v);\n    }\n}\n```  "}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16x8_t mask_v = vdupq_n_u16(mask);\n    uint16x8_t src1_v, src2_v, result_v;\n\n    for (size_t i = 0; i < length; i += 8) {\n        src1_v = vld1q_u16(src1 + i);\n        src2_v = vld1q_u16(src2 + i);\n\n        uint16x8_t index_v = vld1q_u16((const uint16_t*)&i);\n        uint16x8_t and_result = vandq_u16(index_v, mask_v);\n        uint8x8_t cmp_result = vreinterpret_u8_u16(vceqq_u16(and_result, vdupq_n_u16(0)));\n\n        result_v = vbslq_u16(cmp_result, src2_v, src1_v);\n\n        vst1q_u16(dst + i, result_v);\n    }\n}\n```  "}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16x8_t mask_neon = vdupq_n_u16(mask);\n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t index = vld1q_u16(&src1[i]);\n        uint16x8_t src1_val = vld1q_u16(&src1[i]);\n        uint16x8_t src2_val = vld1q_u16(&src2[i]);\n        uint16x8_t result = vbslq_u16(vandq_u16(vreinterpretq_u16_u32(vcgtq_u16(index, vdupq_n_u16(0))), mask_neon), src1_val, src2_val);\n        vst1q_u16(&dst[i], result);\n    }\n}\n```  "}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16x8_t mask_v = vdupq_n_u16(mask);\n    uint16x8_t src1_v, src2_v, result_v;\n\n    for (size_t i = 0; i < length; i += 8) {\n        src1_v = vld1q_u16(src1 + i);\n        src2_v = vld1q_u16(src2 + i);\n\n        uint16x8_t index_v = vld1q_u16((const uint16_t*)&i);\n        uint16x8_t and_result = vandq_u16(index_v, mask_v);\n        uint8x8_t cmp_result = vreinterpret_u8_u16(vceqq_u16(and_result, vdupq_n_u16(0)));\n\n        result_v = vbslq_u16(cmp_result, src2_v, src1_v);\n\n        vst1q_u16(dst + i, result_v);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint16x8_t v_max = vdupq_n_u16(UINT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint16x8_t v_sum = vqaddq_u16(v_src1, v_src2);\n        v_sum = vminq_u16(v_sum, v_max);\n\n        vst1q_u16(dst + i, v_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint16x8_t v_max = vdupq_n_u16(UINT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint16x8_t v_sum = vqaddq_u16(v_src1, v_src2);\n        v_sum = vminq_u16(v_sum, v_max);\n\n        vst1q_u16(dst + i, v_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint16x8_t v_max = vdupq_n_u16(UINT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint16x8_t v_sum = vqaddq_u16(v_src1, v_src2);\n        v_sum = vminq_u16(v_sum, v_max);\n\n        vst1q_u16(dst + i, v_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint16x8_t v_max = vdupq_n_u16(UINT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint16x8_t v_sum = vqaddq_u16(v_src1, v_src2);\n        v_sum = vminq_u16(v_sum, v_max);\n\n        vst1q_u16(dst + i, v_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint16x8_t v_max = vdupq_n_u16(UINT16_MAX);\n    \n    for (size_t i = 0; i < length; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n        \n        uint16x8_t v_sum = vqaddq_u16(v_src1, v_src2);\n        v_sum = vminq_u16(v_sum, v_max);\n        \n        vst1q_u16(dst + i, v_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n                uint64x2_t mask = vcleq_f64(a_vec, vdupq_n_f64(100.0)) & vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                float64x2_t prod_vec = vmulq_f64(a_vec, b_vec);\n                sum_vec = vaddq_f64(sum_vec, vbslq_f64(mask, prod_vec, vdupq_n_f64(0.0)));\n            }\n            C[i * p + j] = vgetq_lane_f64(vpaddq_f64(sum_vec, sum_vec), 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n                uint64x2_t mask_a = vcleq_f64(a_vec, vdupq_n_f64(100.0)) & vcgeq_f64(a_vec, vdupq_n_f64(-100.0));\n                uint64x2_t mask_b = vcleq_f64(b_vec, vdupq_n_f64(100.0)) & vcgeq_f64(b_vec, vdupq_n_f64(-100.0));\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                sum_vec = vaddq_f64(sum_vec, vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(prod), mask)));\n            }\n            C[i * p + j] = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                uint64x2_t mask_a = vcgeq_f64(a, vdupq_n_f64(-100.0)) & vcleq_f64(a, vdupq_n_f64(100.0));\n                uint64x2_t mask_b = vcgeq_f64(b, vdupq_n_f64(-100.0)) & vcleq_f64(b, vdupq_n_f64(100.0));\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                float64x2_t prod = vmulq_f64(a, b);\n                sum = vaddq_f64(sum, vbslq_f64(mask, prod, vdupq_n_f64(0.0)));\n            }\n            C[i * p + j] = vgetq_lane_f64(vpaddq_f64(sum, sum), 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n                uint64x2_t mask = vcleq_f64(a_vec, vdupq_n_f64(100.0)) & vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                sum_vec = vaddq_f64(sum_vec, vbslq_f64(mask, prod, vdupq_n_f64(0.0)));\n            }\n            C[i * p + j] = vgetq_lane_f64(vpaddq_f64(sum_vec, sum_vec), 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                uint64x2_t mask_a = vcgeq_f64(a, vdupq_n_f64(-100.0)) & vcleq_f64(a, vdupq_n_f64(100.0));\n                uint64x2_t mask_b = vcgeq_f64(b, vdupq_n_f64(-100.0)) & vcleq_f64(b, vdupq_n_f64(100.0));\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                float64x2_t prod = vmulq_f64(a, b);\n                sum = vaddq_f64(sum, vbslq_f64(mask, prod, vdupq_n_f64(0.0)));\n            }\n            C[i * p + j] = vgetq_lane_f64(vpaddq_f64(sum, sum), 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t neon_size = total_size / 2;\n\n    int64x2_t va, vb, vc;\n    for (size_t i = 0; i < neon_size; ++i) {\n        va = vld1q_s64(&A[i * 2]);\n        vb = vld1q_s64(&B[i * 2]);\n        vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i * 2], vc);\n    }\n\n    for (size_t i = neon_size * 2; i < total_size; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```  "}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t neon_size = total_size / 2;\n\n    int64x2_t a, b, result;\n    for (size_t i = 0; i < neon_size; ++i) {\n        a = vld1q_s64(&A[i*2]);\n        b = vld1q_s64(&B[i*2]);\n        result = vaddq_s64(a, b);\n        vst1q_s64(&C[i*2], result);\n    }\n\n    for (size_t i = neon_size * 2; i < total_size; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```  "}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t neon_size = total_size / 2;\n\n    int64x2_t* A_ptr = (int64x2_t*)A;\n    int64x2_t* B_ptr = (int64x2_t*)B;\n    int64x2_t* C_ptr = (int64x2_t*)C;\n\n    for (size_t i = 0; i < neon_size; ++i) {\n        int64x2_t va = vld1q_s64((int64_t*)&A_ptr[i]);\n        int64x2_t vb = vld1q_s64((int64_t*)&B_ptr[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64((int64_t*)&C_ptr[i], vc);\n    }\n\n    for (size_t i = neon_size * 2; i < total_size; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```  "}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n}\n```  "}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t neon_size = total_size / 2;\n\n    int64x2_t a, b, result;\n    for (size_t i = 0; i < neon_size; ++i) {\n        a = vld1q_s64(&A[i * 2]);\n        b = vld1q_s64(&B[i * 2]);\n        result = vaddq_s64(a, b);\n        vst1q_s64(&C[i * 2], result);\n    }\n\n    for (size_t i = neon_size * 2; i < total_size; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```  "}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    int i;\n    float32x4_t vec1, vec2, result;\n    for (i = 0; i < length; i += 4) {\n        vec1 = vld1q_f32(src1 + i);\n        vec2 = vld1q_f32(src2 + i);\n        result = vaddq_f32(vec1, vec2);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f));\n        result = vcvtq_s32_f32(result);\n        vst1q_s32(reinterpret_cast<int32_t*>(dst + i), vreinterpretq_s32_f32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    float32x4_t vec1, vec2, result;\n    \n    for (i = 0; i < length; i += 4) {\n        vec1 = vld1q_f32(src1 + i);\n        vec2 = vld1q_f32(src2 + i);\n        result = vaddq_f32(vec1, vec2);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f));\n        result = vcvtq_s32_f32(result);\n        vst1q_s32((int32_t*)(dst + i), vreinterpretq_s32_f32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    float32x4_t v1, v2, result;\n    for (i = 0; i < length; i += 4) {\n        v1 = vld1q_f32(src1 + i);\n        v2 = vld1q_f32(src2 + i);\n        result = vaddq_f32(v1, v2);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f));\n        vst1q_s32((int32_t*)(dst + i), vcvtq_s32_f32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    int i;\n    float32x4_t vec1, vec2, result;\n    for (i = 0; i < length; i += 4) {\n        vec1 = vld1q_f32(src1 + i);\n        vec2 = vld1q_f32(src2 + i);\n        result = vaddq_f32(vec1, vec2);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f));\n        result = vcvtq_s32_f32(result);\n        vst1q_s32((int32_t*)(dst + i), vreinterpretq_s32_f32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    int i;\n    float32x4_t vec1, vec2, result;\n    for (i = 0; i < length; i += 4) {\n        vec1 = vld1q_f32(src1 + i);\n        vec2 = vld1q_f32(src2 + i);\n        result = vaddq_f32(vec1, vec2);\n        result = vrndnq_f32(result);\n        vst1q_s32(reinterpret_cast<int32_t*>(dst + i), vcvtq_s32_f32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    int i;\n    float32x4_t v_threshold = vdupq_n_f32(50.0f);\n    float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n    float32x4_t v_rounding = vdupq_n_f32(0.5f);\n    \n    for(i = 0; i < length; i += 4){\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n        \n        uint32x4_t v_mask = vandq_u32(vcagtq_f32(v_threshold, vabdq_f32(v_src1, v_src2)), vdupq_n_u32(1));\n        v_mask = vandq_u32(v_mask, vceqq_s32(vreinterpretq_s32_f32(v_src1), vshrq_n_s32(vreinterpretq_s32_f32(v_src1), 1)));\n        \n        float32x4_t v_result = vbslq_f32(v_mask, vrhaddq_f32(vmulq_f32(v_src1, v_src2), v_rounding), v_minus_one);\n        \n        vst1q_f32(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    int i;\n    float32x4_t v50 = vdupq_n_f32(50.0f);\n    float32x4_t vneg1 = vdupq_n_f32(-1.0f);\n\n    for(i = 0; i < length; i += 4){\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        uint32x4_t vindex = vdupq_n_u32(i);\n        uint32x4_t vmul_cond = vandq_u32(vceqq_u32(vindex, vshrq_n_u32(vindex, 1)), vcleq_f32(vabsq_f32(vsubq_f32(vsrc1, vsrc2)), v50));\n\n        float32x4_t vmul = vmulq_f32(vsrc1, vsrc2);\n        float32x4_t vresult = vbslq_f32(vmul_cond, vcvtq_f32_s32(vcvtq_s32_f32(vmul)), vneg1);\n\n        vst1q_f32(dst + i, vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    int i;\n    float32x4_t v50 = vdupq_n_f32(50.0f);\n    float32x4_t vneg1 = vdupq_n_f32(-1.0f);\n    \n    for(i = 0; i < length; i += 4){\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        uint32x4_t mask1 = vcltq_f32(vabsq_f32(vsubq_f32(v1, v2)), v50);\n        uint32x4_t mask2 = vandq_u32(vcltq_u32(vdupq_n_u32(i), vdupq_n_u32(2)), mask1);\n        \n        float32x4_t result = vbslq_f32(mask2, vrndpq_f32(vmulq_f32(v1, v2)), vneg1);\n        \n        vst1q_f32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    int i;\n    float32x4_t v50 = vdupq_n_f32(50.0f);\n    float32x4_t vneg1 = vdupq_n_f32(-1.0f);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vtwo = vdupq_n_f32(2.0f);\n    \n    for(i = 0; i < length; i += 4){\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n        \n        float32x4_t vdiff = vsubq_f32(vsrc1, vsrc2);\n        uint32x4_t vabsdiff = vreinterpretq_u32_f32(vabsq_f32(vdiff));\n        uint32x4_t vcond1 = vcleq_f32(vreinterpretq_f32_u32(vabsdiff), v50);\n        uint32x4_t vcond2 = vandq_u32(vcltq_f32(vsrc1, vsrc2), vcltq_f32(vsrc2, vsrc1));\n        uint32x4_t vcond3 = vandq_u32(vmulq_n_f32(vrecpeq_f32(vtwo), vtwo), vcond1);\n        uint32x4_t vcond = vandq_u32(vcond2, vcond3);\n        \n        float32x4_t vresult = vbslq_f32(vcond, vcvtq_f32_s32(vcvtq_s32_f32(vsrc1 * vsrc2)), vneg1);\n        vst1q_f32(dst + i, vrndpq_f32(vresult));\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    int i;\n    float32x4_t v50 = vdupq_n_f32(50.0f);\n    float32x4_t vneg1 = vdupq_n_f32(-1.0f);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vtwo = vdupq_n_f32(2.0f);\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t vsrc1 = vld1q_f32(src1 + i);\n        float32x4_t vsrc2 = vld1q_f32(src2 + i);\n\n        float32x4_t vdiff = vsubq_f32(vsrc1, vsrc2);\n        uint32x4_t vabsdiff = vreinterpretq_u32_f32(vabsq_f32(vdiff));\n        uint32x4_t vcond1 = vcleq_f32(vreinterpretq_f32_u32(vabsdiff), v50);\n        uint32x4_t vcond2 = vceqq_u32(vandq_u32(vabsdiff, vreinterpretq_u32_f32(vtwo)), vzero);\n        uint32x4_t vcond = vandq_u32(vcond1, vcond2);\n\n        float32x4_t vmul = vmulq_f32(vsrc1, vsrc2);\n        float32x4_t vresult = vbslq_f32(vcond, vcvtq_f32_s32(vcvtq_s32_f32(vmul)), vneg1);\n\n        vst1q_f32(dst + i, vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    float64x2_t scalar_v = vdupq_n_f64(scalar);\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t mat_v = vld1q_f64(&mat[i * n + j]);\n            float64x2_t result = vmulq_f64(mat_v, scalar_v);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    float64x2_t scalar_v = vdupq_n_f64(scalar);\n    for (i = 0; i < m; ++i) {\n        size_t base_idx = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t mat_v = vld1q_f64(&mat[base_idx + j]);\n            float64x2_t result = vmulq_f64(mat_v, scalar_v);\n            vst1q_f64(&dst[base_idx + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_size = m * n;\n    size_t neon_size = total_size / 2 * 2;\n\n    float64x2_t scalar_v = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < neon_size; i += 2) {\n        float64x2_t mat_v = vld1q_f64(mat + i);\n        float64x2_t result = vmulq_f64(mat_v, scalar_v);\n        vst1q_f64(dst + i, result);\n    }\n\n    for (size_t i = neon_size; i < total_size; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```  "}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    float64x2_t scalar_v = vdupq_n_f64(scalar);\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t mat_v = vld1q_f64(&mat[i * n + j]);\n            float64x2_t result = vmulq_f64(mat_v, scalar_v);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    float64x2_t scalar_v = vdupq_n_f64(scalar);\n    \n    for (i = 0; i < m; ++i) {\n        size_t base_idx = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t mat_v = vld1q_f64(&mat[base_idx + j]);\n            float64x2_t result = vmulq_f64(mat_v, scalar_v);\n            vst1q_f64(&dst[base_idx + j], result);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_sq = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_sq = vaddq_f32(sum_sq, vmulq_f32(vec, vec));\n        }\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float32x2_t sum_sq_final = vpadd_f32(sum_sq_low, sum_sq_low);\n        float norm = vget_lane_f32(sum_sq_final, 0);\n        norm = 1.0f / sqrtf(norm);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vmulq_n_f32(vec, norm);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_sq = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_sq = vaddq_f32(sum_sq, vmulq_f32(vec, vec));\n        }\n        float32x2_t sum_sq2 = vpadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float32x2_t sum_sq_final = vpadd_f32(sum_sq2, sum_sq2);\n        float32x2_t norm = vrsqrte_f32(sum_sq_final);\n        float32x4_t norm_dup = vcombine_f32(norm, norm);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized = vmulq_f32(vec, norm_dup);\n            vst1q_f32(&mat[i * n + j], normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_sq = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_sq = vaddq_f32(sum_sq, vmulq_f32(vec, vec));\n        }\n        float32x2_t sum_sq2 = vpadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float32x2_t sum_sq_final = vpadd_f32(sum_sq2, sum_sq2);\n        float32x2_t norm = vrsqrte_f32(sum_sq_final);\n        float32x4_t norm_dup = vcombine_f32(norm, norm);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vmulq_f32(vec, norm_dup);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_sq = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_sq = vaddq_f32(sum_sq, vmulq_f32(vec, vec));\n        }\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float32x2_t sum_sq_final = vpadd_f32(sum_sq_low, sum_sq_low);\n        float norm = 1.0f / sqrtf(vget_lane_f32(sum_sq_final, 0));\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized_vec = vmulq_n_f32(vec, norm);\n            vst1q_f32(&mat[i * n + j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_sq = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_sq = vaddq_f32(sum_sq, vmulq_f32(vec, vec));\n        }\n        float32x2_t sum_sq2 = vpadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float32x2_t sum_sq_final = vpadd_f32(sum_sq2, sum_sq2);\n        float32x2_t norm = vrsqrte_f32(sum_sq_final);\n        float32x4_t norm_dup = vcombine_f32(norm, norm);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized = vmulq_f32(vec, norm_dup);\n            vst1q_f32(&mat[i * n + j], normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded = vcvtq_s64_f64(sum);\n            int64x2_t result = vqmovn_s64(rounded);\n            vst1q_s64(&dst[i * p + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t result = vcvtq_s64_f64(sum);\n            int64x2_t rounded = vqrdmulhq_s64(result, vdupq_n_s64(2));\n            int32x2_t final_result = vqmovn_s64(rounded);\n            vst1_s32(&dst[i * p + j], final_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b = vld1q_f64(mat2 + k * p + j);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            dst[i * p + j] = (double)vcvtq_s32_f32(vrndn_f32(vcombine_f32(vcvt_f32_f64(sum), vcvt_f32_f64(vext_f64(sum, sum, 1))))[0]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t result = vcvtq_s64_f64(sum);\n            int32x2_t rounded = vqmovn_s64(result);\n            int32x2_t final_result = vqmovn_s32(vcombine_s32(rounded, rounded));\n            vst1_s32(&dst[i * p + j], final_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t result = vcvtq_s64_f64(sum);\n            int32x2_t rounded = vqmovn_s64(result);\n            int32x2_t final_result = vcombine_s32(rounded, rounded);\n            vst1_s32(&dst[i * p + j], final_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    float32x4_t in0, in1, in2, in3, out0, out1, out2, out3, quarter;\n    quarter = vdupq_n_f32(0.25f);\n\n    for (i = 0; i < cols; i += 4) {\n        for (j = 0; j < rows; j += 4) {\n            in0 = vld1q_f32(&src[j * cols + i]);\n            in1 = vld1q_f32(&src[(j + 1) * cols + i]);\n            in2 = vld1q_f32(&src[(j + 2) * cols + i]);\n            in3 = vld1q_f32(&src[(j + 3) * cols + i]);\n\n            out0 = vcombine_f32(vroundq_f32(vmulq_f32(in0, quarter)), vroundq_f32(vmulq_f32(in1, quarter)));\n            out1 = vcombine_f32(vroundq_f32(vmulq_f32(in2, quarter)), vroundq_f32(vmulq_f32(in3, quarter)));\n\n            vst1q_f32(&dst[i * rows + j], out0);\n            vst1q_f32(&dst[i * rows + j + 4], out1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    float32x4_t v_in, v_out;\n    for (i = 0; i < rows; i += 4) {\n        for (j = 0; j < cols; j++) {\n            v_in = vld1q_f32(src + i * cols + j);\n            v_out = vcombine_f32(vroundq_f32(v_in * 4.0f), vdup_n_f32(0.25f));\n            vst1q_f32(dst + j * rows + i, v_out);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4x4_t in = vld4q_f32(src + i * cols + j);\n            float32x4x4_t out;\n            out.val[0] = vaddq_f32(in.val[0], vdupq_n_f32(0.25f));\n            out.val[1] = vaddq_f32(in.val[1], vdupq_n_f32(0.25f));\n            out.val[2] = vaddq_f32(in.val[2], vdupq_n_f32(0.25f));\n            out.val[3] = vaddq_f32(in.val[3], vdupq_n_f32(0.25f));\n            vst4q_f32(dst + j * rows + i, out);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    float32x4_t vScale = vdupq_n_f32(0.25f);\n\n    for (i = 0; i < rows; i += 4) {\n        for (j = 0; j < cols; j += 4) {\n            float32x4x4_t vSrc;\n            float32x4x4_t vDst;\n\n            vSrc.val[0] = vld1q_f32(&src[(j + 0) * rows + i]);\n            vSrc.val[1] = vld1q_f32(&src[(j + 1) * rows + i]);\n            vSrc.val[2] = vld1q_f32(&src[(j + 2) * rows + i]);\n            vSrc.val[3] = vld1q_f32(&src[(j + 3) * rows + i]);\n\n            vDst.val[0] = vcombine_f32(vrndnq_f32(vmulq_f32(vSrc.val[0], vScale)), vrndnq_f32(vmulq_f32(vSrc.val[1], vScale)));\n            vDst.val[1] = vcombine_f32(vrndnq_f32(vmulq_f32(vSrc.val[2], vScale)), vrndnq_f32(vmulq_f32(vSrc.val[3], vScale)));\n\n            vst1q_f32(&dst[(i + 0) * cols + j], vget_low_f32(vDst.val[0]));\n            vst1q_f32(&dst[(i + 1) * cols + j], vget_high_f32(vDst.val[0]));\n            vst1q_f32(&dst[(i + 2) * cols + j], vget_low_f32(vDst.val[1]));\n            vst1q_f32(&dst[(i + 3) * cols + j], vget_high_f32(vDst.val[1]));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    float32x4_t in0, in1, in2, in3, out0, out1, out2, out3, quarter;\n    quarter = vdupq_n_f32(0.25f);\n\n    for (i = 0; i < rows; i += 4) {\n        for (j = 0; j < cols; j += 4) {\n            in0 = vld1q_f32(&src[(j * rows) + i]);\n            in1 = vld1q_f32(&src[(j * rows) + i + 1]);\n            in2 = vld1q_f32(&src[(j * rows) + i + 2]);\n            in3 = vld1q_f32(&src[(j * rows) + i + 3]);\n\n            out0 = vaddq_f32(in0, quarter);\n            out1 = vaddq_f32(in1, quarter);\n            out2 = vaddq_f32(in2, quarter);\n            out3 = vaddq_f32(in3, quarter);\n\n            vst1q_f32(&dst[(i * cols) + j], out0);\n            vst1q_f32(&dst[(i * cols) + j + 1], out1);\n            vst1q_f32(&dst[(i * cols) + j + 2], out2);\n            vst1q_f32(&dst[(i * cols) + j + 3], out3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1*dim2*dim3; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcleq_f32(result, zero);\n        float32x4_t rounded_result = vbslq_f32(mask, vrndmq_f32(result), vrndpq_f32(result));\n        vst1q_f32(&dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcleq_f32(result, zero);\n        float32x4_t rounded_result = vbslq_f32(mask, vrndmq_f32(result), vrndpq_f32(result));\n        vst1q_f32(&dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcleq_f32(result, zero);\n        float32x4_t rounded_result = vbslq_f32(mask, vroundq_f32(result), vnegq_f32(vroundq_f32(vnegq_f32(result))));\n        vst1q_f32(&dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcleq_f32(result, zero);\n        float32x4_t rounded_result = vbslq_f32(mask, vrndq_f32(result), vnegq_f32(vrndq_f32(vnegq_f32(result))));\n        vst1q_f32(&dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcleq_f32(result, zero);\n        float32x4_t rounded_result = vbslq_f32(mask, vrndmq_f32(result), vrndpq_f32(result));\n        vst1q_f32(&dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        size_t offset = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&mat1[offset + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[offset + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[offset + j], result);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t size = m * n;\n    size_t i;\n    for (i = 0; i < size; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```  "}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        size_t offset = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&mat1[offset + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[offset + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[offset + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        size_t offset = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&mat1[offset + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[offset + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[offset + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; i++) {\n        size_t offset = i * n;\n        for (j = 0; j < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&mat1[offset + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[offset + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[offset + j], result);\n        }\n    }\n}\n```  "}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t acc = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_data = vld1q_f32(&vec[j]);\n            acc = vmlaq_f32(acc, mat_data, vec_data);\n        }\n        float32x2_t acc_high = vget_high_f32(acc);\n        float32x2_t acc_low = vget_low_f32(acc);\n        float32x2_t acc_sum = vpadd_f32(acc_low, acc_high);\n        float32_t result = vget_lane_f32(acc_sum, 0) + vget_lane_f32(acc_sum, 1);\n        dst[i] = result;\n    }\n}\n```  "}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t acc = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_data = vld1q_f32(&vec[j]);\n            acc = vmlaq_f32(acc, mat_data, vec_data);\n        }\n        float32x2_t acc_high = vget_high_f32(acc);\n        float32x2_t acc_low = vget_low_f32(acc);\n        acc_high = vpadd_f32(acc_low, acc_high);\n        float32x2_t result = vpadd_f32(acc_high, acc_high);\n        dst[i] = vget_lane_f32(result, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t acc = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_data = vld1q_f32(&vec[j]);\n            acc = vmlaq_f32(acc, mat_data, vec_data);\n        }\n        float32x2_t acc_low = vadd_f32(vget_low_f32(acc), vget_high_f32(acc));\n        float32x2_t acc_sum = vpadd_f32(acc_low, acc_low);\n        dst[i] = vget_lane_f32(acc_sum, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    float32x4_t vec_reg, mat_reg, res_reg;\n    \n    for (i = 0; i < m; i++) {\n        res_reg = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            vec_reg = vld1q_f32(&vec[j]);\n            mat_reg = vld1q_f32(&mat[i * n + j]);\n            res_reg = vmlaq_f32(res_reg, mat_reg, vec_reg);\n        }\n        float32x2_t res_add = vpadd_f32(vget_low_f32(res_reg), vget_high_f32(res_reg));\n        float32x2_t res_sum = vpadd_f32(res_add, res_add);\n        dst[i] = vget_lane_f32(res_sum, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    float32x4_t vec_neon = vld1q_f32(vec);\n\n    for (i = 0; i < m; i++) {\n        float32x4_t acc = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t mat_neon = vld1q_f32(&mat[i * n + j]);\n            float32x4_t mul = vmulq_f32(mat_neon, vec_neon);\n            acc = vaddq_f32(acc, mul);\n        }\n        float32x2_t acc_high = vget_high_f32(acc);\n        float32x2_t acc_low = vget_low_f32(acc);\n        float32x2_t acc_sum = vpadd_f32(acc_low, acc_high);\n        dst[i] = vget_lane_f32(acc_sum, 0) + vget_lane_f32(acc_sum, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t data = vld1q_f64(mat + i);\n        sum = vaddq_f64(sum, data);\n    }\n\n    float64x2_t sum_reduced = vpaddq_f64(sum, sum);\n    double result = vgetq_lane_f64(sum_reduced, 0) / total_elements;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum = vaddq_f64(sum, vec);\n    }\n\n    float64x2_t sum_final = vpaddq_f64(sum, sum);\n    double result = vgetq_lane_f64(sum_final, 0) / total_elements;\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t data = vld1q_f64(mat + i);\n        sum = vaddq_f64(sum, data);\n    }\n\n    float64x2_t sum_h = vpaddq_f64(sum, sum);\n    float64x2_t avg = vmulq_f64(sum_h, vdupq_n_f64(0.5));\n\n    double result;\n    vst1q_lane_f64(&result, avg, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t neon_elements = n / 2;\n    \n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        const double* row = mat + i * n;\n        \n        for (size_t j = 0; j < neon_elements; j++) {\n            float64x2_t vec = vld1q_f64(row);\n            sum = vaddq_f64(sum, vec);\n            row += 2;\n        }\n    }\n    \n    double result = vgetq_lane_f64(vpaddq_f64(sum, sum), 0) / total_elements;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t data = vld1q_f64(mat + i);\n        sum = vaddq_f64(sum, data);\n    }\n\n    float64x2_t sum_final = vpaddq_f64(sum, sum);\n    double result = vgetq_lane_f64(sum_final, 0) / total_elements;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        bool direction = directions[i];\n        for (size_t j = 1; j < cols / 4; ++j) {\n            int32x4_t current = vld1q_s32(&matrix[i * cols + j * 4]);\n            int32x4_t cmp_result;\n            if (direction) {\n                cmp_result = vcgtq_s32(current, prev);\n            } else {\n                cmp_result = vcltq_s32(current, prev);\n            }\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp_result)) != 0) {\n                return false;\n            }\n            prev = current;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        bool direction = directions[i];\n        for (size_t j = 1; j < cols / 4; ++j) {\n            int32x4_t current = vld1q_s32(&matrix[i * cols + j * 4]);\n            int32x4_t cmp_result = direction ? vcgeq_s32(current, prev) : vcleq_s32(current, prev);\n            if (vaddvq_u8(vreinterpretq_u8_s32(cmp_result)) != 16) {\n                return false;\n            }\n            prev = current;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        bool direction = directions[i];\n        for (size_t j = 1; j < cols; j += 4) {\n            int32x4_t current = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t cmp_result;\n            if (direction) {\n                cmp_result = vcleq_s32(prev, current);\n            } else {\n                cmp_result = vcgeq_s32(prev, current);\n            }\n            if (vaddvq_u8(vreinterpretq_u8_s32(cmp_result)) != 16) {\n                return false;\n            }\n            prev = current;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        bool ascending = directions[i];\n        \n        for (size_t j = 1; j < cols / 4; ++j) {\n            int32x4_t current = vld1q_s32(&matrix[i * cols + j * 4]);\n            int32x4_t cmp_result = ascending ? vcgtq_s32(current, prev) : vcltq_s32(current, prev);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp_result)) != 0) {\n                return false;\n            }\n            prev = current;\n        }\n        \n        for (size_t j = cols / 4 * 4; j < cols; ++j) {\n            int32_t current_scalar = matrix[i * cols + j];\n            int32_t prev_scalar = vgetq_lane_s32(prev, 3);\n            bool cmp_result = ascending ? current_scalar >= prev_scalar : current_scalar <= prev_scalar;\n            if (!cmp_result) {\n                return false;\n            }\n            prev = vsetq_lane_s32(current_scalar, prev, 3);\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        bool direction = directions[i];\n        for (size_t j = 1; j < cols; j += 4) {\n            int32x4_t current = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t cmp_result;\n            if (direction) {\n                cmp_result = vcgtq_s32(current, prev);\n            } else {\n                cmp_result = vcltq_s32(current, prev);\n            }\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp_result)) != 0) {\n                return false;\n            }\n            prev = current;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_v = vdupq_n_s16(base);\n    int16x8_t max_val = vdupq_n_s16(INT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_v = vld1q_s16(src + i);\n        int16x8_t div = vqrdmulhq_s16(src_v, base_v);\n        int16x8_t result = vqmovn_s16(vminq_s16(div, max_val));\n        vst1q_s16(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_v = vdupq_n_s16(base);\n    int16x8_t max_val = vdupq_n_s16(INT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_v = vld1q_s16(src + i);\n        int16x8_t div = vshrq_n_s16(src_v, 15); // 0 if src_v >= 0, -1 if src_v < 0\n        int16x8_t abs_src_v = vabsq_s16(src_v);\n        int16x8_t rem = vsubq_s16(abs_src_v, vandq_s16(abs_src_v, base_v));\n        int16x8_t nearest_multiple = vsubq_s16(abs_src_v, rem);\n        int16x8_t result = vqdmulhq_s16(nearest_multiple, vaddq_s16(div, vshrq_n_s16(nearest_multiple, 15)));\n        result = vminq_s16(result, max_val);\n        vst1q_s16(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_v = vdupq_n_s16(base);\n    int16x8_t max_val = vdupq_n_s16(INT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_v = vld1q_s16(src + i);\n        int16x8_t div = vshrq_n_s16(src_v, 15);\n        int16x8_t abs_src_v = vabsq_s16(src_v);\n        int16x8_t mul = vqrdmulhq_s16(abs_src_v, base_v);\n        int16x8_t cmp = vcleq_s16(mul, abs_src_v);\n        int16x8_t result = vbslq_s16(cmp, mul, vqrdmulhq_s16(vsubq_s16(mul, base_v), div));\n        result = vqdmulhq_s16(result, vnegq_s16(div));\n        result = vqaddq_s16(result, vandq_s16(max_val, div));\n        vst1q_s16(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_v = vdupq_n_s16(base);\n    int16x8_t max_val = vdupq_n_s16(INT16_MAX);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_v = vld1q_s16(src + i);\n        int16x8_t div = vshrq_n_s16(src_v, 15);\n        int16x8_t remainder = vsubq_s16(src_v, vmulq_s16(base_v, vshrq_n_s16(src_v, 15)));\n        int16x8_t multiple = vsubq_s16(src_v, remainder);\n        int16x8_t diff = vsubq_s16(src_v, multiple);\n        uint16x8_t mask = vcleq_s16(diff, vdupq_n_s16(0));\n        int16x8_t result = vbslq_s16(mask, multiple, vsubq_s16(multiple, base_v));\n        result = vminq_s16(result, max_val);\n        vst1q_s16(dst + i, result);\n    }\n}\n```  "}
{"task_id": "SimdBench_31_Neon", "completion": "```\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_v = vdupq_n_s16(base);\n    int16x8_t zero_v = vdupq_n_s16(0);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_v = vld1q_s16(src + i);\n        int16x8_t div_v = vqrdmulhq_s16(src_v, base_v);\n        int16x8_t result_v = vqshrn_n_s32(vqaddq_s32(vshrq_n_s32(div_v, 15), vandq_s32(div_v, zero_v)), 15);\n        vst1q_s16(dst + i, result_v);\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* matrix_row = matrix + i * cols;\n        uint8x8_t result = vceqq_f64(vld1_u64((uint64_t*)matrix_row), vld1_u64((uint64_t*)vector));\n        if (vgetq_lane_u64(vreinterpretq_u64_u8(result), 0) == 0xFFFFFFFFFFFFFFFF) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        uint8x8_t result = vceqq_f64(vld1_f64(row), vld1_f64(vector));\n        if (vget_lane_u64(vreinterpret_u64_u8(result), 0) == 0xFFFFFFFFFFFFFFFF) {\n            return true;\n        }\n    }\n    return false;\n}\n```  "}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        uint8x8_t result = vceqq_f64(vld1_u64((uint64_t*)row), vld1_u64((uint64_t*)vector));\n        if (vgetq_lane_u8(result, 0) && vgetq_lane_u8(result, 1) && vgetq_lane_u8(result, 2) && vgetq_lane_u8(result, 3) &&\n            vgetq_lane_u8(result, 4) && vgetq_lane_u8(result, 5) && vgetq_lane_u8(result, 6) && vgetq_lane_u8(result, 7)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        uint8x8_t result = vceqq_f64(vld1_u64((uint64_t*)row), vld1_u64((uint64_t*)vector));\n        if (vgetq_lane_u8(result, 0) && vgetq_lane_u8(result, 1) && vgetq_lane_u8(result, 2) && vgetq_lane_u8(result, 3) &&\n            vgetq_lane_u8(result, 4) && vgetq_lane_u8(result, 5) && vgetq_lane_u8(result, 6) && vgetq_lane_u8(result, 7)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        uint8x8_t result = vceqq_f64(vld1_u64((uint64_t*)row_ptr), vld1_u64((uint64_t*)vector));\n        if (vgetq_lane_u64(vreinterpretq_u64_u8(result), 0) == 0xFFFFFFFFFFFFFFFF) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t neon_elements = total_elements / 16;\n    \n    uint8x16_t va, vb;\n    uint8x16_t vcount = vdupq_n_u8(0);\n    \n    for (size_t i = 0; i < neon_elements; ++i) {\n        va = vld1q_u8(A);\n        vb = vld1q_u8(B);\n        vcount = vaddq_u8(vcount, vceqq_u8(va, vb));\n        A += 16;\n        B += 16;\n    }\n    \n    uint8x8_t vcount_low = vget_low_u8(vcount);\n    uint8x8_t vcount_high = vget_high_u8(vcount);\n    uint8x8_t vcount_sum = vpadd_u8(vcount_low, vcount_high);\n    uint8x8_t vcount_final = vpadd_u8(vcount_sum, vcount_sum);\n    \n    count = vget_lane_u8(vcount_final, 0);\n    \n    for (size_t i = neon_elements * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t neon_elements = total_elements / 16;\n\n    uint8x16_t va, vb;\n    uint8x16_t vcount = vdupq_n_u8(0);\n\n    for (size_t i = 0; i < neon_elements; ++i) {\n        va = vld1q_u8(A);\n        vb = vld1q_u8(B);\n        vcount = vaddq_u8(vcount, vceqq_u8(va, vb));\n        A += 16;\n        B += 16;\n    }\n\n    uint8x8_t vcount_low = vget_low_u8(vcount);\n    uint8x8_t vcount_high = vget_high_u8(vcount);\n    uint8x8_t vsum = vpadd_u8(vcount_low, vcount_low);\n    vsum = vpadd_u8(vsum, vsum);\n    uint8x8_t vsum_high = vpadd_u8(vcount_high, vcount_high);\n    vsum_high = vpadd_u8(vsum_high, vsum_high);\n    count = vget_lane_u8(vsum, 0) + vget_lane_u8(vsum_high, 0);\n\n    for (size_t i = neon_elements * 16; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t neon_elements = total_elements / 16;\n    \n    uint8x16_t va, vb;\n    uint8x16_t vcount = vdupq_n_u8(0);\n    \n    for (size_t i = 0; i < neon_elements; ++i) {\n        va = vld1q_u8(A);\n        vb = vld1q_u8(B);\n        vcount = vaddq_u8(vcount, vceqq_u8(va, vb));\n        A += 16;\n        B += 16;\n    }\n    \n    uint8x8_t vcount_low = vget_low_u8(vcount);\n    uint8x8_t vcount_high = vget_high_u8(vcount);\n    uint8x8_t vsum = vpadd_u8(vcount_low, vcount_low);\n    vsum = vpadd_u8(vsum, vsum);\n    \n    count = vget_lane_u8(vsum, 0);\n    \n    for (size_t i = neon_elements * 16; i < total_elements; ++i) {\n        if (*A == *B) {\n            count++;\n        }\n        A++;\n        B++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    const size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    const size_t neon_size = 16;\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += neon_size) {\n        uint8x16_t va = vld1q_u8(A + i);\n        uint8x16_t vb = vld1q_u8(B + i);\n        uint8x16_t equal = vceqq_u8(va, vb);\n        uint8x16_t result = vandq_u8(equal, vdupq_n_u8(0xFF));\n        count += vaddvq_u8(result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t neon_elements = total_elements / 16;\n    \n    uint8x16_t va, vb;\n    uint8x16_t vcount = vdupq_n_u8(0);\n    \n    for (size_t i = 0; i < neon_elements; ++i) {\n        va = vld1q_u8(A + i * 16);\n        vb = vld1q_u8(B + i * 16);\n        vcount = vaddq_u8(vcount, vceqq_u8(va, vb));\n    }\n    \n    uint8_t count_array[16];\n    vst1q_u8(count_array, vcount);\n    \n    for (int i = 0; i < 16; ++i) {\n        count += count_array[i];\n    }\n    \n    for (size_t i = neon_elements * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x1_t scalar_a = vdup_n_s64(a);\n    for (size_t i = 0; i < length; i += 1) {\n        int64x1_t vector_x = vld1_s64(x + i);\n        int64x1_t result = vqdmulh_s64(vector_x, scalar_a);\n        int64x1_t abs_result = vabs_s64(result);\n        vst1_s64(y + i, abs_result);\n    }\n}\n```  "}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x1_t scalar_a = vdup_n_s64(a);\n    int64x2_t vec_x, vec_y;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        vec_x = vld1q_s64(x + i);\n        vec_y = vqdmulhq_s64(vec_x, scalar_a);\n        vec_y = vqabsq_s64(vec_y);\n        vst1q_s64(y + i, vec_y);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x1_t scalar_a = vdup_n_s64(a);\n    int64x2_t vec_x, vec_y;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        vec_x = vld1q_s64(x + i);\n        vec_y = vqdmulhq_s64(vec_x, scalar_a);\n        vec_y = vqabsq_s64(vec_y);\n        vst1q_s64(y + i, vec_y);\n    }\n}\n```  "}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x1_t scalar_a = vdup_n_s64(a);\n    for (size_t i = 0; i < length; i += 1) {\n        int64x1_t vector_x = vld1_s64(x + i);\n        int64x1_t result = vqdmulh_s64(vector_x, scalar_a);\n        int64x1_t abs_result = vabs_s64(result);\n        vst1_s64(y + i, abs_result);\n    }\n}\n```  "}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x1_t scalar_a = vdup_n_s64(a);\n    \n    for (size_t i = 0; i < length; i += 1) {\n        int64x1_t vector_x = vld1_s64(x + i);\n        int64x1_t result = vqdmulh_s64(vector_x, scalar_a);\n        int64x1_t abs_result = vabs_s64(result);\n        vst1_s64(y + i, abs_result);\n    }\n}\n```  "}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vld1q_s16(vec);\n    int16x8_t max_val = vld1q_s16(vec);\n    \n    for (size_t i = 8; i < length; i += 8) {\n        int16x8_t data = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, data);\n        max_val = vmaxq_s16(max_val, data);\n    }\n\n    int16_t min_array[8];\n    int16_t max_array[8];\n    vst1q_s16(min_array, min_val);\n    vst1q_s16(max_array, max_val);\n\n    for (int i = 0; i < 8; ++i) {\n        min_val = vmin_s16(min_val, vdup_n_s16(min_array[i]));\n        max_val = vmax_s16(max_val, vdup_n_s16(max_array[i]));\n    }\n\n    MinMaxPair result;\n    result.min_num = vget_lane_s16(min_val, 0);\n    result.max_num = vget_lane_s16(max_val, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vld1q_s16(vec);\n    int16x8_t max_val = vld1q_s16(vec);\n    \n    for (size_t i = 8; i < length; i += 8) {\n        int16x8_t data = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, data);\n        max_val = vmaxq_s16(max_val, data);\n    }\n\n    int16_t min_array[8];\n    int16_t max_array[8];\n    vst1q_s16(min_array, min_val);\n    vst1q_s16(max_array, max_val);\n\n    for (int i = 0; i < 8; ++i) {\n        min_val = vminq_s16(vld1q_s16(&min_array[i]), min_val);\n        max_val = vmaxq_s16(vld1q_s16(&max_array[i]), max_val);\n    }\n\n    MinMaxPair result;\n    result.min_num = vgetq_lane_s16(min_val, 0);\n    result.max_num = vgetq_lane_s16(max_val, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vld1q_s16(vec);\n    int16x8_t max_val = vld1q_s16(vec);\n    \n    for (size_t i = 8; i < length; i += 8) {\n        int16x8_t vec_val = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, vec_val);\n        max_val = vmaxq_s16(max_val, vec_val);\n    }\n    \n    int16_t min_array[8];\n    int16_t max_array[8];\n    vst1q_s16(min_array, min_val);\n    vst1q_s16(max_array, max_val);\n    \n    int16_t min_num = min_array[0];\n    int16_t max_num = max_array[0];\n    \n    for (int i = 1; i < 8; i++) {\n        if (min_array[i] < min_num) {\n            min_num = min_array[i];\n        }\n        if (max_array[i] > max_num) {\n            max_num = max_array[i];\n        }\n    }\n    \n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vld1q_s16(vec);\n    int16x8_t max_val = vld1q_s16(vec);\n    \n    for (size_t i = 8; i < length; i += 8) {\n        int16x8_t data = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, data);\n        max_val = vmaxq_s16(max_val, data);\n    }\n    \n    int16_t min_array[8];\n    int16_t max_array[8];\n    vst1q_s16(min_array, min_val);\n    vst1q_s16(max_array, max_val);\n    \n    for (int i = 0; i < 8; ++i) {\n        min_array[i] = std::min(min_array[i], min_array[i + 8]);\n        max_array[i] = std::max(max_array[i], max_array[i + 8]);\n    }\n    \n    MinMaxPair result;\n    result.min_num = min_array[0];\n    result.max_num = max_array[0];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin_val = vld1q_s16(vec);\n    int16x8_t vmax_val = vmin_val;\n\n    for (size_t i = 8; i < length; i += 8) {\n        int16x8_t vec_val = vld1q_s16(&vec[i]);\n        vmin_val = vminq_s16(vmin_val, vec_val);\n        vmax_val = vmaxq_s16(vmax_val, vec_val);\n    }\n\n    int16_t min_array[8];\n    int16_t max_array[8];\n    vst1q_s16(min_array, vmin_val);\n    vst1q_s16(max_array, vmax_val);\n\n    int16_t min_num = min_array[0];\n    int16_t max_num = max_array[0];\n    for (int i = 1; i < 8; ++i) {\n        if (min_array[i] < min_num) {\n            min_num = min_array[i];\n        }\n        if (max_array[i] > max_num) {\n            max_num = max_array[i];\n        }\n    }\n\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        int32x4_t prev_values = vld1q_s32(&matrix[i * cols]);\n        for (size_t j = 1; j < cols; j += 4) {\n            int32x4_t current_values = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp_result = vcgtq_s32(current_values, prev_values);\n            if (vaddvq_u32(cmp_result) != 4) {\n                return false;\n            }\n            prev_values = current_values;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int32_t* row = matrix + i * cols;\n        uint32x4_t prev_values = vld1q_u32((const uint32_t*)row);\n\n        for (size_t j = 1; j < cols; ++j) {\n            uint32x4_t current_values = vld1q_u32((const uint32_t*)(row + j));\n            uint32x4_t cmp_result = vcltq_u32(prev_values, current_values);\n            uint32x2_t cmp_result_low = vget_low_u32(cmp_result);\n            uint32x2_t cmp_result_high = vget_high_u32(cmp_result);\n            uint32x2_t cmp_result_final = vpmin_u32(cmp_result_low, cmp_result_high);\n            uint32_t result = vget_lane_u32(cmp_result_final, 0) & vget_lane_u32(cmp_result_final, 1);\n            if (result == 0) {\n                return false;\n            }\n            prev_values = current_values;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        int32x4_t prev_values = vld1q_s32(&matrix[i * cols]);\n        for (size_t j = 1; j < cols; j += 4) {\n            int32x4_t current_values = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp_result = vcgtq_s32(current_values, prev_values);\n            if (vaddvq_u32(cmp_result) != 4) {\n                return false;\n            }\n            prev_values = current_values;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int32_t* row = matrix + i * cols;\n        uint32x4_t prev_values = vld1q_u32((const uint32_t*)row);\n\n        for (size_t j = 1; j < cols; j += 4) {\n            uint32x4_t current_values = vld1q_u32((const uint32_t*)(row + j));\n            uint32x4_t cmp_result = vcltq_u32(prev_values, current_values);\n            uint32x2_t cmp_result_low = vget_low_u32(cmp_result);\n            uint32x2_t cmp_result_high = vget_high_u32(cmp_result);\n            uint32x2_t cmp_result_final = vpmin_u32(cmp_result_low, cmp_result_high);\n            uint32_t result = vget_lane_u32(cmp_result_final, 0) & vget_lane_u32(cmp_result_final, 1);\n            if (result == 0) {\n                return false;\n            }\n            prev_values = current_values;\n        }\n    }\n\n    return true;\n}\n```  "}
{"task_id": "SimdBench_36_Neon", "completion": "```\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        int32x4_t prev_values = vld1q_s32(&matrix[i * cols]);\n        for (size_t j = 1; j < cols; j += 4) {\n            int32x4_t current_values = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp_result = vcgtq_s32(current_values, prev_values);\n            if (vgetq_lane_u32(cmp_result, 0) == 0 || vgetq_lane_u32(cmp_result, 1) == 0 || vgetq_lane_u32(cmp_result, 2) == 0 || vgetq_lane_u32(cmp_result, 3) == 0) {\n                return false;\n            }\n            prev_values = current_values;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            int32x4_t first_block = vld1q_s32(matrix + i * cols + j);\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    int32x4_t current_block = vld1q_s32(matrix + (i + k) * cols + j + l);\n                    if (!vceqq_s32(first_block, current_block)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* block = matrix + i * cols + j;\n            int32x4x4_t first_block = vld4q_s32(block);\n\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; l += 4) {\n                    const int* current_block = block + k * cols + l;\n                    int32x4x4_t current = vld4q_s32(current_block);\n\n                    if (vaddvq_s32(vceqq_s32(first_block.val[0], current.val[0])) != 4 ||\n                        vaddvq_s32(vceqq_s32(first_block.val[1], current.val[1])) != 4 ||\n                        vaddvq_s32(vceqq_s32(first_block.val[2], current.val[2])) != 4 ||\n                        vaddvq_s32(vceqq_s32(first_block.val[3], current.val[3])) != 4) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* block = matrix + i * cols + j;\n            int32x4_t first_block = vld1q_s32(block);\n\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    const int* current_block = block + k * cols + l;\n                    int32x4_t current = vld1q_s32(current_block);\n\n                    if (!vceqq_s32(current, first_block)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            int32x4_t first_block = vld1q_s32(matrix + i * cols + j);\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; l += 4) {\n                    int32x4_t current_block = vld1q_s32(matrix + (i + k) * cols + j + l);\n                    if (!vceqq_s32(first_block, current_block)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int32x4_t* block_ptr = (const int32x4_t*)(matrix + i * cols + j);\n            const int32x4_t first_block = vld1q_s32(block_ptr);\n\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    const int32x4_t* current_block_ptr = (const int32x4_t*)(matrix + (i + k) * cols + (j + l));\n                    const int32x4_t current_block = vld1q_s32(current_block_ptr);\n\n                    if (!vceqq_s32(first_block, current_block)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    const double* first_block = vec;\n\n    float64x2_t tolerance_v = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            float64x2_t first_block_v = vld1q_f64(first_block + j);\n            float64x2_t current_block_v = vld1q_f64(current_block + j);\n\n            float64x2_t diff = vsubq_f64(first_block_v, current_block_v);\n            uint64x2_t cmp = vcleq_f64(diff, tolerance_v);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    const double* first_block = vec;\n\n    float64x2_t tolerance_v = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            float64x2_t vec1 = vld1q_f64(first_block + j);\n            float64x2_t vec2 = vld1q_f64(current_block + j);\n            float64x2_t diff = vsubq_f64(vec1, vec2);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            uint64x2_t cmp = vcleq_f64(abs_diff, tolerance_v);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    const size_t num_blocks = length / block_size;\n    const size_t simd_block_size = block_size / 2;\n\n    float64x2_t first_block = vld1q_f64(vec);\n    float64x2_t tolerance_v = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* block_start = vec + i * block_size;\n        float64x2_t block = vld1q_f64(block_start);\n\n        float64x2_t diff = vabdq_f64(first_block, block);\n        uint64x2_t cmp = vcgeq_f64(diff, tolerance_v);\n\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || length % block_size != 0) {\n        return false;\n    }\n\n    float64x2_t first_block = vld1q_f64(vec);\n    float64x2_t tolerance_v = vdupq_n_f64(tolerance);\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        float64x2_t block = vld1q_f64(vec + i);\n        float64x2_t diff = vabdq_f64(block, first_block);\n        uint64x2_t cmp = vcgeq_f64(diff, tolerance_v);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    const double* first_block = vec;\n\n    float64x2_t tolerance_v = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            float64x2_t vec1 = vld1q_f64(first_block + j);\n            float64x2_t vec2 = vld1q_f64(current_block + j);\n            float64x2_t diff = vsubq_f64(vec1, vec2);\n            uint64x2_t cmp = vcleq_f64(diff, tolerance_v);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_start = matrix + i * cols;\n        float64x2_t sum_sq = vdupq_n_f64(0.0);\n        \n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec_a = vld1q_f64(row_start + j);\n            sum_sq = vfmaq_f64(sum_sq, vec_a, vec_a);\n        }\n        \n        float64x2_t threshold = vld1q_f64(thresholds + i);\n        uint64x2_t cmp_result = vcgtq_f64(sum_sq, threshold);\n        result[i] = cmp_result[0] && cmp_result[1];\n    }\n}\n```  "}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_start = matrix + i * cols;\n        float64x2_t sum_sq = vdupq_n_f64(0.0);\n        \n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec1 = vld1q_f64(row_start + j);\n            sum_sq = vfmaq_f64(sum_sq, vec1, vec1);\n        }\n        \n        float64x2_t threshold_vec = vld1q_f64(thresholds + i);\n        uint64x2_t cmp_result = vcgtq_f64(sum_sq, threshold_vec);\n        \n        result[i] = (vgetq_lane_u64(cmp_result, 0) != 0) || (vgetq_lane_u64(cmp_result, 1) != 0);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_start = matrix + i * cols;\n        const double* threshold = thresholds + i;\n        bool* res = result + i;\n\n        float64x2_t sum_sq = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec1 = vld1q_f64(row_start + j);\n            float64x2_t vec2 = vld1q_f64(threshold);\n\n            float64x2_t diff = vsubq_f64(vec1, vec2);\n            sum_sq = vaddq_f64(sum_sq, vmulq_f64(diff, diff));\n        }\n\n        float64x2_t threshold_sq = vld1q_f64(threshold);\n        uint64x2_t cmp = vreinterpretq_u64_f64(vcgeq_f64(sum_sq, threshold_sq));\n\n        *res = vgetq_lane_u64(cmp, 0) & vgetq_lane_u64(cmp, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_sq = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&matrix[i * cols + j]);\n            sum_sq = vfmaq_f64(sum_sq, vec1, vec1);\n        }\n        float64x2_t threshold = vld1q_f64(&thresholds[i]);\n        uint64x2_t cmp_result = vcgtq_f64(vsqrtq_f64(sum_sq), threshold);\n        result[i] = (vgetq_lane_u64(cmp_result, 0) != 0) || (vgetq_lane_u64(cmp_result, 1) != 0);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_start = matrix + i * cols;\n        float64x2_t sum_squared = vdupq_n_f64(0.0);\n        \n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t matrix_data = vld1q_f64(row_start + j);\n            sum_squared = vfmaq_f64(sum_squared, matrix_data, matrix_data);\n        }\n        \n        float64x2_t threshold_data = vld1q_f64(thresholds + i);\n        uint64x2_t compare_result = vcgtq_f64(vsqrtq_f64(sum_squared), threshold_data);\n        \n        result[i] = vgetq_lane_u64(compare_result, 0) & 1;\n        result[i + 1] = vgetq_lane_u64(compare_result, 1) & 1;\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    uint32x4_t va, vb, vc;\n\n    for (i = 0; i < length; i += 4) {\n        va = vld1q_u32(&A[i]);\n        vb = vld1q_u32(&B[i]);\n        vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t neon_length = length / 4;\n    uint32x4_t va, vb, vc;\n\n    for (size_t i = 0; i < neon_length; ++i) {\n        va = vld1q_u32(A);\n        vb = vld1q_u32(B);\n        vc = vorrq_u32(va, vb);\n        vst1q_u32(C, vc);\n\n        A += 4;\n        B += 4;\n        C += 4;\n    }\n\n    for (size_t i = neon_length * 4; i < length; ++i) {\n        *C = *A | *B;\n\n        A++;\n        B++;\n        C++;\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    uint32x4_t va, vb, vc;\n\n    for (i = 0; i < length; i += 4) {\n        va = vld1q_u32(&A[i]);\n        vb = vld1q_u32(&B[i]);\n        vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    uint32x4_t va, vb, vc;\n\n    for (i = 0; i < length; i += 4) {\n        va = vld1q_u32(&A[i]);\n        vb = vld1q_u32(&B[i]);\n        vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    uint32x4_t va, vb, vc;\n\n    for (i = 0; i < length; i += 4) {\n        va = vld1q_u32(&A[i]);\n        vb = vld1q_u32(&B[i]);\n        vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t sum_squares = vdupq_n_s64(0);\n    int64x2_t sum_products = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(&A[i]);\n        int8x16_t b = vld1q_s8(&B[i]);\n\n        int16x8_t a_squares = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        int16x8_t b_squares = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n\n        int16x8_t a_b = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n\n        sum_squares = vpadalq_s32(sum_squares, vcombine_s32(vpaddl_s16(a_squares), vpaddl_s16(b_squares)));\n        sum_products = vpadalq_s32(sum_products, vpaddl_s16(a_b));\n    }\n\n    int64x2_t diff = vsubq_s64(sum_squares, sum_products);\n    int64_t result;\n    vst1q_s64(&result, diff);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t sum_squares = vdupq_n_s64(0);\n    int64x2_t sum_products = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_s16 = vmovl_s8(vget_low_s8(va));\n        int16x8_t vb_s16 = vmovl_s8(vget_low_s8(vb));\n\n        int32x4_t va_s32 = vmovl_s16(vget_low_s16(va_s16));\n        int32x4_t vb_s32 = vmovl_s16(vget_low_s16(vb_s16));\n\n        int64x2_t va_s64 = vmovl_s32(vget_low_s32(va_s32));\n        int64x2_t vb_s64 = vmovl_s32(vget_low_s32(vb_s32));\n\n        sum_squares = vmlal_s32(sum_squares, vget_low_s16(va_s16), vget_low_s16(va_s16));\n        sum_squares = vmlal_s32(sum_squares, vget_low_s16(vb_s16), vget_low_s16(vb_s16));\n\n        sum_products = vmlal_s32(sum_products, vget_low_s16(va_s16), vget_low_s16(vb_s16));\n    }\n\n    int64x2_t diff = vsubq_s64(sum_squares, sum_products);\n    return vgetq_lane_s64(diff, 0) + vgetq_lane_s64(diff, 1);\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t sum_squares = vdupq_n_s64(0);\n    int64x2_t sum_products = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(&A[i]);\n        int8x16_t b = vld1q_s8(&B[i]);\n\n        int16x8_t a_squares = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        int16x8_t b_squares = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n\n        int16x8_t a_b = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n\n        sum_squares = vpadalq_s32(sum_squares, vcombine_s32(vpaddl_s16(a_squares), vpaddl_s16(b_squares)));\n        sum_products = vpadalq_s32(sum_products, vpaddl_s16(a_b));\n    }\n\n    int64x2_t diff = vsubq_s64(sum_squares, sum_products);\n    return vgetq_lane_s64(diff, 0) + vgetq_lane_s64(diff, 1);\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t sum_squares = vdupq_n_s64(0);\n    int64x2_t sum_products = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(&A[i]);\n        int8x16_t b = vld1q_s8(&B[i]);\n\n        int16x8_t a_squares = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        int16x8_t b_squares = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n\n        int16x8_t a_times_b = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n\n        sum_squares = vpadalq_s32(sum_squares, vcombine_s32(vpaddl_s16(vget_low_s16(a_squares)), vpaddl_s16(vget_low_s16(b_squares)));\n        sum_products = vpadalq_s32(sum_products, vpaddl_s16(vget_low_s16(a_times_b)));\n    }\n\n    int64x2_t diff = vsubq_s64(sum_squares, sum_products);\n    return vgetq_lane_s64(diff, 0) + vgetq_lane_s64(diff, 1);\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t sum_squares = vdupq_n_s64(0);\n    int64x2_t sum_products = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int16x8_t a_squares = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        a_squares = vmlal_s8(a_squares, vget_high_s8(a), vget_high_s8(a));\n\n        int16x8_t b_squares = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n        b_squares = vmlal_s8(b_squares, vget_high_s8(b), vget_high_s8(b));\n\n        int16x8_t products = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n        products = vmlal_s8(products, vget_high_s8(a), vget_high_s8(b));\n\n        int32x4_t a_squares_sum = vpaddlq_s16(a_squares);\n        int32x4_t b_squares_sum = vpaddlq_s16(b_squares);\n        int32x4_t products_sum = vpaddlq_s16(products);\n\n        sum_squares = vpadalq_s32(sum_squares, a_squares_sum);\n        sum_squares = vpadalq_s32(sum_squares, b_squares_sum);\n        sum_products = vpadalq_s32(sum_products, products_sum);\n    }\n\n    int64x2_t result = vsubq_s64(sum_squares, sum_products);\n    return vgetq_lane_s64(result, 0) + vgetq_lane_s64(result, 1);\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    uint64x2_t va, vb, vc;\n\n    for (i = 0; i < length; i += 2) {\n        va = vld1q_u64(&A[i]);\n        vb = vld1q_u64(&B[i]);\n        vc = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t result = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    uint64x2_t va, vb, vc;\n    \n    for (i = 0; i < length; i += 2) {\n        va = vld1q_u64(&A[i]);\n        vb = vld1q_u64(&B[i]);\n        vc = vbicq_u64(va, vb);\n        vst1q_u64(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    uint64x2_t va, vb, vc;\n    for (size_t i = 0; i < length; i += 2) {\n        va = vld1q_u64(&A[i]);\n        vb = vld1q_u64(&B[i]);\n        vc = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t neon_length = length / 2;\n    uint64x2_t va, vb, vc;\n    \n    for (size_t i = 0; i < neon_length; ++i) {\n        va = vld1q_u64(&A[i*2]);\n        vb = vld1q_u64(&B[i*2]);\n        vc = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i*2], vc);\n    }\n}\n```  "}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    int8x8_t va, vb, vc;\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t one = vdup_n_s8(1);\n    int8x8_t minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        va = vld1_s8(A + i);\n        vb = vld1_s8(B + i);\n\n        int8x8_t both_positive = vand_s8(va, vb);\n        int8x8_t both_negative = vand_s8(vmvn_s8(va), vmvn_s8(vb));\n\n        vc = vbsl_s8(both_positive, one, zero);\n        vc = vbsl_s8(both_negative, minus_one, vc);\n\n        vst1_s8(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    int8x8_t va, vb, vc;\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t one = vdup_n_s8(1);\n    int8x8_t minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        va = vld1_s8(A + i);\n        vb = vld1_s8(B + i);\n\n        int8x8_t both_positive = vand_s8(va, vb);\n        int8x8_t both_negative = vand_s8(vmvn_s8(va), vmvn_s8(vb));\n\n        vc = vbsl_s8(both_positive, one, zero);\n        vc = vbsl_s8(both_negative, minus_one, vc);\n\n        vst1_s8(C + i, vc);\n    }\n}\n```  "}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    int8x8_t va, vb, vc;\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t one = vdup_n_s8(1);\n    int8x8_t minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        va = vld1_s8(A + i);\n        vb = vld1_s8(B + i);\n\n        int8x8_t both_positive = vand_s8(va, vb);\n        int8x8_t both_negative = vand_s8(vmvn_s8(va), vmvn_s8(vb));\n\n        vc = vbsl_s8(both_positive, one, zero);\n        vc = vbsl_s8(both_negative, minus_one, vc);\n\n        vst1_s8(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    int8x8_t va, vb, vc;\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t one = vdup_n_s8(1);\n    int8x8_t minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        va = vld1_s8(A + i);\n        vb = vld1_s8(B + i);\n\n        int8x8_t both_positive = vand_s8(va, vb);\n        int8x8_t both_negative = vand_s8(vmvn_s8(va), vmvn_s8(vb));\n\n        vc = vbsl_s8(both_positive, one, zero);\n        vc = vbsl_s8(both_negative, minus_one, vc);\n\n        vst1_s8(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    int8x8_t va, vb, vc;\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t one = vdup_n_s8(1);\n    int8x8_t minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        va = vld1_s8(A + i);\n        vb = vld1_s8(B + i);\n\n        int8x8_t both_positive = vand_s8(va, vb);\n        int8x8_t both_negative = vand_s8(vmvn_s8(va), vmvn_s8(vb));\n\n        vc = vbsl_s8(both_positive, one, zero);\n        vc = vbsl_s8(both_negative, minus_one, vc);\n\n        vst1_s8(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    uint16x8_t va, vb, vc;\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; i += 8) {\n        va = vld1q_u16(&A[i]);\n        vb = vld1q_u16(&B[i]);\n        vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    uint16x8_t va, vb, vc;\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < midpoint; i += 8) {\n        va = vld1q_u16(&A[i]);\n        vb = vld1q_u16(&B[i]);\n        vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n    \n    va = vld1q_u16(&A[midpoint]);\n    vst1q_u16(&C[midpoint], va);\n    \n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        va = vld1q_u16(&A[i]);\n        vb = vld1q_u16(&B[i]);\n        vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    uint16x8_t va, vb, vc;\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; i += 8) {\n        va = vld1q_u16(A + i);\n        vb = vld1q_u16(B + i);\n        vc = vandq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n\n    va = vld1q_u16(A + midpoint);\n    vst1q_u16(C + midpoint, va);\n\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        va = vld1q_u16(A + i);\n        vb = vld1q_u16(B + i);\n        vc = veorq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    uint16x8_t a, b, c;\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; i += 8) {\n        a = vld1q_u16(A + i);\n        b = vld1q_u16(B + i);\n        c = vandq_u16(a, b);\n        vst1q_u16(C + i, c);\n    }\n\n    if (length % 16 != 0) {\n        a = vld1q_u16(A + midpoint);\n        vst1q_u16(C + midpoint, a);\n    }\n\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        a = vld1q_u16(A + i);\n        b = vld1q_u16(B + i);\n        c = veorq_u16(a, b);\n        vst1q_u16(C + i, c);\n    }\n}\n```  "}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    uint16x8_t va, vb, vc;\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; i += 8) {\n        va = vld1q_u16(A + i);\n        vb = vld1q_u16(B + i);\n        vc = vandq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n\n    va = vld1q_u16(A + midpoint);\n    vst1q_u16(C + midpoint, va);\n\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        va = vld1q_u16(A + i);\n        vb = vld1q_u16(B + i);\n        vc = veorq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t true_true = vandq_u32(mask1, mask2);\n        uint32x4_t true_false = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t false_true = vandq_u32(vmvnq_u32(mask1), mask2);\n\n        float32x4_t a_values = vld1q_f32(&A[i]);\n        float32x4_t b_values = vld1q_f32(&B[i]);\n        float32x4_t c_values = vld1q_f32(&C[i]);\n        float32x4_t d_values = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(true_true, a_values, vbslq_f32(true_false, b_values, vbslq_f32(false_true, c_values, d_values)));\n\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t true_true = vandq_u32(mask1, mask2);\n        uint32x4_t true_false = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t false_true = vmvnq_u32(mask1);\n\n        float32x4_t a_values = vld1q_f32(A + i);\n        float32x4_t b_values = vld1q_f32(B + i);\n        float32x4_t c_values = vld1q_f32(C + i);\n        float32x4_t d_values = vld1q_f32(D + i);\n\n        float32x4_t result = vbslq_f32(true_true, a_values, vbslq_f32(true_false, b_values, vbslq_f32(false_true, c_values, d_values)));\n\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t true_true = vandq_u32(mask1, mask2);\n        uint32x4_t true_false = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t false_true = vandq_u32(vmvnq_u32(mask1), mask2);\n\n        float32x4_t a_values = vld1q_f32(A + i);\n        float32x4_t b_values = vld1q_f32(B + i);\n        float32x4_t c_values = vld1q_f32(C + i);\n        float32x4_t d_values = vld1q_f32(D + i);\n\n        float32x4_t result = vbslq_f32(true_true, a_values, vbslq_f32(true_false, b_values, vbslq_f32(false_true, c_values, d_values)));\n\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t true_true = vandq_u32(mask1, mask2);\n        uint32x4_t true_false = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t false_true = vandq_u32(vmvnq_u32(mask1), mask2);\n\n        float32x4_t a_values = vld1q_f32(A + i);\n        float32x4_t b_values = vld1q_f32(B + i);\n        float32x4_t c_values = vld1q_f32(C + i);\n        float32x4_t d_values = vld1q_f32(D + i);\n\n        float32x4_t result = vbslq_f32(true_true, a_values, vbslq_f32(true_false, b_values, vbslq_f32(false_true, c_values, d_values)));\n\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t true_true = vandq_u32(mask1, mask2);\n        uint32x4_t true_false = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t false_true = vandq_u32(vmvnq_u32(mask1), mask2);\n\n        float32x4_t valA = vld1q_f32(&A[i]);\n        float32x4_t valB = vld1q_f32(&B[i]);\n        float32x4_t valC = vld1q_f32(&C[i]);\n        float32x4_t valD = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(true_true, valA, vbslq_f32(true_false, valB, vbslq_f32(false_true, valC, valD)));\n\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32x4_t vecA = vld1q_u32(&A[i * 4]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(vecA));\n        uint8x8_t result = vpadd_u8(count, count);\n        result = vpadd_u8(result, result);\n        out[i] = vget_lane_u8(result, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32x4_t vecA = vld1q_u32(&A[i * 4]);\n        uint8x8_t vecCount = vcnt_u8(vreinterpret_u8_u32(vecA));\n        uint8x8_t vecCountLow = vget_low_u8(vecCount);\n        uint8x8_t vecCountHigh = vget_high_u8(vecCount);\n        uint16x8_t vecCount16 = vpaddlq_u8(vecCount);\n        uint16x4_t vecCountSum = vadd_u16(vget_low_u16(vecCount16), vget_high_u16(vecCount16));\n        uint32_t count = vget_lane_u32(vpaddl_u16(vecCountSum), 0);\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32x4_t vecA = vld1q_u32(&A[i * 4]);\n        uint8x8_t vecCount = vcnt_u8(vreinterpret_u8_u32(vecA));\n        uint8x8_t vecCountHigh = vget_high_u8(vecCount);\n        uint8x8_t vecCountLow = vget_low_u8(vecCount);\n        uint16x8_t vecCount16 = vpaddlq_u8(vecCount);\n        uint16x4_t vecCountSum = vadd_u16(vget_low_u16(vecCount16), vget_high_u16(vecCount16));\n        uint32x2_t vecCountFinal = vpaddl_u16(vecCountSum);\n        out[i] = vget_lane_u32(vecCountFinal, 0) + vget_lane_u32(vecCountFinal, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32x4_t vecA = vld1q_u32(&A[i * 4]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(vecA));\n        uint8x8_t count_lo = vget_low_u8(count);\n        uint8x8_t count_hi = vget_high_u8(count);\n        uint16x8_t count_combined = vpaddlq_u8(count);\n        uint16x4_t count_sum = vadd_u16(vget_low_u16(count_combined), vget_high_u16(count_combined));\n        uint32x2_t count_final = vpaddl_u16(vreinterpret_u16_u32(count_sum));\n        uint32_t result = vget_lane_u32(count_final, 0);\n        out[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32x4_t vecA = vld1q_u32(&A[i * 4]);\n        uint8x8_t vecCount = vcnt_u8(vreinterpret_u8_u32(vecA));\n        uint8_t count = vget_lane_u8(vpadd_u8(vecCount, vecCount), 0);\n        out[i] = count;\n    }\n}\n```  "}
{"task_id": "SimdBench_47_Neon", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    int32x4_t divisors = vdupq_n_s32(3);\n\n    for (size_t i = 0; i < rows * cols; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t mask = vceqq_s32(a % divisors, vdupq_n_s32(0));\n\n        int32x4_t result = vbslq_s32(mask, vabsq_s32(a), a);\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    int32x4_t div3 = vdupq_n_s32(3);\n    for (size_t i = 0; i < rows * cols; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t mask = vceqq_s32(vandq_s32(a, div3), vdupq_n_s32(0));\n        int32x4_t result = vbslq_s32(mask, vabsq_s32(a), a);\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    int32x4_t divisors = vdupq_n_s32(3);\n\n    for (size_t i = 0; i < rows * cols; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t mask = vceqq_s32(a % divisors, vdupq_n_s32(0));\n\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    int32x4_t div3 = vdupq_n_s32(3);\n    for (size_t i = 0; i < rows * cols; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t mask = vceqq_s32(a % div3, vdupq_n_s32(0));\n        int32x4_t result = vbslq_s32(mask, vabsq_s32(a), a);\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    int32x4_t div3 = vdupq_n_s32(3);\n    int32x4_t neg3 = vdupq_n_s32(-3);\n    \n    for (size_t i = 0; i < rows * cols; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t mask = vceqq_s32(vandq_s32(a, div3), vdupq_n_s32(0));\n        \n        int32x4_t result = vbslq_s32(mask, vabsq_s32(a), a);\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8x16_t rotate = vdupq_n_u8(rotate_bits);\n    uint32x4_t all_ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32((1 << rotate_bits) - 1);\n\n    for(size_t i = 0; i < length; i += 4){\n        uint32x4_t src_val = vld1q_u32(&src[i]);\n        uint32x4_t low_4_bits = vandq_u32(src_val, vdupq_n_u32(0xF));\n        uint32x4_t condition = vceqq_u32(low_4_bits, vdupq_n_u32(0xF));\n\n        uint32x4_t rotated = vshlq_u32(src_val, vreinterpretq_s32_u32(vnegq_s32(vreinterpretq_s32_u32(rotate))));\n        uint32x4_t negated = vmvnq_u32(src_val);\n\n        uint32x4_t result = vbslq_u32(condition, vandq_u32(rotated, vmvnq_u32(rotate_mask)), negated);\n\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8x16_t rotate_v = vdupq_n_u8(rotate_bits);\n    uint32x4_t all_ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32((1 << rotate_bits) - 1);\n\n    for(size_t i = 0; i < length; i += 4){\n        uint32x4_t src_v = vld1q_u32(src + i);\n        uint32x4_t low_4_bits = vandq_u32(src_v, all_ones);\n        uint32x4_t condition = vceqq_u32(low_4_bits, all_ones);\n\n        uint32x4_t rotated = vshlq_n_u32(src_v, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_v);\n\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8x16_t rotate = vdupq_n_u8(rotate_bits);\n    uint32x4_t all_ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32((1 << rotate_bits) - 1);\n\n    for(size_t i = 0; i < length; i += 4){\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low_4_bits = vandq_u32(src_vec, vdupq_n_u32(0xF));\n        uint32x4_t condition = vceqq_u32(low_4_bits, vdupq_n_u32(0xF));\n\n        uint32x4_t rotated = vshlq_u32(src_vec, vreinterpretq_s32_u32(vnegq_s32(vreinterpretq_s32_u32(rotate))));\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(condition, vandq_u32(rotated, vreinterpretq_u32_u8(rotate_mask)), negated);\n\n        vst1q_u32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8x16_t rotate = vdupq_n_u8(rotate_bits);\n    uint32x4_t all_ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32((1 << rotate_bits) - 1);\n\n    for(size_t i = 0; i < length; i += 4){\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low_4_bits = vandq_u32(src_vec, all_ones);\n        uint32x4_t condition = vceqq_u32(low_4_bits, all_ones);\n\n        uint32x4_t rotated = vshlq_u32(src_vec, vreinterpretq_s32_u32(vnegq_s32(vreinterpretq_s32_u32(rotate))));\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(condition, vandq_u32(rotated, rotate_mask), negated);\n\n        vst1q_u32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8x16_t rotate = vdupq_n_u8(rotate_bits);\n    uint32x4_t mask = vdupq_n_u32(0x0F0F0F0F);\n    uint32x4_t rotate_mask = vdupq_n_u32(0xFFFFFFFF);\n    \n    for(size_t i = 0; i < length; i += 4){\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low4 = vandq_u32(src_vec, mask);\n        uint32x4_t cmp_mask = vceqq_u32(low4, mask);\n        \n        uint32x4_t rotated = vshlq_n_u32(src_vec, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(cmp_mask, rotated, negated);\n        vst1q_u32(dst + i, result);\n    }\n}\n```  "}
{"task_id": "SimdBench_49_Neon", "completion": "```\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    int8x8_t v_zero = vdup_n_s8(0);\n    int8x8_t v_one = vdup_n_s8(1);\n    int8x8_t v_minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_A = vld1q_f32(A + i);\n        float32x4_t v_B = vld1q_f32(B + i);\n\n        float32x4_t v_diff = vsubq_f32(v_A, v_B);\n        float32x4_t v_abs_diff = vabsq_f32(v_diff);\n\n        uint32x4_t v_mask_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_mask_lt = vcltq_f32(v_diff, vnegq_f32(v_epsilon));\n\n        int8x8_t v_result = vbslq_s8(vcombine_s8(v_zero, v_one), vcombine_s8(v_zero, v_minus_one), vreinterpretq_s8_u8(vorrq_u32(v_mask_gt, v_mask_lt)));\n\n        vst1_s8(out + i, vget_low_s8(v_result));\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    int8x8_t v_zero = vdup_n_s8(0);\n    int8x8_t v_one = vdup_n_s8(1);\n    int8x8_t v_minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t v_a1 = vld1q_f32(&A[i]);\n        float32x4_t v_a2 = vld1q_f32(&A[i + 4]);\n        float32x4_t v_b1 = vld1q_f32(&B[i]);\n        float32x4_t v_b2 = vld1q_f32(&B[i + 4]);\n\n        float32x4_t v_diff1 = vsubq_f32(v_a1, v_b1);\n        float32x4_t v_diff2 = vsubq_f32(v_a2, v_b2);\n\n        uint32x4_t v_abs_diff1 = vreinterpretq_u32_f32(vabsq_f32(v_diff1));\n        uint32x4_t v_abs_diff2 = vreinterpretq_u32_f32(vabsq_f32(v_diff2));\n\n        uint32x4_t v_mask1 = vcgtq_f32(v_diff1, v_epsilon);\n        uint32x4_t v_mask2 = vcgtq_f32(v_diff2, v_epsilon);\n\n        uint32x4_t v_mask3 = vcltq_f32(v_diff1, vnegq_f32(v_epsilon));\n        uint32x4_t v_mask4 = vcltq_f32(v_diff2, vnegq_f32(v_epsilon));\n\n        uint32x4_t v_mask = vorrq_u32(vandq_u32(v_mask1, v_mask2), vandq_u32(v_mask3, v_mask4));\n\n        int8x8_t v_result = vbsl_s8(vreinterpret_s8_u8(vqmovn_u16(v_mask)), v_one, v_zero);\n\n        vst1_s8(&out[i], vget_low_s8(v_result));\n        vst1_s8(&out[i + 4], vget_high_s8(v_result));\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    int8x8_t v_zero = vdup_n_s8(0);\n    int8x8_t v_one = vdup_n_s8(1);\n    int8x8_t v_minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_A = vld1q_f32(A + i);\n        float32x4_t v_B = vld1q_f32(B + i);\n\n        float32x4_t v_diff = vsubq_f32(v_A, v_B);\n        float32x4_t v_abs_diff = vabsq_f32(v_diff);\n\n        uint32x4_t v_mask_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_mask_lt = vcltq_f32(v_diff, vnegq_f32(v_epsilon));\n\n        uint32x4_t v_mask_eq = vcleq_f32(v_abs_diff, v_epsilon);\n\n        int8x8_t v_out = vbslq_s8(v_mask_gt, v_one, vbslq_s8(v_mask_lt, v_minus_one, v_zero));\n\n        vst1_s8(out + i, vget_low_s8(v_out));\n        vst1_s8(out + i + 4, vget_high_s8(v_out));\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    int8x8_t v_zero = vdup_n_s8(0);\n    int8x8_t v_one = vdup_n_s8(1);\n    int8x8_t v_minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_A = vld1q_f32(A + i);\n        float32x4_t v_B = vld1q_f32(B + i);\n\n        float32x4_t v_diff = vsubq_f32(v_A, v_B);\n        float32x4_t v_abs_diff = vabsq_f32(v_diff);\n\n        uint32x4_t v_mask_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_mask_lt = vcltq_f32(v_diff, vnegq_f32(v_epsilon));\n\n        uint32x4_t v_mask_eq = vcleq_f32(v_abs_diff, v_epsilon);\n\n        int8x8_t v_out = vbslq_s8(v_mask_gt, v_one, vbslq_s8(v_mask_lt, v_minus_one, v_zero));\n\n        vst1_s8(out + i, vget_low_s8(v_out));\n        vst1_lane_s8(out + i + 4, v_out, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    int8x8_t v_zero = vdup_n_s8(0);\n    int8x8_t v_one = vdup_n_s8(1);\n    int8x8_t v_minus_one = vdup_n_s8(-1);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_b = vld1q_f32(B + i);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n        float32x4_t v_abs_diff = vabsq_f32(v_diff);\n\n        uint32x4_t v_mask_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_mask_lt = vcltq_f32(v_diff, vnegq_f32(v_epsilon));\n\n        uint32x4_t v_mask_eq = vcleq_f32(v_abs_diff, v_epsilon);\n\n        int8x8_t v_out = vbslq_s8(v_mask_gt, v_one, vbslq_s8(v_mask_lt, v_minus_one, v_zero));\n\n        vst1_s8(out + i, vget_low_s8(v_out));\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    float32x4_t v_max = vdupq_n_f32(INT32_MAX);\n    float32x4_t v_min = vdupq_n_f32(INT32_MIN);\n    int32x4_t v_result;\n\n    for (i = 0; i < size; i += 4) {\n        float32x4_t v_input = vld1q_f32(A + i);\n        uint32x4_t v_gt_max = vcgtq_f32(v_input, v_max);\n        uint32x4_t v_lt_min = vcltq_f32(v_input, v_min);\n\n        v_input = vminq_f32(v_input, v_max);\n        v_input = vmaxq_f32(v_input, v_min);\n\n        v_result = vcvtaq_s32_f32(v_input);\n\n        v_result = vbslq_s32(v_gt_max, vdupq_n_s32(INT32_MAX), v_result);\n        v_result = vbslq_s32(v_lt_min, vdupq_n_s32(INT32_MIN), v_result);\n\n        vst1q_s32(B + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    float32x4_t v_max = vdupq_n_f32(INT32_MAX);\n    float32x4_t v_min = vdupq_n_f32(INT32_MIN);\n\n    for (i = 0; i < size; i += 4) {\n        float32x4_t v_a = vld1q_f32(A + i);\n        int32x4_t v_b = vcvtq_s32_f32(v_a);\n        v_b = vminq_s32(v_b, vreinterpretq_s32_f32(v_max));\n        v_b = vmaxq_s32(v_b, vreinterpretq_s32_f32(v_min));\n        vst1q_s32(B + i, v_b);\n    }\n\n    for (; i < size; i++) {\n        float a = A[i];\n        B[i] = (a > INT32_MAX) ? INT32_MAX : ((a < INT32_MIN) ? INT32_MIN : (int32_t)a);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    float32x4_t vmin = vdupq_n_f32(INT32_MIN);\n    float32x4_t vmax = vdupq_n_f32(INT32_MAX);\n    int32x4_t vmin_int = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmax_int = vdupq_n_s32(INT32_MAX);\n\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        int32x4_t b;\n\n        a = vmaxq_f32(a, vmin);\n        a = vminq_f32(a, vmax);\n        b = vcvtq_s32_f32(a);\n        b = vmaxq_s32(b, vmin_int);\n        b = vminq_s32(b, vmax_int);\n\n        vst1q_s32(B + i, b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    float32x4_t v_max = vdupq_n_f32(INT32_MAX);\n    float32x4_t v_min = vdupq_n_f32(INT32_MIN);\n\n    for (i = 0; i < size; i += 4) {\n        float32x4_t v_a = vld1q_f32(A + i);\n        int32x4_t v_b = vcvtq_s32_f32(v_a);\n        v_b = vminq_s32(v_b, vreinterpretq_s32_f32(v_max));\n        v_b = vmaxq_s32(v_b, vreinterpretq_s32_f32(v_min));\n        vst1q_s32(B + i, v_b);\n    }\n\n    for (; i < size; ++i) {\n        float a = A[i];\n        B[i] = (a > INT32_MAX) ? INT32_MAX : ((a < INT32_MIN) ? INT32_MIN : (int32_t)a);\n    }\n}\n```  "}
{"task_id": "SimdBench_50_Neon", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    float32x4_t vmin = vdupq_n_f32(INT32_MIN);\n    float32x4_t vmax = vdupq_n_f32(INT32_MAX);\n\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        int32x4_t b = vcvtq_s32_f32(vmaxq_f32(vminq_f32(a, vmax), vmin));\n        vst1q_s32(&B[i], b);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (A[i] > INT32_MAX) ? INT32_MAX : ((A[i] < INT32_MIN) ? INT32_MIN : (int32_t)A[i]);\n    }\n}\n```  "}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    float32x4_t scale_f = vdupq_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&A[i]);\n        float32x4_t scaled = vcvtq_f32_s32(input) * scale_f;\n        vst1q_f32(&B[i], scaled);\n    }\n}\n```  "}
{"task_id": "SimdBench_51_Neon", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    float32x4_t scale_f = vcvtq_f32_s32(scale_v);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&A[i]);\n        float32x4_t result = vmulq_f32(vcvtq_f32_s32(input), scale_f);\n        vst1q_f32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    float32x4_t scale_f = vcvtq_f32_s32(scale_v);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&A[i]);\n        float32x4_t result = vmulq_f32(vcvtq_f32_s32(input), scale_f);\n        vst1q_f32(&B[i], result);\n    }\n}\n```  "}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    float32x4_t scale_f = vdupq_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        float32x4_t result = vcvtq_f32_s32(a);\n        result = vmulq_f32(result, scale_f);\n        vst1q_f32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t scale_v = vdupq_n_s32(scale);\n    float32x4_t scale_f = vdupq_n_f32((float)scale);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        float32x4_t result = vcvtq_f32_s32(a);\n        result = vmulq_f32(result, scale_f);\n        vst1q_f32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    float32x4_t a, b, result;\n    int32x4_t rounded_result;\n\n    for (i = 0; i < size; i += 4) {\n        a = vld1q_f32(A + i);\n        b = vld1q_f32(B + i);\n        result = vdivq_f32(a, b);\n        rounded_result = vcvtq_s32_f32(result);\n        vst1q_s32(C + i, rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    float32x4_t va, vb, vc;\n    int32x4_t result;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_f32(A + i);\n        vb = vld1q_f32(B + i);\n        vc = vdivq_f32(va, vb);\n        result = vcvtq_s32_f32(vc);\n        vst1q_s32(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    float32x4_t va, vb, vc;\n    int32x4_t result;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_f32(A + i);\n        vb = vld1q_f32(B + i);\n        vc = vdivq_f32(va, vb);\n        result = vcvtq_s32_f32(vc);\n        vst1q_s32(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    float32x4_t va, vb, vc;\n    int32x4_t result;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_f32(A + i);\n        vb = vld1q_f32(B + i);\n        vc = vdivq_f32(va, vb);\n        result = vcvtq_s32_f32(vc);\n        vst1q_s32(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    float32x4_t va, vb, vc;\n    int32x4_t result;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_f32(A + i);\n        vb = vld1q_f32(B + i);\n        vc = vdivq_f32(va, vb);\n        result = vcvtq_s32_f32(vc);\n        vst1q_s32(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64x2_t vinput;\n    float32x2_t voutput;\n    const double max_val = FLT_MAX;\n    const double min_val = -FLT_MAX;\n    const float max_val_f = FLT_MAX;\n    const float min_val_f = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += 2) {\n        vinput = vld1q_u64((const uint64_t*)&A[i]);\n        voutput = vcvt_f32_f64(vreinterpretq_f64_u64(vinput));\n        voutput = vmin_f32(voutput, vdup_n_f32(max_val_f));\n        voutput = vmax_f32(voutput, vdup_n_f32(min_val_f));\n        vst1_f32(&B[i], voutput);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64x2_t vinput;\n    float32x2_t voutput;\n\n    for (size_t i = 0; i < size; i += 2) {\n        vinput = vld1q_u64((const uint64_t*)&A[i]);\n        voutput = vcvt_f32_f64(vcvt_f64_f64(vreinterpretq_f64_u64(vinput)));\n\n        voutput = vmin_f32(voutput, vdup_n_f32(FLT_MAX));\n        voutput = vmax_f32(voutput, vdup_n_f32(-FLT_MAX));\n\n        vst1_f32(&B[i], voutput);\n    }\n}\n```  "}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64x2_t vinput;\n    float32x2_t voutput;\n    const double FLT_MAX_VAL = FLT_MAX;\n    const double NEG_FLT_MAX_VAL = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += 2) {\n        vinput = vld1q_u64((const uint64_t*)&A[i]);\n        voutput = vcvt_f32_f64(vreinterpretq_f64_u64(vinput));\n        voutput = vmin_f32(voutput, vdup_n_f32(FLT_MAX_VAL));\n        voutput = vmax_f32(voutput, vdup_n_f32(NEG_FLT_MAX_VAL));\n        vst1_f32(&B[i], voutput);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64x2_t vinput;\n    float32x2_t voutput;\n    const float32x2_t vflt_max = vdup_n_f32(FLT_MAX);\n    const float32x2_t vnflt_max = vdup_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 2) {\n        vinput = vld1q_u64((const uint64_t*)&A[i]);\n        voutput = vcvt_f32_f64(vcvt_f64_u32(vinput));\n\n        voutput = vmin_f32(voutput, vflt_max);\n        voutput = vmax_f32(voutput, vnflt_max);\n\n        vst1_f32(&B[i], voutput);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64x2_t vinput;\n    float32x2_t voutput;\n    float32x2_t vmax = vdup_n_f32(FLT_MAX);\n    float32x2_t vmin = vdup_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 2) {\n        vinput = vld1q_u64((const uint64_t*)&A[i]);\n        voutput = vcvt_f32_f64(vcvt_f64_u32(vinput));\n        voutput = vmaxnmv_f32(vmax, vmin, voutput);\n        vst1_f32(&B[i], voutput);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 8) {\n        int16x8_t v_src = vld1q_s16(&A[i]);\n        int32x4_t v_dst_low = vmovl_s16(vget_low_s16(v_src));\n        int32x4_t v_dst_high = vmovl_s16(vget_high_s16(v_src));\n        vst1q_s32(&B[i], vcombine_s32(v_dst_low, v_dst_high));\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    uint16x8_t vec16;\n    int32x4_t vec32_1, vec32_2;\n\n    for (i = 0; i < size; i += 8) {\n        vec16 = vld1q_u16((const uint16_t*)(A + i));\n        vec32_1 = vmovl_u16(vget_low_u16(vec16));\n        vec32_2 = vmovl_u16(vget_high_u16(vec16));\n        vst1q_s32(B + i, vec32_1);\n        vst1q_s32(B + i + 4, vec32_2);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 8) {\n        int16x8_t v_a = vld1q_s16(&A[i]);\n        int32x4_t v_b1 = vmovl_s16(vget_low_s16(v_a));\n        int32x4_t v_b2 = vmovl_s16(vget_high_s16(v_a));\n        vst1q_s32(&B[i], vcombine_s32(v_b1, v_b2));\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    uint16x8_t a;\n    int32x4_t b1, b2;\n\n    for (i = 0; i < size; i += 8) {\n        a = vld1q_u16((const uint16_t*)(A + i));\n        b1 = vmovl_u16(vget_low_u16(a));\n        b2 = vmovl_u16(vget_high_u16(a));\n        vst1q_s32(B + i, b1);\n        vst1q_s32(B + i + 4, b2);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    int16x8_t v_input;\n    int32x4_t v_output1, v_output2;\n\n    for (i = 0; i < size; i += 8) {\n        v_input = vld1q_s16(&A[i]);\n        v_output1 = vmovl_s16(vget_low_s16(v_input));\n        v_output2 = vmovl_s16(vget_high_s16(v_input));\n        vst1q_s32(&B[i], vcombine_s32(v_output1, v_output2));\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n    float32x4_t vmax_val = vdupq_n_f32(max_val);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vcontrol = vld1q_s32(control + i);\n        float32x4_t va = vld1q_f32(A + i);\n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        float32x4_t vresult = vdivq_f32(vsubq_f32(va, vmin_val), vsubq_f32(vmax_val, vmin_val));\n        vresult = vmaxq_f32(vresult, vzero);\n        vresult = vminq_f32(vresult, vone);\n\n        float32x4_t vfinal = vbslq_f32(mask, vresult, va);\n        vst1q_f32(B + i, vfinal);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n    float32x4_t vmax_val = vdupq_n_f32(max_val);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vcontrol = vld1q_s32(control + i);\n        float32x4_t va = vld1q_f32(A + i);\n        \n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t val = vdivq_f32(vsubq_f32(va, vmin_val), vsubq_f32(vmax_val, vmin_val));\n        val = vmaxq_f32(vminq_f32(val, vone), vzero);\n        \n        float32x4_t result = vbslq_f32(mask, val, va);\n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n    float32x4_t vmax_val = vdupq_n_f32(max_val);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vcontrol = vld1q_s32(control + i);\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb;\n\n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        float32x4_t vnormalized = vdivq_f32(vsubq_f32(va, vmin_val), vsubq_f32(vmax_val, vmin_val));\n        vnormalized = vmaxq_f32(vmin_val, vminq_f32(vnormalized));\n        vnormalized = vminq_f32(vmax_val, vmaxq_f32(vnormalized));\n\n        vb = vbslq_f32(mask, vnormalized, va);\n\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n    float32x4_t vmax_val = vdupq_n_f32(max_val);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vcontrol = vld1q_s32(control + i);\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb;\n\n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnormalized = vdivq_f32(vsubq_f32(va, vmin_val), vsubq_f32(vmax_val, vmin_val));\n        vnormalized = vmaxq_f32(vmin_val, vminq_f32(vnormalized));\n        vnormalized = vminq_f32(vmax_val, vmaxq_f32(vnormalized));\n\n        vb = vbslq_f32(mask, vnormalized, va);\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n    float32x4_t vmax_val = vdupq_n_f32(max_val);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vcontrol = vld1q_s32(control + i);\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb;\n\n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        float32x4_t vnormalized = vdivq_f32(vsubq_f32(va, vmin_val), vsubq_f32(vmax_val, vmin_val));\n        vnormalized = vmaxq_f32(vmin_val, vminq_f32(vnormalized, vone));\n\n        vb = vbslq_f32(mask, vnormalized, va);\n\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    uint32x4_t va;\n    float32x4_t vb;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_u32(&A[i]);\n        vb = vcvtq_f32_u32(vshrq_n_u32(va, 16));\n        vb = vsqrtq_f32(vb);\n        vst1q_f32(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    uint32x4_t va;\n    float32x4_t vb;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_u32(A + i);\n        vb = vcvtq_f32_u32(vshrn_n_u64(vmovl_u32(va), 16));\n        vb = vsqrtq_f32(vb);\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    uint32x4_t va;\n    float32x4_t vb;\n\n    for (size_t i = 0; i < size; i += 4) {\n        va = vld1q_u32(A + i);\n        vb = vcvtq_f32_u32(vshrq_n_u32(va, 16));\n        vb = vsqrtq_f32(vb);\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    uint32x4_t va;\n    float32x4_t vb;\n    \n    for (size_t i = 0; i < size; i += 4) {\n        va = vld1q_u32(A + i);\n        vb = vcvtq_f32_u32(vshrn_n_u64(vmovl_u32(va), 16));\n        vb = vsqrtq_f32(vb);\n        vst1q_f32(B + i, vb);\n    }\n}\n```  "}
{"task_id": "SimdBench_56_Neon", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    uint32x4_t va;\n    float32x4_t vb;\n\n    for (i = 0; i < size; i += 4) {\n        va = vld1q_u32(A + i);\n        vb = vcvtq_f32_u32(vshrn_n_u64(vmovl_u32(va), 16));\n        vb = vsqrtq_f32(vb);\n        vst1q_f32(B + i, vb);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&A[i]);\n        float32x4_t v_dst = vreinterpretq_f32_u32(v_src);\n        vst1q_f32(&B[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t vA = vld1q_u32(&A[i]);\n        float32x4_t vB = vreinterpretq_f32_u32(vA);\n        vst1q_f32(&B[i], vB);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    uint32x4_t v_src;\n    float32x4_t v_dst;\n\n    for (i = 0; i < size; i += 4) {\n        v_src = vld1q_u32(&A[i]);\n        v_dst = vreinterpretq_f32_u32(v_src);\n        vst1q_f32(&B[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&A[i]);\n        float32x4_t v_dst = vreinterpretq_f32_u32(v_src);\n        vst1q_f32(&B[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&A[i]);\n        float32x4_t v_dst = vreinterpretq_f32_u32(v_src);\n        vst1q_f32(&B[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    int32x4_t prev = vdupq_n_s32(0);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t current = vld1q_s32(&A[i]);\n        int32x4_t diff_int = vsubq_s32(current, prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n        float32x4_t result = vbslq_f32(vreinterpretq_u32_s32(mask), diff_float, zero);\n        vst1q_f32(&diff[i], result);\n        prev = current;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    int32x4_t prev = vdupq_n_s32(0);\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t values = vld1q_s32(&A[i]);\n        \n        int32x4_t diffs = vsubq_s32(values, prev);\n        float32x4_t float_diffs = vcvtq_f32_s32(diffs);\n        \n        float32x4_t result = vbslq_f32(vreinterpretq_u32_s32(mask), float_diffs, vdupq_n_f32(0.0f));\n        \n        vst1q_f32(&diff[i], result);\n        \n        prev = values;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    int32x4_t prev = vdupq_n_s32(0);\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t current = vld1q_s32(&A[i]);\n        int32x4_t diff_int = vsubq_s32(current, prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n        float32x4_t result = vbslq_f32(vreinterpretq_u32_s32(mask), diff_float, vdupq_n_f32(0.0f));\n        vst1q_f32(&diff[i], result);\n        prev = current;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    int32x4_t prev = vdupq_n_s32(0);\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t values = vld1q_s32(&A[i]);\n        int32x4_t diffs = vsubq_s32(values, prev);\n        float32x4_t float_diffs = vcvtq_f32_s32(diffs);\n        float32x4_t result = vbslq_f32(vreinterpretq_u32_s32(mask), float_diffs, vdupq_n_f32(0.0f));\n        vst1q_f32(&diff[i], result);\n        prev = values;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    int32x4_t prev = vdupq_n_s32(0);\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t current = vld1q_s32(&A[i]);\n        int32x4_t diff_int = vsubq_s32(current, prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n        float32x4_t result = vbslq_f32(vreinterpretq_u32_s32(mask), diff_float, vdupq_n_f32(0.0f));\n        vst1q_f32(&diff[i], result);\n        prev = current;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n\n    for (i = 0; i < length; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vmovl_u32(src_vec);\n        dst_vec = vsetq_lane_u64(0xFFFFFFFFFFFFFFFF, dst_vec, 1);\n        vst1q_u64(dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n\n    for (size_t i = 0; i < length; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vmovl_u32(src_vec);\n        dst_vec = vsetq_lane_u64(0xFFFFFFFFFFFFFFFF, dst_vec, 1);\n        vst1q_u64(dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n\n    for (i = 0; i < length; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vmovl_u32(src_vec);\n        dst_vec = vsetq_lane_u64(0xFFFFFFFFFFFFFFFF, dst_vec, 1);\n        vst1q_u64(dst + i, dst_vec);\n    }\n}\n```  "}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n\n    for (size_t i = 0; i < length; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vmovl_u32(src_vec);\n        dst_vec = vsetq_lane_u64(0xFFFFFFFFFFFFFFFF, dst_vec, 1);\n        vst1q_u64(dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n\n    for (i = 0; i < length; i += 4) {\n        src_vec = vld1q_u32(&src[i]);\n        dst_vec = vmovl_u32(src_vec);\n        dst_vec = vsetq_lane_u64(0xFFFFFFFFFFFFFFFF, dst_vec, 1);\n        vst1q_u64(&dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t index_vec = vld1_s16(&index[i]);\n        int16x4_t index_shifted = vsub_s16(index_vec, vdup_n_s16(i));\n        \n        float64x2_t vec_values = vld1q_f64(&vec[0]);\n        float64x2_t vec_values_shifted = vld1q_f64(&vec[2]);\n        \n        float64x2_t selected_values = vcombine_f64(vtbl2_f64(vec_values, index_shifted), vtbl2_f64(vec_values_shifted, index_shifted));\n        \n        sum_vec = vaddq_f64(sum_vec, selected_values);\n    }\n    \n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        float64x2_t val = vld1q_f64(&vec[idx[0]]);\n        sum = vaddq_f64(sum, val);\n        \n        if (i + 1 < length) {\n            val = vld1q_f64(&vec[idx[1]]);\n            sum = vaddq_f64(sum, val);\n        }\n    }\n    \n    double result[2];\n    vst1q_f64(result, sum);\n    \n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        float64x2_t val = vld1q_f64(&vec[idx[0]]);\n        sum = vaddq_f64(sum, val);\n        \n        if (i + 1 < length) {\n            val = vld1q_f64(&vec[idx[1]]);\n            sum = vaddq_f64(sum, val);\n        }\n    }\n    \n    double result[2];\n    vst1q_f64(result, sum);\n    \n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        float64x2_t val = vld1q_f64(&vec[idx[0]]);\n        sum = vaddq_f64(sum, val);\n        \n        if (i + 1 < length) {\n            val = vld1q_f64(&vec[idx[1]]);\n            sum = vaddq_f64(sum, val);\n        }\n    }\n    \n    double result[2];\n    vst1q_f64(result, sum);\n    \n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        float64x2_t val = vld1q_f64(&vec[idx[0]]);\n        sum = vaddq_f64(sum, val);\n        \n        if (i + 1 < length) {\n            val = vld1q_f64(&vec[idx[1]]);\n            sum = vaddq_f64(sum, val);\n        }\n    }\n    \n    double result[2];\n    vst1q_f64(result, sum);\n    \n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    int output_size = input_size - kernel_size + 1;\n    int output_elements = output_size * output_size;\n\n    for (int i = 0; i < output_elements; ++i) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (int ky = 0; ky < kernel_size; ++ky) {\n            for (int kx = 0; kx < kernel_size; ++kx) {\n                float64x2_t input_val = vld1q_f64(&input[(i / output_size + ky) * input_size + i % output_size + kx]);\n                float64x2_t kernel_val = vld1q_f64(&kernel[ky * kernel_size + kx]);\n                sum = vmlaq_f64(sum, input_val, kernel_val);\n            }\n        }\n\n        float64x2_t zero = vdupq_n_f64(0.0);\n        sum = vmaxq_f64(sum, zero);\n        vst1q_f64(&output[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    int output_size = input_size - kernel_size + 1;\n    int output_elements = output_size * output_size;\n\n    for (int i = 0; i < output_elements; ++i) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (int ky = 0; ky < kernel_size; ++ky) {\n            for (int kx = 0; kx < kernel_size; ++kx) {\n                int input_index = (i / output_size + ky) * input_size + i % output_size + kx;\n                int kernel_index = ky * kernel_size + kx;\n                float64x2_t input_val = vld1q_f64(&input[input_index]);\n                float64x2_t kernel_val = vld1q_f64(&kernel[kernel_index]);\n                sum = vfmaq_f64(sum, input_val, kernel_val);\n            }\n        }\n\n        float64x2_t zero = vdupq_n_f64(0.0);\n        sum = vmaxq_f64(sum, zero);\n        vst1q_f64(&output[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    int output_size = input_size - kernel_size + 1;\n    int output_elements = output_size * output_size;\n\n    for (int i = 0; i < output_elements; i += 2) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (int j = 0; j < kernel_size; j++) {\n            for (int k = 0; k < kernel_size; k++) {\n                float64x2_t input_val = vld1q_f64(&input[(j + k) * input_size + i]);\n                float64x2_t kernel_val = vld1q_dup_f64(&kernel[j * kernel_size + k]);\n                sum = vfmaq_f64(sum, input_val, kernel_val);\n            }\n        }\n\n        float64x2_t zero = vdupq_n_f64(0.0);\n        sum = vmaxq_f64(sum, zero);\n\n        vst1q_f64(&output[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    int output_size = input_size - kernel_size + 1;\n    int output_elements = output_size * output_size;\n\n    for (int i = 0; i < output_elements; ++i) {\n        float64x2_t acc = vdupq_n_f64(0.0);\n\n        for (int ky = 0; ky < kernel_size; ++ky) {\n            for (int kx = 0; kx < kernel_size; ++kx) {\n                int input_idx = (i / output_size + ky) * input_size + i % output_size + kx;\n                int kernel_idx = ky * kernel_size + kx;\n\n                float64x2_t input_val = vld1q_f64(&input[input_idx]);\n                float64x2_t kernel_val = vld1q_f64(&kernel[kernel_idx]);\n\n                acc = vfmaq_f64(acc, input_val, kernel_val);\n            }\n        }\n\n        float64x2_t zero = vdupq_n_f64(0.0);\n        acc = vmaxq_f64(acc, zero);\n\n        vst1q_f64(&output[i], acc);\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    int output_size = input_size - kernel_size + 1;\n    int output_elements = output_size * output_size;\n\n    for (int i = 0; i < output_elements; ++i) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (int j = 0; j < kernel_size; ++j) {\n            for (int k = 0; k < kernel_size; ++k) {\n                float64x2_t input_val = vld1q_f64(&input[(i / output_size + j) * input_size + i % output_size + k]);\n                float64x2_t kernel_val = vld1q_f64(&kernel[j * kernel_size + k]);\n                sum = vfmaq_f64(sum, input_val, kernel_val);\n            }\n        }\n\n        float64x2_t zero = vdupq_n_f64(0.0);\n        sum = vmaxq_f64(sum, zero);\n\n        vst1q_f64(&output[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    const double* data = numbers.data();\n    int size = numbers.size();\n\n    float64x2_t threshold_v = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        float64x2_t current_v = vld1q_f64(data + i);\n        for (int j = i + 1; j < size; j++) {\n            float64x2_t next_v = vld1q_f64(data + j);\n            float64x2_t diff_v = vabdq_f64(current_v, next_v);\n            uint64x2_t cmp_v = vcltq_f64(diff_v, threshold_v);\n            if (vgetq_lane_u64(cmp_v, 0) || vgetq_lane_u64(cmp_v, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    const double* data = numbers.data();\n    const int size = numbers.size();\n\n    float64x2_t threshold_v = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        float64x2_t current_v = vld1q_f64(data + i);\n        for (int j = i + 1; j < size; j++) {\n            float64x2_t next_v = vld1q_f64(data + j);\n            float64x2_t diff_v = vabdq_f64(current_v, next_v);\n            uint64x2_t cmp_v = vcltq_f64(diff_v, threshold_v);\n            if (vgetq_lane_u64(cmp_v, 0) || vgetq_lane_u64(cmp_v, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    const double* data = numbers.data();\n    int size = numbers.size();\n\n    float64x2_t threshold_v = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        float64x2_t current_v = vld1q_f64(data + i);\n        for (int j = i + 1; j < size; j++) {\n            float64x2_t next_v = vld1q_f64(data + j);\n            float64x2_t diff_v = vabdq_f64(current_v, next_v);\n            uint64x2_t cmp_v = vcleq_f64(diff_v, threshold_v);\n            if (vgetq_lane_u64(cmp_v, 0) || vgetq_lane_u64(cmp_v, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    const double* data = numbers.data();\n    const int size = numbers.size();\n\n    float64x2_t threshold_v = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        float64x2_t current_v = vld1q_f64(data + i);\n        for (int j = i + 1; j < size; j++) {\n            float64x2_t next_v = vld1q_f64(data + j);\n            float64x2_t diff_v = vabdq_f64(current_v, next_v);\n            uint64x2_t cmp_v = vcleq_f64(diff_v, threshold_v);\n            if (vgetq_lane_u64(cmp_v, 0) || vgetq_lane_u64(cmp_v, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    const double* data = numbers.data();\n    int size = numbers.size();\n\n    float64x2_t threshold_v = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        float64x2_t current_v = vld1q_f64(data + i);\n        for (int j = i + 1; j < size; j++) {\n            float64x2_t next_v = vld1q_f64(data + j);\n            float64x2_t diff_v = vabdq_f64(current_v, next_v);\n            uint64x2_t cmp_v = vcltq_f64(diff_v, threshold_v);\n            if (vgetq_lane_u64(cmp_v, 0) || vgetq_lane_u64(cmp_v, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations){\n    int32x4_t balance = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations){\n    int32x4_t balance = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vreinterpretq_u32_s32(vcltq_s32(balance, vdupq_n_s32(0)));\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations){\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for(int i = 0; i < size; i += 4){\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        \n        uint32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if(vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)){\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations){\n    int32x4_t balance = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        \n        int32x4_t below_zero = vreinterpretq_s32_u32(vcltq_s32(balance, vdupq_n_s32(0)));\n        if (vgetq_lane_s32(below_zero, 0) || vgetq_lane_s32(below_zero, 1) || vgetq_lane_s32(below_zero, 2) || vgetq_lane_s32(below_zero, 3)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations){\n    int32x4_t balance = vdupq_n_s32(0);\n\n    for (int i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t size = numbers.size();\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n\n    // Calculate the sum of all elements\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, data);\n    }\n\n    // Calculate the mean\n    mean = vdivq_f32(sum, vdupq_n_f32(size));\n\n    float32x4_t mad_sum = vdupq_n_f32(0.0f);\n\n    // Calculate the sum of absolute differences\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        float32x4_t diff = vabdq_f32(data, mean);\n        mad_sum = vaddq_f32(mad_sum, diff);\n    }\n\n    float32x2_t mad_sum_low = vget_low_f32(mad_sum);\n    float32x2_t mad_sum_high = vget_high_f32(mad_sum);\n    mad_sum_low = vpadd_f32(mad_sum_low, mad_sum_low);\n    mad_sum_high = vpadd_f32(mad_sum_high, mad_sum_high);\n    float32x2_t mad_sum_final = vadd_f32(mad_sum_low, mad_sum_high);\n\n    float32x2_t result = vmul_f32(mad_sum_final, vdup_n_f32(1.0f / size));\n    return vget_lane_f32(result, 0);\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t size = numbers.size();\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n\n    // Calculate the sum of all numbers\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, data);\n    }\n\n    // Calculate the mean\n    mean = vdivq_f32(sum, vdupq_n_f32(size));\n\n    float32x4_t mad_sum = vdupq_n_f32(0.0f);\n\n    // Calculate the sum of absolute differences\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        float32x4_t diff = vabdq_f32(data, mean);\n        mad_sum = vaddq_f32(mad_sum, diff);\n    }\n\n    float32x2_t mad_sum_low = vget_low_f32(mad_sum);\n    float32x2_t mad_sum_high = vget_high_f32(mad_sum);\n    mad_sum_low = vpadd_f32(mad_sum_low, mad_sum_low);\n    mad_sum_high = vpadd_f32(mad_sum_high, mad_sum_high);\n    float32x2_t mad_sum_final = vadd_f32(mad_sum_low, mad_sum_high);\n\n    return vget_lane_f32(mad_sum_final, 0) / size;\n}\n```  "}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n    float32x4_t diff, abs_diff, mad;\n    int size = numbers.size();\n    \n    for(int i = 0; i < size; i += 4){\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, vec);\n    }\n    \n    mean = vdivq_f32(sum, vdupq_n_f32(size));\n    \n    sum = vdupq_n_f32(0.0f);\n    \n    for(int i = 0; i < size; i += 4){\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        diff = vsubq_f32(vec, mean);\n        abs_diff = vabsq_f32(diff);\n        sum = vaddq_f32(sum, abs_diff);\n    }\n    \n    mad = vmulq_f32(sum, vdupq_n_f32(1.0f/size));\n    \n    float32x2_t mad_low = vget_low_f32(mad);\n    float32x2_t mad_high = vget_high_f32(mad);\n    \n    mad_low = vpadd_f32(mad_low, mad_low);\n    mad_high = vpadd_f32(mad_high, mad_high);\n    \n    mad_low = vpadd_f32(mad_low, mad_low);\n    \n    return vget_lane_f32(mad_low, 0);\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n    float32x4_t diff, abs_diff, mad;\n    \n    // Calculate the sum of all elements\n    for (int i = 0; i < numbers.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, vec);\n    }\n    \n    // Calculate the mean\n    mean = vdivq_f32(sum, vdupq_n_f32(numbers.size()));\n    \n    // Calculate the mean absolute deviation\n    mad = vdupq_n_f32(0.0f);\n    for (int i = 0; i < numbers.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        diff = vsubq_f32(vec, mean);\n        abs_diff = vabsq_f32(diff);\n        mad = vaddq_f32(mad, abs_diff);\n    }\n    \n    float32x2_t mad_low = vget_low_f32(mad);\n    float32x2_t mad_high = vget_high_f32(mad);\n    float32x2_t mad_sum = vpadd_f32(mad_low, mad_high);\n    \n    float32x2_t result = vpadd_f32(mad_sum, mad_sum);\n    \n    return vget_lane_f32(result, 0) / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    int size = numbers.size();\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n\n    // Calculate the sum of all elements\n    for (int i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, data);\n    }\n\n    // Calculate the mean\n    mean = vdupq_n_f32(vgetq_lane_f32(sum, 0) + vgetq_lane_f32(sum, 1) + vgetq_lane_f32(sum, 2) + vgetq_lane_f32(sum, 3) / size);\n\n    float32x4_t mad = vdupq_n_f32(0.0f);\n\n    // Calculate the mean absolute deviation\n    for (int i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        float32x4_t diff = vabdq_f32(data, mean);\n        mad = vaddq_f32(mad, diff);\n    }\n\n    float32x2_t mad_sum = vpadd_f32(vget_low_f32(mad), vget_high_f32(mad));\n    float32x2_t mad_final = vpadd_f32(mad_sum, mad_sum);\n    \n    return vget_lane_f32(mad_final, 0) / size;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result(numbers.size() * 2 - 1);\n    int delimeterArray[4] = {delimeter, delimeter, delimeter, delimeter};\n    uint32x4_t vDelimeter = vld1q_u32(delimeterArray);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result[i * 2] = numbers[i];\n        if (i < numbers.size() - 1) {\n            result[i * 2 + 1] = vgetq_lane_u32(vDelimeter, 0);\n        }\n    }\n\n    return result;\n}\n```  "}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result(numbers.size() * 2 - 1);\n    \n    int32x4_t v_delimeter = vdupq_n_s32(delimeter);\n    int i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        int32x4_t v_input = vld1q_s32(&numbers[i]);\n        int32x4x2_t v_output = {{v_input, v_delimeter}};\n        vst2q_s32(&result[i * 2], v_output);\n    }\n    \n    for (; i < numbers.size(); ++i) {\n        result[i * 2] = numbers[i];\n        if (i != numbers.size() - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result(numbers.size() * 2 - 1);\n    int delimeterArray[4] = {delimeter, delimeter, delimeter, delimeter};\n    uint32x4_t v_delimeter = vld1q_u32(delimeterArray);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result[i * 2] = numbers[i];\n        if (i < numbers.size() - 1) {\n            result[i * 2 + 1] = vgetq_lane_u32(v_delimeter, 0);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result(numbers.size() * 2 - 1);\n    int delimeterArray[4] = {delimeter, delimeter, delimeter, delimeter};\n    int i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        int32x4_t delim = vld1q_s32(delimeterArray);\n        int32x4x2_t interleaved = {input, delim};\n        vst2q_s32(&result[i * 2], interleaved);\n    }\n    for (; i < numbers.size(); ++i) {\n        result[i * 2] = numbers[i];\n        if (i != numbers.size() - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n    return result;\n}\n```  "}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    std::vector<int> result(numbers.size() * 2 - 1);\n    int delimeterArray[4] = {delimeter, delimeter, delimeter, delimeter};\n    int i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        int32x4_t delim = vld1q_s32(delimeterArray);\n        int32x4x2_t interleaved = {input, delim};\n        vst2q_s32(&result[i * 2], interleaved);\n    }\n    for (; i < numbers.size(); ++i) {\n        result[i * 2] = numbers[i];\n        if (i != numbers.size() - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    uint16x8_t sum = vdupq_n_u16(0);\n    uint16x8_t product = vdupq_n_u16(1);\n\n    for (size_t i = 0; i < numbers.size(); i += 8) {\n        uint16x8_t vec = vld1q_u16(reinterpret_cast<uint16_t*>(&numbers[i]));\n        sum = vaddq_u16(sum, vec);\n        product = vmulq_u16(product, vec);\n    }\n\n    uint16_t sum_arr[8];\n    uint16_t product_arr[8];\n    vst1q_u16(sum_arr, sum);\n    vst1q_u16(product_arr, product);\n\n    int64_t sum_result = 0;\n    int64_t product_result = 1;\n\n    for (int i = 0; i < 8; ++i) {\n        sum_result += sum_arr[i];\n        product_result *= product_arr[i];\n    }\n\n    return {sum_result, product_result};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<int64x2_t, int64x2_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int16x8_t vec = vld1q_s16(numbers.data());\n    int32x4_t sum = vpaddlq_s16(vec);\n    int64x2_t sum_64 = vpaddl_s32(vget_low_s32(sum));\n    int64x2_t prod = vmull_s16(vget_low_s16(vec), vget_high_s16(vec));\n    prod = vmull_s16(vget_low_s16(prod), vget_high_s16(prod));\n    return std::make_pair(sum_64, vget_low_s64(prod));\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    int16x8_t sum = vdupq_n_s16(0);\n    int16x8_t product = vdupq_n_s16(1);\n\n    for (size_t i = 0; i < numbers.size(); i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        sum = vaddq_s16(sum, vec);\n        product = vmulq_s16(product, vec);\n    }\n\n    int16_t sum_arr[8];\n    int16_t product_arr[8];\n    vst1q_s16(sum_arr, sum);\n    vst1q_s16(product_arr, product);\n\n    int64_t sum_result = 0;\n    int64_t product_result = 1;\n\n    for (int i = 0; i < 8; i++) {\n        sum_result += sum_arr[i];\n        product_result *= product_arr[i];\n    }\n\n    return {sum_result, product_result};\n}\n```  "}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<int64x2_t, int64x2_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int16x8_t vec = vld1q_s16(numbers.data());\n    \n    int32x4_t sum_low = vpaddl_s16(vget_low_s16(vec));\n    int32x4_t sum_high = vpaddl_s16(vget_high_s16(vec));\n    int64x2_t sum = vpaddl_s32(sum_low, sum_high);\n    \n    int32x4_t prod_low = vmull_s16(vget_low_s16(vec), vget_high_s16(vec));\n    int32x4_t prod_high = vpadd_s32(prod_low, prod_low);\n    int64x2_t product = vmulq_s32(prod_high, vdupq_n_s32(1));\n    \n    return std::make_pair(sum, product);\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    uint16x8_t sum = vdupq_n_u16(0);\n    uint16x8_t product = vdupq_n_u16(1);\n\n    for (size_t i = 0; i < numbers.size(); i += 8) {\n        uint16x8_t data = vld1q_u16(reinterpret_cast<uint16_t*>(&numbers[i]));\n\n        sum = vaddq_u16(sum, data);\n        product = vmulq_u16(product, data);\n    }\n\n    uint16_t sum_array[8];\n    uint16_t product_array[8];\n    vst1q_u16(sum_array, sum);\n    vst1q_u16(product_array, product);\n\n    int64_t sum_result = 0;\n    int64_t product_result = 1;\n\n    for (int i = 0; i < 8; ++i) {\n        sum_result += sum_array[i];\n        product_result *= product_array[i];\n    }\n\n    return {sum_result, product_result};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result(numbers.size());\n    int32x4_t current_max = vdupq_n_s32(INT_MIN);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        vst1q_s32(&result[i], current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result(numbers.size());\n    int32x4_t current_max = vdupq_n_s32(INT_MIN);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        vst1q_s32(&result[i], current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result(numbers.size());\n    int32x4_t vmax = vdupq_n_s32(INT_MIN);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        vmax = vmaxq_s32(vmax, input);\n        vst1q_s32(&result[i], vmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> rolling_max(numbers.size());\n    int32x4_t current_max = vdupq_n_s32(INT_MIN);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        vst1q_s32(&rolling_max[i], current_max);\n    }\n\n    return rolling_max;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    std::vector<int> result(numbers.size());\n    int32x4_t curr_max = vdupq_n_s32(INT_MIN);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        curr_max = vmaxq_s32(curr_max, input);\n        vst1q_s32(&result[i], curr_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int length = a.length();\n    \n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        uint8_t temp[16];\n        vst1q_u8(temp, vxor);\n        for (int j = 0; j < 16 && i + j < length; j++) {\n            result += (temp[j] == 0) ? '0' : '1';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int length = a.length();\n    uint8x16_t va, vb, vresult;\n    \n    for(int i = 0; i < length; i += 16){\n        va = vld1q_u8((uint8_t*)(a.c_str() + i));\n        vb = vld1q_u8((uint8_t*)(b.c_str() + i));\n        vresult = veorq_u8(va, vb);\n        uint8_t temp[16];\n        vst1q_u8(temp, vresult);\n        for(int j = 0; j < 16; j++){\n            result += (char)(temp[j] + '0');\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int length = a.length();\n    uint8x16_t va, vb, vxor;\n    for (int i = 0; i < length; i += 16) {\n        va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n        vxor = veorq_u8(va, vb);\n        uint8_t temp[16];\n        vst1q_u8(temp, vxor);\n        for (int j = 0; j < 16 && i + j < length; j++) {\n            result += (temp[j] == 0) ? '0' : '1';\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result;\n    result.resize(a.size());\n\n    uint8x16_t va, vb, vr;\n    uint8_t* pa = reinterpret_cast<uint8_t*>(a.data());\n    uint8_t* pb = reinterpret_cast<uint8_t*>(b.data());\n    uint8_t* pr = reinterpret_cast<uint8_t*>(&result[0]);\n\n    for (size_t i = 0; i < a.size(); i += 16) {\n        va = vld1q_u8(pa + i);\n        vb = vld1q_u8(pb + i);\n        vr = veorq_u8(va, vb);\n        vst1q_u8(pr + i, vr);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    std::string result = \"\";\n    int length = a.length();\n    \n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n        uint8x16_t vresult = veorq_u8(va, vb);\n        \n        uint8_t temp[16];\n        vst1q_u8(temp, vresult);\n        \n        for (int j = 0; j < 16 && i + j < length; j++) {\n            result += (temp[j] == 0) ? '0' : '1';\n        }\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if(strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    const char* longest_str = strings[0].c_str();\n\n    for(const std::string& str : strings){\n        if(str.length() > max_length){\n            max_length = str.length();\n            longest_str = str.c_str();\n        }\n    }\n\n    uint8x16_t max_length_v = vdupq_n_u8(max_length);\n    const uint8_t* longest_str_ptr = reinterpret_cast<const uint8_t*>(longest_str);\n    const uint8x16_t* ptr = reinterpret_cast<const uint8x16_t*>(longest_str_ptr);\n\n    uint8x16_t result = vld1q_u8(ptr);\n    for(size_t i = 16; i < max_length; i += 16){\n        ptr++;\n        uint8x16_t data = vld1q_u8(ptr);\n        uint8x16_t mask = vcgtq_u8(data, result);\n        result = vbslq_u8(mask, data, result);\n    }\n\n    char longest_result[16];\n    vst1q_u8(reinterpret_cast<uint8_t*>(longest_result), result);\n    longest_result[max_length] = '\\0';\n\n    return std::string(longest_result);\n}\n```  "}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if(strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    const char* longest_str = strings[0].c_str();\n\n    for(const auto& str : strings){\n        if(str.length() > max_length){\n            max_length = str.length();\n            longest_str = str.c_str();\n        }\n    }\n\n    uint8x16_t max_length_v = vdupq_n_u8(max_length);\n\n    const uint8_t* str_ptr = reinterpret_cast<const uint8_t*>(longest_str);\n    size_t remaining = max_length;\n\n    while(remaining >= 16){\n        uint8x16_t str_v = vld1q_u8(str_ptr);\n        uint8x16_t cmp_v = vcgtq_u8(str_v, max_length_v);\n        if(vaddvq_u8(cmp_v)){\n            longest_str = reinterpret_cast<const char*>(str_ptr);\n            max_length = remaining;\n            max_length_v = vdupq_n_u8(max_length);\n        }\n        str_ptr += 16;\n        remaining -= 16;\n    }\n\n    for(size_t i = 0; i < remaining; ++i){\n        if(longest_str[i] > max_length){\n            longest_str += i;\n            max_length = remaining;\n            break;\n        }\n    }\n\n    return std::string(longest_str, max_length);\n}\n```  "}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if(strings.empty()) {\n        return \"None\";\n    }\n\n    size_t max_length = 0;\n    const char* longest_str = strings[0].c_str();\n\n    for(const auto& str : strings) {\n        if(str.length() > max_length) {\n            max_length = str.length();\n            longest_str = str.c_str();\n        }\n    }\n\n    uint8x16_t max_length_v = vdupq_n_u8(max_length);\n\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(longest_str);\n    const uint8x16_t* ptr_v = reinterpret_cast<const uint8x16_t*>(ptr);\n\n    uint8x16_t result = vld1q_u8(ptr);\n    for(size_t i = 16; i < max_length; i += 16) {\n        uint8x16_t next = vld1q_u8(ptr + i);\n        uint8x16_t mask = vcgtq_u8(vld1q_u8(ptr + i), result);\n        result = vbslq_u8(mask, next, result);\n    }\n\n    char longest[max_length + 1];\n    vst1q_u8(reinterpret_cast<uint8_t*>(longest), result);\n    longest[max_length] = '\\0';\n\n    return std::string(longest);\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if(strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    const char* longest_str = strings[0].c_str();\n\n    for(const std::string& str : strings){\n        if(str.length() > max_length){\n            max_length = str.length();\n            longest_str = str.c_str();\n        }\n    }\n\n    uint8x16_t max_length_v = vdupq_n_u8(max_length);\n    const uint8_t* longest_str_ptr = reinterpret_cast<const uint8_t*>(longest_str);\n\n    uint8x16_t result = vld1q_u8(longest_str_ptr);\n\n    for(size_t i = 16; i < max_length; i += 16){\n        uint8x16_t next_chunk = vld1q_u8(longest_str_ptr + i);\n        uint8x16_t cmp_result = vcgtq_u8(vld1q_u8(longest_str_ptr + i), result);\n        result = vbslq_u8(cmp_result, next_chunk, result);\n    }\n\n    char result_arr[16];\n    vst1q_u8(reinterpret_cast<uint8_t*>(result_arr), result);\n\n    return std::string(result_arr, max_length);\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if(strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    const char* longest_str = strings[0].c_str();\n\n    for(const std::string& str : strings){\n        if(str.length() > max_length){\n            max_length = str.length();\n            longest_str = str.c_str();\n        }\n    }\n\n    uint8x16_t max_length_v = vdupq_n_u8(max_length);\n\n    const uint8_t* longest_str_ptr = reinterpret_cast<const uint8_t*>(longest_str);\n    const uint8x16_t* ptr = reinterpret_cast<const uint8x16_t*>(longest_str_ptr);\n\n    uint8x16_t result = vld1q_u8(ptr);\n\n    for(size_t i = 16; i < max_length; i += 16){\n        ptr++;\n        uint8x16_t data = vld1q_u8(ptr);\n        uint8x16_t mask = vcgtq_u8(data, result);\n        result = vbslq_u8(mask, data, result);\n    }\n\n    uint8_t result_arr[16];\n    vst1q_u8(result_arr, result);\n\n    return std::string(reinterpret_cast<char*>(result_arr));\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (va[0] != vb[0] || va[1] != vb[1]) {\n        uint64x2_t mask = vcgtq_u64(va, vb);\n        va = vbslq_u64(mask, va - vb, va);\n        vb = vbslq_u64(mask, vb, vb - va);\n    }\n    \n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (va[0] != vb[0] || va[1] != vb[1]) {\n        uint64x2_t mask = vcgtq_u64(va, vb);\n        va = vbslq_u64(mask, va - vb, va);\n        vb = vbslq_u64(mask, vb, vb - va);\n    }\n    \n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (va[0] != vb[0] || va[1] != vb[1]) {\n        uint64x2_t mask = vcgtq_u64(va, vb);\n        va = vbslq_u64(mask, va - vb, va);\n        vb = vbslq_u64(mask, vb, vb - va);\n    }\n    \n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (va[0] != vb[0] || va[1] != vb[1]) {\n        uint64x2_t mask = vcgtq_u64(va, vb);\n        va = vbslq_u64(mask, va - vb, va);\n        vb = vbslq_u64(mask, vb, vb - va);\n    }\n    \n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (va[0] != vb[0] || va[1] != vb[1]) {\n        uint64x2_t mask = vcgtq_u64(va, vb);\n        va = vbslq_u64(mask, va - vb, va);\n        vb = vbslq_u64(mask, vb, vb - va);\n    }\n    \n    return va[0];\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<float, float> find_closest_elements_simd(std::vector<float> numbers){\n    float32x4_t v = vld1q_f32(numbers.data());\n    float32x4_t v_sorted = vcombine_f32(vget_low_f32(v), vget_high_f32(v));\n    v_sorted = vcombine_f32(vmin_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted)), vmax_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted)));\n    float32x2_t v_min = vmin_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted));\n    float32x2_t v_max = vmax_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted));\n    float32x2_t v_diff = vsub_f32(v_max, v_min);\n    float32x2_t v_result = vbsl_f32(vceq_f32(v_diff, vdup_n_f32(vget_lane_f32(v_diff, 0))), v_min, v_max);\n    std::pair<float, float> result;\n    vst1_f32(&result.first, vget_low_f32(v_result));\n    vst1_f32(&result.second, vget_high_f32(v_result));\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<float, float> find_closest_elements_simd(std::vector<float> numbers){\n    float32x4_t v = vld1q_f32(numbers.data());\n    float32x4_t v_sorted = vcombine_f32(vget_low_f32(v), vget_high_f32(v));\n    v_sorted = vsetq_lane_f32(0.0f, v_sorted, 3);\n    v_sorted = vabsq_f32(vsubq_f32(v_sorted, v));\n    float32x2_t v_min = vpmin_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted));\n    float32x2_t v_final = vcombine_f32(vget_low_f32(v_min), vget_high_f32(v_min));\n    float32x2_t v_result = vrev64_f32(v_final);\n    return std::make_pair(vget_lane_f32(v_result, 0), vget_lane_f32(v_result, 1));\n}\n```  "}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<float, float> find_closest_elements_simd(std::vector<float> numbers){\n    float32x4_t v = vld1q_f32(numbers.data());\n    float32x4_t v_sorted = vcombine_f32(vget_low_f32(v), vget_high_f32(v));\n    v_sorted = vsetq_lane_f32(0.0f, v_sorted, 3);\n    float32x4_t v_diff = vsubq_f32(v_sorted, v);\n    float32x2_t v_abs_diff = vpabs_f32(vget_low_f32(v_diff), vget_high_f32(v_diff));\n    float32x2_t v_min_diff = vpmin_f32(vget_low_f32(v_abs_diff), vget_high_f32(v_abs_diff));\n    float32x2_t v_result = vdup_n_f32(vget_lane_f32(v_min_diff, 0));\n    uint32x2_t v_mask = vceqq_f32(vget_low_f32(v_abs_diff), v_result);\n    uint32x2_t v_mask_shifted = vext_u32(v_mask, v_mask, 1);\n    uint32x2_t v_final_mask = vorr_u32(v_mask, v_mask_shifted);\n    float32x2_t v_closest = vbsl_f32(vreinterpret_f32_u32(v_final_mask), vget_low_f32(v), vget_high_f32(v));\n    return std::make_pair(vget_lane_f32(vget_low_f32(v_closest), 0), vget_lane_f32(vget_low_f32(v_closest), 1));\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<float, float> find_closest_elements_simd(std::vector<float> numbers){\n    float32x4_t v = vld1q_f32(numbers.data());\n    float32x4_t v_sorted = vcombine_f32(vget_low_f32(v), vget_high_f32(v));\n    v_sorted = vcombine_f32(vmin_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted)), vmax_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted)));\n    float32x2_t result = vpmin_f32(vget_low_f32(v_sorted), vget_high_f32(v_sorted));\n    float closest1, closest2;\n    vst1_f32(&closest1, vget_low_f32(result));\n    vst1_lane_f32(&closest2, vget_low_f32(result), 1);\n    return std::make_pair(closest1, closest2);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::pair<float, float> find_closest_elements_simd(std::vector<float> numbers){\n    float32x4_t v = vld1q_f32(numbers.data());\n    float32x4_t v_sorted = vcombine_f32(vget_low_f32(v), vget_high_f32(v));\n    v_sorted = vsetq_lane_f32(0.0f, v_sorted, 3);\n    float32x4_t v_diff = vsubq_f32(v_sorted, v);\n    float32x2_t v_abs_diff = vpabs_f32(vget_low_f32(v_diff), vget_high_f32(v_diff));\n    float32x2_t v_min_diff = vpmin_f32(vget_low_f32(v_abs_diff), vget_high_f32(v_abs_diff));\n    float32x2_t v_result = vtbl2_f32(v_sorted, vreinterpret_s32_f32(v_min_diff));\n    return std::make_pair(vget_lane_f32(v_result, 0), vget_lane_f32(v_result, 1));\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    // Find min and max values\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n    \n    // Calculate the scaling factors\n    float scale = 1.0f / (max_val - min_val);\n    float offset = -min_val * scale;\n    \n    // SIMD implementation\n    float32x4_t scale_v = vdupq_n_f32(scale);\n    float32x4_t offset_v = vdupq_n_f32(offset);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t input = vld1q_f32(&numbers[i]);\n        float32x4_t scaled = vmulq_f32(vaddq_f32(input, offset_v), scale_v);\n        vst1q_f32(&numbers[i], scaled);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    // Find min and max values in the vector\n    for (size_t i = 1; i < numbers.size(); i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    // Calculate the range\n    float range = max_val - min_val;\n    \n    // Load the range into a Neon vector\n    float32x4_t range_neon = vdupq_n_f32(range);\n    \n    // Load the min value into a Neon vector\n    float32x4_t min_neon = vdupq_n_f32(min_val);\n    \n    // Calculate the scaling factor\n    float32x4_t scale = vdupq_n_f32(1.0f) / range_neon;\n    \n    // Load the input vector into Neon vector\n    float32x4_t input_neon = vld1q_f32(numbers.data());\n    \n    // Subtract min value from input\n    input_neon = vsubq_f32(input_neon, min_neon);\n    \n    // Multiply by the scaling factor\n    input_neon = vmulq_f32(input_neon, scale);\n    \n    // Store the result back to the output vector\n    std::vector<float> result(numbers.size());\n    vst1q_f32(result.data(), input_neon);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    // Find min and max values in the vector\n    for (int i = 1; i < numbers.size(); i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n    \n    // Calculate the range\n    float range = max_val - min_val;\n    \n    // Load the range into a Neon register\n    float32x4_t range_neon = vdupq_n_f32(range);\n    \n    // Load the min value into a Neon register\n    float32x4_t min_neon = vdupq_n_f32(min_val);\n    \n    // Calculate the reciprocal of the range\n    float32x4_t reciprocal_range = vrecpeq_f32(range_neon);\n    \n    // Calculate the vectorized rescaled values\n    std::vector<float> rescaled(numbers.size());\n    for (int i = 0; i < numbers.size(); i += 4) {\n        float32x4_t values = vld1q_f32(&numbers[i]);\n        float32x4_t rescaled_values = vmulq_f32(vsubq_f32(values, min_neon), reciprocal_range);\n        vst1q_f32(&rescaled[i], rescaled_values);\n    }\n    \n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    // Find min and max values in the vector\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n    \n    // Calculate the range\n    float range = max_val - min_val;\n    \n    // Load the range into a Neon vector\n    float32x4_t range_neon = vdupq_n_f32(range);\n    \n    // Load the min value into a Neon vector\n    float32x4_t min_val_neon = vdupq_n_f32(min_val);\n    \n    // Calculate the reciprocal of the range\n    float32x4_t reciprocal_range = vrecpeq_f32(range_neon);\n    \n    // Calculate the offset\n    float32x4_t offset = vnegq_f32(min_val_neon);\n    \n    // Load the numbers into a Neon vector\n    float32x4_t numbers_neon = vld1q_f32(numbers.data());\n    \n    // Subtract the min value from the numbers\n    numbers_neon = vaddq_f32(numbers_neon, offset);\n    \n    // Multiply by the reciprocal of the range\n    numbers_neon = vmulq_f32(numbers_neon, reciprocal_range);\n    \n    // Store the result back to the vector\n    std::vector<float> result(numbers.size());\n    vst1q_f32(result.data(), numbers_neon);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    // Find min and max values in the vector\n    for (size_t i = 1; i < numbers.size(); i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    // Calculate the range\n    float range = max_val - min_val;\n    \n    // Load the range into a Neon register\n    float32x4_t range_neon = vdupq_n_f32(range);\n    \n    // Load the min value into a Neon register\n    float32x4_t min_val_neon = vdupq_n_f32(min_val);\n    \n    // Calculate the reciprocal of the range\n    float32x4_t reciprocal_range = vrecpeq_f32(range_neon);\n    \n    // Calculate the offset\n    float32x4_t offset = vnegq_f32(min_val_neon);\n    \n    // Load the input numbers into a Neon register\n    float32x4_t input_neon = vld1q_f32(numbers.data());\n    \n    // Subtract the min value from the input numbers\n    float32x4_t subtracted = vaddq_f32(input_neon, offset);\n    \n    // Multiply by the reciprocal of the range\n    float32x4_t result = vmulq_f32(subtracted, reciprocal_range);\n    \n    // Store the result back to the vector\n    std::vector<float> rescaled(numbers.size());\n    vst1q_f32(rescaled.data(), result);\n    \n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64x2_t input = vdupq_n_u64(n);\n    uint64x2_t divisors = vld1q_u64((const uint64_t*)&(uint64_t){1, 2});\n    uint64x2_t result = vdupq_n_u64(0);\n\n    while (vgetq_lane_u64(result, 0) < n / 2) {\n        uint64x2_t mask = vceqq_u64(vdupq_n_u64(0), vreinterpretq_u64_u32(vcltq_u32(vreinterpretq_u32_u64(input), vreinterpretq_u32_u64(divisors))));\n        uint64x2_t selected_divisors = vandq_u64(divisors, mask);\n        uint64x2_t max_divisor = vmaxq_u64(selected_divisors, result);\n        result = vextq_u64(max_divisor, max_divisor, 1);\n        divisors = vaddq_u64(divisors, vdupq_n_u64(2));\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64x2_t input = vdupq_n_u64(n);\n    uint64x2_t divisors = vld1q_u64((const uint64_t[]){1, 2});\n    uint64x2_t result = vdupq_n_u64(0);\n\n    while (1) {\n        uint64x2_t mask = vcltq_u64(divisors, input);\n        uint64x2_t new_result = vbslq_u64(mask, divisors, result);\n        if (vaddvq_u64(mask) == 0) {\n            break;\n        }\n        result = new_result;\n        divisors = vaddq_u64(divisors, vdupq_n_u64(2));\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64x2_t input = vdupq_n_u64(n);\n    uint64x2_t divisors = vld1q_u64((const uint64_t*)&(uint64_t){1, 2});\n    uint64x2_t result = vdupq_n_u64(1);\n\n    while (1) {\n        uint64x2_t mask = vcltq_u64(divisors, input);\n        uint64x2_t new_result = vmaxq_u64(result, vandq_u64(divisors, mask));\n        if (vaddvq_u64(mask) == 0) {\n            break;\n        }\n        result = new_result;\n        divisors = vaddq_u64(divisors, vdupq_n_u64(2));\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisors = vld1q_u64((uint64_t[]){1, 2});\n    uint64x2_t result = vdupq_n_u64(1);\n\n    for (uint64_t i = 3; i < n; i += 2) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        uint64x2_t mod = vreinterpretq_u64_u32(vceqq_u32(vreinterpretq_u32_u64(n_vec), vreinterpretq_u32_u64(vmulq_u64(divisors, i_vec))));\n        uint64x2_t mask = vandq_u64(mod, vcltq_u64(i_vec, n_vec));\n        result = vbslq_u64(mask, i_vec, result);\n    }\n\n    uint64_t result_lane0, result_lane1;\n    vst1q_lane_u64(&result_lane0, result, 0);\n    vst1q_lane_u64(&result_lane1, result, 1);\n\n    return result_lane0 > result_lane1 ? result_lane0 : result_lane1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64x2_t input = vdupq_n_u64(n);\n    uint64x2_t divisors = vld1q_u64((const uint64_t[2]){1, 2});\n    uint64x2_t result = vsubq_u64(vqrdmulhq_u64(input, divisors), divisors);\n    uint64_t output[2];\n    vst1q_u64(output, result);\n    return output[0];\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    \n    int factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    \n    int factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    \n    int factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    \n    int factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    \n    int factor = 2;\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t values = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcltq_f32(values, zero);\n        uint32x4_t mask_shifted = vshlq_n_u32(mask, 31);\n        float32x4_t result_values = vbslq_f32(mask_shifted, values, zero);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_values);\n        for (int j = 0; j < 4; j++) {\n            if (result_arr[j] > 0) {\n                result.push_back(result_arr[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    const float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcltq_f32(input, zero);\n        uint32x4_t mask_neg = vmvnq_u32(mask);\n\n        float32x4_t result_vec = vbslq_f32(mask_neg, input, zero);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_vec);\n\n        for (int j = 0; j < 4; j++) {\n            if (result_arr[j] > 0) {\n                result.push_back(result_arr[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    const float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcltq_f32(vec, zero);\n        uint32x4_t mask_neg = vmvnq_u32(mask);\n\n        float32x4_t result_vec = vbslq_f32(mask_neg, vec, zero);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (result_arr[j] > 0) {\n                result.push_back(result_arr[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcltq_f32(input, zero);\n        uint32x4_t mask_shifted = vshlq_n_u32(mask, 31);\n        float32x4_t result_vec = vbslq_f32(mask_shifted, zero, input);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_vec);\n\n        for (int j = 0; j < 4; j++) {\n            if (result_arr[j] > 0) {\n                result.push_back(result_arr[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vreinterpretq_u32_f32(vcgtq_f32(input, zero));\n        uint32x4_t positive_mask = vandq_u32(mask, vdupq_n_u32(0x7FFFFFFF));\n        float32x4_t result_vec = vbslq_f32(positive_mask, input, vdupq_n_f32(0.0f));\n        vst1q_f32(&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    \n    int64x1_t num = vdup_n_s64(n);\n    int64x1_t divisor = vdup_n_s64(2);\n    \n    int64x1_t limit = vdup_n_s64((int64_t)sqrt(n));\n    \n    while (vget_lane_s64(num, 0) % vget_lane_s64(divisor, 0) != 0 && vget_lane_s64(divisor, 0) <= vget_lane_s64(limit, 0)) {\n        divisor = vadd_s64(divisor, vdup_n_s64(1));\n    }\n    \n    return vget_lane_s64(divisor, 0) > vget_lane_s64(limit, 0);\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    \n    if (n <= 3) {\n        return true;\n    }\n    \n    if ((n % 2 == 0) || (n % 3 == 0)) {\n        return false;\n    }\n    \n    int64x2_t num = vdupq_n_s64(n);\n    int64x2_t div = vdupq_n_s64(6);\n    \n    for (int i = 6; i * i <= n; i += 6) {\n        int64x2_t i_vec = vdupq_n_s64(i);\n        int64x2_t add_vec = vdupq_n_s64(1);\n        \n        int64x2_t mod1 = vaddq_s64(i_vec, add_vec);\n        int64x2_t mod2 = vaddq_s64(i_vec, add_vec);\n        \n        int64x2_t mod1_res = vandq_s64(num, mod1);\n        int64x2_t mod2_res = vandq_s64(num, mod2);\n        \n        uint64x2_t cmp1 = vceqq_s64(mod1_res, vdupq_n_s64(0));\n        uint64x2_t cmp2 = vceqq_s64(mod2_res, vdupq_n_s64(0));\n        \n        if (vgetq_lane_u64(cmp1, 0) || vgetq_lane_u64(cmp2, 0)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    \n    if (n <= 3) {\n        return true;\n    }\n    \n    if ((n % 2 == 0) || (n % 3 == 0)) {\n        return false;\n    }\n    \n    int64x2_t num = vdupq_n_s64(n);\n    int64x2_t div = vdupq_n_s64(2);\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        int64x2_t i_vec = vdupq_n_s64(i);\n        int64x2_t i_plus_2_vec = vdupq_n_s64(i + 2);\n        \n        int64x2_t mod1 = vandq_s64(num, div);\n        int64x2_t mod2 = vandq_s64(num, vaddq_s64(div, vdupq_n_s64(2)));\n        \n        if (vgetq_lane_s64(mod1, 0) == 0 || vgetq_lane_s64(mod1, 1) == 0 || vgetq_lane_s64(mod2, 0) == 0 || vgetq_lane_s64(mod2, 1) == 0) {\n            return false;\n        }\n        \n        div = vaddq_s64(div, vdupq_n_s64(6));\n    }\n    \n    return true;\n}\n```  "}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    \n    if (n <= 3) {\n        return true;\n    }\n    \n    if ((n % 2 == 0) || (n % 3 == 0)) {\n        return false;\n    }\n    \n    int64x2_t num = vdupq_n_s64(n);\n    int64x2_t div = vdupq_n_s64(2);\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        int64x2_t div1 = vdupq_n_s64(i);\n        int64x2_t div2 = vdupq_n_s64(i + 2);\n        \n        int64x2_t rem1 = vreinterpretq_s64_u64(vceqq_s64(vremq_s64(num, div1), vdupq_n_s64(0)));\n        int64x2_t rem2 = vreinterpretq_s64_u64(vceqq_s64(vremq_s64(num, div2), vdupq_n_s64(0)));\n        \n        if (vgetq_lane_s64(rem1, 0) || vgetq_lane_s64(rem1, 1) || vgetq_lane_s64(rem2, 0) || vgetq_lane_s64(rem2, 1)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```  "}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) {\n        return false;\n    }\n    \n    int64x2_t num = vdupq_n_s64(n);\n    int64x2_t div = vdupq_n_s64(2);\n    int64x2_t limit = vdupq_n_s64((int64_t)sqrt(n) + 1);\n\n    while (vgetq_lane_s64(num, 0) % vgetq_lane_s64(div, 0) != 0 && vgetq_lane_s64(num, 1) % vgetq_lane_s64(div, 1) != 0) {\n        div = vaddq_s64(div, vdupq_n_s64(1));\n        if (vgetq_lane_s64(div, 0) >= vgetq_lane_s64(limit, 0) || vgetq_lane_s64(div, 1) >= vgetq_lane_s64(limit, 1)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```  "}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0b11011111); // Mask to convert lowercase to uppercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0b00100000); // Mask to convert uppercase to lowercase\n    uint8x16_t letter_mask = vdupq_n_u8(0b11000000); // Mask to check if a character is a letter\n\n    int length = s.size();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t is_letter = vandq_u8(input, letter_mask);\n        uint8x16_t is_lowercase = vceqq_u8(input, vandq_u8(input, lowercase_mask));\n        uint8x16_t is_uppercase = vceqq_u8(input, vandq_u8(input, uppercase_mask));\n\n        uint8x16_t result_mask = vbslq_u8(is_letter, vbslq_u8(is_lowercase, uppercase_mask, lowercase_mask), input);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), result_mask);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            result[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n        } else {\n            result[i] = s[i];\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0b11011111); // Mask to convert lowercase to uppercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0b00100001); // Mask to convert uppercase to lowercase\n    uint8x16_t letter_mask = vdupq_n_u8(0b11000000); // Mask to check if a character is a letter\n    uint8x16_t reverse_mask = vdupq_n_u8(0b00000001); // Mask to reverse the characters\n\n    for (int i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t is_letter = vandq_u8(input, letter_mask);\n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask);\n        uint8x16_t uppercase = vandq_u8(input, uppercase_mask);\n        uint8x16_t converted = vbslq_u8(is_letter, veorq_u8(lowercase, uppercase), input);\n        uint8x16_t reversed = veorq_u8(converted, reverse_mask);\n        vst1q_u8((uint8_t*)&result[i], reversed);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t lowercase = vdupq_n_u8('a');\n    uint8x16_t uppercase = vdupq_n_u8('A');\n    uint8x16_t mask = vdupq_n_u8(32); // 32 is the difference between lowercase and uppercase letters\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t isLetterMask = vandq_u8(vcgeq_u8(input, vdupq_n_u8('a')), vcleq_u8(input, vdupq_n_u8('z')));\n        uint8x16_t isUpperCaseMask = vandq_u8(isLetterMask, vceqq_u8(vandq_u8(input, mask), lowercase));\n\n        uint8x16_t resultMask = vbslq_u8(isUpperCaseMask, vsubq_u8(input, mask), veorq_u8(input, vdupq_n_u8(32)));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), resultMask);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0b11011111); // Mask to convert lowercase to uppercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0b00100000); // Mask to convert uppercase to lowercase\n    uint8x16_t letter_mask = vdupq_n_u8(0b11000000); // Mask to check if a character is a letter\n\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t is_letter = vandq_u8(input, letter_mask);\n        uint8x16_t is_lowercase = vceqq_u8(input, vandq_u8(input, lowercase_mask));\n        uint8x16_t is_uppercase = vceqq_u8(input, vandq_u8(input, uppercase_mask));\n\n        uint8x16_t result_mask = vbslq_u8(is_letter, vbslq_u8(is_lowercase, uppercase_mask, vbslq_u8(is_uppercase, lowercase_mask, input)), input);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), result_mask);\n    }\n\n    for (; i < length; ++i) {\n        if (isalpha(s[i])) {\n            result[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n        } else {\n            result[i] = s[i];\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s){\n    std::string result = s;\n\n    uint8x16_t lowercaseMask = vdupq_n_u8(0x1F);\n    uint8x16_t uppercaseMask = vdupq_n_u8(0x5F);\n    uint8x16_t invertCaseMask = vdupq_n_u8(0x20);\n\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)&s[i]);\n        uint8x16_t isLetterMask = vandq_u8(vcgeq_u8(input, vdupq_n_u8('a')), vcleq_u8(input, vdupq_n_u8('z')));\n        uint8x16_t isUpperCaseMask = vandq_u8(isLetterMask, vceqq_u8(vandq_u8(input, lowercaseMask), vdupq_n_u8(0)));\n        uint8x16_t isLowerCaseMask = vandq_u8(isLetterMask, vceqq_u8(vandq_u8(input, lowercaseMask), lowercaseMask));\n\n        uint8x16_t invertedCase = vandq_u8(input, invertCaseMask);\n        invertedCase = veorq_u8(invertedCase, isUpperCaseMask);\n        invertedCase = veorq_u8(invertedCase, isLowerCaseMask);\n\n        vst1q_u8((uint8_t*)&result[i], invertedCase);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c - 'A' + 'a';\n        } else {\n            result[i] = c;\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int size = l.size();\n    int num_lanes = 4;\n    int num_chunks = size / num_lanes;\n    \n    int32x4_t mask = {0, 1, 2, 3};\n    int32x4_t step = {num_lanes, num_lanes, num_lanes, num_lanes};\n    \n    for (int i = 0; i < num_chunks; ++i) {\n        int32x4_t v = vld1q_s32(&l[i * num_lanes]);\n        int32x4_t v_mod = vandq_s32(v, mask);\n        int32x4_t v_div = vshrq_n_s32(v, 2);\n        int32x4_t v_sorted = vaddq_s32(v_div, vmulq_s32(v_mod, step));\n        vst1q_s32(&l[i * num_lanes], v_sorted);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int size = l.size();\n    int num_lanes = 4;\n    int num_chunks = size / num_lanes;\n    \n    int32x4_t mask = {0, 1, 2, 3};\n    \n    for (int i = 0; i < num_chunks; ++i) {\n        int32x4_t input = vld1q_s32(&l[i * num_lanes]);\n        \n        int32x4_t div_by_three = vandq_s32(input, vdupq_n_s32(3));\n        uint32x4_t cmp_result = vceqq_s32(div_by_three, vdupq_n_s32(0));\n        \n        int32x4_t sorted = vqtbl1q_s32(input, mask);\n        \n        int32x4_t result = vbslq_s32(cmp_result, sorted, input);\n        \n        vst1q_s32(&l[i * num_lanes], result);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int size = l.size();\n    int num_lanes = 4;\n    int num_chunks = size / num_lanes;\n    \n    int32x4_t mask = {0, 1, 2, 3};\n    \n    for (int i = 0; i < num_chunks; ++i) {\n        int32x4_t input = vld1q_s32(&l[i * num_lanes]);\n        \n        int32x4_t div3_mask = vandq_s32(vdupq_n_s32(1), vceqq_s32(vandq_s32(input, vdupq_n_s32(3)), vdupq_n_s32(0)));\n        \n        int32x4_t sorted = vreinterpretq_s32_s8(vqtbl1q_s8(vreinterpretq_s8_s32(input), vreinterpretq_u8_s32(mask)));\n        \n        int32x4_t result = vbslq_s32(div3_mask, sorted, input);\n        \n        vst1q_s32(&l[i * num_lanes], result);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t vdivisible = vdupq_n_s32(3);\n    int32x4_t vindex = {0, 1, 2, 3};\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t vinput = vld1q_s32(&l[i]);\n        uint32x4_t vcmp = vceqq_s32(vandq_s32(vinput, vdivisible), vdivisible);\n        int32x4_t vsorted = vqtbl1q_s32(vinput, vindex);\n        vst1q_s32(&result[i], vbslq_s32(vcmp, vsorted, vinput));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    int size = l.size();\n    int num_lanes = 4;\n    int num_chunks = size / num_lanes;\n    \n    int32x4_t mask = {0, 1, 2, 3};\n    \n    for (int i = 0; i < num_chunks; ++i) {\n        int32x4_t input = vld1q_s32(&l[i * num_lanes]);\n        int32x4_t sorted = vdupq_n_s32(0);\n        \n        for (int j = 0; j < num_lanes; ++j) {\n            int32x4_t cmp = vceqq_s32(vandq_s32(input, vdupq_n_s32(3)), vdupq_n_s32(0));\n            int32x4_t sorted_val = vbslq_s32(cmp, input, vextq_s32(input, sorted, 1));\n            sorted = vextq_s32(sorted_val, sorted, 1);\n            input = vextq_s32(input, input, 1);\n        }\n        \n        vst1q_s32(&l[i * num_lanes], sorted);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float32x4_t max_val = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < l.size(); i += 4) {\n        float32x4_t val = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, val);\n    }\n\n    float max_element = vgetq_lane_f32(vpmaxq_f32(max_val, max_val), 0);\n    return max_element;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l){\n    float32x4_t vmax = vld1q_f32(&l[0]);\n    for (size_t i = 4; i < l.size(); i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n    float max_val = vmax[0];\n    for (int i = 1; i < 4; ++i) {\n        if (vmax[i] > max_val) {\n            max_val = vmax[i];\n        }\n    }\n    return max_val;\n}\n```  "}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float32x4_t max_val = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < l.size(); i += 4) {\n        float32x4_t val = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, val);\n    }\n\n    float max_element = vgetq_lane_f32(vpmaxq_f32(max_val, max_val), 0);\n    return max_element;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float32x4_t max_val = vld1q_f32(&l[0]);\n    for (int i = 4; i < l.size(); i += 4) {\n        float32x4_t values = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, values);\n    }\n    float max_element = vgetq_lane_f32(vpmaxq_f32(max_val, max_val), 0);\n    for (int i = l.size() - l.size() % 4; i < l.size(); ++i) {\n        max_element = std::max(max_element, l[i]);\n    }\n    return max_element;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float32x4_t vmax = vld1q_f32(&l[0]);\n    for (int i = 4; i < l.size(); i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n    float max_val = vmax[0];\n    for (int i = 1; i < 4; i++) {\n        if (vmax[i] > max_val) {\n            max_val = vmax[i];\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    uint8x16_t digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5};\n    uint8x16_t digit7 = vdupq_n_u8(7);\n    uint8x16_t divisors = {11, 13, 11, 13, 11, 13, 11, 13, 11, 13, 11, 13, 11, 13, 11, 13};\n    uint8x16_t mask = vdupq_n_u8(1);\n\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t values = vld1q_u8((uint8_t*)&digits);\n        uint8x16_t mod11 = vandq_u8(vcgeq_u8(vsubq_u8(values, digit7), vdupq_n_u8(0)), vceqq_u8(vdupq_n_u8(0), vandq_u8(values, vdupq_n_u8(1))));\n        uint8x16_t mod13 = vandq_u8(vcgeq_u8(vsubq_u8(values, digit7), vdupq_n_u8(0)), vceqq_u8(vdupq_n_u8(0), vandq_u8(values, vdupq_n_u8(3))));\n        uint8x16_t divisible = vbslq_u8(mod11, vdupq_n_u8(1), mod13);\n        count += vaddvq_u8(vandq_u8(divisible, mask));\n        digits = vaddq_u8(digits, vdupq_n_u8(16));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n){\n    uint32x4_t count = vdupq_n_u32(0);\n    uint32x4_t divisors = {11, 13, 11, 13};\n    uint32x4_t sevens = {7, 7, 7, 7};\n    \n    for (int i = 0; i < n; i += 4) {\n        uint32x4_t values = vld1q_u32(&i);\n        uint32x4_t mod11 = vandq_u32(values, vdupq_n_u32(10));\n        uint32x4_t mod13 = vandq_u32(values, vdupq_n_u32(12));\n        \n        uint32x4_t divisible_by_11 = vceqq_u32(mod11, vdupq_n_u32(0));\n        uint32x4_t divisible_by_13 = vceqq_u32(mod13, vdupq_n_u32(0));\n        uint32x4_t divisible_by_11_or_13 = vorrq_u32(divisible_by_11, divisible_by_13);\n        \n        uint32x4_t mask = vandq_u32(divisible_by_11_or_13, vceqq_u32(values, sevens));\n        count = vaddq_u32(count, mask);\n    }\n    \n    uint32x2_t count_sum = vpadd_u32(vget_low_u32(count), vget_high_u32(count));\n    uint32x2_t final_count = vpadd_u32(count_sum, count_sum);\n    \n    return vget_lane_u32(final_count, 0);\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    uint8x16_t divisors_11 = {0, 11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165};\n    uint8x16_t divisors_13 = {0, 13, 26, 39, 52, 65, 78, 91, 104, 117, 130, 143, 156, 169, 182, 195};\n    uint8x16_t digit_7 = {7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};\n\n    for(int i = 0; i < n; i += 16){\n        uint8x16_t values = vld1q_u8((uint8_t*)&i);\n        uint8x16_t mod_11 = vandq_u8(values, divisors_11);\n        uint8x16_t mod_13 = vandq_u8(values, divisors_13);\n        uint8x16_t cmp_7_11 = vceqq_u8(mod_11, digit_7);\n        uint8x16_t cmp_7_13 = vceqq_u8(mod_13, digit_7);\n        uint8x16_t cmp_7 = vorrq_u8(cmp_7_11, cmp_7_13);\n        count += vaddvq_u8(cmp_7);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    uint8x16_t divisors_11 = {11, 22, 33, 44, 55, 66, 77, 88, 99, 110, 121, 132, 143, 154, 165, 176};\n    uint8x16_t divisors_13 = {13, 26, 39, 52, 65, 78, 91, 104, 117, 130, 143, 156, 169, 182, 195, 208};\n    uint8x16_t digit_7 = {7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};\n\n    for(int i=0; i<n; i+=16){\n        uint8x16_t values = vld1q_u8((uint8_t*)&i);\n        uint8x16_t mod_11 = vandq_u8(values, vdupq_n_u8(10));\n        uint8x16_t mod_13 = vandq_u8(values, vdupq_n_u8(12));\n        uint8x16_t cmp_11 = vceqq_u8(mod_11, divisors_11);\n        uint8x16_t cmp_13 = vceqq_u8(mod_13, divisors_13);\n        uint8x16_t cmp = vorrq_u8(cmp_11, cmp_13);\n        uint8x16_t result = vandq_u8(cmp, digit_7);\n        count += vaddvq_u8(result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n){\n    uint32x4_t count = vdupq_n_u32(0);\n    uint32x4_t divisors = {11, 13, 11, 13};\n    uint32x4_t sevens = {7, 7, 7, 7};\n\n    for(int i = 0; i < n; i+=4){\n        uint32x4_t values = {i, i+1, i+2, i+3};\n        uint32x4_t divisible_by_11 = vceqq_u32(vandq_u32(values, divisors), divisors);\n        uint32x4_t divisible_by_13 = vceqq_u32(vandq_u32(values, divisors), divisors);\n        uint32x4_t divisible_by_11_or_13 = vorrq_u32(divisible_by_11, divisible_by_13);\n        uint32x4_t has_seven = vceqq_u32(vandq_u32(values, sevens), sevens);\n        count = vaddq_u32(count, vandq_u32(divisible_by_11_or_13, has_seven));\n    }\n\n    uint32x2_t count_sum = vpadd_u32(vget_low_u32(count), vget_high_u32(count));\n    uint32x2_t count_final = vpadd_u32(count_sum, count_sum);\n    \n    return vget_lane_u32(count_final, 0);\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    std::vector<float> result(size);\n\n    float32x4_t v_odd, v_even, v_sorted;\n    for (size_t i = 0; i < size; i += 4) {\n        v_odd = vld1q_f32(l.data() + i);\n        v_even = vld1q_f32(l.data() + i + 1);\n        v_sorted = vsort_f32(v_even);\n        vst1q_f32(result.data() + i, v_odd);\n        vst1q_f32(result.data() + i + 1, v_sorted);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    if(l.size() % 2 != 0){\n        l.push_back(0.0f); // Padding with zero if odd number of elements\n    }\n\n    float32x4_t v1, v2;\n    for(size_t i = 0; i < l.size(); i += 4){\n        v1 = vld1q_f32(&l[i]);\n        v2 = vld1q_f32(&l[i+2]);\n        vst1q_f32(&l[i], v1);\n        vst1q_f32(&l[i+2], vcombine_f32(vget_high_f32(v1), vget_low_f32(v2)));\n    }\n\n    if(l.back() == 0.0f){\n        l.pop_back(); // Removing the padding zero\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    std::vector<float> result(l.size());\n    float32x4_t vec, sorted_vec;\n    for (int i = 0; i < l.size(); i += 4) {\n        vec = vld1q_f32(&l[i]);\n        sorted_vec = vcombine_f32(vrev64_f32(vget_low_f32(vec)), vget_high_f32(vec));\n        vst1q_f32(&result[i], sorted_vec);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    std::vector<float> result(size);\n\n    float32x4_t v_odd, v_even, v_sorted;\n    for (size_t i = 0; i < size; i += 4) {\n        v_odd = vld1q_f32(l.data() + i);\n        v_even = vld1q_f32(l.data() + i + 1);\n        v_sorted = vsort_f32(v_even);\n        vst1q_f32(result.data() + i, v_odd);\n        vst1q_f32(result.data() + i + 1, v_sorted);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    std::vector<float> result(l.size());\n    float32x4_t v1, v2;\n    for (int i = 0; i < l.size(); i += 4) {\n        v1 = vld1q_f32(&l[i]);\n        v2 = vld1q_f32(&l[i]);\n        v2 = vcombine_f32(vrev64_f32(vget_low_f32(v2)), vget_high_f32(v2));\n        vst1q_f32(&result[i], v1);\n        vst1q_f32(&result[i+2], v2);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    int size = l.size();\n    if(size < 3) return false;\n    \n    int32x4_t v;\n    for(int i = 0; i < size - 2; ++i){\n        for(int j = i + 1; j < size - 1; ++j){\n            for(int k = j + 1; k < size; ++k){\n                v = vsetq_lane_s32(l[i], v, 0);\n                v = vsetq_lane_s32(l[j], v, 1);\n                v = vsetq_lane_s32(l[k], v, 2);\n                v = vsetq_lane_s32(0, v, 3);\n                \n                int32x4_t sum = vaddq_s32(v, vextq_s32(v, v, 1));\n                sum = vaddq_s32(sum, vextq_s32(v, v, 2));\n                \n                uint32x4_t cmp = vceqq_s32(sum, vdupq_n_s32(0));\n                uint32x2_t cmp_pair = vget_low_u32(cmp);\n                if(vget_lane_u32(cmp_pair, 0) && vget_lane_u32(cmp_pair, 1)){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int size = l.size();\n    if (size < 3) {\n        return false;\n    }\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < size - 2; ++i) {\n        int32x4_t v_a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < size - 1; ++j) {\n            int32x4_t v_b = vdupq_n_s32(l[j]);\n            for (int k = j + 1; k < size; ++k) {\n                int32x4_t v_c = vdupq_n_s32(l[k]);\n                int32x4_t v_sum = vaddq_s32(vaddq_s32(v_a, v_b), v_c);\n                uint32x4_t v_cmp = vceqq_s32(v_sum, v_zero);\n                if (vgetq_lane_u32(v_cmp, 0) && vgetq_lane_u32(v_cmp, 1) && vgetq_lane_u32(v_cmp, 2) && vgetq_lane_u32(v_cmp, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int size = l.size();\n    if (size < 3) {\n        return false;\n    }\n\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < size - 2; ++i) {\n        int32x4_t a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < size - 1; ++j) {\n            int32x4_t b = vdupq_n_s32(l[j]);\n            for (int k = j + 1; k < size; ++k) {\n                int32x4_t c = vdupq_n_s32(l[k]);\n                int32x4_t sum = vaddq_s32(vaddq_s32(a, b), c);\n                uint32x4_t cmp = vceqq_s32(sum, zero);\n                if (vgetq_lane_u32(cmp, 0) && vgetq_lane_u32(cmp, 1) && vgetq_lane_u32(cmp, 2) && vgetq_lane_u32(cmp, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    int32x4_t v;\n    for (int i = 0; i < l.size() - 2; ++i) {\n        v = vld1q_s32(&l[i]);\n        for (int j = i + 1; j < l.size() - 1; ++j) {\n            int32x4_t v2 = vld1q_s32(&l[j]);\n            for (int k = j + 1; k < l.size(); ++k) {\n                int32x4_t v3 = vld1q_s32(&l[k]);\n                int32x4_t sum = vaddq_s32(vaddq_s32(v, v2), v3);\n                uint32x4_t cmp = vceqq_s32(sum, vdupq_n_s32(0));\n                uint32x2_t cmp2 = vand_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n                if (vget_lane_u32(vget_low_u32(cmp2), 0) && vget_lane_u32(vget_low_u32(cmp2), 1)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int size = l.size();\n    if (size < 3) {\n        return false;\n    }\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < size - 2; ++i) {\n        int32x4_t v_a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < size - 1; ++j) {\n            int32x4_t v_b = vdupq_n_s32(l[j]);\n            for (int k = j + 1; k < size; ++k) {\n                int32x4_t v_c = vdupq_n_s32(l[k]);\n                int32x4_t v_sum = vaddq_s32(vaddq_s32(v_a, v_b), v_c);\n                uint32x4_t v_cmp = vceqq_s32(v_sum, v_zero);\n                uint32x2_t v_cmp_low = vget_low_u32(v_cmp);\n                uint32x2_t v_cmp_high = vget_high_u32(v_cmp);\n                uint64x2_t v_cmp_final = vpaddlq_u32(v_cmp);\n                uint64_t result = vgetq_lane_u64(v_cmp_final, 0) + vgetq_lane_u64(v_cmp_final, 1);\n                if (result != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t increment = vdupq_n_s32(1);\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&l[i]);\n        int32x4_t output = vaddq_s32(input, increment);\n        vst1q_s32(&result[i], output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t increment = vdupq_n_s32(1);\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&l[i]);\n        int32x4_t output = vaddq_s32(input, increment);\n        vst1q_s32(&result[i], output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t increment = vdupq_n_s32(1);\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&l[i]);\n        int32x4_t output = vaddq_s32(input, increment);\n        vst1q_s32(&result[i], output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t increment = vdupq_n_s32(1);\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&l[i]);\n        int32x4_t output = vaddq_s32(input, increment);\n        vst1q_s32(&result[i], output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    std::vector<int> result(l.size());\n    int32x4_t increment = vdupq_n_s32(1);\n\n    for (int i = 0; i < l.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&l[i]);\n        int32x4_t output = vaddq_s32(input, increment);\n        vst1q_s32(&result[i], output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    int size = l.size();\n    int32x4_t zeros = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n\n        for (int j = i + 1; j < size; j++) {\n            int32x4_t vec2 = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(vec, vec2);\n            uint32x4_t cmp = vceqq_s32(sum, zeros);\n\n            if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        vsum = vaddq_s32(vsum, v);\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vsum_final = vpadd_s32(vsum_low, vsum_high);\n\n    int32x2_t vcmp = vceq_s32(vsum_final, vzero);\n    uint32x2_t vresult = vand_u32(vreinterpret_u32_s32(vcmp), vreinterpret_u32_s32(vshl_n_s32(vcmp, 16)));\n\n    return vget_lane_u32(vresult, 0) != 0;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    int size = l.size();\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t v_input = vld1q_s32(&l[i]);\n\n        for (int j = i + 1; j < size; j += 4) {\n            int32x4_t v_input_next = vld1q_s32(&l[j]);\n            int32x4_t v_sum = vaddq_s32(v_input, v_input_next);\n            uint32x4_t v_cmp = vceqq_s32(v_sum, v_zero);\n            uint64x2_t v_cmp64 = vpaddlq_u32(v_cmp);\n            uint32x2_t v_cmp32 = vreinterpret_u32_u64(v_cmp64);\n            uint32x2_t v_result = vpmin_u32(v_cmp32, v_cmp32);\n            if (vget_lane_u32(v_result, 0) == 0xFFFFFFFF) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    int size = l.size();\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n\n        for (int j = i + 1; j < size; j++) {\n            int32x4_t vec2 = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(vec, vec2);\n            uint32x4_t cmp = vceqq_s32(sum, zero);\n            if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        vsum = vaddq_s32(vsum, v);\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vsum_final = vpadd_s32(vsum_low, vsum_high);\n\n    int32x2_t vcmp = vceq_s32(vsum_final, vzero);\n    uint32x2_t vresult = vand_u32(vreinterpret_u32_s32(vcmp), vreinterpret_u32_s32(vshrn_n_s64(vreinterpretq_s64_s32(vsum_final), 32)));\n\n    return vget_lane_u32(vresult, 0) || vget_lane_u32(vresult, 1);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    uint8x8_t base_vec = vdup_n_u8(base);\n    uint8x8_t result_vec = vdup_n_u8(0);\n    \n    while (x > 0) {\n        uint8x8_t x_vec = vdup_n_u8(x % base);\n        result_vec = vadd_u8(result_vec, x_vec);\n        x /= base;\n        result_vec = vshl_n_u8(result_vec, 1);\n    }\n    \n    uint8_t result_arr[8];\n    vst1_u8(result_arr, result_vec);\n    \n    std::string result_str;\n    for (int i = 7; i >= 0; i--) {\n        if (result_arr[i] != 0) {\n            result_str += std::to_string(result_arr[i]);\n        }\n    }\n    \n    return result_str;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base){\n    uint8x8_t digits = {0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x8_t base_v = vdup_n_u8(base);\n    uint8x8_t result = {0, 0, 0, 0, 0, 0, 0, 0};\n\n    for(int i = 0; i < 8; ++i){\n        digits[i] = x % base;\n        x /= base;\n    }\n\n    for(int i = 0; i < 8; ++i){\n        result = vmla_u8(result, base_v, digits);\n        base_v = vmul_u8(base_v, vdup_n_u8(base));\n        digits = vshrq_n_u8(digits, 1);\n    }\n\n    uint8_t res[8];\n    vst1_u8(res, result);\n\n    std::string res_str = \"\";\n    for(int i = 7; i >= 0; --i){\n        res_str += std::to_string(res[i]);\n    }\n\n    return res_str;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base){\n    uint8x8_t digits = {0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x8_t base_v = vdup_n_u8(base);\n    uint8x8_t result = vdup_n_u8(0);\n\n    while (x > 0) {\n        uint8x8_t remainder = vreinterpret_u8_u64(vdup_n_u64(x % base));\n        x /= base;\n        result = vadd_u8(result, vmul_u8(remainder, digits));\n        digits = vadd_u8(digits, digits);\n        digits = vqadd_u8(digits, vclt_u8(digits, base_v));\n    }\n\n    uint8_t res[8];\n    vst1_u8(res, result);\n\n    std::string res_str;\n    for (int i = 7; i >= 0; i--) {\n        if (res[i] != 0) {\n            res_str += std::to_string(res[i]);\n        }\n    }\n\n    return res_str.empty() ? \"0\" : res_str;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base){\n    uint8x8_t digits = vdup_n_u8(0);\n    uint8x8_t base_v = vdup_n_u8(base);\n    uint8x8_t x_v = vdup_n_u8(x);\n\n    uint8x8_t quotient, remainder;\n    std::string result;\n\n    do {\n        quotient = vqrdmulhq_u8(x_v, base_v);\n        remainder = vsub_u8(x_v, vmul_u8(quotient, base_v));\n        x_v = vqrdmulhq_u8(quotient, base_v);\n\n        uint8_t digit[8];\n        vst1_u8(digit, remainder);\n\n        for (int i = 0; i < 8; ++i) {\n            result += std::to_string(digit[i]);\n        }\n    } while (vmaxv_u8(x_v) != 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base){\n    uint8x8_t digits = {0, 0, 0, 0, 0, 0, 0, 0};\n    uint8_t result[8];\n    \n    for(int i = 0; i < 8; ++i){\n        digits[i] = x % base;\n        x /= base;\n    }\n    \n    vst1_u8(result, digits);\n    \n    std::string res = \"\";\n    for(int i = 7; i >= 0; --i){\n        res += std::to_string(result[i]);\n    }\n    \n    return res;\n}\n```  "}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_palindrome_simd(std::string text){\n    int length = text.length();\n    const char* str = text.c_str();\n    \n    int i = 0;\n    int j = length - 1;\n    \n    uint8x16_t result = vdupq_n_u8(1);\n    \n    while (i < j) {\n        uint8x16_t first = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i]));\n        uint8x16_t last = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[j]));\n        \n        uint8x16_t cmp = vceqq_u8(first, last);\n        result = vandq_u8(result, cmp);\n        \n        i += 16;\n        j -= 16;\n    }\n    \n    uint8x8_t final_result = vget_low_u8(result);\n    uint8x8_t compare = vrev64_u8(final_result);\n    uint8x8_t final_compare = vand_u8(final_result, compare);\n    \n    return vget_lane_u8(final_compare, 0) == 255;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_palindrome_simd(std::string text){\n    int length = text.length();\n    const char* str = text.c_str();\n    \n    int i = 0;\n    int j = length - 1;\n    \n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8((uint8_t*)(str + i));\n        uint8x16_t v2 = vld1q_u8((uint8_t*)(str + j));\n        \n        uint8x16_t cmp = vceqq_u8(v1, v2);\n        uint64x2_t cmp64 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(cmp)));\n        \n        uint64_t result = vgetq_lane_u64(cmp64, 0) & vgetq_lane_u64(cmp64, 1);\n        if (result == 0) {\n            return false;\n        }\n        \n        i += 16;\n        j -= 16;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_palindrome_simd(std::string text){\n    int length = text.length();\n    const char* str = text.c_str();\n    \n    int i = 0;\n    int j = length - 1;\n    \n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8((uint8_t*)(str + i));\n        uint8x16_t v2 = vld1q_u8((uint8_t*)(str + j));\n        \n        uint8x16_t cmp = vceqq_u8(v1, v2);\n        \n        uint64x2_t result = vreinterpretq_u64_u8(cmp);\n        uint64_t mask = vgetq_lane_u64(result, 0) & vgetq_lane_u64(result, 1);\n        \n        if (mask == 0) {\n            return false;\n        }\n        \n        i += 16;\n        j -= 16;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_palindrome_simd(std::string text){\n    int length = text.length();\n    const char* str = text.c_str();\n    \n    int i = 0;\n    int j = length - 1;\n    \n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8((uint8_t*)(str + i));\n        uint8x16_t v2 = vld1q_u8((uint8_t*)(str + j));\n        \n        uint8x16_t cmp = vceqq_u8(v1, v2);\n        uint64x2_t result = vreinterpretq_u64_u8(cmp);\n        \n        uint64_t mask = vgetq_lane_u64(result, 0) & vgetq_lane_u64(result, 1);\n        \n        if (mask == 0) {\n            return false;\n        }\n        \n        i += 16;\n        j -= 16;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_palindrome_simd(std::string text){\n    int length = text.length();\n    const char* str = text.c_str();\n    \n    int i = 0;\n    int j = length - 1;\n    \n    while (i < j) {\n        uint8x16_t first = vld1q_u8((uint8_t*)(str + i));\n        uint8x16_t second = vld1q_u8((uint8_t*)(str + j));\n        \n        uint8x16_t cmp = vceqq_u8(first, second);\n        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);\n        \n        uint64x1_t result = vget_lane_u64(cmp64, 0) & vget_lane_u64(cmp64, 1);\n        \n        if (vget_lane_u64(result, 0) == 0) {\n            return false;\n        }\n        \n        i += 16;\n        j -= 16;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    int i;\n    uint8x16_t shift = vdupq_n_u8(5);\n    uint8x16_t a_val = vdupq_n_u8('a');\n    uint8x16_t z_val = vdupq_n_u8('z');\n    uint8x16_t a_offset = vdupq_n_u8('a');\n    \n    for (i = 0; i < s.length(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t diff = vsubq_u8(shifted, a_val);\n        uint8x16_t mod = vandq_u8(diff, vdupq_n_u8(0x1F));\n        uint8x16_t result = vaddq_u8(mod, a_offset);\n        \n        uint8_t result_arr[16];\n        vst1q_u8(result_arr, result);\n        \n        for (int j = 0; j < 16; j++) {\n            out += (char)result_arr[j];\n        }\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    int i;\n    uint8x16_t shift = vdupq_n_u8(5);\n    uint8x16_t a_val = vdupq_n_u8('a');\n    uint8x16_t z_val = vdupq_n_u8('z');\n    uint8x16_t a_offset = vdupq_n_u8('a');\n    uint8x16_t mod_val = vdupq_n_u8(26);\n\n    for (i = 0; i < s.length(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n\n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t diff = vsubq_u8(shifted, a_val);\n        uint8x16_t mod = vaddq_u8(diff, mod_val);\n        uint8x16_t result = vaddq_u8(mod, a_offset);\n\n        uint8_t result_arr[16];\n        vst1q_u8(result_arr, result);\n\n        for (int j = 0; j < 16; j++) {\n            out += (char)result_arr[j];\n        }\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    int i;\n    uint8x16_t shift = vdupq_n_u8(5);\n    uint8x16_t a_val = vdupq_n_u8('a');\n    uint8x16_t z_val = vdupq_n_u8('z');\n    uint8x16_t a_offset = vdupq_n_u8('a' - 'a');\n    uint8x16_t z_offset = vdupq_n_u8('z' - 'a' + 1);\n\n    for (i = 0; i < s.length(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n\n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t diff = vsubq_u8(shifted, a_val);\n        uint8x16_t mod = vandq_u8(diff, z_val);\n        uint8x16_t result = vaddq_u8(mod, a_offset);\n        uint8x16_t mask = vcleq_u8(shifted, z_val);\n        result = vbslq_u8(mask, result, shifted);\n\n        vst1q_u8((uint8_t*)&out[i], result);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    int i;\n    uint8x16_t shift = vdupq_n_u8(5);\n    uint8x16_t a_val = vdupq_n_u8('a');\n    uint8x16_t z_val = vdupq_n_u8('z');\n    uint8x16_t a_offset = vdupq_n_u8('a');\n    uint8x16_t z_offset = vdupq_n_u8('z' + 1);\n\n    for (i = 0; i < s.length(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n\n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t shifted_mod = vqsubq_u8(shifted, a_val);\n        uint8x16_t shifted_mod_z = vqaddq_u8(shifted_mod, z_offset);\n        uint8x16_t result = vqsubq_u8(shifted_mod_z, a_offset);\n\n        vst1q_u8((uint8_t*)&out[i], result);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```\nstd::string decode_shift_simd(std::string s){\n    std::string out;\n    int i;\n    uint8x16_t shift = vdupq_n_u8(5);\n    uint8x16_t a_val = vdupq_n_u8('a');\n    uint8x16_t z_val = vdupq_n_u8('z');\n    uint8x16_t a_offset = vdupq_n_u8('a');\n    uint8x16_t mod_val = vdupq_n_u8(26);\n\n    for (i = 0; i < s.length(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n\n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t diff = vsubq_u8(shifted, a_val);\n        uint8x16_t mod = vaddq_u8(diff, mod_val);\n        uint8x16_t result = vaddq_u8(mod, a_offset);\n\n        uint8_t result_arr[16];\n        vst1q_u8(result_arr, result);\n\n        for (int j = 0; j < 16; j++) {\n            out += (char)result_arr[j];\n        }\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&l[i]);\n        uint32x4_t result = vcltq_s32(values, threshold);\n        if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0 || vgetq_lane_u32(result, 2) == 0 || vgetq_lane_u32(result, 3) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    int32x4_t vec = vld1q_s32(l.data());\n    uint32x4_t result = vcltq_s32(vec, threshold);\n    return vgetq_lane_u32(result, 0) & vgetq_lane_u32(result, 1) & vgetq_lane_u32(result, 2) & vgetq_lane_u32(result, 3);\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&l[i]);\n        uint32x4_t result = vcltq_s32(values, threshold);\n        if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0 || vgetq_lane_u32(result, 2) == 0 || vgetq_lane_u32(result, 3) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&l[i]);\n        uint32x4_t result = vcltq_s32(values, threshold);\n        if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0 || vgetq_lane_u32(result, 2) == 0 || vgetq_lane_u32(result, 3) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&l[i]);\n        uint32x4_t result = vcltq_s32(values, threshold);\n        if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0 || vgetq_lane_u32(result, 2) == 0 || vgetq_lane_u32(result, 3) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int len = brackets.length();\n    if (len % 2 != 0) {\n        return false;\n    }\n\n    uint8x16_t openBracket = vdupq_n_u8('<');\n    uint8x16_t closeBracket = vdupq_n_u8('>');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        uint8x16_t isOpenBracket = vceqq_u8(input, openBracket);\n        uint8x16_t isCloseBracket = vceqq_u8(input, closeBracket);\n        uint8x16_t balance = vsubq_u8(isOpenBracket, isCloseBracket);\n        if (vmaxvq_u8(balance) != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 2 != 0) {\n        return false;\n    }\n\n    uint8x16_t open = vdupq_n_u8('<');\n    uint8x16_t close = vdupq_n_u8('>');\n    uint8x16_t stack = vdupq_n_u8(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t current = vld1q_u8((uint8_t*)(brackets.c_str() + i));\n        uint8x16_t isOpen = vceqq_u8(current, open);\n        uint8x16_t isClose = vceqq_u8(current, close);\n        stack = vaddq_u8(stack, vandq_u8(isOpen, vdupq_n_u8(1)));\n        stack = vsubq_u8(stack, vandq_u8(isClose, vdupq_n_u8(1)));\n    }\n\n    uint8x8_t sum = vpadd_u8(vget_low_u8(stack), vget_high_u8(stack));\n    uint8x8_t final_sum = vpadd_u8(sum, sum);\n\n    uint64x1_t result;\n    vst1_u64(&result[0], vreinterpret_u64_u8(final_sum));\n\n    return (vget_lane_u64(result, 0) == 0);\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 2 != 0) {\n        return false;\n    }\n\n    uint8x16_t open = vdupq_n_u8('<');\n    uint8x16_t close = vdupq_n_u8('>');\n    uint8x16_t stack = vdupq_n_u8(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t current = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        stack = vaddq_u8(stack, vandq_u8(vceqq_u8(current, open), vdupq_n_u8(1)));\n        stack = vsubq_u8(stack, vandq_u8(vceqq_u8(current, close), vdupq_n_u8(1)));\n    }\n\n    uint8x8_t sum = vpadd_u8(vget_low_u8(stack), vget_high_u8(stack));\n    sum = vpadd_u8(sum, sum);\n\n    return vget_lane_u8(sum, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int len = brackets.length();\n    if (len % 2 != 0) {\n        return false;\n    }\n\n    uint8x16_t openBracket = vdupq_n_u8('<');\n    uint8x16_t closeBracket = vdupq_n_u8('>');\n    uint8x16_t stack = vdupq_n_u8(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        uint8x16_t isOpenBracket = vceqq_u8(input, openBracket);\n        uint8x16_t isCloseBracket = vceqq_u8(input, closeBracket);\n\n        stack = vaddq_u8(stack, vandq_u8(isOpenBracket, vdupq_n_u8(1)));\n        stack = vsubq_u8(stack, vandq_u8(isCloseBracket, vdupq_n_u8(1)));\n    }\n\n    uint8x16_t result = vceqq_u8(stack, vdupq_n_u8(0));\n    return vgetq_lane_u8(result, 0) && vgetq_lane_u8(result, 1) && vgetq_lane_u8(result, 2) && vgetq_lane_u8(result, 3);\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int len = brackets.length();\n    int count = 0;\n    uint8x16_t open = vdupq_n_u8('<');\n    uint8x16_t close = vdupq_n_u8('>');\n    \n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t cmp_open = vceqq_u8(chunk, open);\n        uint8x16_t cmp_close = vceqq_u8(chunk, close);\n        count += vaddvq_u8(cmp_open) - vaddvq_u8(cmp_close);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int openCount = 0;\n    int closeCount = 0;\n    uint8x16_t openBracket = vdupq_n_u8('(');\n    uint8x16_t closeBracket = vdupq_n_u8(')');\n    \n    for (size_t i = 0; i < brackets.size(); i += 16) {\n        uint8x16_t bracketChunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        uint8x16_t openMask = vceqq_u8(bracketChunk, openBracket);\n        uint8x16_t closeMask = vceqq_u8(bracketChunk, closeBracket);\n        \n        openCount += vaddvq_u8(openMask);\n        closeCount += vaddvq_u8(closeMask);\n    }\n    \n    return openCount == closeCount;\n}\n```  "}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int count = 0;\n    uint8x16_t open = vdupq_n_u8('(');\n    uint8x16_t close = vdupq_n_u8(')');\n    \n    for (size_t i = 0; i < brackets.size(); i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        uint8x16_t cmp_open = vceqq_u8(chunk, open);\n        uint8x16_t cmp_close = vceqq_u8(chunk, close);\n        \n        int open_count = vaddvq_u8(cmp_open);\n        int close_count = vaddvq_u8(cmp_close);\n        \n        count += open_count - close_count;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets){\n    int count = 0;\n    uint8x16_t open = vdupq_n_u8('(');\n    uint8x16_t close = vdupq_n_u8(')');\n    \n    for (size_t i = 0; i < brackets.size(); i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        uint8x16_t open_mask = vceqq_u8(chunk, open);\n        uint8x16_t close_mask = vceqq_u8(chunk, close);\n        \n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n        \n        count += open_count - close_count;\n    }\n    \n    return count == 0;\n}\n```  "}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int count = 0;\n    uint8x16_t open = vdupq_n_u8('(');\n    uint8x16_t close = vdupq_n_u8(')');\n    \n    for (size_t i = 0; i < brackets.size(); i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        uint8x16_t cmp_open = vceqq_u8(chunk, open);\n        uint8x16_t cmp_close = vceqq_u8(chunk, close);\n        \n        int open_count = vaddvq_u8(cmp_open);\n        int close_count = vaddvq_u8(cmp_close);\n        \n        count += open_count - close_count;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int size = brackets.size();\n    int remaining = 0;\n    uint8x16_t open = vdupq_n_u8('(');\n    uint8x16_t close = vdupq_n_u8(')');\n    \n    for (int i = 0; i < size; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)(brackets.data() + i));\n        \n        uint8x16_t open_mask = vceqq_u8(chunk, open);\n        uint8x16_t close_mask = vceqq_u8(chunk, close);\n        \n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n        \n        remaining += open_count - close_count;\n    }\n    \n    return remaining == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, derivative;\n    \n    for (int i = 0; i < xs.size() - 1; i += 4) {\n        coeffs = vld1q_f32(&xs[i]);\n        float32x4_t indices = {1.0f, 2.0f, 3.0f, 4.0f}; // Coefficients for derivative calculation\n        derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], derivative);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, derivative;\n    \n    for (int i = 0; i < xs.size() - 1; i += 4) {\n        coeffs = vld1q_f32(xs.data() + i);\n        float32x4_t indices = {1.0f, 2.0f, 3.0f, 4.0f}; // Coefficients for derivative calculation\n        derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(result.data() + i, derivative);\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, derivatives;\n    \n    for (int i = 0; i < xs.size() - 1; i += 4) {\n        coeffs = vld1q_f32(xs.data() + i);\n        float32x4_t indices = {1.0f, 2.0f, 3.0f, 4.0f}; // Coefficients for derivative calculation\n        derivatives = vmulq_f32(coeffs, indices);\n        vst1q_f32(result.data() + i, derivatives);\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs = vld1q_f32(xs.data());\n    float32x4_t indices = {1.0f, 2.0f, 3.0f, 4.0f};\n    float32x4_t derivative = vmulq_f32(coeffs, indices);\n    vst1q_f32(result.data(), derivative);\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, derivative;\n    \n    for (int i = 0; i < xs.size() - 1; i += 4) {\n        coeffs = vld1q_f32(xs.data() + i);\n        float32x4_t indices = {1.0f, 2.0f, 3.0f, 4.0f}; // Coefficients for derivative calculation\n        derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(result.data() + i, derivative);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_u32(vsetq_lane_u32(1, vdupq_n_u32(0x00010101), 3)); // 'a', 'e', 'i', 'o', 'u', 'y' (end of word)\n    \n    for (int i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vreinterpretq_u8_u64(vld1q_u64(reinterpret_cast<uint64_t*>(&s[i])));\n        uint8x16_t result = vandq_u8(vceqq_u8(vandq_u8(input, vdupq_n_u8(0xDF)), vowels), vdupq_n_u8(1));\n        count += vaddvq_u8(result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s) {\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    uint8x16_t vowels_vec = vld1q_u8((uint8_t*)vowels);\n    uint8x16_t count = vdupq_n_u8(0);\n    \n    for (int i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n        uint8x16_t is_vowel = vreinterpretq_u8_u16(vceqq_u16(vmovl_u8(input), vmovl_u8(vowels_vec)));\n        count = vaddq_u8(count, is_vowel);\n    }\n    \n    uint8x8_t count_low = vget_low_u8(count);\n    uint8x8_t count_high = vget_high_u8(count);\n    uint8x8_t total_count = vpadd_u8(count_low, count_high);\n    total_count = vpadd_u8(total_count, total_count);\n    \n    return vget_lane_u8(total_count, 0);\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s){\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    const int8x16_t vowels_vec = vld1q_s8(vowels);\n\n    int count = 0;\n    int length = s.length();\n    for (int i = 0; i < length; i += 16) {\n        int8x16_t input = vld1q_s8(reinterpret_cast<int8_t*>(&s[i]));\n        uint8x16_t result = vceqq_s8(input, vowels_vec);\n        count += vaddvq_u8(result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s) {\n    const uint8x16_t vowels = vreinterpretq_u8_u32(vsetq_lane_u32(1, vdupq_n_u32(0x0A0A0A0A), 3));\n    const uint8x16_t y_mask = vdupq_n_u8('y');\n    const uint8x16_t vowels_end_mask = vdupq_n_u8(0x80);\n    int count = 0;\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t is_vowel = vceqq_u8(vandq_u8(input, vowels), vowels);\n        uint8x16_t is_y = vceqq_u8(input, y_mask);\n        uint8x16_t is_y_end = vandq_u8(is_y, vceqq_u8(vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i + 16])), vdupq_n_u8(0)));\n        uint8x16_t is_vowel_end = vandq_u8(is_y_end, vowels_end_mask);\n        count += vaddvq_u8(vaddq_u8(is_vowel, is_vowel_end));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_u32(vsetq_lane_u32(1, vdupq_n_u32(0), 4)); // 'aeiou' in each byte\n    uint8x16_t y_mask = vdupq_n_u8(0);\n    y_mask = vsetq_lane_u8(1, y_mask, 15); // 'y' at the end of the word\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t y_end_mask = vandq_u8(vceqq_u8(vdupq_n_u8('y'), input), vceqq_u8(vdupq_n_u8('\\0'), vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i + 16]))));\n        uint8x16_t vowels_mask = vceqq_u8(vandq_u8(input, vdupq_n_u8(0xDF)), vowels); // case-insensitive comparison\n        vowels_mask = vorrq_u8(vandq_u8(vowels_mask, vdupq_n_u8(0x1F)), y_end_mask);\n        count += vaddvq_u8(vowels_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    uint8x16_t asciiMask = vdupq_n_u8(0x80);\n    uint8x16_t asciiOffset = vdupq_n_u8(0);\n    \n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upperChars = vandq_u8(input, asciiMask);\n        uint8x16_t asciiCodes = vsubq_u8(upperChars, asciiOffset);\n        \n        uint16x8_t asciiCodesLow = vpaddlq_u8(vget_low_u8(asciiCodes));\n        uint16x8_t asciiCodesHigh = vpaddlq_u8(vget_high_u8(asciiCodes));\n        \n        uint32x4_t asciiCodes32 = vpaddlq_u16(vreinterpretq_u16_u32(asciiCodesLow));\n        uint32x4_t asciiCodes64 = vpaddlq_u16(vreinterpretq_u16_u32(asciiCodesHigh));\n        \n        uint64x2_t asciiCodes128 = vpaddlq_u32(asciiCodes32);\n        uint64x2_t asciiCodesSum = vpaddlq_u32(asciiCodes64);\n        \n        sum += vgetq_lane_u64(asciiCodes128, 0) + vgetq_lane_u64(asciiCodes128, 1) +\n               vgetq_lane_u64(asciiCodesSum, 0) + vgetq_lane_u64(asciiCodesSum, 1);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    uint8x16_t asciiMask = vdupq_n_u8(0x80); // Mask to check if character is uppercase\n    uint8x16_t asciiValues;\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        asciiValues = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upperChars = vandq_u8(asciiValues, asciiMask);\n        uint8x16_t asciiSums = vpaddq_u8(upperChars, upperChars);\n        uint16x8_t asciiSums16 = vpaddlq_u8(asciiSums);\n        uint32x4_t asciiSums32 = vpaddlq_u16(asciiSums16);\n        sum += vgetq_lane_u32(asciiSums32, 0) + vgetq_lane_u32(asciiSums32, 1) + vgetq_lane_u32(asciiSums32, 2) + vgetq_lane_u32(asciiSums32, 3);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    uint8x16_t upperMask = vdupq_n_u8(0x20);\n    uint8x16_t asciiValues;\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        asciiValues = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upperChars = vcgtq_u8(asciiValues, upperMask);\n        uint8x16_t upperAscii = vandq_u8(asciiValues, upperChars);\n        sum += vaddvq_u8(upperAscii);\n    }\n\n    return sum;\n}\n```  "}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    uint8x16_t upperMask = vdupq_n_u8(0x20); // Mask to check if character is uppercase\n    uint8x16_t asciiMask = vdupq_n_u8(0x7F); // Mask to extract ASCII value\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t isUpper = vcgtq_u8(input, upperMask);\n        uint8x16_t upperChars = vandq_u8(input, isUpper);\n        uint8x16_t asciiValues = vandq_u8(upperChars, asciiMask);\n        uint8x8x2_t asciiValuesPair = vuzpq_u8(vget_low_u8(asciiValues), vget_high_u8(asciiValues));\n        uint16x8_t asciiValuesSum = vpaddlq_u8(asciiValuesPair.val[0]);\n        uint16x8_t asciiValuesSum2 = vpaddlq_u8(asciiValuesPair.val[1]);\n        uint16x8_t asciiValuesSumFinal = vaddq_u16(asciiValuesSum, asciiValuesSum2);\n        uint32x4_t asciiValuesSum32 = vpaddlq_u16(asciiValuesSumFinal);\n        uint64x2_t asciiValuesSum64 = vpaddlq_u32(asciiValuesSum32);\n        sum += vgetq_lane_u64(asciiValuesSum64, 0) + vgetq_lane_u64(asciiValuesSum64, 1);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    uint8x16_t upperMask = vdupq_n_u8(0x20); // Mask to check if character is uppercase\n    uint8x16_t asciiMask = vdupq_n_u8(0x7F); // Mask to keep only ASCII characters\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upperChars = vandq_u8(input, upperMask);\n        uint8x16_t asciiChars = vandq_u8(upperChars, asciiMask);\n        uint16x8_t asciiSum = vpaddlq_u8(asciiChars);\n        uint32x4_t asciiSum32 = vpaddlq_u16(asciiSum);\n        uint64x2_t asciiSum64 = vpaddlq_u32(asciiSum32);\n        sum += vgetq_lane_u64(asciiSum64, 0) + vgetq_lane_u64(asciiSum64, 1);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if(arr.empty()) return {};\n\n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_idx = vdupq_n_s32(INT_MAX);\n    int32x4_t even_mask = vdupq_n_s32(1);\n\n    for(int i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(values, even_mask);\n        uint32x4_t is_nonzero = vceqq_s32(values, vdupq_n_s32(0));\n        uint32x4_t is_smaller = vcleq_s32(values, min_val);\n\n        min_val = vbslq_s32(vandq_u32(is_even, is_nonzero), values, min_val);\n        min_idx = vbslq_s32(vandq_u32(is_even, is_nonzero), vdupq_n_s32(i), min_idx);\n        min_val = vbslq_s32(vandq_u32(vmvnq_u32(is_even), is_smaller), values, min_val);\n        min_idx = vbslq_s32(vandq_u32(vmvnq_u32(is_even), is_smaller), vdupq_n_s32(i), min_idx);\n    }\n\n    int32x2_t min_val_pair = vpmin_s32(vget_low_s32(min_val), vget_high_s32(min_val));\n    int32x2_t min_idx_pair = vpmin_s32(vget_low_s32(min_idx), vget_high_s32(min_idx));\n\n    int32x2_t final_val = vmin_s32(min_val_pair, vext_s32(min_val_pair, min_val_pair, 1));\n    int32x2_t final_idx = vmin_s32(min_idx_pair, vext_s32(min_idx_pair, min_idx_pair, 1));\n\n    int result[2];\n    vst1_s32(result, final_val);\n    vst1_s32(result + 1, final_idx);\n\n    return {result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if(arr.empty()) return {};\n\n    int32x4_t min_even = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t min_even_idx = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n\n    for(int i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        uint32x4_t even_mask = vandq_u32(vceqq_s32(vandq_s32(values, vdupq_n_s32(1)), vdupq_n_s32(0)), vcltq_s32(values, min_even));\n        min_even = vminq_s32(min_even, vandq_s32(values, even_mask));\n        min_even_idx = vbslq_s32(vreinterpretq_s32_u32(even_mask), vdupq_n_s32(i), min_even_idx);\n    }\n\n    int32x2_t min_even_final = vpmin_s32(vget_low_s32(min_even), vget_high_s32(min_even));\n    int32x2_t min_even_idx_final = vpmin_s32(vget_low_s32(min_even_idx), vget_high_s32(min_even_idx));\n\n    int32x2_t result = vext_s32(min_even_final, min_even_idx_final, 1);\n    return {vget_lane_s32(result, 0), vget_lane_s32(result, 1)};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if(arr.empty()) return {};\n    \n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_idx = vdupq_n_s32(INT_MAX);\n    \n    for(int i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(values), vdupq_n_u32(1));\n        uint32x4_t even_values_mask = vceqq_u32(even_mask, vdupq_n_u32(0));\n        int32x4_t even_values = vandq_s32(values, vreinterpretq_s32_u32(even_values_mask));\n        \n        int32x4_t cmp_mask = vcltq_s32(even_values, min_val);\n        min_val = vminq_s32(min_val, even_values);\n        min_idx = vbslq_s32(cmp_mask, vdupq_n_s32(i), min_idx);\n    }\n    \n    int32x2_t min_val2 = vpmin_s32(vget_low_s32(min_val), vget_high_s32(min_val));\n    int32x2_t min_idx2 = vpmin_s32(vget_low_s32(min_idx), vget_high_s32(min_idx));\n    \n    int32x2_t result = vext_s32(min_val2, min_idx2, 1);\n    \n    std::vector<int> res(2);\n    vst1_s32(&res[0], result);\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if(arr.empty()) return {};\n\n    int32x4_t min_even = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t min_even_idx = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n\n    for(int i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        uint32x4_t even_mask = vandq_u32(vceqq_s32(vandq_s32(values, vdupq_n_s32(1)), vdupq_n_s32(0)), vcltq_s32(values, min_even));\n        min_even = vminq_s32(min_even, vandq_s32(values, even_mask));\n        min_even_idx = vbslq_s32(vreinterpretq_s32_u32(even_mask), vdupq_n_s32(i), min_even_idx);\n    }\n\n    int32x2_t min_even_final = vpmin_s32(vget_low_s32(min_even), vget_high_s32(min_even));\n    int32x2_t min_even_idx_final = vpmin_s32(vget_low_s32(min_even_idx), vget_high_s32(min_even_idx));\n\n    if(vget_lane_s32(min_even_final, 0) == INT_MAX) return {};\n\n    return {vgetq_lane_s32(min_even_final, 0), vgetq_lane_s32(min_even_idx_final, 0)};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if(arr.empty()) return {};\n    \n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_idx = vdupq_n_s32(INT_MAX);\n    \n    for(int i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vandq_u32(vceqq_s32(vandq_s32(values, vdupq_n_s32(1)), vdupq_n_s32(0)), vcltq_s32(values, min_val));\n        min_val = vminq_s32(min_val, values);\n        min_idx = vbslq_s32(mask, vdupq_n_s32(i), min_idx);\n    }\n    \n    int32x2_t min_val2 = vpmin_s32(vget_low_s32(min_val), vget_high_s32(min_val));\n    int32x2_t min_idx2 = vpmin_s32(vget_low_s32(min_idx), vget_high_s32(min_idx));\n    \n    int32x2_t result = vcombine_s32(min_val2, min_idx2);\n    \n    int result_arr[2];\n    vst1_s32(result_arr, result);\n    \n    return {result_arr[0], result_arr[1]};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst){\n    int max_val = -1;\n    int max_freq = 0;\n    \n    int size = lst.size();\n    int32x4_t target = vld1q_s32(&lst[0]);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t values = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vceqq_s32(values, target);\n        uint32x4_t freq = vpaddlq_u16(vcntq_u16(vreinterpretq_u16_u32(mask)));\n        \n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(values, j);\n            int f = vgetq_lane_u32(freq, j);\n            \n            if (val > 0 && f >= val && f > max_freq) {\n                max_val = val;\n                max_freq = f;\n            }\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst){\n    int max_val = -1;\n    int max_freq = 0;\n    \n    uint32x4_t freq_count = vdupq_n_u32(0);\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        uint32x4_t values = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        \n        freq_count = vqaddq_u32(freq_count, vceqq_u32(values, vdupq_n_u32(1)));\n        freq_count = vqaddq_u32(freq_count, vceqq_u32(values, vdupq_n_u32(2)));\n        freq_count = vqaddq_u32(freq_count, vceqq_u32(values, vdupq_n_u32(3)));\n        freq_count = vqaddq_u32(freq_count, vceqq_u32(values, vdupq_n_u32(4)));\n    }\n    \n    uint32x2_t freq_count_low = vget_low_u32(freq_count);\n    uint32x2_t freq_count_high = vget_high_u32(freq_count);\n    \n    uint32x2_t max_freq_low = vpmax_u32(freq_count_low, freq_count_low);\n    uint32x2_t max_freq_high = vpmax_u32(freq_count_high, freq_count_high);\n    \n    uint32x2_t max_freq_final = vpmax_u32(max_freq_low, max_freq_high);\n    \n    uint32_t max_freq_scalar;\n    vst1_lane_u32(&max_freq_scalar, max_freq_final, 0);\n    \n    if (max_freq_scalar > 0) {\n        for (int i = 0; i < lst.size(); ++i) {\n            if (lst[i] == max_freq_scalar && max_freq_scalar >= lst[i]) {\n                max_val = max_freq_scalar;\n                break;\n            }\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = -1;\n    int max_freq = 0;\n    \n    int size = lst.size();\n    int32x4_t v_max_val = vdupq_n_s32(-1);\n    int32x4_t v_max_freq = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t v_lst = vld1q_s32(&lst[i]);\n        \n        for (int j = 0; j < 4; j++) {\n            int32x4_t v_mask = vceqq_s32(v_lst, vdupq_n_s32(lst[i + j]));\n            int32x4_t v_count = vcntq_s32(v_mask);\n            \n            v_max_val = vmaxq_s32(v_max_val, v_lst);\n            v_max_freq = vmaxq_s32(v_max_freq, v_count);\n        }\n    }\n    \n    int32x2_t v_max_val_low = vget_low_s32(v_max_val);\n    int32x2_t v_max_val_high = vget_high_s32(v_max_val);\n    \n    int32x2_t v_max_freq_low = vget_low_s32(v_max_freq);\n    int32x2_t v_max_freq_high = vget_high_s32(v_max_freq);\n    \n    int32x2_t v_result = vpmax_s32(v_max_val_low, v_max_val_high);\n    v_result = vand_s32(v_result, vreinterpret_s32_u32(vcle_s32(v_result, v_max_freq_low)));\n    v_result = vand_s32(v_result, vreinterpret_s32_u32(vcle_s32(v_result, v_max_freq_high)));\n    \n    int result;\n    vst1_s32(&result, v_result);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst){\n    int max_val = -1;\n    int max_freq = 0;\n    \n    uint32x4_t freqs = vdupq_n_u32(0);\n    uint32x4_t values = vdupq_n_u32(0);\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        uint32x4_t input = vld1q_u32(&lst[i]);\n        \n        uint32x4_t mask = vceqq_u32(input, values);\n        freqs = vaddq_u32(freqs, vandq_u32(mask, vdupq_n_u32(1)));\n        values = vbslq_u32(mask, values, input);\n    }\n    \n    uint32x4_t cmp_mask = vcgeq_u32(freqs, values);\n    uint32x4_t result_mask = vandq_u32(cmp_mask, vcgtq_u32(values, vdupq_n_u32(0)));\n    \n    uint32x2_t result = vmax_u32(vget_low_u32(result_mask), vget_high_u32(result_mask));\n    uint32x2_t result_perm = vpmax_u32(result, result);\n    \n    uint32_t final_result;\n    vst1_lane_u32(&final_result, result_perm, 0);\n    \n    return (final_result == 0) ? -1 : final_result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst){\n    int max_val = -1;\n    int max_freq = 0;\n    \n    uint32x4_t freq_count = vdupq_n_u32(0);\n    uint32x4_t max_val_vec = vdupq_n_u32(0);\n    uint32x4_t max_freq_vec = vdupq_n_u32(0);\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        uint32x4_t values = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        \n        uint32x4_t mask = vceqq_u32(values, max_val_vec);\n        freq_count = vaddq_u32(freq_count, vandq_u32(mask, vdupq_n_u32(1)));\n        \n        mask = vcgtq_u32(freq_count, max_freq_vec);\n        max_val_vec = vbslq_u32(mask, values, max_val_vec);\n        max_freq_vec = vbslq_u32(mask, freq_count, max_freq_vec);\n    }\n    \n    uint32x2_t max_val_pair = vmax_u32(vget_low_u32(max_val_vec), vget_high_u32(max_val_vec));\n    uint32x2_t max_freq_pair = vmax_u32(vget_low_u32(max_freq_vec), vget_high_u32(max_freq_vec));\n    \n    max_val = vmaxvq_u32(max_val_pair);\n    int max_freq_val = vmaxvq_u32(max_freq_pair);\n    \n    if (max_val > 0 && max_freq_val >= max_val) {\n        return max_val;\n    } else {\n        return -1;\n    }\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t max_weight = vdupq_n_s32(w);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t elements = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, elements);\n    }\n    \n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t sum_final = vpadd_s32(sum_low, sum_high);\n    \n    int32x2_t compare_result = vcle_s32(sum_final, max_weight);\n    \n    return vget_lane_s32(compare_result, 0) && vget_lane_s32(compare_result, 1);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, vec);\n    }\n    \n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t sum_final = vpadd_s32(sum_low, sum_high);\n    \n    int total_sum = vget_lane_s32(sum_final, 0) + vget_lane_s32(sum_final, 1);\n    \n    bool is_balanced = true;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - i - 1]) {\n            is_balanced = false;\n            break;\n        }\n    }\n    \n    return is_balanced && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, vec);\n    }\n    \n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t sum_final = vpadd_s32(sum_low, sum_high);\n    \n    int total_sum = vget_lane_s32(sum_final, 0) + vget_lane_s32(sum_final, 1);\n    \n    bool balanced = true;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) {\n            balanced = false;\n            break;\n        }\n    }\n    \n    return balanced && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, vec);\n    }\n    \n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t sum_final = vpadd_s32(sum_low, sum_high);\n    \n    int total_sum = vget_lane_s32(sum_final, 0) + vget_lane_s32(sum_final, 1);\n    \n    bool is_balanced = true;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n    \n    return is_balanced && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, vec);\n    }\n    \n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t sum_final = vpadd_s32(sum_low, sum_high);\n    \n    int total_sum = vget_lane_s32(sum_final, 0) + vget_lane_s32(sum_final, 1);\n    \n    bool is_balanced = true;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n    \n    return is_balanced && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint smallest_change_simd(std::vector<int> arr){\n    int size = arr.size();\n    int changes = 0;\n    \n    int* data = arr.data();\n    int* end = data + size;\n    \n    int32x4_t v1, v2;\n    \n    for (int i = 0; i < size / 8; ++i) {\n        v1 = vld1q_s32(data);\n        v2 = vld1q_s32(end - 4);\n        int32x4_t cmp = vceqq_s32(v1, v2);\n        changes += 4 - vaddvq_s32(cmp);\n        data += 4;\n        end -= 4;\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint smallest_change_simd(std::vector<int> arr){\n    int size = arr.size();\n    int half_size = size / 2;\n    \n    int changes = 0;\n    \n    int32x4_t v1, v2;\n    \n    for (int i = 0; i < half_size; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[size - i - 4]);\n        \n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        uint32x4_t cmp_rev = vrev64q_u32(cmp);\n        uint32x4_t cmp_final = vandq_u32(cmp, cmp_rev);\n        \n        changes += 4 - vcnt_u32(cmp_final);\n    }\n    \n    if (size % 2 != 0) {\n        if (arr[half_size] != arr[size - half_size - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint smallest_change_simd(std::vector<int> arr){\n    int size = arr.size();\n    int half_size = size / 2;\n    \n    int changes = 0;\n    \n    int32x4_t v1, v2;\n    for (int i = 0; i < half_size; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[size - i - 4]);\n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        changes += 4 - vaddvq_u32(cmp);\n    }\n    \n    if (size % 2 != 0) {\n        if (arr[half_size] != arr[size - half_size - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint smallest_change_simd(std::vector<int> arr){\n    int size = arr.size();\n    int half_size = size / 2;\n    \n    int changes = 0;\n    \n    int32x4_t v1, v2;\n    for (int i = 0; i < half_size; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[size - i - 4]);\n        \n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        uint32x4_t cmp_rev = vrev64q_u32(cmp);\n        uint32x4_t cmp_final = vandq_u32(cmp, cmp_rev);\n        \n        changes += 4 - vcnt_u32(cmp_final);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint smallest_change_simd(std::vector<int> arr){\n    int size = arr.size();\n    int half_size = size / 2;\n    \n    int changes = 0;\n    \n    int32x4_t vec1, vec2;\n    for (int i = 0; i < half_size; i += 4) {\n        vec1 = vld1q_s32(&arr[i]);\n        vec2 = vld1q_s32(&arr[size - i - 4]);\n        \n        uint32x4_t cmp = vceqq_s32(vec1, vec2);\n        uint32x4_t cmp_rev = vrev64q_u32(cmp);\n        uint32x4_t cmp_final = vandq_u32(cmp, cmp_rev);\n        \n        changes += vaddvq_u32(cmp_final);\n    }\n    \n    return size / 2 - changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<std::string> result;\n    \n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    for (const auto &str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum1 = vaddq_u32(sum1, len);\n    }\n    \n    for (const auto &str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum2 = vaddq_u32(sum2, len);\n    }\n    \n    uint32x4_t cmp = vcltq_u32(sum1, sum2);\n    \n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        uint32x4_t mask = vld1q_u32(reinterpret_cast<const uint32_t*>(&cmp) + i);\n        uint32x4_t result_mask = vandq_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(&lst1) + i), mask);\n        uint32_t result_arr[4];\n        vst1q_u32(result_arr, result_mask);\n        for (int j = 0; j < 4; ++j) {\n            if (result_arr[j] != 0) {\n                result.push_back(lst1[i + j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<std::string> result;\n    \n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    for (const auto &str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum1 = vaddq_u32(sum1, len);\n    }\n    \n    for (const auto &str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum2 = vaddq_u32(sum2, len);\n    }\n    \n    uint32x4_t cmp = vcltq_u32(sum1, sum2);\n    \n    for (size_t i = 0; i < 4; i++) {\n        if (vgetq_lane_u32(cmp, i)) {\n            result.push_back(lst1[i]);\n        }\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<std::string> result;\n    \n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    for (const auto &str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum1 = vaddq_u32(sum1, len);\n    }\n    \n    for (const auto &str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum2 = vaddq_u32(sum2, len);\n    }\n    \n    uint32x4_t cmp = vcltq_u32(sum1, sum2);\n    \n    for (int i = 0; i < 4; ++i) {\n        if (vgetq_lane_u32(cmp, i)) {\n            result.push_back(lst1[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<std::string> result;\n    \n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    for (const auto& str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.size());\n        sum1 = vaddq_u32(sum1, len);\n    }\n    \n    for (const auto& str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.size());\n        sum2 = vaddq_u32(sum2, len);\n    }\n    \n    uint32x4_t cmp = vcltq_u32(sum1, sum2);\n    \n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        uint32x4_t mask = vld1q_u32(reinterpret_cast<const uint32_t*>(&cmp) + i);\n        uint32x4_t result_mask = vandq_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(&lst1) + i), mask);\n        uint32_t result_arr[4];\n        vst1q_u32(result_arr, result_mask);\n        for (int j = 0; j < 4; ++j) {\n            if (result_arr[j] != 0) {\n                result.push_back(lst1[i + j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    std::vector<std::string> result;\n    \n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    for (const auto& str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum1 = vaddq_u32(sum1, len);\n    }\n    \n    for (const auto& str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        sum2 = vaddq_u32(sum2, len);\n    }\n    \n    uint32x4_t cmp = vcltq_u32(sum1, sum2);\n    \n    for (size_t i = 0; i < lst1.size(); ++i) {\n        if (vgetq_lane_u32(cmp, i) != 0) {\n            result.push_back(lst1[i]);\n        }\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (x == 1) {\n        return true;\n    }\n\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n\n    uint64x2_t result = vdupq_n_u64(0);\n\n    uint64x2_t pow = vdupq_n_u64(1);\n    uint64x2_t i = vdupq_n_u64(1);\n\n    while (true) {\n        pow = vmulq_u64(pow, n_vec);\n        result = vaddq_u64(result, vreinterpretq_u64_u32(vceqq_u32(vreinterpretq_u32_u64(pow), x_vec)));\n        i = vaddq_u64(i, vdupq_n_u64(1));\n\n        uint64x2_t cmp = vceqq_u64(result, vdupq_n_u64(1));\n        if (vgetq_lane_u64(cmp, 0) == 1 || vgetq_lane_u64(cmp, 1) == 1) {\n            return true;\n        }\n\n        uint64x2_t cmp2 = vceqq_u64(pow, x_vec);\n        if (vgetq_lane_u64(cmp2, 0) == 1 || vgetq_lane_u64(cmp2, 1) == 1) {\n            return false;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (x == 1) {\n        return true;\n    }\n    \n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    \n    uint64x2_t result = vdupq_n_u64(1);\n    \n    while (x_vec[0] % n == 0 && x_vec[1] % n == 0) {\n        x_vec = vdivq_u64(x_vec, n_vec);\n    }\n    \n    return x_vec[0] == 1 && x_vec[1] == 1;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (x == 1) {\n        return true;\n    }\n\n    uint64x1_t x_vec = vdup_n_u64(x);\n    uint64x1_t n_vec = vdup_n_u64(n);\n\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t pow = vdup_n_u64(1);\n\n    while (vget_lane_u64(result, 0) < x) {\n        pow = vmul_u64(pow, n_vec);\n        result = vmul_u64(pow, n_vec);\n    }\n\n    return vget_lane_u64(result, 0) == x;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (x == 1) {\n        return true;\n    }\n\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t power = vdupq_n_u64(n);\n\n    while (true) {\n        result = vmulq_u64(result, power);\n        uint64x2_t cmp = vceqq_u64(result, x_vec);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return true;\n        }\n        if (vgetq_lane_u64(vmaxq_u64(result, x_vec), 0) > vgetq_lane_u64(x_vec, 0) ||\n            vgetq_lane_u64(vmaxq_u64(result, x_vec), 1) > vgetq_lane_u64(x_vec, 1)) {\n            return false;\n        }\n    }\n\n    return false; // This should never be reached\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (x == 1) {\n        return true;\n    }\n\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n\n    uint64x2_t result = vdupq_n_u64(0);\n\n    while (x_vec[0] % n == 0 && x_vec[1] % n == 0) {\n        x_vec[0] /= n;\n        x_vec[1] /= n;\n        result = vaddq_u64(result, vreinterpretq_u64_u32(vceqq_u32(vreinterpretq_u32_u64(x_vec), vreinterpretq_u32_u64(vdupq_n_u64(1))));\n    }\n\n    return (result[0] == 2 && result[1] == 2);\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    uint8x16_t primes = {2, 3, 5, 7, 11, 13, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x16_t input;\n    uint8x16_t cmp_result;\n\n    for (size_t i = 0; i < num.size(); i += 16) {\n        input = vld1q_u8((const uint8_t*)&num[i]);\n        cmp_result = vceqq_u8(input, primes);\n        count += vaddvq_u8(cmp_result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    uint8x16_t primes = {2, 3, 5, 7, 11, 13, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x16_t input, cmp_result;\n    \n    for (size_t i = 0; i < num.size(); i += 16) {\n        input = vld1q_u8((const uint8_t*)(num.c_str() + i));\n        cmp_result = vceqq_u8(input, primes);\n        count += vaddvq_u8(cmp_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    uint8x16_t primes = {2, 3, 5, 7, 11, 13, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x16_t input;\n    \n    for (size_t i = 0; i < num.size(); i += 16) {\n        input = vld1q_u8((const uint8_t*)&num[i]);\n        uint8x16_t cmp_result = vceqq_u8(input, primes);\n        count += vaddvq_u8(cmp_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    uint8x16_t primes = {2, 3, 5, 7, 11, 13, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x16_t input;\n    uint8x16_t cmp_result;\n\n    for (size_t i = 0; i < num.size(); i += 16) {\n        input = vld1q_u8((const uint8_t*)&num[i]);\n        cmp_result = vceqq_u8(input, primes);\n        count += vaddvq_u8(cmp_result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    uint8x16_t primes = {2, 3, 5, 7, 11, 13, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    uint8x16_t input;\n    uint8x16_t cmp_result;\n\n    for (size_t i = 0; i < num.size(); i += 16) {\n        input = vld1q_u8((const uint8_t*)&num[i]);\n        cmp_result = vceqq_u8(input, primes);\n        count += vaddvq_u8(cmp_result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int length = s.length();\n\n    for(int i = 0; i <= length - 3; i += 16){\n        uint8x16_t v1 = vld1q_u8(str + i);\n        uint8x16_t v2 = vld1q_u8(str + i + 1);\n        uint8x16_t v3 = vld1q_u8(str + i + 2);\n\n        uint8x16_t v12 = vceqq_u8(v1, v2);\n        uint8x16_t v13 = vceqq_u8(v1, v3);\n        uint8x16_t v23 = vceqq_u8(v2, v3);\n\n        uint8x16_t v123 = vorrq_u8(v12, vorrq_u8(v13, v23));\n\n        if(vgetq_lane_u8(v123, 0) || vgetq_lane_u8(v123, 1) || vgetq_lane_u8(v123, 2) || vgetq_lane_u8(v123, 3) ||\n           vgetq_lane_u8(v123, 4) || vgetq_lane_u8(v123, 5) || vgetq_lane_u8(v123, 6) || vgetq_lane_u8(v123, 7) ||\n           vgetq_lane_u8(v123, 8) || vgetq_lane_u8(v123, 9) || vgetq_lane_u8(v123, 10) || vgetq_lane_u8(v123, 11) ||\n           vgetq_lane_u8(v123, 12) || vgetq_lane_u8(v123, 13) || vgetq_lane_u8(v123, 14) || vgetq_lane_u8(v123, 15)){\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int length = s.length();\n\n    uint8x16_t prev = vld1q_u8(str);\n    uint8x16_t curr = vld1q_u8(str + 16);\n    uint8x16_t next = vld1q_u8(str + 32);\n\n    for(int i = 0; i < length - 2; i += 16){\n        uint8x16_t all_distinct = vceqq_u8(prev, curr) | vceqq_u8(curr, next) | vceqq_u8(prev, next);\n        if(vmaxvq_u8(all_distinct) != 0){\n            return false;\n        }\n\n        prev = curr;\n        curr = next;\n        next = vld1q_u8(str + i + 48);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    if(s.length() < 3) {\n        return false;\n    }\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    uint8x16x3_t chars = vld3q_u8(str);\n\n    uint8x16_t mask1 = vceqq_u8(chars.val[0], chars.val[1]);\n    uint8x16_t mask2 = vceqq_u8(chars.val[1], chars.val[2]);\n    uint8x16_t mask3 = vceqq_u8(chars.val[2], chars.val[0]);\n    uint8x16_t mask = vorr_u8(vorr_u8(mask1, mask2), mask3);\n\n    return !vgetq_lane_u8(mask, 0);\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int length = s.length();\n\n    for(int i = 0; i <= length - 24; i += 24){\n        uint8x16_t v1 = vld1q_u8(str + i);\n        uint8x16_t v2 = vld1q_u8(str + i + 16);\n        uint8x16_t v3 = vld1q_u8(str + i + 32);\n\n        uint8x16_t v12 = vcombine_u8(vget_low_u8(v1), vget_low_u8(v2));\n        uint8x16_t v23 = vcombine_u8(vget_low_u8(v2), vget_low_u8(v3));\n\n        uint8x16_t v12_unique = vceqq_u8(v12, vextq_u8(v12, v12, 1));\n        uint8x16_t v23_unique = vceqq_u8(v23, vextq_u8(v23, v23, 1));\n\n        if(vgetq_lane_u8(v12_unique, 15) || vgetq_lane_u8(v23_unique, 0)){\n            return false;\n        }\n    }\n\n    for(int i = length - 24 + 1; i < length - 2; ++i){\n        if(str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]){\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    if(s.length() < 3){\n        return false;\n    }\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int length = s.length();\n\n    for(int i = 0; i <= length - 24; i += 24){\n        uint8x16_t v1 = vld1q_u8(str + i);\n        uint8x16_t v2 = vld1q_u8(str + i + 16);\n        uint8x16_t v3 = vld1q_u8(str + i + 32);\n\n        uint8x16_t v12 = vcombine_u8(v1, v2);\n        uint8x16_t v23 = vcombine_u8(v2, v3);\n\n        uint8x16_t v12_unique = vceqq_u8(v12, vextq_u8(v12, v12, 1));\n        uint8x16_t v23_unique = vceqq_u8(v23, vextq_u8(v23, v23, 1));\n\n        uint8x16_t v_unique = vorrq_u8(v12_unique, v23_unique);\n        if(vgetq_lane_u8(v_unique, 0) || vgetq_lane_u8(v_unique, 8)){\n            return false;\n        }\n    }\n\n    for(int i = length - 24 + 1; i < length - 2; ++i){\n        if(s[i] == s[i - 1] || s[i] == s[i - 2] || s[i - 1] == s[i - 2]){\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    int length = str.length();\n    if (length <= 1) {\n        return false;\n    }\n    \n    int sqrt_length = sqrt(length);\n    uint8x16_t vLength = vdupq_n_u8(length);\n    uint8x16_t vSqrtLength = vdupq_n_u8(sqrt_length);\n    \n    uint8x16_t vMask = vdupq_n_u8(1);\n    for (int i = 2; i <= sqrt_length; ++i) {\n        uint8x16_t vI = vdupq_n_u8(i);\n        uint8x16_t vRemainder = vdupq_n_u8(length % i);\n        uint8x16_t vIsDivisible = vceqq_u8(vRemainder, vMask);\n        uint8x16_t vAllZeros = vceqq_u8(vIsDivisible, vMask);\n        uint8x16_t vAnyDivisible = vreinterpretq_u8_u16(vpmaxq_u8(vreinterpretq_u16_u8(vIsDivisible), vreinterpretq_u16_u8(vIsDivisible)));\n        if (!vgetq_lane_u8(vAnyDivisible, 0)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    int length = str.length();\n    \n    if (length <= 1) {\n        return false;\n    }\n    \n    if (length == 2) {\n        return true;\n    }\n    \n    int sqrt_length = sqrt(length);\n    for (int i = 2; i <= sqrt_length; i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    int length = str.length();\n    if (length <= 1) {\n        return false;\n    }\n    \n    int sqrt_length = sqrt(length);\n    for (int i = 2; i <= sqrt_length; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    int length = str.length();\n    if (length <= 1) {\n        return false;\n    }\n    \n    int sqrt_length = sqrt(length);\n    for (int i = 2; i <= sqrt_length; i++) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    int length = str.length();\n    if (length <= 1) {\n        return false;\n    }\n    \n    int sqrt_length = sqrt(length);\n    for (int i = 2; i <= sqrt_length; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N){\n    uint64x1_t num = vdup_n_u64(N);\n    uint8x8_t digits = vcreate_u8(0x0101010101010101);\n    uint8x8_t mask = vdup_n_u8(1);\n    uint8x8_t sum = vdup_n_u8(0);\n\n    for(int i=0; i<64; i++){\n        uint8x8_t digit = vand_u8(vshl_n_u8(num, i), mask);\n        sum = vadd_u8(sum, digit);\n    }\n\n    uint8x8_t result = vpadd_u8(sum, sum);\n    result = vpadd_u8(result, result);\n\n    uint32_t sum_int;\n    vst1_lane_u32(&sum_int, vreinterpret_u32_u8(result), 0);\n\n    std::string binary = std::bitset<32>(sum_int).to_string();\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N){\n    uint64x1_t num = vdup_n_u64(N);\n    uint8x8_t digits = vcreate_u8(0x0101010101010101);\n    uint8x8_t mask = vdup_n_u8(1);\n    uint8x8_t sum = vdup_n_u8(0);\n\n    while(N > 0){\n        uint8x8_t n = vreinterpret_u8_u64(num);\n        uint8x8_t digit = vand_u8(n, mask);\n        sum = vadd_u8(sum, digit);\n        num = vshrq_n_u64(num, 1);\n        N >>= 1;\n    }\n\n    uint8x8_t result = vpadd_u8(sum, sum);\n    result = vpadd_u8(result, result);\n    uint8_t res = vget_lane_u8(result, 0);\n\n    std::string binary;\n    while(res > 0){\n        binary = std::to_string(res % 2) + binary;\n        res /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N){\n    uint64x1_t num = vdup_n_u64(N);\n    uint8x8_t digits = vcreate_u8(0x0101010101010101);\n    uint8x8_t mask = vdup_n_u8(1);\n    \n    uint8x8_t sum = vand_u8(vcnt_u8(vand_u8(vreinterpret_u8_u64(num), digits)), mask);\n    \n    uint64_t result;\n    vst1_u8(reinterpret_cast<uint8_t*>(&result), sum);\n    \n    std::string binary = std::bitset<8>(result).to_string();\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N){\n    uint64x2_t n = vdupq_n_u64(N);\n    uint64x2_t mask = vdupq_n_u64(1);\n    uint64x2_t sum = vdupq_n_u64(0);\n\n    while (vgetq_lane_u64(n, 0) > 0 || vgetq_lane_u64(n, 1) > 0) {\n        uint64x2_t digit = vandq_u64(n, mask);\n        sum = vaddq_u64(sum, digit);\n        n = vshrq_n_u64(n, 1);\n    }\n\n    uint64_t result[2];\n    vst1q_u64(result, sum);\n\n    std::string binary = std::bitset<64>(result[0]).to_string() + std::bitset<64>(result[1]).to_string();\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N){\n    uint64x1_t num = vdup_n_u64(N);\n    uint64x1_t mask = vdup_n_u64(1);\n    uint64x1_t sum = vdup_n_u64(0);\n\n    while (num[0] > 0) {\n        uint64x1_t digit = vand_u64(num, mask);\n        sum = vadd_u64(sum, digit);\n        num = vshrq_n_u64(num, 1);\n    }\n\n    uint64_t result = sum[0];\n    std::string binary;\n    while (result > 0) {\n        binary = std::to_string(result % 2) + binary;\n        result /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int32x4_t vec = vld1q_s32(lst.data());\n    int32x4_t mask = {0, -1, 0, -1};\n    int32x4_t result = vandq_s32(vec, mask);\n    int32x2_t sum_vec = vpadd_s32(vget_low_s32(result), vget_high_s32(result));\n    sum += vget_lane_s32(sum_vec, 0);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n    \n    for (int i = 1; i < lst.size(); i += 2) {\n        int32x4_t velems = vld1q_s32(&lst[i]);\n        vsum = vaddq_s32(vsum, velems);\n    }\n    \n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    \n    vsum_low = vpadd_s32(vsum_low, vsum_low);\n    vsum_high = vpadd_s32(vsum_high, vsum_high);\n    \n    sum = vget_lane_s32(vsum_low, 0) + vget_lane_s32(vsum_high, 0);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        int32x4_t velements = vld1q_s32(&lst[i]);\n        vsum = vaddq_s32(vsum, velements);\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vfinal_sum = vpadd_s32(vsum_low, vsum_high);\n\n    sum = vget_lane_s32(vfinal_sum, 0) + vget_lane_s32(vfinal_sum, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int32x4_t vec = vld1q_s32(lst.data());\n    int32x4_t mask = {0, -1, 0, -1}; // Mask to select elements at odd indices\n    int32x4_t odd_elements = vandq_s32(vec, mask);\n    int32x2_t sum_elements = vpadd_s32(vget_low_s32(odd_elements), vget_high_s32(odd_elements));\n    sum = vget_lane_s32(sum_elements, 0) + vget_lane_s32(sum_elements, 1);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (int i = 1; i < lst.size(); i += 2) {\n        int32x4_t velements = vld1q_s32(&lst[i]);\n        vsum = vaddq_s32(vsum, velements);\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vfinal_sum = vpadd_s32(vsum_low, vsum_high);\n\n    sum = vget_lane_s32(vfinal_sum, 0) + vget_lane_s32(vfinal_sum, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t shift = vdupq_n_u8(2 * 2);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t rotated = vqaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), rotated);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    int length = s.length();\n    \n    uint8x16_t shift = vdupq_n_u8(2 * 2);\n    uint8x16_t mask = vdupq_n_u8(0x1F); // Mask to wrap around the alphabet\n    \n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        uint8x16_t shifted = vaddq_u8(input, shift);\n        uint8x16_t wrapped = vandq_u8(shifted, mask);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), wrapped);\n    }\n    \n    return result;\n}\n```  "}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t shift = vdupq_n_u8(2 * 2);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t rotated = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), rotated);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t shift = vdupq_n_u8(2 * 2);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t rotated = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), rotated);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result = s;\n    uint8x16_t shift = vdupq_n_u8(2 * 2);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t rotated = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), rotated);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F);\n    uint8x16_t vowels_mask = vdupq_n_u8(0x1F);\n    vowels_mask = vsetq_lane_u8(0, vowels_mask, 4); // Set 'a' to 0\n    vowels_mask = vsetq_lane_u8(0, vowels_mask, 8); // Set 'e' to 0\n    vowels_mask = vsetq_lane_u8(0, vowels_mask, 14); // Set 'u' to 0\n    uint8x16_t two_ahead_mask = vdupq_n_u8(2);\n    \n    for (size_t i = 0; i < message.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask);\n        uint8x16_t vowels = vceqq_u8(input, vowels_mask);\n        uint8x16_t vowels_shifted = vaddq_u8(vaddq_u8(vandq_u8(vshlq_n_u8(vowels, 2), vowels), vowels), vowels);\n        uint8x16_t result_lower = vbslq_u8(vowels, vowels_shifted, lowercase);\n        uint8x16_t result_upper = vbslq_u8(vowels, vowels_shifted, vsubq_u8(input, lowercase));\n        \n        result_lower = vorrq_u8(vandq_u8(input, vdupq_n_u8(0x20)), result_lower);\n        result_upper = vorrq_u8(vandq_u8(input, vdupq_n_u8(0x20)), result_upper);\n        \n        result_lower = vandq_u8(result_lower, vdupq_n_u8(0xDF)); // Clear bit 5\n        result_upper = vandq_u8(result_upper, vdupq_n_u8(0xDF)); // Clear bit 5\n        \n        uint8x16_t result_combined = vorrq_u8(result_lower, result_upper);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), result_combined);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert uppercase to lowercase\n    uint8x16_t vowel_mask = vdupq_n_u8(0x1); // Mask to identify vowels\n    uint8x16_t two_ahead_mask = vdupq_n_u8(2); // Mask to calculate letter 2 places ahead\n    uint8x16_t ascii_a_mask = vdupq_n_u8('A'); // Mask for 'A' in ASCII\n    uint8x16_t ascii_z_mask = vdupq_n_u8('Z'); // Mask for 'Z' in ASCII\n\n    for (size_t i = 0; i < message.size(); i += 16) {\n        uint8x16_t input = vreinterpretq_u8_u8(vld1q_u8((uint8_t*)&message[i])); // Load 16 characters\n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask); // Convert uppercase to lowercase\n        uint8x16_t vowels = vceqq_u8(vandq_u8(input, lowercase_mask), vdupq_n_u8('A')) |\n                           vceqq_u8(vandq_u8(input, lowercase_mask), vdupq_n_u8('E')) |\n                           vceqq_u8(vandq_u8(input, lowercase_mask), vdupq_n_u8('I')) |\n                           vceqq_u8(vandq_u8(input, lowercase_mask), vdupq_n_u8('O')) |\n                           vceqq_u8(vandq_u8(input, lowercase_mask), vdupq_n_u8('U')); // Identify vowels\n        uint8x16_t two_ahead = vaddq_u8(lowercase, two_ahead_mask); // Calculate letter 2 places ahead\n        uint8x16_t result_chars = vbslq_u8(vowels, two_ahead, lowercase); // Replace vowels with 2 places ahead\n        uint8x16_t result_uppercase = vandq_u8(result_chars, lowercase_mask); // Convert back to uppercase if needed\n        uint8x16_t result_final = vbicq_u8(result_chars, lowercase_mask) | result_uppercase; // Final result\n        vst1q_u8((uint8_t*)&result[i], vreinterpretq_u8_u8(result_final)); // Store the result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F);\n    uint8x16_t vowel_mask = vdupq_n_u8(0x06);\n    uint8x16_t two_ahead_mask = vdupq_n_u8(0x02);\n    uint8x16_t vowels = vdupq_n_u8(0x05); // Vowels: A, E, I, O, U\n\n    for (size_t i = 0; i < message.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask);\n        uint8x16_t is_vowel = vceqq_u8(input, vowels);\n        uint8x16_t vowel_index = vaddq_u8(lowercase, two_ahead_mask);\n        uint8x16_t result_vowels = vbslq_u8(is_vowel, vowel_index, input);\n        uint8x16_t result_uppercase = vbicq_u8(input, lowercase_mask);\n        uint8x16_t result_lowercase = vorrq_u8(result_uppercase, lowercase);\n        uint8x16_t result_final = vbslq_u8(is_vowel, result_vowels, result_lowercase);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), result_final);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F);\n    uint8x16_t vowel_mask = vdupq_n_u8(0x1F);\n    uint8x16_t vowel_shift = vdupq_n_u8(2);\n    uint8x16_t vowels = vdupq_n_u8(0x55); // 'A', 'E', 'I', 'O', 'U'\n    \n    for (size_t i = 0; i < message.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask);\n        uint8x16_t uppercase = vsubq_u8(input, lowercase);\n        \n        uint8x16_t is_vowel = vqtbl1q_u8(vowels, lowercase);\n        uint8x16_t shifted_vowels = vqaddq_u8(is_vowel, vowel_shift);\n        \n        uint8x16_t encoded_vowels = vbslq_u8(is_vowel, shifted_vowels, lowercase);\n        \n        uint8x16_t result_vec = vbslq_u8(is_vowel, encoded_vowels, uppercase);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint8x16_t lowercase_mask = vdupq_n_u8(0b11011111); // Mask to convert uppercase to lowercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0b00100000); // Mask to convert lowercase to uppercase\n    uint8x16_t vowel_mask = vdupq_n_u8(0b00001000); // Mask to identify vowels\n    uint8x16_t alphabet_offset = vdupq_n_u8(2); // Offset to replace vowels\n\n    for (size_t i = 0; i < message.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Convert uppercase to lowercase\n        uint8x16_t lowercase = vandq_u8(input, lowercase_mask);\n        \n        // Convert lowercase to uppercase\n        uint8x16_t uppercase = vandq_u8(input, uppercase_mask);\n        \n        // Swap case\n        uint8x16_t swapped_case = vorrq_u8(lowercase, uppercase);\n        \n        // Identify vowels\n        uint8x16_t vowels = vandq_u8(swapped_case, vowel_mask);\n        \n        // Replace vowels\n        uint8x16_t replaced_vowels = vaddq_u8(vaddq_u8(vowels, alphabet_offset), alphabet_offset);\n        \n        // Update result\n        uint8x16_t final_result = vbicq_u8(swapped_case, vowel_mask);\n        final_result = vorrq_u8(final_result, replaced_vowels);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if(dict.empty()) return false;\n    \n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert uppercase to lowercase\n    uint8x16_t all_lowercase = vdupq_n_u8(0); // Vector to store lowercase flag\n    uint8x16_t all_uppercase = vdupq_n_u8(0); // Vector to store uppercase flag\n    \n    for(auto& entry : dict){\n        const std::string& key = entry.first;\n        if(key.empty()) continue;\n        \n        uint8_t first_char = key[0];\n        uint8x16_t key_vector = vdupq_n_u8(first_char);\n        \n        uint8x16_t lowercase_check = vcleq_u8(key_vector, vdupq_n_u8('z'));\n        uint8x16_t uppercase_check = vcgeq_u8(key_vector, vdupq_n_u8('A'));\n        \n        lowercase_check = vandq_u8(lowercase_check, vcleq_u8(key_vector, vdupq_n_u8('a')));\n        uppercase_check = vandq_u8(uppercase_check, vcgeq_u8(key_vector, vdupq_n_u8('Z')));\n        \n        lowercase_check = vandq_u8(lowercase_check, vcleq_u8(key_vector, vdupq_n_u8('z')));\n        uppercase_check = vandq_u8(uppercase_check, vcgeq_u8(key_vector, vdupq_n_u8('A')));\n        \n        uint8x16_t key_lowercase = vandq_u8(lowercase_check, vandq_u8(vceqq_u8(key_vector, vandq_u8(key_vector, lowercase_mask)), vceqq_u8(key_vector, vdupq_n_u8(first_char))));\n        uint8x16_t key_uppercase = vandq_u8(uppercase_check, vceqq_u8(key_vector, vandq_u8(key_vector, lowercase_mask)));\n        \n        all_lowercase = vorrq_u8(all_lowercase, key_lowercase);\n        all_uppercase = vorrq_u8(all_uppercase, key_uppercase);\n    }\n    \n    uint8x16_t all_lowercase_result = vandq_u8(all_lowercase, vmvnq_u8(all_uppercase));\n    uint8x16_t all_uppercase_result = vandq_u8(all_uppercase, vmvnq_u8(all_lowercase));\n    \n    uint8x8_t result = vpadd_u8(vget_low_u8(all_lowercase_result), vget_high_u8(all_lowercase_result));\n    result = vpadd_u8(result, result);\n    \n    return vget_lane_u8(result, 0) == 255 || vget_lane_u8(result, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if(dict.empty()) return false;\n    \n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert characters to lowercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0xDF); // Mask to convert characters to uppercase\n    \n    bool all_lowercase = true;\n    bool all_uppercase = true;\n    \n    for(auto& entry : dict){\n        std::string key = entry.first;\n        \n        uint8_t key_chars[16] = {0};\n        std::memcpy(key_chars, key.c_str(), std::min(key.size(), static_cast<size_t>(16)));\n        \n        uint8x16_t key_vec = vld1q_u8(key_chars);\n        \n        uint8x16_t lowercase_result = vandq_u8(key_vec, lowercase_mask);\n        uint8x16_t uppercase_result = vandq_u8(key_vec, uppercase_mask);\n        \n        uint8x16_t lowercase_check = vceqq_u8(key_vec, lowercase_result);\n        uint8x16_t uppercase_check = vceqq_u8(key_vec, uppercase_result);\n        \n        all_lowercase &= vgetq_lane_u8(vreinterpretq_u8_u16(vmovl_u8(vminvq_u8(lowercase_check))), 0);\n        all_uppercase &= vgetq_lane_u8(vreinterpretq_u8_u16(vmovl_u8(vminvq_u8(uppercase_check))), 0);\n    }\n    \n    return all_lowercase || all_uppercase;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if(dict.empty()) return false;\n    \n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert characters to lowercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0x5F); // Mask to convert characters to uppercase\n    uint8x16_t all_lowercase = vdupq_n_u8(0xFF); // Mask to check if all characters are lowercase\n    uint8x16_t all_uppercase = vdupq_n_u8(0x00); // Mask to check if all characters are uppercase\n    \n    for(auto it = dict.begin(); it != dict.end(); ++it){\n        const std::string& key = it->first;\n        uint8_t* key_ptr = reinterpret_cast<uint8_t*>(const_cast<char*>(key.c_str()));\n        size_t key_length = key.length();\n        \n        for(size_t i = 0; i < key_length; i += 16){\n            uint8x16_t key_chars = vld1q_u8(key_ptr + i);\n            uint8x16_t lowercase_result = vandq_u8(vcgeq_u8(key_chars, vdupq_n_u8('a')), vcleq_u8(key_chars, vdupq_n_u8('z')));\n            uint8x16_t uppercase_result = vandq_u8(vcgeq_u8(key_chars, vdupq_n_u8('A')), vcleq_u8(key_chars, vdupq_n_u8('Z')));\n            \n            all_lowercase = vandq_u8(all_lowercase, lowercase_result);\n            all_uppercase = vorrq_u8(all_uppercase, uppercase_result);\n        }\n    }\n    \n    return vceqq_u8(all_lowercase, vdupq_n_u8(0xFF)) || vceqq_u8(all_uppercase, vdupq_n_u8(0xFF));\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if(dict.empty()) return false;\n\n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert uppercase to lowercase\n    uint8x16_t all_lowercase = vdupq_n_u8(0); // Vector to track lowercase keys\n    uint8x16_t all_uppercase = vdupq_n_u8(0); // Vector to track uppercase keys\n\n    for(auto const& entry : dict){\n        std::string key = entry.first;\n        if(key.empty()) continue;\n\n        uint8x16_t key_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str()));\n        uint8x16_t key_lower = vandq_u8(key_vec, lowercase_mask);\n        uint8x16_t key_upper = vbicq_u8(key_vec, lowercase_mask);\n\n        all_lowercase = vorrq_u8(all_lowercase, key_lower);\n        all_uppercase = vorrq_u8(all_uppercase, key_upper);\n    }\n\n    uint8x16_t lowercase_result = vceqq_u8(all_lowercase, vdupq_n_u8(0));\n    uint8x16_t uppercase_result = vceqq_u8(all_uppercase, vdupq_n_u8(0));\n\n    uint8x16_t final_result = vandq_u8(lowercase_result, uppercase_result);\n    return vgetq_lane_u8(final_result, 0) != 0;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if(dict.empty()) return false;\n    \n    uint8x16_t lowercase_mask = vdupq_n_u8(0x1F); // Mask to convert characters to lowercase\n    uint8x16_t uppercase_mask = vdupq_n_u8(0x5F); // Mask to convert characters to uppercase\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for(auto const& entry : dict){\n        std::string key = entry.first;\n        \n        for(int i = 0; i < key.size(); i += 16){\n            uint8x16_t key_chars = vld1q_u8((uint8_t*)(key.data() + i));\n            uint8x16_t lowercase = vandq_u8(key_chars, lowercase_mask);\n            uint8x16_t uppercase = vandq_u8(key_chars, uppercase_mask);\n            \n            uint8x16_t lower_compare = vceqq_u8(key_chars, lowercase);\n            uint8x16_t upper_compare = vceqq_u8(key_chars, uppercase);\n            \n            all_lower &= vaddvq_u8(lower_compare);\n            all_upper &= vaddvq_u8(upper_compare);\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    uint32x4_t sieve = vdupq_n_u32(0xFFFFFFFF);\n    vst1q_lane_u32(&sieve[0], vdupq_n_u32(0xFFFFFFFE), 0);\n\n    for (int i = 2; i < n; ++i) {\n        if (sieve[i / 32] & (1 << (i % 32))) {\n            primes.push_back(i);\n            for (int j = i * 2; j < n; j += i) {\n                sieve[j / 32] &= ~(1 << (j % 32));\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> result;\n    if(n < 2) return result;\n\n    uint32x4_t primes = {2, 3, 5, 7};\n    uint32x4_t increment = {30, 30, 30, 30};\n    uint32x4_t current = primes;\n\n    for(uint32_t i = 11; i < n; i += 30){\n        uint32x4_t mask = vcltq_u32(current, vdupq_n_u32(n));\n        uint32x4_t next = vaddq_u32(current, increment);\n        uint32x4_t is_prime = vandq_u32(mask, mask);\n        current = vaddq_u32(current, increment);\n\n        if(vgetq_lane_u32(is_prime, 0)){\n            result.push_back(vgetq_lane_u32(current, 0));\n        }\n        if(vgetq_lane_u32(is_prime, 1)){\n            result.push_back(vgetq_lane_u32(current, 1));\n        }\n        if(vgetq_lane_u32(is_prime, 2)){\n            result.push_back(vgetq_lane_u32(current, 2));\n        }\n        if(vgetq_lane_u32(is_prime, 3)){\n            result.push_back(vgetq_lane_u32(current, 3));\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> result;\n    if (n < 2) {\n        return result;\n    }\n\n    std::vector<int> primes;\n    primes.push_back(2);\n\n    for (int i = 3; i < n; i += 2) {\n        int is_prime = 1;\n        for (int j = 0; j < primes.size(); ++j) {\n            if (i % primes[j] == 0) {\n                is_prime = 0;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> result;\n    if(n < 2) return result;\n\n    uint32x4_t primes = {2, 3, 5, 7};\n    uint32x4_t increment = {30, 30, 30, 30};\n    uint32x4_t current = {11, 13, 17, 19};\n\n    for(uint32_t i = 20; i < n; i+=30){\n        uint32x4_t is_prime = {1, 1, 1, 1};\n\n        for(uint32_t j = 0; j < 4; j++){\n            uint32x4_t divisors = vdupq_n_u32(2);\n            uint32x4_t limit = vdupq_n_u32((uint32_t)sqrt(i+j));\n\n            uint32x4_t k = {11, 13, 17, 19};\n            uint32x4_t not_prime = vdupq_n_u32(0);\n\n            while(vgetq_lane_u32(k, 0) <= vgetq_lane(limit, 0)){\n                not_prime = vorrq_u32(not_prime, vceqq_u32(vdupq_n_u32(0), vandq_u32(vceqq_u32(vdupq_n_u32(0), vshrq_n_u32(vdupq_n_u32(i+j), 1)), vceqq_u32(vdupq_n_u32(0), vshrq_n_u32(vdupq_n_u32(i+j), vgetq_lane_u32(k, 0))))));\n                k = vaddq_u32(k, increment);\n            }\n\n            is_prime = vandq_u32(is_prime, vmvnq_u32(not_prime));\n        }\n\n        uint32x4_t mask = vandq_u32(is_prime, vcltq_u32(current, vdupq_n_u32(n)));\n        uint32x4_t new_primes = vbslq_u32(mask, current, vdupq_n_u32(0));\n        primes = vbslq_u32(mask, new_primes, primes);\n        current = vaddq_u32(current, increment);\n    }\n\n    for(uint32_t i = 0; i < 4; i++){\n        if(vgetq_lane_u32(primes, i) < n){\n            result.push_back(vgetq_lane_u32(primes, i));\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> result;\n    if (n < 2) return result;\n\n    uint32x4_t primes = {2, 3, 5, 7};\n    uint32x4_t increment = {30, 30, 30, 30};\n    uint32x4_t current = {11, 13, 17, 19};\n\n    for (uint32_t i = 20; i < n; i += 30) {\n        uint32x4_t is_prime = {1, 1, 1, 1};\n\n        uint32x4_t divisors = vdupq_n_u32(2);\n        uint32x4_t max_divisors = vdupq_n_u32(4);\n\n        uint32x4_t mask = vcltq_u32(current, vdupq_n_u32(i));\n\n        for (uint32_t j = 2; j < 5; ++j) {\n            uint32x4_t mod = vdupq_n_u32(j);\n            uint32x4_t rem = vdupq_n_u32(0);\n\n            rem = vaddq_u32(rem, vandq_u32(vceqq_u32(vdupq_n_u32(0), vandq_u32(vdupq_n_u32(i), mod)), vdupq_n_u32(1)));\n            rem = vaddq_u32(rem, vandq_u32(vceqq_u32(vdupq_n_u32(0), vandq_u32(vdupq_n_u32(i), vaddq_u32(mod, vdupq_n_u32(1)))), vdupq_n_u32(1)));\n            rem = vaddq_u32(rem, vandq_u32(vceqq_u32(vdupq_n_u32(0), vandq_u32(vdupq_n_u32(i), vaddq_u32(mod, vdupq_n_u32(2)))), vdupq_n_u32(1)));\n            rem = vaddq_u32(rem, vandq_u32(vceqq_u32(vdupq_n_u32(0), vandq_u32(vdupq_n_u32(i), vaddq_u32(mod, vdupq_n_u32(3)))), vdupq_n_u32(1)));\n\n            is_prime = vandq_u32(is_prime, vceqq_u32(rem, vdupq_n_u32(4)));\n        }\n\n        is_prime = vandq_u32(is_prime, mask);\n        is_prime = vandq_u32(is_prime, vcltq_u32(current, vdupq_n_u32(n)));\n\n        uint32x4_t indices = vaddq_u32(vandq_u32(is_prime, divisors), vandq_u32(vmvnq_u32(is_prime), max_divisors));\n        uint32x4_t selected_primes = vqtbl1q_u32(primes, indices);\n\n        for (int k = 0; k < 4; ++k) {\n            if (current[k] < n && is_prime[k]) {\n                result.push_back(current[k]);\n            }\n        }\n\n        current = vaddq_u32(current, increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_s8(vceqq_u8(vreinterpretq_s8_u8(vdupq_n_u8('A')), vreinterpretq_s8_u8(vdupq_n_u8('E'))));\n    vowels = vandq_u8(vowels, vreinterpretq_u8_s8(vceqq_u8(vreinterpretq_s8_u8(vdupq_n_u8('I')), vreinterpretq_s8_u8(vdupq_n_u8('U'))));\n    \n    for (int i = 0; i < s.size(); i += 16) {\n        uint8x16_t str = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t mask = vdupq_n_u8(0);\n        mask = vbslq_u8(vceqq_u8(vandq_u8(str, vdupq_n_u8(0x20)), vdupq_n_u8(0x40)), vdupq_n_u8(1), mask);\n        mask = vandq_u8(mask, vdupq_n_u8(0xAA));\n        mask = vandq_u8(mask, vceqq_u8(vandq_u8(str, vdupq_n_u8(0xDF)), str));\n        mask = vandq_u8(mask, vowels);\n        count += vaddvq_u8(mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_s8(vceqq_u8(vreinterpretq_u8_s8(vdupq_n_s8('A')), vreinterpretq_u8_s8(vdupq_n_s8('E')));\n    uint8x16_t mask = vdupq_n_u8(0x55); // Mask to select even indices\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upper = vandq_u8(vceqq_u8(vandq_u8(input, mask), mask), vandq_u8(vcgeq_u8(input, vdupq_n_u8('A')), vcleq_u8(input, vdupq_n_u8('Z'))));\n        count += vaddvq_u8(vandq_u8(upper, vowels));\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_s8(vceqq_u8(vreinterpretq_u8_s8(vdupq_n_s8('A')), vreinterpretq_u8_s8(vdupq_n_s8('E')));\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t str = vld1q_u8((const uint8_t*)(s.data() + i));\n        uint8x16_t mask = vandq_u8(vceqq_u8(vandq_u8(str, vdupq_n_u8(0x20)), vdupq_n_u8(0x40)), vdupq_n_u8(0x40));\n        count += vaddvq_u8(vandq_u8(mask, vowels));\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_u64(vdupq_n_u64(0x00000000000000AE)); // 'AE' in ASCII\n    for (int i = 0; i < s.size(); i += 16) {\n        uint8x16_t str = vreinterpretq_u8_u64(vld1q_u64((const uint64_t*)(s.data() + i)));\n        uint8x16_t uppercase = vandq_u8(str, vdupq_n_u8(0xDF)); // Convert lowercase to uppercase\n        uint8x16_t is_vowel = vandq_u8(uppercase, vowels);\n        uint8x16_t even_indices = vdupq_n_u8(0x55); // Mask for even indices\n        uint8x16_t even_vowels = vandq_u8(is_vowel, even_indices);\n        count += vaddvq_u8(even_vowels);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    uint8x16_t vowels = vreinterpretq_u8_s8(vceqq_u8(vreinterpretq_u8_s8(vdupq_n_s8('A')), vreinterpretq_u8_s8(vdupq_n_s8('E')));\n    uint8x16_t mask = vdupq_n_u8(0x55); // Mask for even indices\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t str = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upper = vandq_u8(vceqq_u8(vandq_u8(str, mask), mask), vceqq_u8(vandq_u8(str, vowels), vowels));\n        count += vaddvq_u8(upper);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t stones = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&result[i], stones);\n        stones = vaddq_s32(stones, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t stones = vmovq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&result[i], stones);\n        stones = vaddq_s32(stones, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t stones = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&result[i], stones);\n        stones = vaddq_s32(stones, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t stones = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&result[i], stones);\n        stones = vaddq_s32(stones, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    int base = n;\n    int step = 1;\n    for (int i = 0; i < n; ++i) {\n        result[i] = base;\n        base += step;\n        step = (n % 2 == 0) ? 2 : 1;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    int64x2_t sum_v = vdupq_n_s64(0);\n\n    for(int64_t i = n; i <= m; i += 2) {\n        int64x2_t values = {i, i+1};\n        sum_v = vaddq_s64(sum_v, values);\n    }\n\n    int64x2_t avg_v = vrshrq_n_s64(sum_v, 1);\n    int64x2_t rounded_avg_v = vshrq_n_s64(avg_v, 1);\n\n    int64_t rounded_avg[2];\n    vst1q_s64(rounded_avg, rounded_avg_v);\n\n    std::string result = \"\";\n    for(int i = 1; i >= 0; i--) {\n        result += std::to_string(rounded_avg[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    int64x2_t sum_v = vdupq_n_s64(0);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t values = {i, i + 1};\n        sum_v = vaddq_s64(sum_v, values);\n    }\n\n    int64x2_t avg_v = vrshrq_n_s64(sum_v, 1);\n    int64x2_t rounded_avg_v = vshrn_n_s64(avg_v, 0);\n\n    int64_t rounded_avg[2];\n    vst1q_s64(rounded_avg, rounded_avg_v);\n\n    std::string result = \"\";\n    for (int i = 1; i >= 0; i--) {\n        result += std::to_string(rounded_avg[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m) {\n        return \"-1\";\n    }\n    \n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    int64x2_t vsum = vdupq_n_s64(0);\n    int64x2_t vcount = vdupq_n_s64(count);\n    \n    for(int64_t i = n; i <= m; i += 2) {\n        int64x2_t v = {i, i+1};\n        vsum = vaddq_s64(vsum, v);\n    }\n    \n    int64x2_t vavg = vqrdmulhq_s64(vsum, vcount);\n    int64x2_t vrounded = vrshrq_n_s64(vavg, 1);\n    \n    int64_t rounded[2];\n    vst1q_s64(rounded, vrounded);\n    \n    std::string result = \"\";\n    for(int i = 0; i < 2; i++) {\n        result += std::to_string(rounded[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t vsum = vdupq_n_s64(0);\n    int64x2_t vcount = vdupq_n_s64(count);\n\n    for(int64_t i = n; i <= m; i += 2) {\n        int64x2_t v = {i, i + 1};\n        vsum = vaddq_s64(vsum, v);\n    }\n\n    int64x2_t vavg = vrshrq_n_s64(vsum, 1);\n    int64x2_t vrounded_avg = vqmovn_s64(vavg);\n\n    int64_t rounded_avg[2];\n    vst1_s64(rounded_avg, vrounded_avg);\n\n    std::string result = std::bitset<64>(rounded_avg[0]).to_string().substr(64 - count, count);\n    if(count == 2) {\n        result += std::bitset<64>(rounded_avg[1]).to_string().substr(64 - count, count);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    int64x2_t vsum = vdupq_n_s64(0);\n\n    for(int64_t i = n; i <= m; i += 2) {\n        int64x2_t v = {i, i+1};\n        vsum = vaddq_s64(vsum, v);\n    }\n\n    int64_t temp[2];\n    vst1q_s64(temp, vsum);\n    sum = temp[0] + temp[1];\n\n    int64_t avg = sum / count;\n    std::string binary = std::bitset<64>(avg).to_string();\n    return binary.substr(binary.find('1'));\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    uint32x4_t factorial = vdupq_n_u32(1);\n    uint32x4_t sum = vdupq_n_u32(0);\n    \n    for (int i = 1; i <= n; i += 4) {\n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t is_even = vandq_u32(indices, vdupq_n_u32(1));\n        uint32x4_t factorials = vmulq_u32(factorial, indices);\n        uint32x4_t sums = vaddq_u32(sum, indices);\n        \n        uint32x4_t even_mask = vceqq_u32(is_even, vdupq_n_u32(0));\n        uint32x4_t result_values = vbslq_u32(even_mask, factorials, sums);\n        \n        vst1q_u32(&result[i-1], result_values);\n        \n        factorial = factorials;\n        sum = sums;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t factorial = vdupq_n_s32(1);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask = vcltq_s32(indices, vdupq_n_s32(n + 1));\n\n        int32x4_t factorial_masked = vandq_s32(factorial, vreinterpretq_s32_u32(mask));\n        int32x4_t sum_masked = vandq_s32(sum, vmvnq_u32(mask));\n\n        for (int j = 0; j < 4; j++) {\n            if (i + j <= n) {\n                factorial_masked = vmulq_s32(factorial_masked, vaddq_s32(vdupq_n_s32(1), vdupq_n_s32(j)));\n                sum_masked = vaddq_s32(sum_masked, vdupq_n_s32(i + j));\n            }\n        }\n\n        factorial = vbslq_s32(mask, factorial_masked, factorial);\n        sum = vbslq_s32(mask, sum_masked, sum);\n\n        vst1q_s32(&result[i - 1], vaddq_s32(factorial, sum));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t factorial = vdupq_n_s32(1);\n    \n    for(int i = 1; i <= n; i+=4){\n        int32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t mask = vcltq_s32(indices, vdupq_n_s32(n+1));\n        \n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n        \n        for(int j = 1; j <= 4; j++){\n            factorials = vmulq_s32(factorials, indices);\n            sums = vaddq_s32(sums, indices);\n            indices = vaddq_s32(indices, vdupq_n_s32(4));\n        }\n        \n        factorial = vbslq_s32(mask, factorials, factorial);\n        sum = vbslq_s32(mask, sums, sum);\n        \n        vst1q_s32(&result[i-1], sum);\n        vst1q_s32(&result[i], factorial);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t factorial = vdupq_n_s32(1);\n    \n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t mask = vcltq_s32(indices, vdupq_n_s32(n+1));\n        \n        int32x4_t factorial_masked = vandq_s32(factorial, vreinterpretq_s32_u32(mask));\n        int32x4_t sum_masked = vandq_s32(sum, vmvnq_u32(mask));\n        \n        for (int j = 1; j <= 4; ++j) {\n            factorial_masked = vmulq_s32(factorial_masked, vdupq_n_s32(j));\n            sum_masked = vaddq_s32(sum_masked, vdupq_n_s32(j));\n        }\n        \n        factorial = vbslq_s32(mask, factorial_masked, factorial);\n        sum = vbslq_s32(mask, sum_masked, sum);\n        \n        vst1q_s32(&result[i-1], vaddq_s32(factorial, sum));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t fact = vdupq_n_s32(1);\n    \n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask = vcltq_s32(indices, vdupq_n_s32(n + 1));\n        \n        int32x4_t factorial_mask = vandq_s32(mask, vceqq_s32(vshrq_n_s32(indices, 1), vdupq_n_s32(0)));\n        int32x4_t sum_mask = vmvnq_u32(factorial_mask);\n        \n        for (int j = 1; j <= 4; ++j) {\n            int32x4_t fact_mul = vmulq_s32(fact, indices);\n            fact = vbslq_s32(factorial_mask, fact_mul, fact);\n            \n            int32x4_t sum_add = vaddq_s32(sum, indices);\n            sum = vbslq_s32(sum_mask, sum_add, sum);\n            \n            indices = vaddq_s32(indices, vdupq_n_s32(4));\n            mask = vcltq_s32(indices, vdupq_n_s32(n + 1));\n            \n            factorial_mask = vandq_s32(mask, vceqq_s32(vshrq_n_s32(indices, 1), vdupq_n_s32(0)));\n            sum_mask = vmvnq_u32(factorial_mask);\n        }\n    }\n    \n    int32x4_t result_lane0 = vbslq_s32(vcltq_s32(vdupq_n_s32(n), vdupq_n_s32(1)), sum, fact);\n    int32x2_t result_lane01 = vget_low_s32(result_lane0);\n    int32x2_t result_lane23 = vget_high_s32(result_lane0);\n    \n    result[0] = vget_lane_s32(result_lane01, 0);\n    result[1] = vget_lane_s32(result_lane01, 1);\n    result[2] = vget_lane_s32(result_lane23, 0);\n    result[3] = vget_lane_s32(result_lane23, 1);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n){\n    uint8x16_t even_count = vdupq_n_u8(0);\n    uint8x16_t odd_count = vdupq_n_u8(0);\n\n    for (int i = 1; i <= n; ++i) {\n        int rev = 0, temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == i) {\n            if (i % 2 == 0) {\n                even_count = vaddq_u8(even_count, vdupq_n_u8(1));\n            } else {\n                odd_count = vaddq_u8(odd_count, vdupq_n_u8(1));\n            }\n        }\n    }\n\n    uint8x8_t even_count_low = vget_low_u8(even_count);\n    uint8x8_t even_count_high = vget_high_u8(even_count);\n    uint8x8_t odd_count_low = vget_low_u8(odd_count);\n    uint8x8_t odd_count_high = vget_high_u8(odd_count);\n\n    uint8x8_t even_count_sum = vpadd_u8(even_count_low, even_count_high);\n    uint8x8_t odd_count_sum = vpadd_u8(odd_count_low, odd_count_high);\n\n    std::vector<int> result(2);\n    result[0] = vget_lane_u8(even_count_sum, 0) + vget_lane_u8(even_count_sum, 1);\n    result[1] = vget_lane_u8(odd_count_sum, 0) + vget_lane_u8(odd_count_sum, 1);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n){\n    uint32x4_t even_count = vdupq_n_u32(0);\n    uint32x4_t odd_count = vdupq_n_u32(0);\n    \n    for (int i = 1; i <= n; ++i) {\n        int rev = 0;\n        int temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == i) {\n            if (i % 2 == 0) {\n                even_count = vaddq_u32(even_count, vdupq_n_u32(1));\n            } else {\n                odd_count = vaddq_u32(odd_count, vdupq_n_u32(1));\n            }\n        }\n    }\n    \n    uint32_t even_result[4];\n    uint32_t odd_result[4];\n    vst1q_u32(even_result, even_count);\n    vst1q_u32(odd_result, odd_count);\n    \n    return {even_result[0], odd_result[0]};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n){\n    uint32x4_t even_count = vdupq_n_u32(0);\n    uint32x4_t odd_count = vdupq_n_u32(0);\n    \n    for (int i = 1; i <= n; ++i) {\n        int rev = 0, temp = i;\n        while (temp != 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        \n        if (rev == i) {\n            if (i % 2 == 0) {\n                even_count = vaddq_u32(even_count, vdupq_n_u32(1));\n            } else {\n                odd_count = vaddq_u32(odd_count, vdupq_n_u32(1));\n            }\n        }\n    }\n    \n    uint32_t even_result[4];\n    uint32_t odd_result[4];\n    vst1q_u32(even_result, even_count);\n    vst1q_u32(odd_result, odd_count);\n    \n    return {even_result[0], odd_result[0]};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n){\n    uint32x4_t even_count = vdupq_n_u32(0);\n    uint32x4_t odd_count = vdupq_n_u32(0);\n\n    for (int i = 1; i <= n; ++i) {\n        int rev = 0, temp = i;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == i) {\n            if (i % 2 == 0) {\n                even_count = vaddq_u32(even_count, vdupq_n_u32(1));\n            } else {\n                odd_count = vaddq_u32(odd_count, vdupq_n_u32(1));\n            }\n        }\n    }\n\n    uint32_t even_result[4];\n    uint32_t odd_result[4];\n    vst1q_u32(even_result, even_count);\n    vst1q_u32(odd_result, odd_count);\n\n    return {even_result[0], odd_result[0]};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n){\n    std::vector<int> result(2, 0);\n    \n    uint8x16_t digits, reversed;\n    uint8x16_t mask = vdupq_n_u8(0x0F);\n    uint8x16_t cmp_mask = vdupq_n_u8(0x08);\n    uint8x16_t even_count = vdupq_n_u8(0);\n    uint8x16_t odd_count = vdupq_n_u8(0);\n    \n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        digits = vdupq_n_u8(0);\n        for (int j = 0; j < 3; ++j) {\n            uint8x16_t digit = vdupq_n_u8(temp % 10);\n            digits = vsetq_lane_u8(temp % 10, digits, j);\n            temp /= 10;\n        }\n        \n        reversed = vrev64q_u8(digits);\n        reversed = vandq_u8(reversed, mask);\n        \n        uint8x16_t cmp_result = vceqq_u8(reversed, cmp_mask);\n        uint8x16_t even_mask = vandq_u8(cmp_result, vdupq_n_u8(0x01));\n        uint8x16_t odd_mask = vandq_u8(cmp_result, vdupq_n_u8(0x00));\n        \n        even_count = vaddq_u8(even_count, even_mask);\n        odd_count = vaddq_u8(odd_count, odd_mask);\n    }\n    \n    uint8x8_t even_count_low = vpadd_u8(vget_low_u8(even_count), vget_high_u8(even_count));\n    uint8x8_t odd_count_low = vpadd_u8(vget_low_u8(odd_count), vget_high_u8(odd_count));\n    \n    result[0] = vget_lane_u8(even_count_low, 0) + vget_lane_u8(even_count_low, 1);\n    result[1] = vget_lane_u8(odd_count_low, 0) + vget_lane_u8(odd_count_low, 1);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    int32x4_t sum_digits = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < n.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sum_abs_digits = vaddq_s32(vaddq_s32(vdupq_n_s32(0), vget_low_s32(abs_vec)), vget_high_s32(abs_vec));\n\n        uint32x4_t mask = vreinterpretq_u32_s32(vcltq_s32(sum_abs_digits, vdupq_n_s32(1)));\n        uint32x2_t mask_low = vget_low_u32(mask);\n        uint32x2_t mask_high = vget_high_u32(mask);\n        uint64x2_t mask_combined = vmovl_u32(mask_low);\n        mask_combined = vaddq_u64(mask_combined, vmovl_u32(mask_high));\n\n        count += vgetq_lane_u64(mask_combined, 0) + vgetq_lane_u64(mask_combined, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    int32x4_t sum_digits = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < n.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&n[i]);\n\n        int32x4_t abs_input = vabsq_s32(input);\n        int32x4_t tens = vdupq_n_s32(10);\n        int32x4_t sum = vdupq_n_s32(0);\n\n        for (int j = 0; j < 10; j++) {\n            int32x4_t digit = vdupq_n_s32(j);\n            int32x4_t cmp = vcltq_s32(abs_input, tens);\n            sum = vaddq_s32(sum, vandq_s32(cmp, digit));\n            tens = vmulq_n_s32(tens, 10);\n        }\n\n        sum_digits = vaddq_s32(sum_digits, sum);\n    }\n\n    int32x2_t sum_digits_low = vget_low_s32(sum_digits);\n    int32x2_t sum_digits_high = vget_high_s32(sum_digits);\n    int32x2_t sum_digits_total = vpadd_s32(sum_digits_low, sum_digits_high);\n\n    count += vget_lane_s32(sum_digits_total, 0);\n    count += vget_lane_s32(sum_digits_total, 1);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    int32x4_t sum_digits = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < n.size(); i += 4) {\n        int32x4_t input = vld1q_s32(&n[i]);\n        int32x4_t abs_input = vabsq_s32(input);\n\n        int32x4_t digit1 = vdupq_n_s32(0);\n        int32x4_t digit2 = vdupq_n_s32(0);\n        int32x4_t digit3 = vdupq_n_s32(0);\n\n        digit1 = vsubq_s32(vshrq_n_s32(abs_input, 0), vmulq_n_s32(vshrq_n_s32(abs_input, 1), 10));\n        digit2 = vsubq_s32(vshrq_n_s32(abs_input, 1), vmulq_n_s32(vshrq_n_s32(abs_input, 2), 10));\n        digit3 = vsubq_s32(vshrq_n_s32(abs_input, 2), vmulq_n_s32(vshrq_n_s32(abs_input, 3), 10));\n\n        int32x4_t sum_digits_mask = vaddq_s32(vaddq_s32(digit1, digit2), digit3);\n        sum_digits = vaddq_s32(sum_digits, vandq_s32(vdupq_n_s32(1), vceqq_s32(sum_digits_mask, vdupq_n_s32(0))));\n    }\n\n    int32x2_t sum_digits_low = vget_low_s32(sum_digits);\n    int32x2_t sum_digits_high = vget_high_s32(sum_digits);\n    int32x2_t sum_digits_total = vpadd_s32(sum_digits_low, sum_digits_high);\n    count = vget_lane_s32(sum_digits_total, 0) + vget_lane_s32(sum_digits_total, 1);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    uint8x16_t all_zeros = vdupq_n_u8(0);\n    \n    for (int i = 0; i < n.size(); i += 16) {\n        uint8x16_t sum_digits = all_zeros;\n        \n        for (int j = 0; j < 16; j++) {\n            if (i + j < n.size()) {\n                int num = n[i + j];\n                int sum = 0;\n                \n                while (num != 0) {\n                    sum += abs(num % 10);\n                    num /= 10;\n                }\n                \n                sum_digits[j] = sum > 0 ? 1 : 0;\n            }\n        }\n        \n        uint8x16_t cmp = vcleq_u8(sum_digits, all_zeros);\n        count += vaddvq_u8(cmp);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    uint8x16_t zero = vdupq_n_u8(0);\n    \n    for (int i = 0; i < n.size(); i += 16) {\n        uint8x16_t sum_digits = vdupq_n_u8(0);\n        \n        for (int j = 0; j < 16; j++) {\n            if (i + j < n.size()) {\n                int num = n[i + j];\n                int abs_num = abs(num);\n                \n                while (abs_num > 0) {\n                    int digit = abs_num % 10;\n                    sum_digits = vaddq_u8(sum_digits, vdupq_n_u8(digit));\n                    abs_num /= 10;\n                }\n                \n                if (num < 0) {\n                    sum_digits = vsubq_u8(sum_digits, vdupq_n_u8(1));\n                }\n            }\n        }\n        \n        uint8x16_t cmp = vcgtq_u8(sum_digits, zero);\n        count += vaddvq_u8(cmp);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```\nbool move_one_ball_simd(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    \n    int N = arr.size();\n    int min_val = *std::min_element(arr.begin(), arr.end());\n    int max_val = *std::max_element(arr.begin(), arr.end());\n    \n    if(min_val == arr[0] && max_val == arr[N-1]){\n        return true;\n    }\n    \n    int32x4_t vec = vld1q_s32(arr.data());\n    int32x4_t sorted_vec = vdupq_n_s32(min_val);\n    \n    for(int i=0; i<N; i++){\n        if(vceqq_s32(vec, sorted_vec)){\n            return true;\n        }\n        vec = vextq_s32(vec, vec, 1);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    \n    int N = arr.size();\n    int32x4_t vec = vld1q_s32(arr.data());\n    \n    for(int i=0; i<N-1; i++){\n        int32x4_t shifted_vec = vextq_s32(vec, vec, 1);\n        uint32x4_t cmp = vcleq_s32(vec, shifted_vec);\n        uint32x2_t cmp_low = vget_low_u32(cmp);\n        uint32x2_t cmp_high = vget_high_u32(cmp);\n        uint32x2_t result = vpmin_u32(cmp_low, cmp_high);\n        if(vget_lane_u32(result, 0) == 0){\n            return false;\n        }\n        vec = shifted_vec;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```\nbool move_one_ball_simd(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    \n    int N = arr.size();\n    int max_val = *std::max_element(arr.begin(), arr.end());\n    \n    uint32x4_t max_val_v = vdupq_n_u32(max_val);\n    uint32x4_t sorted_v = vld1q_u32((const uint32_t*)arr.data());\n    \n    for(int i = 0; i < N; i++){\n        uint32x4_t shifted_v = vextq_u32(sorted_v, sorted_v, 1);\n        uint32x4_t cmp_result = vcleq_u32(sorted_v, shifted_v);\n        uint32x4_t max_cmp = vcleq_u32(sorted_v, max_val_v);\n        uint32x4_t final_cmp = vandq_u32(cmp_result, max_cmp);\n        \n        uint32_t result[4];\n        vst1q_u32(result, final_cmp);\n        \n        if(result[0] == 0 && result[1] == 0 && result[2] == 0 && result[3] == 0){\n            return false;\n        }\n        \n        sorted_v = shifted_v;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```\nbool move_one_ball_simd(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    \n    int N = arr.size();\n    int max_val = *std::max_element(arr.begin(), arr.end());\n    \n    uint32x4_t mask = vdupq_n_u32(max_val);\n    \n    for(int i=0; i<N; i+=4){\n        uint32x4_t vec = vld1q_u32(reinterpret_cast<uint32_t*>(&arr[i]));\n        uint32x4_t cmp = vceqq_u32(vec, mask);\n        uint32x4_t result = vandq_u32(cmp, vshrq_n_u32(cmp, 1));\n        uint32x2_t res = vpadd_u32(vget_low_u32(result), vget_high_u32(result));\n        if(vget_lane_u32(res, 0) != 0){\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    if(arr.empty()){\n        return true;\n    }\n    \n    int N = arr.size();\n    int32x4_t vec = vld1q_s32(arr.data());\n    int32x4_t sorted_vec = vld1q_s32(arr.data());\n    sorted_vec = vsetq_lane_s32(INT_MIN, sorted_vec, 3);\n    sorted_vec = vextq_s32(sorted_vec, sorted_vec, 3);\n    sorted_vec = vmaxq_s32(sorted_vec, vec);\n    \n    for(int i=0; i<N-1; i++){\n        vec = vextq_s32(vec, vec, 1);\n        sorted_vec = vmaxq_s32(sorted_vec, vec);\n    }\n    \n    int32x2_t result = vpmin_s32(vget_low_s32(sorted_vec), vget_high_s32(sorted_vec));\n    return vget_lane_s32(vpmin_s32(result, result), 0) >= vget_lane_s32(vget_high_s32(sorted_vec), 0);\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int size = lst1.size();\n    uint32x4_t mask = vdupq_n_u32(1);\n    uint32x4_t odd_mask = vdupq_n_u32(1);\n\n    for (int i = 0; i < size; i += 4) {\n        uint32x4_t vec1 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst1[i]));\n        uint32x4_t vec2 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst2[i]));\n\n        uint32x4_t even1 = vandq_u32(vec1, mask);\n        uint32x4_t even2 = vandq_u32(vec2, mask);\n\n        uint32x4_t odd1 = vandq_u32(vec1, odd_mask);\n        uint32x4_t odd2 = vandq_u32(vec2, odd_mask);\n\n        uint32x4_t odd_sum = vaddq_u32(odd1, odd2);\n        uint32x4_t even_sum = vaddq_u32(even1, even2);\n\n        uint32x4_t odd_check = vandq_u32(odd_sum, mask);\n\n        if (vmaxvq_u32(odd_check) == 0) {\n            return \"YES\";\n        }\n    }\n\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int size = lst1.size();\n    uint8x16_t mask = vdupq_n_u8(0x01);\n    uint8x16_t all_ones = vdupq_n_u8(0xFF);\n    uint8x16_t v_odd = vdupq_n_u8(0x01);\n    uint8x16_t v_even = vdupq_n_u8(0x00);\n\n    for (int i = 0; i < size; i += 16) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(&lst1[i]));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(&lst2[i]));\n\n        uint8x16_t odd_mask1 = vandq_u8(vec1, mask);\n        uint8x16_t odd_mask2 = vandq_u8(vec2, mask);\n\n        uint8x16_t odd_positions = vceqq_u8(odd_mask1, v_odd);\n        uint8x16_t even_positions = vceqq_u8(odd_mask1, v_even);\n\n        uint8x16_t odd_positions2 = vceqq_u8(odd_mask2, v_odd);\n\n        uint8x16_t can_exchange = vandq_u8(odd_positions, odd_positions2);\n        can_exchange = vandq_u8(can_exchange, even_positions);\n\n        if (vmaxvq_u8(can_exchange) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    uint32x4_t v_odd_mask = vdupq_n_u32(1);\n    uint32x4_t v_lst1, v_lst2, v_result;\n\n    for (int i = 0; i < lst1.size(); i += 4) {\n        v_lst1 = vld1q_u32(&lst1[i]);\n        v_lst2 = vld1q_u32(&lst2[i]);\n\n        v_result = vandq_u32(v_lst1, v_odd_mask);\n        v_result = vceqq_u32(v_result, vdupq_n_u32(1));\n\n        if (vmaxvq_u32(v_result) == 1) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int size = lst1.size();\n    uint32x4_t mask = vdupq_n_u32(1);\n    uint32x4_t odd_mask = vdupq_n_u32(1);\n    uint32x4_t even_mask = vdupq_n_u32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        uint32x4_t vec1 = vld1q_u32(&lst1[i]);\n        uint32x4_t vec2 = vld1q_u32(&lst2[i]);\n\n        uint32x4_t vec1_even = vandq_u32(vec1, mask);\n        uint32x4_t vec2_even = vandq_u32(vec2, mask);\n\n        uint32x4_t vec1_odd = veorq_u32(vec1_even, odd_mask);\n        uint32x4_t vec2_odd = veorq_u32(vec2_even, odd_mask);\n\n        uint32x4_t vec1_all_even = vceqq_u32(vec1_odd, even_mask);\n        uint32x4_t vec2_all_even = vceqq_u32(vec2_odd, even_mask);\n\n        uint32x4_t result = vandq_u32(vec1_all_even, vec2_all_even);\n\n        uint32x2_t result_low = vget_low_u32(result);\n        uint32x2_t result_high = vget_high_u32(result);\n\n        if (vget_lane_u32(result_low, 0) == 0 || vget_lane_u32(result_low, 1) == 0 ||\n            vget_lane_u32(result_high, 0) == 0 || vget_lane_u32(result_high, 1) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    uint32x4_t v_odd_mask = vdupq_n_u32(1);\n    uint32x4_t v_lst1, v_lst2, v_result;\n\n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        v_lst1 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst1[i]));\n        v_lst2 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst2[i]));\n\n        v_result = vandq_u32(v_lst1, v_odd_mask);\n        if (vmaxvq_u32(v_result) > 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        for (size_t i = 0; i < str.size(); ++i) {\n            uint8x16_t digits = vreinterpretq_u8_u8(vdupq_n_u8(str[i] - '0'));\n            uint8x16_t odd_mask = vandq_u8(digits, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odd_mask);\n        }\n        uint8_t odd_count_arr[16];\n        vst1q_u8(odd_count_arr, odd_count);\n        std::string res_str = \"the number of odd elements \";\n        for (int j = 0; j < 16; ++j) {\n            res_str += std::to_string(odd_count_arr[j]);\n        }\n        res_str += \"n the str\" + std::to_string(result.size()) + \"ng \" + std::to_string(result.size()) + \" of the \" + std::to_string(result.size()) + \"nput.\";\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        uint8x16_t odd_mask = vdupq_n_u8(1);\n        uint8x16_t count = vdupq_n_u8(0);\n        for (size_t i = 0; i < str.size(); ++i) {\n            uint8x16_t digits = vdupq_n_u8(str[i] - '0');\n            uint8x16_t odd_digits = vandq_u8(digits, odd_mask);\n            count = vaddq_u8(count, odd_digits);\n        }\n        uint8_t count_arr[16];\n        vst1q_u8(count_arr, count);\n        std::string res_str = \"the number of odd elements \";\n        for (int i = 0; i < 16; ++i) {\n            res_str += std::to_string(count_arr[i]);\n        }\n        res_str += \"n the str\" + std::to_string(result.size()) + \"ng \" + std::to_string(result.size()) + \" of the \" + std::to_string(result.size()) + \"nput.\";\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        for (size_t i = 0; i < str.size(); i++) {\n            uint8x16_t digits = vdupq_n_u8(str[i] - '0');\n            uint8x16_t is_odd = vandq_u8(digits, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, is_odd);\n        }\n        uint8_t odd_count_arr[16];\n        vst1q_u8(odd_count_arr, odd_count);\n        std::string res_str = \"the number of odd elements \";\n        for (int j = 0; j < 16; j++) {\n            res_str += std::to_string(odd_count_arr[j]);\n        }\n        res_str += \" in the string \" + str + \" of the input.\";\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        for (size_t i = 0; i < str.size(); i++) {\n            uint8x16_t digits = vdupq_n_u8(str[i] - '0');\n            uint8x16_t odd_mask = vandq_u8(digits, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odd_mask);\n        }\n        uint8_t odd_count_arr[16];\n        vst1q_u8(odd_count_arr, odd_count);\n        std::string res_str = \"the number of odd elements \";\n        for (int j = 0; j < 16; j++) {\n            res_str += std::to_string(odd_count_arr[j]);\n        }\n        res_str += \"n the str\" + std::to_string(result.size()) + \"ng \" + std::to_string(result.size()) + \" of the \" + std::to_string(result.size()) + \"nput.\";\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const std::string &str : lst) {\n        uint8x16_t odd_mask = vcreate_u8(0x5555555555555555); // Mask to check odd digits\n        uint8x16_t count = vdupq_n_u8(0);\n        for (char c : str) {\n            if (c >= '0' && c <= '9') {\n                uint8x16_t digit = vdupq_n_u8(c - '0');\n                uint8x16_t is_odd = vandq_u8(digit, odd_mask);\n                count = vaddq_u8(count, is_odd);\n            }\n        }\n        uint8_t count_arr[16];\n        vst1q_u8(count_arr, count);\n        std::string res_str = \"the number of odd elements \";\n        for (int i = 0; i < 16; ++i) {\n            res_str += std::to_string(count_arr[i]);\n        }\n        res_str += \"n the str\" + std::to_string(result.size()) + \"ng \" + std::to_string(result.size()) + \" of the \" + std::to_string(result.size()) + \"nput.\";\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64x2_t min_sum = vdupq_n_s64(INT64_MAX);\n    int64x2_t current_sum = vdupq_n_s64(0);\n\n    for (int i = 0; i < nums.size(); i += 2) {\n        int64x2_t num = vld1q_s64(&nums[i]);\n\n        current_sum = vminq_s64(num, vaddq_s64(current_sum, num));\n        min_sum = vminq_s64(min_sum, current_sum);\n    }\n\n    int64_t result[2];\n    vst1q_s64(result, min_sum);\n\n    return std::min(result[0], result[1]);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64x2_t min_sum = vdupq_n_s64(0);\n    int64x2_t current_sum = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < nums.size(); i += 2) {\n        int64x2_t num = vld1q_s64(&nums[i]);\n        current_sum = vmaxq_s64(vaddq_s64(current_sum, num), num);\n        min_sum = vminq_s64(min_sum, current_sum);\n    }\n    \n    int64_t result[2];\n    vst1q_s64(result, min_sum);\n    \n    return std::min(result[0], result[1]);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64x2_t min_sum = vdupq_n_s64(INT64_MAX);\n    int64x2_t current_sum = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < nums.size(); i += 2) {\n        int64x2_t num = vld1q_s64(&nums[i]);\n\n        current_sum = vminq_s64(vaddq_s64(current_sum, num), num);\n        min_sum = vminq_s64(min_sum, current_sum);\n    }\n\n    int64_t result[2];\n    vst1q_s64(result, min_sum);\n\n    return std::min(result[0], result[1]);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64x2_t min_sum = vdupq_n_s64(0);\n    int64x2_t curr_sum = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < nums.size(); i += 2) {\n        int64x2_t num = vld1q_s64(&nums[i]);\n        curr_sum = vmaxq_s64(vaddq_s64(curr_sum, num), num);\n        min_sum = vminq_s64(min_sum, curr_sum);\n    }\n    \n    int64_t result[2];\n    vst1q_s64(result, min_sum);\n    \n    return std::min(result[0], result[1]);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    int64x2_t min_sum = vdupq_n_s64(0);\n    int64x2_t curr_sum = vdupq_n_s64(0);\n    \n    for (int i = 0; i < nums.size(); i += 2) {\n        int64x2_t num = vld1q_s64(&nums[i]);\n        curr_sum = vmaxq_s64(vaddq_s64(curr_sum, num), num);\n        min_sum = vminq_s64(min_sum, curr_sum);\n    }\n    \n    int64_t result[2];\n    vst1q_s64(result, min_sum);\n    \n    return std::min(result[0], result[1]);\n}\n```  "}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int count = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    int32x4_t capacity_v = vdupq_n_s32(capacity);\n    int32x4_t count_v = vdupq_n_s32(0);\n    \n    for (int i = 0; i < rows; ++i) {\n        int32x4_t sum_v = vdupq_n_s32(0);\n        for (int j = 0; j < cols; j += 4) {\n            int32x4_t row_v = vld1q_s32(&grid[i][j]);\n            sum_v = vaddq_s32(sum_v, row_v);\n            int32x4_t excess_v = vsubq_s32(sum_v, capacity_v);\n            int32x4_t mask_v = vcleq_s32(excess_v, vdupq_n_s32(0));\n            count_v = vaddq_s32(count_v, vandq_s32(vabsq_s32(excess_v), mask_v));\n            sum_v = vandq_s32(excess_v, vmvnq_s32(mask_v));\n        }\n    }\n    \n    int32x2_t count_v2 = vpadd_s32(vget_low_s32(count_v), vget_high_s32(count_v));\n    count = vget_lane_s32(vpadd_s32(count_v2, count_v2), 0);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int count = 0;\n    int bucket_capacity = capacity;\n    int grid_rows = grid.size();\n    int grid_cols = grid[0].size();\n    \n    int32x4_t v_bucket_capacity = vdupq_n_s32(bucket_capacity);\n    int32x4_t v_count = vdupq_n_s32(0);\n    \n    for (int i = 0; i < grid_rows; ++i) {\n        int j = 0;\n        for (; j <= grid_cols - 4; j += 4) {\n            uint8x8_t v_wells = vld1_u8(&grid[i][j]);\n            uint8x8_t v_wells_next = vld1_u8(&grid[i][j + 4]);\n            \n            uint8x8_t v_sum = vadd_u8(v_wells, v_wells_next);\n            uint8x8_t v_compare = vcgt_u8(v_sum, vdup_n_u8(0));\n            uint8x8_t v_result = vand_u8(v_compare, v_sum);\n            \n            uint16x8_t v_result_widen = vmovl_u8(v_result);\n            uint32x4_t v_result_sum = vpaddlq_u16(v_result_widen);\n            \n            v_count = vaddq_s32(v_count, vreinterpretq_s32_u32(v_result_sum));\n        }\n        for (; j < grid_cols; ++j) {\n            count += grid[i][j];\n        }\n    }\n    \n    int32x2_t v_count_low = vget_low_s32(v_count);\n    int32x2_t v_count_high = vget_high_s32(v_count);\n    int32x2_t v_count_sum = vpadd_s32(v_count_low, v_count_high);\n    \n    int count_array[2];\n    vst1_s32(count_array, v_count_sum);\n    \n    count += count_array[0] + count_array[1];\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int count = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    int32x4_t v_capacity = vdupq_n_s32(capacity);\n    int32x4_t v_count = vdupq_n_s32(0);\n    \n    for (int i = 0; i < rows; ++i) {\n        int j = 0;\n        for (; j <= cols - 4; j += 4) {\n            uint8x8_t v_wells = vld1_u8(&grid[i][j]);\n            uint8x8_t v_wells_next = vld1_u8(&grid[i][j + 4]);\n            \n            uint8x8_t v_sum = vadd_u8(v_wells, v_wells_next);\n            uint8x8_t v_compare = vcgt_u8(v_sum, vdup_n_u8(0));\n            uint8x8_t v_result = vand_u8(v_compare, v_sum);\n            \n            uint16x8_t v_sum16 = vpaddlq_u8(v_result);\n            uint32x4_t v_sum32 = vpaddlq_u16(v_sum16);\n            \n            v_count = vaddq_s32(v_count, vreinterpretq_s32_u32(v_sum32));\n        }\n        for (; j < cols; ++j) {\n            count += grid[i][j];\n        }\n    }\n    \n    int32x2_t v_count_low = vget_low_s32(v_count);\n    int32x2_t v_count_high = vget_high_s32(v_count);\n    int32x2_t v_count_final = vadd_s32(v_count_low, v_count_high);\n    \n    int result[2];\n    vst1_s32(result, v_count_final);\n    \n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int count = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    int32x4_t capacity_v = vdupq_n_s32(capacity);\n    int32x4_t count_v = vdupq_n_s32(0);\n    \n    for (int i = 0; i < rows; ++i) {\n        int32x4_t row_v = vld1q_s32(&grid[i][0]);\n        \n        int32x4_t diff_v = vsubq_s32(capacity_v, row_v);\n        int32x4_t zero_v = vdupq_n_s32(0);\n        diff_v = vmaxq_s32(diff_v, zero_v);\n        \n        count_v = vaddq_s32(count_v, diff_v);\n    }\n    \n    int32x2_t count_v2 = vpadd_s32(vget_low_s32(count_v), vget_high_s32(count_v));\n    int32x2_t count_v2_sum = vpadd_s32(count_v2, count_v2);\n    \n    count += vget_lane_s32(count_v2_sum, 0);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int count = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    int32x4_t v_capacity = vdupq_n_s32(capacity);\n    int32x4_t v_count = vdupq_n_s32(0);\n    \n    for (int i = 0; i < rows; ++i) {\n        int32x4_t v_sum = vdupq_n_s32(0);\n        for (int j = 0; j < cols; j += 4) {\n            int32x4_t v_wells = vld1q_s32(&grid[i][j]);\n            v_sum = vaddq_s32(v_sum, v_wells);\n            \n            int32x4_t v_diff = vsubq_s32(v_capacity, v_sum);\n            int32x4_t v_mask = vcltq_s32(v_diff, vdupq_n_s32(0));\n            v_count = vaddq_s32(v_count, vandq_s32(v_mask, vnegq_s32(v_diff)));\n            v_sum = vandq_s32(v_sum, vmvnq_s32(v_mask));\n        }\n    }\n    \n    int32x2_t v_count_low = vget_low_s32(v_count);\n    int32x2_t v_count_high = vget_high_s32(v_count);\n    int count_low = vget_lane_s32(v_count_low, 0) + vget_lane_s32(v_count_low, 1);\n    int count_high = vget_lane_s32(v_count_high, 0) + vget_lane_s32(v_count_high, 1);\n    \n    count = count_low + count_high;\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64x2_t sum = vdupq_n_s64(0);\n    int16x8_t data = vld1q_s16(lst.data());\n\n    for (int i = 0; i < 4; i++) {\n        int16x8_t odd_elements = vandq_s16(data, vdupq_n_s16(1));\n        int16x4_t even_positions = vget_low_s16(odd_elements);\n        int16x4_t odd_positions = vget_high_s16(odd_elements);\n        sum = vaddw_s16(sum, vreinterpretq_s64_s16(vcombine_s16(even_positions, vdup_n_s16(0))));\n        data = vextq_s16(data, data, 4);\n    }\n\n    return vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n}\n```  "}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64x2_t sum = vdupq_n_s64(0);\n    int16x8_t data = vld1q_s16(lst.data());\n\n    for (int i = 0; i < 4; i++) {\n        int16x8_t odd_elements = vandq_s16(data, vdupq_n_s16(1));\n        int16x8_t even_positions = vandq_s16(vdupq_n_s16(0xAAAAAAAA), vdupq_n_s16(0xFFFF));\n        int16x8_t odd_elements_in_even_positions = vandq_s16(odd_elements, even_positions);\n        int16x4_t odd_elements_in_even_positions_low = vget_low_s16(odd_elements_in_even_positions);\n        int16x4_t odd_elements_in_even_positions_high = vget_high_s16(odd_elements_in_even_positions);\n        sum = vaddw_s16(sum, odd_elements_in_even_positions_low);\n        sum = vaddw_s16(sum, odd_elements_in_even_positions_high);\n    }\n\n    int64x1_t result = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    return vget_lane_s64(result, 0);\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64x2_t sum = vdupq_n_s64(0);\n    int16x8_t data = vld1q_s16(lst.data());\n    \n    for (int i = 0; i < 4; i++) {\n        int16x8_t odd_elements = vandq_s16(data, vdupq_n_s16(1));\n        int16x8_t even_positions = vandq_s16(vdupq_n_s16(0xAAAAAAAA), vdupq_n_s16(0xFFFF));\n        int16x8_t odd_elements_in_even_positions = vandq_s16(odd_elements, even_positions);\n        int16x4_t odd_elements_in_even_positions_low = vget_low_s16(odd_elements_in_even_positions);\n        int16x4_t odd_elements_in_even_positions_high = vget_high_s16(odd_elements_in_even_positions);\n        \n        sum = vaddw_s16(sum, odd_elements_in_even_positions_low);\n        sum = vaddw_s16(sum, odd_elements_in_even_positions_high);\n        \n        data = vextq_s16(data, data, 4);\n    }\n    \n    int64x1_t result = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    return vget_lane_s64(result, 0);\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64x2_t sum = vdupq_n_s64(0);\n    int16x8_t data = vld1q_s16(lst.data());\n\n    for (int i = 0; i < 4; i++) {\n        int16x8_t odd_elements = vandq_s16(data, vdupq_n_s16(1));\n        int16x4_t even_positions = vget_low_s16(odd_elements);\n        int16x4_t odd_positions = vget_high_s16(odd_elements);\n        sum = vaddw_s16(sum, vreinterpretq_s64_s16(vcombine_s16(even_positions, vdup_n_s16(0))));\n        data = vextq_s16(data, data, 4);\n    }\n\n    return vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64x2_t sum = vdupq_n_s64(0);\n    int16x8_t vec = vld1q_s16(lst.data());\n\n    for (int i = 0; i < 4; i++) {\n        int16x8_t odd_elements = vandq_s16(vec, vdupq_n_s16(1));\n        int16x8_t even_positions = vandq_s16(vdupq_n_s16(0xAAAAAAAA), vshrq_n_s16(vec, 1));\n        int16x8_t odd_elements_in_even_positions = vandq_s16(odd_elements, even_positions);\n        sum = vaddw_s16(sum, vget_low_s16(odd_elements_in_even_positions));\n        sum = vaddw_s16(sum, vget_high_s16(odd_elements_in_even_positions));\n    }\n\n    int64x1_t result = vadd_s64(vget_low_s64(sum), vget_high_s64(sum));\n    return vget_lane_s64(result, 0);\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t varr = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcltq_s32(varr, vdupq_n_s32(100));\n        int32x4_t filtered = vbslq_s32(mask, varr, vdupq_n_s32(0));\n        vsum = vaddq_s32(vsum, filtered);\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vsum_final = vpadd_s32(vsum_low, vsum_high);\n    sum = vget_lane_s32(vsum_final, 0) + vget_lane_s32(vsum_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t input = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcltq_s32(input, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(input, vreinterpretq_s32_u32(mask));\n        sum_vec = vaddq_s32(sum_vec, filtered);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t input = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcltq_s32(input, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(input, vreinterpretq_s32_u32(mask));\n        sum_vec = vaddq_s32(sum_vec, filtered);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n    \n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t varr = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcltq_s32(varr, vdupq_n_s32(100));\n        vsum = vaddq_s32(vsum, vandq_u32(varr, vreinterpretq_s32_u32(mask)));\n    }\n\n    int32x2_t vsum_low = vget_low_s32(vsum);\n    int32x2_t vsum_high = vget_high_s32(vsum);\n    int32x2_t vsum_final = vpadd_s32(vsum_low, vsum_high);\n    sum = vget_lane_s32(vsum_final, 0) + vget_lane_s32(vsum_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t arr_vec = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcltq_s32(arr_vec, vdupq_n_s32(100));\n        int32x4_t filtered_arr = vbslq_s32(mask, arr_vec, vdupq_n_s32(0));\n        sum_vec = vaddq_s32(sum_vec, filtered_arr);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```\nbool is_sorted_simd(const std::vector<int> & lst){\n    if(lst.size() < 2) return true;\n    \n    uint32x4_t prev = vld1q_u32((const uint32_t*)&lst[0]);\n    \n    for(size_t i = 4; i < lst.size(); i += 4){\n        uint32x4_t curr = vld1q_u32((const uint32_t*)&lst[i]);\n        uint32x4_t cmp = vcltq_u32(curr, prev);\n        if(vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)){\n            return false;\n        }\n        prev = curr;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```\nbool is_sorted_simd(const std::vector<int> & lst){\n    if(lst.size() < 2) {\n        return true;\n    }\n\n    int size = lst.size();\n    int32x4_t prev = vld1q_s32(&lst[0]);\n\n    for(int i = 4; i < size; i += 4) {\n        int32x4_t curr = vld1q_s32(&lst[i]);\n        uint32x4_t cmp = vcleq_s32(prev, curr);\n        uint32x2_t cmp_low = vget_low_u32(cmp);\n        uint32x2_t cmp_high = vget_high_u32(cmp);\n        if(vget_lane_u32(cmp_low, 0) == 0 || vget_lane_u32(cmp_low, 1) == 0 || vget_lane_u32(cmp_high, 0) == 0 || vget_lane_u32(cmp_high, 1) == 0) {\n            return false;\n        }\n        prev = vld1q_lane_s32(&lst[i], prev, 3);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```\nbool is_sorted_simd(const std::vector<int> & lst){\n    if(lst.size() < 2) return true;\n\n    uint32x4_t prev = vld1q_u32((const uint32_t*)&lst[0]);\n    uint32x4_t curr;\n\n    for(size_t i = 4; i < lst.size(); i += 4){\n        curr = vld1q_u32((const uint32_t*)&lst[i]);\n        uint32x4_t cmp = vcleq_u32(prev, curr);\n        uint32_t mask = vmovemaskq_u32(cmp);\n        if(mask != 0xf) return false;\n        prev = vld1q_u32((const uint32_t*)&lst[i]);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```\nbool is_sorted_simd(const std::vector<int> & lst){\n    if(lst.size() < 2) {\n        return true;\n    }\n\n    int size = lst.size();\n    int lanes = 4;\n    int full_chunks = size / lanes;\n    int remaining_elements = size % lanes;\n\n    int32x4_t prev = vld1q_s32(&lst[0]);\n\n    for(int i = 1; i < full_chunks; i++) {\n        int32x4_t curr = vld1q_s32(&lst[i * lanes]);\n        uint32x4_t cmp = vcleq_s32(prev, curr);\n        if(vmovemaskq_u32(cmp) != 0xF) {\n            return false;\n        }\n        prev = vld1q_s32(&lst[i * lanes]);\n    }\n\n    if(remaining_elements > 0) {\n        int32x4_t curr = vld1q_s32(&lst[full_chunks * lanes]);\n        uint32x4_t cmp = vcleq_s32(prev, curr);\n        if(vmovemaskq_u32(cmp) != (1 << remaining_elements) - 1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```\nbool is_sorted_simd(const std::vector<int> & lst){\n    if(lst.size() < 2) {\n        return true;\n    }\n\n    int size = lst.size();\n    int32x4_t prev = vld1q_s32(&lst[0]);\n\n    for(int i = 4; i < size; i += 4) {\n        int32x4_t curr = vld1q_s32(&lst[i]);\n        uint32x4_t cmp = vcleq_s32(prev, curr);\n        uint32x2_t cmp_pair = vand_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n        uint32_t result = vget_lane_u32(vget_low_u32(cmp_pair), 0) & vget_lane_u32(vget_high_u32(cmp_pair), 0);\n        if(result == 0) {\n            return false;\n        }\n        prev = vld1q_s32(&lst[i]);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr){\n    if(arr.empty()) return -32768;\n\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t signs = vdupq_n_s32(1);\n\n    for(size_t i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t abs_values = vabsq_s32(values);\n        int32x4_t signs_mask = vshrq_n_s32(values, 31);\n        signs = vmulq_s32(signs, signs_mask);\n        sum = vaddq_s32(sum, abs_values);\n    }\n\n    int32x2_t sum_low = vget_low_s32(sum);\n    int32x2_t sum_high = vget_high_s32(sum);\n    int32x2_t signs_low = vget_low_s32(signs);\n    int32x2_t signs_high = vget_high_s32(signs);\n\n    int32x2_t result_low = vmul_s32(sum_low, signs_low);\n    int32x2_t result_high = vmul_s32(sum_high, signs_high);\n\n    int32x2_t result = vpadd_s32(result_low, result_high);\n    return vget_lane_s32(result, 0) + vget_lane_s32(result, 1);\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if(arr.empty()) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t signs_prod = vdupq_n_s32(1);\n\n    for(size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t signs = vshrq_n_s32(values, 31);\n        signs_prod = vmulq_s32(signs_prod, signs);\n        sum_vec = vmlaq_s32(sum_vec, vabsq_s32(values), signs);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    int32x2_t signs_prod_low = vget_low_s32(signs_prod);\n    int32x2_t signs_prod_high = vget_high_s32(signs_prod);\n    int32x2_t signs_prod_final = vmul_s32(signs_prod_low, signs_prod_high);\n    int signs_prod_scalar = vget_lane_s32(signs_prod_final, 0) * vget_lane_s32(signs_prod_final, 1);\n\n    return sum * signs_prod_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr){\n    if(arr.empty()) return -32768;\n\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t signs_prod = vdupq_n_s32(1);\n\n    for(size_t i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t signs = vdupq_n_s32(1);\n        for(int j = 0; j < 4; j++){\n            int32x4_t sign_mask = vdupq_n_s32(arr[i+j] < 0 ? -1 : 1);\n            signs = vmulq_s32(signs, sign_mask);\n        }\n        signs_prod = vmulq_s32(signs_prod, signs);\n        sum_vec = vaddq_s32(sum_vec, vabsq_s32(values));\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n\n    int32x2_t signs_prod_low = vget_low_s32(signs_prod);\n    int32x2_t signs_prod_high = vget_high_s32(signs_prod);\n    int32x2_t signs_prod_final = vmul_s32(signs_prod_low, signs_prod_high);\n\n    int sum_final = vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n    int signs_prod_final_scalar = vget_lane_s32(signs_prod_final, 0) * vget_lane_s32(signs_prod_final, 1);\n\n    return sum_final * signs_prod_final_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr){\n    if(arr.empty()) return -32768;\n\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t signs_prod = vdupq_n_s32(1);\n\n    for(size_t i = 0; i < arr.size(); i += 4){\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t signs = vdupq_n_s32(1);\n        int32x4_t zero = vdupq_n_s32(0);\n\n        uint32x4_t is_negative = vcltq_s32(values, zero);\n        int32x4_t neg_ones = vreinterpretq_s32_u32(is_negative);\n        int32x4_t pos_ones = vandq_s32(vmvnq_s32(is_negative), signs);\n\n        signs_prod = vmulq_s32(signs_prod, vbslq_s32(is_negative, neg_ones, pos_ones));\n        sum_vec = vaddq_s32(sum_vec, vabdq_s32(values, zero));\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n\n    int32x2_t signs_prod_low = vget_low_s32(signs_prod);\n    int32x2_t signs_prod_high = vget_high_s32(signs_prod);\n    int32x2_t signs_prod_final = vmul_s32(signs_prod_low, signs_prod_high);\n\n    sum = vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n    sum *= vget_lane_s32(signs_prod_final, 0);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if(arr.empty()) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t signs_prod = vdupq_n_s32(1);\n\n    for(size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t signs = vdupq_n_s32(1);\n        int32x4_t signs_mask = vreinterpretq_s32_u32(vcgtq_s32(values, vdupq_n_s32(0)));\n        signs = vsubq_s32(signs, signs_mask);\n        signs_prod = vmulq_s32(signs_prod, signs);\n        sum_vec = vaddq_s32(sum_vec, vabdq_s32(values, vdupq_n_s32(0)));\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n\n    int32x2_t signs_prod_low = vget_low_s32(signs_prod);\n    int32x2_t signs_prod_high = vget_high_s32(signs_prod);\n    int32x2_t signs_prod_final = vmul_s32(signs_prod_low, signs_prod_high);\n\n    int sum_final = vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n    int signs_prod_result = vget_lane_s32(signs_prod_final, 0) * vget_lane_s32(signs_prod_final, 1);\n\n    return sum_final * signs_prod_result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    std::vector<int> result;\n    int N = grid.size();\n    int total_cells = N * N;\n\n    int16x8_t path_values;\n    int16x8_t min_values = vdupq_n_s16(INT16_MAX);\n    int16x8_t min_indices = vdupq_n_s16(0);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j += 8) {\n            path_values = vld1q_s16(&grid[i][j]);\n            uint8x8_t path_indices = vdup_n_u8(i * N + j);\n\n            uint8x8_t less_than_mask = vcltq_s16(path_values, min_values);\n            min_values = vbslq_s16(less_than_mask, path_values, min_values);\n            min_indices = vbslq_s16(less_than_mask, vreinterpretq_s16_u8(path_indices), min_indices);\n        }\n    }\n\n    int16_t min_values_array[8];\n    int16_t min_indices_array[8];\n    vst1q_s16(min_values_array, min_values);\n    vst1q_s16(min_indices_array, min_indices);\n\n    for (int i = 0; i < 8; i++) {\n        if (min_indices_array[i] < total_cells) {\n            result.push_back(grid[min_indices_array[i] / N][min_indices_array[i] % N]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    std::vector<int> result;\n    int N = grid.size();\n    int total_cells = N * N;\n    int remaining_cells = k;\n    \n    int row = 0;\n    int col = 0;\n    \n    result.push_back(grid[row][col]);\n    remaining_cells--;\n    \n    while (remaining_cells > 0) {\n        uint8x16_t values = vld1q_u8(reinterpret_cast<uint8_t*>(&grid[row][col]));\n        uint8x16_t min_values = values;\n        int min_row = row;\n        int min_col = col;\n        \n        if (row > 0) {\n            uint8x16_t up_values = vld1q_u8(reinterpret_cast<uint8_t*>(&grid[row-1][col]));\n            uint8x16_t up_mask = vcleq_u8(up_values, min_values);\n            min_values = vminq_u8(min_values, up_values);\n            min_row = vgetq_lane_u8(vbslq_u8(up_mask, vdupq_n_u8(row-1), vdupq_n_u8(min_row)), 0);\n        }\n        \n        if (row < N-1) {\n            uint8x16_t down_values = vld1q_u8(reinterpret_cast<uint8_t*>(&grid[row+1][col]));\n            uint8x16_t down_mask = vcleq_u8(down_values, min_values);\n            min_values = vminq_u8(min_values, down_values);\n            min_row = vgetq_lane_u8(vbslq_u8(down_mask, vdupq_n_u8(row+1), vdupq_n_u8(min_row)), 0);\n        }\n        \n        if (col > 0) {\n            uint8x16_t left_values = vld1q_u8(reinterpret_cast<uint8_t*>(&grid[row][col-1]));\n            uint8x16_t left_mask = vcleq_u8(left_values, min_values);\n            min_values = vminq_u8(min_values, left_values);\n            min_row = vgetq_lane_u8(vbslq_u8(left_mask, vdupq_n_u8(row), vdupq_n_u8(min_row)), 0);\n            min_col = vgetq_lane_u8(vbslq_u8(left_mask, vdupq_n_u8(col-1), vdupq_n_u8(min_col)), 0);\n        }\n        \n        if (col < N-1) {\n            uint8x16_t right_values = vld1q_u8(reinterpret_cast<uint8_t*>(&grid[row][col+1]));\n            uint8x16_t right_mask = vcleq_u8(right_values, min_values);\n            min_values = vminq_u8(min_values, right_values);\n            min_row = vgetq_lane_u8(vbslq_u8(right_mask, vdupq_n_u8(row), vdupq_n_u8(min_row)), 0);\n            min_col = vgetq_lane_u8(vbslq_u8(right_mask, vdupq_n_u8(col+1), vdupq_n_u8(min_col)), 0);\n        }\n        \n        row = min_row;\n        col = min_col;\n        \n        result.push_back(grid[row][col]);\n        remaining_cells--;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    int total_elements = N * N;\n    int path_length = k;\n\n    std::vector<int> result(k);\n\n    int16x8_t path_values = vdupq_n_s16(0);\n    int16x8_t path_indices = vdupq_n_s16(0);\n\n    for (int i = 0; i < path_length; i++) {\n        int16x8_t min_values = vdupq_n_s16(INT16_MAX);\n        int16x8_t min_indices = vdupq_n_s16(0);\n\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col += 8) {\n                int16x8_t grid_values = vld1q_s16(&grid[row][col]);\n                uint16x8_t mask = vcltq_s16(grid_values, min_values);\n                min_values = vminq_s16(min_values, grid_values);\n                min_indices = vbslq_s16(mask, vdupq_n_s16(row * N + col), min_indices);\n            }\n        }\n\n        path_values = vsetq_lane_s16(vgetq_lane_s16(min_values, 0), path_values, i);\n        path_indices = vsetq_lane_s16(vgetq_lane_s16(min_indices, 0), path_indices, i);\n\n        for (int row = 0; row < N; row++) {\n            for (int col = 0; col < N; col++) {\n                int16x8_t current_indices = vdupq_n_s16(row * N + col);\n                uint16x8_t mask = vceqq_s16(current_indices, min_indices);\n                grid[row][col] = vgetq_lane_s16(vbslq_s16(mask, vdupq_n_s16(INT16_MAX), grid_values), 0);\n            }\n        }\n    }\n\n    for (int i = 0; i < path_length; i++) {\n        result[i] = vgetq_lane_s16(path_values, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    int16x8_t path = vdupq_n_s16(0);\n    int16x8_t indices = vdupq_n_s16(0);\n    \n    for (int i = 0; i < k; ++i) {\n        int16x8_t min_val = vdupq_n_s16(32767);\n        int16x8_t min_index = vdupq_n_s16(0);\n        \n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                int16x8_t val = vld1q_s16(&grid[r][c]);\n                uint16x8_t mask = vcleq_s16(val, min_val);\n                min_val = vminq_s16(min_val, val);\n                min_index = vbslq_s16(mask, vdupq_n_s16(r * N + c + 1), min_index);\n            }\n        }\n        \n        path = vsetq_lane_s16(vgetq_lane_s16(min_val, 0), path, i);\n        indices = vsetq_lane_s16(vgetq_lane_s16(min_index, 0), indices, i);\n        \n        for (int r = 0; r < N; ++r) {\n            for (int c = 0; c < N; ++c) {\n                int16x8_t index = vdupq_n_s16(r * N + c + 1);\n                uint16x8_t mask = vceqq_s16(index, min_index);\n                min_val = vbslq_s16(mask, vdupq_n_s16(32767), min_val);\n            }\n        }\n    }\n    \n    vst1q_s16(result.data(), path);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    std::vector<int> result;\n    int N = grid.size();\n    int i = 0, j = 0;\n    result.push_back(grid[i][j]);\n    \n    for (int step = 1; step < k; step++) {\n        uint8x16_t values = vld1q_u8(&grid[i][j]);\n        uint8x16_t min_values = values;\n        int min_i = i, min_j = j;\n        \n        if (i > 0) {\n            uint8x16_t up_values = vld1q_u8(&grid[i-1][j]);\n            uint8x16_t mask = vcltq_u8(up_values, min_values);\n            min_values = vbslq_u8(mask, up_values, min_values);\n            min_i = vgetq_lane_u8(mask, 0) ? i-1 : min_i;\n            min_j = vgetq_lane_u8(mask, 1) ? j : min_j;\n        }\n        \n        if (i < N-1) {\n            uint8x16_t down_values = vld1q_u8(&grid[i+1][j]);\n            uint8x16_t mask = vcltq_u8(down_values, min_values);\n            min_values = vbslq_u8(mask, down_values, min_values);\n            min_i = vgetq_lane_u8(mask, 0) ? i+1 : min_i;\n            min_j = vgetq_lane_u8(mask, 1) ? j : min_j;\n        }\n        \n        if (j > 0) {\n            uint8x16_t left_values = vld1q_u8(&grid[i][j-1]);\n            uint8x16_t mask = vcltq_u8(left_values, min_values);\n            min_values = vbslq_u8(mask, left_values, min_values);\n            min_i = vgetq_lane_u8(mask, 0) ? i : min_i;\n            min_j = vgetq_lane_u8(mask, 1) ? j-1 : min_j;\n        }\n        \n        if (j < N-1) {\n            uint8x16_t right_values = vld1q_u8(&grid[i][j+1]);\n            uint8x16_t mask = vcltq_u8(right_values, min_values);\n            min_values = vbslq_u8(mask, right_values, min_values);\n            min_i = vgetq_lane_u8(mask, 0) ? i : min_i;\n            min_j = vgetq_lane_u8(mask, 1) ? j+1 : min_j;\n        }\n        \n        i = min_i;\n        j = min_j;\n        result.push_back(grid[i][j]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t zero = vdup_n_u64(0);\n    \n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            result = vmul_u64(result, vdup_n_u64(digit));\n        }\n        n /= 10;\n    }\n    \n    uint64_t output[1];\n    vst1_u64(output, result);\n    \n    return output[0];\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t zero = vdup_n_u64(0);\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            result = vmul_n_u64(result, digit);\n        } else if (digit == 0) {\n            return 0;\n        }\n        n /= 10;\n    }\n    \n    return vget_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t zero = vdup_n_u64(0);\n\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            result = vmul_n_u64(result, digit);\n        }\n        n /= 10;\n    }\n\n    uint64_t output[1];\n    vst1_u64(output, result);\n\n    return output[0];\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t zero = vdup_n_u64(0);\n    \n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            result = vmul_n_u64(result, digit);\n        }\n        n /= 10;\n    }\n    \n    uint64_t output[1];\n    vst1_u64(output, result);\n    \n    return output[0];\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64x1_t result = vdup_n_u64(1);\n    uint64x1_t zero = vdup_n_u64(0);\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            result = vmul_n_u64(result, digit);\n        }\n        n /= 10;\n    }\n    \n    uint64_t output[1];\n    vst1_u64(output, result);\n    \n    return output[0];\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t vec = vceqq_f32(vld1q_f32(lst.data()), vld1q_f32(lst.data()));\n    vec = vcvtq_u32_f32(vceilq_f32(vcvtq_f32_u32(vec)));\n    uint32x4_t squared = vmulq_u32(vec, vec);\n    uint64x2_t sum_low = vpaddl_u32(vget_low_u32(squared));\n    uint64x2_t sum_high = vpaddl_u32(vget_high_u32(squared));\n    sum = vpadal_u32(sum, sum_low);\n    sum = vpadal_u32(sum, sum_high);\n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t vec = vceqq_f32(vld1q_f32(lst.data()), vld1q_f32(lst.data()));\n    vec = vcvtq_u32_f32(vceilq_f32(vcvtq_f32_u32(vec)));\n    uint32x4_t squared = vmulq_u32(vec, vec);\n    uint64x2_t squared_sum = vpaddlq_u32(squared);\n    sum = vpadalq_u32(sum, squared_sum);\n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t vec = vceqq_f32(vld1q_f32(lst.data()), vld1q_f32(lst.data()));\n    vec = vcvtq_u32_f32(vceilq_f32(vcvtq_f32_u32(vec)));\n    uint32x4_t squared = vmulq_u32(vec, vec);\n    uint64x2_t sum_low = vpaddl_u32(vget_low_u32(squared));\n    uint64x2_t sum_high = vpaddl_u32(vget_high_u32(squared));\n    sum = vpadal_u32(sum, sum_low);\n    sum = vpadal_u32(sum, sum_high);\n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    float32x4_t vec = vld1q_f32(lst.data());\n\n    vec = vcvt_round_f32_s32(vcgtq_f32(vec, vdupq_n_f32(0)), vec);\n\n    float32x4_t squared = vmulq_f32(vec, vec);\n    uint32x4_t squared_int = vcvtq_u32_f32(squared);\n\n    uint64x2_t squared_int_sum = vpaddlq_u32(squared_int);\n    sum = vpadalq_u32(sum, squared_int_sum);\n\n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    float32x4_t vec = vld1q_f32(lst.data());\n    float32x4_t rounded = vcvtceilq_f32_s32(vec);\n    float32x4_t squared = vmulq_f32(rounded, rounded);\n    uint32x4_t squared_int = vcvtq_u32_f32(squared);\n    uint64x2_t squared_int64 = vpaddlq_u32(squared_int);\n    sum = vpadalq_u64(sum, squared_int64);\n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr){\n    int result = -1;\n    int maxIndex = -1;\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    \n    for (int i = 1; i < arr.size(); i+=4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcleq_s32(current, prev);\n        int32x4_t indices = vdupq_n_s32(i-1);\n        int32x4_t newMaxIndex = vmaxq_s32(vandq_s32(indices, vreinterpretq_s32_u32(mask)), vreinterpretq_s32_u32(vmvnq_u32(mask)));\n        maxIndex = vmaxvq_s32(maxIndex, newMaxIndex);\n        prev = vld1q_lane_s32(&arr[i+3], prev, 3);\n    }\n    \n    return vmaxvq_s32(maxIndex, vdupq_n_s32(-1));\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int largestIndex = -1;\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    for (int i = 1; i < arr.size(); i+=4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcgeq_s32(current, prev);\n        uint32x2_t mask_low = vget_low_u32(mask);\n        uint32x2_t mask_high = vget_high_u32(mask);\n        uint64x2_t mask_combined = vmovl_u32(mask_low);\n        uint64x1_t mask_final = vcombine_u64(mask_combined, mask_combined);\n        uint64x2_t mask_shifted = vextq_u64(mask_final, mask_final, 1);\n        uint64x2_t mask_or = vorr_u64(mask_final, mask_shifted);\n        uint64x1_t mask_or_reduced = vpadd_u64(vget_low_u64(mask_or), vget_high_u64(mask_or));\n        uint64_t mask_result;\n        vst1_u64(&mask_result, mask_or_reduced);\n        if (mask_result == 0xFFFFFFFFFFFFFFFF) {\n            largestIndex = i + 3;\n            break;\n        }\n        prev = vld1q_s32(&arr[i+3]);\n    }\n    return largestIndex;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int maxIndex = -1;\n    int32x4_t prev = vld1q_s32(&arr[0]);\n\n    for (size_t i = 4; i < arr.size(); i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n\n        uint32x4_t cmp = vcleq_s32(curr, prev);\n        uint32x4_t shift = vshrq_n_u32(cmp, 1);\n        uint32x4_t mask = vandq_u32(cmp, shift);\n\n        uint64x2_t mask64 = vpaddlq_u32(mask);\n        uint64x1_t mask64_sum = vpadd_u64(vget_low_u64(mask64), vget_high_u64(mask64));\n\n        uint32x2_t mask32 = vreinterpret_u32_u64(mask64_sum);\n        uint32x2_t mask32_perm = vrev64_u32(mask32);\n\n        if (vget_lane_u32(mask32_perm, 0) != 0) {\n            maxIndex = i - 1;\n        }\n\n        prev = curr;\n    }\n\n    return maxIndex;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if(arr.size() < 2) return -1;\n\n    int result = -1;\n    int32x4_t prev = vld1q_s32(&arr[0]);\n    int32x4_t curr = vld1q_s32(&arr[4]);\n\n    for(size_t i = 4; i < arr.size(); i += 4){\n        int32x4_t next = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcleq_s32(curr, prev);\n        uint32x4_t mask_next = vcleq_s32(next, curr);\n        uint32x4_t mask_result = vandq_u32(mask, mask_next);\n        uint32x4_t mask_final = vandq_u32(mask_result, vdupq_n_u32(1));\n        uint32x2_t mask_final_low = vget_low_u32(mask_final);\n        uint32x2_t mask_final_high = vget_high_u32(mask_final);\n        uint32x2_t mask_final_merged = vpmax_u32(mask_final_low, mask_final_high);\n        uint32x2_t mask_final_final = vpmax_u32(mask_final_merged, mask_final_merged);\n        uint32_t result_scalar;\n        vst1_lane_u32(&result_scalar, mask_final_final, 0);\n        if(result_scalar){\n            result = i - 1;\n            break;\n        }\n        prev = curr;\n        curr = next;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int result = -1;\n    int maxIndex = -1;\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    \n    for (int i = 1; i < arr.size(); i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcleq_s32(current, prev);\n        int index = i + vgetq_lane_s32(vmaxq_s32(vandq_u32(mask, vdupq_n_u32(i)), 0), 0);\n        if (index > maxIndex) {\n            maxIndex = index;\n            result = maxIndex - 1;\n        }\n        prev = vld1q_lane_s32(&arr[i+3], prev, 3);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if(lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t largest_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t smallest_pos = vdupq_n_s32(INT_MAX);\n\n    for(size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        largest_neg = vmaxq_s32(largest_neg, vandq_s32(vec, vcltq_s32(vec, vdupq_n_s32(0))));\n        smallest_pos = vminq_s32(smallest_pos, vandq_s32(vec, vcgtq_s32(vec, vdupq_n_s32(0)));\n    }\n\n    int32x2_t result;\n    result = vpmax_s32(vget_low_s32(largest_neg), vget_high_s32(largest_neg));\n    result = vcombine_s32(result, vpmin_s32(vget_low_s32(smallest_pos), vget_high_s32(smallest_pos)));\n\n    return {vget_lane_s32(result, 0), vget_lane_s32(result, 1)};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if(lst.empty()) return {0, 0};\n\n    int32x4_t largest_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t smallest_pos = vdupq_n_s32(INT_MAX);\n\n    for(size_t i = 0; i < lst.size(); i += 4){\n        int32x4_t v = vld1q_s32(&lst[i]);\n        \n        largest_neg = vmaxq_s32(largest_neg, vandq_s32(v, vcltq_s32(v, vdupq_n_s32(0))));\n        smallest_pos = vminq_s32(smallest_pos, vandq_s32(v, vcgtq_s32(v, vdupq_n_s32(0))));\n    }\n\n    int32x2_t result;\n    result = vpmin_s32(vget_low_s32(largest_neg), vget_high_s32(largest_neg));\n    result = vpmin_s32(result, result);\n    int32_t largest = vget_lane_s32(result, 0);\n\n    result = vpmin_s32(vget_low_s32(smallest_pos), vget_high_s32(smallest_pos));\n    result = vpmin_s32(result, result);\n    int32_t smallest = vget_lane_s32(result, 0);\n\n    return {largest, smallest};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if(lst.empty()) return {0, 0};\n\n    int32x4_t max_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT_MAX);\n\n    for(size_t i = 0; i < lst.size(); i += 4){\n        int32x4_t data = vld1q_s32(&lst[i]);\n        max_neg = vmaxq_s32(max_neg, vreinterpretq_s32_u32(vcgtq_s32(data, max_neg) & vreinterpretq_u32_s32(data)));\n        min_pos = vminq_s32(min_pos, vreinterpretq_s32_u32(vcltq_s32(data, min_pos) & vreinterpretq_u32_s32(data)));\n    }\n\n    int32x2_t max_neg_pair = vpmax_s32(vget_low_s32(max_neg), vget_high_s32(max_neg));\n    int32x2_t min_pos_pair = vpmin_s32(vget_low_s32(min_pos), vget_high_s32(min_pos));\n\n    int32x2_t result = {vget_lane_s32(max_neg_pair, 0), vget_lane_s32(min_pos_pair, 0)};\n\n    return {result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if(lst.empty()) return {0, 0};\n\n    int32x4_t max_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT_MAX);\n\n    for(size_t i = 0; i < lst.size(); i += 4){\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(v, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcgtq_s32(v, vdupq_n_s32(0));\n\n        max_neg = vmaxq_s32(max_neg, vandq_s32(v, neg_mask));\n        min_pos = vminq_s32(min_pos, vandq_s32(v, pos_mask));\n    }\n\n    int32x2_t max_neg_pair = vpmax_s32(vget_low_s32(max_neg), vget_high_s32(max_neg));\n    int32x2_t min_pos_pair = vpmin_s32(vget_low_s32(min_pos), vget_high_s32(min_pos));\n\n    int32x2_t result = vcombine_s32(max_neg_pair, min_pos_pair);\n\n    std::vector<int> res(2);\n    vst1_s32(&res[0], result);\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if(lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t largest_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t smallest_pos = vdupq_n_s32(INT_MAX);\n\n    for(size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        \n        largest_neg = vmaxq_s32(v, largest_neg);\n        smallest_pos = vminq_s32(v, smallest_pos);\n    }\n\n    int32_t result[8];\n    vst1q_s32(&result[0], largest_neg);\n    vst1q_s32(&result[4], smallest_pos);\n\n    return {std::max(result[0], 0), std::min(result[4], 0)};\n}\n```  "}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorials = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i += 2) {\n        factorials = vmulq_u64(factorials, vld1q_u64(&i));\n        result = vmulq_u64(result, factorials);\n    }\n    \n    uint64_t final_result[2];\n    vst1q_u64(final_result, result);\n    \n    return final_result[0] * final_result[1];\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64x2_t result = vdupq_n_u64(1);\n    for(uint64_t i = 1; i <= n; i+=2){\n        uint64x2_t current = vmull_u32(vcreate_u64(i), vcreate_u64(i+1));\n        result = vmulq_u64(result, current);\n    }\n    uint64_t final_result = vgetq_lane_u64(result, 0) * vgetq_lane_u64(result, 1);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorials = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; i += 2) {\n        factorials = vmulq_u64(factorials, vld1q_u64(&i));\n        result = vmulq_u64(result, factorials);\n    }\n\n    uint64_t final_result[2];\n    vst1q_u64(final_result, result);\n\n    return final_result[0] * final_result[1];\n}\n```  "}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t multiplier = vdupq_n_u64(1);\n    \n    for(uint64_t i = 1; i <= n; i += 2){\n        multiplier = vmulq_u64(multiplier, vsetq_lane_u64(i, vdupq_n_u64(0), 0));\n        multiplier = vmulq_u64(multiplier, vsetq_lane_u64(i+1, vdupq_n_u64(0), 1));\n        result = vmulq_u64(result, multiplier);\n    }\n    \n    uint64_t final_result = vgetq_lane_u64(result, 0) * vgetq_lane_u64(result, 1);\n    \n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorials = vdupq_n_u64(1);\n    \n    for(uint64_t i = 1; i <= n; i += 2){\n        factorials = vmulq_u64(factorials, vld1q_u64(&i));\n        result = vmulq_u64(result, factorials);\n    }\n    \n    uint64_t final_result[2];\n    vst1q_u64(final_result, result);\n    \n    return final_result[0] * final_result[1];\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&lst[i]);\n        int32x4_t index = vdupq_n_s32(i);\n\n        uint32x4_t is_multiple_of_3 = vceqq_s32(vandq_s32(index, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t is_multiple_of_4 = vceqq_s32(vandq_s32(index, vdupq_n_s32(4)), vdupq_n_s32(0));\n\n        int32x4_t squared = vmulq_s32(input, input);\n        int32x4_t cubed = vmulq_s32(input, vmulq_s32(input, input));\n\n        int32x4_t result = vbslq_s32(is_multiple_of_3, squared, input);\n        result = vbslq_s32(is_multiple_of_4, cubed, result);\n\n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vadd_s32(sum_vec_low, sum_vec_high);\n\n    sum += vget_lane_s32(sum_vec_final, 0);\n    sum += vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for(int i = 0; i < size; i += 4){\n        int32x4_t input = vld1q_s32(&lst[i]);\n        int32x4_t index = vdupq_n_s32(i);\n\n        uint32x4_t is_multiple_of_3 = vceqq_s32(vandq_s32(index, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t is_multiple_of_4 = vceqq_s32(vandq_s32(index, vdupq_n_s32(4)), vdupq_n_s32(0));\n\n        int32x4_t squared = vmulq_s32(input, input);\n        int32x4_t cubed = vmulq_s32(input, vmulq_s32(input, input));\n\n        int32x4_t result = vbslq_s32(is_multiple_of_3, squared, input);\n        result = vbslq_s32(is_multiple_of_4, cubed, result);\n\n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vadd_s32(sum_vec_low, sum_vec_high);\n\n    sum += vget_lane_s32(sum_vec_final, 0);\n    sum += vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&lst[i]);\n        int32x4_t index = vdupq_n_s32(i);\n\n        uint32x4_t is_multiple_of_3 = vceqq_s32(vandq_s32(index, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t is_multiple_of_4 = vceqq_s32(vandq_s32(index, vdupq_n_s32(4)), vdupq_n_s32(0));\n\n        int32x4_t squared = vmulq_s32(input, input);\n        int32x4_t cubed = vmulq_s32(input, vmulq_s32(input, input));\n\n        int32x4_t result = vbslq_s32(is_multiple_of_3, squared, input);\n        result = vbslq_s32(is_multiple_of_4, cubed, result);\n\n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vadd_s32(sum_vec_low, sum_vec_high);\n    \n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&lst[i]);\n        int32x4_t index = vdupq_n_s32(i);\n\n        uint32x4_t is_multiple_of_3 = vceqq_s32(vandq_s32(index, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t is_multiple_of_4 = vceqq_s32(vandq_s32(index, vdupq_n_s32(4)), vdupq_n_s32(0));\n\n        int32x4_t square_mask = vandq_s32(is_multiple_of_3, vreinterpretq_s32_u32(is_multiple_of_3));\n        int32x4_t cube_mask = vandq_s32(vmvnq_u32(is_multiple_of_3), is_multiple_of_4);\n\n        int32x4_t squared = vmulq_s32(input, input);\n        int32x4_t cubed = vmulq_s32(input, vmulq_s32(input, input));\n\n        int32x4_t result = vaddq_s32(vandq_s32(square_mask, squared), vandq_s32(cube_mask, cubed));\n\n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vadd_s32(sum_vec_low, sum_vec_high);\n\n    sum += vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t input = vld1q_s32(&lst[i]);\n        int32x4_t mask3 = vdupq_n_s32(0);\n        int32x4_t mask4 = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; j++) {\n            if ((i + j) % 3 == 0) {\n                mask3[j] = 1;\n            }\n            if ((i + j) % 4 == 0 && (i + j) % 3 != 0) {\n                mask4[j] = 1;\n            }\n        }\n\n        int32x4_t squared = vmulq_s32(input, vreinterpretq_s32_s8(mask3));\n        int32x4_t cubed = vmulq_s32(vmulq_s32(input, input), vreinterpretq_s32_s8(mask4));\n\n        sum_vec = vaddq_s32(sum_vec, vaddq_s32(squared, cubed));\n    }\n\n    int32x2_t sum_vec_low = vget_low_s32(sum_vec);\n    int32x2_t sum_vec_high = vget_high_s32(sum_vec);\n    int32x2_t sum_vec_final = vpadd_s32(sum_vec_low, sum_vec_high);\n    sum = vget_lane_s32(sum_vec_final, 0) + vget_lane_s32(sum_vec_final, 1);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int32x4_t v_threshold = vdupq_n_s32(10);\n    int32x4_t v_odd_digits = vdupq_n_s32(0x55555555); // Odd digits mask (1, 3, 5, 7, 9)\n    \n    for (size_t i = 0; i < nums.size(); i += 4) {\n        int32x4_t v_nums = vld1q_s32(&nums[i]);\n        \n        uint32x4_t v_first_digit = vabsq_s32(vandq_s32(v_nums, vdupq_n_s32(0xF))); // Extract first digit\n        uint32x4_t v_last_digit = vabsq_s32(vshrq_n_s32(v_nums, 28)); // Extract last digit\n        \n        uint32x4_t v_odd_first_digit = vandq_u32(v_first_digit, v_odd_digits);\n        uint32x4_t v_odd_last_digit = vandq_u32(v_last_digit, v_odd_digits);\n        \n        uint32x4_t v_odd_both_digits = vandq_u32(v_odd_first_digit, v_odd_last_digit);\n        \n        uint32x4_t v_greater_than_10 = vcgtq_s32(v_nums, v_threshold);\n        \n        uint32x4_t v_result = vandq_u32(v_odd_both_digits, v_greater_than_10);\n        \n        count += vaddvq_u32(v_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int32x4_t v_threshold = vdupq_n_s32(10);\n    int32x4_t v_odd_digits = vdupq_n_s32(0x55555555); // Odd digits: 1, 3, 5, 7, 9\n    \n    for (size_t i = 0; i < nums.size(); i += 4) {\n        int32x4_t v_nums = vld1q_s32(&nums[i]);\n        \n        uint32x4_t v_first_digit = vandq_u32(vabsq_s32(v_nums), vdupq_n_u32(0xF));\n        uint32x4_t v_last_digit = vandq_u32(vabsq_s32(vrev32q_s32(v_nums)), vdupq_n_u32(0xF));\n        \n        uint32x4_t v_first_digit_odd = vandq_u32(v_first_digit, v_odd_digits);\n        uint32x4_t v_last_digit_odd = vandq_u32(v_last_digit, v_odd_digits);\n        \n        uint32x4_t v_both_digits_odd = vandq_u32(v_first_digit_odd, v_last_digit_odd);\n        \n        uint32x4_t v_greater_than_10 = vcgtq_s32(v_nums, v_threshold);\n        \n        uint32x4_t v_result = vandq_u32(v_both_digits_odd, v_greater_than_10);\n        \n        count += vaddvq_u32(v_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int32x4_t v_threshold = vdupq_n_s32(10);\n    int32x4_t v_odd_digits = vdupq_n_s32(0x55555555); // Odd digits: 1, 3, 5, 7, 9\n    \n    for (size_t i = 0; i < nums.size(); i += 4) {\n        int32x4_t v_nums = vld1q_s32(&nums[i]);\n        \n        uint32x4_t v_first_digit = vandq_u32(v_nums, vdupq_n_u32(0xF));\n        uint32x4_t v_last_digit = vandq_u32(vshrq_n_u32(v_nums, 28), vdupq_n_u32(0xF));\n        \n        uint32x4_t v_first_digit_odd = vceqq_u32(vandq_u32(v_first_digit, v_odd_digits), v_odd_digits);\n        uint32x4_t v_last_digit_odd = vceqq_u32(vandq_u32(v_last_digit, v_odd_digits), v_odd_digits);\n        \n        uint32x4_t v_both_digits_odd = vandq_u32(v_first_digit_odd, v_last_digit_odd);\n        \n        uint32x4_t v_greater_than_10 = vcgtq_s32(v_nums, v_threshold);\n        \n        uint32x4_t v_result = vandq_u32(v_both_digits_odd, v_greater_than_10);\n        \n        count += vaddvq_u32(v_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int32x4_t v_threshold = vdupq_n_s32(10);\n    int32x4_t v_odd_digits = vdupq_n_s32(0x55555555); // Odd digits: 1, 3, 5, 7, 9\n    \n    for (size_t i = 0; i < nums.size(); i += 4) {\n        int32x4_t v_nums = vld1q_s32(&nums[i]);\n        \n        uint32x4_t v_first_digit = vandq_u32(v_nums, vdupq_n_u32(0xF));\n        uint32x4_t v_last_digit = vandq_u32(vshrq_n_u32(v_nums, 28), vdupq_n_u32(0xF));\n        \n        uint32x4_t v_first_digit_odd = vceqq_u32(vandq_u32(v_first_digit, v_odd_digits), v_odd_digits);\n        uint32x4_t v_last_digit_odd = vceqq_u32(vandq_u32(v_last_digit, v_odd_digits), v_odd_digits);\n        \n        uint32x4_t v_both_digits_odd = vandq_u32(v_first_digit_odd, v_last_digit_odd);\n        \n        uint32x4_t v_greater_than_10 = vcgtq_s32(v_nums, v_threshold);\n        \n        uint32x4_t v_result = vandq_u32(v_both_digits_odd, v_greater_than_10);\n        \n        count += vaddvq_u32(v_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int32x4_t v_threshold = vdupq_n_s32(10);\n    int32x4_t v_odd_digits = vdupq_n_s32(0x55555555); // Odd digits: 1, 3, 5, 7, 9\n    \n    for (size_t i = 0; i < nums.size(); i += 4) {\n        int32x4_t v_nums = vld1q_s32(&nums[i]);\n        \n        uint32x4_t v_first_digit = vandq_u32(v_nums, vdupq_n_u32(0xF));\n        uint32x4_t v_last_digit = vandq_u32(v_nums, vdupq_n_u32(0xF0));\n        \n        uint32x4_t v_first_digit_odd = vceqq_u32(vandq_u32(v_first_digit, v_odd_digits), v_odd_digits);\n        uint32x4_t v_last_digit_odd = vceqq_u32(vandq_u32(v_last_digit, v_odd_digits), v_odd_digits);\n        \n        int32x4_t v_greater_than_10 = vcgtq_s32(v_nums, v_threshold);\n        \n        uint32x4_t v_both_odd_digits = vandq_u32(v_first_digit_odd, v_last_digit_odd);\n        \n        uint32x4_t v_result = vandq_u32(v_greater_than_10, v_both_odd_digits);\n        \n        count += vaddvq_u32(v_result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64x2_t sum_mod3 = vdupq_n_u64(0);\n    uint64_t count = 0;\n\n    for (uint64_t i = 1; i <= n; i += 2) {\n        uint64x2_t a = vmulq_n_u64(vaddq_u64(vdupq_n_u64(i), vdupq_n_u64(1)), i);\n        sum_mod3 = vaddq_u64(sum_mod3, vandq_u64(a, vdupq_n_u64(3)));\n        count += vgetq_lane_u64(vaddq_u64(vaddq_u64(vget_low_u64(a), vget_high_u64(a)), vdupq_n_u64(1)), 0) % 3 == 0;\n    }\n\n    return count + vgetq_lane_u64(vaddq_u64(vget_low_u64(sum_mod3), vget_high_u64(sum_mod3)), 0) / 3;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64x2_t sum_mod3 = vdupq_n_u64(0);\n    uint64_t count = 0;\n\n    for (uint64_t i = 1; i <= n; i += 2) {\n        uint64x2_t idx = {i, i + 1};\n        uint64x2_t val = vmulq_u64(idx, vsubq_u64(idx, vdupq_n_u64(1)));\n        val = vaddq_u64(val, vdupq_n_u64(1));\n        sum_mod3 = vaddq_u64(sum_mod3, vandq_u64(val, vdupq_n_u64(3)));\n\n        if (i % 3 == 0) {\n            count += vgetq_lane_u64(vaddq_u64(vaddq_u64(sum_mod3, vextq_u64(sum_mod3, sum_mod3, 1)), sum_mod3), 0);\n            sum_mod3 = vdupq_n_u64(0);\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64x2_t sum_mod3 = vdupq_n_u64(0);\n    uint64_t count = 0;\n\n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t indices = vaddq_u64(vdupq_n_u64(i), vdupq_n_u64(1));\n        uint64x2_t values = vmlaq_u64(indices, vsubq_u64(indices, vdupq_n_u64(1)), vdupq_n_u64(1));\n\n        sum_mod3 = vaddq_u64(sum_mod3, vandq_u64(values, vdupq_n_u64(3)));\n\n        if (i % 3 == 1) {\n            count += vaddvq_u64(vceqq_u64(sum_mod3, vdupq_n_u64(0xFFFFFFFFFFFFFFFF)));\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64x2_t sum_mod3 = vdupq_n_u64(0);\n    uint64_t count = 0;\n\n    for (uint64_t i = 1; i <= n; i += 2) {\n        uint64x2_t a = vmulq_n_u64(vaddq_u64(vdupq_n_u64(i), vdupq_n_u64(1)), i);\n        sum_mod3 = vaddq_u64(sum_mod3, vandq_u64(a, vdupq_n_u64(3)));\n        count += (i + 1 <= n);\n    }\n\n    uint64_t sum_mod3_arr[2];\n    vst1q_u64(sum_mod3_arr, sum_mod3);\n    count += (sum_mod3_arr[0] == 0 && sum_mod3_arr[1] == 0);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64x2_t sum_mod3 = vdupq_n_u64(0);\n    uint64_t count = 0;\n\n    for (uint64_t i = 1; i <= n; i += 2) {\n        uint64x2_t idx = {i, i + 1};\n        uint64x2_t val = vmulq_n_u64(idx, i);\n        val = vsubq_n_u64(val, i - 1);\n\n        sum_mod3 = vaddq_u64(sum_mod3, vandq_u64(val, vdupq_n_u64(3)));\n\n        if (i % 3 == 0) {\n            count += i / 3;\n        }\n    }\n\n    uint64_t sum_mod3_arr[2];\n    vst1q_u64(sum_mod3_arr, sum_mod3);\n\n    count += (sum_mod3_arr[0] + sum_mod3_arr[1]) / 3;\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    int result;\n    uint32x4_t prime_mask = vdupq_n_u32(1);\n    uint32x4_t non_prime_mask = vdupq_n_u32(0);\n    \n    for(int i = 2; i <= n/2; ++i){\n        if(n % i == 0){\n            return y;\n        }\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    int result;\n    uint32x4_t prime_mask = vdupq_n_u32(1);\n    uint32x4_t non_prime_mask = vdupq_n_u32(0);\n    \n    for(int i = 2; i <= n / 2; ++i){\n        if(n % i == 0){\n            result = y;\n            break;\n        }\n    }\n    \n    if(i > n / 2){\n        result = x;\n    }\n    \n    uint32x4_t result_vec = vdupq_n_u32(result);\n    uint32x4_t final_result = vbslq_u32(prime_mask, result_vec, non_prime_mask);\n    \n    return vgetq_lane_u32(final_result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    int result;\n    uint32x4_t prime_mask = vdupq_n_u32(1);\n    uint32x4_t non_prime_mask = vdupq_n_u32(0);\n    \n    for(int i = 2; i <= n / 2; ++i){\n        if(n % i == 0){\n            return y;\n        }\n    }\n    \n    result = x;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    int result;\n    uint32x4_t prime_mask = vdupq_n_u32(1);\n    uint32x4_t non_prime_mask = vdupq_n_u32(0);\n\n    for(int i = 2; i <= n/2; i++){\n        if(n % i == 0){\n            return y;\n        }\n    }\n\n    result = (n > 1) ? x : y;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    int result;\n    uint32x4_t prime_mask = vdupq_n_u32(1);\n    uint32x4_t non_prime_mask = vdupq_n_u32(0);\n\n    for(int i = 2; i <= n / 2; i++){\n        if(n % i == 0){\n            return y;\n        }\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    float32x4_t vec = vld1q_f32(lst.data());\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        float32x4_t values = vld1q_f32(lst.data() + i);\n        uint32x4_t mask = vandq_u32(vcgtq_f32(values, vdupq_n_f32(0)), vceqq_f32(vcvtnq_s32_f32(values), vcvtq_f32_s32(vcvtnq_s32_f32(values))));\n        float32x4_t odd_values = vbslq_f32(mask, values, vdupq_n_f32(0));\n        float32x4_t squares = vmulq_f32(odd_values, odd_values);\n        sum = vaddw_u32(sum, vmovn_u32(vcvtq_u32_f32(squares)));\n    }\n    \n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t mask = vdupq_n_u32(0x80000000);\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_odd = vandq_u32(vceqq_f32(vcvtq_u32_f32(vec), vcvtq_u32_f32(vabsq_f32(vec))), mask);\n        uint32x4_t is_positive = vcltq_f32(vec, vdupq_n_f32(0));\n        uint32x4_t is_integer = vceqq_f32(vec, vcvtq_f32_u32(vcvtq_u32_f32(vec)));\n        uint32x4_t valid = vandq_u32(vmvnq_u32(is_positive), is_integer);\n        uint32x4_t valid_odd = vandq_u32(valid, is_odd);\n        float32x4_t valid_odd_squared = vmulq_f32(vcvtq_f32_u32(valid_odd), vcvtq_f32_u32(valid_odd));\n        sum = vaddw_u32(sum, vreinterpretq_u64_f32(valid_odd_squared));\n    }\n    \n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    float32x4_t vec = vld1q_f32(lst.data());\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        float32x4_t values = vld1q_f32(lst.data() + i);\n        uint32x4_t mask = vandq_u32(vcgtq_f32(values, vdupq_n_f32(0)), vceqq_f32(vmulq_n_f32(values, 2), vcvtq_f32_u32(vcvtq_n_u32_f32(values))));\n        uint32x4_t odd_mask = vandq_u32(mask, vreinterpretq_u32_u8(vandq_u8(vreinterpretq_u8_u32(vmvnq_u32(vreinterpretq_u32_u8(vreinterpretq_u8_u32(vshrq_n_u32(vreinterpretq_u32_u8(vreinterpretq_u8_u32(mask)), 1)))), vdupq_n_u8(0x80))));\n        float32x4_t odd_values = vbslq_f32(vreinterpretq_u32_u8(odd_mask), values, vdupq_n_f32(0));\n        float32x4_t squares = vmulq_f32(odd_values, odd_values);\n        sum = vaddw_u32(sum, vreinterpretq_u32_f32(squares));\n    }\n    \n    return vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t mask = vdupq_n_u32(0x80000000);\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_odd = vandq_u32(vcvtq_u32_f32(vec), mask);\n        uint32x4_t is_positive = vcltq_f32(vec, vdupq_n_f32(0));\n        uint32x4_t is_integer = vceqq_f32(vcvtq_f32_u32(vcvtq_u32_f32(vec)), vec);\n        uint32x4_t valid = vandq_u32(vandq_u32(vmvnq_u32(is_positive), vmvnq_u32(is_integer)), is_odd);\n        float32x4_t valid_values = vbslq_f32(valid, vec, vdupq_n_f32(0));\n        float32x4_t squares = vmulq_f32(valid_values, valid_values);\n        uint64x2_t squares_sum = vpaddlq_u32(vcvtq_u32_f32(squares));\n        sum = vaddq_u64(sum, vpaddlq_u32(squares_sum));\n    }\n    \n    uint64x2_t result = vpaddq_u64(sum, sum);\n    return vgetq_lane_u64(result, 0) + vgetq_lane_u64(result, 1);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64x2_t sum = vdupq_n_u64(0);\n    uint32x4_t mask_odd = vdupq_n_u32(0x80000000);\n    uint32x4_t mask_int = vdupq_n_u32(0x7F800000);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_odd = vandq_u32(vreinterpretq_u32_f32(vec), mask_odd);\n        uint32x4_t is_int = vceqq_u32(vreinterpretq_u32_f32(vcvtq_f32_s32(vcvtq_s32_f32(vec))), vreinterpretq_u32_f32(vec));\n        uint32x4_t valid = vandq_u32(is_odd, is_int);\n        float32x4_t squared = vmulq_f32(vec, vec);\n        float32x4_t valid_squared = vbslq_f32(valid, squared, zero);\n        sum = vaddw_u32(sum, vreinterpretq_u32_f32(valid_squared));\n    }\n\n    uint64x2_t sum_final = vpaddlq_u32(sum);\n    return vgetq_lane_u64(sum_final, 0) + vgetq_lane_u64(sum_final, 1);\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    int32x4_t game_vec, guess_vec, diff_vec, result_vec;\n    for (size_t i = 0; i < size; i += 4) {\n        game_vec = vld1q_s32(&game[i]);\n        guess_vec = vld1q_s32(&guess[i]);\n        diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    int32x4_t game_vec, guess_vec, diff_vec, result_vec;\n    for (size_t i = 0; i < size; i += 4) {\n        game_vec = vld1q_s32(&game[i]);\n        guess_vec = vld1q_s32(&guess[i]);\n        diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    int32x4_t game_vec, guess_vec, diff_vec, result_vec;\n    for (size_t i = 0; i < size; i += 4) {\n        game_vec = vld1q_s32(&game[i]);\n        guess_vec = vld1q_s32(&guess[i]);\n        diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    int32x4_t game_vec, guess_vec, diff_vec, abs_diff_vec;\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        game_vec = vld1q_s32(&game[i]);\n        guess_vec = vld1q_s32(&guess[i]);\n\n        diff_vec = vsubq_s32(game_vec, guess_vec);\n        abs_diff_vec = vabsq_s32(diff_vec);\n\n        vst1q_s32(&result[i], abs_diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    int32x4_t game_vec, guess_vec, diff_vec, result_vec;\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        game_vec = vld1q_s32(&game[i]);\n        guess_vec = vld1q_s32(&guess[i]);\n\n        diff_vec = vabdq_s32(game_vec, guess_vec);\n        result_vec = vreinterpretq_s32_u32(vceqq_s32(diff_vec, zero_vec));\n\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}

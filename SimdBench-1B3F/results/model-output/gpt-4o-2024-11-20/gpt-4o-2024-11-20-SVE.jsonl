{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t index = 0;\n\n    while (index < length) {\n        // Determine the vector length dynamically\n        svbool_t pg = svwhilelt_b64(index, length);\n\n        // Load the mask values into a predicate register\n        svbool_t mask_pg = svld1_b8(pg, (const uint8_t *)&mask[index]);\n\n        // Load the source values\n        svint64_t src_vec = svld1_s64(pg, &src[index]);\n\n        // Conditionally store values from src to dst based on the mask\n        svst1_s64(svsel(mask_pg, pg, svdup_s64(0)), &dst[index], src_vec);\n\n        // Increment the index by the vector length\n        index += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load elements from src and mask arrays\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1_b8(pg, &mask[i]);\n\n        // Conditionally store elements from src to dst based on mask\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n\n        // Increment the index by the vector length\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Determine the vector length dynamically\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load elements from src and mask\n        svint64_t src_vec = svld1_s64(pg, &src[i]);\n        svbool_t mask_vec = svld1_b8(pg, &mask[i]);\n\n        // Conditionally store elements from src to dst based on mask\n        svst1_s64(pg, &dst[i], svsel_s64(mask_vec, src_vec, svld1_s64(pg, &dst[i])));\n\n        // Increment the index by the vector length\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        // Load elements from src and mask arrays\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1_b8(pg, (const uint8_t *)&mask[i]);\n\n        // Conditionally store elements into dst based on the mask\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n\n        // Increment the index by the vector length\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b64(i, length))) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svint64_t dst_vec = svld1(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b(pg, &mask[i]);\n\n        dst_vec = svsel(mask_vec, src_vec, dst_vec);\n        svst1(pg, &dst[i], dst_vec);\n\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhile32_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src\n        svint32_t vec_src = svld1_s32(pg, &src[i]);\n\n        // Perform calculations\n        svint32_t vec_scaled = svmul_s32_x(pg, vec_src, svdup_s32(scale));\n        svint32_t tmp1 = svrshl_s32_x(pg, vec_scaled, svdup_s32(-3)); // Right shift by 3\n        svint32_t tmp2 = svlsl_s32_x(pg, vec_scaled, svdup_s32(3));  // Left shift by 3\n        svint32_t tmp_product = svmul_s32_x(pg, tmp1, tmp2);\n        svint32_t vec_result = svdiv_s32_x(pg, svadd_s32_x(pg, vec_scaled, tmp_product), svdup_s32(7));\n\n        // Store results in dst\n        svst1_s32(pg, &dst[i], vec_result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhile32_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhile32_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Perform element * scale\n        svint32_t scaled_vec = svmul_s32_x(pg, src_vec, svdup_s32(scale));\n\n        // Calculate tmp1: (element * scale) >> 3\n        svint32_t tmp1 = svrshr_n_s32_x(pg, scaled_vec, 3);\n\n        // Calculate tmp2: (element * scale) << 3\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled_vec, 3);\n\n        // Calculate final result: (element * scale + tmp1 * tmp2) / 7\n        svint32_t tmp1_tmp2_mul = svmul_s32_x(pg, tmp1, tmp2);\n        svint32_t final_result = svadd_s32_x(pg, scaled_vec, tmp1_tmp2_mul);\n        final_result = svdiv_s32_x(pg, final_result, svdup_s32(7));\n\n        // Store results in dst\n        svst1_s32(pg, &dst[i], final_result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhile32_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        // Load elements from src\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Perform element * scale\n        svint32_t scaled_vec = svmul_n_s32_z(pg, src_vec, scale);\n\n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t tmp1 = svasr_n_s32_z(pg, scaled_vec, 3);\n\n        // Calculate tmp2 = (element * scale) << 3\n        svint32_t tmp2 = svlsl_n_s32_z(pg, scaled_vec, 3);\n\n        // Calculate tmp1 * tmp2\n        svint32_t tmp1_tmp2 = svmul_s32_z(pg, tmp1, tmp2);\n\n        // Calculate (element * scale + tmp1 * tmp2)\n        svint32_t result = svadd_s32_z(pg, scaled_vec, tmp1_tmp2);\n\n        // Divide by 7\n        result = svdiv_s32_z(pg, result, svdup_n_s32(7));\n\n        // Store the result in dst\n        svst1_s32(pg, &dst[i], result);\n\n        // Increment index\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhile32_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src\n        svint32_t src_vec = svld1(pg, &src[i]);\n\n        // Perform element * scale\n        svint32_t scaled_vec = svmul_s32_x(pg, src_vec, svdup_s32(scale));\n\n        // Calculate tmp1: (element * scale) >> 3\n        svint32_t tmp1 = svrshr_n_s32_x(pg, scaled_vec, 3);\n\n        // Calculate tmp2: (element * scale) << 3\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled_vec, 3);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        svint32_t tmp_product = svmul_s32_x(pg, tmp1, tmp2);\n        svint32_t result = svadd_s32_x(pg, scaled_vec, tmp_product);\n        result = svdiv_s32_x(pg, result, svdup_s32(7));\n\n        // Store results in dst\n        svst1(pg, &dst[i], result);\n\n        // Update loop index and predicate\n        i += svcntw();\n        pg = svwhile32_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements in the loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Perform element * scale\n        svint32_t scaled_vec = svmul_s32_x(pg, src_vec, svdup_n_s32(scale));\n\n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t tmp1 = svasr_n_s32_x(pg, scaled_vec, 3);\n\n        // Calculate tmp2 = (element * scale) << 3\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled_vec, 3);\n\n        // Calculate tmp1 * tmp2\n        svint32_t tmp1_tmp2 = svmul_s32_x(pg, tmp1, tmp2);\n\n        // Calculate final result: (element * scale + tmp1 * tmp2) / 7\n        svint32_t result = svadd_s32_x(pg, scaled_vec, tmp1_tmp2);\n        result = svdiv_s32_x(pg, result, svdup_n_s32(7));\n\n        // Store the result in dst\n        svst1_s32(pg, &dst[i], result);\n\n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    svbool_t pg = svwhilelt_b64(r, rows); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Calculate the indices for the strided load\n        svuint64_t indices = svindex_u64(0, 1); // Generate indices [0, 1, 2, ...]\n        indices = svmul_n_u64_x(pg, indices, cols); // Multiply by cols\n        indices = svadd_n_u64_x(pg, indices, stride); // Add stride to each index\n        indices = svadd_n_u64_x(pg, indices, r); // Offset by current row index\n\n        // Perform strided load from src\n        svfloat64_t src_values = svld1_gather_u64index(pg, src, indices);\n\n        // Store the loaded values into dst\n        svst1(pg, &dst[r], src_values);\n\n        // Update row index\n        r += svcntd();\n        pg = svwhilelt_b64(r, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    svbool_t pg = svwhilelt_b64(r, rows); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Calculate the indices for the elements to load\n        svuint64_t indices = svindex_u64(0, 1); // Vector of indices [0, 1, 2, ...]\n        indices = svadd_u64_z(pg, indices, svdup_u64(r)); // Add current row offset\n        indices = svmul_u64_z(pg, indices, svdup_u64(cols)); // Multiply by cols\n        indices = svadd_u64_z(pg, indices, svdup_u64(stride)); // Add stride offset\n\n        // Load elements from src using calculated indices\n        svfloat64_t src_values = svld1_gather_u64index_f64(pg, src, indices);\n\n        // Store the loaded values into dst\n        svst1_f64(pg, &dst[r], src_values);\n\n        // Update row index and predicate\n        r += svcntd();\n        pg = svwhilelt_b64(r, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    svbool_t pg = svwhilelt_b64(r, rows); // Predicate for active elements in the loop\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Calculate the indices for the strided load\n        svuint64_t indices = svindex_u64(0, 1); // Generate indices [0, 1, 2, ...]\n        indices = svmul_u64_x(pg, indices, cols); // Multiply indices by cols\n        indices = svadd_u64_x(pg, indices, svdup_u64(stride)); // Add stride to indices\n\n        // Perform strided load\n        svfloat64_t src_values = svld1_gather_u64index(pg, src, indices);\n\n        // Store the values into the destination array\n        svst1(pg, &dst[r], src_values);\n\n        // Update row index\n        r += svcntd(); // Move to the next set of rows\n        pg = svwhilelt_b64(r, rows); // Update predicate for remaining rows\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    svbool_t pg = svwhilelt_b64(r, rows); // Predicate for active elements\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Calculate the indices for strided access\n        svuint64_t indices = svindex_u64(0, 1); // Generate indices [0, 1, 2, ...]\n        indices = svmul_n_u64_x(pg, indices, cols); // Multiply indices by cols\n        indices = svadd_n_u64_x(pg, indices, stride); // Add stride to indices\n\n        // Load elements from src using calculated indices\n        svfloat64_t src_values = svld1_gather_u64index(pg, src, indices);\n\n        // Store the loaded values into dst\n        svst1(pg, dst + r, src_values);\n\n        // Update row index\n        r += svcntd(); // Move to the next set of rows\n        pg = svwhilelt_b64(r, rows); // Update predicate for remaining rows\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    svbool_t pg = svwhilelt_b64(r, rows); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Calculate the indices for strided access\n        svuint64_t indices = svindex_u64(r * cols + stride, cols);\n        \n        // Load elements from src using strided indices\n        svfloat64_t data = svld1_gather_u64index(pg, src, indices);\n        \n        // Store the loaded elements into dst\n        svst1(pg, dst + r, data);\n        \n        // Update row index\n        r += svcntd();\n        pg = svwhilelt_b64(r, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation: Copy values from src to dst using indices as lookups\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, indices + i); // Load indices\n        svfloat32_t gathered_values = svld1_gather_index(pg, src, index_vec); // Gather values from src\n        svst1(pg, dst + i, gathered_values); // Store gathered values to dst\n        i += svcntw();\n    }\n\n    i = 0;\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, indices + i); // Load indices\n        svfloat32_t src_values = svld1(pg, src + i); // Load values from src\n        svst1_scatter_index(pg, dst, index_vec, src_values); // Scatter values to dst\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation: Copy values from src to dst using indices as lookups\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, &indices[i]); // Load indices\n        svfloat32_t src_vec = svld1(pg, src);        // Load source values\n        svfloat32_t gathered_vec = svld1_gather_index(pg, src, index_vec); // Gather operation\n        svst1(pg, &dst[i], gathered_vec);           // Store gathered values to destination\n        i += svcntw();\n    }\n\n    i = 0;\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, &indices[i]); // Load indices\n        svfloat32_t src_vec = svld1(pg, &src[i]);     // Load source values\n        svst1_scatter_index(pg, dst, index_vec, src_vec); // Scatter operation\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Process in chunks of SVE vector length\n    while (i < length) {\n        // Determine the active vector length for this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load indices\n        svint32_t index_vec = svld1(pg, &indices[i]);\n\n        // Gather operation: Load values from src using indices and store in dst\n        svfloat32_t gathered_values = svld1_gather_index(pg, src, index_vec);\n        svst1(pg, &dst[i], gathered_values);\n\n        // Scatter operation: Store values from src into dst using indices\n        svscatter_index(pg, dst, index_vec, svld1(pg, &src[i]));\n\n        // Increment the loop counter by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: Load values from src using indices and store them in dst\n        svint32_t index_vec = svld1(pg, indices + i);\n        svfloat32_t gathered_values = svld1_gather_index(pg, src, index_vec);\n        svst1(pg, dst + i, gathered_values);\n\n        // Scatter operation: Store values from src into dst using indices as write locations\n        svscatter_index(pg, dst, index_vec, svld1(pg, src + i));\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation: Copy values from src to dst using indices as lookups\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, &indices[i]);\n        svfloat32_t gathered_values = svld1_gather_index(pg, src, index_vec);\n        svst1(pg, &dst[i], gathered_values);\n        i += svcntw();\n    }\n\n    i = 0;\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    while ((pg = svwhilelt_b32(i, length))) {\n        svint32_t index_vec = svld1(pg, &indices[i]);\n        svfloat32_t src_values = svld1(pg, &src[i]);\n        svst1_scatter_index(pg, dst, index_vec, src_values);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        svbool_t pg_left = svwhilelt_b16(left, right + 1);\n        svbool_t pg_right = svwhilelt_b16(right, left - 1);\n\n        svint16_t vec_left = svld1(pg_left, &arr[left]);\n        svint16_t vec_right = svld1(pg_right, &arr[right - svcntw() + 1]);\n\n        svst1(pg_left, &arr[left], vec_right);\n        svst1(pg_right, &arr[right - svcntw() + 1], vec_left);\n\n        left += svcntw();\n        right -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        // Determine the vector length for the current iteration\n        svbool_t pg_left = svwhilelt_b16(left, right + 1);\n        svbool_t pg_right = svwhilelt_b16(right, left - 1);\n\n        // Load vectors from both ends\n        svint16_t vec_left = svld1(pg_left, &arr[left]);\n        svint16_t vec_right = svld1(pg_right, &arr[right - svcntw() + 1]);\n\n        // Store swapped vectors\n        svst1(pg_left, &arr[left], svrev_b16(vec_right));\n        svst1(pg_right, &arr[right - svcntw() + 1], svrev_b16(vec_left));\n\n        // Update indices\n        left += svcntw();\n        right -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        svbool_t pg = svwhilelt_b16(left, right + 1);\n\n        svuint64_t left_indices = svindex_u64(left, 1);\n        svuint64_t right_indices = svindex_u64(right, -1);\n\n        svint16_t left_values = svld1_gather_u64(pg, arr, left_indices);\n        svint16_t right_values = svld1_gather_u64(pg, arr, right_indices);\n\n        svst1_scatter_u64(pg, arr, left_indices, right_values);\n        svst1_scatter_u64(pg, arr, right_indices, left_values);\n\n        left += svcntp_b16(pg, pg);\n        right -= svcntp_b16(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        svbool_t pg = svwhilelt_b16(left, right + 1);\n\n        svuint64_t left_indices = svindex_u64(left, 1);\n        svuint64_t right_indices = svindex_u64(right, -1);\n\n        svint16_t left_values = svld1_s16(pg, &arr[left]);\n        svint16_t right_values = svld1_s16(pg, &arr[right - svcntw() + 1]);\n\n        svst1_s16(pg, &arr[left], right_values);\n        svst1_s16(pg, &arr[right - svcntw() + 1], left_values);\n\n        left += svcntw();\n        right -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        // Determine the vector length for the current iteration\n        svbool_t pg_left = svwhilelt_b16(left, right + 1);\n        svbool_t pg_right = svwhilelt_b16(right, left - 1);\n\n        // Load elements from the left and right sides\n        svint16_t vec_left = svld1(pg_left, &arr[left]);\n        svint16_t vec_right = svld1(pg_right, &arr[right - svcntw() + 1]);\n\n        // Reverse the right vector\n        svint16_t vec_right_reversed = svrev_b16(vec_right);\n\n        // Store the reversed vectors back to their respective positions\n        svst1(pg_left, &arr[left], vec_left);\n        svst1(pg_right, &arr[right - svcntw() + 1], vec_right_reversed);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]);\n        svst1(pg, &slice[i], vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2; // Offset to the start of the slice in the flattened tensor\n    size_t total_elements = dim1 * dim2;          // Total elements in the 2D slice\n    size_t i = 0;\n\n    // Use SVE to copy the slice in parallel\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements); // Predicate for active elements\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]); // Load elements from the tensor\n        svst1(pg, &slice[i], vec); // Store elements into the slice\n        i += svcntb(); // Advance by the number of bytes processed in this iteration\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2; // Offset to the start of the slice in the flattened tensor\n    size_t total_elements = dim1 * dim2;          // Total elements in the 2D slice\n    size_t i = 0;\n\n    // Use SVE to load and store data in chunks\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements); // Predicate for active elements\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]); // Load a vector of elements\n        svst1(pg, &slice[i], vec); // Store the vector into the slice\n        i += svcntb(); // Advance by the number of bytes processed in this iteration\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2; // Offset to the start of the slice in the 1D tensor array\n    size_t total_elements = dim1 * dim2;          // Total number of elements in the 2D slice\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements); // Predicate for active elements in the vector\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]); // Load elements from the tensor\n        svst1(pg, &slice[i], vec);                           // Store elements into the slice\n        i += svcntb();                                       // Increment index by vector length\n        pg = svwhilelt_b8(i, total_elements);                // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svbool_t pg = svptrue_b8(); // Predicate for active lanes\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]); // Load tensor elements\n        svst1(pg, &slice[i], vec);                           // Store into slice\n        i += svcntb();                                       // Increment by vector length\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size <= rows) ? block_size : rows - i;\n            size_t block_cols = (j + block_size <= cols) ? block_size : cols - j;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                size_t src_index = (i + bi) * cols + j;\n                size_t dst_index = j * rows + (i + bi);\n\n                svbool_t pg = svwhilelt_b16(0, block_cols);\n                size_t offset = 0;\n\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[src_index + offset]);\n                    svst1(pg, &dst[dst_index + offset * rows], vec);\n\n                    offset += svcntw();\n                    pg = svwhilelt_b16(offset, block_cols);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = i + block_size > rows ? rows : i + block_size;\n            size_t block_col_end = j + block_size > cols ? cols : j + block_size;\n\n            for (size_t bi = i; bi < block_row_end; bi++) {\n                size_t src_offset = bi * cols + j;\n                size_t dst_offset = j * rows + bi;\n\n                svbool_t pg = svwhilelt_b16(j, block_col_end);\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[src_offset]);\n                    svst1(pg, &dst[dst_offset], vec);\n\n                    src_offset += svcntw();\n                    dst_offset += svcntw() * rows;\n                    pg = svwhilelt_b16(src_offset % cols, block_col_end);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = (i + block_size > rows) ? rows : i + block_size;\n            size_t block_col_end = (j + block_size > cols) ? cols : j + block_size;\n\n            for (size_t bi = i; bi < block_row_end; ++bi) {\n                size_t src_offset = bi * cols + j;\n                size_t dst_offset = j * rows + bi;\n\n                svbool_t pg = svwhilelt_b16(j, block_col_end);\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[src_offset]);\n                    svst1(pg, &dst[dst_offset], vec);\n\n                    src_offset += svcntw();\n                    dst_offset += svcntw() * rows;\n                    pg = svwhilelt_b16(src_offset % cols, block_col_end);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                size_t src_index = (i + bi) * cols + j;\n                size_t dst_index = j * rows + (i + bi);\n\n                svbool_t pg = svwhilelt_b16_u32(0, block_cols);\n                size_t offset = 0;\n\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[src_index + offset]);\n                    svst1(pg, &dst[dst_index + offset * rows], vec);\n                    offset += svcntw();\n                    pg = svwhilelt_b16_u32(offset, block_cols);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = (i + block_size > rows) ? rows : i + block_size;\n            size_t block_col_end = (j + block_size > cols) ? cols : j + block_size;\n\n            for (size_t bi = i; bi < block_row_end; ++bi) {\n                size_t bj = j;\n                svbool_t pg = svwhilelt_b16(bj, block_col_end);\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[bi * cols + bj]);\n                    svst1(pg, &dst[bj * rows + bi], vec);\n                    bj += svcntw();\n                    pg = svwhilelt_b16(bj, block_col_end);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t diagonal_count = dim; // Number of diagonal elements\n    svfloat32_t sum_vec = svdup_f32(0.0f); // Initialize vector sum to 0\n\n    for (size_t i = 0; i < diagonal_count; i += svcntw()) {\n        // Create a predicate for the active elements in this iteration\n        svbool_t pg = svwhilelt_b32(i, diagonal_count);\n\n        // Calculate the index of the diagonal element in the flattened array\n        svuint32_t indices = svmul_n_u32_z(pg, svindex_u32(i, 1), dim * dim + dim + 1);\n\n        // Load the diagonal elements into a vector\n        svfloat32_t diag_elements = svld1_gather_u32index_f32(pg, array, indices);\n\n        // Accumulate the sum\n        sum_vec = svadd_f32_m(pg, sum_vec, diag_elements);\n    }\n\n    // Horizontally reduce the vector sum to a scalar\n    float result = svaddv_f32(svptrue_b32(), sum_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n\n    // Iterate over the diagonal elements\n    while (i < dim) {\n        // Load diagonal elements into vector\n        svfloat32_t vec = svld1(pg, &array[i * dim * dim + i * dim + i]);\n\n        // Perform horizontal addition of vector elements\n        sum += svaddv(pg, vec);\n\n        // Increment index for next diagonal element\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t diag_count = dim; // Number of diagonal elements\n    float sum = 0.0f;\n\n    svbool_t pg = svwhilelt_b32(0, diag_count); // Predicate for active elements\n    svfloat32_t sum_vec = svdup_f32(0.0f);      // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, 1); // Generate indices\n        svbool_t active = svwhilelt_b32(i, diag_count); // Active elements in this iteration\n\n        svuint32_t diag_indices = svmul_u32_x(active, indices, svdup_u32(dim * dim + dim + 1)); // Calculate diagonal indices\n        svfloat32_t diag_values = svld1_gather_u32index_f32(active, array, diag_indices); // Gather diagonal elements\n\n        sum_vec = svadd_f32_m(active, sum_vec, diag_values); // Accumulate diagonal values\n        pg = svwhilelt_b32(i + svcntw(), diag_count); // Update predicate for next iteration\n    }\n\n    sum = svaddv_f32(svptrue_b32(), sum_vec); // Reduce vector to scalar sum\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n\n    while (i < dim) {\n        // Load diagonal elements into vector\n        svfloat32_t vec = svld1(pg, &array[i * dim * dim + i * dim + i]);\n\n        // Perform horizontal addition of the vector elements\n        sum += svaddv(pg, vec);\n\n        // Advance to the next chunk of diagonal elements\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n\n    while (i < dim) {\n        // Load diagonal elements into a vector\n        svfloat32_t vec = svld1(pg, &array[i * dim * dim + i * dim + i]);\n        \n        // Perform horizontal addition of the vector elements\n        sum += svaddv(pg, vec);\n        \n        // Update the loop index\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svwhilelt_b64(0, total_elements); // Predicate for active elements\n    size_t index = 0;\n\n    svfloat64_t v_threshold = svdup_f64(threshold); // Broadcast threshold\n    svfloat64_t v_scale = svdup_f64(scale);         // Broadcast scale factor\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t v_src = svld1(pg, &src[index]); // Load source elements\n        svbool_t mask = svcmpgt_f64(pg, v_src, v_threshold); // Compare src > threshold\n        svfloat64_t v_result = svsel_f64(mask, svmul_f64_x(pg, v_src, v_scale), v_src); // Conditional scaling\n        svst1(pg, &dst[index], v_result); // Store result to destination array\n        index += svcntd(); // Advance index by vector length\n        pg = svwhilelt_b64(index, total_elements); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold\n    svfloat64_t scale_vec = svdup_f64(scale);         // Broadcast scale factor\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t src_vec = svld1(pg, &src[i]); // Load source elements\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_x(pg, src_vec, scale_vec); // Scale values\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec); // Select scaled or original\n        svst1(pg, &dst[i], result_vec); // Store result to destination\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold\n    svfloat64_t scale_vec = svdup_f64(scale);         // Broadcast scale\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t src_vec = svld1(pg, &src[i]); // Load source elements\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_m(mask, src_vec, scale_vec); // Scale where mask is true\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec); // Select scaled or original\n        svst1(pg, &dst[i], result_vec); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b64(); // Predicate for active elements\n\n    svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold\n    svfloat64_t scale_vec = svdup_f64(scale);         // Broadcast scale factor\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t src_vec = svld1(pg, &src[i]); // Load source elements\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_m(mask, src_vec, scale_vec); // Scale values where mask is true\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec);  // Select scaled or original values\n        svst1(pg, &dst[i], result_vec); // Store result in destination array\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svwhilelt_b64(0, total_elements); // Predicate for active elements\n    size_t index = 0;\n\n    svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold\n    svfloat64_t scale_vec = svdup_f64(scale);         // Broadcast scale factor\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t src_vec = svld1(pg, &src[index]); // Load source elements\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_m(mask, src_vec, scale_vec); // Scale where mask is true\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec);  // Select scaled or original\n        svst1(pg, &dst[index], result_vec); // Store result to destination array\n\n        index += svcntd(); // Move to next vector chunk\n        pg = svwhilelt_b64(index, total_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t row_size = cols * sizeof(double); // Size of a single row in bytes\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < rows; i++) {\n        // Load the index for the current row\n        size_t index = indices[i];\n\n        // Calculate the source and destination row pointers\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        // Process the row using SVE\n        size_t offset = 0;\n        while (offset < cols) {\n            // Load elements from the source row\n            svfloat64_t src_vec = svld1(pg, &src_row[offset]);\n\n            // Store elements to the destination row\n            svst1(pg, &dst_row[offset], src_vec);\n\n            // Advance the offset by the vector length\n            offset += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t row_size = cols * sizeof(double); // Size of a row in bytes\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < rows; i++) {\n        // Load the index for the current row\n        size_t index = indices[i];\n\n        // Calculate the source and destination row pointers\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        // Process the row using SVE\n        size_t offset = 0;\n        while (offset < cols) {\n            // Load a vector of elements from the source row\n            svfloat64_t vec = svld1(pg, &src_row[offset]);\n\n            // Store the vector into the destination row\n            svst1(pg, &dst_row[offset], vec);\n\n            // Advance the offset by the vector length\n            offset += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t row_size = cols * sizeof(double); // Size of a single row in bytes\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < rows; i++) {\n        // Load the index for the current row\n        size_t index = indices[i];\n\n        // Calculate the source and destination row pointers\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        // Process the row using SVE\n        size_t col_offset = 0;\n        while (col_offset < cols) {\n            // Load elements from the source row\n            svfloat64_t src_vec = svld1(pg, &src_row[col_offset]);\n\n            // Store elements into the destination row\n            svst1(pg, &dst_row[col_offset], src_vec);\n\n            // Advance the column offset\n            col_offset += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t row_size = cols; // Number of elements in a row\n    size_t i = 0;\n\n    // Process rows in chunks based on SVE vector length\n    svbool_t pg = svwhilelt_b64(i, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load indices for the current chunk\n        svuint64_t index_vec = svld1(pg, indices + i);\n\n        // For each index, gather the corresponding row from src and store it in dst\n        for (size_t col = 0; col < cols; col++) {\n            // Calculate the source column offset\n            svuint64_t src_offset = svmad_u64_z(pg, index_vec, svdup_u64(row_size), svdup_u64(col));\n\n            // Gather the elements from src\n            svfloat64_t gathered = svld1_gather_index(pg, src, src_offset);\n\n            // Store the gathered elements into the destination matrix\n            svst1(pg, dst + i * row_size + col, gathered);\n        }\n\n        // Move to the next chunk of rows\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t row_size = cols * sizeof(double); // Size of a row in bytes\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i]; // Get the source row index from the indices array\n        const double *src_row = src + src_row_index * cols; // Pointer to the source row\n        double *dst_row = dst + i * cols; // Pointer to the destination row\n\n        size_t col = 0;\n        while (col < cols) {\n            svbool_t pg = svwhilelt_b64(col, cols); // Predicate for active elements\n            svfloat64_t vec = svld1(pg, &src_row[col]); // Load a vector of elements from the source row\n            svst1(pg, &dst_row[col], vec); // Store the vector of elements into the destination row\n            col += vl; // Advance by the vector length\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load vectors from src1 and src2\n        svint64_t vec1 = svld1(pg, &src1[index]);\n        svint64_t vec2 = svld1(pg, &src2[index]);\n\n        // Perform element-wise addition of src1 and src2\n        svint64_t sum = svadd_s64_m(pg, vec1, vec2);\n\n        // Add scalar to the result\n        svint64_t sum_with_scalar = svadd_s64_m(pg, sum, svdup_n_s64(scalar));\n\n        // Divide by 2 (round-toward-zero)\n        svint64_t result = svasr_n_s64_m(pg, sum_with_scalar, 1);\n\n        // Store the result in the destination array\n        svst1(pg, &dst[index], result);\n\n        // Update index and predicate for the next iteration\n        index += svcntd();\n        pg = svwhilelt_b64(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_src1 = svld1(pg, &src1[index]); // Load elements from src1\n        svint64_t vec_src2 = svld1(pg, &src2[index]); // Load elements from src2\n\n        svint64_t vec_sum = svadd_s64_m(pg, vec_src1, vec_src2); // Element-wise addition\n        svint64_t vec_scalar = svdup_s64(scalar);               // Broadcast scalar\n        svint64_t vec_result = svadd_s64_m(pg, vec_sum, vec_scalar); // Add scalar to result\n        vec_result = svasr_s64_m(pg, vec_result, 1);            // Divide by 2 (round-toward-zero)\n\n        svst1(pg, &dst[index], vec_result); // Store results in dst\n\n        index += svcntd(); // Increment index by vector length\n        pg = svwhilelt_b64(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_src1 = svld1(pg, &src1[index]); // Load src1 vector\n        svint64_t vec_src2 = svld1(pg, &src2[index]); // Load src2 vector\n\n        svint64_t vec_sum = svadd_s64_m(pg, vec_src1, vec_src2); // Element-wise addition\n        svint64_t vec_scalar = svdup_s64(scalar);               // Duplicate scalar value\n        svint64_t vec_result = svadd_s64_m(pg, vec_sum, vec_scalar); // Add scalar to result\n        vec_result = svasr_s64_m(pg, vec_result, 1);            // Divide by 2 (arithmetic shift right)\n\n        svst1(pg, &dst[index], vec_result); // Store result in dst\n        index += svcntd(); // Increment index by vector length\n        pg = svwhilelt_b64(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_src1 = svld1(pg, &src1[index]); // Load src1 vector\n        svint64_t vec_src2 = svld1(pg, &src2[index]); // Load src2 vector\n\n        svint64_t vec_sum = svadd_s64_x(pg, vec_src1, vec_src2); // Element-wise addition\n        svint64_t vec_scalar = svdup_s64(scalar);               // Broadcast scalar\n        svint64_t vec_add_scalar = svadd_s64_x(pg, vec_sum, vec_scalar); // Add scalar\n        svint64_t vec_result = svasr_n_s64_x(pg, vec_add_scalar, 1);     // Divide by 2 (round-toward-zero)\n\n        svst1(pg, &dst[index], vec_result); // Store result in dst\n\n        index += svcntd(); // Advance index by vector length\n        pg = svwhilelt_b64(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load vectors from src1 and src2\n        svint64_t vec1 = svld1(pg, &src1[index]);\n        svint64_t vec2 = svld1(pg, &src2[index]);\n\n        // Perform element-wise addition\n        svint64_t sum = svadd_s64_m(pg, vec1, vec2);\n\n        // Add scalar to the result\n        svint64_t sum_with_scalar = svadd_s64_m(pg, sum, svdup_s64(scalar));\n\n        // Divide by 2 (round-toward-zero)\n        svint64_t result = svasr_s64_m(pg, sum_with_scalar, 1);\n\n        // Store the result in the destination array\n        svst1(pg, &dst[index], result);\n\n        // Update index and predicate for the next iteration\n        index += svcntd();\n        pg = svwhilelt_b64(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    svint32_t min_vec = svdup_n_s32(INT32_MAX); // Initialize vector with max int value\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec = svld1(pg, &src[i]); // Load elements into vector\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(pg, vec, svdup_n_s32(1)), svdup_n_s32(0)); // Mask for even elements\n        svint32_t even_vec = svsel_s32(even_mask, vec, svdup_n_s32(INT32_MAX)); // Select even elements\n        min_vec = svmin_s32_x(pg, min_vec, even_vec); // Compute minimum\n        pg = svwhilelt_b32(i + svcntw(), length); // Update predicate for next iteration\n    }\n\n    int min_value = svminv_s32(svptrue_b32(), min_vec); // Reduce to find minimum value\n    return min_value == INT32_MAX ? -1 : min_value; // Return -1 if no even elements found\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t min_vec = svdup_s32(INT32_MAX); // Initialize vector with max int value\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, length); // Active lanes based on remaining elements\n        svint32_t data = svld1_s32(active, &src[i]); // Load a vector of data\n        svbool_t even_mask = svcmpeq_s32(pg, svand_s32_x(pg, data, svdup_s32(1)), svdup_s32(0)); // Mask for even numbers\n        svint32_t even_data = svsel_s32(even_mask, data, svdup_s32(INT32_MAX)); // Select even numbers, others set to max int\n        min_vec = svmin_s32_x(active, min_vec, even_data); // Compute the minimum\n    }\n\n    // Reduce the vector to find the minimum value\n    int min_value = svminv_s32(pg, min_vec);\n\n    return (min_value == INT32_MAX) ? -1 : min_value; // If no even numbers, return -1\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t min_vec = svdup_s32(SVINT32_MAX); // Initialize vector with max int value\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, length); // Predicate for remaining elements\n        svint32_t vec = svld1_s32(active, &src[i]); // Load vector from memory\n\n        svbool_t even_mask = svcmpeq_n_s32(svand_n_s32_z(active, vec, 1), 0); // Mask for even numbers\n        svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(SVINT32_MAX)); // Select even numbers\n\n        min_vec = svmin_s32_z(active, min_vec, even_vec); // Compute minimum\n    }\n\n    int min_val = SVINT32_MAX;\n    for (int j = 0; j < svcntw(); ++j) {\n        min_val = svminv_s32(pg, min_vec); // Reduce vector to find minimum\n    }\n\n    return (min_val == SVINT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svwhile32_b32(0, length); // Predicate for active elements\n    svint32_t min_vec = svdup_n_s32(INT32_MAX); // Initialize vector with max int value\n    svint32_t zero_vec = svdup_n_s32(0); // Vector of zeros for masking\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &src[index]); // Load vector from source array\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(pg, vec, svdup_n_s32(1)), zero_vec); // Mask for even elements\n        min_vec = svmin_s32_x(even_mask, min_vec, vec); // Compute minimum of even elements\n        index += svcntw(); // Increment index by vector width\n        pg = svwhile32_b32(index, length); // Update predicate for remaining elements\n    }\n\n    // Reduce the vector to find the minimum value\n    int min_value = svminv_s32(svptrue_b32(), min_vec);\n\n    return min_value == INT32_MAX ? -1 : min_value; // Return -1 if no even elements found\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svwhile32_b32(0, length); // Predicate for active elements\n    svint32_t min_vec = svdup_n_s32(INT32_MAX); // Initialize vector with maximum possible value\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &src[i]); // Load vector from source array\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(pg, vec, svdup_n_s32(1)), svdup_n_s32(0)); // Mask for even numbers\n        svint32_t even_vec = svsel_s32(even_mask, vec, svdup_n_s32(INT32_MAX)); // Select even numbers, others set to INT32_MAX\n        min_vec = svmin_s32_x(pg, min_vec, even_vec); // Compute minimum\n        pg = svwhile32_b32(i + svcntw(), length); // Update predicate for next iteration\n    }\n\n    int min_value = svminv_s32(svptrue_b32(), min_vec); // Reduce to find minimum value\n    return min_value == INT32_MAX ? -1 : min_value; // Return -1 if no even numbers found\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(index, length))) {\n        // Load a vector of 32-bit integers from the source array\n        svint32_t src_vec = svld1_s32(pg, &src[index]);\n\n        // Perform arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, src_vec, shift);\n\n        // Convert to unsigned, perform logical right shift, and cast back to signed\n        svuint32_t src_vec_u = svreinterpret_u32_s32(src_vec);\n        svuint32_t logic_shift_u = svlsr_n_u32_z(pg, src_vec_u, shift);\n        svint32_t logic_shift = svreinterpret_s32_u32(logic_shift_u);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logic_shift);\n\n        // Store the result in the destination array\n        svst1_s32(pg, &dst[index], result);\n\n        // Increment the index by the number of processed elements\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(index, length))) {\n        // Load the source vector\n        svint32_t vec_src = svld1_s32(pg, &src[index]);\n\n        // Perform arithmetic right shift\n        svint32_t vec_arith_shift = svasr_n_s32_z(pg, vec_src, shift);\n\n        // Convert to unsigned and perform logical right shift\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logical_shift = svlsr_n_u32_z(pg, vec_unsigned, shift);\n\n        // Convert logical shift result back to signed\n        svint32_t vec_logical_shift_signed = svreinterpret_s32_u32(vec_logical_shift);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32_m(pg, vec_arith_shift, vec_logical_shift_signed);\n\n        // Store the result in the destination array\n        svst1_s32(pg, &dst[index], vec_result);\n\n        // Increment the index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(index, length))) {\n        // Load the source vector\n        svint32_t vec_src = svld1_s32(pg, &src[index]);\n\n        // Perform arithmetic right shift\n        svint32_t vec_arith_shift = svasr_n_s32_z(pg, vec_src, shift);\n\n        // Convert to unsigned, perform logical right shift, and cast back to signed\n        svuint32_t vec_src_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logical_shift_unsigned = svlsr_n_u32_z(pg, vec_src_unsigned, shift);\n        svint32_t vec_logical_shift = svreinterpret_s32_u32(vec_logical_shift_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32_m(pg, vec_arith_shift, vec_logical_shift);\n\n        // Store the result in the destination array\n        svst1_s32(pg, &dst[index], vec_result);\n\n        // Increment index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhile32_b32(index, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load source vector\n        svint32_t vec_src = svld1(pg, &src[index]);\n\n        // Perform arithmetic right shift\n        svint32_t vec_arith_shift = svasr_n_s32(vec_src, shift);\n\n        // Perform logical right shift\n        svuint32_t vec_src_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logical_shift = svlsr_n_u32(vec_src_unsigned, shift);\n        svint32_t vec_logical_shift_signed = svreinterpret_s32_u32(vec_logical_shift);\n\n        // Add results and store in destination\n        svint32_t vec_result = svadd_s32_m(pg, vec_arith_shift, vec_logical_shift_signed);\n        svst1(pg, &dst[index], vec_result);\n\n        // Update index and predicate\n        index += svcntw();\n        pg = svwhile32_b32(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_src = svld1(pg, &src[index]); // Load source elements\n        svint32_t vec_arith_shift = svasr_n_s32(vec_src, shift); // Arithmetic right shift\n        svuint32_t vec_src_unsigned = svreinterpret_u32(vec_src); // Convert to unsigned\n        svuint32_t vec_logic_shift = svlsr_n_u32(vec_src_unsigned, shift); // Logical right shift\n        svint32_t vec_logic_shift_signed = svreinterpret_s32(vec_logic_shift); // Cast back to signed\n        svint32_t vec_result = svadd_s32_m(pg, vec_arith_shift, vec_logic_shift_signed); // Add results\n        svst1(pg, &dst[index], vec_result); // Store results to destination\n        index += svcntw(); // Increment index by vector width\n        pg = svwhilelt_b32(index, length); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n\n    while (i < total_elements) {\n        // Load a vector of elements from the matrix\n        svint32_t vec = svld1(pg, &matrix[i]);\n\n        // Convert to 64-bit integers for accumulation\n        svint64_t vec64 = svcvt_s64_s32_x(pg, vec);\n\n        // Horizontal add across the vector lanes\n        sum += svaddv_s64(pg, vec64);\n\n        // Advance the index by the number of active lanes\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    // Process the matrix in chunks using SVE\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svint32_t vec = svld1(pg, &matrix[i]); // Load a vector of 32-bit integers\n        svint64_t vec_widened = svaddv_s64(pg, svreinterpret_s64(vec)); // Widen and sum the vector\n        sum += svaddv_s64(pg, vec_widened); // Accumulate the sum\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t active = svwhilelt_b32(index, total_elements); // Active lanes for remaining elements\n        svint32_t vec = svld1_s32(active, &matrix[index]);      // Load vector of elements\n        svint64_t vec_sum = svaddv_s64(pg, svreinterpret_s64_s32(vec)); // Accumulate sum in vector\n        sum += svlastb_s64(pg, vec_sum);                        // Add vector sum to scalar sum\n        index += svcntw();                                      // Increment index by vector width\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint64_t vec_sum = svdup_n_s64(0); // Initialize vector sum to zero\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, total_elements); // Active lanes for current iteration\n        svint32_t vec = svld1_s32(active, &matrix[i]); // Load vector of integers\n        vec_sum = svadd_s64_m(active, vec_sum, svaddv_s64(active, svreinterpret_s64(vec))); // Accumulate sum\n    }\n\n    sum = svaddv_s64(pg, vec_sum); // Reduce vector sum to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svint32_t vec = svld1(pg, &matrix[i]); // Load vector of 32-bit integers\n        svint64_t vec_widened = svaddv(pg, svreinterpret_s64(vec)); // Widen and sum within vector\n        sum += svaddv_s64(pg, vec_widened); // Accumulate sum\n        i += svcntw(); // Increment index by vector width\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = INT8_MIN;\n\n    svbool_t pg = svwhilelt_b8(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, &src[index]); // Load a vector of elements\n        svbool_t cmp = svcmpgt_s8(pg, vec, svdup_s8(max_value)); // Compare with current max value\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_value = svmaxv_s8(cmp, vec); // Find the maximum value in the vector\n            svuint64_t indices = svindex_u64(index, 1); // Generate indices\n            svuint64_t max_indices = svsel_u64(cmp, indices, svdup_u64(max_index)); // Select indices of max values\n            max_index = svlastb_u64(cmp, max_indices); // Get the last active index\n        }\n\n        index += svcntb(); // Move to the next chunk\n        pg = svwhilelt_b8(index, length); // Update predicate for remaining elements\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_values = svld1(pg, src);\n    svuint64_t max_indices = svindex_u64(0, 1);\n\n    size_t index = 0;\n    int8_t max_value = svmaxv_s8(pg, max_values);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t current_values = svld1(pg, src + index);\n        svuint64_t current_indices = svindex_u64(index, 1);\n\n        svbool_t mask = svcmpeq_s8(pg, current_values, max_value);\n        svuint64_t filtered_indices = svsel_u64(mask, current_indices, max_indices);\n\n        index += svcntb();\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = INT8_MIN;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1(pg, &src[index]);\n        svint8_t max_vec = svdup_s8(max_value);\n        svbool_t mask = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(svptrue_b8(), mask)) {\n            svint8_t masked_values = svsel(mask, vec, max_vec);\n            max_value = svmaxv_s8(svptrue_b8(), masked_values);\n\n            svuint8_t indices = svindex_u8(index, 1);\n            svuint8_t masked_indices = svsel(mask, indices, svdup_u8(max_index));\n            max_index = svlastb_u8(svptrue_b8(), masked_indices);\n        }\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, length);\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_values = svld1(pg, src);\n    svuint64_t max_indices = svindex_u64(0, 1);\n\n    size_t index = 0;\n    int8_t max_value = svmaxv_s8(pg, max_values);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t current_values = svld1(pg, src + index);\n        svuint64_t current_indices = svindex_u64(index, 1);\n\n        svbool_t mask = svcmpeq_s8(pg, current_values, max_value);\n        max_indices = svsel_u64(mask, current_indices, max_indices);\n\n        pg = svwhilelt_b8(index += svcntb(), length);\n    }\n\n    return max_indices;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length); // Predicate for active elements\n    svint8_t max_values = svld1(pg, src);  // Load initial vector of values\n    svuint64_t max_indices = svindex_u64(0, 1); // Initialize indices\n    size_t max_index = 0;\n    int8_t max_value = svmaxv_s8(pg, max_values); // Initial max value\n\n    size_t offset = svcntb(); // Vector length in bytes\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t current_values = svld1(pg, src);\n        svuint64_t current_indices = svindex_u64(max_index, 1);\n\n        svbool_t cmp_mask = svcmpeq_s8(pg, current_values, max_value);\n        svuint64_t selected_indices = svsel_u64(cmp_mask, current_indices, max_indices);\n        max_indices = selected_indices;\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b16(index, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t indices = svindex_u16(index, 1); // Generate indices\n        svuint16_t src1_vec = svld1(pg, &src1[index]); // Load src1 values\n        svuint16_t src2_vec = svld1(pg, &src2[index]); // Load src2 values\n\n        svuint16_t mask_vec = svdup_u16(mask); // Duplicate mask value\n        svuint16_t index_masked = svand_u16(indices, mask_vec); // Apply mask to indices\n        svbool_t condition = svcmpne_u16(index_masked, svdup_u16(0)); // Check if masked index is non-zero\n\n        svuint16_t result = svsel_u16(condition, src1_vec, src2_vec); // Blend src1 and src2 based on condition\n        svst1(pg, &dst[index], result); // Store result in dst\n\n        index += svcntw(); // Increment index by vector length\n        pg = svwhilelt_b16(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b16(index, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec_src1 = svld1(pg, &src1[index]); // Load src1 vector\n        svuint16_t vec_src2 = svld1(pg, &src2[index]); // Load src2 vector\n\n        svuint32_t vec_index = svindex_u32(index, 1); // Generate indices\n        svuint32_t vec_masked = svand_u32(vec_index, svdup_u32(mask)); // Apply mask\n\n        svbool_t condition = svcmpne_n_u32(vec_masked, 0); // Check condition (non-zero)\n        svuint16_t vec_result = svsel(condition, vec_src1, vec_src2); // Blend based on condition\n\n        svst1(pg, &dst[index], vec_result); // Store result to destination array\n\n        index += svcntw(); // Increment index by vector width\n        pg = svwhilelt_b16(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t index = 0;\n\n    while (index < length) {\n        // Get the maximum vector length for the current SVE configuration\n        svbool_t pg = svwhilelt_b16(index, length);\n\n        // Load elements from src1 and src2\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[index]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[index]);\n\n        // Create an index vector\n        svuint32_t vec_index = svindex_u32(index, 1);\n\n        // Compute the condition: (index & mask) != 0\n        svbool_t blend_mask = svcmpne_n_u32(pg, svand_n_u32_x(pg, vec_index, mask), 0);\n\n        // Select values based on the condition\n        svuint16_t vec_result = svsel_u16(blend_mask, vec_src1, vec_src2);\n\n        // Store the result in the destination array\n        svst1_u16(pg, &dst[index], vec_result);\n\n        // Increment the index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t index = 0;\n\n    while (index < length) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b16(index, length);\n\n        // Load elements from src1 and src2\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[index]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[index]);\n\n        // Generate indices for the current vector\n        svuint32_t vec_indices = svindex_u32(index, 1);\n\n        // Compute the condition: (index & mask) != 0\n        svbool_t blend_mask = svcmpne_n_u32(pg, svand_n_u32(vec_indices, mask), 0);\n\n        // Select values based on the condition\n        svuint16_t vec_result = svsel_u16(blend_mask, vec_src1, vec_src2);\n\n        // Store the result in the destination array\n        svst1_u16(pg, &dst[index], vec_result);\n\n        // Advance the index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b16(index, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t indices = svindex_u16(index, 1); // Generate indices\n        svuint16_t src1_vec = svld1(pg, &src1[index]); // Load src1 elements\n        svuint16_t src2_vec = svld1(pg, &src2[index]); // Load src2 elements\n\n        svuint16_t mask_vec = svdup_u16(mask); // Duplicate mask value\n        svuint16_t and_result = svand_u16(indices, mask_vec); // Perform bitwise AND\n\n        svbool_t condition = svcmpne_u16(and_result, svdup_u16(0)); // Check if AND result is non-zero\n        svuint16_t blended = svsel(condition, src1_vec, src2_vec); // Select based on condition\n\n        svst1(pg, &dst[index], blended); // Store result in dst\n\n        index += svcntw(); // Increment index by vector width\n        pg = svwhilelt_b16(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, length); // Create a predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svuint32_t vec_src = svld1_u32(pg, &src[index]); // Load a vector of source elements\n        svuint32_t vec_popcount = svcntp_b_u32(pg, svdup_u32(1), vec_src); // Compute population count for each element\n        svst1_u32(pg, &dst[index], vec_popcount); // Store the result in the destination array\n        index += svcntw(); // Increment index by the number of processed elements\n        pg = svwhilelt_b32(index, length); // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t index = 0;\n\n    // Process the array in chunks using SVE\n    while (index < length) {\n        // Determine the vector length for this iteration\n        svbool_t pg = svwhilelt_b32(index, length);\n\n        // Load a chunk of the source array\n        svuint32_t src_vec = svld1_u32(pg, &src[index]);\n\n        // Perform population count on each element in the vector\n        svuint32_t popcount_vec = svcnt_u32_z(pg, src_vec);\n\n        // Store the result into the destination array\n        svst1_u32(pg, &dst[index], popcount_vec);\n\n        // Advance the index by the number of elements processed\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        // Load a vector of uint32_t from the source array\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n\n        // Compute the population count for each element in the vector\n        svuint32_t vec_popcount = svcnt_u32_x(pg, vec_src);\n\n        // Store the result into the destination array\n        svst1_u32(pg, &dst[i], vec_popcount);\n\n        // Increment the index by the number of active elements in the predicate\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhile32_b32(index, length); // Create a predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svuint32_t vec_src = svld1_u32(pg, &src[index]); // Load source vector\n        svuint32_t vec_popcount = svcntp_b_u32(pg, svdup_u32(0), vec_src); // Compute population count\n        svst1_u32(pg, &dst[index], vec_popcount); // Store the result in destination array\n        index += svcntw(); // Move to the next vector chunk\n        pg = svwhile32_b32(index, length); // Update the predicate for the next chunk\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b32(), pg)) { // Check if any elements are left to process\n        svuint32_t vec_src = svld1_u32(pg, &src[i]); // Load a vector of source elements\n        svuint32_t vec_popcount = svcntp_b_u32(svptrue_b32(), svcnt_u32(vec_src)); // Compute population count\n        svst1_u32(pg, &dst[i], vec_popcount); // Store the result in the destination array\n        i += svcntw(); // Move to the next vector\n        pg = svwhilelt_b32(i, length); // Update the predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length); // Predicate for active elements in the vector\n\n    while (svptest_any(svptrue_b16(), pg)) { // Loop while there are active elements\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]); // Load vector from src1\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]); // Load vector from src2\n\n        svuint16_t result = svqadd_u16(vec1, vec2); // Saturating addition of vec1 and vec2\n\n        svst1_u16(pg, &dst[i], result); // Store the result to dst\n\n        i += svcntw(); // Increment index by the number of elements processed\n        pg = svwhilelt_b16(i, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length); // Create a predicate for active elements\n    while (svptest_any(svptrue_b16(), pg)) { // Loop while there are active elements\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]); // Load src1 elements\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]); // Load src2 elements\n        svuint16_t result = svqadd_u16(vec1, vec2); // Perform saturating addition\n        svst1_u16(pg, &dst[i], result); // Store the result in dst\n        i += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b16(i, length); // Update the predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, length))) {\n        // Load vectors from src1 and src2\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n\n        // Perform saturating addition\n        svuint16_t result = svqadd_u16_z(pg, vec1, vec2);\n\n        // Store the result in dst\n        svst1_u16(pg, &dst[i], result);\n\n        // Increment index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, length))) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svqadd_u16_z(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, length))) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svqadd_u16_z(pg, vec1, vec2); // Saturating addition\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vectorized sum to zero\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements of A and B\n                svbool_t pg = svwhilelt_b64(k, n); // Predicate for active elements\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n\n                // Apply range check for [-100, 100]\n                svbool_t a_in_range = svand_b_z(pg, svcmple_f64(pg, svdup_f64(-100.0), a_vec), svcmple_f64(pg, a_vec, svdup_f64(100.0)));\n                svbool_t b_in_range = svand_b_z(pg, svcmple_f64(pg, svdup_f64(-100.0), b_vec), svcmple_f64(pg, b_vec, svdup_f64(100.0)));\n                svbool_t valid_elements = svand_b_z(pg, a_in_range, b_in_range);\n\n                // Perform multiplication only for valid elements\n                svfloat64_t product = svmul_f64_m(valid_elements, a_vec, b_vec);\n\n                // Accumulate the product into the sum vector\n                sum_vec = svadd_f64_m(pg, sum_vec, product);\n            }\n            // Reduce the sum vector to a scalar and store in C\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svbool_t pg = svptrue_b64(); // Predicate for active lanes\n            svfloat64_t sum = svdup_f64(0.0); // Initialize sum vector to zero\n\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements of A and B\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n\n                // Create masks for range [-100, 100]\n                svbool_t a_mask = svand_b_z(pg, svcmple_f64(pg, a_vec, svdup_f64(100.0)), svcmpge_f64(pg, a_vec, svdup_f64(-100.0)));\n                svbool_t b_mask = svand_b_z(pg, svcmple_f64(pg, b_vec, svdup_f64(100.0)), svcmpge_f64(pg, b_vec, svdup_f64(-100.0)));\n\n                // Combine masks\n                svbool_t valid_mask = svand_b_z(pg, a_mask, b_mask);\n\n                // Perform multiplication only for valid elements\n                svfloat64_t product = svmul_f64_m(valid_mask, a_vec, b_vec);\n\n                // Accumulate the results\n                sum = svadd_f64_m(pg, sum, product);\n            }\n\n            // Reduce the sum vector to a scalar\n            double final_sum = svaddv_f64(pg, sum);\n\n            // Store the result in C\n            C[i * p + j] = final_sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n\n                svbool_t a_in_range = svand_b_z(pg, svcmple_f64(pg, svdup_f64(-100.0), a_vec), svcmple_f64(pg, a_vec, svdup_f64(100.0)));\n                svbool_t b_in_range = svand_b_z(pg, svcmple_f64(pg, svdup_f64(-100.0), b_vec), svcmple_f64(pg, b_vec, svdup_f64(100.0)));\n\n                svbool_t valid_mask = svand_b_z(pg, a_in_range, b_in_range);\n\n                svfloat64_t product_vec = svmul_f64_m(valid_mask, a_vec, b_vec);\n                sum_vec = svadd_f64_m(pg, sum_vec, product_vec);\n            }\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements of A and B\n                svbool_t pg = svwhilelt_b64(k, n); // Predicate for bounds\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n\n                // Check range [-100, 100] for A\n                svbool_t a_in_range = svand_b_z(pg, svcmple(pg, svdup_f64(-100.0), a_vec), svcmple(pg, a_vec, svdup_f64(100.0)));\n\n                // Check range [-100, 100] for B\n                svbool_t b_in_range = svand_b_z(pg, svcmple(pg, svdup_f64(-100.0), b_vec), svcmple(pg, b_vec, svdup_f64(100.0)));\n\n                // Combine predicates for both A and B\n                svbool_t valid_mask = svand_b_z(pg, a_in_range, b_in_range);\n\n                // Perform multiplication only for valid elements\n                svfloat64_t product = svmul_m(valid_mask, a_vec, b_vec);\n\n                // Accumulate the result\n                sum_vec = svadd_m(valid_mask, sum_vec, product);\n            }\n            // Horizontal add to get the final sum for C[i * p + j]\n            C[i * p + j] = svaddv(svptrue_b64(), sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svbool_t pg = svwhilelt_b64(0, n); // Predicate for vectorization\n            size_t k = 0;\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vectorized sum to 0\n\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]); // Load A[i][k] vector\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]); // Load B[k][j] vector\n\n                // Check if A[i][k] and B[k][j] are in range [-100, 100]\n                svbool_t a_in_range = svand_b_z(pg, svcmple(pg, svdup_f64(-100.0), a_vec), svcmple(pg, a_vec, svdup_f64(100.0)));\n                svbool_t b_in_range = svand_b_z(pg, svcmple(pg, svdup_f64(-100.0), b_vec), svcmple(pg, b_vec, svdup_f64(100.0)));\n                svbool_t valid_mask = svand_b_z(pg, a_in_range, b_in_range);\n\n                // Multiply and accumulate only for valid elements\n                svfloat64_t prod_vec = svmul_m(valid_mask, a_vec, b_vec);\n                sum_vec = svadd_m(valid_mask, sum_vec, prod_vec);\n\n                k += svcntd(); // Move to the next vector chunk\n                pg = svwhilelt_b64(k, n); // Update predicate for remaining elements\n            }\n\n            // Horizontally reduce the sum vector to a scalar\n            double sum = svaddv(svptrue_b64(), sum_vec);\n            C[i * p + j] = sum; // Store the result in C[i][j]\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) { // Loop while there are active elements\n        svint64_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svint64_t vecB = svld1(pg, &B[index]); // Load vector from B\n        svint64_t vecC = svadd_s64_m(pg, vecA, vecB); // Perform element-wise addition\n        svst1(pg, &C[index], vecC); // Store result in C\n        index += svcntd(); // Move to the next set of elements\n        pg = svwhilelt_b64(index, total_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vecA = svld1(pg, &A[index]);\n        svint64_t vecB = svld1(pg, &B[index]);\n        svint64_t vecC = svadd_s64_m(pg, vecA, vecB);\n        svst1(pg, &C[index], vecC);\n\n        index += svcntd();\n        pg = svwhilelt_b64(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vecA = svld1(pg, &A[index]);\n        svint64_t vecB = svld1(pg, &B[index]);\n        svint64_t vecC = svadd_s64_z(pg, vecA, vecB);\n        svst1(pg, &C[index], vecC);\n\n        index += svcntd();\n        pg = svwhilelt_b64(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements); // Predicate for active lanes\n    while (svptest_any(svptrue_b64(), pg)) { // Check if any lanes are active\n        svint64_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svint64_t vecB = svld1(pg, &B[index]); // Load vector from B\n        svint64_t vecC = svadd_s64_m(pg, vecA, vecB); // Element-wise addition\n        svst1(pg, &C[index], vecC); // Store result in C\n        index += svcntd(); // Move to the next vector chunk\n        pg = svwhilelt_b64(index, total_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) { // Loop while there are active elements\n        svint64_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svint64_t vecB = svld1(pg, &B[index]); // Load vector from B\n        svint64_t vecC = svadd_s64_m(pg, vecA, vecB); // Perform element-wise addition\n        svst1(pg, &C[index], vecC); // Store result in C\n        index += svcntd(); // Move to the next vector chunk\n        pg = svwhilelt_b64(index, total_elements); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b32(), pg)) { // Check if any elements are left to process\n        svfloat32_t vec1 = svld1(pg, &src1[i]); // Load elements from src1\n        svfloat32_t vec2 = svld1(pg, &src2[i]); // Load elements from src2\n\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2); // Perform element-wise addition\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);  // Round to the nearest integer\n\n        svst1(pg, &dst[i], rounded); // Store the result in dst\n\n        i += svcntw(); // Increment the index by the vector length\n        pg = svwhilelt_b32(i, length); // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src1 and src2\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n\n        // Perform element-wise addition\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n\n        // Round to the nearest integer\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);\n\n        // Store the result in dst\n        svst1(pg, &dst[i], rounded);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);\n\n        svst1(pg, &dst[i], rounded);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Create a predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]); // Load elements from src1\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]); // Load elements from src2\n\n        svfloat32_t vec_add = svadd_f32_m(pg, vec_src1, vec_src2); // Element-wise addition\n        svfloat32_t vec_rounded = svrintn_f32_m(pg, vec_add); // Round to nearest integer\n\n        svst1(pg, &dst[i], vec_rounded); // Store the result in dst\n\n        i += svcntw(); // Increment the index by the vector length\n        pg = svwhilelt_b32(i, length); // Update the predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        svfloat32_t vec_sum = svadd_f32_m(pg, vec_src1, vec_src2);\n        svfloat32_t vec_rounded = svrintn_f32_m(pg, vec_sum);\n\n        svst1(pg, &dst[i], vec_rounded);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src1 and src2\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // Compute the absolute difference\n        svfloat32_t vec_diff = svsub_f32_x(pg, vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32_x(pg, vec_diff);\n\n        // Check condition 1: absolute difference within 50\n        svbool_t cond1 = svcmple_f32(pg, vec_abs_diff, svdup_f32(50.0f));\n\n        // Check condition 2: index is a multiple of 2\n        svuint32_t vec_indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(pg, svand_u32_x(pg, vec_indices, svdup_u32(1)), svdup_u32(0));\n\n        // Combine conditions\n        svbool_t combined_cond = svand_b_z(pg, cond1, cond2);\n\n        // Perform element-wise multiplication\n        svfloat32_t vec_mul = svmul_f32_x(combined_cond, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        svfloat32_t vec_ceil = svrintp_f32_x(combined_cond, vec_mul);\n\n        // Set -1 for elements not meeting conditions\n        svfloat32_t vec_result = svsel_f32(combined_cond, vec_ceil, svdup_f32(-1.0f));\n\n        // Store results to destination array\n        svst1(pg, &dst[i], vec_result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]); // Load src1 vector\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]); // Load src2 vector\n\n        svfloat32_t vec_diff = svsub_f32_x(pg, vec_src1, vec_src2); // Compute difference\n        svfloat32_t vec_abs_diff = svabs_f32_x(pg, vec_diff);       // Compute absolute difference\n\n        svuint32_t vec_indices = svindex_u32(i, 1); // Generate indices\n        svbool_t cond_abs_diff = svcmple_f32(pg, vec_abs_diff, 50.0f); // Condition: abs(diff) <= 50\n        svbool_t cond_indices = svcmpeq_u32(pg, svand_u32_x(pg, vec_indices, 1), 0); // Condition: index % 2 == 0\n\n        svbool_t combined_cond = svand_b_z(pg, cond_abs_diff, cond_indices); // Combine conditions\n\n        svfloat32_t vec_mul = svmul_f32_x(combined_cond, vec_src1, vec_src2); // Element-wise multiplication\n        svfloat32_t vec_ceil = svceil_f32_x(combined_cond, vec_mul);          // Round up toward positive infinity\n\n        svfloat32_t vec_result = svsel_f32(combined_cond, vec_ceil, svdup_f32(-1.0f)); // Select results based on condition\n\n        svst1(pg, &dst[i], vec_result); // Store results in destination array\n\n        i += svcntw(); // Increment index by vector length\n        pg = svwhilelt_b32(i, length); // Update predicate for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src1 and src2\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t abs_diff = svabs_f32_m(pg, svsub_f32_m(pg, vec_src1, vec_src2));\n\n        // Check condition: absolute difference <= 50\n        svbool_t cond_diff = svcmple_f32(pg, abs_diff, svdup_f32(50.0f));\n\n        // Check condition: index is a multiple of 2\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t cond_index = svcmpeq_u32(pg, svand_u32_x(pg, indices, svdup_u32(1)), svdup_u32(0));\n\n        // Combine conditions\n        svbool_t cond = svand_b_z(pg, cond_diff, cond_index);\n\n        // Perform element-wise multiplication\n        svfloat32_t result = svmul_f32_m(cond, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        result = svrintp_f32_m(cond, result);\n\n        // For elements not meeting conditions, set to -1\n        result = svsel_f32(cond, result, svdup_f32(-1.0f));\n\n        // Store results in dst\n        svst1(pg, &dst[i], result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src1 and src2\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // Calculate absolute difference\n        svfloat32_t vec_diff = svsub_f32_x(pg, vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32_x(pg, vec_diff);\n\n        // Condition 1: Absolute difference within 50\n        svbool_t cond1 = svcmplt_f32(pg, vec_abs_diff, svdup_f32(50.0f));\n\n        // Condition 2: Index is a multiple of 2\n        svuint32_t vec_indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(pg, svand_u32_x(pg, vec_indices, svdup_u32(1)), svdup_u32(0));\n\n        // Combine conditions\n        svbool_t combined_cond = svand_b_z(pg, cond1, cond2);\n\n        // Perform element-wise multiplication\n        svfloat32_t vec_mul = svmul_f32_x(pg, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        svfloat32_t vec_ceil = svrintp_f32_x(pg, vec_mul);\n\n        // Apply conditions: Store result or -1\n        svfloat32_t vec_result = svsel_f32(combined_cond, vec_ceil, svdup_f32(-1.0f));\n\n        // Store results in dst\n        svst1(pg, &dst[i], vec_result);\n\n        // Update loop index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from src1 and src2\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // Calculate absolute difference\n        svfloat32_t vec_diff = svsub_f32_x(pg, vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32_x(pg, vec_diff);\n\n        // Condition 1: Absolute difference within 50\n        svbool_t cond1 = svcmple_f32(pg, vec_abs_diff, svdup_f32(50.0f));\n\n        // Condition 2: Index is a multiple of 2\n        svuint32_t vec_indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(pg, svand_u32_x(pg, vec_indices, svdup_u32(1)), svdup_u32(0));\n\n        // Combine conditions\n        svbool_t combined_cond = svand_b_z(pg, cond1, cond2);\n\n        // Perform element-wise multiplication\n        svfloat32_t vec_mul = svmul_f32_x(combined_cond, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        svfloat32_t vec_ceil = svceiling_f32_x(combined_cond, vec_mul);\n\n        // Set -1 for elements that do not meet the conditions\n        svfloat32_t vec_result = svsel_f32(combined_cond, vec_ceil, svdup_f32(-1.0f));\n\n        // Store results in dst\n        svst1(pg, &dst[i], vec_result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar); // Duplicate scalar across vector\n\n    size_t index = 0;\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements); // Predicate for active lanes\n        svfloat64_t mat_vec = svld1(pg, &mat[index]);       // Load elements from mat\n        svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec); // Multiply with scalar\n        svst1(pg, &dst[index], result_vec);                // Store result in dst\n        index += svcntd();                                 // Advance index by vector length\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active elements\n\n    // Broadcast the scalar to an SVE vector\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        // Load a vector of elements from the source matrix\n        svfloat64_t mat_vec = svld1(pg, &mat[i]);\n\n        // Perform element-wise multiplication\n        svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n\n        // Store the result back to the destination matrix\n        svst1(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b64(index, total_elements); // Predicate for active elements\n    svfloat64_t scalar_vec = svdup_f64(scalar);         // Broadcast scalar to vector\n\n    while (svptest_any(svptrue_b64(), pg)) {            // Loop while there are active elements\n        svfloat64_t mat_vec = svld1(pg, &mat[index]);   // Load vector from mat\n        svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec); // Multiply mat_vec by scalar_vec\n        svst1(pg, &dst[index], result_vec);            // Store result in dst\n        index += svcntd();                             // Increment index by vector length\n        pg = svwhilelt_b64(index, total_elements);     // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec_mat = svld1(pg, &mat[i]); // Load vector from mat\n        svfloat64_t vec_scalar = svdup_f64(scalar); // Duplicate scalar across vector\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar); // Element-wise multiplication\n        svst1(pg, &dst[i], vec_result); // Store result in dst\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active elements\n    svfloat64_t scalar_vec = svdup_f64(scalar); // Broadcast scalar to vector\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        // Load a vector of elements from the source matrix\n        svfloat64_t mat_vec = svld1(pg, &mat[i]);\n        // Perform element-wise multiplication with the scalar\n        svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n        // Store the result in the destination matrix\n        svst1(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svbool_t pg = svptrue_b32();\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Compute the sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, row + j);\n            sum_vec = svadd_f32_m(pg, sum_vec, svmul_f32_x(pg, vec, vec));\n        }\n\n        // Reduce the sum vector to a scalar\n        float sum = svaddv_f32(pg, sum_vec);\n\n        // Compute the L^2 norm\n        float norm = sqrtf(sum);\n\n        // Normalize the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, row + j);\n            svfloat32_t normalized_vec = svdiv_f32_x(pg, vec, svdup_f32(norm));\n            svst1(pg, row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Calculate the sum of squares for the row\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1(pg, &row[j]);\n            sum_vec = svmla_f32_x(pg, sum_vec, vec, vec); // sum_vec += vec * vec\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        // Reduce sum_vec to a single scalar value\n        float sum_of_squares = svaddv_f32(svptrue_b32(), sum_vec);\n        float l2_norm = sqrtf(sum_of_squares);\n\n        // Normalize the row\n        j = 0;\n        pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1(pg, &row[j]);\n            svfloat32_t normalized_vec = svdiv_f32_x(pg, vec, svdup_f32(l2_norm));\n            svst1(pg, &row[j], normalized_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svbool_t pg = svptrue_b32(); // Predicate for active vector lanes\n\n        // Compute L^2 norm of the row\n        svfloat32_t sum_squares = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &row[j]);\n            sum_squares = svmla_f32_m(pg, sum_squares, vec, vec); // sum_squares += vec * vec\n        }\n\n        float l2_norm = sqrtf(svaddv_f32(pg, sum_squares)); // Reduce sum_squares and compute sqrt\n\n        // Normalize the row\n        svfloat32_t norm_factor = svdup_f32(1.0f / l2_norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &row[j]);\n            svfloat32_t normalized_vec = svmul_f32_m(pg, vec, norm_factor); // normalized_vec = vec / l2_norm\n            svst1(pg, &row[j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n\n        // Step 1: Compute the L^2 norm of the row\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t row_vec = svld1(pg, &row[j]);\n            sum_vec = svmla_f32_m(pg, sum_vec, row_vec, row_vec); // sum_vec += row_vec * row_vec\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float sum = svaddv_f32(svptrue_b32(), sum_vec); // Horizontal sum of the vector\n        float l2_norm = sqrtf(sum);\n\n        // Step 2: Normalize the row\n        if (l2_norm > 0.0f) {\n            svfloat32_t norm_factor = svdup_f32(1.0f / l2_norm);\n            j = 0;\n            pg = svwhilelt_b32(j, n);\n            while (svptest_any(svptrue_b32(), pg)) {\n                svfloat32_t row_vec = svld1(pg, &row[j]);\n                svfloat32_t normalized_vec = svmul_f32_m(pg, row_vec, norm_factor); // row_vec / l2_norm\n                svst1(pg, &row[j], normalized_vec);\n                j += svcntw();\n                pg = svwhilelt_b32(j, n);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svbool_t pg = svptrue_b32();\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n\n        // Compute the sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, row + j);\n            sum_vec = svmla_f32_x(pg, sum_vec, vec, vec);\n        }\n\n        // Reduce the sum of squares to a single value\n        float sum_of_squares = svaddv_f32(pg, sum_vec);\n\n        // Compute the L^2 norm\n        float norm = sqrtf(sum_of_squares);\n\n        // Normalize the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, row + j);\n            svfloat32_t normalized_vec = svdiv_f32_x(pg, vec, svdup_f32(norm));\n            svst1(pg, row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vectorized sum to 0\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements from mat1 and mat2 into SVE vectors\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                // Perform element-wise multiplication and accumulate\n                svfloat64_t prod_vec = svmul_f64_x(pg, mat1_vec, mat2_vec);\n                sum_vec = svadd_f64_x(pg, sum_vec, prod_vec);\n            }\n\n            // Reduce the vector sum to a scalar\n            double sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svbool_t pg = svptrue_b64(); // Predicate for active lanes\n            svfloat64_t sum = svdup_f64(0.0); // Initialize sum vector to 0\n\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t vec1 = svld1(pg, &mat1[i * n + k]); // Load a vector from mat1\n                svfloat64_t vec2 = svld1(pg, &mat2[k * p + j]); // Load a vector from mat2\n                sum = svmla_f64_x(pg, sum, vec1, vec2); // Perform multiply-accumulate\n            }\n\n            // Reduce the sum vector to a single value\n            double result = svaddv_f64(pg, sum);\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vectorized sum to 0\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements from mat1 and mat2\n                svbool_t pg = svwhilelt_b64(k, n); // Predicate for bounds\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                // Perform element-wise multiplication and accumulate\n                sum_vec = svmla_f64_m(pg, sum_vec, mat1_vec, mat2_vec);\n            }\n\n            // Horizontal add to compute the final sum\n            double sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n            for (size_t k = 0; k < n; k += svcntd()) {\n                // Load elements from mat1 and mat2\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                // Multiply and accumulate\n                sum_vec = svmla_f64_m(pg, sum_vec, mat1_vec, mat2_vec);\n            }\n\n            // Horizontal add to compute the total sum\n            double sum = svaddv(svptrue_b64(), sum_vec);\n\n            // Round to the nearest integer and store in dst\n            dst[i * p + j] = (double)((long long)(sum + 0.5));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vector sum to zero\n            size_t k = 0;\n\n            // Perform dot product using SVE\n            while (k < n) {\n                // Load elements from mat1 and mat2 into vectors\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                // Multiply and accumulate\n                sum_vec = svmla_f64_x(pg, sum_vec, mat1_vec, mat2_vec);\n\n                k += svcntd(); // Move to the next vector chunk\n            }\n\n            // Reduce the vector sum to a scalar\n            double sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n            // Round to the nearest integer and store in dst\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, cols); // Predicate for active elements\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load a vector of elements from the row\n            svfloat32_t rounded = svmul_f32_z(pg, svrintn_f32_z(pg, svmul_f32_z(pg, vec, svdup_f32(4.0f))), svdup_f32(0.25f)); // Round to nearest quarter\n            svst1(pg, &dst[j * rows + i], rounded); // Store transposed and rounded elements\n            j += svcntw(); // Move to the next vector chunk\n            pg = svwhilelt_b32(j, cols); // Update predicate\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, cols); // Predicate for active elements\n        while (svptest_any(svptrue_b32(), pg)) {\n            // Load a vector of elements from the source matrix\n            svfloat32_t src_vec = svld1(pg, &src[i * cols + j]);\n\n            // Round each element to the nearest quarter (0.25)\n            svfloat32_t scaled = svmul_f32_x(pg, src_vec, svdup_n_f32(4.0f));\n            svfloat32_t rounded = svrintn_f32_x(pg, scaled);\n            svfloat32_t result = svmul_f32_x(pg, rounded, svdup_n_f32(0.25f));\n\n            // Store the transposed and rounded elements in the destination matrix\n            svst1(pg, &dst[j * rows + i], result);\n\n            // Update the column index and predicate\n            j += svcntw();\n            pg = svwhilelt_b32(j, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t col = 0;\n        svbool_t pg = svwhilelt_b32(col, cols); // Predicate for active elements\n        while (svptest_any(svptrue_b32(), pg)) {\n            // Load a vector of elements from the source matrix\n            svfloat32_t vec = svld1(pg, &src[i * cols + col]);\n\n            // Round each element to the nearest quarter (0.25)\n            svfloat32_t scaled = svmul_n_f32_z(pg, vec, 4.0f); // Multiply by 4\n            svfloat32_t rounded = svrintn_f32_z(pg, scaled);   // Round to nearest integer\n            svfloat32_t result = svmul_n_f32_z(pg, rounded, 0.25f); // Divide by 4 (multiply by 0.25)\n\n            // Store the transposed and rounded elements in the destination matrix\n            for (size_t j = 0; j < svcntw(); j++) {\n                if (svptest_any(pg, svwhilelt_b32(j, svcntw()))) {\n                    dst[(col + j) * rows + i] = svlastb_f32(pg, result);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t row, col;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    for (row = 0; row < rows; row++) {\n        for (col = 0; col < cols; col += svcntw()) {\n            // Load a vector of elements from the source matrix\n            svfloat32_t vec = svld1(pg, &src[row * cols + col]);\n\n            // Round each element to the nearest quarter (0.25)\n            svfloat32_t rounded_vec = svmul_f32_z(pg, svrintn_f32_z(pg, svmul_f32_z(pg, vec, svdup_f32(4.0f))), svdup_f32(0.25f));\n\n            // Store the transposed and rounded elements into the destination matrix\n            svst1(pg, &dst[col * rows + row], rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, cols); // Predicate for active elements\n        while (svptest_any(svptrue_b32(), pg)) {\n            // Load a vector of elements from the source matrix\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]);\n\n            // Round each element to the nearest quarter (0.25)\n            svfloat32_t scaled = svmul_f32_z(pg, vec, svdup_n_f32(4.0f)); // Multiply by 4\n            svfloat32_t rounded = svrintn_f32_z(pg, scaled);             // Round to nearest integer\n            svfloat32_t result = svmul_f32_z(pg, rounded, svdup_n_f32(0.25f)); // Divide by 4\n\n            // Store the transposed and rounded elements into the destination matrix\n            svst1(pg, &dst[j * rows + i], result);\n\n            // Advance to the next vector of elements\n            j += svcntw();\n            pg = svwhilelt_b32(j, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1(pg, &tensor1[index]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[index]);\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded_result = svcvt_f32_s32_z(pg, svcvt_s32_f32_z(pg, result));\n        svst1(pg, &dst[index], rounded_result);\n\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements); // Predicate for active lanes\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from tensor1 and tensor2\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction\n        svfloat32_t result = svsub_f32_m(pg, vec1, vec2);\n\n        // Round towards zero\n        svfloat32_t rounded_result = svrintz_f32_m(pg, result);\n\n        // Store the result in the destination tensor\n        svst1(pg, &dst[i], rounded_result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1(pg, &tensor1[index]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[index]);\n        svfloat32_t sub_result = svsub_f32_x(pg, vec1, vec2);\n        svfloat32_t rounded_result = svrintz_f32_x(pg, sub_result);\n        svst1(pg, &dst[index], rounded_result);\n\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1(pg, &tensor1[index]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[index]);\n        svfloat32_t vec_sub = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t vec_rounded = svrintz_f32_z(pg, vec_sub);\n        svst1(pg, &dst[index], vec_rounded);\n\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b32(index, total_elements); // Predicate for active lanes\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1(pg, &tensor1[index]);  // Load tensor1 elements\n        svfloat32_t vec2 = svld1(pg, &tensor2[index]);  // Load tensor2 elements\n        svfloat32_t result = svsub_f32_m(pg, vec1, vec2); // Element-wise subtraction\n        svfloat32_t rounded_result = svcvt_f32_s32_m(pg, svcvt_s32_f32_m(pg, result)); // Round towards zero\n        svst1(pg, &dst[index], rounded_result);         // Store result in dst\n        index += svcntw();                             // Move to next vector chunk\n        pg = svwhilelt_b32(index, total_elements);     // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_mat1 = svld1(pg, &mat1[i]); // Load elements from mat1\n        svfloat64_t vec_mat2 = svld1(pg, &mat2[i]); // Load elements from mat2\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat1, vec_mat2); // Element-wise multiplication\n        svst1(pg, &dst[i], vec_result); // Store the result in dst\n        i += svcntd(); // Increment index by the number of processed elements\n        pg = svwhilelt_b64(i, total_elements); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements); // Create a predicate for the loop\n    while (svptest_any(svptrue_b64(), pg)) {       // Check if any elements are left to process\n        svfloat64_t vec_mat1 = svld1(pg, &mat1[i]); // Load a vector of elements from mat1\n        svfloat64_t vec_mat2 = svld1(pg, &mat2[i]); // Load a vector of elements from mat2\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat1, vec_mat2); // Perform element-wise multiplication\n        svst1(pg, &dst[i], vec_result);           // Store the result in the destination matrix\n        i += svcntd();                            // Increment the index by the vector length\n        pg = svwhilelt_b64(i, total_elements);    // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_mat1 = svld1(pg, &mat1[i]); // Load elements from mat1\n        svfloat64_t vec_mat2 = svld1(pg, &mat2[i]); // Load elements from mat2\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat1, vec_mat2); // Element-wise multiplication\n        svst1(pg, &dst[i], vec_result); // Store result in dst\n        i += svcntd(); // Increment index by vector length\n        pg = svwhilelt_b64(i, total_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {       // Loop while there are active elements\n        svfloat64_t vec1 = svld1(pg, &mat1[i]);    // Load elements from mat1\n        svfloat64_t vec2 = svld1(pg, &mat2[i]);    // Load elements from mat2\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2); // Perform element-wise multiplication\n        svst1(pg, &dst[i], result);               // Store the result in dst\n        i += svcntd();                            // Increment index by vector length\n        pg = svwhilelt_b64(i, total_elements);    // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_mat1 = svld1(pg, &mat1[i]); // Load elements from mat1\n        svfloat64_t vec_mat2 = svld1(pg, &mat2[i]); // Load elements from mat2\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat1, vec_mat2); // Element-wise multiplication\n        svst1(pg, &dst[i], vec_result); // Store result in dst\n        i += svcntd(); // Increment index by vector length\n        pg = svwhilelt_b64(i, total_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f); // Initialize sum to zero\n        size_t col = 0;\n\n        while (col < n) {\n            // Load a vector of matrix row elements and vector elements\n            svbool_t pg = svwhilelt_b32(col, n); // Predicate for active lanes\n            svfloat32_t mat_row = svld1(pg, &mat[i * n + col]);\n            svfloat32_t vec_col = svld1(pg, &vec[col]);\n\n            // Perform element-wise multiplication and accumulate\n            sum = svmla_f32_m(pg, sum, mat_row, vec_col);\n\n            col += svcntw(); // Move to the next chunk of elements\n        }\n\n        // Horizontally reduce the sum vector to a single value\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f); // Initialize sum vector to zero\n        size_t col = 0;\n\n        while (col < n) {\n            // Load a vector of matrix elements and vector elements\n            svbool_t pg = svwhilelt_b32(col, n); // Predicate for active lanes\n            svfloat32_t mat_vec = svld1(pg, &mat[i * n + col]);\n            svfloat32_t vec_vec = svld1(pg, &vec[col]);\n\n            // Perform element-wise multiplication and accumulate\n            sum = svmla_f32_x(pg, sum, mat_vec, vec_vec);\n\n            col += svcntw(); // Move to the next chunk\n        }\n\n        // Horizontally reduce the sum vector to a single scalar value\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f); // Initialize sum to zero\n        size_t col = 0;\n\n        // Process columns in chunks using SVE\n        while (col < n) {\n            size_t vl = svcntw(); // Get the vector length\n            size_t remaining = n - col;\n            size_t active = remaining < vl ? remaining : vl;\n\n            svbool_t pg = svwhilelt_b32(col, n); // Predicate for active elements\n            svfloat32_t mat_vec = svld1(pg, &mat[i * n + col]); // Load matrix row\n            svfloat32_t vec_vec = svld1(pg, &vec[col]); // Load vector\n\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec); // Multiply and accumulate\n\n            col += active; // Advance column index\n        }\n\n        // Horizontal add to compute the final sum for the row\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f); // Initialize sum vector to 0\n        size_t col = 0;\n\n        while (col < n) {\n            // Load a vector of elements from the matrix row and the vector\n            svbool_t pg = svwhilelt_b32(col, n); // Predicate for active lanes\n            svfloat32_t mat_row = svld1(pg, &mat[i * n + col]);\n            svfloat32_t vec_col = svld1(pg, &vec[col]);\n\n            // Perform element-wise multiplication and accumulate\n            sum = svmla_f32_x(pg, sum, mat_row, vec_col);\n\n            col += svcntw(); // Move to the next chunk of elements\n        }\n\n        // Horizontally reduce the sum vector to a single value\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f); // Initialize sum vector to zero\n        size_t col = 0;\n\n        // Process columns in chunks using SVE\n        while (col < n) {\n            size_t vl = svcntw(); // Vector length in elements\n            size_t remaining = n - col;\n            vl = remaining < vl ? remaining : vl; // Adjust vector length if remaining elements are fewer\n\n            svbool_t pg = svwhilelt_b32(col, n); // Predicate for active elements\n            svfloat32_t mat_vec = svld1(pg, &mat[i * n + col]); // Load matrix row elements\n            svfloat32_t vec_vec = svld1(pg, &vec[col]); // Load vector elements\n\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec); // Multiply and accumulate\n\n            col += vl; // Move to the next chunk\n        }\n\n        // Horizontal add to compute the final sum for the row\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vector sum to 0\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &mat[i]); // Load vector of elements\n        sum_vec = svadd_f64_m(pg, sum_vec, vec); // Accumulate sum\n    }\n\n    // Reduce vector sum to a single scalar value\n    double sum = svaddv(pg, sum_vec);\n\n    return sum / total_elements; // Calculate average\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vector sum to 0\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &mat[i]); // Load vector of elements\n        sum_vec = svadd_f64_m(pg, sum_vec, vec); // Accumulate sum\n    }\n\n    // Horizontal reduction to compute the total sum\n    double sum = svaddv_f64(pg, sum_vec);\n\n    // Compute and return the average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vector sum to 0\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &mat[i]); // Load elements into vector\n        sum_vec = svadd_f64_m(pg, sum_vec, vec); // Accumulate sum\n    }\n\n    // Horizontal reduction to compute the total sum\n    double sum = svaddv_f64(pg, sum_vec);\n\n    // Compute and return the average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &mat[i]); // Load elements into vector\n        sum_vec = svadd_f64_m(pg, sum_vec, vec); // Accumulate sum\n    }\n\n    // Horizontal reduction to compute the total sum\n    double sum = svaddv_f64(pg, sum_vec);\n\n    return sum / total_elements; // Compute and return the average\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t sum_vec = svdup_f64(0.0); // Initialize vector sum to 0\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &mat[i]); // Load vector of elements\n        sum_vec = svadd_f64_m(pg, sum_vec, vec); // Accumulate sum\n    }\n\n    // Horizontal reduction to compute the total sum\n    double sum = svaddv_f64(pg, sum_vec);\n\n    // Compute the average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t col = 0;\n\n        svbool_t pg = svwhilelt_b32(col, cols - 1);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t current = svld1(pg, row + col);\n            svint32_t next = svld1(pg, row + col + 1);\n\n            svbool_t sorted;\n            if (ascending) {\n                sorted = svcmple(pg, current, next);\n            } else {\n                sorted = svcmpge(pg, current, next);\n            }\n\n            if (!svptest_all(pg, sorted)) {\n                return false;\n            }\n\n            col += svcntw();\n            pg = svwhilelt_b32(col, cols - 1);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n        for (size_t j = 0; j < cols - 1; j += svcntw()) {\n            svint32_t current = svld1(pg, row + j);\n            svint32_t next = svld1(pg, row + j + 1);\n\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpge(pg, next, current); // Check if next >= current\n            } else {\n                cmp = svcmple(pg, next, current); // Check if next <= current\n            }\n\n            if (!svptest_all(pg, cmp)) {\n                return false; // Row is not sorted\n            }\n        }\n    }\n    return true; // All rows are sorted\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n        \n        svbool_t pg = svptrue_b32(); // Predicate for active lanes\n        size_t i = 0;\n\n        while (i < cols - 1) {\n            svbool_t active = svwhilelt_b32(i, cols - 1); // Active lanes for remaining elements\n            svint32_t current = svld1(pg, &row[i]);       // Load current elements\n            svint32_t next = svld1(pg, &row[i + 1]);      // Load next elements\n\n            svbool_t sorted;\n            if (ascending) {\n                sorted = svcmple(pg, current, next);      // Check ascending order\n            } else {\n                sorted = svcmpge(pg, current, next);      // Check descending order\n            }\n\n            if (!svptest_all(pg, sorted)) {\n                return false; // Row is not sorted\n            }\n\n            i += svcntw(); // Move to next vector chunk\n        }\n    }\n\n    return true; // All rows are sorted\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svptrue_b32(); // Predicate for active lanes\n        svbool_t sorted = svptrue_b32(); // Predicate to track sorted status\n\n        if (directions[i]) { // Ascending order\n            for (size_t j = 0; j < cols - 1; j += svcntw()) {\n                svint32_t current = svld1(pg, row + j);\n                svint32_t next = svld1(pg, row + j + 1);\n                svbool_t cmp = svcmpge(pg, next, current); // Check if next >= current\n                sorted = svand_b_z(pg, sorted, cmp); // Update sorted status\n                if (!svptest_any(pg, sorted)) {\n                    return false; // Early exit if not sorted\n                }\n            }\n        } else { // Descending order\n            for (size_t j = 0; j < cols - 1; j += svcntw()) {\n                svint32_t current = svld1(pg, row + j);\n                svint32_t next = svld1(pg, row + j + 1);\n                svbool_t cmp = svcmple(pg, next, current); // Check if next <= current\n                sorted = svand_b_z(pg, sorted, cmp); // Update sorted status\n                if (!svptest_any(pg, sorted)) {\n                    return false; // Early exit if not sorted\n                }\n            }\n        }\n    }\n    return true; // All rows sorted\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* row_ptr = matrix + row * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1); // Predicate for vectorized loop\n        svbool_t sorted = svptrue_b32(); // Initialize sorted flag to true\n\n        if (directions[row]) { // Ascending order\n            int prev = row_ptr[0];\n            for (size_t i = 1; i < cols; i++) {\n                sorted &= prev <= row_ptr[i];\n            }\n        } else { // Descending order\n            int prev = row_ptr[0];\n            for (size_t i = 1; i < cols; i++) {\n                sorted &= prev >= row_ptr[i];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        // Load a vector of 16-bit integers from src\n        svint16_t src_vec = svld1_s16(pg, &src[index]);\n\n        // Convert base to 16-bit integer vector\n        svint16_t base_vec = svdup_s16(base);\n\n        // Compute the nearest multiple of base less than or equal to each element in src\n        svint16_t div = svdiv_s16_z(pg, src_vec, base_vec); // Integer division\n        svint16_t nearest_multiple = svmul_s16_z(pg, div, base_vec); // Multiply back to get the multiple\n\n        // Store the result in dst\n        svst1_s16(pg, &dst[index], nearest_multiple);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b16(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    int16_t* src_ptr = (int16_t*)src;\n    int16_t* dst_ptr = dst;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t src_vec = svld1_s16(pg, src_ptr); // Load source vector\n        svint16_t base_vec = svdup_s16(base);      // Broadcast base value\n\n        svint16_t div_result = svdiv_s16_x(pg, src_vec, base_vec); // Divide src by base\n        svint16_t nearest_multiple = svmul_s16_x(pg, div_result, base_vec); // Multiply back to get nearest multiple\n\n        svst1_s16(pg, dst_ptr, nearest_multiple); // Store result in destination array\n\n        src_ptr += svcntw(); // Move to next chunk\n        dst_ptr += svcntw();\n        pg = svwhilelt_b16(src_ptr - src, length); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    int16_t* src_ptr = (int16_t*)src;\n    int16_t* dst_ptr = dst;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t src_vec = svld1_s16(pg, src_ptr); // Load source vector\n        svint16_t base_vec = svdup_s16(base);      // Duplicate base value across vector\n\n        // Perform division to find the nearest multiple\n        svint16_t div_result = svdiv_s16_z(pg, src_vec, base_vec);\n        svint16_t nearest_multiple = svmul_s16_z(pg, div_result, base_vec);\n\n        // Ensure the nearest multiple is no more than the value in src\n        svint16_t result = svsel_s16(svcmple_s16(pg, nearest_multiple, src_vec), nearest_multiple, src_vec);\n\n        svst1_s16(pg, dst_ptr, result); // Store result in destination array\n\n        src_ptr += svcntw(); // Advance pointer by vector width\n        dst_ptr += svcntw();\n        pg = svwhilelt_b16(src_ptr - src, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    int16_t index = 0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t src_vec = svld1(pg, &src[index]); // Load src vector\n        svint16_t base_vec = svdup_s16(base);      // Duplicate base value\n\n        // Perform integer division to find the nearest multiple\n        svint16_t div_result = svdiv_s16_z(pg, src_vec, base_vec);\n\n        // Multiply back to get the nearest multiple\n        svint16_t nearest_multiple = svmul_s16_z(pg, div_result, base_vec);\n\n        // Store the result in dst\n        svst1(pg, &dst[index], nearest_multiple);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b16(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    int16_t base_val = (int16_t)base;      // Convert base to 16-bit integer\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t src_vec = svld1(pg, src); // Load elements from src\n        svint16_t div_vec = svdiv_s16_x(pg, src_vec, base_val); // Divide src by base\n        svint16_t mul_vec = svmul_s16_x(pg, div_vec, base_val); // Multiply back to get nearest multiple\n        svst1(pg, dst, mul_vec); // Store result in dst\n\n        src += svcntw(); // Move pointer forward by vector width\n        dst += svcntw(); // Move pointer forward by vector width\n        pg = svwhilelt_b16(src - (const int16_t*)src, length); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        size_t remaining = cols;\n        svbool_t all_match = svptrue_b64(); // Initialize predicate to true for all lanes\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining); // Predicate for active lanes\n            svfloat64_t row_vec = svld1(pg, row_ptr);  // Load row elements\n            svfloat64_t vec_vec = svld1(pg, vector);   // Load vector elements\n\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec); // Compare row and vector\n            all_match = svand_z(all_match, cmp);          // Accumulate matches\n\n            if (!svptest_any(svptrue_b64(), all_match)) { // Early exit if any mismatch\n                break;\n            }\n\n            row_ptr += svcntd(); // Advance pointer by vector length\n            vector += svcntd();\n            remaining -= svcntd();\n        }\n\n        if (svptest_all(svptrue_b64(), all_match)) { // Check if all elements matched\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t col = 0;\n        bool row_matches = true;\n\n        while (col < cols) {\n            svbool_t pg = svwhilelt_b64(col, cols); // Predicate for active elements\n            svfloat64_t row_vec = svld1(pg, &row[col]); // Load row elements\n            svfloat64_t vec_vec = svld1(pg, &vector[col]); // Load vector elements\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec); // Compare row and vector\n            if (!svptest_all(pg, cmp)) { // Check if all comparisons are true\n                row_matches = false;\n                break;\n            }\n            col += svcntd(); // Advance by the vector length\n        }\n\n        if (row_matches) {\n            return true; // Found a matching row\n        }\n    }\n\n    return false; // No matching row found\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        size_t col = 0;\n        bool row_matches = true;\n\n        while (col < cols) {\n            svbool_t pg = svwhilelt_b64(col, cols); // Predicate for active elements\n            svfloat64_t row_vec = svld1(pg, &row[col]); // Load row elements\n            svfloat64_t vec_vec = svld1(pg, &vector[col]); // Load vector elements\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec); // Compare row and vector\n            if (!svptest_all(pg, cmp)) { // Check if all comparisons are true\n                row_matches = false;\n                break;\n            }\n            col += svcntd(); // Advance by the vector length\n        }\n\n        if (row_matches) {\n            return true; // Found a matching row\n        }\n    }\n    return false; // No matching row found\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t remaining = cols;\n        svbool_t all_match = svptrue_b64(); // Initialize predicate to true for all lanes\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining); // Create predicate for active lanes\n            svfloat64_t row_vec = svld1(pg, row);      // Load row elements\n            svfloat64_t vec_vec = svld1(pg, vector);  // Load vector elements\n\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec); // Compare row and vector elements\n            all_match = svand_b_z(pg, all_match, cmp);    // Update all_match predicate\n\n            if (!svptest_any(svptrue_b64(), all_match)) { // If no match, break early\n                break;\n            }\n\n            row += svcntd(); // Move to next chunk of row\n            vector += svcntd(); // Move to next chunk of vector\n            remaining -= svcntd(); // Decrease remaining count\n        }\n\n        if (svptest_all(svptrue_b64(), all_match)) { // Check if all elements matched\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        size_t remaining = cols;\n        svbool_t all_match = svptrue_b64(); // Start with all lanes active\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining); // Predicate for active lanes\n            svfloat64_t row_vec = svld1(pg, row_ptr);  // Load row elements\n            svfloat64_t vec_vec = svld1(pg, vector);   // Load vector elements\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec); // Compare row and vector\n            all_match = svand_z(all_match, cmp);       // Accumulate matches\n            if (!svptest_any(svptrue_b64(), all_match)) {\n                break; // Early exit if any mismatch\n            }\n            row_ptr += svcntd(); // Move to the next chunk\n            remaining -= svcntd();\n        }\n\n        if (svptest_all(svptrue_b64(), all_match)) {\n            return true; // Found a matching row\n        }\n    }\n    return false; // No matching row found\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t cmp = svcmpeq_u8(pg, vecA, vecB);\n        count += svcntp_b8(pg, cmp);\n        i += svcntw();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    svbool_t pg;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        pg = svwhilelt_b8(i, total_elements); // Create predicate for remaining elements\n        svuint8_t vecA = svld1_u8(pg, &A[i]); // Load vector from A\n        svuint8_t vecB = svld1_u8(pg, &B[i]); // Load vector from B\n        svbool_t cmp = svcmpeq_u8(pg, vecA, vecB); // Compare elements\n        equal_count += svcntp_b8(pg, cmp); // Count true predicates\n        i += svcntb(); // Increment by vector length\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    svbool_t pg = svptrue_b8(); // Predicate for active elements\n    size_t i = 0;\n\n    while (i < total_elements) {\n        // Load vectors from A and B\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n\n        // Compare elements\n        svbool_t cmp_result = svcmpeq_u8(pg, vecA, vecB);\n\n        // Count matches\n        equal_count += svcntp_b8(pg, cmp_result);\n\n        // Advance by the vector length\n        i += svcntb();\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    svbool_t pg = svptrue_b8(); // Predicate for active elements\n    size_t i = 0;\n\n    while (i < total_elements) {\n        // Load vectors from A and B\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n\n        // Compare elements\n        svbool_t cmp_result = svcmpeq(pg, vecA, vecB);\n\n        // Count the number of true comparisons\n        equal_count += svcntp_b8(pg, cmp_result);\n\n        // Advance by the vector length\n        i += svcntb();\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    svbool_t pg;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        pg = svwhilelt_b8(i, total_elements); // Create predicate for remaining elements\n        svuint8_t vecA = svld1_u8(pg, &A[i]); // Load vector from A\n        svuint8_t vecB = svld1_u8(pg, &B[i]); // Load vector from B\n        svbool_t cmp = svcmpeq_u8(pg, vecA, vecB); // Compare elements\n        equal_count += svcntp_b8(pg, cmp); // Count matches\n        i += svcntb(); // Increment by vector length\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_x = svld1(pg, &x[index]); // Load vector from x\n        svint64_t vec_y = svld1(pg, &y[index]); // Load vector from y\n\n        svint64_t scaled_x = svmul_s64_x(pg, vec_x, a); // Scalar-vector multiplication\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);       // Absolute value of y\n        svint64_t result = svsub_s64_x(pg, scaled_x, abs_y); // Element-wise subtraction\n\n        svst1(pg, &y[index], result); // Store result back to y\n\n        index += svcntd(); // Increment index by vector length\n        pg = svwhilelt_b64(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load vector from x\n        svint64_t vec_x = svld1(pg, &x[index]);\n\n        // Multiply scalar a with vector x\n        svint64_t vec_ax = svmul_x(pg, svdup_s64(a), vec_x);\n\n        // Load vector from y\n        svint64_t vec_y = svld1(pg, &y[index]);\n\n        // Compute absolute value of y\n        svint64_t vec_abs_y = svabs_x(pg, vec_y);\n\n        // Perform element-wise subtraction\n        svint64_t vec_result = svsub_x(pg, vec_ax, vec_abs_y);\n\n        // Store the result back to y\n        svst1(pg, &y[index], vec_result);\n\n        // Update index and predicate\n        index += svcntd();\n        pg = svwhilelt_b64(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b64(i, length))) {\n        // Load vector elements from x and y\n        svint64_t vec_x = svld1(pg, &x[i]);\n        svint64_t vec_y = svld1(pg, &y[i]);\n\n        // Perform scalar-vector multiplication\n        svint64_t scaled_x = svmul_s64_z(pg, vec_x, a);\n\n        // Compute absolute value of y\n        svint64_t abs_y = svabs_s64_z(pg, vec_y);\n\n        // Perform element-wise subtraction\n        svint64_t result = svsub_s64_z(pg, scaled_x, abs_y);\n\n        // Store the result back to y\n        svst1(pg, &y[i], result);\n\n        // Increment the index\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_x = svld1(pg, &x[index]);       // Load vector x\n        svint64_t vec_y = svld1(pg, &y[index]);       // Load vector y\n        svint64_t vec_ax = svmul_s64_x(pg, a, vec_x); // Multiply scalar a with vector x\n        vec_y = svsub_s64_x(pg, vec_ax, svabs_s64_x(pg, vec_y)); // Subtract abs(y) from ax\n        svst1(pg, &y[index], vec_y);                 // Store result back to y\n        index += svcntd();                           // Increment index by vector length\n        pg = svwhilelt_b64(index, length);           // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_x = svld1(pg, &x[i]);           // Load vector x\n        svint64_t vec_y = svld1(pg, &y[i]);           // Load vector y\n        svint64_t vec_ax = svmul_s64_x(pg, a, vec_x); // Multiply scalar a with vector x\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);     // Compute absolute value of vector y\n        svint64_t result = svsub_s64_x(pg, vec_ax, abs_y); // Subtract abs(y) from ax\n        svst1(pg, &y[i], result);                     // Store the result back to y\n        i += svcntd();                                // Increment index by vector length\n        pg = svwhilelt_b64(i, length);                // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    svint16_t min_vec = svdup_s16(SHRT_MAX); // Initialize min vector with max possible value\n    svint16_t max_vec = svdup_s16(SHRT_MIN); // Initialize max vector with min possible value\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &vec[index]); // Load vector elements\n        min_vec = svmin_s16_z(pg, min_vec, data);   // Compute element-wise minimum\n        max_vec = svmax_s16_z(pg, max_vec, data);   // Compute element-wise maximum\n        index += svcntw();                         // Move to the next chunk\n        pg = svwhilelt_b16(index, length);         // Update predicate\n    }\n\n    // Reduce min and max vectors to scalar values\n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    svint16_t vec_min = svdup_n_s16(SHRT_MAX); // Initialize min with maximum possible value\n    svint16_t vec_max = svdup_n_s16(SHRT_MIN); // Initialize max with minimum possible value\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &vec[index]); // Load vector elements\n        vec_min = svmin_s16_m(pg, vec_min, data);   // Compute minimum\n        vec_max = svmax_s16_m(pg, vec_max, data);   // Compute maximum\n        index += svcntw();                          // Move to next chunk\n        pg = svwhilelt_b16(index, length);          // Update predicate\n    }\n\n    // Reduce across vector to find final min and max\n    int16_t final_min = svminv_s16(svptrue_b16(), vec_min);\n    int16_t final_max = svmaxv_s16(svptrue_b16(), vec_max);\n\n    MinMaxPair result = {final_min, final_max};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    svint16_t vec_min = svdup_s16(INT16_MAX); // Initialize min vector\n    svint16_t vec_max = svdup_s16(INT16_MIN); // Initialize max vector\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &vec[index]); // Load vector elements\n        vec_min = svmin_s16_m(pg, vec_min, data);   // Compute minimum\n        vec_max = svmax_s16_m(pg, vec_max, data);   // Compute maximum\n        index += svcntw();                          // Move to next chunk\n        pg = svwhilelt_b16(index, length);          // Update predicate\n    }\n\n    // Reduce across the vector to get the final min and max values\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    svint16_t min_vec = svdup_s16(INT16_MAX); // Initialize min vector\n    svint16_t max_vec = svdup_s16(INT16_MIN); // Initialize max vector\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &vec[index]); // Load vector elements\n        min_vec = svmin_s16_z(pg, min_vec, data);   // Compute min\n        max_vec = svmax_s16_z(pg, max_vec, data);   // Compute max\n        index += svcntw();                         // Advance index\n        pg = svwhilelt_b16(index, length);         // Update predicate\n    }\n\n    // Reduce min and max values across the vector\n    int16_t min_num = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_num = svmaxv_s16(svptrue_b16(), max_vec);\n\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active elements\n    svint16_t min_vec = svdup_s16(SHRT_MAX); // Initialize min vector with max possible value\n    svint16_t max_vec = svdup_s16(SHRT_MIN); // Initialize max vector with min possible value\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &vec[index]); // Load vector elements\n        min_vec = svmin_s16_z(pg, min_vec, data);   // Compute minimum\n        max_vec = svmax_s16_z(pg, max_vec, data);   // Compute maximum\n        index += svcntw();                          // Move to the next chunk\n        pg = svwhilelt_b16(index, length);          // Update predicate\n    }\n\n    // Reduce the min and max vectors to scalar values\n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t remaining = cols - 1; // Number of comparisons in the row\n        svbool_t pg = svwhilelt_b32(0, remaining); // Predicate for active elements\n        svbool_t all_increasing = svptrue_b32();   // Tracks if all comparisons are valid\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t current = svld1(pg, row);       // Load current elements\n            svint32_t next = svld1(pg, row + 1);      // Load next elements\n            svbool_t cmp = svcmpgt(pg, next, current); // Compare next > current\n            all_increasing = svand_z(pg, all_increasing, cmp); // Update all_increasing\n            row += svcntw();                          // Move to next vector chunk\n            remaining -= svcntw();                    // Update remaining elements\n            pg = svwhilelt_b32(0, remaining);         // Update predicate\n        }\n\n        if (!svptest_all(svptrue_b32(), all_increasing)) {\n            return false; // If any row is not strictly increasing, return false\n        }\n    }\n\n    return true; // All rows are strictly increasing\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols < 2) {\n        return false; // Empty matrix or invalid dimensions\n    }\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        size_t remaining = cols - 1; // Number of comparisons in the row\n        svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n        while (remaining > 0) {\n            svbool_t active = svwhilelt_b32(0, remaining); // Active lanes for current iteration\n            svint32_t current = svld1(pg, row);           // Load current elements\n            svint32_t next = svld1(pg, row + 1);          // Load next elements\n\n            svbool_t cmp = svcmpgt(pg, next, current);    // Compare next > current\n            if (!svptest_all(pg, cmp)) {\n                return false; // If any comparison fails, row is not strictly increasing\n            }\n\n            size_t vl = svcntp_b32(active, active);       // Count active lanes\n            row += vl;                                    // Move to next segment\n            remaining -= vl;                              // Update remaining comparisons\n        }\n    }\n\n    return true; // All rows are strictly increasing\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols < 2) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t remaining = cols - 1;\n        svbool_t pg = svwhilelt_b32(0, remaining);\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t current = svld1(pg, row);\n            svint32_t next = svld1(pg, row + 1);\n\n            svbool_t cmp = svcmpgt(pg, next, current);\n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n\n            row += svcntw();\n            remaining -= svcntw();\n            pg = svwhilelt_b32(0, remaining);\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols < 2) {\n        return false; // Empty matrix or columns less than 2 cannot be strictly increasing\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t remaining = cols - 1; // Number of comparisons in the row\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b32(0, remaining); // Predicate for active elements\n            svint32_t current = svld1(pg, row);        // Load current elements\n            svint32_t next = svld1(pg, row + 1);       // Load next elements\n\n            svbool_t cmp = svcmpgt_s32(pg, next, current); // Compare next > current\n            if (!svptest_all(pg, cmp)) {\n                return false; // If any comparison fails, the row is not strictly increasing\n            }\n\n            size_t vl = svcntp_b32(pg, pg); // Vector length\n            row += vl;                     // Move to next segment\n            remaining -= vl;               // Reduce remaining comparisons\n        }\n    }\n\n    return true; // All rows are strictly increasing\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols < 2) {\n        return false; // Empty matrix or not enough columns to compare\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t remaining = cols - 1; // Number of comparisons in the row\n        svbool_t pg = svwhilelt_b32(0, remaining); // Predicate for active elements\n        svbool_t all_increasing = svptrue_b32(); // Initialize to true for all elements\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t current = svld1(pg, row); // Load current elements\n            svint32_t next = svld1(pg, row + 1); // Load next elements\n            svbool_t cmp = svcmpgt_s32(next, current); // Compare next > current\n            all_increasing = svand_b_z(pg, all_increasing, cmp); // Update all_increasing\n            row += svcntw(); // Move to the next vector chunk\n            remaining -= svcntw(); // Update remaining comparisons\n            pg = svwhilelt_b32(0, remaining); // Update predicate\n        }\n\n        if (!svptest_all(svptrue_b32(), all_increasing)) {\n            return false; // If any row is not strictly increasing, return false\n        }\n    }\n\n    return true; // All rows are strictly increasing\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            // Skip the first block (already considered as reference)\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_row = first_block + i * cols;\n                const int* current_row = current_block + i * cols;\n\n                size_t remaining = block_size;\n                while (remaining > 0) {\n                    svbool_t pg = svwhilelt_b32(0, remaining);\n                    svint32_t vec_first = svld1(pg, first_row);\n                    svint32_t vec_current = svld1(pg, current_row);\n\n                    if (!svptest_all(pg, svcmpeq(pg, vec_first, vec_current))) {\n                        return false;\n                    }\n\n                    size_t vl = svcntw();\n                    first_row += vl;\n                    current_row += vl;\n                    remaining -= vl;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < blocks_per_col; ++block_row) {\n        for (size_t block_col = 0; block_col < blocks_per_row; ++block_col) {\n            // Skip the first block as it's the reference\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_row = first_block + i * cols;\n                const int* current_row = current_block + i * cols;\n\n                size_t remaining = block_size;\n                while (remaining > 0) {\n                    svbool_t pg = svwhilelt_b32(0, remaining);\n                    svint32_t vec_first = svld1(pg, first_row);\n                    svint32_t vec_current = svld1(pg, current_row);\n\n                    if (!svptest_all(pg, svcmpeq(pg, vec_first, vec_current))) {\n                        return false;\n                    }\n\n                    size_t vl = svcntw();\n                    first_row += vl;\n                    current_row += vl;\n                    remaining -= vl;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < blocks_per_col; ++block_row) {\n        for (size_t block_col = 0; block_col < blocks_per_row; ++block_col) {\n            // Skip the first block comparison\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_row = first_block + i * cols;\n                const int* current_row = current_block + i * cols;\n\n                size_t remaining = block_size;\n                while (remaining > 0) {\n                    svbool_t pg = svwhilelt_b32(0, remaining);\n                    svint32_t vec_first = svld1(pg, first_row);\n                    svint32_t vec_current = svld1(pg, current_row);\n\n                    if (!svptest_all(pg, svcmpeq(pg, vec_first, vec_current))) {\n                        return false;\n                    }\n\n                    size_t vl = svcntw();\n                    first_row += vl;\n                    current_row += vl;\n                    remaining -= vl;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t br = 0; br < block_rows; ++br) {\n        for (size_t bc = 0; bc < block_cols; ++bc) {\n            if (br == 0 && bc == 0) {\n                continue; // Skip the first block\n            }\n\n            const int* current_block = matrix + (br * block_size * cols) + (bc * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_row = first_block + i * cols;\n                const int* current_row = current_block + i * cols;\n\n                size_t remaining = block_size;\n                while (remaining > 0) {\n                    svbool_t pg = svwhilelt_b32(0, remaining);\n                    svint32_t first_vec = svld1(pg, first_row);\n                    svint32_t current_vec = svld1(pg, current_row);\n\n                    if (!svptest_all(pg, svcmpeq(pg, first_vec, current_vec))) {\n                        return false;\n                    }\n\n                    size_t vl = svcntw();\n                    first_row += vl;\n                    current_row += vl;\n                    remaining -= vl;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false; // Illegal block size\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < blocks_per_col; ++block_row) {\n        for (size_t block_col = 0; block_col < blocks_per_row; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue; // Skip the first block\n            }\n\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            size_t offset = 0;\n            while (offset < block_elements) {\n                svbool_t pg = svwhilelt_b32(offset, block_elements);\n                svint32_t first_vec = svld1(pg, first_block + offset);\n                svint32_t current_vec = svld1(pg, current_block + offset);\n\n                if (!svptest_any(pg, svcmpeq(pg, first_vec, current_vec))) {\n                    return false; // Blocks are not equal\n                }\n\n                offset += svcntw();\n            }\n        }\n    }\n\n    return true; // All blocks are equal\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false; // Illegal input or no complete blocks\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false; // No complete blocks\n    }\n\n    const double* first_block = vec;\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        const double* current_block = vec + i * block_size;\n        size_t remaining = block_size;\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining);\n            svfloat64_t first_vec = svld1(pg, first_block);\n            svfloat64_t current_vec = svld1(pg, current_block);\n\n            svfloat64_t diff = svsub_f64_x(pg, first_vec, current_vec);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t within_tolerance = svcmple_f64(pg, abs_diff, svdup_f64(tolerance));\n\n            if (!svptest_all(pg, within_tolerance)) {\n                return false; // Blocks are not equal within tolerance\n            }\n\n            size_t active = svcntp_b64(pg, pg);\n            first_block += active;\n            current_block += active;\n            remaining -= active;\n        }\n    }\n\n    return true; // All blocks are equal within tolerance\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Load the first block\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, block_size);\n    svfloat64_t first_block = svld1(pg, &vec[i]);\n\n    // Iterate over all other blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        i = block * block_size;\n        pg = svwhilelt_b64(0, block_size);\n\n        // Load the current block\n        svfloat64_t current_block = svld1(pg, &vec[i]);\n\n        // Compute the absolute difference\n        svfloat64_t diff = svsub_z(pg, current_block, first_block);\n        svfloat64_t abs_diff = svabs_z(pg, diff);\n\n        // Compare with tolerance\n        svbool_t cmp = svcmple(pg, abs_diff, svdup_f64(tolerance));\n\n        // Check if all elements satisfy the condition\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false; // Invalid input or no complete blocks\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false; // No complete blocks\n    }\n\n    const double* first_block = vec;\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        const double* current_block = vec + block_idx * block_size;\n\n        size_t remaining = block_size;\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining);\n            svfloat64_t first_vec = svld1(pg, first_block);\n            svfloat64_t current_vec = svld1(pg, current_block);\n\n            svfloat64_t diff = svsub_f64_x(pg, first_vec, current_vec);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t within_tolerance = svcmple_f64(pg, abs_diff, svdup_f64(tolerance));\n\n            if (!svptest_all(pg, within_tolerance)) {\n                return false; // Blocks are not equal within tolerance\n            }\n\n            size_t vl = svcntd();\n            first_block += vl;\n            current_block += vl;\n            remaining -= vl;\n        }\n    }\n\n    return true; // All blocks are equal within tolerance\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block with the first block\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        size_t offset = block_idx * block_size;\n        size_t remaining = block_size;\n\n        while (remaining > 0) {\n            svbool_t pg = svwhilelt_b64(0, remaining);\n            svfloat64_t first_block = svld1(pg, vec);\n            svfloat64_t current_block = svld1(pg, vec + offset);\n\n            svfloat64_t diff = svsub_f64_x(pg, first_block, current_block);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t within_tolerance = svcmple_f64(pg, abs_diff, tolerance);\n\n            if (!svptest_all(svptrue_b64(), within_tolerance)) {\n                return false;\n            }\n\n            vec += svcntd();\n            offset += svcntd();\n            remaining -= svcntd();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <math.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    svbool_t pg;\n    size_t i, j;\n\n    // Load the first block\n    for (j = 0; j < block_size; j += svcntd()) {\n        pg = svwhilelt_b64(j, block_size);\n        svfloat64_t ref_block = svld1(pg, &vec[j]);\n\n        // Compare each subsequent block with the first block\n        for (i = 1; i < num_blocks; i++) {\n            svfloat64_t current_block = svld1(pg, &vec[i * block_size + j]);\n            svfloat64_t diff = svsub_z(pg, current_block, ref_block);\n            svfloat64_t abs_diff = svabs_z(pg, diff);\n            svbool_t cmp = svcmple(pg, abs_diff, svdup_f64(tolerance));\n\n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svbool_t pg = svptrue_b64(); // Predicate for active elements\n        svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t row_vec = svld1(pg, row_ptr + j); // Load row elements\n            sum_vec = svmla_f64_m(pg, sum_vec, row_vec, row_vec); // Accumulate squared values\n        }\n\n        // Horizontal reduction to compute the total sum\n        double sum = svaddv(pg, sum_vec);\n        double norm = sqrt(sum); // Compute the Euclidean norm\n\n        // Compare norm with the threshold\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        svbool_t pg = svptrue_b64(); // Predicate for active lanes\n        svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, row + j); // Load elements of the row\n            sum_vec = svmla_f64_x(pg, sum_vec, vec, vec); // Accumulate squared values\n        }\n\n        double sum = svaddv(pg, sum_vec); // Reduce sum across vector lanes\n        double norm = sqrt(sum); // Compute Euclidean norm\n        result[i] = norm > thresholds[i]; // Compare norm with threshold\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t pg = svptrue_b64(); // Predicate for active elements\n        svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to zero\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t row_vec = svld1(pg, &matrix[i * cols + j]); // Load row elements\n            sum_vec = svmla_f64_x(pg, sum_vec, row_vec, row_vec);  // Accumulate squared values\n        }\n\n        double sum = svaddv(pg, sum_vec); // Reduce sum vector to scalar\n        double norm = sqrt(sum);         // Compute Euclidean norm\n        result[i] = norm > thresholds[i]; // Compare norm with threshold\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t pg = svptrue_b64(); // Predicate for active lanes\n        svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to zero\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            size_t offset = i * cols + j;\n            svfloat64_t row_vec = svld1(pg, &matrix[offset]); // Load row elements\n            sum_vec = svmla_f64_x(pg, sum_vec, row_vec, row_vec); // Accumulate squared values\n        }\n\n        double sum = svaddv_f64(pg, sum_vec); // Reduce sum vector\n        double norm = sqrt(sum); // Compute Euclidean norm\n        result[i] = norm > thresholds[i]; // Compare norm with threshold\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svbool_t pg = svptrue_b64(); // Predicate for active elements\n        svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, row_ptr + j); // Load a vector of elements\n            sum_vec = svmla(sum_vec, vec, vec); // Accumulate squared values\n        }\n\n        // Horizontal reduction to compute the total sum of squares\n        double sum = svaddv(pg, sum_vec);\n        double norm = sqrt(sum); // Compute the Euclidean norm\n\n        // Compare norm with the threshold\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhile32_b32(i, length); // Create a predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svuint32_t vecA = svld1_u32(pg, &A[i]); // Load vector from A\n        svuint32_t vecB = svld1_u32(pg, &B[i]); // Load vector from B\n        svuint32_t vecC = svorr_u32_z(pg, vecA, vecB); // Perform bitwise OR\n        svst1_u32(pg, &C[i], vecC); // Store result in C\n        i += svcntw(); // Increment index by vector length\n        pg = svwhile32_b32(i, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecC = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecC);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecC = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecC);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecC = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecC);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhile32_b32(i, length); // Create a predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) { // Check if there are active elements\n        svuint32_t vecA = svld1(pg, &A[i]); // Load vector from A\n        svuint32_t vecB = svld1(pg, &B[i]); // Load vector from B\n        svuint32_t vecC = svorr_x(pg, vecA, vecB); // Perform bitwise OR\n        svst1(pg, &C[i], vecC); // Store result in C\n        i += svcntw(); // Increment index by vector length\n        pg = svwhile32_b32(i, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t *A, const int8_t *B, size_t length) {\n    svbool_t pg = svwhilelt_b8(0, length); // Predicate for vector loop\n    svint16_t sum_of_squares = svdup_s16(0); // Accumulator for sum of squares\n    svint16_t sum_of_products = svdup_s16(0); // Accumulator for sum of products\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1_s8(pg, &A[index]); // Load vector from A\n        svint8_t vecB = svld1_s8(pg, &B[index]); // Load vector from B\n\n        svint16_t vecA_squared = svmul_s16(svext_s16(vecA), svext_s16(vecA)); // Square of A\n        svint16_t vecB_squared = svmul_s16(svext_s16(vecB), svext_s16(vecB)); // Square of B\n        svint16_t product = svmul_s16(svext_s16(vecA), svext_s16(vecB)); // Product of A and B\n\n        sum_of_squares = svadd_s16_m(pg, sum_of_squares, svadd_s16(vecA_squared, vecB_squared)); // Accumulate sum of squares\n        sum_of_products = svadd_s16_m(pg, sum_of_products, product); // Accumulate sum of products\n\n        index += svcntb(); // Increment index by vector length\n        pg = svwhilelt_b8(index, length); // Update predicate for next iteration\n    }\n\n    int64_t sum_squares = svaddv_s16(svptrue_b16(), sum_of_squares); // Reduce sum of squares\n    int64_t sum_products = svaddv_s16(svptrue_b16(), sum_of_products); // Reduce sum of products\n\n    return sum_squares - sum_products; // Return difference\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t *A, const int8_t *B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1_s8(pg, &A[index]);\n        svint8_t vecB = svld1_s8(pg, &B[index]);\n\n        svint16_t squaresA = svmul_s16(svreinterpret_s16_s8(vecA), svreinterpret_s16_s8(vecA));\n        svint16_t squaresB = svmul_s16(svreinterpret_s16_s8(vecB), svreinterpret_s16_s8(vecB));\n        svint16_t products = svmul_s16(svreinterpret_s16_s8(vecA), svreinterpret_s16_s8(vecB));\n\n        sum_of_squares += svaddv_s16(pg, squaresA);\n        sum_of_squares += svaddv_s16(pg, squaresB);\n        sum_of_products += svaddv_s16(pg, products);\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, length);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t *A, const int8_t *B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1_s8(pg, &A[index]); // Load vector A\n        svint8_t vecB = svld1_s8(pg, &B[index]); // Load vector B\n\n        svint16_t squaresA = svmul_s16(svreinterpret_s16_s8(vecA), svreinterpret_s16_s8(vecA)); // A[i] * A[i]\n        svint16_t squaresB = svmul_s16(svreinterpret_s16_s8(vecB), svreinterpret_s16_s8(vecB)); // B[i] * B[i]\n        svint16_t products = svmul_s16(svreinterpret_s16_s8(vecA), svreinterpret_s16_s8(vecB)); // A[i] * B[i]\n\n        sum_of_squares += svaddv_s16(pg, squaresA) + svaddv_s16(pg, squaresB); // Sum of squares\n        sum_of_products += svaddv_s16(pg, products); // Sum of products\n\n        index += svcntb(); // Move to the next chunk\n        pg = svwhilelt_b8(index, length); // Update predicate\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1(pg, &A[index]);\n        svint8_t vecB = svld1(pg, &B[index]);\n\n        svint16_t squaresA = svmul_s16(svreinterpret_s16(vecA), svreinterpret_s16(vecA));\n        svint16_t squaresB = svmul_s16(svreinterpret_s16(vecB), svreinterpret_s16(vecB));\n        svint16_t products = svmul_s16(svreinterpret_s16(vecA), svreinterpret_s16(vecB));\n\n        sum_of_squares += svaddv_s64(svptrue_b16(), svreinterpret_s64(svadd_s16(squaresA, squaresB)));\n        sum_of_products += svaddv_s64(svptrue_b16(), svreinterpret_s64(products));\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, length);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t *A, const int8_t *B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length); // Predicate for loop\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1_s8(pg, &A[index]); // Load vector A\n        svint8_t vecB = svld1_s8(pg, &B[index]); // Load vector B\n\n        svint16_t squaresA = svmul_s16(svadd_s16(svdup_s16(0), vecA), svadd_s16(svdup_s16(0), vecA));\n        svint16_t squaresB = svmul_s16(svadd_s16(svdup_s16(0), vecB), svadd_s16(svdup_s16(0), vecB));\n        svint16_t products = svmul_s16(vecA,vecB);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b64(), pg)) { // Check if any elements are left to process\n        svuint64_t vecA = svld1(pg, &A[i]);  // Load vector from A\n        svuint64_t vecB = svld1(pg, &B[i]);  // Load vector from B\n\n        svuint64_t vecNotB = svnot_u64_z(pg, vecB); // Compute bitwise NOT of B\n        svuint64_t vecC = svand_u64_z(pg, vecA, vecNotB); // Compute A & ~B\n\n        svst1(pg, &C[i], vecC); // Store the result in C\n\n        i += svcntd(); // Increment index by the number of elements processed\n        pg = svwhilelt_b64(i, length); // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length); // Create a predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) { // Check if any elements are active\n        svuint64_t vecA = svld1(pg, &A[i]); // Load vector from A\n        svuint64_t vecB = svld1(pg, &B[i]); // Load vector from B\n        svuint64_t vecNotB = svnot_u64_z(pg, vecB); // Compute bitwise NOT of B\n        svuint64_t vecC = svand_u64_z(pg, vecA, vecNotB); // Perform bitwise AND between A and NOT B\n        svst1(pg, &C[i], vecC); // Store the result in C\n        i += svcntd(); // Increment index by the number of elements processed\n        pg = svwhilelt_b64(i, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b64(), pg)) { // Check if any elements are left to process\n        svuint64_t vecA = svld1(pg, &A[i]);  // Load vector from A\n        svuint64_t vecB = svld1(pg, &B[i]);  // Load vector from B\n\n        svuint64_t vecNotB = svnot_u64_x(pg, vecB); // Compute bitwise NOT of B\n        svuint64_t vecC = svand_u64_x(pg, vecA, vecNotB); // Compute A & ~B\n\n        svst1(pg, &C[i], vecC); // Store the result in C\n\n        i += svcntd(); // Move to the next chunk of elements\n        pg = svwhilelt_b64(i, length); // Update the predicate for the next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b64(index, length); // Create a predicate for active elements\n\n    while (svptest_any(svptrue_b64(), pg)) { // Check if any elements are active\n        svuint64_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svuint64_t vecB = svld1(pg, &B[index]); // Load vector from B\n\n        svuint64_t vecB_neg = svnot_u64_z(pg, vecB); // Compute bitwise negation of B\n        svuint64_t vecC = svand_u64_z(pg, vecA, vecB_neg); // Perform bitwise AND between A and negated B\n\n        svst1(pg, &C[index], vecC); // Store the result in C\n\n        index += svcntd(); // Increment index by the number of elements processed\n        pg = svwhilelt_b64(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load vectors from A and B\n        svuint64_t vecA = svld1(pg, &A[i]);\n        svuint64_t vecB = svld1(pg, &B[i]);\n\n        // Perform bitwise negation of B\n        svuint64_t vecB_neg = svnot_u64_z(pg, vecB);\n\n        // Perform bitwise AND between A and ~B\n        svuint64_t vecC = svand_u64_z(pg, vecA, vecB_neg);\n\n        // Store the result in C\n        svst1(pg, &C[i], vecC);\n\n        // Update index and predicate for the next iteration\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load vectors from A and B\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        // Create masks for positive and negative values\n        svbool_t pos_mask = svand_b_z(pg, svcmplt_s8(pg, 0, vecA), svcmplt_s8(pg, 0, vecB));\n        svbool_t neg_mask = svand_b_z(pg, svcmpgt_s8(pg, 0, vecA), svcmpgt_s8(pg, 0, vecB));\n\n        // Set results based on masks\n        svint8_t result = svdup_s8(0); // Default value is 0\n        result = svsel_s8(pos_mask, svdup_s8(1), result);\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n\n        // Store the result in C\n        svst1_s8(pg, &C[i], result);\n\n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load vectors from A and B\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        // Perform element-wise comparisons\n        svbool_t both_positive = svand_b_z(pg, svcmplt_s8(pg, 0, vecA), svcmplt_s8(pg, 0, vecB));\n        svbool_t both_negative = svand_b_z(pg, svcmpgt_s8(pg, 0, vecA), svcmpgt_s8(pg, 0, vecB));\n\n        // Create result vectors based on conditions\n        svint8_t result = svdup_s8(0); // Default value is 0\n        result = svsel_s8(both_positive, svdup_s8(1), result);\n        result = svsel_s8(both_negative, svdup_s8(-1), result);\n\n        // Store the result in C\n        svst1_s8(pg, &C[i], result);\n\n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    while (i < length) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        // Load vectors from A and B\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        // Create masks for positive and negative conditions\n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, vecA, 0), svcmpgt_s8(pg, vecB, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, vecA, 0), svcmplt_s8(pg, vecB, 0));\n\n        // Generate result vectors\n        svint8_t result = svdup_s8_z(pg, 0); // Default to 0\n        result = svsel_s8(pos_mask, svdup_s8(1), result); // Set 1 where both are positive\n        result = svsel_s8(neg_mask, svdup_s8(-1), result); // Set -1 where both are negative\n\n        // Store the result back to C\n        svst1_s8(pg, &C[i], result);\n\n        // Increment the index by the vector length\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load vectors from A and B\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        // Create masks for conditions\n        svbool_t mask_positive = svand_b_z(pg, svcmpgt_s8(pg, vecA, 0), svcmpgt_s8(pg, vecB, 0));\n        svbool_t mask_negative = svand_b_z(pg, svcmplt_s8(pg, vecA, 0), svcmplt_s8(pg, vecB, 0));\n\n        // Initialize C with zeros\n        svint8_t vecC = svdup_s8_z(pg, 0);\n\n        // Set C to 1 where both A and B are positive\n        vecC = svsel_s8(mask_positive, svdup_s8(1), vecC);\n\n        // Set C to -1 where both A and B are negative\n        vecC = svsel_s8(mask_negative, svdup_s8(-1), vecC);\n\n        // Store the result in C\n        svst1_s8(pg, &C[i], vecC);\n\n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load vectors from A and B\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        // Create masks for conditions\n        svbool_t positive_mask = svand_b_z(pg, svcmpgt_s8(pg, vecA, 0), svcmpgt_s8(pg, vecB, 0));\n        svbool_t negative_mask = svand_b_z(pg, svcmplt_s8(pg, vecA, 0), svcmplt_s8(pg, vecB, 0));\n\n        // Initialize result vector to 0\n        svint8_t vecC = svdup_s8(0);\n\n        // Set values based on conditions\n        vecC = svsel_s8(positive_mask, svdup_s8(1), vecC);\n        vecC = svsel_s8(negative_mask, svdup_s8(-1), vecC);\n\n        // Store result in C\n        svst1_s8(pg, &C[i], vecC);\n\n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b16(index, length); // Predicate for active elements\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svuint16_t vecB = svld1(pg, &B[index]); // Load vector from B\n\n        svuint16_t vecC;\n        svbool_t before_midpoint = svwhilelt_b16(index, midpoint); // Predicate for elements before midpoint\n        svbool_t at_midpoint = svcmpeq_n_u16(pg, index + svindex_u16(), midpoint); // Predicate for midpoint element\n\n        // Perform XOR for elements before midpoint\n        vecC = svsel(before_midpoint, svxor_u16_x(pg, vecA, vecB), vecA);\n\n        // Perform AND for elements after midpoint\n        vecC = svsel(svnot_b_z(pg, before_midpoint), svand_u16_x(pg, vecA, vecB), vecC);\n\n        // Store the result in C\n        svst1(pg, &C[index], vecC);\n\n        index += svcntw(); // Increment index by vector width\n        pg = svwhilelt_b16(index, length); // Update predicate for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b16(index, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vecA = svld1_u16(pg, &A[index]);\n        svuint16_t vecB = svld1_u16(pg, &B[index]);\n\n        svuint16_t vecC;\n        svbool_t before_midpoint = svwhilelt_b16(index, midpoint);\n        svbool_t at_midpoint = svcmpeq_n_u16(pg, index, midpoint);\n\n        vecC = svsel_u16(at_midpoint, vecA, svdup_n_u16(0)); // Keep A at midpoint\n        vecC = svsel_u16(before_midpoint, svxor_u16_z(pg,vecA,vecB),vecA)\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n\n        svuint16_t vecC;\n        svbool_t before_midpoint = svwhilelt_b16(i, midpoint);\n        svbool_t at_midpoint = svcmpeq_n_u16(pg, svindex_u16(i, 1), midpoint);\n\n        vecC = svsel_u16(before_midpoint, svxor_u16_z(pg, vecA, vecB), vecA);\n        vecC = svsel_u16(svnot_b_z(pg, before_midpoint), svand_u16_z(pg, vecA, vecB), vecC);\n        vecC = svsel_u16(at_midpoint, vecA, vecC);\n\n        svst1_u16(pg, &C[i], vecC);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b16(index, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vecA = svld1_u16(pg, &A[index]);\n        svuint16_t vecB = svld1_u16(pg, &B[index]);\n\n        svuint16_t vecC;\n        svbool_t before_midpoint = svwhilelt_b16(index, midpoint);\n        svbool_t at_midpoint = svcmpeq_n_u16(pg, svindex_u16(index, svcntw_u16()), midpoint);\n\n        vecC = svsel_u16(before_midpoint, svxor_u16_z(pg, vecA, vecB), vecA);\n        vecC = svsel_u16(svnot_b16(before_midpoint), svand_u16_z(pg, vecA, vecB), vecC);\n        vecC = svsel_u16(at_midpoint, vecA, vecC);\n\n        svst1_u16(pg, &C[index], vecC);\n\n        index += svcntw_u16();\n        pg = svwhilelt_b16(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b16(index, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vecA = svld1(pg, &A[index]);\n        svuint16_t vecB = svld1(pg, &B[index]);\n\n        svuint16_t vecC;\n        svbool_t before_midpoint = svwhilelt_b16(index, midpoint);\n        svbool_t at_midpoint = svcmpeq_n_u16(pg, index, midpoint);\n\n        vecC = svsel(before_midpoint, sveor_u16_x(pg, vecA, vecB), svand_u16_x(pg, vecA, vecB));\n        vecC = svsel(at_midpoint, vecA, vecC);\n\n        svst1(pg, &C[index], vecC);\n\n        index += svcntw();\n        pg = svwhilelt_b16(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n        svfloat32_t vecC = svld1(pg, &C[i]);\n        svfloat32_t vecD = svld1(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, (const uint8_t*)&cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t both_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t both_false = svnot_b_z(pg, svorr_b_z(pg, cond1_vec, cond2_vec));\n\n        svfloat32_t result = svdup_f32(0.0f);\n        result = svsel_f32(both_true, vecA, result);\n        result = svsel_f32(cond1_true_cond2_false, vecB, result);\n        result = svsel_f32(cond1_false_cond2_true, vecC, result);\n        result = svsel_f32(both_false, vecD, result);\n\n        svst1(pg, &out[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        // Load data\n        svfloat32_t vecA = svld1(pg, &A[index]);\n        svfloat32_t vecB = svld1(pg, &B[index]);\n        svfloat32_t vecC = svld1(pg, &C[index]);\n        svfloat32_t vecD = svld1(pg, &D[index]);\n\n        svbool_t vecCond1 = svld1_b8(pg, &cond1[index]);\n        svbool_t vecCond2 = svld1_b8(pg, &cond2[index]);\n\n        // Compute masks\n        svbool_t maskA = svand_b_z(pg, vecCond1, vecCond2);\n        svbool_t maskB = svand_b_z(pg, vecCond1, svnot_b_z(pg, vecCond2));\n        svbool_t maskC = svand_b_z(pg, svnot_b_z(pg, vecCond1), vecCond2);\n        svbool_t maskD = svand_b_z(pg, svnot_b_z(pg, vecCond1), svnot_b_z(pg, vecCond2));\n\n        // Select values based on conditions\n        svfloat32_t result = svdup_f32(0.0f);\n        result = svsel_f32(maskA, vecA, result);\n        result = svsel_f32(maskB, vecB, result);\n        result = svsel_f32(maskC, vecC, result);\n        result = svsel_f32(maskD, vecD, result);\n\n        // Store results\n        svst1(pg, &out[index], result);\n\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        svfloat32_t vecA = svld1(pg, &A[index]);\n        svfloat32_t vecB = svld1(pg, &B[index]);\n        svfloat32_t vecC = svld1(pg, &C[index]);\n        svfloat32_t vecD = svld1(pg, &D[index]);\n\n        svbool_t cond1_vec = svld1_b(pg, &cond1[index]);\n        svbool_t cond2_vec = svld1_b(pg, &cond2[index]);\n\n        svbool_t both_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t both_false = svnot_b_z(pg, svorr_b_z(pg, cond1_vec, cond2_vec));\n\n        svfloat32_t result = svdup_f32(0.0f);\n        result = svsel_f32(both_true, vecA, result);\n        result = svsel_f32(cond1_true_cond2_false, vecB, result);\n        result = svsel_f32(cond1_false_cond2_true, vecC, result);\n        result = svsel_f32(both_false, vecD, result);\n\n        svst1(pg, &out[index], result);\n\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        svfloat32_t vecA = svld1(pg, &A[index]);\n        svfloat32_t vecB = svld1(pg, &B[index]);\n        svfloat32_t vecC = svld1(pg, &C[index]);\n        svfloat32_t vecD = svld1(pg, &D[index]);\n\n        svbool_t cond1_vec = svld1_b8(pg, (const uint8_t*)&cond1[index]);\n        svbool_t cond2_vec = svld1_b8(pg, (const uint8_t*)&cond2[index]);\n\n        svbool_t both_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t both_false = svnot_b_z(pg, svorr_b_z(pg, cond1_vec, cond2_vec));\n\n        svfloat32_t result = svdup_f32(0.0f);\n        result = svsel_f32(both_true, vecA, result);\n        result = svsel_f32(cond1_true_cond2_false, vecB, result);\n        result = svsel_f32(cond1_false_cond2_true, vecC, result);\n        result = svsel_f32(both_false, vecD, result);\n\n        svst1(pg, &out[index], result);\n\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        svfloat32_t vecA = svld1(pg, &A[index]);\n        svfloat32_t vecB = svld1(pg, &B[index]);\n        svfloat32_t vecC = svld1(pg, &C[index]);\n        svfloat32_t vecD = svld1(pg, &D[index]);\n\n        svbool_t vecCond1 = svld1_b(pg, &cond1[index]);\n        svbool_t vecCond2 = svld1_b(pg, &cond2[index]);\n\n        svbool_t cond1_and_cond2 = svand_b_z(pg, vecCond1, vecCond2);\n        svbool_t cond1_and_not_cond2 = svand_b_z(pg, vecCond1, svnot_b_z(pg, vecCond2));\n        svbool_t not_cond1_and_cond2 = svand_b_z(pg, svnot_b_z(pg, vecCond1), vecCond2);\n        svbool_t not_cond1_and_not_cond2 = svand_b_z(pg, svnot_b_z(pg, vecCond1), svnot_b_z(pg, vecCond2));\n\n        svfloat32_t result = svdup_f32(0.0f);\n        result = svsel_f32(cond1_and_cond2, vecA, result);\n        result = svsel_f32(cond1_and_not_cond2, vecB, result);\n        result = svsel_f32(not_cond1_and_cond2, vecC, result);\n        result = svsel_f32(not_cond1_and_not_cond2, vecD, result);\n\n        svst1(pg, &out[index], result);\n\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    while (index < total_elements) {\n        // Load a vector of 32-bit unsigned integers from A\n        svuint32_t vecA = svld1_u32(pg, &A[index]);\n\n        // Count the number of bits set to 1 in each element of vecA\n        svuint32_t popcount = svcntp_b_u32(pg, svcnt_u32_x(pg, vecA));\n\n        // Narrow the 32-bit popcount results to 8-bit and store them in out\n        svuint8_t narrowed = svqxtun_u32_z(pg, popcount);\n        svst1_u8(pg, &out[index], narrowed);\n\n        // Increment index by the number of active lanes\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit integers from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Count the number of bits set to 1 in each element\n        svuint32_t bit_count = svcntp_b_u32(pg, svdup_n_u32(1), vecA);\n\n        // Narrow the 32-bit counts to 8-bit and store in the output array\n        svuint8_t result = svqxtun_u32_z(pg, bit_count);\n        svst1_u8(pg, &out[i], result);\n\n        // Advance to the next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1_u32(pg, &A[index]);\n        svuint32_t bit_counts = svcntp_b_u32(svptrue_b32(), svreinterpret_u32(svdup_u32(0)), vecA);\n\n        svuint8_t vecOut = svreinterpret_u8(bit_counts);\n        svst1_u8(pg, &out[index], vecOut);\n\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit integers from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Count the number of bits set to 1 in each element\n        svuint32_t popcount = svcntp_b_u32(svptrue_b32(), vecA);\n\n        // Narrow the result to 8-bit integers and store in out\n        svuint8_t result = svqxtun_u32_z(pg, popcount);\n        svst1_u8(pg, &out[i], result);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements); // Predicate for active elements\n        svuint32_t vecA = svld1_u32(pg, &A[index]);         // Load 32-bit integers from A\n        svuint32_t bit_counts = svcntp_b32(pg, svdup_u32(0), vecA); // Count bits set to 1 in each element\n        svuint32_t bit_counts"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    // Process the matrix using SVE intrinsics\n    while (index < total_elements) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        // Load a vector of elements from A\n        svint32_t vecA = svld1_s32(pg, &A[index]);\n\n        // Compute the condition: divisible by 3\n        svint32_t mod_result = svmod_s32_x(pg, vecA, svdup_s32(3));\n        svbool_t condition = svcmpeq_s32(pg, mod_result, svdup_s32(0));\n\n        // Compute the absolute value of elements in A\n        svint32_t absA = svabs_s32_x(pg, vecA);\n\n        // Select the result based on the condition\n        svint32_t vecB = svsel_s32(condition, absA, vecA);\n\n        // Store the result into B\n        svst1_s32(pg, &B[index], vecB);\n\n        // Advance the index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements); // Create a predicate for active elements\n        svint32_t vecA = svld1_s32(pg, &A[index]);          // Load elements from A\n        svint32_t modResult = svmod_s32_x(pg, vecA, svdup_s32(3)); // Compute A % 3\n        svbool_t condition = svcmpeq_s32(pg, modResult, svdup_s32(0)); // Check if A % 3 == 0\n        svint32_t absVecA = svabs_s32_x(pg, vecA);          // Compute absolute value of A\n        svint32_t result = svsel_s32(condition, absVecA, vecA); // Select based on condition\n        svst1_s32(pg, &B[index], result);                  // Store result in B\n        index += svcntw();                                 // Increment index by vector length\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of integers from A\n        svint32_t vecA = svld1_s32(pg, &A[i]);\n\n        // Check if elements are divisible by 3\n        svint32_t vecMod = svmod_s32_x(pg, vecA, svdup_s32(3));\n        svbool_t condition = svcmpeq_s32(pg, vecMod, svdup_s32(0));\n\n        // Compute absolute values\n        svint32_t vecAbs = svabs_s32_x(pg, vecA);\n\n        // Select absolute value or original value based on condition\n        svint32_t vecResult = svsel_s32(condition, vecAbs, vecA);\n\n        // Store the result in B\n        svst1_s32(pg, &B[i], vecResult);\n\n        // Advance to the next vector\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements); // Create a predicate for active elements\n        svint32_t vecA = svld1_s32(pg, &A[index]);          // Load elements from A\n        svint32_t modResult = svmod_s32_x(pg, vecA, 3);     // Compute A % 3\n        svbool_t divisibleBy3 = svcmpeq_s32(pg, modResult, 0); // Check if A % 3 == 0\n        svint32_t absVecA = svabs_s32_x(pg, vecA);          // Compute absolute value of A\n        svint32_t result = svsel_s32(divisibleBy3, absVecA, vecA); // Select abs(A) if divisible, else A\n        svst1_s32(pg, &B[index], result);                   // Store result in B\n        index += svcntw();                                  // Increment index by vector width\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n\n        // Load a vector of elements from A\n        svint32_t vecA = svld1_s32(pg, &A[index]);\n\n        // Compute the condition: element % 3 == 0\n        svint32_t mod_result = svrem_s32_z(pg, vecA, svdup_s32(3));\n        svbool_t condition = svcmpeq_s32(pg, mod_result, svdup_s32(0));\n\n        // Compute the absolute value of elements in A\n        svint32_t absA = svabs_s32_z(pg, vecA);\n\n        // Select either the absolute value or the original value based on the condition\n        svint32_t result = svsel_s32(condition, absA, vecA);\n\n        // Store the result into B\n        svst1_s32(pg, &B[index], result);\n\n        // Increment the index by the number of processed elements\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load src vector\n        svuint32_t src_vec = svld1(pg, &src[i]);\n\n        // Check if low 4 bits are all 1\n        svuint32_t mask = svdup_u32(0xF); // Mask for low 4 bits\n        svuint32_t low_bits = svand_u32_z(pg, src_vec, mask);\n        svbool_t condition = svcmpeq_n_u32(pg, low_bits, 0xF);\n\n        // Perform rotation\n        svuint32_t rotated = svlsr_n_u32_z(pg, src_vec, 32 - rotate_bits); // Right shift\n        rotated = svorr_u32_z(pg, svlsl_n_u32_z(pg, src_vec, rotate_bits), rotated); // Combine with left shift\n\n        // Perform bitwise negation\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        // Select based on condition\n        svuint32_t result = svsel_u32(condition, rotated, negated);\n\n        // Store result to dst\n        svst1(pg, &dst[i], result);\n\n        // Update loop index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[index]); // Load src vector\n        svuint32_t low_bits_mask = svdup_u32(0xF);  // Mask for low 4 bits\n        svuint32_t low_bits = svand_u32_x(pg, src_vec, low_bits_mask); // Extract low 4 bits\n        svbool_t condition = svcmpeq_u32(pg, low_bits, low_bits_mask); // Check if low 4 bits are all 1\n\n        svuint32_t rotated = svlsr_u32_x(pg, src_vec, 32 - rotate_bits); // Rotate right\n        rotated = svorr_u32_x(pg, svlsl_u32_x(pg, src_vec, rotate_bits), rotated); // Combine rotated parts\n\n        svuint32_t negated = svnot_u32_x(pg, src_vec); // Bitwise negation\n\n        svuint32_t result = svsel_u32(condition, rotated, negated); // Select based on condition\n        svst1(pg, &dst[index], result); // Store result to dst\n\n        index += svcntw(); // Move to next vector chunk\n        pg = svwhilelt_b32(index, length); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[index]); // Load src vector\n        svuint32_t low_4_bits = svand_n_u32_z(pg, src_vec, 0xF); // Extract low 4 bits\n        svbool_t condition = svcmpeq_n_u32(pg, low_4_bits, 0xF); // Check if low 4 bits are all 1\n\n        svuint32_t rotated = svlsr_n_u32_z(pg, src_vec, 32 - rotate_bits); // Right shift for rotation\n        rotated = svorr_u32_z(pg, rotated, svlsl_n_u32_z(pg, src_vec, rotate_bits)); // Combine for rotation\n\n        svuint32_t negated = svnot_u32_z(pg, src_vec); // Bitwise negation\n\n        svuint32_t result = svsel_u32(condition, rotated, negated); // Select based on condition\n        svst1(pg, &dst[index], result); // Store result to dst\n\n        index += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit unsigned integers from src\n        svuint32_t src_vec = svld1(pg, &src[index]);\n\n        // Check if the low 4 bits of each element in src_vec are all 1\n        svuint32_t low_4_bits = svand_n_u32_x(pg, src_vec, 0xF); // Mask low 4 bits\n        svbool_t condition = svcmpeq_n_u32(pg, low_4_bits, 0xF); // Compare to 0xF\n\n        // Perform bitwise rotation for elements satisfying the condition\n        svuint32_t rotated = svorr_u32_x(pg, svlsl_n_u32_x(pg, src_vec, rotate_bits), svlsr_n_u32_x(pg, src_vec, 32 - rotate_bits));\n\n        // Perform bitwise negation for elements not satisfying the condition\n        svuint32_t negated = svnot_u32_x(pg, src_vec);\n\n        // Select between rotated and negated based on the condition\n        svuint32_t result = svsel_u32(condition, rotated, negated);\n\n        // Store the result into dst\n        svst1(pg, &dst[index], result);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load source vector\n        svuint32_t src_vec = svld1_u32(pg, &src[index]);\n\n        // Check if the low 4 bits of each element are all 1\n        svuint32_t low_4_bits = svand_u32_z(pg, src_vec, svdup_u32(0xF));\n        svbool_t condition = svcmpeq_u32(pg, low_4_bits, svdup_u32(0xF));\n\n        // Perform rotation for elements that satisfy the condition\n        svuint32_t rotated = svorr_u32_z(\n            condition,\n            svlsl_n_u32_z(condition, src_vec, rotate_bits),\n            svlsr_n_u32_z(condition, src_vec, 32 - rotate_bits)\n        );\n\n        // Perform bitwise negation for elements that do not satisfy the condition\n        svuint32_t negated = svnot_u32_z(svnot_b_z(pg, condition), src_vec);\n\n        // Combine results based on the condition\n        svuint32_t result = svsel_u32(condition, rotated, negated);\n\n        // Store the result in the destination vector\n        svst1_u32(pg, &dst[index], result);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    float abs_epsilon = svdup_f32(fabsf(epsilon)); // Broadcast absolute epsilon to all lanes\n\n    size_t i = 0;\n    while (i < length) {\n        // Load elements from A and B\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n\n        // Compute A - B\n        svfloat32_t diff = svsub_f32(vecA, vecB);\n\n        // Compare diff > abs_epsilon\n        svbool_t cmp_gt = svcmpgt_f32(pg, diff, abs_epsilon);\n\n        // Compare diff < -abs_epsilon\n        svfloat32_t neg_abs_epsilon = svneg_f32(abs_epsilon);\n        svbool_t cmp_lt = svcmplt_f32(pg, diff, neg_abs_epsilon);\n\n        // Compare abs(diff) <= abs_epsilon\n        svfloat32_t abs_diff = svabs_f32(diff);\n        svbool_t cmp_eq = svcmple_f32(pg, abs_diff, abs_epsilon);\n\n        // Create output values based on comparisons\n        svint8_t result_gt = svdup_s8(1);  // Value for diff > abs_epsilon\n        svint8_t result_lt = svdup_s8(-1); // Value for diff < -abs_epsilon\n        svint8_t result_eq = svdup_s8(0);  // Value for abs(diff) <= abs_epsilon\n\n        // Merge results into output vector\n        svint8_t result = svdup_s8(0); // Initialize result vector\n        result = svsel_s8(cmp_gt, result_gt, result);\n        result = svsel_s8(cmp_lt, result_lt, result);\n        result = svsel_s8(cmp_eq, result_eq, result);\n\n        // Store results to output tensor\n        svst1_s8(pg, &out[i], result);\n\n        // Advance index by the number of processed lanes\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    float abs_epsilon = svdup_f32(fabsf(epsilon)); // Broadcast absolute epsilon to all lanes\n\n    size_t i = 0;\n    while (i < length) {\n        svfloat32_t vecA = svld1(pg, &A[i]); // Load vector of A\n        svfloat32_t vecB = svld1(pg, &B[i]); // Load vector of B\n\n        svfloat32_t diff = svsub_f32_x(pg, vecA, vecB); // Compute A[i] - B[i]\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);   // Compute abs(A[i] - B[i])\n\n        svbool_t gt_eps = svcmpgt_f32(pg, diff, abs_epsilon);  // diff > abs(epsilon)\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, svneg_f32_x(pg, abs_epsilon)); // diff < -abs(epsilon)\n        svbool_t within_eps = svcmple_f32(pg, abs_diff, abs_epsilon); // abs(A[i] - B[i]) <= abs(epsilon)\n\n        svint8_t result = svdup_s8(0); // Initialize result vector to 0\n        result = svsel_s8(gt_eps, svdup_s8(1), result); // Set 1 where diff > abs(epsilon)\n        result = svsel_s8(lt_neg_eps, svdup_s8(-1), result); // Set -1 where diff < -abs(epsilon)\n\n        svst1(pg, &out[i], result); // Store result to output tensor\n\n        i += svcntw(); // Increment index by vector width\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    float abs_epsilon = svdup_f32(fabsf(epsilon)); // Broadcast absolute epsilon to all lanes\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vecA = svld1(pg, &A[index]); // Load vector of A\n        svfloat32_t vecB = svld1(pg, &B[index]); // Load vector of B\n\n        svfloat32_t diff = svsub_f32(vecA, vecB); // Compute A[i] - B[i]\n        svfloat32_t abs_diff = svabs_f32(diff);   // Compute abs(A[i] - B[i])\n\n        svbool_t greater = svcmpgt_f32(pg, diff, abs_epsilon); // Check A[i] - B[i] > abs(epsilon)\n        svbool_t less = svcmplt_f32(pg, diff, svneg_f32(abs_epsilon)); // Check A[i] - B[i] < -abs(epsilon)\n        svbool_t equal = svcmple_f32(pg, abs_diff, abs_epsilon); // Check abs(A[i] - B[i]) <= abs(epsilon)\n\n        svint8_t result = svdup_n_s8(0); // Initialize result vector with 0\n        result = svsel_s8(greater, svdup_n_s8(1), result); // Set 1 where greater\n        result = svsel_s8(less, svdup_n_s8(-1), result);  // Set -1 where less\n\n        svst1_s8(pg, &out[index], result); // Store result to output tensor\n\n        index += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(index, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    float abs_epsilon = svdup_f32(fabsf(epsilon)); // Broadcast absolute epsilon\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vecA = svld1(pg, &A[index]); // Load vector from A\n        svfloat32_t vecB = svld1(pg, &B[index]); // Load vector from B\n\n        svfloat32_t diff = svsub_f32(vecA, vecB); // Compute A[i] - B[i]\n        svfloat32_t abs_diff = svabs_f32(diff);  // Compute abs(A[i] - B[i])\n\n        svbool_t gt_eps = svcmpgt_f32(pg, diff, abs_epsilon); // diff > abs(epsilon)\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, svneg_f32(abs_epsilon)); // diff < -abs(epsilon)\n        svbool_t eq_eps = svcmple_f32(pg, abs_diff, abs_epsilon); // abs(diff) <= abs(epsilon)\n\n        svint8_t result = svdup_s8(0); // Initialize result vector to 0\n        result = svsel_s8(gt_eps, svdup_s8(1), result); // Set 1 where diff > abs(epsilon)\n        result = svsel_s8(lt_neg_eps, svdup_s8(-1), result); // Set -1 where diff < -abs(epsilon)\n\n        svst1(pg, &out[index], result); // Store result to output tensor\n\n        index += svcntw(); // Increment index by vector length\n        pg = svwhilelt_b32(index, length); // Update predicate for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active elements\n    float abs_epsilon = svdup_f32(fabsf(epsilon)); // Broadcast absolute epsilon to all lanes\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vecA = svld1(pg, &A[i]); // Load vector from A\n        svfloat32_t vecB = svld1(pg, &B[i]); // Load vector from B\n\n        svfloat32_t diff = svsub_f32(vecA, vecB); // Compute A[i] - B[i]\n        svfloat32_t abs_diff = svabs_f32(diff); // Compute abs(A[i] - B[i])\n\n        svbool_t greater = svcmpgt_f32(pg, diff, abs_epsilon); // A[i] - B[i] > abs(epsilon)\n        svbool_t less = svcmplt_f32(pg, diff, svneg_f32(abs_epsilon)); // A[i] - B[i] < -abs(epsilon)\n        svbool_t equal = svcmple_f32(pg, abs_diff, abs_epsilon); // abs(A[i] - B[i]) <= abs(epsilon)\n\n        svint8_t result = svdup_s8(0); // Initialize result vector to 0\n        result = svsel_s8(greater, svdup_s8(1), result); // Set 1 where greater\n        result = svsel_s8(less, svdup_s8(-1), result); // Set -1 where less\n\n        svst1(pg, &out[i], result); // Store result to output tensor\n\n        i += svcntw(); // Increment index by vector length\n        pg = svwhilelt_b32(i, length); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t i = 0;\n\n    // Define constants for INT32_MIN and INT32_MAX\n    const float int32_min_f = (float)INT32_MIN;\n    const float int32_max_f = (float)INT32_MAX;\n\n    // Process the array in chunks using SVE\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load a vector of floats from the source array\n        svfloat32_t vec_a = svld1(pg, &A[i]);\n\n        // Clamp the values to the range [INT32_MIN, INT32_MAX]\n        svfloat32_t clamped = svmin_f32_z(pg, svmax_f32_z(pg, vec_a, svdup_f32(int32_min_f)), svdup_f32(int32_max_f));\n\n        // Convert the clamped float values to int32_t\n        svint32_t vec_b = svcvt_s32_f32_z(pg, clamped);\n\n        // Store the converted values into the destination array\n        svst1(pg, &B[i], vec_b);\n\n        // Increment the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float INT32_MAX_F = (float)INT32_MAX;\n    const float INT32_MIN_F = (float)INT32_MIN;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of floats from A\n        svfloat32_t vecA = svld1(pg, &A[i]);\n\n        // Clamp values to INT32_MAX_F and INT32_MIN_F\n        svfloat32_t clamped = svmin_f32_m(pg, svdup_f32(INT32_MAX_F), svmax_f32_m(pg, svdup_f32(INT32_MIN_F), vecA));\n\n        // Convert clamped floats to int32_t\n        svint32_t vecB = svcvt_s32_f32_m(pg, clamped);\n\n        // Store the result in B\n        svst1(pg, &B[i], vecB);\n\n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Define INT32_MIN and INT32_MAX as constants\n    const float int32_min = (float)INT32_MIN;\n    const float int32_max = (float)INT32_MAX;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load a vector of floats from A\n        svfloat32_t vec_a = svld1(pg, &A[i]);\n\n        // Clamp the values to the range [INT32_MIN, INT32_MAX]\n        svfloat32_t clamped = svmin_f32_z(pg, svmax_f32_z(pg, vec_a, svdup_f32(int32_min)), svdup_f32(int32_max));\n\n        // Convert the clamped float values to int32_t\n        svint32_t vec_b = svcvt_s32_f32_z(pg, clamped);\n\n        // Store the results into B\n        svst1(pg, &B[i], vec_b);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t i = 0;\n\n    // Define constants for INT32_MIN and INT32_MAX\n    const float int32_min_f = (float)INT32_MIN;\n    const float int32_max_f = (float)INT32_MAX;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load a vector of floats from the source array\n        svfloat32_t vec_a = svld1(pg, &A[i]);\n\n        // Clamp the values to the range [INT32_MIN, INT32_MAX]\n        svfloat32_t clamped = svmin_f32_z(pg, svmax_f32_z(pg, vec_a, svdup_f32(int32_min_f)), svdup_f32(int32_max_f));\n\n        // Convert the clamped float values to int32_t\n        svint32_t vec_b = svcvt_s32_f32_z(pg, clamped);\n\n        // Store the results in the destination array\n        svst1(pg, &B[i], vec_b);\n\n        // Increment the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float INT32_MAX_F = (float)INT32_MAX;\n    const float INT32_MIN_F = (float)INT32_MIN;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active lanes\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of floats from A\n        svfloat32_t vecA = svld1(pg, &A[i]);\n\n        // Clamp values to INT32_MIN_F and INT32_MAX_F\n        svfloat32_t clamped = svmin_f32_m(pg, svdup_f32(INT32_MAX_F), svmax_f32_m(pg, svdup_f32(INT32_MIN_F), vecA));\n\n        // Convert clamped float values to int32_t\n        svint32_t vecB = svcvt_s32_f32_m(pg, clamped);\n\n        // Store the result into B\n        svst1(pg, &B[i], vecB);\n\n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load int32_t values from A\n        svint32_t vecA = svld1_s32(pg, &A[index]);\n\n        // Convert int32_t to float\n        svfloat32_t vecB = svcvt_f32_s32(vecA);\n\n        // Scale the float values\n        svfloat32_t scaledB = svmul_f32_x(pg, vecB, svdup_n_f32((float)scale));\n\n        // Store the results in B\n        svst1_f32(pg, &B[index], scaledB);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhile32_b32(0, size); // Predicate for active vector elements\n    svfloat32_t scale_vec = svdup_f32((float)scale); // Broadcast scale factor to all lanes\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svint32_t vecA = svld1(pg, &A[index]); // Load int32_t elements from A\n        svfloat32_t vecA_float = svcvt_f32_s32(vecA); // Convert int32_t to float\n        svfloat32_t vecB = svmul_f32_x(pg, vecA_float, scale_vec); // Scale the values\n        svst1(pg, &B[index], vecB); // Store the scaled float values into B\n\n        index += svcntw(); // Move to the next vector chunk\n        pg = svwhile32_b32(index, size); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load int32_t values from A\n        svint32_t vecA = svld1_s32(pg, &A[index]);\n\n        // Convert int32_t to float\n        svfloat32_t vecB = svcvt_f32_s32_x(pg, vecA);\n\n        // Scale the float values\n        svfloat32_t scaledB = svmul_n_f32_x(pg, vecB, (float)scale);\n\n        // Store the scaled float values into B\n        svst1_f32(pg, &B[index], scaledB);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for loop bounds\n    int index = 0;\n\n    // Broadcast the scale factor to all lanes\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load int32_t values from A\n        svint32_t vec_a = svld1_s32(pg, &A[index]);\n\n        // Convert int32_t to float\n        svfloat32_t vec_a_float = svcvt_f32_s32(vec_a);\n\n        // Scale the float values\n        svfloat32_t vec_b = svmul_f32_x(pg, vec_a_float, scale_vec);\n\n        // Store the scaled float values to B\n        svst1_f32(pg, &B[index], vec_b);\n\n        // Increment index and update predicate\n        index += svcntw();\n        pg = svwhilelt_b32(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t scale_vec = svdup_s32(scale); // Broadcast scale factor to all lanes\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load int32_t values from A\n        svint32_t vec_a = svld1_s32(pg, &A[index]);\n\n        // Convert int32_t to float\n        svfloat32_t vec_a_float = svcvt_f32_s32_x(pg, vec_a);\n\n        // Scale the float values\n        svfloat32_t vec_b = svmul_f32_x(pg, vec_a_float, svcvt_f32_s32_x(pg, scale_vec));\n\n        // Store the result in B\n        svst1_f32(pg, &B[index], vec_b);\n\n        // Update index and predicate for next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors from A and B\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vecDiv = svdiv_f32_z(pg, vecA, vecB);\n\n        // Round to nearest integer\n        svfloat32_t vecRounded = svrintn_f32_z(pg, vecDiv);\n\n        // Convert to 32-bit integer\n        svint32_t vecInt = svcvt_s32_f32_z(pg, vecRounded);\n\n        // Store the result in C\n        svst1(pg, &C[i], vecInt);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from A and B\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vecDiv = svdiv_f32_z(pg, vecA, vecB);\n\n        // Round to nearest integer\n        svfloat32_t vecRounded = svrintn_f32_z(pg, vecDiv);\n\n        // Convert to int32_t\n        svint32_t vecResult = svcvt_s32_f32_z(pg, vecRounded);\n\n        // Store the result in C\n        svst1(pg, &C[i], vecResult);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load vectors of floats from A and B\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vecDiv = svdiv_f32_z(pg, vecA, vecB);\n\n        // Round to the nearest integer\n        svfloat32_t vecRounded = svrintn_f32_z(pg, vecDiv);\n\n        // Convert rounded floats to 32-bit integers\n        svint32_t vecInt = svcvt_s32_f32_z(pg, vecRounded);\n\n        // Store the result in C\n        svst1(pg, &C[i], vecInt);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Create predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) { // Loop while there are active elements\n        svfloat32_t vecA = svld1(pg, &A[i]); // Load vector from A\n        svfloat32_t vecB = svld1(pg, &B[i]); // Load vector from B\n        svfloat32_t vecDiv = svdiv_f32_z(pg, vecA, vecB); // Perform element-wise division\n        svint32_t vecRounded = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vecDiv)); // Round to nearest and convert to int32_t\n        svst1(pg, &C[i], vecRounded); // Store result in C\n        i += svcntw(); // Increment index by vector width\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load vectors from A and B\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svld1(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t div_vec = svdiv_f32_z(pg, a_vec, b_vec);\n\n        // Round to the nearest integer\n        svfloat32_t rounded_vec = svrinta_f32_z(pg, div_vec, SV_RINTA);\n\n        // Convert to 32-bit integers\n        svint32_t int_vec = svcvt_s32_f32_z(pg, rounded_vec);\n\n        // Store the result in C\n        svst1(pg, &C[i], int_vec);\n\n        // Increment the index\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for loop bounds\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load double values from A\n        svfloat64_t vecA = svld1(pg, &A[index]);\n\n        // Convert double to float with saturation\n        svfloat32_t vecB = svcvt_f32_f64_x(pg, vecA);\n\n        // Saturate values greater than FLT_MAX\n        svfloat32_t max_val = svdup_f32(FLT_MAX);\n        vecB = svmin_f32_x(pg, vecB, max_val);\n\n        // Saturate values less than -FLT_MAX\n        svfloat32_t min_val = svdup_f32(-FLT_MAX);\n        vecB = svmax_f32_x(pg, vecB, min_val);\n\n        // Store the results in B\n        svst1(pg, &B[index], vecB);\n\n        // Update index and predicate for next iteration\n        index += svcntw();\n        pg = svwhilelt_b64(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // FLT_MAX as SVE vector\n    svfloat32_t flt_max_vec = svdup_f32(FLT_MAX);\n    svfloat32_t neg_flt_max_vec = svdup_f32(-FLT_MAX);\n\n    while ((pg = svwhilelt_b64(i, size))) {\n        // Load double values from A\n        svfloat64_t a_vec = svld1(pg, &A[i]);\n\n        // Convert double to float\n        svfloat32_t b_vec = svcvt_f32_f64_z(pg, a_vec);\n\n        // Saturate values to FLT_MAX and -FLT_MAX\n        b_vec = svmin_f32_z(pg, b_vec, flt_max_vec);\n        b_vec = svmax_f32_z(pg, b_vec, neg_flt_max_vec);\n\n        // Store the result in B\n        svst1(pg, &B[i], b_vec);\n\n        // Increment index\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load double values from A\n        svfloat64_t vecA = svld1(pg, &A[index]);\n\n        // Convert double to float\n        svfloat32_t vecB = svcvt_f32_f64(vecA);\n\n        // Saturate values greater than FLT_MAX\n        svfloat32_t max_vec = svdup_f32(FLT_MAX);\n        vecB = svmin_f32_x(pg, vecB, max_vec);\n\n        // Saturate values less than -FLT_MAX\n        svfloat32_t min_vec = svdup_f32(-FLT_MAX);\n        vecB = svmax_f32_x(pg, vecB, min_vec);\n\n        // Store the results in B\n        svst1(pg, &B[index], vecB);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b64(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load a vector of double values from A\n        svfloat64_t vecA = svld1(pg, &A[index]);\n\n        // Convert double to float with saturation\n        svfloat32_t vecB = svcvt_f32_f64_x(pg, vecA);\n\n        // Saturate values greater than FLT_MAX\n        svfloat32_t max_val = svdup_f32(FLT_MAX);\n        vecB = svmin_f32_x(pg, vecB, max_val);\n\n        // Saturate values less than -FLT_MAX\n        svfloat32_t min_val = svdup_f32(-FLT_MAX);\n        vecB = svmax_f32_x(pg, vecB, min_val);\n\n        // Store the result in B\n        svst1(pg, &B[index], vecB);\n\n        // Update index and predicate for the next iteration\n        index += svcntw();\n        pg = svwhilelt_b64(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load a vector of double values from A\n        svfloat64_t vecA = svld1(pg, &A[index]);\n\n        // Convert double to float with saturation\n        svfloat32_t vecB = svcvt_f32_f64_z(pg, vecA);\n\n        // Saturate values greater than FLT_MAX\n        svfloat32_t max_val = svdup_f32(FLT_MAX);\n        vecB = svmin_f32_z(pg, vecB, max_val);\n\n        // Saturate values less than -FLT_MAX\n        svfloat32_t min_val = svdup_f32(-FLT_MAX);\n        vecB = svmax_f32_z(pg, vecB, min_val);\n\n        // Store the result in B\n        svst1(pg, &B[index], vecB);\n\n        // Update index and predicate\n        index += svcntd();\n        pg = svwhilelt_b64(index, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, size))) {\n        // Load 16-bit integers from A\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n\n        // Convert 16-bit integers to 32-bit integers\n        svint32_t vecB = svcvt_s32_s16(vecA);\n\n        // Store the 32-bit integers into B\n        svst1_s32(pg, &B[i], vecB);\n\n        // Increment the index by the number of active elements in the vector\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, size))) {\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n        svint32_t vecB = svcvt_s32_s16_x(pg, vecA);\n        svst1_s32(pg, &B[i], vecB);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, size))) {\n        svint16_t vecA = svld1_s16(pg, &A[i]); // Load int16_t values from A\n        svint32_t vecB = svcvt_s32_s16_x(pg, vecA); // Convert int16_t to int32_t\n        svst1_s32(pg, &B[i], vecB); // Store int32_t values into B\n        i += svcntw(); // Increment index by the number of elements processed\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, size))) {\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n        svint32_t vecB = svcvt_s32_s16_x(pg, vecA);\n        svst1_s32(pg, &B[i], vecB);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b16(i, size))) {\n        // Load int16_t elements from A\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n\n        // Convert int16_t to int32_t\n        svint32_t vec_b = svcvt_s32_s16_x(pg, vec_a);\n\n        // Store the converted int32_t elements into B\n        svst1_s32(pg, &B[i], vec_b);\n\n        // Increment the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_z(svptrue_b32(), max_val_vec, min_val_vec);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        // Normalize A[i] if control[i] > 0\n        svbool_t control_mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n        svfloat32_t normalized_vec = svdiv_f32_z(control_mask, svsub_f32_z(control_mask, a_vec, min_val_vec), range_vec);\n        normalized_vec = svmax_f32_z(control_mask, zero_vec, svmin_f32_z(control_mask, normalized_vec, one_vec));\n\n        // Copy A[i] directly if control[i] <= 0\n        svfloat32_t result_vec = svsel_f32(control_mask, normalized_vec, a_vec);\n\n        // Store the result in B\n        svst1(pg, &B[i], result_vec);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_val_vec, min_val_vec);\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svint32_t control_vec = svld1(pg, &control[i]);\n        svfloat32_t normalized_vec = svdiv_f32_x(pg, svsub_f32_x(pg, a_vec, min_val_vec), range_vec);\n\n        // Clamp normalized values to [0.0, 1.0]\n        normalized_vec = svmax_f32_x(pg, svdup_f32(0.0f), normalized_vec);\n        normalized_vec = svmin_f32_x(pg, svdup_f32(1.0f), normalized_vec);\n\n        // Create a mask for control > 0\n        svbool_t mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n\n        // Select normalized values or original values based on the mask\n        svfloat32_t result_vec = svsel_f32(mask, normalized_vec, a_vec);\n\n        // Store the result in B\n        svst1(pg, &B[i], result_vec);\n\n        // Advance the loop\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_val_vec, min_val_vec);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n\n        svfloat32_t normalized_vec = svdiv_f32_x(pg, svsub_f32_x(pg, a_vec, min_val_vec), range_vec);\n        normalized_vec = svmax_f32_x(pg, normalized_vec, zero_vec);\n        normalized_vec = svmin_f32_x(pg, normalized_vec, one_vec);\n\n        svfloat32_t result_vec = svsel_f32(mask, normalized_vec, a_vec);\n\n        svst1_f32(pg, &B[i], result_vec);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_z(svptrue_b32(), max_val_vec, min_val_vec);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n\n        svfloat32_t normalized = svdiv_f32_z(mask, svsub_f32_z(mask, a_vec, min_val_vec), range_vec);\n        normalized = svmax_f32_z(mask, normalized, zero_vec);\n        normalized = svmin_f32_z(mask, normalized, one_vec);\n\n        svfloat32_t result = svsel_f32(mask, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_z(svptrue_b32(), max_val_vec, min_val_vec);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n\n        svfloat32_t normalized_vec = svdiv_f32_z(pg, svsub_f32_z(pg, a_vec, min_val_vec), range_vec);\n        normalized_vec = svmax_f32_z(pg, normalized_vec, zero_vec);\n        normalized_vec = svmin_f32_z(pg, normalized_vec, one_vec);\n\n        svfloat32_t result_vec = svsel_f32(mask, normalized_vec, a_vec);\n\n        svst1(pg, &B[i], result_vec);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n\n        // Extract the high 16 bits of each uint32_t value\n        svuint32_t vec_high16 = svlsr_n_u32_z(pg, vec_a, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t vec_float = svcvt_f32_u32_z(pg, vec_high16);\n\n        // Compute the square root of the float values\n        svfloat32_t vec_sqrt = svsqrt_f32_z(pg, vec_float);\n\n        // Store the result into B\n        svst1_f32(pg, &B[i], vec_sqrt);\n\n        // Increment the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements in the loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load uint32_t values from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Extract high 16 bits and convert to float\n        svuint32_t highBits = svlsr_n_u32_x(pg, vecA, 16); // Logical shift right by 16 bits\n        svfloat32_t floatVals = svcvt_f32_u32_x(pg, highBits);\n\n        // Compute square root\n        svfloat32_t sqrtVals = svsqrt_f32_x(pg, floatVals);\n\n        // Store results in B\n        svst1(pg, &B[i], sqrtVals);\n\n        // Update index and predicate\n        i += svcntw(); // Increment by the number of elements processed in one vector\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load uint32_t values from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Extract high 16 bits and convert to float\n        svuint32_t high16 = svlsr_n_u32_x(pg, vecA, 16);\n        svfloat32_t vecFloat = svcvt_f32_u32_x(pg, high16);\n\n        // Compute square root\n        svfloat32_t vecSqrt = svsqrt_f32_x(pg, vecFloat);\n\n        // Store results in B\n        svst1_f32(pg, &B[i], vecSqrt);\n\n        // Increment index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load 32-bit unsigned integers from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Extract the high 16 bits by shifting right\n        svuint32_t high16 = svlsr_n_u32_x(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVals = svcvt_f32_u32_x(pg, high16);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVals = svsqrt_f32_x(pg, floatVals);\n\n        // Store the results in B\n        svst1_f32(pg, &B[i], sqrtVals);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Create a predicate for the loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load 32-bit unsigned integers from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Extract the high 16 bits by shifting right\n        svuint32_t high16 = svlsr_n_u32(vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t vecFloat = svcvt_f32_u32(high16);\n\n        // Compute the square root of the float values\n        svfloat32_t vecSqrt = svsqrt_f32(vecFloat);\n\n        // Store the results in B\n        svst1_f32(pg, &B[i], vecSqrt);\n\n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]); // Load uint32_t values from A\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA); // Reinterpret bits as float\n        svst1_f32(pg, &B[i], vecB); // Store the float values into B\n        i += svcntw(); // Increment index by the number of elements processed\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        svuint32_t vec_int = svld1_u32(pg, &A[i]); // Load uint32_t values from A\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_int); // Reinterpret as float\n        svst1_f32(pg, &B[i], vec_float); // Store the float values into B\n        i += svcntw(); // Increment index by the vector length\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load uint32_t values from A\n        svuint32_t int_vec = svld1_u32(pg, &A[i]);\n\n        // Reinterpret the uint32_t vector as float vector\n        svfloat32_t float_vec = svreinterpret_f32_u32(int_vec);\n\n        // Store the float vector into B\n        svst1_f32(pg, &B[i], float_vec);\n\n        // Increment the index by the active vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    while (i < size) {\n        // Determine the number of elements the current SVE vector can handle\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load uint32_t values from A into an SVE vector\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Reinterpret the uint32_t vector as a float vector\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA);\n\n        // Store the float vector into B\n        svst1_f32(pg, &B[i], vecB);\n\n        // Advance the index by the number of elements processed\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, size))) {\n        // Load uint32_t values from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Reinterpret the uint32_t vector as float vector\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA);\n\n        // Store the float values into B\n        svst1_f32(pg, &B[i], vecB);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1; // Start from the second element\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load current and previous elements of A\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t prev = svld1(pg, &A[i - 1]);\n\n        // Load condition array\n        svbool_t cond_mask = svld1_b8(pg, &cond[i]);\n\n        // Compute difference (curr - prev)\n        svint32_t diff_int = svsub_s32_m(cond_mask, curr, prev);\n\n        // Convert to float\n        svfloat32_t diff_float = svcvt_f32_s32_m(cond_mask, svundef_f32(), diff_int);\n\n        // Set diff[i] to 0.0f where cond[i] is false\n        diff_float = svsel_f32(cond_mask, diff_float, svdup_f32(0.0f));\n\n        // Store the result in diff\n        svst1(pg, &diff[i], diff_float);\n\n        // Update predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1; // Start from the second element\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load current and previous elements of A\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t prev = svld1(pg, &A[i - 1]);\n\n        // Load condition values\n        svbool_t cond_mask = svld1_b8(pg, &cond[i]);\n\n        // Compute the difference (curr - prev) where condition is true\n        svint32_t diff_int = svsub_m(cond_mask, curr, prev);\n\n        // Convert the difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Mask out elements where condition is false (set to 0.0f)\n        diff_float = svsel(cond_mask, diff_float, svdup_f32(0.0f));\n\n        // Store the result in the diff array\n        svst1(pg, &diff[i], diff_float);\n\n        // Update the predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always set to 0.0f\n\n    size_t i = 1; // Start from the second element\n    svbool_t pg = svwhilelt_b32(i, size); // Create predicate for loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load current and previous elements of A\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t prev = svld1(pg, &A[i - 1]);\n\n        // Compute difference\n        svint32_t diff_int = svsub_s32_x(pg, curr, prev);\n\n        // Convert difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Load condition array\n        svbool_t cond_mask = svld1_b8(pg, &cond[i]);\n\n        // Apply condition: set diff[i] to 0.0f if cond[i] is false\n        svfloat32_t result = svsel_f32(cond_mask, diff_float, svdup_f32(0.0f));\n\n        // Store result in diff array\n        svst1(pg, &diff[i], result);\n\n        // Update loop predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1; // Start from the second element\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load current and previous elements of A\n        svint32_t curr = svld1(pg, &A[i]);\n        svint32_t prev = svld1(pg, &A[i - 1]);\n\n        // Compute the difference (A[i] - A[i-1])\n        svint32_t diff_int = svsub_s32_m(pg, curr, prev);\n\n        // Convert the difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_m(pg, diff_int);\n\n        // Load the condition array\n        svbool_t cond_mask = svld1_b8(pg, &cond[i]);\n\n        // Apply the condition: set diff[i] to 0.0f if cond[i] is false\n        svfloat32_t result = svsel_f32(cond_mask, diff_float, svdup_f32(0.0f));\n\n        // Store the result in the diff array\n        svst1(pg, &diff[i], result);\n\n        // Update the predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1; // Start from the second element\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load current and previous elements of A\n        svint32_t current = svld1(pg, &A[i]);\n        svint32_t previous = svld1(pg, &A[i - 1]);\n\n        // Load condition array\n        svbool_t cond_mask = svld1_b8(pg, &cond[i]);\n\n        // Compute difference (current - previous)\n        svint32_t diff_int = svsub_s32_x(pg, current, previous);\n\n        // Convert difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Apply condition: set diff[i] to 0.0f if cond[i] is false\n        svfloat32_t result = svsel_f32(cond_mask, diff_float, svdup_f32(0.0f));\n\n        // Store result in diff array\n        svst1(pg, &diff[i], result);\n\n        // Update predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        // Load 32-bit unsigned integers from src\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        // Widen to 64-bit unsigned integers\n        svuint64_t widened_vec = svunpklo_u64(src_vec);\n\n        // Set the high 32 bits to 1\n        svuint64_t result_vec = svorr_u64_x(pg, widened_vec, svdup_n_u64(0xFFFFFFFF00000000));\n\n        // Store the result in dst\n        svst1_u64(pg, &dst[i], result_vec);\n\n        // Increment index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    while (i < length) {\n        // Determine the number of elements that can be processed in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load 32-bit unsigned integers from src\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n\n        // Widen to 64-bit unsigned integers\n        svuint64_t vec_dst = svwiden_u32(vec_src);\n\n        // Set high 32 bits to 1 (bitwise OR with 0xFFFFFFFF00000000)\n        svuint64_t vec_result = svorr_u64_x(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000));\n\n        // Store the results in dst\n        svst1_u64(pg, &dst[i], vec_result);\n\n        // Advance the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b32(i, length))) {\n        // Load 32-bit unsigned integers from src\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        // Widen to 64-bit unsigned integers\n        svuint64_t widened_vec = svunpklo_u64(src_vec);\n\n        // Set high 32 bits to 1 (bitwise OR with 0xFFFFFFFF00000000)\n        svuint64_t result_vec = svorr_u64_x(pg, widened_vec, svdup_n_u64(0xFFFFFFFF00000000));\n\n        // Store the result in dst\n        svst1_u64(pg, &dst[i], result_vec);\n\n        // Increment index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    while (i < length) {\n        // Determine the number of elements that fit in the vector\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load 32-bit unsigned integers from the source array\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        // Widen the 32-bit integers to 64-bit integers\n        svuint64_t widened_vec = svunpklo_u64(src_vec);\n\n        // Set the high 32 bits of each 64-bit integer to 1\n        svuint64_t result_vec = svorr_u64_x(pg, widened_vec, svdup_n_u64(0xFFFFFFFF00000000));\n\n        // Store the results in the destination array\n        svst1_u64(pg, &dst[i], result_vec);\n\n        // Advance the index by the number of processed elements\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process elements in chunks using SVE\n    while (i < length) {\n        // Determine the vector length for the current iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n\n        // Load 32-bit unsigned integers from the source array\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n\n        // Widen to 64-bit unsigned integers\n        svuint64_t widened_vec = svwiden_u64(src_vec);\n\n        // Set the high 32 bits of each 64-bit value to 1\n        svuint64_t result_vec = svorr_u64_x(pg, widened_vec, svdup_n_u64(0xFFFFFFFF00000000));\n\n        // Store the results in the destination array\n        svst1_u64(pg, &dst[i], result_vec);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for loop bounds\n    svfloat64_t sum_vec = svdup_f64(0.0);   // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(pg, pg); i += svcntw()) {\n        svint16_t indices = svld1(pg, &index[i]); // Load indices\n        svbool_t valid_pg = svcmpge_n_s16(pg, indices, 0); // Check indices >= 0\n        valid_pg = svand_b_z(valid_pg, valid_pg, svcmplt_n_s16(pg, indices, length)); // Check indices < length\n\n        svfloat64_t values = svld1_gather_index(pg, vec, indices); // Gather values from vec using indices\n        sum_vec = svadd_m(valid_pg, sum_vec, values); // Add valid values to sum_vec\n\n        pg = svwhilelt_b16(i + svcntw(), length); // Update predicate for next iteration\n    }\n\n    result = svaddv_f64(svptrue_b64(), sum_vec); // Reduce sum_vec to scalar\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    size_t i = 0;\n    while (i < length) {\n        // Load indices into a vector\n        svint16_t indices = svld1(pg, &index[i]);\n\n        // Convert indices to 64-bit integers for indexing\n        svuint64_t indices_u64 = svcvt_u64_s16_x(pg, indices);\n\n        // Gather elements from vec using indices\n        svfloat64_t gathered = svld1_gather_u64index(pg, vec, indices_u64);\n\n        // Accumulate the gathered elements\n        result += svaddv(pg, gathered);\n\n        // Advance the loop by the vector length\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    size_t i = 0;\n    while (i < length) {\n        // Load indices in chunks using SVE\n        svint16_t indices = svld1(pg, &index[i]);\n\n        // Convert indices to 64-bit integers for indexing\n        svuint64_t indices_u64 = svcvt_u64_s16_x(pg, indices);\n\n        // Gather elements from vec using indices\n        svfloat64_t gathered = svld1_gather_u64index(pg, vec, indices_u64);\n\n        // Accumulate the gathered values\n        result += svaddv(pg, gathered);\n\n        // Advance by the vector length\n        i += svcntd();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for loop control\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        // Load indices using SVE\n        svint16_t indices = svld1(pg, &index[i]);\n\n        // Gather elements from vec based on indices\n        svfloat64_t gathered = svld1_gather_index(pg, vec, indices);\n\n        // Perform horizontal addition of gathered elements\n        result += svaddv(pg, gathered);\n\n        // Update loop index and predicate\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b16(); // Predicate for active elements\n    svfloat64_t sum = svdup_f64(0.0); // Initialize sum vector to 0\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        // Load a vector of indices\n        svint16_t indices = svld1(pg, &index[i]);\n\n        // Check if indices are within bounds [0, length)\n        svbool_t valid = svand_z(pg, svcmpge(pg, indices, svdup_s16(0)), svcmplt(pg, indices, svdup_s16((int16_t)length)));\n\n        // Convert valid indices to 64-bit for gather\n        svuint64_t valid_indices = svcvt_u64_s16_z(valid, indices);\n\n        // Gather elements from vec based on valid indices\n        svfloat64_t gathered = svld1_gather_index(pg, vec, valid_indices);\n\n        // Accumulate the valid gathered elements\n        sum = svadd_m(valid, sum, gathered);\n    }\n\n    // Reduce the sum vector to a scalar\n    result = svaddv(pg, sum);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svbool_t pg = svptrue_b64(); // Predicate for active lanes\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to zero\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    svfloat64_t input_vec = svld1(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n\n                    sum_vec = svmla_f64_x(pg, sum_vec, input_vec, kernel_vec); // Multiply-accumulate\n                }\n            }\n\n            // Perform horizontal addition to reduce the vector sum\n            double sum = svaddv_f64(pg, sum_vec);\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svbool_t pg = svptrue_b64(); // Predicate for active lanes\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n\n                    size_t input_idx = input_row * input_size + input_col;\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    svfloat64_t input_vec = svld1(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n\n                    sum_vec = svmla_f64_x(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Horizontal add to reduce the sum vector to a scalar\n            double sum = svaddv(pg, sum_vec);\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t acc = svdup_f64(0.0); // Initialize accumulator to zero\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    svbool_t pg = svwhilelt_b64(0, 1); // Predicate for single element\n                    svfloat64_t input_vec = svld1(pg, &input[input_index]);\n                    svfloat64_t kernel_vec = svld1(pg, &kernel[kernel_index]);\n\n                    acc = svmla_f64_m(pg, acc, input_vec, kernel_vec); // Multiply-accumulate\n                }\n            }\n\n            // Apply ReLU activation\n            svfloat64_t zero_vec = svdup_f64(0.0);\n            acc = svmax_f64_z(svptrue_b64(), acc, zero_vec);\n\n            // Store the result in the output array\n            size_t output_index = i * output_size + j;\n            svbool_t pg = svwhilelt_b64(0, 1); // Predicate for single element\n            svst1(pg, &output[output_index], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svbool_t pg = svptrue_b64(); // Predicate for active elements\n            svfloat64_t sum_vec = svdup_f64(0.0); // Initialize sum vector to 0\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    svfloat64_t input_vec = svld1(pg, &input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n\n                    sum_vec = svmla_f64_x(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Horizontal add to reduce the vector sum to a scalar\n            double sum = svaddv(pg, sum_vec);\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    svfloat64_t input_vec = svld1(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n\n                    sum_vec = svmla_f64_x(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            double sum = svaddv_f64(pg, sum_vec);\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t current = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n\n        while (svptest_any(pg, pg)) {\n            svfloat64_t other = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svsub_f64_z(pg, current, other);\n            svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n            svbool_t mask = svcmplt_f64(pg, abs_diff, threshold_vec);\n\n            if (svptest_any(pg, mask)) {\n                return true;\n            }\n\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t current = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n\n        while (pg = svwhilelt_b64(j, n)) {\n            svfloat64_t other = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svsub_f64_x(pg, current, other);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t cmp = svcmplt_f64(pg, abs_diff, threshold_vec);\n\n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n\n            j += svcntd();\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t current = svdup_f64(numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            size_t remaining = n - j;\n            svbool_t pg_active = svwhilelt_b64(0, remaining);\n\n            svfloat64_t other = svld1(pg_active, &numbers[j]);\n            svfloat64_t diff = svsub_f64_x(pg_active, current, other);\n            svfloat64_t abs_diff = svabs_f64_x(pg_active, diff);\n\n            svbool_t close = svcmplt_f64(pg_active, abs_diff, threshold_vec);\n            if (svptest_any(pg_active, close)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64(); // Predicate for active elements\n    svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold to all lanes\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t base_vec = svdup_f64(numbers[i]); // Broadcast the current number to all lanes\n\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            size_t remaining = n - j;\n            svbool_t active = svwhilelt_b64(0, remaining); // Predicate for remaining elements\n            svfloat64_t compare_vec = svld1(active, &numbers[j]); // Load the next chunk of numbers\n\n            svfloat64_t diff_vec = svsub_f64_x(active, base_vec, compare_vec); // Compute differences\n            svfloat64_t abs_diff_vec = svabs_f64_x(active, diff_vec); // Take absolute differences\n\n            svbool_t close_mask = svcmplt_f64(active, abs_diff_vec, threshold_vec); // Check if differences are less than threshold\n            if (svptest_any(pg, close_mask)) { // If any lane satisfies the condition\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg;\n    svfloat64_t vec_i, vec_j, diff;\n    svbool_t cmp_result;\n\n    for (size_t i = 0; i < n; ++i) {\n        vec_i = svdup_f64(numbers[i]); // Broadcast numbers[i] to all lanes\n\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            pg = svwhilelt_b64(j, n); // Predicate for valid lanes\n            vec_j = svld1(pg, &numbers[j]); // Load elements from numbers[j] onwards\n            diff = svsub_f64_x(pg, vec_i, vec_j); // Compute differences\n            diff = svabs_f64_x(pg, diff); // Take absolute value of differences\n            cmp_result = svcmplt_f64(pg, diff, threshold); // Compare with threshold\n\n            if (svptest_any(pg, cmp_result)) { // Check if any comparison is true\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    size_t size = operations.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &operations[i]); // Load vector of operations\n        svint32_t balances = svdup_n_s32(balance); // Duplicate current balance\n        balances = svadd_s32_m(pg, balances, vec); // Update balances in parallel\n\n        // Check if any balance falls below zero\n        svbool_t below_zero = svcmplt_s32(pg, balances, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), below_zero)) {\n            return true;\n        }\n\n        // Update scalar balance for next iteration\n        balance = svlastb_s32(pg, balances);\n        i += svcntw(); // Move to next chunk\n        pg = svwhilelt_b32(i, size); // Update predicate for next chunk\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    size_t size = operations.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhile32(svtrue_b32(), size - i); // Predicate for active elements\n    while (svptest_any(svtrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &operations[i]); // Load vector of operations\n        svint32_t balances = svdup_s32(balance);   // Duplicate current balance\n        balances = svadd_s32_m(pg, balances, vec); // Update balances using vector addition\n\n        if (svptest_any(svtrue_b32(), svcmplt_s32(pg, balances, svdup_s32(0)))) {\n            return true; // Return true if any balance falls below zero\n        }\n\n        balance = svlastb_s32(pg, balances); // Update the scalar balance\n        i += svcntw();                      // Move to the next chunk\n        pg = svwhile32(svtrue_b32(), size - i); // Update predicate for remaining elements\n    }\n\n    return false; // Return false if no balance falls below zero\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n\n    for (int i = 0; i < n;) {\n        svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n        svint32_t vec = svld1_s32(pg, &operations[i]); // Load vector of operations\n        svint32_t balance_vec = svdup_s32(balance); // Duplicate current balance\n\n        balance_vec = svadd_s32_m(pg, balance_vec, vec); // Compute new balances\n\n        if (svptest_any(pg, svcmplt_s32(pg, balance_vec, svdup_s32(0)))) {\n            return true; // If any balance is below zero, return true\n        }\n\n        balance = svlastb_s32(pg, balance_vec); // Update scalar balance\n        i += svcntw(); // Increment by vector width\n    }\n\n    return false; // No balance fell below zero\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    size_t n = operations.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &operations[i]); // Load vector of operations\n        svint32_t balances = svdup_n_s32(balance); // Duplicate current balance\n        balances = svadd_s32_m(pg, balances, vec); // Update balances with operations\n\n        // Check if any balance falls below zero\n        svbool_t below_zero = svcmplt_s32(pg, balances, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), below_zero)) {\n            return true;\n        }\n\n        // Update the scalar balance for the next iteration\n        balance = svlastb_s32(pg, balances);\n\n        i += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(i, n); // Update predicate\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    size_t n = operations.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &operations[i]); // Load vector of operations\n        svint32_t balances = svdup_n_s32(balance); // Duplicate current balance\n        balances = svadd_s32_m(pg, balances, vec); // Update balances in parallel\n\n        // Check if any balance falls below zero\n        svbool_t below_zero = svcmplt_s32(pg, balances, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), below_zero)) {\n            return true;\n        }\n\n        // Update the scalar balance for the next iteration\n        balance = svlastb_s32(pg, balances);\n\n        i += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(i, n); // Update predicate\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / n;\n\n    // Calculate Mean Absolute Deviation using SVE\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64_m(pg, vec, svdup_f64(mean));\n        svfloat64_t abs_diff = svabs_f64_m(pg, diff);\n        mad_vec = svadd_f64_m(pg, mad_vec, abs_diff);\n    }\n    double mad_sum = svaddv_f64(svptrue_b64(), mad_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean of the numbers\n    double sum = 0.0;\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        sum_vec = svadd_m(pg, sum_vec, vec);\n    }\n    sum = svaddv(pg, sum_vec);\n    double mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation (MAD)\n    double mad_sum = 0.0;\n    svfloat64_t mad_sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_m(pg, vec, svdup_f64(mean));\n        svfloat64_t abs_diff = svabs_f64_m(pg, diff);\n        mad_sum_vec = svadd_m(pg, mad_sum_vec, abs_diff);\n    }\n    mad_sum = svaddv(pg, mad_sum_vec);\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t active = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(active, &numbers[i]);\n        sum_vec = svadd_m(active, sum_vec, vec);\n    }\n    double sum = svaddv(pg, sum_vec);\n    double mean = sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t active = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(active, &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64_m(active, svsub_f64_m(active, vec, mean_vec));\n        mad_vec = svadd_m(active, mad_vec, abs_diff);\n    }\n    double mad_sum = svaddv(pg, mad_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Step 1: Calculate the mean\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n    double sum = svaddv(pg, sum_vec);\n    double mean = sum / n;\n\n    // Step 2: Calculate the Mean Absolute Deviation\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64_m(pg, vec, svdup_f64(mean));\n        svfloat64_t abs_diff = svabs_f64_m(pg, diff);\n        mad_vec = svadd_f64_m(pg, mad_vec, abs_diff);\n    }\n    double mad_sum = svaddv(pg, mad_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Step 1: Calculate the mean\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (size_t i = 0; svptest_any(pg, pg); i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n        pg = svwhilelt_b64(i + svcntd(), n);\n    }\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / n;\n\n    // Step 2: Calculate the Mean Absolute Deviation\n    pg = svwhilelt_b64(0, n);\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    for (size_t i = 0; svptest_any(pg, pg); i += svcntd()) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64_m(pg, vec, svdup_f64(mean));\n        svfloat64_t abs_diff = svabs_f64_m(pg, diff);\n        mad_vec = svadd_f64_m(pg, mad_vec, abs_diff);\n        pg = svwhilelt_b64(i + svcntd(), n);\n    }\n    double mad_sum = svaddv_f64(svptrue_b64(), mad_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t delimeter_vec = svdup_s32(delimeter); // Broadcast delimiter to all lanes\n\n    size_t i = 0, j = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input_vec = svld1(pg, &numbers[i]); // Load input vector\n        svst1(pg, &result[j], input_vec); // Store input vector to result\n\n        i += svcntw(); // Move to next chunk of input\n        j += svcntw() * 2; // Move to next chunk of result (skipping delimiter slots)\n\n        if (j < result_size) {\n            svst1(pg, &result[j - svcntw()], delimeter_vec); // Store delimiter between elements\n        }\n\n        pg = svwhilelt_b32(i, n); // Update predicate for next iteration\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    size_t i = 0, j = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_numbers = svld1(pg, &numbers[i]); // Load input numbers\n        svst1(pg, &result[j], vec_numbers);            // Store numbers in result\n\n        i += svcntw(); // Advance input index\n        j += svcntw(); // Advance result index\n\n        // Insert delimiter values\n        if (j < result_size) {\n            svint32_t vec_delimiter = svdup_n_s32(delimeter);\n            svst1(pg, &result[j], vec_delimiter);\n            j += svcntw();\n        }\n\n        pg = svwhilelt_b32(i, n); // Update predicate\n    }\n\n    // Handle the last delimiter if necessary\n    if (result_size % 2 == 0) {\n        result[result_size - 1] = delimeter;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t result_size = n * 2 - (n > 0 ? 1 : 0);\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    size_t i = 0, j = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from the input vector\n        svint32_t vec = svld1(pg, &numbers[i]);\n\n        // Store the original numbers in the result vector\n        svst1(pg, &result[j], vec);\n\n        // Create a vector filled with the delimiter\n        svint32_t del_vec = svdup_n_s32(delimeter);\n\n        // Store the delimiter in the interleaved positions\n        svst1(pg, &result[j + 1], del_vec);\n\n        // Advance the indices\n        i += svcntw();\n        j += svcntw() * 2;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    // Adjust the result size to remove the trailing delimiter\n    if (n > 0) {\n        result.resize(result_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    size_t i = 0, j = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load input vector elements\n        svint32_t vec = svld1(pg, &numbers[i]);\n\n        // Store original elements to result\n        svst1(pg, &result[j], vec);\n\n        // Create a vector filled with the delimiter\n        svint32_t del_vec = svdup_n_s32(delimeter);\n\n        // Store delimiter elements to result\n        svst1(pg, &result[j + 1], del_vec);\n\n        // Advance indices\n        i += svcntw();\n        j += 2 * svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    // Handle the last element (no delimiter after the last element)\n    result[result_size - 1] = numbers[n - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t result_size = 2 * n - (n > 0 ? 1 : 0);\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t delimeter_vec = svdup_s32(delimeter); // Vector of delimeter values\n\n    size_t i = 0, j = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input_vec = svld1(pg, &numbers[i]); // Load input vector\n        svst1(pg, &result[j], input_vec); // Store input vector to result\n        i += svcntw();\n        j += svcntw();\n\n        pg = svwhilelt_b32(i, n); // Update predicate for next chunk\n        if (svptest_any(svptrue_b32(), pg)) {\n            svst1(pg, &result[j], delimeter_vec); // Store delimeter values\n            j += svcntw();\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16(); // Predicate for active elements\n    svint16_t vec_sum = svdup_s16(0); // Initialize sum vector to 0\n    svint16_t vec_product = svdup_s16(1); // Initialize product vector to 1\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    // Process the input vector in chunks of SVE vector length\n    while (i < n) {\n        svbool_t active = svwhilelt_b16(i, n); // Predicate for remaining elements\n        svint16_t vec = svld1_s16(active, &numbers[i]); // Load active elements\n\n        vec_sum = svadd_s16_m(active, vec_sum, vec); // Accumulate sum\n        vec_product = svmul_s16_m(active, vec_product, vec); // Accumulate product\n\n        i += svcntw(); // Move to the next chunk\n    }\n\n    // Reduce the sum and product vectors to scalar values\n    sum = svaddv_s16(pg, vec_sum);\n    product = svmulv_s16(pg, vec_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b16(0, n); // Predicate for active elements\n    svint16_t vec_sum = svdup_s16(0);  // Initialize sum vector to 0\n    svint16_t vec_product = svdup_s16(1); // Initialize product vector to 1\n\n    for (size_t i = 0; svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]); // Load vector from input\n        vec_sum = svadd_s16_m(pg, vec_sum, vec);   // Perform vectorized sum\n        vec_product = svmul_s16_m(pg, vec_product, vec); // Perform vectorized product\n        pg = svwhilelt_b16(i + svcntw(), n);       // Update predicate\n    }\n\n    // Reduce sum and product vectors to scalars\n    sum = svaddv_s16(svptrue_b16(), vec_sum);\n    product = svmulv_s16(svptrue_b16(), vec_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t size = numbers.size();\n    svbool_t pg = svwhilelt_b16(0, size);\n    svint16_t vec_sum = svdup_s16(0);\n    svint16_t vec_product = svdup_s16(1);\n\n    for (size_t i = 0; svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vec_sum = svadd_s16_m(pg, vec_sum, vec);\n        vec_product = svmul_s16_m(pg, vec_product, vec);\n        pg = svwhilelt_b16(i + svcntw(), size);\n    }\n\n    sum = svaddv_s16(svptrue_b16(), vec_sum);\n    product = svmulv_s16(svptrue_b16(), vec_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16(); // Predicate for all active lanes\n    svint16_t vec_sum = svdup_s16(0); // Initialize sum vector to 0\n    svint16_t vec_product = svdup_s16(1); // Initialize product vector to 1\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    // Process the input vector in chunks of SVE vector length\n    while (i < n) {\n        svbool_t active = svwhilelt_b16(i, n); // Predicate for remaining elements\n        svint16_t vec = svld1_s16(active, &numbers[i]); // Load elements into vector\n\n        vec_sum = svadd_s16_m(active, vec_sum, vec); // Vectorized sum\n        vec_product = svmul_s16_m(active, vec_product, vec); // Vectorized product\n\n        i += svcntw(); // Advance by the number of elements processed\n    }\n\n    // Reduce the sum and product vectors to scalar values\n    sum = svaddv_s16(pg, vec_sum);\n    product = svmulv_s16(pg, vec_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16(); // Predicate for all active lanes\n    svint16_t vec_sum = svdup_s16(0); // Initialize sum vector to 0\n    svint16_t vec_product = svdup_s16(1); // Initialize product vector to 1\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    while (i < n) {\n        svbool_t active = svwhilelt_b16(i, n); // Active lanes for remaining elements\n        svint16_t vec = svld1_s16(active, &numbers[i]); // Load elements into vector\n\n        vec_sum = svadd_s16_m(active, vec_sum, vec); // Vectorized sum\n        vec_product = svmul_s16_m(active, vec_product, vec); // Vectorized product\n\n        i += svcntw(); // Move to the next chunk\n    }\n\n    // Horizontal reduction for sum and product\n    sum = svaddv_s16(pg, vec_sum);\n    product = svmulv_s16(pg, vec_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    svint32_t max_vec = svdup_n_s32(INT32_MIN); // Initialize max vector with minimum integer value\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input_vec = svld1_s32(pg, &numbers[i]); // Load input vector\n        max_vec = svmax_s32_m(pg, max_vec, input_vec);   // Compute rolling max\n        svst1_s32(pg, &result[i], max_vec);             // Store result\n        i += svcntw();                                  // Advance by vector width\n        pg = svwhilelt_b32(i, n);                       // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32(); // Predicate for active elements\n    svint32_t max_vec = svdup_n_s32(numbers[0]); // Initialize max vector with the first element\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        pg = svwhilelt_b32(i, n); // Update predicate for remaining elements\n\n        svint32_t current_vec = svld1_s32(pg, &numbers[i]); // Load current chunk\n        max_vec = svmax_s32_m(pg, max_vec, current_vec); // Compute rolling max\n        svst1_s32(pg, &result[i], max_vec); // Store the result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t i = 0;\n    int rolling_max = INT_MIN;\n\n    while (i < n) {\n        // Load a chunk of the input vector\n        svint32_t vec = svld1(pg, &numbers[i]);\n\n        // Broadcast the current rolling maximum to all lanes\n        svint32_t rolling_max_vec = svdup_n_s32(rolling_max);\n\n        // Compute the maximum between the rolling maximum and the current vector\n        svint32_t max_vec = svmax_s32_m(pg, rolling_max_vec, vec);\n\n        // Store the result back to the output vector\n        svst1(pg, &result[i], max_vec);\n\n        // Update the rolling maximum for the next iteration\n        rolling_max = svmaxv_s32(pg, max_vec);\n\n        // Advance the index by the vector length\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    svbool_t pg = svptrue_b32(); // Predicate for active elements\n    svint32_t max_vec = svdup_n_s32(SVINT32_MIN); // Initialize max vector with minimum values\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        svbool_t active = svwhilelt_b32(i, n); // Predicate for remaining elements\n        svint32_t input_vec = svld1_s32(active, &numbers[i]); // Load input vector\n        max_vec = svmax_s32_z(active, max_vec, input_vec); // Compute rolling max\n        svst1_s32(active, &result[i], max_vec); // Store result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t max_vec = svdup_s32(SVINT32_MIN); // Initialize max vector with smallest possible value\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input_vec = svld1_s32(pg, &numbers[index]); // Load input vector\n        max_vec = svmax_s32_z(pg, max_vec, input_vec); // Compute rolling max\n        svst1_s32(pg, &result[index], max_vec); // Store result\n        index += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(index, n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    std::string result(n, '0');\n\n    // Ensure both strings are of the same length\n    if (n != b.size()) {\n        return \"\"; // Return empty string for mismatched lengths\n    }\n\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process in chunks using SVE\n    for (; i + svcntb() <= n; i += svcntb()) {\n        pg = svwhilelt_b8(i, n);\n\n        // Load characters from strings a and b\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Convert '0'/'1' characters to binary values (0 or 1)\n        vec_a = svsub_u8_x(pg, vec_a, svdup_u8('0'));\n        vec_b = svsub_u8_x(pg, vec_b, svdup_u8('0'));\n\n        // Perform XOR operation\n        svuint8_t vec_res = sveor_u8_x(pg, vec_a, vec_b);\n\n        // Convert binary values back to '0'/'1' characters\n        vec_res = svadd_u8_x(pg, vec_res, svdup_u8('0'));\n\n        // Store the result back to the result string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_res);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    if (n != b.size()) {\n        throw std::invalid_argument(\"Input strings must have the same length\");\n    }\n\n    std::string result(n, '0');\n    size_t i = 0;\n\n    while (i < n) {\n        size_t remaining = n - i;\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        svuint8_t vec_xor = sveor_u8_z(pg, vec_a, vec_b);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_xor);\n\n        i += svcntb();\n    }\n\n    for (size_t j = 0; j < n; ++j) {\n        result[j] = (result[j] == '1' + '0') ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Input strings must have the same length.\");\n    }\n\n    std::string result(len, '0');\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        svuint8_t vec_xor = sveor_u8(vec_a, vec_b);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_xor);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    for (size_t j = 0; j < len; ++j) {\n        result[j] = (result[j] == 1) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    if (n != b.size()) {\n        throw std::invalid_argument(\"Input strings must have the same length\");\n    }\n\n    std::string result(n, '0');\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, n);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        svuint8_t vec_xor = sveor_u8(vec_a, vec_b);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_xor);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n\n    // Convert '0' and '1' ASCII values back to characters\n    std::transform(result.begin(), result.end(), result.begin(), [](char c) {\n        return c == 1 ? '1' : '0';\n    });\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        svuint8_t vec_result = sveor_u8(vec_a, vec_b);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_result);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n\n    size_t n = strings.size();\n    std::vector<int> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t max_lengths = svdup_s32(0);\n    svint32_t max_indices = svdup_s32(0);\n\n    int index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_lengths = svld1(pg, &lengths[index]);\n        svint32_t vec_indices = svindex_s32(index, 1);\n\n        svbool_t mask = svcmpgt(pg, vec_lengths, max_lengths);\n        max_lengths = svsel(mask, vec_lengths, max_lengths);\n        max_indices = svsel(mask, vec_indices, max_indices);\n\n        pg = svwhilelt_b32(index += svcntw(), n);\n    }\n\n    int max_index = svlastb_s32(svptrue_b32(), max_indices);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\"; // Return empty string for empty input\n    }\n\n    size_t n = strings.size();\n    std::vector<int> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t max_lengths = svdup_s32(0);\n    svint32_t max_indices = svdup_s32(0);\n\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec_lengths = svld1(pg, &lengths[i]);\n        svint32_t indices = svindex_s32(i, 1);\n\n        svbool_t cmp = svcmpgt(pg, vec_lengths, max_lengths);\n        max_lengths = svsel(cmp, vec_lengths, max_lengths);\n        max_indices = svsel(cmp, indices, max_indices);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    int max_index = svlastb_s32(svptrue_b32(), max_indices);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\"; // Return empty string for None\n    }\n\n    size_t n = strings.size();\n    std::vector<int> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t max_lengths = svdup_s32(0);\n    svint32_t max_indices = svdup_s32(0);\n\n    for (size_t i = 0; svptest_any(pg, pg); i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t current_lengths = svld1(pg, &lengths[i]);\n\n        svbool_t cmp = svcmpgt(pg, current_lengths, max_lengths);\n        max_lengths = svsel(cmp, current_lengths, max_lengths);\n        max_indices = svsel(cmp, indices, max_indices);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    int max_index = svlastb_s32(svptrue_b32(), max_indices);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\"; // Return empty string for empty input\n    }\n\n    size_t n = strings.size();\n    std::vector<int32_t> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t max_lengths = svdup_s32(0);\n    svint32_t max_indices = svdup_s32(0);\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec_lengths = svld1(pg, &lengths[i]);\n        svint32_t indices = svindex_s32(i, 1);\n\n        svbool_t cmp = svcmpgt(pg, vec_lengths, max_lengths);\n        max_lengths = svsel(cmp, vec_lengths, max_lengths);\n        max_indices = svsel(cmp, indices, max_indices);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    int32_t max_index = svlastb_s32(svptrue_b32(), max_indices);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::vector<int> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].length();\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t max_lengths = svdup_s32(0);\n    svint32_t max_indices = svdup_s32(0);\n\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t current_lengths = svld1(pg, &lengths[i]);\n        svint32_t indices = svindex_s32(i, 1);\n\n        svbool_t mask = svcmpgt(pg, current_lengths, max_lengths);\n        max_lengths = svsel(mask, current_lengths, max_lengths);\n        max_indices = svsel(mask, indices, max_indices);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    int max_length = svmaxv_s32(svptrue_b32(), max_lengths);\n    int max_index = -1;\n\n    for (int i = 0; i < n; ++i) {\n        if (lengths[i] == max_length) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t va = svdup_n_u64(a); // Broadcast 'a' to all lanes\n    svuint64_t vb = svdup_n_u64(b); // Broadcast 'b' to all lanes\n\n    while (1) {\n        svuint64_t vzero = svdup_n_u64(0);\n        svbool_t bzero = svcmpeq(pg, vb, vzero); // Check if any lane in 'vb' is zero\n        if (svptest_any(pg, bzero)) {\n            break; // Exit loop if any lane in 'vb' is zero\n        }\n\n        svuint64_t vtemp = svsub_m(pg, va, svmul_m(pg, svdivr_m(pg, va, vb), vb)); // va % vb\n        va = vb;\n        vb = vtemp;\n    }\n\n    return svlastb_u64(pg, va); // Return the result from the last active lane\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        svbool_t pg = svwhilelt_b64(0, 1); // Predicate for active lanes\n        svuint64_t va = svdup_n_u64(a);    // Broadcast 'a' to all lanes\n        svuint64_t vb = svdup_n_u64(b);    // Broadcast 'b' to all lanes\n\n        svuint64_t vmod = svmod_u64_z(pg, va, vb); // Compute a % b in parallel\n        a = b;\n        b = svlastb_u64(pg, vmod);                // Extract the last active lane result\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        svbool_t pg = svwhilelt_b64(0, 1); // Predicate for active lanes\n        svuint64_t va = svdup_n_u64(a);    // Broadcast 'a' to all lanes\n        svuint64_t vb = svdup_n_u64(b);    // Broadcast 'b' to all lanes\n\n        svuint64_t vmod = svmod_u64_z(pg, va, vb); // Compute a % b in parallel\n        a = b;\n        b = svlastb_u64(pg, vmod); // Extract the last active lane result\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        svbool_t pg = svwhilelt_b64(0, 1); // Predicate for active lanes\n        svuint64_t va = svdup_n_u64(a);    // Broadcast 'a' to all lanes\n        svuint64_t vb = svdup_n_u64(b);    // Broadcast 'b' to all lanes\n\n        svuint64_t vmod = svmod_u64_z(pg, va, vb); // Compute a % b in parallel\n        a = b;\n        b = svlastb_u64(pg, vmod); // Extract the last active lane result\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t va = svdup_n_u64(a); // Broadcast 'a' to all lanes\n    svuint64_t vb = svdup_n_u64(b); // Broadcast 'b' to all lanes\n\n    while (1) {\n        svuint64_t vzero = svdup_n_u64(0);\n        svbool_t bzero = svcmpeq(pg, vb, vzero); // Check if any lane in vb is 0\n        if (svptest_any(pg, bzero)) {\n            break;\n        }\n\n        svbool_t bgreater = svcmpgt(pg, va, vb); // Compare va > vb\n        svuint64_t vdiff = svsub_m(pg, va, va, vb); // va - vb\n        va = svsel(bgreater, vdiff, va); // Update va if va > vb\n        vb = svsel(bgreater, vb, vdiff); // Update vb if vb > va\n    }\n\n    return svlastb_u64(pg, va); // Return the last active lane value\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n\n    for (size_t i = 0; i < n; ++i) {\n        float current = numbers[i];\n        svfloat32_t vec_current = svdup_f32(current);\n\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            pg = svwhilelt_b32(j, n);\n            svfloat32_t vec_next = svld1(pg, &numbers[j]);\n            svfloat32_t vec_diff = svabs_f32(svsub_f32(vec_current, vec_next));\n\n            svfloat32_t vec_min_diff = svdup_f32(min_diff);\n            svbool_t mask = svcmplt_f32(pg, vec_diff, vec_min_diff);\n\n            if (svptest_any(svptrue_b32(), mask)) {\n                svfloat32_t vec_a = svdup_f32(current);\n                svfloat32_t vec_b = vec_next;\n\n                svfloat32_t vec_closest_a = svsel_f32(mask, vec_a, svdup_f32(closest_a));\n                svfloat32_t vec_closest_b = svsel_f32(mask, vec_b, svdup_f32(closest_b));\n                svfloat32_t vec_closest_diff = svsel_f32(mask, vec_diff, vec_min_diff);\n\n                closest_a = svmaxv_f32(svptrue_b32(), vec_closest_a);\n                closest_b = svmaxv_f32(svptrue_b32(), vec_closest_b);\n                min_diff = svminv_f32(svptrue_b32(), vec_closest_diff);\n            }\n        }\n    }\n\n    if (closest_a > closest_b) std::swap(closest_a, closest_b);\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {}; // Return empty if there are less than two elements\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        size_t remaining = n - i - 1;\n        svbool_t pg = svwhilelt_b32(0, remaining); // Predicate for remaining elements\n        svfloat32_t vec_i = svdup_f32(numbers[i]); // Broadcast numbers[i] to a vector\n        svfloat32_t vec_rest = svld1(pg, &numbers[i + 1]); // Load remaining elements\n        svfloat32_t diff = svabs_f32(svsub_f32_x(pg, vec_i, vec_rest)); // Compute absolute differences\n\n        // Find the minimum difference in the vector\n        float local_min_diff = svminv_f32(pg, diff);\n        if (local_min_diff < min_diff) {\n            min_diff = local_min_diff;\n\n            // Find the index of the closest element\n            svbool_t min_mask = svcmpeq_f32(pg, diff, svdup_f32(local_min_diff));\n            int min_index = svlastb_s32(min_mask) + i + 1;\n\n            closest_a = numbers[i];\n            closest_b = numbers[min_index];\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n - 1; ++i) {\n        svfloat32_t base = svdup_f32(numbers[i]); // Broadcast numbers[i] to all lanes\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t remaining = n - j;\n            svbool_t active = svwhilelt_b32(0, remaining); // Predicate for remaining elements\n            svfloat32_t vec = svld1_f32(active, &numbers[j]); // Load vector of numbers[j..]\n\n            svfloat32_t diff = svsub_f32_x(active, vec, base); // Compute differences\n            diff = svabs_f32_x(active, diff); // Take absolute value of differences\n\n            svfloat32_t min_diff_vec = svdup_f32(min_diff); // Broadcast current min_diff\n            svbool_t less_than = svcmplt_f32(active, diff, min_diff_vec); // Compare with min_diff\n\n            if (svptest_any(pg, less_than)) { // Check if any lane has a smaller difference\n                svfloat32_t min_vals = svsel_f32(less_than, vec, svdup_f32(closest_b)); // Select new closest_b\n                svfloat32_t min_base = svsel_f32(less_than, base, svdup_f32(closest_a)); // Select new closest_a\n\n                // Find the minimum difference and update min_diff\n                svfloat32_t new_diff = svsel_f32(less_than, diff, min_diff_vec);\n                min_diff = svminv_f32(active, new_diff); // Reduce to find the minimum value\n\n                // Update closest_a and closest_b\n                closest_a = svminv_f32(active, min_base);\n                closest_b = svminv_f32(active, min_vals);\n            }\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        svbool_t pg = svwhilelt_b32(i + 1, n);\n        svfloat32_t vec_i = svdup_f32(numbers[i]);\n        svfloat32_t vec_rest = svld1(pg, &numbers[i + 1]);\n\n        svfloat32_t diff = svabs_f32_m(pg, svsub_f32_m(pg, vec_rest, vec_i));\n        svfloat32_t min_diff_vec = svdup_f32(min_diff);\n        svbool_t mask = svcmplt_f32(pg, diff, min_diff_vec);\n\n        if (svptest_any(pg, mask)) {\n            svfloat32_t min_diff_values = svsel(mask, diff, min_diff_vec);\n            min_diff = svminv_f32(pg, min_diff_values);\n\n            svbool_t update_mask = svcmpeq_f32(pg, diff, svdup_f32(min_diff));\n            svfloat32_t closest_values = svsel(update_mask, vec_rest, svdup_f32(closest_b));\n            closest_b = svlastb_f32(update_mask, closest_values);\n            closest_a = numbers[i];\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {}; // Return empty if there are less than two elements\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        svbool_t pg = svwhilelt_b32(i + 1, n);\n        svfloat32_t vec_i = svdup_f32(numbers[i]);\n        svfloat32_t vec_rest = svld1(pg, &numbers[i + 1]);\n\n        svfloat32_t diff = svabs_f32_m(pg, svsub_f32_m(pg, vec_i, vec_rest));\n        float local_min_diff = svminv_f32(pg, diff);\n\n        if (local_min_diff < min_diff) {\n            min_diff = local_min_diff;\n\n            svbool_t min_mask = svcmpeq_f32(pg, diff, svdup_f32(local_min_diff));\n            int index = svlastb(pg, svcompact(pg, svindex_s32(i + 1, 1), min_mask));\n\n            closest_a = numbers[i];\n            closest_b = numbers[index];\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find the minimum and maximum values in the vector using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    svfloat32_t min_vec = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        min_vec = svmin_f32_z(pg, min_vec, vec);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Reduce min and max across all lanes\n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n\n    // Handle edge case where all numbers are the same\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    // Rescale the numbers to the range [0, 1] using SVE\n    pg = svwhilelt_b32(0, n);\n    svfloat32_t min_broadcast = svdup_f32(min_val);\n    svfloat32_t range_broadcast = svdup_f32(max_val - min_val);\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, min_broadcast), range_broadcast);\n        svst1(pg, &numbers[i], rescaled);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return numbers; // Not enough elements to rescale\n    }\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svfloat32_t vec_min = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t vec_max = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Find min and max in parallel\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        vec_min = svmin_f32_m(pg, vec_min, vec);\n        vec_max = svmax_f32_m(pg, vec_max, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Reduce min and max across all lanes\n    float min_val = svminv_f32(svptrue_b32(), vec_min);\n    float max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    // Handle edge case where all elements are the same\n    if (min_val == max_val) {\n        return std::vector<float>(n, 0.0f);\n    }\n\n    float range = max_val - min_val;\n    pg = svwhilelt_b32(0, n); // Reset predicate\n\n    // Rescale the numbers in parallel\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1(pg, &numbers[i], normalized);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find the minimum and maximum values using SVE\n    float min_val = std::numeric_limits<float>::max();\n    float max_val = std::numeric_limits<float>::lowest();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        min_val = svminv(pg, svmin_f32_z(pg, vec, svdup_f32(min_val)));\n        max_val = svmaxv(pg, svmax_f32_z(pg, vec, svdup_f32(max_val)));\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Compute the range\n    float range = max_val - min_val;\n    if (range == 0.0f) return std::vector<float>(n, 0.0f);\n\n    // Rescale the numbers using SVE\n    std::vector<float> result(n);\n    pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1(pg, &result[i], rescaled);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svfloat32_t min_val = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t max_val = svdup_f32(std::numeric_limits<float>::lowest());\n\n    // Find min and max values in the vector\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        min_val = svmin_f32_z(pg, min_val, vec);\n        max_val = svmax_f32_z(pg, max_val, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Reduce min and max across all lanes\n    float min_scalar = svminv_f32(svptrue_b32(), min_val);\n    float max_scalar = svmaxv_f32(svptrue_b32(), max_val);\n\n    // Handle edge case where all numbers are the same\n    if (min_scalar == max_scalar) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n\n    float range = max_scalar - min_scalar;\n\n    // Rescale values to the range [0, 1]\n    pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_scalar)), svdup_f32(range));\n        svst1(pg, &numbers[i], rescaled);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = std::numeric_limits<float>::max();\n    float max_val = std::numeric_limits<float>::lowest();\n\n    // Find min and max using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        min_val = svminv(pg, svmin_f32_z(pg, vec, svdup_f32(min_val)));\n        max_val = svmaxv(pg, svmax_f32_z(pg, vec, svdup_f32(max_val)));\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0.0f) return std::vector<float>(n, 0.0f); // Avoid division by zero\n\n    // Rescale numbers using SVE\n    std::vector<float> result(n);\n    pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1(pg, &result[i], rescaled);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n    svuint64_t divisors = svdup_u64(0); // Vector to store divisors\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t remainders = svmod_u64_x(pg, svdup_u64(n), indices); // Compute n % indices\n        svbool_t divisible = svcmpeq_n_u64(pg, remainders, 0); // Check if n % indices == 0\n        divisors = svsel_u64(divisible, indices, divisors); // Update divisors where divisible\n        indices = svadd_u64_x(pg, indices, svdup_u64(svcntd())); // Increment indices\n        pg = svwhilelt_b64(svlastb_u64(pg, indices), n); // Update predicate\n    }\n\n    return svlastb_u64(svptrue_b64(), divisors); // Return the largest divisor\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n    svuint64_t divisors = svdup_u64(0); // Vector to store divisors\n\n    // Check divisors in parallel\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t remainders = svmod_u64_z(pg, svdup_u64(n), indices); // Compute n % indices\n        svbool_t is_divisor = svcmpeq(pg, remainders, svdup_u64(0)); // Check if n % indices == 0\n        divisors = svsel(is_divisor, indices, divisors); // Update divisors where condition is true\n        indices = svadd_u64_m(pg, indices, svdup_u64(svcntd())); // Increment indices\n        pg = svwhilelt_b64(svlastb_u64(pg, indices), n); // Update predicate\n    }\n\n    // Find the largest divisor\n    uint64_t result = 0;\n    svst1_u64(svptrue_b64(), &result, divisors);\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n    svuint64_t divisors = svdup_u64(0); // Vector to hold divisors\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t remainders = svmod_u64_z(pg, svdup_u64(n), indices); // Compute n % i\n        svbool_t is_divisor = svcmpeq(pg, remainders, svdup_u64(0)); // Check if n % i == 0\n        divisors = svsel(is_divisor, indices, divisors); // Select valid divisors\n        indices = svadd_u64_m(pg, indices, svdup_u64(1)); // Increment indices\n        pg = svwhilelt_b64(svlastb_u64(pg, indices), n); // Update predicate\n    }\n\n    uint64_t result = 0;\n    svst1_u64(svptrue_b64(), &result, divisors); // Store the largest divisor\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t result = 0;\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Generate indices from 1 to n\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t divisors = svdiv_u64(indices, n); // Divide n evenly\n        svuint64_t divisors = svdiv_u64(indices, n); // Divide evenly\n    }\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n    svuint64_t divisors = svdup_u64(0); // Vector to store divisors\n\n    // Check divisors in parallel\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t remainders = svmod_u64_x(pg, svdup_u64(n), indices); // Compute n % indices\n        svbool_t is_divisor = svcmpeq_n_u64(pg, remainders, 0); // Check if remainder is 0\n        divisors = svsel_u64(is_divisor, indices, divisors); // Select valid divisors\n        indices = svadd_u64_x(pg, indices, svdup_u64(svcntd())); // Increment indices\n        pg = svwhilelt_b64(svlastb_u64(pg, indices), n); // Update predicate\n    }\n\n    // Find the maximum divisor\n    uint64_t result = 0;\n    svst1_u64(svptrue_b64(), &result, svmaxv_u64(svptrue_b64(), divisors));\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int factor = 2;\n\n    while (n > 1) {\n        svbool_t pg = svwhilelt_b32_s32(factor, n + 1); // Predicate for active lanes\n        svint32_t vec_factors = svdup_s32(factor);      // Vector of current factor\n        svint32_t vec_n = svdup_s32(n);                // Vector of current n\n\n        // Check divisibility in parallel\n        svbool_t divisible = svcmpeq_n_s32(pg, svmod_s32_x(pg, vec_n, vec_factors), 0);\n\n        // Extract results for active lanes\n        while (svptest_any(svptrue_b32(), divisible)) {\n            factors.push_back(factor);\n            n /= factor;\n\n            vec_n = svdup_s32(n); // Update n vector\n            divisible = svcmpeq_n_s32(pg, svmod_s32_x(pg, vec_n, vec_factors), 0);\n        }\n\n        factor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    if (n <= 1) {\n        return factors;\n    }\n\n    int max_factor = n; // Upper bound for factors\n    int factor = 2;\n\n    while (n > 1 && factor <= max_factor) {\n        // Create a vector of the current factor\n        svbool_t pg = svwhilelt_b32(0, max_factor);\n        svint32_t factor_vec = svdup_s32(factor);\n\n        // Check divisibility in parallel\n        while (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        }\n        factor++;\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    // Initialize the vector length for SVE\n    svbool_t pg = svptrue_b32();\n    svint32_t vec = svindex_s32(2, 1); // Vector of integers starting from 2\n\n    while (n > 1) {\n        // Check divisibility for all elements in the vector\n        svint32_t rem = svrem_s32_x(pg, svdup_s32(n), vec);\n        svbool_t divisible = svcmpeq_s32(pg, rem, svdup_s32(0));\n\n        // Extract the first divisor from the vector\n        int divisor = svlastb_s32(divisible, vec);\n\n        if (divisor > 1) {\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            vec = svadd_s32_x(pg, vec, svdup_s32(svlen_s32(vec))); // Increment vector elements\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int max_factor = n;\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    for (int i = 2; i <= max_factor; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        if (n == 1) break;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n\n    // Initialize the current number to factorize\n    int current = n;\n\n    // Start with the smallest prime number\n    int prime = 2;\n\n    while (current > 1) {\n        // Create an SVE vector of the current prime number\n        svbool_t pg = svwhilelt_b32(0, current);\n        svint32_t prime_vec = svdup_s32(prime);\n\n        // Check divisibility in parallel\n        svint32_t current_vec = svdup_s32(current);\n        svint32_t remainder_vec = svrem_s32_z(pg, current_vec, prime_vec);\n\n        // Extract the result\n        int remainder = svlastb_s32(pg, remainder_vec);\n\n        if (remainder == 0) {\n            // If divisible, add the prime factor and divide the number\n            factors.push_back(prime);\n            current /= prime;\n        } else {\n            // Move to the next potential prime factor\n            prime++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    // Allocate a buffer to store positive results temporarily\n    float temp_buffer[n];\n    size_t temp_index = 0;\n\n    // Process the input vector in chunks using SVE\n    while (i < n) {\n        // Load a chunk of data into an SVE vector\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n\n        // Compare elements to check if they are positive\n        svbool_t mask = svcmpgt_f32(pg, vec, 0.0f);\n\n        // Compress positive elements into the temporary buffer\n        svst1(mask, &temp_buffer[temp_index], svcompact(mask, vec));\n\n        // Update indices\n        temp_index += svcntp_b32(mask, mask);\n        i += svcntw();\n    }\n\n    // Copy the positive elements from the temporary buffer to the result vector\n    result.insert(result.end(), temp_buffer, temp_buffer + temp_index);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    // Allocate a buffer large enough to hold the output\n    float *output_buffer = new float[n];\n    size_t output_index = 0;\n\n    // Process the input vector in chunks using SVE\n    while (i < n) {\n        // Determine the vector length for this iteration\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load a chunk of the input vector\n        svfloat32_t vec = svld1(pg, &l[i]);\n\n        // Create a mask for positive values\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n\n        // Compress the positive values into the output buffer\n        svst1(pg, &output_buffer[output_index], svcompact_f32(mask, vec));\n\n        // Update indices\n        output_index += svcntp_b32(mask, pg);\n        i += svcntw();\n    }\n\n    // Copy the positive values from the buffer to the result vector\n    result.assign(output_buffer, output_buffer + output_index);\n\n    // Free the buffer\n    delete[] output_buffer;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    // Allocate a buffer to store positive numbers\n    float *buffer = new float[n];\n    size_t buffer_index = 0;\n\n    // Process the input vector in chunks using SVE\n    while (i < n) {\n        // Load a chunk of the input vector\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n\n        // Compare elements to find positive numbers\n        svbool_t mask = svcmpgt_f32(pg, vec, 0.0f);\n\n        // Compress positive numbers into the buffer\n        svst1(mask, &buffer[buffer_index], svcompact(mask, vec));\n\n        // Update indices\n        buffer_index += svcntp_b32(mask, mask);\n        i += svcntw();\n    }\n\n    // Copy the positive numbers from the buffer to the result vector\n    result.assign(buffer, buffer + buffer_index);\n\n    // Free the buffer\n    delete[] buffer;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    // Allocate a buffer to store positive numbers\n    float *positive_buffer = new float[n];\n    size_t positive_count = 0;\n\n    // Process the input vector in chunks using SVE\n    while (i < n) {\n        // Load a chunk of data into an SVE vector\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n\n        // Compare the vector elements to zero\n        svbool_t mask = svcmpgt_f32(pg, vec, 0.0f);\n\n        // Compress the positive elements into the buffer\n        svst1(mask, &positive_buffer[positive_count], svcompact(mask, vec));\n\n        // Update the positive count and index\n        positive_count += svcntp_b32(mask, mask);\n        i += svcntw();\n    }\n\n    // Copy the positive numbers into the result vector\n    result.assign(positive_buffer, positive_buffer + positive_count);\n\n    // Free the buffer\n    delete[] positive_buffer;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    // Allocate a buffer to store positive numbers\n    float buffer[n];\n    size_t buffer_index = 0;\n\n    // Process the input vector using SVE\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n); // Create a predicate for the current chunk\n        svfloat32_t vec = svld1(pg, &l[i]); // Load a vector chunk\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f)); // Compare elements with 0\n        svst1(mask, &buffer[buffer_index], svcompact_f32(mask, vec)); // Store positive elements\n        buffer_index += svcntp_b32(mask, pg); // Count positive elements\n        i += svcntw(); // Move to the next chunk\n    }\n\n    // Copy positive numbers to the result vector\n    result.assign(buffer, buffer + buffer_index);\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg = svwhilelt_b64(5, sqrt_n + 1); // Predicate for vectorized range\n    svint64_t vec_i = svindex_s64(5, 1);        // Vectorized indices starting from 5\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_mod = svmod_s64_x(pg, n, vec_i); // Compute n % vec_i\n        svbool_t is_zero = svcmpeq_s64(pg, vec_mod, svdup_s64(0)); // Check if any mod result is zero\n        if (svptest_any(svptrue_b64(), is_zero)) return false;\n\n        vec_i = svadd_s64_x(pg, vec_i, svdup_s64(2)); // Increment indices by 2 (skip even numbers)\n        pg = svwhilelt_b64(svlastb_s64(vec_i), sqrt_n + 1); // Update predicate for next range\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = svsqrt_z(svptrue_b64(), svdup_n_s64(n)); // Calculate sqrt(n) using SVE\n    int64_t i = 5;\n\n    while (i <= limit) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg = svptrue_b64();\n    svint64_t vec_i = svindex_s64(5, 1); // Start from 5 and increment by 1\n\n    while (svlastb(pg, vec_i) <= sqrt_n) {\n        svint64_t vec_mod = svmod_s64_x(pg, n, vec_i); // n % vec_i\n        svint64_t vec_mod_next = svmod_s64_x(pg, n, svadd_s64_x(pg, vec_i, svdup_s64(2))); // n % (vec_i + 2)\n\n        svbool_t is_zero = svorr_b_z(pg, svcmpeq_s64(pg, vec_mod, svdup_s64(0)), svcmpeq_s64(pg, vec_mod_next, svdup_s64(0)));\n        if (svptest_any(pg, is_zero)) {\n            return false;\n        }\n\n        vec_i = svadd_s64_x(pg, vec_i, svdup_s64(6)); // Increment by 6\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg;\n    for (int64_t i = 5; i <= sqrt_n; i += svcntd() * 2) {\n        svint64_t vec_i = svindex_s64(i, 2); // Generate vector [i, i+2, i+4, ...]\n        svbool_t within_bounds = svwhilelt_b64(i, sqrt_n + 1); // Ensure bounds\n        vec_i = svsel_s64(within_bounds, vec_i, svdup_s64(0)); // Mask out-of-bounds values\n\n        svint64_t n_vec = svdup_s64(n); // Broadcast n\n        svint64_t rem = svrem_s64_z(within_bounds, n_vec, vec_i); // Compute n % vec_i\n        pg = svcmpeq_s64(within_bounds, rem, svdup_s64(0)); // Check if any remainder is 0\n\n        if (svptest_any(svptrue_b64(), pg)) { // If any element in the vector is divisible\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    int64_t sqrt_n = 1;\n    while (sqrt_n * sqrt_n <= n) {\n        sqrt_n++;\n    }\n    sqrt_n--;\n\n    svbool_t pg;\n    for (int64_t i = 5; i <= sqrt_n; i += svcntd() * 2) {\n        svint64_t vec = svindex_s64(i, 2);\n        pg = svwhilelt_b64(i, sqrt_n + 1);\n        svint64_t mod = svmod_s64_x(pg, svdup_s64(n), vec);\n        if (svptest_any(pg, svcmpeq_s64(pg, mod, svdup_s64(0)))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n    svbool_t pg = svwhilelt_b8(0, n);\n\n    svuint8_t indices = svindex_u8(0, 1);\n    svuint8_t reversed_indices = svsub_u8(svdup_u8(n - 1), indices);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t current_indices = svadd_u8(svdup_u8(i), indices);\n        svuint8_t reverse_indices = svadd_u8(svdup_u8(i), reversed_indices);\n\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(s.data() + i));\n\n        svbool_t is_lower = svcmplt_u8(pg, chars, svdup_u8('a'));\n        svbool_t is_upper = svcmplt_u8(pg, chars, svdup_u8('A'));\n        svbool_t is_letter = svorr_b8(is_lower, is_upper);\n\n        svuint8_t flipped_case = svadd_u8(chars, svdup_u8(0));\n    }\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n    svbool_t pg = svwhilelt_b8(0, n);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t is_lower = svand_u8(svcmplt_u8(vec, svdup_u8('z' + 1)), svcmpge_u8(vec, svdup_u8('a')));\n        svuint8_t is_upper = svand_u8(svcmplt_u8(vec, svdup_u8('Z' + 1)), svcmpge_u8(vec, svdup_u8('A')));\n        svuint8_t is_letter = svorr_u8(is_lower, is_upper);\n\n        svuint8_t flipped_case = svsel_u8(is_lower, svsub_u8(vec, svdup_u8('a' - 'A')),\n                                          svsel_u8(is_upper, svadd_u8(vec, svdup_u8('a' - 'A')), vec));\n        svuint8_t final_vec = svsel_u8(is_letter, flipped_case, vec);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), final_vec);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n    const char *input = s.data();\n    char *output = result.data();\n\n    size_t i = 0;\n    svbool_t pg;\n\n    while ((pg = svwhilelt_b8(i, n))) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(input + i));\n\n        // Check if characters are lowercase letters\n        svbool_t is_lower = svcmpeq(pg, svand_z(pg, chars, svdup_u8(0xE0)), svdup_u8(0x60));\n        // Check if characters are uppercase letters\n        svbool_t is_upper = svcmpeq(pg, svand_z(pg, chars, svdup_u8(0xE0)), svdup_u8(0x40));\n\n        // Flip case for lowercase letters\n        svuint8_t flipped_lower = sveor_z(is_lower, chars, svdup_u8(0x20));\n        // Flip case for uppercase letters\n        svuint8_t flipped_upper = sveor_z(is_upper, chars, svdup_u8(0x20));\n\n        // Merge flipped results with original characters for non-letters\n        svuint8_t result_chars = svsel(is_lower, flipped_lower, chars);\n        result_chars = svsel(is_upper, flipped_upper, result_chars);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t *>(output + i), result_chars);\n        i += svcntb();\n    }\n\n    // Check if the string contains no letters\n    bool has_letters = std::any_of(result.begin(), result.end(), [](char c) {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n    });\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n\n    svbool_t pg = svwhilelt_b8(0, n);\n    svuint8_t indices = svindex_u8(0, 1);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()) + svlastb_u8(pg, indices));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('z' + 1)), svcmplt_u8(pg, svdup_u8('a' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n        svbool_t is_letter = svorr_b_z(pg, svand_b_z(pg, svcmplt_u8(pg, chars, svdup_u8('Z' + 1)), svcmplt_u8(pg, svdup_u8('A' -1), chars));\n"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n    svbool_t pg = svwhilelt_b8(0, n);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t is_alpha = svand_u8(svcmplt_u8(vec, svdup_u8('z' + 1)), svcmpge_u8(vec, svdup_u8('A')));\n        svuint8_t is_lower = svand_u8(svcmplt_u8(vec, svdup_u8('z' + 1)), svcmpge_u8(vec, svdup_u8('a')));\n        svuint8_t is_upper = svand_u8(svcmplt_u8(vec, svdup_u8('Z' + 1)), svcmpge_u8(vec, svdup_u8('A')));\n\n        svuint8_t flipped_case = svdup_u8(0);\n        flipped_case = svsel_u8(is_lower, svsub_u8(vec, svdup_u8('a' - 'A')), flipped_case);\n        flipped_case = svsel_u8(is_upper, svadd_u8(vec, svdup_u8('a' - 'A')), flipped_case);\n        svuint8_t final_vec = svsel_u8(is_alpha, flipped_case, vec);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n\n    if (std::none_of(s.begin(), s.end(), [](char c) { return std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    std::vector<int> divisible_by_three;\n\n    // Extract elements at indices divisible by three\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Load sorted elements back into the result vector using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    svbool_t pg_divisible_by_three = svwhilelt_b32(0, divisible_by_three.size());\n    size_t sorted_index = 0;\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t mod_result = svmod_u32_z(pg, indices, svdup_u32(3));\n        svbool_t is_divisible_by_three = svcmpeq_u32(pg, mod_result, svdup_u32(0));\n\n        svuint32_t original_values = svld1_u32(pg, &l[i]);\n        svuint32_t sorted_values = svld1_u32(pg_divisible_by_three, &divisible_by_three[sorted_index]);\n\n        svuint32_t result_values = svsel_u32(is_divisible_by_three, sorted_values, original_values);\n        svst1_u32(pg, &result[i], result_values);\n\n        sorted_index += svcntp_b32(pg_divisible_by_three, is_divisible_by_three);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    std::vector<int> divisible_by_three;\n\n    // Extract values at indices divisible by three\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the values divisible by three\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Initialize SVE vector processing\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t index = 0;\n    size_t sorted_index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(index, 1);\n        svbool_t divisible_pg = svcmpeq_u32(pg, svmod_u32_x(pg, indices, svdup_u32(3)), svdup_u32(0));\n\n        svint32_t input = svld1_s32(pg, &l[index]);\n        svint32_t output = svdup_s32(0);\n\n        // Process indices divisible by three\n        svbool_t not_divisible_pg = svnot_b_z(pg, divisible_pg);\n        output = svsel_s32(not_divisible_pg, input, svdup_s32(0));\n\n        if (svptest_any(svptrue_b32(), divisible_pg)) {\n            svint32_t sorted_values = svld1_s32(divisible_pg, &divisible_by_three[sorted_index]);\n            output = svsel_s32(divisible_pg, sorted_values, output);\n            sorted_index += svcntp_b32(divisible_pg, divisible_pg);\n        }\n\n        svst1_s32(pg, &result[index], output);\n        index += svcntw();\n        pg = svwhilelt_b32(index, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    std::vector<int> divisible_by_three;\n\n    // Extract elements at indices divisible by 3\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Initialize SVE loop\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t idx = 0;\n    size_t sorted_idx = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(idx, 1);\n        svbool_t divisible_pg = svcmpeq_n_u32(pg, svmod_n_u32(indices, 3), 0);\n\n        svint32_t vec = svld1(pg, &l[idx]);\n        svint32_t sorted_vec = svdup_n_s32(0);\n\n        // Replace values at indices divisible by 3 with sorted values\n        if (svptest_any(svptrue_b32(), divisible_pg)) {\n            sorted_vec = svld1(divisible_pg, &divisible_by_three[sorted_idx]);\n            sorted_idx += svcntp_b32(divisible_pg, divisible_pg);\n        }\n\n        svint32_t final_vec = svsel(divisible_pg, sorted_vec, vec);\n        svst1(pg, &result[idx], final_vec);\n\n        idx += svcntw();\n        pg = svwhilelt_b32(idx, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the divisible_by_three vector\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Use SVE to update the result vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t idx = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t mask = svmod_s32_x(pg, indices, svdup_s32(3));\n        svbool_t divisible_pg = svcmpeq_s32(pg, mask, svdup_s32(0));\n\n        svint32_t original_values = svld1_s32(pg, l.data());\n        svint32_t updated_values = svdup_s32(0);\n\n        if (idx < divisible_by_three.size()) {\n            updated_values = svdup_s32(divisible_by_three[idx++]);\n        }\n\n        svint32_t result_values = svsel_s32(divisible_pg, updated_values, original_values);\n        svst1_s32(pg, result.data(), result_values);\n\n        pg = svwhilelt_b32(svadd_s32_x(pg, svdup_s32(1), svdup_s32(1)), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    std::vector<int> divisible_by_three;\n\n    // Extract indices divisible by 3\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the divisible_by_three vector\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Initialize SVE loop\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t idx = 0;\n    size_t sorted_idx = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &l[idx]);\n        svint32_t res_vec = svdup_s32(0);\n\n        // Process elements in the vector\n        for (size_t i = 0; i < svcntw(); i++) {\n            int element = svextract_s32(vec, i);\n            if ((idx + i) % 3 == 0) {\n                res_vec = svins_s32(res_vec, i, divisible_by_three[sorted_idx++]);\n            } else {\n                res_vec = svins_s32(res_vec, i, element);\n            }\n        }\n\n        // Store results\n        svst1(pg, &result[idx], res_vec);\n\n        idx += svcntw();\n        pg = svwhilelt_b32(idx, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::lowest();\n\n    const float* data = l.data();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1(pg, &data[index]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n        index += svcntw();\n        pg = svwhilelt_b32(index, n);\n    }\n\n    float max_value = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::lowest();\n\n    const float* data = l.data();\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1(pg, &data[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    float max_value = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::lowest();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &l[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    float max_val = svmaxv(svptrue_b32(), max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::lowest();\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest()); // Initialize max vector\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t data_vec = svld1(pg, &l[i]); // Load vector from input\n        max_vec = svmax_f32_m(pg, max_vec, data_vec); // Compute max\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    // Reduce max_vec to a single maximum value\n    float max_value = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::lowest();\n\n    const float *data = l.data();\n    svfloat32_t max_vec = svdup_f32(std::numeric_limits<float>::lowest());\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &data[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisible_by_11 = svrem_s32_x(pg, indices, 11);\n        svint32_t divisible_by_13 = svrem_s32_x(pg, indices, 13);\n        svbool_t is_divisible = svorr_b_z(pg, svcmpeq_s32(pg, divisible_by_11, 0), svcmpeq_s32(pg, divisible_by_13, 0));\n\n        svint32_t filtered_indices = svcompact_s32(pg, indices, is_divisible);\n        int32_t temp[svcntw()];\n        svst1_s32(pg, temp, filtered_indices);\n\n        for (int i = 0; i < svcntw(); i++) {\n            int num = temp[i];\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n\n        indices = svadd_s32_x(pg, indices, svcntw_s32());\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisible_by_11 = svand_s32_x(pg, svdup_s32(11), indices);\n        svint32_t divisible_by_13 = svand_s32_x(pg, svdup_s32(13), indices);\n        svint32_t divisible_by_7 = svand_s32_x(pg, svdup_s32(7), indices);\n    }\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisible_by_11 = svand_s32_x(pg, svdup_s32(11), indices);\n        svint32_t divisible_by_13 = svand_s32_x(pg, svdup_s32(13), indices);\n        svint32_t divisible = svorr_s32_x(pg, divisible_by_11, divisible_by_13);\n        svint32_t digit_count = svcount_s32_x(pg, divisible);\n        count += digit_count;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisible_by_11 = svand_s32_x(pg, svdup_s32(11), indices);\n        svint32_t divisible_by_13 = svand_s32_x(pg, svdup_s32(13), indices);\n        svint32_t divisible_by_11_or_13 = svorr_s32_x(pg, divisible_by_11, divisible_by_13);\n        svint32_t digit_7_count = svcount_s32_x(pg, divisible_by_11_or_13);\n        count += digit_7_count;\n    }\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices starting from 0\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Check divisibility by 11 or 13\n        svbool_t divisible_by_11 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(11)), svdup_s32(0));\n        svbool_t divisible_by_13 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(13)), svdup_s32(0));\n        svbool_t divisible = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        // Mask indices that are divisible by 11 or 13\n        svint32_t filtered_indices = svsel_s32(divisible, indices, svdup_s32(-1));\n\n        // Count occurrences of digit 7 in filtered indices\n        svint32_t sevens_count = svdup_s32(0);\n        svint32_t ten = svdup_s32(10);\n        svint32_t seven = svdup_s32(7);\n\n        while (svptest_any(pg, divisible)) {\n            svint32_t digit = svmod_s32_x(pg, filtered_indices, ten);\n            svbool_t is_seven = svcmpeq_s32(pg, digit, seven);\n            sevens_count = svadd_s32_m(is_seven, sevens_count, svdup_s32(1));\n            filtered_indices = svdiv_s32_x(pg, filtered_indices, ten);\n            divisible = svcmpne_s32(pg, filtered_indices, svdup_s32(0));\n        }\n\n        // Reduce the count of sevens in the vector\n        count += svaddv_s32(svptrue_b32(), sevens_count);\n\n        // Advance to the next set of indices\n        indices = svadd_s32_x(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    // Sort the even indices\n    std::sort(even_indices.begin(), even_indices.end());\n\n    // Use SVE to copy sorted even indices back to the result vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t even_idx = 0;\n    size_t odd_idx = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(0, 1);\n        svfloat32_t vec_l = svld1(pg, l.data() + odd_idx);\n        svfloat32_t vec_result = svdup_f32(0);\n\n        svbool_t even_mask = svcmpeq(pg, svand_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n        svbool_t odd_mask = svnot_z(pg, even_mask);\n\n        vec_result = svsel(even_mask, svld1(pg, even_indices.data() + even_idx), vec_l);\n\n        svst1(pg, result.data() + odd_idx, vec_result);\n\n        even_idx += svcntp_b32(even_mask, pg);\n        odd_idx += svcntp_b32(pg, pg);\n        pg = svwhilelt_b32(odd_idx, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indices using std::sort\n    std::sort(even_values.begin(), even_values.end());\n\n    // Load sorted even values back into the result vector using SVE\n    size_t even_index = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svuint32_t indices = svindex_u32(0, 2); // Generate even indices\n        indices = svadd_u32_z(pg, indices, svdup_u32(i * 2)); // Offset indices by i * 2\n        svbool_t even_mask = svcmplt(pg, indices, svdup_u32(n)); // Mask for valid indices\n        svfloat32_t even_vec = svld1_gather_u32index(pg, even_values.data(), indices); // Load sorted even values\n        svst1_scatter_u32index(pg, result.data(), indices, even_vec); // Store back into result\n        pg = svwhilelt_b32(i * 2 + svcntw(), n); // Update predicate for next iteration\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Use SVE to store sorted even values back into the result vector\n    size_t even_index = 0;\n    svbool_t pg = svwhilelt_b32(0, even_values.size());\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t even_vec = svld1(pg, &even_values[even_index]);\n        for (size_t i = 0; i < svcntw(); i++) {\n            size_t idx = even_index + i;\n            if (idx * 2 < n) {\n                result[idx * 2] = svlasta(pg, even_vec);\n            }\n        }\n        even_index += svcntw();\n        pg = svwhilelt_b32(even_index, even_values.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indices using std::sort\n    std::sort(even_values.begin(), even_values.end());\n\n    // Use SVE to populate the result vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    svfloat32_t vec_l = svld1(pg, l.data());\n    svfloat32_t vec_result = svdup_f32(0);\n\n    size_t even_idx = 0;\n    size_t odd_idx = 1;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(0, 1);\n        svbool_t even_mask = svcmpeq_u32(pg, svand_u32(indices, svdup_u32(1)), svdup_u32(0));\n        svbool_t odd_mask = svnot_b32(even_mask);\n\n        // Populate even indices with sorted values\n        svfloat32_t even_vec = svld1(pg, even_values.data() + even_idx);\n        vec_result = svsel_f32(even_mask, even_vec, vec_result);\n\n        // Populate odd indices with original values\n        vec_result = svsel_f32(odd_mask, vec_l, vec_result);\n\n        // Update indices and predicate\n        even_idx += svcntw();\n        odd_idx += svcntw();\n        pg = svwhilelt_b32(even_idx, n);\n    }\n\n    // Store the result back into the output vector\n    svst1(svptrue_b32(), result.data(), vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even indices\n    std::sort(even_values.begin(), even_values.end());\n\n    // Load sorted even values back into the result vector using SVE\n    svbool_t pg = svwhilelt_b32(0, even_values.size());\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t even_vec = svld1(pg, &even_values[index]);\n        for (size_t i = 0; i < svcntw(); i++) {\n            size_t even_index = index + i;\n            if (even_index * 2 < n) {\n                result[even_index * 2] = svlasta(pg, even_vec);\n            }\n        }\n        index += svcntw();\n        pg = svwhilelt_b32(index, even_values.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            svbool_t pg = svwhilelt_b32(0, n - j - 1);\n            svint32_t vec_l = svld1(pg, &l[j + 1]);\n            svint32_t vec_sum = svdup_s32(-(l[i] + l[j]));\n            svbool_t match = svcmpeq(pg, vec_l, vec_sum);\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < n - 2; ++i) {\n        svint32_t vi = svdup_n_s32(l[i]);\n\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            svint32_t vj = svdup_n_s32(l[j]);\n\n            for (size_t k = j + 1; k < n; k += svcntw()) {\n                svint32_t vk = svld1(pg, &l[k]);\n                svint32_t sum = svadd_s32_m(pg, svadd_s32_m(pg, vi, vj), vk);\n                if (svptest_any(pg, svcmpeq_s32(pg, sum, svdup_n_s32(0)))) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            svbool_t pg = svwhilelt_b32(0, n - j - 1);\n            svint32_t vec_l = svld1(pg, &l[j + 1]);\n            svint32_t sum = svdup_s32(l[i] + l[j]);\n            svint32_t result = svadd_s32_x(pg, sum, vec_l);\n\n            if (svptest_any(pg, svcmpeq_s32(pg, result, svdup_s32(0)))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n; i++) {\n        svint32_t vi = svdup_s32(l[i]); // Broadcast l[i] to all lanes\n        for (size_t j = i + 1; j < n; j++) {\n            svint32_t vj = svdup_s32(l[j]); // Broadcast l[j] to all lanes\n            svint32_t sum_ij = svadd_s32_m(pg, vi, vj); // vi + vj\n            for (size_t k = j + 1; k < n; k += svcntw()) {\n                svint32_t vk = svld1(pg, &l[k]); // Load vector of l[k] values\n                svint32_t sum_ijk = svadd_s32_m(pg, sum_ij, vk); // sum_ij + vk\n                svbool_t cmp = svcmpeq_s32(pg, sum_ijk, svdup_s32(0)); // Check if sum_ijk == 0\n                if (svptest_any(pg, cmp)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n - 2; ++i) {\n        svint32_t vi = svdup_n_s32(l[i]); // Broadcast l[i] across vector lanes\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            svint32_t vj = svdup_n_s32(l[j]); // Broadcast l[j] across vector lanes\n            svint32_t sum_ij = svadd_s32_x(pg, vi, vj); // Compute l[i] + l[j]\n\n            for (size_t k = j + 1; k < n; k += svcntw()) {\n                svint32_t vk = svld1_s32(pg, &l[k]); // Load elements from l[k] onwards\n                svint32_t sum = svadd_s32_x(pg, sum_ij, vk); // Compute l[i] + l[j] + l[k]\n                svbool_t cmp = svcmpeq_s32(pg, sum, svdup_n_s32(0)); // Check if sum == 0\n\n                if (svptest_any(pg, cmp)) return true; // If any lane matches, return true\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from the input vector\n        svint32_t vec = svld1(pg, &l[i]);\n        // Increment each element by 1\n        svint32_t incremented_vec = svadd_s32_x(pg, vec, svdup_n_s32(1));\n        // Store the result back to the output vector\n        svst1(pg, &result[i], incremented_vec);\n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    // Process the input vector in chunks of SVE vector length\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1(pg, &l[i]);\n\n        // Increment each element in the vector\n        svint32_t incremented = svadd_s32_x(pg, vec, svdup_n_s32(1));\n\n        // Store the result back to the output vector\n        svst1(pg, &result[i], incremented);\n\n        // Advance the index by the vector length\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    int *input = l.data();\n    int *output = result.data();\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &input[i]); // Load vector from input\n        vec = svadd_s32_x(pg, vec, svdup_n_s32(1)); // Increment each element by 1\n        svst1(pg, &output[i], vec); // Store result back to output\n        i += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(i, n); // Update predicate for remaining elements\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    // Process the input vector in chunks of SVE vector length\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load elements from the input vector\n        svint32_t vec = svld1_s32(pg, &l[i]);\n\n        // Increment each element by 1\n        svint32_t incremented_vec = svadd_s32_x(pg, vec, svdup_n_s32(1));\n\n        // Store the result back to the output vector\n        svst1_s32(pg, &result[i], incremented_vec);\n\n        // Update index and predicate for the next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    // Process the input vector in chunks using SVE\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n); // Create a predicate for active lanes\n        svint32_t vec = svld1_s32(pg, &l[i]); // Load elements into SVE vector\n        vec = svadd_s32_x(pg, vec, svdup_s32(1)); // Increment each element by 1\n        svst1_s32(pg, &result[i], vec); // Store the result back to the output vector\n        i += svcntw(); // Move to the next chunk\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        svint32_t vec = svld1(pg, &l[0]); // Load vector from the list\n        svint32_t neg_current = svdup_n_s32(-current); // Broadcast -current\n        svbool_t match = svcmpeq(pg, vec, neg_current); // Compare for matches\n        svbool_t exclude_self = svbic(match, svwhilelt_b32(i, i + 1)); // Exclude self-match\n        if (svptest_any(pg, exclude_self)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n; i++) {\n        int32_t current = l[i];\n        svint32_t vec = svld1(pg, l.data()); // Load the vector\n        svint32_t neg_current = svdup_s32(-current); // Broadcast -current to all lanes\n        svbool_t match = svcmpeq_s32(pg, vec, neg_current); // Compare for equality\n        if (svptest_any(pg, match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        svint32_t vec = svdup_s32(current); // Broadcast current element to all lanes\n\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t remaining = n - j;\n            svbool_t active = svwhilelt_b32(j, n); // Active lanes for remaining elements\n            svint32_t other = svld1_s32(active, &l[j]); // Load next chunk of elements\n            svint32_t sum = svadd_s32_m(active, vec, other); // Compute sum\n            if (svptest_any(pg, svcmpeq_s32(active, sum, svdup_s32(0)))) {\n                return true; // Found a pair that sums to zero\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        svint32_t vec = svdup_s32(current); // Broadcast current element to all lanes\n\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t remaining = n - j;\n            svbool_t pg_active = svwhilelt_b32(j, n); // Predicate for remaining elements\n            svint32_t other = svld1(pg_active, &l[j]); // Load next chunk of elements\n\n            svint32_t sum = svadd_s32_m(pg_active, vec, other); // Compute sum\n            svbool_t zero_mask = svcmpeq_s32(pg_active, sum, svdup_s32(0)); // Check for zero\n\n            if (svptest_any(pg_active, zero_mask)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        svint32_t vec = svdup_s32(current); // Broadcast current element to vector\n\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t remaining = n - j;\n            svbool_t active = svwhilelt_b32(j, n); // Predicate for remaining elements\n            svint32_t other = svld1_s32(active, &l[j]); // Load remaining elements\n\n            svint32_t sum = svadd_s32_m(active, vec, other); // Compute sum\n            if (svptest_any(pg, svcmpeq_s32(active, sum, svdup_s32(0)))) {\n                return true; // Found a pair that sums to zero\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n\n    std::vector<char> result;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    while (x > 0) {\n        // Calculate x % base for each lane\n        svint64_t vec_x = svdup_n_s64(x);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_remainder = svrem_s64_z(pg, vec_x, vec_base);\n\n        // Extract the remainder from the first lane\n        int64_t remainder = svlastb_s64(pg, vec_remainder);\n        result.push_back('0' + remainder);\n\n        // Update x = x / base\n        x /= base;\n    }\n\n    // Reverse the result to get the correct order\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n\n    const int max_digits = 64; // Maximum digits for base conversion\n    char result[max_digits];\n    int index = max_digits;\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    while (x > 0) {\n        // Compute x % base and x / base in parallel\n        svint64_t vec_x = svdup_n_s64(x);\n        svint64_t vec_base = svdup_n_s64(base);\n\n        svint64_t vec_mod = svmod_s64_z(pg, vec_x, vec_base); // x % base\n        svint64_t vec_div = svdiv_s64_z(pg, vec_x, vec_base); // x / base\n\n        // Extract the remainder (x % base) and store it as a character\n        int64_t remainder = svlastb_s64(pg, vec_mod);\n        result[--index] = '0' + remainder;\n\n        // Update x with the quotient (x / base)\n        x = svlastb_s64(pg, vec_div);\n    }\n\n    return std::string(result + index, result + max_digits);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9 || x < 0) {\n        return \"\"; // Invalid base or negative number\n    }\n\n    std::vector<char> result;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svint64_t vec_x = svdup_n_s64(x); // Broadcast x to all lanes\n    svint64_t vec_base = svdup_n_s64(base); // Broadcast base to all lanes\n\n    while (svptest_any(pg, vec_x)) {\n        svint64_t vec_remainder = svmod_s64_x(pg, vec_x, vec_base); // Compute x % base\n        svint64_t vec_quotient = svdiv_s64_x(pg, vec_x, vec_base); // Compute x / base\n\n        int64_t remainders[svcntd()];\n        svst1_s64(pg, remainders, vec_remainder); // Store remainders\n\n        for (int i = 0; i < svcntd(); i++) {\n            if (remainders[i] >= 0) {\n                result.push_back('0' + remainders[i]);\n            }\n        }\n\n        vec_x = vec_quotient; // Update x for the next iteration\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n\n    const int max_digits = 64; // Maximum digits for base conversion\n    char result[max_digits];\n    int index = max_digits;\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    while (x > 0) {\n        // Compute x % base and x / base in parallel\n        svint64_t vec_x = svdup_n_s64(x);\n        svint64_t vec_base = svdup_n_s64(base);\n\n        svint64_t vec_remainder = svmod_s64_z(pg, vec_x, vec_base);\n        svint64_t vec_quotient = svdiv_s64_z(pg, vec_x, vec_base);\n\n        // Extract the remainder (last digit in the new base)\n        int64_t remainder = svlastb_s64(pg, vec_remainder);\n        result[--index] = '0' + remainder;\n\n        // Update x for the next iteration\n        x = svlastb_s64(pg, vec_quotient);\n    }\n\n    return std::string(result + index, result + max_digits);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n\n    std::vector<int8_t> digits;\n    svbool_t pg = svptrue_b8(); // Predicate for active lanes\n\n    while (x > 0) {\n        // Compute remainder using SVE\n        svint64_t vec_x = svdup_n_s64(x);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_remainder = svrem_s64_x(pg, vec_x, vec_base);\n\n        // Extract remainder and store in digits\n        int64_t remainder = svlastb_s64(pg, vec_remainder);\n        digits.push_back(static_cast<int8_t>(remainder));\n\n        // Update x for next iteration\n        x /= base;\n    }\n\n    // Convert digits to string representation\n    std::string result;\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n        result += std::to_string(*it);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.size();\n    if (len <= 1) {\n        return true;\n    }\n\n    const char *str = text.c_str();\n    size_t half_len = len / 2;\n\n    size_t i = 0;\n    while (i < half_len) {\n        svbool_t pg = svwhilelt_b8(i, half_len);\n        svuint8_t vec_front = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + i));\n        svuint8_t vec_back = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + len - i - svcntw_u8(pg)));\n\n        svbool_t cmp = svcmpeq(pg, vec_front, svrev_u8(pg, vec_back));\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n\n        i += svcntw_u8(pg);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.size();\n    if (len <= 1) return true;\n\n    const char *str = text.c_str();\n    size_t half_len = len / 2;\n\n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, half_len);\n        svuint8_t left = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + i));\n        svuint8_t right = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + len - i - svcntb()));\n\n        right = svrev_b8(pg, right); // Reverse the right vector\n        svbool_t cmp = svcmpeq(pg, left, right);\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.size();\n    if (len <= 1) {\n        return true;\n    }\n\n    const char* str = text.c_str();\n    size_t half_len = len / 2;\n\n    size_t i = 0;\n    for (; i < half_len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, half_len);\n\n        svuint8_t front = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n        svuint8_t back = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[len - i - svcntb()]));\n\n        svuint8_t reversed_back = svrev_u8(back);\n\n        svbool_t cmp = svcmpeq(pg, front, reversed_back);\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n\n    while (i < n / 2) {\n        size_t remaining = n / 2 - i;\n        svbool_t pg = svwhilelt_b8(i, i + remaining);\n\n        svuint8_t vec_front = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec_back = svld1(pg, reinterpret_cast<const uint8_t*>(str + n - i - svcntb()));\n\n        svuint8_t vec_back_reversed = svrev_b8(vec_back);\n\n        svbool_t cmp = svcmpeq(pg, vec_front, vec_back_reversed);\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.size();\n    if (len == 0) {\n        return true;\n    }\n\n    const char* str = text.c_str();\n    size_t half_len = len / 2;\n\n    svbool_t pg = svwhilelt_b8(0, half_len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec_front = svld1_u8(pg, (const uint8_t*)str);\n        svuint8_t vec_back = svld1_u8(pg, (const uint8_t*)(str + len - svcntb() * svcntp_b8(pg)));\n\n        svbool_t cmp = svcmpeq_u8(pg, vec_front, vec_back);\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n\n        pg = svwhilelt_b8(svcntb() * svcntp_b8(pg), half_len);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    const int shift = 5;\n    const int alphabet_size = 26;\n    const int base_char = 'a';\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into a vector\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        // Subtract the shift and wrap around the alphabet\n        svuint8_t decoded = svsub_u8_z(pg, vec, svdup_u8(shift));\n        svuint8_t wrapped = svadd_u8_z(pg, decoded, svdup_u8(alphabet_size));\n        svuint8_t result = svsub_u8_z(pg, wrapped, svdup_u8(base_char));\n        svuint8_t final_result = svmod_u8_z(pg, result, svdup_u8(alphabet_size));\n        final_result = svadd_u8_z(pg, final_result, svdup_u8(base_char));\n\n        // Store the decoded characters back into the output string\n        svst1(pg, reinterpret_cast<uint8_t*>(out.data() + i), final_result);\n\n        // Update the predicate for the next iteration\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    const int shift = 5;\n    const int alphabet_size = 26;\n    const int base = 'a';\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into vector\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        // Decode: subtract shift, wrap around alphabet\n        svuint8_t decoded = svsub_u8_z(pg, vec, svdup_u8(shift)); // Subtract shift\n        svuint8_t wrapped = svsub_u8_z(pg, decoded, svdup_u8(base)); // Subtract base\n        svuint8_t modded = svmod_u8_z(pg, wrapped, svdup_u8(alphabet_size)); // Modulo alphabet size\n        svuint8_t final = svadd_u8_z(pg, modded, svdup_u8(base)); // Add base back\n\n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(out.data() + i), final);\n\n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    int n = s.length();\n    std::string out(n, ' ');\n\n    const int shift = 5;\n    const int alphabet_size = 26;\n    const int base = 'a';\n\n    svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svint8_t shift_vec = svdup_s8(shift);\n    svint8_t base_vec = svdup_s8(base);\n    svint8_t alphabet_size_vec = svdup_s8(alphabet_size);\n\n    for (int i = 0; svptest_any(svptrue_b8(), pg); i += svcntb()) {\n        svint8_t encoded_chars = svld1_s8(pg, (const int8_t*)&s[i]); // Load encoded characters\n        svint8_t decoded_chars = svsub_s8_x(pg, encoded_chars, shift_vec); // Subtract shift\n        decoded_chars = svsub_s8_x(pg, decoded_chars, base_vec); // Subtract base\n        decoded_chars = svmod_s8_x(pg, decoded_chars, alphabet_size_vec); // Modulo alphabet size\n        decoded_chars = svadd_s8_x(pg, decoded_chars, base_vec); // Add base back\n        svst1_s8(pg, (int8_t*)&out[i], decoded_chars); // Store decoded characters\n        pg = svwhilelt_b8(i + svcntb(), n); // Update predicate for next iteration\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    const int shift = 5;\n    const int alphabet_size = 26;\n    const char base = 'a';\n\n    size_t i = 0;\n\n    // Process in chunks using SVE\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into SVE vector\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 'a' to normalize to 0-25 range\n        svuint8_t normalized = svsub_u8_x(pg, vec, svdup_u8(base));\n\n        // Reverse the shift and handle wrap-around\n        svuint8_t shifted = svsub_u8_x(pg, normalized, svdup_u8(shift));\n        svuint8_t decoded = svmod_u8_x(pg, svadd_u8_x(pg, shifted, svdup_u8(alphabet_size)), svdup_u8(alphabet_size));\n\n        // Add 'a' back to get ASCII values\n        svuint8_t result = svadd_u8_x(pg, decoded, svdup_u8(base));\n\n        // Store the result back to the output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&out[i]), result);\n\n        // Advance the pointer\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    const int shift = 5;\n    const int alphabet_size = 26;\n    const int base = 'a';\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t encoded_chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t decoded_chars = svsub_u8_z(pg, encoded_chars, svdup_u8(shift)); // Subtract shift\n        svuint8_t wrapped_chars = svsub_u8_z(pg, decoded_chars, svdup_u8(base));  // Remove base\n        wrapped_chars = svmod_u8_z(pg, wrapped_chars, svdup_u8(alphabet_size));  // Modulo alphabet size\n        decoded_chars = svadd_u8_z(pg, wrapped_chars, svdup_u8(base));           // Add base back\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&out[i]), decoded_chars);\n\n        i += svcntb(); // Move to the next vector chunk\n        pg = svwhilelt_b8(i, len); // Update predicate for remaining elements\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t size = l.size();\n    const int *data = l.data();\n    svbool_t all_below = svptrue_b32(); // Initialize predicate to all true\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size); // Create predicate for active elements\n        svint32_t vec = svld1(pg, &data[i]);  // Load vector elements\n        svbool_t cmp = svcmplt_n_s32(pg, vec, t); // Compare elements with threshold\n        all_below = svand_b_z(pg, all_below, cmp); // Update predicate\n        if (!svptest_any(svptrue_b32(), all_below)) {\n            return false; // Early exit if any element is above threshold\n        }\n    }\n\n    return true; // All elements are below threshold\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    const int *data = l.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    int index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &data[index]); // Load vector elements\n        svbool_t cmp = svcmplt(pg, vec, svdup_n_s32(t)); // Compare elements with threshold\n        if (!svptest_all(pg, cmp)) { // Check if all elements satisfy the condition\n            return false;\n        }\n        index += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(index, n); // Update predicate for remaining elements\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    const int *data = l.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    int index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &data[index]); // Load vector\n        svbool_t cmp = svcmplt_s32(pg, vec, svdup_s32(t)); // Compare elements with threshold\n        if (!svptest_all(pg, cmp)) {\n            return false; // If any element is not below threshold, return false\n        }\n        index += svcntw(); // Move to the next set of elements\n        pg = svwhilelt_b32(index, n); // Update predicate\n    }\n\n    return true; // All elements are below the threshold\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    const int *data = l.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t threshold = svdup_s32(t); // Broadcast threshold to vector\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector elements\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold); // Compare elements with threshold\n        if (!svptest_all(pg, cmp)) { // Check if all elements satisfy the condition\n            return false;\n        }\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    const int *data = l.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t threshold = svdup_s32(t); // Broadcast threshold to all lanes\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector elements\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold); // Compare elements with threshold\n        if (!svptest_any(pg, cmp)) { // Check if any element is not below threshold\n            return false;\n        }\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    size_t i = 0;\n    svint32_t balance = svdup_s32(0); // Initialize vector for balance\n    svbool_t pg;\n\n    while (i < n) {\n        size_t remaining = n - i;\n        size_t vl = svcntw(); // Vector length in elements\n        if (remaining < vl) {\n            vl = remaining;\n        }\n\n        pg = svwhilelt_b32(i, n); // Predicate for active elements\n\n        // Load characters into a vector\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(brackets.data() + i));\n\n        // Compare '<' and '>' to create increment and decrement masks\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n\n        // Increment balance for '<' and decrement for '>'\n        balance = svadd_m(is_open, balance, svdup_s32(1));\n        balance = svsub_m(is_close, balance, svdup_s32(1));\n\n        // Check if balance ever goes negative\n        svbool_t negative_balance = svcmplt_n_s32(pg, balance, 0);\n        if (svptest_any(pg, negative_balance)) {\n            return false;\n        }\n\n        i += vl;\n    }\n\n    // Sum up the balance vector\n    int32_t final_balance = svaddv_s32(svptrue_b32(), balance);\n\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    const char* data = brackets.c_str();\n\n    svint32_t balance = svdup_s32(0);\n    svbool_t pg = svwhilelt_b8(0, n);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&data[i]);\n        svint32_t open = svcvt_s32_u32(svcmpeq_u8(chars, svdup_u8('<')));\n        svint32_t close = svcvt_s32_u32(svcmpeq_u8(chars, svdup_u8('>')));\n\n        balance = svadd_s32_m(pg, balance, svsub_s32(open, close));\n\n        svbool_t negative_balance = svcmplt_s32(pg, balance, svdup_s32(0));\n        if (svptest_any(svptrue_b8(), negative_balance)) {\n            return false;\n        }\n\n        i += svcntp_b8(pg, pg);\n        pg = svwhilelt_b8(i, n);\n    }\n\n    int final_balance = svaddv_s32(svptrue_b8(), balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    size_t i = 0;\n    svint32_t open_count = svdup_s32(0);\n\n    while (i < n) {\n        // Determine the vector length for this iteration\n        size_t vl = svcntb() / sizeof(char);\n        vl = (i + vl > n) ? n - i : vl;\n\n        // Load a chunk of the string into an SVE vector\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Compare '<' and '>'\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n\n        // Count '<' as +1 and '>' as -1\n        svint32_t delta = svsub_s32_z(pg, svreinterpret_s32_u8(is_open), svreinterpret_s32_u8(is_close));\n        open_count = svadd_s32_m(pg, open_count, delta);\n\n        // Check if open_count goes negative (invalid state)\n        svbool_t invalid = svcmplt_n_s32(pg, open_count, 0);\n        if (svptest_any(pg, invalid)) {\n            return false;\n        }\n\n        i += vl;\n    }\n\n    // Check if all opening brackets are closed\n    int final_open_count = svaddv_s32(svptrue_b32(), open_count);\n    return final_open_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    const char *data = brackets.c_str();\n\n    svbool_t pg = svwhilelt_b8(0, n);\n    svint32_t balance = svdup_s32(0); // Initialize balance to 0\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into an SVE vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(data + index));\n\n        // Compare '<' and '>' to generate masks\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n\n        // Convert masks to +1 for '<' and -1 for '>'\n        svint32_t open_count = svcvt_s32_x(pg, svreinterpret_s8(is_open));\n        svint32_t close_count = svcvt_s32_x(pg, svreinterpret_s8(is_close));\n        svint32_t delta = svsub_s32_m(pg, open_count, close_count);\n\n        // Update balance\n        balance = svadd_s32_m(pg, balance, delta);\n\n        // Check if balance ever goes negative\n        svbool_t negative_balance = svcmplt_n_s32(pg, balance, 0);\n        if (svptest_any(svptrue_b8(), negative_balance)) {\n            return false;\n        }\n\n        // Advance to the next chunk\n        index += svcntb();\n        pg = svwhilelt_b8(index, n);\n    }\n\n    // Check if balance is zero at the end\n    int final_balance = svaddv_s32(svptrue_b8(), balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    size_t i = 0;\n    svint32_t balance = svdup_s32(0); // Initialize balance vector to 0\n    svbool_t pg;\n\n    while (i < n) {\n        // Load characters into a vector\n        size_t remaining = n - i;\n        size_t vl = svcntb(); // Vector length in bytes\n        size_t load_size = (remaining < vl) ? remaining : vl;\n\n        svbool_t pg = svwhilelt_b8(i, n); // Predicate for active elements\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Compare characters to '<' and '>'\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n\n        // Convert to integer increments/decrements\n        svint32_t open_inc = svcvt_s32_u32_z(pg, svreinterpret_u32_u8(is_open));\n        svint32_t close_dec = svcvt_s32_u32_z(pg, svreinterpret_u32_u8(is_close));\n        close_dec = svneg_s32_z(pg, close_dec);\n\n        // Update balance\n        balance = svadd_s32_m(pg, balance, open_inc);\n        balance = svadd_s32_m(pg, balance, close_dec);\n\n        // Check if balance goes negative\n        svbool_t negative = svcmplt_n_s32(pg, balance, 0);\n        if (svptest_any(pg, negative)) {\n            return false;\n        }\n\n        i += load_size;\n    }\n\n    // Reduce balance across all lanes\n    int final_balance = svaddv_s32(svptrue_b32(), balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int total_balance = 0;\n    int min_balance = 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, n);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n        svint32_t balances = svdup_s32(0);\n\n        svbool_t is_open = svcmpeq_u8(pg, chars, svdup_u8('('));\n        svbool_t is_close = svcmpeq_u8(pg, chars, svdup_u8(')'));\n\n        balances = svadd_s32_m(is_open, balances, svdup_s32(1));\n        balances = svsub_s32_m(is_close, balances, svdup_s32(1));\n\n        total_balance += svaddv_s32(pg, balances);\n        min_balance = std::min(min_balance, svminv_s32(pg, balances));\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n\n    return total_balance == 0 && min_balance >= 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svint32_t balance = svdup_s32(0); // Initialize balance to 0\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, n); // Active predicate for current chunk\n        svuint8_t chars = svld1_u8(active, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n\n        // Map '(' to +1 and ')' to -1\n        svint32_t delta = svsel_s32(\n            svcmpeq_n_u8(active, chars, '('),\n            svdup_s32(1),\n            svdup_s32(-1)\n        );\n\n        // Update balance\n        balance = svadd_s32_m(active, balance, delta);\n\n        // Check if balance ever goes negative\n        svbool_t negative = svcmplt_n_s32(active, balance, 0);\n        if (svptest_any(pg, negative)) {\n            return false;\n        }\n    }\n\n    // Final balance should be zero\n    int final_balance = svaddv_s32(pg, balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    svint32_t min_balance = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        size_t remaining = n - i;\n        svbool_t active = svwhilelt_b8(i, n);\n\n        svuint8_t chars = svld1_u8(active, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        svint32_t delta = svreinterpret_s32(svsub_u8_z(active, chars, svdup_u8('(')));\n        delta = svadd_s32_z(active, delta, svdup_s32(1));\n        delta = svsub_s32_z(active, delta, svdup_s32(2));\n\n        balance = svadd_s32_m(active, balance, delta);\n        min_balance = svmin_s32_m(active, min_balance, balance);\n\n        if (svminv_s32(pg, min_balance) < 0) return false;\n    }\n\n    return svlastb(pg, balance) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    svint32_t min_balance = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        size_t remaining = n - i;\n        svbool_t active = svwhilelt_b8((uint64_t)0, remaining);\n\n        svuint8_t chars = svld1_u8(active, (const uint8_t*)&brackets[i]);\n        svint32_t open = svcvt_s32_u32(svcmpeq_n_u8(active, chars, '('));\n        svint32_t close = svcvt_s32_u32(svcmpeq_n_u8(active, chars, ')'));\n\n        balance = svadd_s32_m(active, balance, svsub_s32_m(active, open, close));\n        min_balance = svmin_s32_m(active, min_balance, balance);\n\n        if (svminv_s32(pg, min_balance) < 0) {\n            return false;\n        }\n    }\n\n    return svlastb(pg, balance) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int32_t total_sum = 0;\n    int32_t min_prefix_sum = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n\n    while (i < n) {\n        size_t remaining = n - i;\n        pg = svwhilelt_b8(i, n);\n\n        svint32_t counts = svdup_s32(0);\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n\n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '(');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, ')');\n\n        counts = svadd_s32_m(is_open, counts, svdup_s32(1));\n        counts = svsub_s32_m(is_close, counts, svdup_s32(1));\n\n        int32_t local_sum = svaddv_s32(pg, counts);\n        total_sum += local_sum;\n\n        svint32_t prefix_sums = svdup_s32(total_sum);\n        prefix_sums = svadd_s32_x(pg, prefix_sums, svreinterpret_s32_u8(svindex_u8(0, 1)));\n\n        int32_t local_min = svminv_s32(pg, prefix_sums);\n        min_prefix_sum = std::min(min_prefix_sum, local_min);\n\n        i += svcntb();\n    }\n\n    return total_sum == 0 && min_prefix_sum >= 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is empty.\n    }\n\n    std::vector<float> result(n - 1);\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements.\n\n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        // Load coefficients into SVE vector.\n        svfloat32_t coeffs = svld1(pg, &xs[i + 1]);\n\n        // Generate indices (1, 2, 3, ...) for the derivative.\n        svuint32_t indices = svindex_u32(i + 1, 1);\n\n        // Convert indices to float and multiply with coefficients.\n        svfloat32_t derivative = svmul_f32_z(pg, coeffs, svcvt_f32_u32_z(pg, indices));\n\n        // Store the result back to the output vector.\n        svst1(pg, &result[i], derivative);\n\n        // Update predicate for the next iteration.\n        pg = svwhilelt_b32(i + svcntw(), n - 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is empty\n    }\n\n    std::vector<float> result(n - 1);\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements\n    svuint32_t indices = svindex_u32(0, 1); // Generate indices [0, 1, 2, ...]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t coeffs = svld1(pg, xs.data()); // Load coefficients\n        svfloat32_t factors = svcvt_f32_u32_x(pg, indices); // Convert indices to float\n        svfloat32_t derivatives = svmul_x(pg, coeffs, factors); // Multiply coeffs by indices\n        svst1(pg, result.data(), derivatives); // Store results\n        xs.erase(xs.begin()); // Shift xs for next iteration\n        pg = svwhilelt_b32(0, xs.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is empty\n    }\n\n    std::vector<float> result(n - 1);\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements\n    svuint32_t indices = svindex_u32(1, 1); // Generate indices 1, 2, 3, ...\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t coeffs = svld1(pg, &xs[i + 1]); // Load coefficients starting from xs[1]\n        svfloat32_t factors = svcvt_f32_u32_z(pg, indices); // Convert indices to float\n        svfloat32_t derivatives = svmul_f32_z(pg, coeffs, factors); // Multiply coeffs by their indices\n        svst1(pg, &result[i], derivatives); // Store the result\n        i += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(i, n - 1); // Update predicate for the next chunk\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is empty\n    }\n\n    std::vector<float> result(n - 1);\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements\n    svuint32_t indices = svindex_u32(1, 1); // Indices starting from 1\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t coeffs = svld1(pg, &xs[i + 1]); // Load coefficients starting from xs[1]\n        svfloat32_t factors = svcvt_f32_u32_z(pg, indices); // Convert indices to float\n        svfloat32_t derivatives = svmul_f32_z(pg, coeffs, factors); // Multiply coefficients by their respective indices\n        svst1(pg, &result[i], derivatives); // Store the result\n        i += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(i, n - 1); // Update predicate for remaining elements\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return {}; // Derivative of a constant or empty polynomial is empty\n    }\n\n    std::vector<float> result(n - 1);\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        // Load coefficients into SVE vector\n        svfloat32_t coeffs = svld1(pg, &xs[i]);\n\n        // Generate indices (1, 2, 3, ...) for multiplication\n        svuint32_t indices = svindex_u32(i, 1);\n\n        // Convert indices to float for multiplication\n        svfloat32_t factors = svcvt_f32_u32_z(pg, indices);\n\n        // Multiply coefficients by their respective indices\n        svfloat32_t derivatives = svmul_f32_z(pg, coeffs, factors);\n\n        // Store the result back to the output vector\n        svst1(pg, &result[i - 1], derivatives);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char *str = s.c_str();\n    int count = 0;\n\n    // Define the vowels as a vector\n    svbool_t pg = svwhilelt_b8(0, 6); // Predicate for 6 elements\n    uint8_t vowels_array[6] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    svuint8_t vowels = svld1(pg, vowels_array);\n\n    // Process the string in chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for the current chunk\n        svuint8_t chars = svld1(pg, (const uint8_t *)(str + i));\n\n        // Convert to lowercase\n        svuint8_t lower_chars = svorr_z(pg, chars, 0x20);\n\n        // Check for vowels\n        svbool_t is_vowel = svcmpeq(pg, lower_chars, vowels);\n        count += svcntp_b8(pg, is_vowel);\n    }\n\n    // Check if the last character is 'y' and add to count\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint32_t count = svdup_s32(0);     // Initialize count to 0\n\n    // Loop over the string in chunks of SVE vector length\n    for (int i = 0; i < len; i += 8) {\n        // Load the next chunk of 8 bytes\n        svint8_t chunk = svld1(pg, s + i);\n        // Check if each byte is a vowel\n        svbool_t is_vowel = svcmpeq(pg,chunk,vowels[0]);\n    }\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char y_lower = 'y';\n    const char y_upper = 'Y';\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint8_t count = svdup_s8(0);       // Initialize count to zero\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(s.data() + i)); // Load characters\n        svbool_t is_vowel = svfalse_b();                                 // Initialize predicate for vowels\n\n        // Check for vowels\n        for (int j = 0; j < 10; j++) {\n            svuint8_t vowel = svdup_u8(vowels[j]);\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, vowel));\n        }\n\n        // Check for 'y' or 'Y' at the end of the string\n        if (i + svcntb() >= len) {\n            svuint8_t y_lower_vec = svdup_u8(y_lower);\n            svuint8_t y_upper_vec = svdup_u8(y_upper);\n            svbool_t is_y = svorr_b_z(pg, svcmpeq_u8(pg, chars, y_lower_vec), svcmpeq_u8(pg, chars, y_upper_vec));\n            is_vowel = svorr_b_z(pg, is_vowel, is_y);\n        }\n\n        // Count vowels\n        svint8_t increment = svdup_s8(1);\n        count = svadd_s8_m(is_vowel, count, increment);\n\n        pg = svwhilelt_b8(i + svcntb(), len); // Update predicate for next iteration\n    }\n\n    // Sum up the counts\n    int total_vowels = 0;\n    svint8_t count_vec = svdup_s8(0);\n    svst1_s8(pg, (int8_t *)&total_vowels, count_vec);\n\n    return total_vowels;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.size();\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint88_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    svuint8_t vowel_mask = svdup_u8(0);\n    sv"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char *str = s.c_str();\n    int count = 0;\n\n    // Define the vowels\n    const char vowels[] = \"aeiouAEIOU\";\n    const size_t vowels_len = sizeof(vowels) - 1;\n\n    // Process the string in chunks using SVE\n    size_t i = 0;\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(str + i)); // Load characters\n\n        // Check for vowels\n        svbool_t is_vowel = svdup_b_z(pg, 0); // Initialize to false\n        for (size_t j = 0; j < vowels_len; j++) {\n            svuint8_t vowel = svdup_u8_z(pg, vowels[j]);\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq(pg, chars, vowel));\n        }\n\n        // Count vowels\n        count += svcntp_b8(pg, is_vowel);\n\n        i += svcntb();\n    }\n\n    // Check if the last character is 'y' or 'Y' and add to the count\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.size();\n    const char *str = s.c_str();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);   // Initialize vector sum to zero\n\n    for (size_t i = 0; svptest_any(svptrue_b8(), pg); i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(str + i)); // Load characters\n        svbool_t upper_mask = svcmplt_u8(chars, svdup_u8('[')) & svcmpge_u8(chars, svdup_u8('A')); // Mask for uppercase letters\n        svuint8_t upper_chars = svsel_u8(upper_mask, chars, svdup_u8(0)); // Select uppercase characters\n        svint32_t ascii_values = svreinterpret_s32_u8(upper_chars); // Convert to ASCII values\n        sum_vec = svadd_s32_m(upper_mask, sum_vec, ascii_values); // Add ASCII values to sum_vec\n        pg = svwhilelt_b8(i + svcntb(), len); // Update predicate for next iteration\n    }\n\n    sum = svaddv_s32(svptrue_b32(), sum_vec); // Reduce vector sum to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    const char *str = s.c_str();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1(pg, (const uint8_t *)&str[index]); // Load characters\n        svbool_t is_upper = svcmpeq(pg, svand_z(pg, chars, svdup_u8(0xDF)), chars); // Check if uppercase\n        svuint8_t upper_chars = svand_z(is_upper, chars, svdup_u8(0xFF)); // Mask uppercase chars\n        svuint32_t ascii_values = svcvt_u32_z(is_upper, upper_chars); // Convert to 32-bit integers\n        sum += svaddv_u32(is_upper, ascii_values); // Sum ASCII values of uppercase chars\n\n        index += svcntb(); // Move to the next vector\n        pg = svwhilelt_b8(index, len); // Update predicate\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.size();\n    const char* str = s.c_str();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);   // Initialize vector sum to 0\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len); // Update predicate for current chunk\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i)); // Load characters\n\n        svbool_t upper_mask = svcmplt_u8(pg, svdup_u8('A' - 1), chars); // Check >= 'A'\n        upper_mask = svand_b_z(pg, upper_mask, svcmple_u8(pg, chars, svdup_u8('Z'))); // Check <= 'Z'\n\n        svuint8_t upper_chars = svsel_u8(upper_mask, chars, svdup_u8(0)); // Select upper chars\n        svint32_t upper_ascii = svreinterpret_s32_u8(upper_chars); // Convert to int32\n        sum_vec = svadd_s32_m(pg, sum_vec, upper_ascii); // Accumulate ASCII values\n    }\n\n    sum = svaddv_s32(svptrue_b32(), sum_vec); // Reduce vector sum to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.size();\n    const char* str = s.c_str();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);   // Initialize vector sum to 0\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len); // Update predicate for current chunk\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i)); // Load characters\n        svuint8_t upper_mask = svcmpge_u8(pg, chars, svdup_u8('A')) & svcmple_u8(pg, chars, svdup_u8('Z')); // Mask for uppercase letters\n        svint32_t ascii_values = svcvt_s32_u32(svdup_u32(0), svreinterpret_u32_u8(chars)); // Convert to ASCII values\n        svint32_t masked_values = svsel_s32(upper_mask, ascii_values, svdup_s32(0)); // Apply mask\n        sum_vec = svadd_s32_m(pg, sum_vec, masked_values); // Accumulate sum\n    }\n\n    sum = svaddv_s32(svptrue_b32(), sum_vec); // Reduce vector sum to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    const char *str = s.c_str();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);   // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(svptrue_b8(), pg); i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(str + i)); // Load characters\n        svbool_t is_upper = svcmpge_u8(pg, chars, svdup_u8('A')) & svcmple_u8(pg, chars, svdup_u8('Z')); // Check for uppercase\n        svint32_t ascii_vals = svcvt_s32_u32_z(is_upper, svreinterpret_u32_u8(chars)); // Convert to int where uppercase\n        sum_vec = svadd_s32_m(is_upper, sum_vec, ascii_vals); // Add ASCII values of uppercase characters\n        pg = svwhilelt_b8(i + svcntb(), len); // Update predicate for next iteration\n    }\n\n    sum = svaddv_s32(svptrue_b32(), sum_vec); // Reduce sum vector to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even_value = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t min_value_vec = svdup_s32(min_even_value); // Initialize min value vector\n    svint32_t min_index_vec = svdup_s32(min_index); // Initialize min index vector\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n); // Active elements for current iteration\n        svint32_t data = svld1_s32(active, &arr[i]); // Load data from array\n\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(active, data, svdup_s32(1)), svdup_s32(0)); // Check for even values\n        svint32_t filtered_data = svsel_s32(even_mask, data, svdup_s32(std::numeric_limits<int>::max())); // Replace odd values with max int\n\n        svbool_t less_mask = svcmplt_s32(filtered_data, min_value_vec); // Compare with current min value\n        min_value_vec = svsel_s32(less_mask, filtered_data, min_value_vec); // Update min value\n        min_index_vec = svsel_s32(less_mask, indices, min_index_vec); // Update min index\n\n        indices = svadd_s32_x(active, indices, svdup_s32(svcntw())); // Increment indices\n    }\n\n    // Extract the results\n    int min_value = svminv_s32(svptrue_b32(), min_value_vec);\n    if (min_value == std::numeric_limits<int>::max()) {\n        return {}; // No even values found\n    }\n\n    svbool_t match_mask = svcmpeq_s32(min_value_vec, svdup_s32(min_value));\n    int min_index = svminv_s32(svptrue_b32(), svsel_s32(match_mask, min_index_vec, svdup_s32(std::numeric_limits<int>::max())));\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t min_even_values = svdup_s32(std::numeric_limits<int>::max()); // Initialize to max int\n    svint32_t min_indices = svdup_s32(-1); // Initialize indices to -1\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n); // Active predicate for current chunk\n        svint32_t vec = svld1_s32(active, &arr[i]); // Load chunk of data\n\n        svbool_t even_mask = svcmpeq_s32(svand_s32(vec, svdup_s32(1)), svdup_s32(0)); // Check for even values\n        svint32_t even_values = svsel_s32(even_mask, vec, svdup_s32(std::numeric_limits<int>::max())); // Select even values\n\n        svbool_t smaller_mask = svcmplt_s32(even_values, min_even_values); // Compare for smaller even values\n        min_even_values = svsel_s32(smaller_mask, even_values, min_even_values); // Update smallest even values\n        min_indices = svsel_s32(smaller_mask, svadd_s32(indices, svdup_s32(i)), min_indices); // Update indices\n\n        indices = svadd_s32(indices, svdup_s32(svcntw())); // Increment indices\n    }\n\n    // Extract the smallest even value and its index\n    int min_value = svminv_s32(pg, min_even_values);\n    if (min_value == std::numeric_limits<int>::max()) {\n        return {}; // No even values found\n    }\n\n    svbool_t match_mask = svcmpeq_s32(min_even_values, svdup_s32(min_value));\n    int min_index = svminv_s32(match_mask, min_indices);\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even_value = std::numeric_limits<int>::max();\n    int min_even_index = -1;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_min_value = svdup_s32(min_even_value);\n    svint32_t vec_min_index = svdup_s32(min_even_index);\n\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec_data = svld1(pg, &arr[i]);\n        svint32_t vec_indices = svindex_s32(i, 1);\n\n        svbool_t even_mask = svcmpeq_s32(svand_s32(vec_data, svdup_s32(1)), svdup_s32(0));\n\n        svint32_t vec_filtered_values = svsel(even_mask, vec_data, svdup_s32(std::numeric_limits<int>::max()));\n        svint32_t vec_filtered_indices = svsel(even_mask, vec_indices, svdup_s32(-1));\n\n        svbool_t cmp_mask = svcmplt_s32(vec_filtered_values, vec_min_value);\n        vec_min_value = svsel(cmp_mask, vec_filtered_values, vec_min_value);\n        vec_min_index = svsel(cmp_mask, vec_filtered_indices, vec_min_index);\n\n        svbool_t eq_mask = svcmpeq_s32(vec_filtered_values, vec_min_value);\n        svbool_t index_mask = svcmplt_s32(vec_filtered_indices, vec_min_index);\n        svbool_t final_mask = svand_b_z(eq_mask, index_mask);\n        vec_min_index = svsel(final_mask, vec_filtered_indices, vec_min_index);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    min_even_value = svlastb_s32(svptrue_b32(), vec_min_value);\n    min_even_index = svlastb_s32(svptrue_b32(), vec_min_index);\n\n    if (min_even_index == -1) {\n        return {};\n    }\n\n    return {min_even_value, min_even_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_value = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t vec_min_value = svdup_s32(min_value); // Initialize vector for minimum values\n    svint32_t vec_min_index = svdup_s32(min_index); // Initialize vector for minimum indices\n    svint32_t vec_indices = svindex_s32(0, 1); // Vector of indices\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n); // Update predicate for active elements\n        svint32_t vec_data = svld1_s32(pg, &arr[i]); // Load data into vector\n\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(pg, vec_data, svdup_s32(1)), svdup_s32(0)); // Mask for even numbers\n        svint32_t vec_filtered = svsel_s32(even_mask, vec_data, svdup_s32(std::numeric_limits<int>::max())); // Filter out odd numbers\n\n        svbool_t cmp_mask = svcmplt_s32(vec_filtered, vec_min_value); // Compare for minimum value\n        vec_min_value = svsel_s32(cmp_mask, vec_filtered, vec_min_value); // Update minimum value\n        vec_min_index = svsel_s32(cmp_mask, vec_indices, vec_min_index); // Update minimum index\n\n        vec_indices = svadd_s32_x(pg, vec_indices, svdup_s32(svcntw())); // Increment indices\n    }\n\n    // Reduce to find the smallest value and its index\n    min_value = svminv_s32(svptrue_b32(), vec_min_value);\n    svbool_t final_mask = svcmpeq_s32(vec_min_value, svdup_s32(min_value));\n    min_index = svminv_s32(final_mask, vec_min_index);\n\n    if (min_value == std::numeric_limits<int>::max()) {\n        return {};\n    }\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t min_even_values = svdup_s32(std::numeric_limits<int>::max()); // Initialize with max int\n    svint32_t min_indices = svdup_s32(-1); // Initialize indices to -1\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n); // Active predicate for current chunk\n        svint32_t vec = svld1_s32(active, &arr[i]); // Load vector chunk\n\n        svbool_t even_mask = svcmpeq_s32(svand_s32_x(active, vec, svdup_s32(1)), svdup_s32(0)); // Check for even numbers\n        svint32_t filtered_values = svsel_s32(even_mask, vec, svdup_s32(std::numeric_limits<int>::max())); // Replace odd numbers with max int\n\n        svbool_t smaller_mask = svcmplt_s32(filtered_values, min_even_values); // Compare for smaller values\n        min_even_values = svsel_s32(smaller_mask, filtered_values, min_even_values); // Update minimum values\n        min_indices = svsel_s32(smaller_mask, svadd_s32_x(active, indices, svdup_s32(i)), min_indices); // Update indices\n    }\n\n    // Reduce across the vector to find the global minimum\n    int min_value = svminv_s32(pg, min_even_values);\n    if (min_value == std::numeric_limits<int>::max()) {\n        return {}; // No even values found\n    }\n\n    svbool_t match_mask = svcmpeq_s32(min_even_values, svdup_s32(min_value)); // Find matching minimum value\n    int min_index = svminv_s32(match_mask, min_indices); // Find the smallest index for the minimum value\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    // Step 1: Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    // Step 2: Extract keys and values into separate vectors\n    std::vector<int> keys, values;\n    for (const auto& pair : freq_map) {\n        keys.push_back(pair.first);\n        values.push_back(pair.second);\n    }\n\n    int n = keys.size();\n    int max_value = -1;\n\n    // Step 3: Use SVE to find the greatest integer meeting the condition\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t keys_vec = svld1(pg, keys.data() + i);    // Load keys\n        svint32_t values_vec = svld1(pg, values.data() + i); // Load values\n\n        // Check condition: frequency >= key\n        svbool_t condition = svcmpge(pg, values_vec, keys_vec);\n\n        // Masked selection of keys that meet the condition\n        svint32_t valid_keys = svsel(condition, keys_vec, svdup_n_s32(-1));\n\n        // Find the maximum valid key\n        int local_max = svmaxv_s32(pg, valid_keys);\n        max_value = std::max(max_value, local_max);\n\n        // Update predicate for the next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    // Step 1: Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    // Step 2: Extract keys and values into separate vectors\n    std::vector<int> keys, values;\n    for (const auto& pair : freq_map) {\n        keys.push_back(pair.first);\n        values.push_back(pair.second);\n    }\n\n    int n = keys.size();\n    int max_val = -1;\n\n    // Step 3: Use SVE to find the maximum value meeting the condition\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t sv_keys = svld1(pg, &keys[i]);\n        svint32_t sv_values = svld1(pg, &values[i]);\n\n        // Condition: frequency >= key\n        svbool_t condition = svcmpge(pg, sv_values, sv_keys);\n\n        // Masked load of keys that meet the condition\n        svint32_t valid_keys = svsel(condition, sv_keys, svdup_n_s32(-1));\n\n        // Find the maximum value among valid keys\n        max_val = std::max(max_val, svmaxv_s32(pg, valid_keys));\n\n        // Update predicate for the next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    // Step 1: Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    // Step 2: Extract keys and values into separate vectors\n    std::vector<int> keys, values;\n    for (const auto& pair : freq_map) {\n        keys.push_back(pair.first);\n        values.push_back(pair.second);\n    }\n\n    int n = keys.size();\n    int max_value = -1;\n\n    // Step 3: Use SVE to find the greatest integer meeting the condition\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t keys_vec = svld1(pg, keys.data() + i);    // Load keys\n        svint32_t values_vec = svld1(pg, values.data() + i); // Load values\n\n        // Check condition: frequency >= value\n        svbool_t condition = svcmpge(pg, values_vec, keys_vec);\n\n        // Masked selection of valid keys\n        svint32_t valid_keys = svsel(condition, keys_vec, svdup_n_s32(-1));\n\n        // Find the maximum valid key\n        int local_max = svmaxv_s32(pg, valid_keys);\n        if (local_max > max_value) {\n            max_value = local_max;\n        }\n\n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    // Step 1: Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    // Step 2: Extract keys and values into separate vectors\n    std::vector<int> keys, values;\n    for (const auto& pair : freq_map) {\n        keys.push_back(pair.first);\n        values.push_back(pair.second);\n    }\n\n    int n = keys.size();\n    int max_result = -1;\n\n    // Step 3: Use SVE intrinsics to process keys and values in parallel\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t keys_vec = svld1(pg, keys.data() + i);\n        svint32_t values_vec = svld1(pg, values.data() + i);\n\n        // Check if the key satisfies the condition: key <= frequency\n        svbool_t condition = svcmple_s32(pg, keys_vec, values_vec);\n\n        // Masked load to find the maximum key that satisfies the condition\n        svint32_t filtered_keys = svsel(condition, keys_vec, svdup_s32(-1));\n        int local_max = svmaxv_s32(pg, filtered_keys);\n\n        // Update the global maximum result\n        max_result = std::max(max_result, local_max);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    std::unordered_map<int, int> freq_map;\n\n    // Calculate frequency of each integer\n    size_t size = lst.size();\n    svbool_t pg = svwhilelt_b32(0, size);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t values = svld1(pg, lst.data());\n        int32_t temp[svcntw()];\n        svst1(pg, temp, values);\n\n        for (int i = 0; i < svcntw() && i < size; i++) {\n            freq_map[temp[i]]++;\n        }\n\n        size -= svcntw();\n        pg = svwhilelt_b32(0, size);\n    }\n\n    // Find the greatest integer meeting the condition\n    int result = -1;\n    for (const auto& [key, value] : freq_map) {\n        if (value >= key && key > result) {\n            result = key;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic (balanced)\n    bool is_palindromic = true;\n    int half_size = n / 2;\n\n    svbool_t pg = svwhilelt_b32(0, half_size);\n    for (int i = 0; i < half_size; i += svcntw()) {\n        svint32_t left = svld1(pg, &q[i]);\n        svint32_t right = svld1(pg, &q[n - i - svcntw()]);\n        svbool_t cmp = svcmpeq(pg, left, svrev(pg, right));\n        if (!svptest_any(pg, cmp)) {\n            is_palindromic = false;\n            break;\n        }\n        pg = svwhilelt_b32(i + svcntw(), half_size);\n    }\n\n    if (!is_palindromic) return false;\n\n    // Calculate the sum of the elements in the vector\n    int sum = 0;\n    pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &q[i]);\n        sum += svaddv(pg, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    bool is_palindrome = true;\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) return false;\n\n    // Compute the sum of the elements using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t sum_vec = svdup_s32(0);\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &q[i]);\n        sum_vec = svadd_m(pg, sum_vec, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Horizontal sum of the vector\n    int sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n\n    // Check if the vector is palindromic (balanced)\n    int is_palindromic = 1;\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = 0;\n            break;\n        }\n    }\n\n    if (!is_palindromic) {\n        return false;\n    }\n\n    // Calculate the sum of elements using SVE intrinsics\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t sum_vec = svdup_s32(0); // Initialize sum vector to 0\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n); // Active lanes for remaining elements\n        svint32_t vec = svld1_s32(active, &q[i]); // Load elements into vector\n        sum_vec = svadd_m(pg, sum_vec, vec); // Accumulate the sum\n    }\n\n    // Horizontal reduction to get the total sum\n    int sum = svaddv_s32(pg, sum_vec);\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic (balanced)\n    bool is_palindromic = true;\n    int half_size = n / 2;\n    svbool_t pg = svwhilelt_b32(0, half_size);\n    for (int i = 0; i < half_size; i += svcntw()) {\n        svint32_t front = svld1(pg, &q[i]);\n        svint32_t back = svld1(pg, &q[n - i - svcntw()]);\n        svbool_t cmp = svcmpeq(pg, front, svrev(pg, back));\n        if (!svptest_any(pg, cmp)) {\n            is_palindromic = false;\n            break;\n        }\n        pg = svwhilelt_b32(i + svcntw(), half_size);\n    }\n    if (!is_palindromic) return false;\n\n    // Calculate the sum of the elements\n    int sum = 0;\n    pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &q[i]);\n        sum += svaddv(pg, vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if the vector is palindromic (balanced)\n    bool is_palindromic = true;\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n    if (!is_palindromic) {\n        return false;\n    }\n\n    // Calculate the sum of the vector using SVE intrinsics\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t sum_vec = svdup_s32(0); // Initialize sum vector to 0\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg_active = svwhilelt_b32(i, n); // Active lanes for current chunk\n        svint32_t vec_chunk = svld1(pg_active, &q[i]); // Load chunk of data\n        sum_vec = svadd_m(pg_active, sum_vec, vec_chunk); // Accumulate sum\n    }\n\n    // Horizontal add to get the total sum\n    int total_sum = svaddv(pg, sum_vec);\n\n    // Check if the total sum is less than or equal to the maximum weight\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half_n = n / 2;\n    int changes = 0;\n\n    svbool_t pg = svwhilelt_b32(0, half_n); // Predicate for loop bounds\n    svint32_t left_indices = svindex_s32(0, 1); // Indices for the left half\n    svint32_t right_indices = svdup_n_s32(n - 1); // Start with the last index\n    right_indices = svsub_s32_z(pg, right_indices, left_indices); // Calculate right indices\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t left_values = svld1_s32(pg, arr.data() + svlastb_s32(pg, left_indices));\n        svint32_t right_values = svld1_s32(pg, arr.data() + svlastb_s32(pg, right_indices));\n\n        svbool_t mismatch = svcmpne_s32(pg, left_values, right_values); // Compare left and right values\n        changes += svcntp_b32(svptrue_b32(), mismatch); // Count mismatches\n\n        left_indices = svadd_s32_z(pg, left_indices, svdup_n_s32(1)); // Increment left indices\n        right_indices = svsub_s32_z(pg, right_indices, svdup_n_s32(1)); // Decrement right indices\n        pg = svwhilelt_b32(svlastb_s32(pg, left_indices), half_n); // Update predicate\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Process the vector in parallel using SVE\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        // Load elements from the start and end of the vector\n        svint32_t vec_start = svld1(pg, &arr[i]);\n        svint32_t vec_end = svld1(pg, &arr[n - i - svcntw()]);\n\n        // Compare elements from start and end\n        svbool_t mismatch = svcmpne(pg, vec_start, vec_end);\n\n        // Count mismatches\n        changes += svcntp_b32(pg, mismatch);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    size_t half_n = n / 2;\n    int changes = 0;\n\n    svbool_t pg = svwhilelt_b32(0, half_n); // Predicate for vectorized loop\n    svint32_t vec_left, vec_right, mask;\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        vec_left = svld1(pg, &arr[i]); // Load left half\n        vec_right = svld1(pg, &arr[n - i - 1]); // Load right half\n\n        mask = svcmpne(pg, vec_left, vec_right); // Compare elements\n        changes += svcntp_b32(svptrue_b32(), mask); // Count mismatches\n\n        pg = svwhilelt_b32(i + svcntw(), half_n); // Update predicate\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half_size = n / 2;\n    int changes = 0;\n\n    svbool_t pg = svwhilelt_b32(0, half_size); // Predicate for loop bounds\n    svint32_t left_indices = svindex_s32(0, 1); // Indices for left side\n    svint32_t right_indices = svsub_s32_z(pg, svdup_s32(n - 1), left_indices); // Indices for right side\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t left_values = svld1_s32(pg, arr.data() + svlastb_s32(pg, left_indices));\n        svint32_t right_values = svld1_s32(pg, arr.data() + svlastb_s32(pg, right_indices));\n\n        svbool_t mismatch = svcmpne_s32(pg, left_values, right_values);\n        changes += svcntp_b32(svptrue_b32(), mismatch); // Count mismatched pairs\n\n        left_indices = svadd_s32_z(pg, left_indices, svdup_s32(1));\n        right_indices = svsub_s32_z(pg, right_indices, svdup_s32(1));\n        pg = svwhilelt_b32(svlastb_s32(pg, left_indices), half_size);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half_size = n / 2;\n    int changes = 0;\n\n    svbool_t pg = svwhilelt_b32(0, half_size); // Predicate for active elements\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t left = svld1(pg, &arr[i]); // Load left half\n        svint32_t right = svld1(pg, &arr[n - i - svcntw()]); // Load right half\n\n        svbool_t mismatch = svcmpne(pg, left, right); // Compare left and right\n        changes += svcntp_b32(pg, mismatch); // Count mismatches\n\n        pg = svwhilelt_b32(i + svcntw(), half_size); // Update predicate\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto calculate_total_chars = [](const std::vector<std::string>& lst) -> int {\n        size_t vec_size = lst.size();\n        svbool_t pg = svwhilelt_b32(0, vec_size);\n        svint32_t total_chars = svdup_s32(0);\n\n        for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n            svint32_t lengths = svdup_s32(0);\n            for (size_t j = 0; j < svcntw() && (i + j) < vec_size; ++j) {\n                lengths = svadd_s32_x(pg, lengths, svdup_s32(lst[i + j].size()));\n            }\n            total_chars = svadd_s32_x(pg, total_chars, lengths);\n            pg = svwhilelt_b32(i + svcntw(), vec_size);\n        }\n\n        int result = 0;\n        svint32_t sum = svdup_s32(0);\n        svbool_t all_true = svptrue_b32();\n        sum = svaddv_s32(all_true, total_chars);\n        result += svlastb_s32(all_true, sum);\n        return result;\n    };\n\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto calculate_total_chars_simd = [](const std::vector<std::string>& lst) -> int {\n        size_t n = lst.size();\n        svbool_t pg = svwhilelt_b32(0, n);\n        svint32_t total_chars = svdup_s32(0);\n        int index = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t lengths = svdup_s32(0);\n            svint32_t indices = svindex_s32(index, 1);\n            svbool_t active = svwhilelt_b32(index, n);\n\n            for (size_t i = 0; i < n; i++) {\n                if (svptest_any(active, svwhilelt_b32(i, n))) {\n                    lengths = svadd_s32_z(active, lengths, svdup_s32(lst[i].size()));\n                }\n            }\n\n            total_chars = svadd_s32_m(pg, total_chars, lengths);\n            index += svcntw();\n            pg = svwhilelt_b32(index, n);\n        }\n\n        int result = 0;\n        svst1_s32(svptrue_b32(), &result, total_chars);\n        return result;\n    };\n\n    int total1 = calculate_total_chars_simd(lst1);\n    int total2 = calculate_total_chars_simd(lst2);\n\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto calculate_total_chars = [](const std::vector<std::string>& lst) -> int {\n        size_t n = lst.size();\n        svbool_t pg = svwhilelt_b32(0, n);\n        int total_chars = 0;\n        int index = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t lengths = svdup_n_s32(0);\n\n            for (size_t i = 0; i < svcntw(); ++i) {\n                if (index + i < n) {\n                    lengths = svadd_s32_m(pg, lengths, svdup_n_s32(lst[index + i].size()));\n                }\n            }\n\n            total_chars += svaddv_s32(pg, lengths);\n            index += svcntw();\n            pg = svwhilelt_b32(index, n);\n        }\n\n        return total_chars;\n    };\n\n    int total1 = calculate_total_chars(lst1);\n    int total2 = calculate_total_chars(lst2);\n\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto compute_total_chars = [](const std::vector<std::string>& lst) -> int {\n        size_t size = lst.size();\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t total_chars = svdup_s32(0);\n        int index = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t lengths = svdup_s32(0);\n            svint32_t indices = svindex_s32(index, 1);\n            svbool_t active = svwhilelt_b32(index, size);\n\n            for (size_t i = 0; i < svcntw(); ++i) {\n                if (svptest_any(active, svdup_b32(i))) {\n                    int idx = svlasta_s32(active, indices);\n                    lengths = svadd_s32_z(active, lengths, svdup_s32(lst[idx].size()));\n                }\n            }\n\n            total_chars = svadd_s32_z(pg, total_chars, lengths);\n            index += svcntw();\n            pg = svwhilelt_b32(index, size);\n        }\n\n        return svaddv_s32(svptrue_b32(), total_chars);\n    };\n\n    int total_chars_lst1 = compute_total_chars(lst1);\n    int total_chars_lst2 = compute_total_chars(lst2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto calculate_total_chars = [](const std::vector<std::string>& lst) -> int {\n        int total_chars = 0;\n        size_t n = lst.size();\n        size_t i = 0;\n\n        // SVE vectorized loop\n        svbool_t pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t lengths = svdup_s32(0);\n\n            // Load string lengths into SVE vector\n            for (size_t j = 0; svptest_any(pg, svwhilelt_b32(j, n)); ++j) {\n                lengths = svadd_s32_m(pg, lengths, svdup_s32(lst[j].size()));\n            }\n\n            // Reduce the vector to calculate the sum of lengths\n            total_chars += svaddv_s32(pg, lengths);\n\n            i += svcntw();\n            pg = svwhilelt_b32(i, n);\n        }\n\n        return total_chars;\n    };\n\n    int total_chars_lst1 = calculate_total_chars(lst1);\n    int total_chars_lst2 = calculate_total_chars(lst2);\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // Special case: n^0 = 1\n    if (n <= 1 || x < n) return false; // Invalid cases\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t base = svdup_u64(n); // Vector of base values\n    svuint64_t power = svdup_u64(1); // Vector to hold powers of n\n\n    while (true) {\n        // Multiply current powers by n\n        power = svmul_u64_x(pg, power, base);\n\n        // Check if any lane matches x\n        svbool_t match = svcmpeq_u64(pg, power, svdup_u64(x));\n        if (svptest_any(pg, match)) {\n            return true;\n        }\n\n        // Check if all lanes exceed x\n        svbool_t exceed = svcgt_u64(pg, power, svdup_u64(x));\n        if (svptest_all(pg, exceed)) {\n            return false;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // Special case: n^0 = 1\n    if (n <= 1 || x < n) return false; // Invalid cases\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t base = svdup_u64(n); // Vector of base values\n    svuint64_t power = svdup_u64(1); // Vector to hold powers of n\n\n    while (true) {\n        svuint64_t next_power = svmul_u64_x(pg, power, base); // Compute next power\n        svbool_t cmp = svcmpeq_u64(pg, next_power, svdup_u64(x)); // Compare with x\n\n        if (svptest_any(pg, cmp)) {\n            return true; // Found a match\n        }\n\n        svbool_t overflow = svcmpeq_u64(pg, next_power, svdup_u64(0)); // Check for overflow\n        if (svptest_any(pg, overflow) || svptest_any(pg, svcmpgt_u64(pg, next_power, svdup_u64(x)))) {\n            return false; // Overflow or exceeded x\n        }\n\n        power = next_power; // Update power for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // Special case: n^0 = 1\n    if (n <= 1 || x < n) return false; // Invalid cases\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t base = svdup_u64(n); // Broadcast n to all lanes\n    svuint64_t power = svdup_u64(1); // Start with n^0 = 1\n\n    while (svptest_any(pg, svcmplt_u64(pg, power, svdup_u64(x)))) {\n        power = svmul_u64_x(pg, power, base); // Compute next power\n        if (svptest_any(pg, svcmpeq_u64(pg, power, svdup_u64(x)))) {\n            return true; // Found x as a power of n\n        }\n    }\n\n    return false; // x is not a simple power of n\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) {\n        return true; // n^0 = 1 for any n > 0\n    }\n    if (n <= 1) {\n        return false; // n must be greater than 1 for valid powers\n    }\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t base = svdup_u64(n); // Broadcast n to all lanes\n    svuint64_t result = svdup_u64(1); // Start with n^0 = 1\n    svuint64_t target = svdup_u64(x); // Broadcast x to all lanes\n\n    while (true) {\n        svbool_t cmp = svcmpeq_u64(pg, result, target); // Compare result with x\n        if (svptest_any(pg, cmp)) {\n            return true; // Found a match\n        }\n\n        svbool_t overflow_check = svcmpeq_u64(pg, result, svdup_u64(UINT64_MAX / n));\n        if (svptest_any(pg, overflow_check)) {\n            return false; // Prevent overflow\n        }\n\n        result = svmul_u64_x(pg, result, base); // Multiply result by n\n        if (svptest_any(pg, svcmpeq_u64(pg, result, svdup_u64(0)))) {\n            return false; // If result becomes zero, x is not a power of n\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x < 1 || n < 1) {\n        return false;\n    }\n    if (x == 1) {\n        return true; // n^0 = 1 for any n >= 1\n    }\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svuint64_t base = svdup_u64(n); // Broadcast n to all lanes\n    svuint64_t result = svdup_u64(1); // Initialize result vector with 1\n    svuint64_t target = svdup_u64(x); // Broadcast x to all lanes\n\n    while (true) {\n        // Multiply result by base\n        result = svmul_u64_m(pg, result, base);\n\n        // Check if any lane matches x\n        svbool_t match = svcmpeq_u64(pg, result, target);\n        if (svptest_any(pg, match)) {\n            return true;\n        }\n\n        // Check if result exceeds x in all lanes\n        svbool_t overflow = svcmpgt_u64(pg, result, target);\n        if (svptest_all(pg, overflow)) {\n            return false;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    // Prime hexadecimal digits: '2', '3', '5', '7', 'B', 'D'\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    const size_t prime_count = sizeof(prime_hex_digits) / sizeof(prime_hex_digits[0]);\n\n    size_t len = num.size();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t prime_set = svdup_u8(0); // Vector to store prime matches\n\n    // Load prime hexadecimal digits into vector\n    for (size_t i = 0; i < prime_count; ++i) {\n        svuint8_t digit = svdup_u8(prime_hex_digits[i]);\n        prime_set = svorr_u8_z(pg, prime_set, digit);\n    }\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters from the input string\n        svuint8_t input_chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(num.data() + index));\n\n        // Compare input characters with prime set\n        svbool_t match = svcmpeq_u8(pg, input_chars, prime_set);\n\n        // Count matches\n        count += svcntp_b8(svptrue_b8(), match);\n\n        // Update index and predicate for next iteration\n        index += svcntw();\n        pg = svwhilelt_b8(index, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    size_t len = num.size();\n    int prime_count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec_prime_digits = svld1_u8(pg, reinterpret_cast<const uint8_t*>(prime_hex_digits));\n    svuint8_t vec_input;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        vec_input = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&num[i]));\n\n        svbool_t mask = svcmpeq_u8(pg, vec_input, vec_prime_digits);\n        prime_count += svcntp_b8(pg, mask);\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    // Prime hexadecimal digits: 2, 3, 5, 7, B (11), D (13)\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    const size_t prime_count = sizeof(prime_hex_digits) / sizeof(prime_hex_digits[0]);\n\n    int count = 0;\n    size_t len = num.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters from the input string\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(num.data() + i));\n\n        // Initialize a vector to accumulate matches\n        svuint8_t match_count = svdup_u8(0);\n\n        // Compare against each prime hex digit\n        for (size_t j = 0; j < prime_count; ++j) {\n            svuint8_t prime_char = svdup_u8(static_cast<uint8_t>(prime_hex_digits[j]));\n            svbool_t match = svcmpeq(pg, chars, prime_char);\n            match_count = svadd_u8_m(match, match_count, svdup_u8(1));\n        }\n\n        // Sum up matches in the vector\n        count += svaddv_u8(pg, match_count);\n\n        // Advance to the next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    // Prime hexadecimal digits: 2, 3, 5, 7, B (11), D (13)\n    const char prime_hex[] = {'2', '3', '5', '7', 'B', 'D'};\n    const size_t prime_count = sizeof(prime_hex) / sizeof(prime_hex[0]);\n\n    size_t len = num.size();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters from the input string\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(num.data() + index));\n\n        // Initialize a vector to accumulate matches\n        svuint8_t match_count = svdup_u8(0);\n\n        // Compare against each prime hexadecimal digit\n        for (size_t i = 0; i < prime_count; ++i) {\n            svuint8_t prime_char = svdup_u8(static_cast<uint8_t>(prime_hex[i]));\n            svbool_t match = svcmpeq(pg, chars, prime_char);\n            match_count = svadd_u8_m(match, match_count, svdup_u8(1));\n        }\n\n        // Sum up the matches in the current vector\n        count += svaddv_u8(pg, match_count);\n\n        // Update index and predicate for the next iteration\n        index += svcntb();\n        pg = svwhilelt_b8(index, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    // Prime hexadecimal digits: 2, 3, 5, 7, B (11), D (13)\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    const size_t prime_count = sizeof(prime_hex_digits) / sizeof(prime_hex_digits[0]);\n\n    size_t len = num.size();\n    int prime_count_total = 0;\n\n    for (size_t i = 0; i < len;) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(num.data() + i)); // Load a vector of characters\n\n        // Initialize a vector to count matches\n        svuint8_t match_count = svdup_u8(0);\n\n        // Compare each character in the vector with the prime hexadecimal digits\n        for (size_t j = 0; j < prime_count; ++j) {\n            svuint8_t prime_vec = svdup_u8(prime_hex_digits[j]);\n            svbool_t cmp = svcmpeq(pg, vec, prime_vec); // Compare vector elements\n            match_count = svadd_z(pg, match_count, svdup_u8(1)); // Increment match count where comparison is true\n        }\n\n        // Sum up the matches in the vector\n        prime_count_total += svaddv_u8(pg, match_count);\n\n        i += svcntb(); // Move to the next vector chunk\n    }\n\n    return prime_count_total;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    const char *str = s.c_str();\n    size_t i = 0;\n\n    while (i + 3 <= len) {\n        svbool_t pg = svwhilelt_b8(i, len - 2);\n        svuint8_t v1 = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + i));\n        svuint8_t v2 = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + i + 1));\n        svuint8_t v3 = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq_u8(pg, v1, v2);\n        svbool_t cmp2 = svcmpeq_u8(pg, v2, v3);\n        svbool_t cmp3 = svcmpeq_u8(pg, v1, v3);\n\n        svbool_t any_equal = svorr_b_z(pg, cmp1, svorr_b_z(pg, cmp2, cmp3));\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n\n        i += svcntb();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, n - 3);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t v1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t v2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i + 1));\n        svuint8_t v3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i + 2));\n\n        svbool_t distinct = svcmpne_u8(pg, v1, v2);\n        distinct = svand_b_z(pg, distinct, svcmpne_u8(pg, v2, v3));\n        distinct = svand_b_z(pg, distinct, svcmpne_u8(pg, v1, v3));\n\n        if (!svptest_all(svptrue_b8(), distinct)) {\n            return false;\n        }\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, n - 3);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    for (size_t i = 0; i <= n - 3; i += svcntb()) {\n        size_t remaining = n - i - 2;\n        svbool_t mask = svwhilelt_b8(i, i + svcntb());\n        mask = svand_b_z(pg, mask, svwhilelt_b8(0, remaining));\n\n        svuint8_t v1 = svld1_u8(mask, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t v2 = svld1_u8(mask, reinterpret_cast<const uint8_t*>(&s[i + 1]));\n        svuint8_t v3 = svld1_u8(mask, reinterpret_cast<const uint8_t*>(&s[i + 2]));\n\n        svbool_t distinct = svand_b_z(mask, svcmpne_u8(mask, v1, v2), svcmpne_u8(mask, v2, v3));\n        distinct = svand_b_z(mask, distinct, svcmpne_u8(mask, v1, v3));\n\n        if (!svptest_any(pg, distinct)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    const char *data = s.data();\n\n    for (size_t i = 0; i <= n - 3; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n - 2); // Predicate for valid range\n        svuint8_t v1 = svld1_u8(pg, (const uint8_t *)(data + i));\n        svuint8_t v2 = svld1_u8(pg, (const uint8_t *)(data + i + 1));\n        svuint8_t v3 = svld1_u8(pg, (const uint8_t *)(data + i + 2));\n\n        svbool_t cmp1 = svcmpne_u8(pg, v1, v2); // v1 != v2\n        svbool_t cmp2 = svcmpne_u8(pg, v2, v3); // v2 != v3\n        svbool_t cmp3 = svcmpne_u8(pg, v1, v3); // v1 != v3\n\n        svbool_t all_distinct = svand_b_z(pg, svand_b_z(pg, cmp1, cmp2), cmp3); // All three distinct\n        if (!svptest_any(pg, all_distinct)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b8(); // Predicate for active elements\n    for (size_t i = 0; i <= n - 3; i += svcntb()) {\n        size_t remaining = n - i;\n        size_t vector_len = svcntb();\n        size_t active_len = remaining < vector_len ? remaining : vector_len;\n\n        pg = svwhilelt_b8(i, i + active_len);\n\n        svuint8_t v1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t v2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i + 1]));\n        svuint8_t v3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i + 2]));\n\n        svbool_t distinct1 = svcmpne_u8(pg, v1, v2);\n        svbool_t distinct2 = svcmpne_u8(pg, v2, v3);\n        svbool_t distinct3 = svcmpne_u8(pg, v1, v3);\n\n        svbool_t all_distinct = svand_b_z(pg, distinct1, svand_b_z(pg, distinct2, distinct3));\n\n        if (!svptest_any(pg, all_distinct)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b32(); // Predicate for active elements\n    int sqrt_length = static_cast<int>(sqrt(length));\n\n    for (int i = 2; i <= sqrt_length; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1); // Generate indices starting from i\n        svbool_t valid_pg = svwhilelt_b32(i, length + 1); // Mask for valid indices\n        valid_pg = svand_b_z(pg, valid_pg, svcmple_s32(pg, indices, sqrt_length)); // Ensure indices <= sqrt_length\n\n        svint32_t remainders = svmod_s32_z(valid_pg, svdup_s32(length), indices); // Compute remainders\n        if (svptest_any(valid_pg, svcmpeq_s32(valid_pg, remainders, svdup_s32(0)))) {\n            return false; // If any remainder is 0, length is not prime\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    if (length < 2) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (int i = 2; i * i <= length; i += svcntw()) {\n        svint32_t vec_i = svindex_s32(i, 1); // Vector of [i, i+1, i+2, ...]\n        svbool_t valid_pg = svcmple_s32(pg, vec_i, length); // Mask for valid divisors <= length\n        svint32_t vec_length = svdup_s32(length); // Broadcast length to all lanes\n        svint32_t vec_rem = svrem_s32_z(valid_pg, vec_length, vec_i); // Compute length % vec_i\n        if (svptest_any(valid_pg, svcmpeq_s32(valid_pg, vec_rem, svdup_s32(0)))) {\n            return false; // If any remainder is 0, length is not prime\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    svbool_t pg = svwhilelt_b32(0, sqrt_len);\n\n    for (int i = 2; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t valid = svand_b_z(pg, svcmpge_n_s32(pg, indices, 2), svcmple_n_s32(pg, indices, sqrt_len));\n        svint32_t remainders = svrem_n_s32_z(valid, length, indices);\n\n        if (svptest_any(svptrue_b32(), svcmpeq_n_s32(valid, remainders, 0))) {\n            return false;\n        }\n\n        pg = svwhilelt_b32(i + svcntw(), sqrt_len);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    if (length < 2) {\n        return false;\n    }\n\n    int sqrt_len = std::sqrt(length);\n    svbool_t pg = svwhilelt_b32(0, sqrt_len);\n    svint32_t indices = svindex_s32(1, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisors = svadd_s32_x(pg, indices, 1);\n        svint32_t remainders = svmod_s32_x(pg, svdup_s32(length), divisors);\n        if (svptest_any(pg, svcmpeq_s32(pg, remainders, svdup_s32(0)))) {\n            return false;\n        }\n        pg = svwhilelt_b32(svlastb_s32(pg, indices) + 1, sqrt_len);\n        indices = svadd_s32_x(pg, indices, svcntw());\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    svbool_t pg = svwhilelt_b32(0, sqrt_len + 1);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t divisors = svadd_s32_x(pg, indices, 2); // Start from 2\n        svint32_t remainders = svmod_s32_x(pg, svdup_s32(length), divisors);\n        if (svcmpeq_n_s32(pg, remainders, 0)) {\n            return false; // Found a divisor\n        }\n        indices = svadd_s32_x(pg, indices, svcntw());\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), sqrt_len + 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to extract digits\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n\n    // Allocate memory for the digits\n    uint8_t digits[len];\n    for (size_t i = 0; i < len; i++) {\n        digits[i] = num_str[i] - '0';\n    }\n\n    // Use SVE to sum the digits\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t vec_digits = svld1(pg, digits); // Load digits into vector\n    uint8_t sum = svaddv_u8(pg, vec_digits); // Sum the vector elements\n\n    // Convert the sum to binary string\n    std::string binary_result;\n    while (sum > 0) {\n        binary_result = (char)((sum % 2) + '0') + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to extract digits\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n\n    // Allocate an array to store the digits\n    uint8_t digits[len];\n    for (size_t i = 0; i < len; ++i) {\n        digits[i] = num_str[i] - '0';\n    }\n\n    // Initialize the sum\n    uint64_t sum = 0;\n\n    // Use SVE to process the digits in parallel\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &digits[index]);\n        svuint64_t vec_sum = svaddv_u64(pg, svreinterpret_u64(vec));\n        sum += svlastb_u64(pg, vec_sum);\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, len);\n    }\n\n    // Convert the sum to binary\n    std::string binary_result;\n    while (sum > 0) {\n        binary_result = (sum % 2 ? '1' : '0') + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to extract digits\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n\n    // Prepare an array to hold the digits\n    std::vector<uint8_t> digits(len);\n    for (size_t i = 0; i < len; ++i) {\n        digits[i] = num_str[i] - '0';\n    }\n\n    // Load the digits into SVE vector\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec_digits = svld1_u8(pg, digits.data());\n\n    // Perform the sum reduction\n    uint64_t sum = svaddv_u64(pg, svreinterpret_u64_u8(vec_digits));\n\n    // Convert the sum to binary string\n    std::string binary_result;\n    while (sum > 0) {\n        binary_result = (sum % 2 == 0 ? \"0\" : \"1\") + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to extract digits\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n\n    // Allocate memory for digits\n    std::vector<int32_t> digits(len);\n    for (size_t i = 0; i < len; ++i) {\n        digits[i] = num_str[i] - '0';\n    }\n\n    // Load digits into SVE vector\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t vec_digits = svld1(pg, digits.data());\n\n    // Perform reduction to sum all digits\n    int32_t sum = svaddv_s32(pg, vec_digits);\n\n    // Convert the sum to binary string\n    std::string binary_result;\n    while (sum > 0) {\n        binary_result = (char)((sum % 2) + '0') + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to extract digits\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n\n    // Prepare an array to hold the digits\n    std::vector<uint8_t> digits(len);\n    for (size_t i = 0; i < len; ++i) {\n        digits[i] = num_str[i] - '0';\n    }\n\n    // Use SVE to sum the digits\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec_digits = svld1_u8(pg, digits.data());\n    uint8_t sum = svaddv_u8(pg, vec_digits);\n\n    // Convert the sum to binary string\n    std::string binary_result;\n    while (sum > 0) {\n        binary_result = (char)((sum % 2) + '0') + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t indices = svindex_s32(0, 1);\n\n    svbool_t odd_indices = svand_b_z(pg, svcmpeq_s32_z(pg, svand_s32_z(pg, indices, svdup_s32(1)), svdup_s32(1)));\n    svbool_t even_values = svcmpeq_s32_z(pg, svand_s32_z(pg, vec, svdup_s32(1)), svdup_s32(0));\n\n    svbool_t mask = svand_b_z(pg, odd_indices, even_values);\n    svint32_t filtered = svsel_s32(mask, vec, svdup_s32(0));\n\n    int result = svaddv_s32(pg, filtered);\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t sum_vec = svdup_s32(0);\n\n    for (int i = 0; svptest_any(pg, pg); i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svbool_t odd_indices = svand_b_z(pg, svcmpeq_s32(svand_s32(indices, svdup_s32(1)), svdup_s32(1)), pg);\n        svbool_t even_values = svcmpeq_s32(svand_s32(data, svdup_s32(1)), svdup_s32(0));\n        svbool_t mask = svand_b_z(pg, odd_indices, even_values);\n        sum_vec = svadd_s32_m(mask, sum_vec, data);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n < 2) return 0;\n\n    int sum = 0;\n    svbool_t pg = svwhilelt_b32(0, n / 2); // Predicate for odd indices\n    svint32_t vec_sum = svdup_s32(0);\n\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t indices = svindex_s32(1, 2); // Generate odd indices\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        vec_sum = svadd_s32(pg, vec_sum, vec);\n    }\n    return sum;\n}"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t vec_indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t vec_data = svld1(pg, lst.data()); // Load data into vector\n\n    svbool_t odd_indices = svand_b_z(pg, svcmpeq_s32(pg, svand_s32_x(pg, vec_indices, svdup_s32(1)), svdup_s32(1))); // Mask for odd indices\n    svbool_t even_values = svcmpeq_s32(pg, svand_s32_x(pg, vec_data, svdup_s32(1)), svdup_s32(0)); // Mask for even values\n    svbool_t combined_mask = svand_b_z(pg, odd_indices, even_values); // Combine masks\n\n    svint32_t filtered_values = svsel_s32(combined_mask, vec_data, svdup_s32(0)); // Select values based on mask\n    int result = svaddv_s32(pg, filtered_values); // Sum up the filtered values\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t vec = svld1(pg, lst.data());\n    \n    svbool_t odd_indices = svcmpeq_s32(pg, svand_s32_x(pg, indices, svdup_s32(1)), svdup_s32(1));\n    svbool_t even_values = svcmpeq_s32(pg, svand_s32_x(pg, vec, svdup_s32(1)), svdup_s32(0));\n    svbool_t mask = svand_b_z(pg, odd_indices, even_values);\n    \n    svint32_t filtered = svsel_s32(mask, vec, svdup_s32(0));\n    int result = svaddv_s32(pg, filtered);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.length();\n    std::vector<char> encrypted(len);\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t shift_vector = svdup_u8(4); // Shift by 4 (2 * 2)\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t input_vector = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[index]));\n        svuint8_t result_vector = svadd_u8_x(pg, input_vector, shift_vector);\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&encrypted[index]), result_vector);\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, len);\n    }\n\n    return std::string(encrypted.begin(), encrypted.end());\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n\n    const int shift = 2 * 2; // Alphabet shift by 2 * 2 = 4\n    const int alphabet_size = 26;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters into SVE vector\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Check if characters are lowercase letters\n        svbool_t is_lowercase = svcmpge_u8(pg, vec, 'a') & svcmple_u8(pg, vec, 'z');\n\n        // Perform rotation for lowercase letters\n        svuint8_t rotated = svadd_u8_z(is_lowercase, vec, shift);\n        rotated = svsub_u8_z(is_lowercase & svcmpgt_u8(pg, rotated, 'z'), rotated, alphabet_size);\n\n        // Store the result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), rotated);\n\n        // Update loop index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n\n    const int shift = 2 * 2; // Alphabet rotation factor\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t vec_shift = svdup_u8(shift); // Vectorized shift value\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len); // Update predicate for current chunk\n        svuint8_t vec_input = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i)); // Load input chunk\n        svuint8_t vec_output = svadd_u8_x(pg, vec_input, vec_shift); // Perform vectorized addition\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_output); // Store result chunk\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t n = s.size();\n    std::vector<char> result(n);\n\n    const svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svint8_t shift = svdup_s8(2 * 2);       // Shift value (2 * 2 = 4)\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, n); // Predicate for active elements in this iteration\n        svint8_t chars = svld1_s8(active, reinterpret_cast<const int8_t*>(&s[i])); // Load characters\n        svint8_t encrypted = svadd_s8_x(active, chars, shift); // Add shift value\n        svst1_s8(active, reinterpret_cast<int8_t*>(&result[i]), encrypted); // Store encrypted characters\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n\n    const int shift = 2 * 2; // Shift by 4 places\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active elements\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i)); // Load characters\n        svuint8_t rotated = svadd_u8_x(pg, chars, svdup_u8(shift)); // Rotate characters\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), rotated); // Store result\n        i += svcntb(); // Increment by vector length\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string encoded(len, '\\0');\n\n    const char vowels[] = \"AEIOUaeiou\";\n    const char replacements[] = \"CGKMQcgkmq\";\n\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(message.data() + index));\n        svuint8_t result = chars;\n\n        // Swap case\n        svbool_t is_upper = svcmplt_u8(pg, chars, svdup_u8('a'));\n        svbool_t is_lower = svcmpge_u8(pg, chars, svdup_u8('a'));\n        result = svsel_u8(is_upper, svadd_u8_x(pg, chars, svdup_u8('a' - 'A')), result);\n        result = svsel_u8(is_lower, svsub_u8_x(pg, chars, svdup_u8('a' - 'A')), result);\n\n        // Replace vowels\n        for (int i = 0; i < 10; ++i) {\n            svbool_t is_vowel = svcmpeq_u8(pg, result, svdup_u8(vowels[i]));\n            result = svsel_u8(is_vowel, svdup_u8(replacements[i]), result);\n        }\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(encoded.data() + index), result);\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, len);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string encoded(len, '\\0');\n\n    const char vowels[] = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    const char replacements[] = {'C', 'G', 'K', 'Q', 'W', 'c', 'g', 'k', 'q', 'w'};\n\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(message.data() + i));\n        svuint8_t result = chars;\n\n        // Swap case\n        svbool_t is_upper = svcmpeq_u8(pg, svand_u8(chars, svdup_u8(0xDF)), chars); // Check if uppercase\n        svbool_t is_lower = svnot_b_z(pg, is_upper); // Check if lowercase\n        result = svsel_u8(is_upper, svadd_u8(chars, svdup_u8(32)), result); // Convert to lowercase\n        result = svsel_u8(is_lower, svsub_u8(chars, svdup_u8(32)), result); // Convert to uppercase\n\n        // Replace vowels\n        for (int j = 0; j < 10; ++j) {\n            svbool_t is_vowel = svcmpeq_u8(pg, result, svdup_u8(vowels[j]));\n            result = svsel_u8(is_vowel, svdup_u8(replacements[j]), result);\n        }\n\n        svst1_u8(pg, reinterpret_cast<uint8_t *>(encoded.data() + i), result);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string encoded(len, '\\0');\n\n    const char vowels[] = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    const char replacements[] = {'C', 'G', 'K', 'Q', 'W', 'c', 'g', 'k', 'q', 'w'};\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t *>(message.data() + i));\n        svuint8_t result = vec;\n\n        // Swap case\n        svbool_t is_upper = svcmplt_u8(vec, svdup_u8('a'));\n        svbool_t is_lower = svcmpge_u8(vec, svdup_u8('a'));\n        svuint8_t upper_to_lower = svadd_u8(vec, svdup_u8('a' - 'A'));\n        svuint8_t lower_to_upper = svsub_u8(vec, svdup_u8('a' - 'A'));\n        result = svsel_u8(is_upper, upper_to_lower, result);\n        result = svsel_u8(is_lower, lower_to_upper, result);\n\n        // Replace vowels\n        for (int j = 0; j < 10; ++j) {\n            svbool_t is_vowel = svcmpeq_u8(result, svdup_u8(vowels[j]));\n            result = svsel_u8(is_vowel, svdup_u8(replacements[j]), result);\n        }\n\n        svst1_u8(pg, reinterpret_cast<uint8_t *>(encoded.data() + i), result);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n\n    const char vowels[] = \"AEIOUaeiou\";\n    const char vowel_replacements[] = \"CGKMQcgkmq\";\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t *>(message.data() + i));\n        svuint8_t encoded_chars = chars;\n\n        // Swap case\n        svbool_t is_upper = svcmplt_u8(pg, chars, svdup_u8('a'));\n        svbool_t is_lower = svcmpge_u8(pg, chars, svdup_u8('a'));\n        encoded_chars = svsel_u8(is_upper, svadd_u8_z(pg, chars, svdup_u8('a' - 'A')), encoded_chars);\n        encoded_chars = svsel_u8(is_lower, svsub_u8_z(pg, chars, svdup_u8('a' - 'A')), encoded_chars);\n\n        // Replace vowels\n        for (size_t v = 0; v < 10; ++v) {\n            svbool_t is_vowel = svcmpeq_u8(pg, encoded_chars, svdup_u8(vowels[v]));\n            encoded_chars = svsel_u8(is_vowel, svdup_u8(vowel_replacements[v]), encoded_chars);\n        }\n\n        svst1_u8(pg, reinterpret_cast<uint8_t *>(result.data() + i), encoded_chars);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::vector<char> encoded(len);\n\n    const char vowels[] = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'};\n    const char replacements[] = {'C', 'G', 'K', 'Q', 'W', 'c', 'g', 'k', 'q', 'w'};\n\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t *>(message.data() + i));\n        svuint8_t result = vec;\n\n        svbool_t is_upper = svcmplt_u8(pg, vec, svdup_u8('a'));\n        svuint8_t case_swapped = svsel_u8(is_upper, svadd_u8_x(pg, vec, svdup_u8('a' - 'A')),\n                                          svsub_u8_x(pg, vec, svdup_u8('a' - 'A')));\n\n        svbool_t is_vowel = svdup_b8(false);\n        for (size_t j = 0; j < 10; ++j) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, vec, svdup_u8(vowels[j])));\n        }\n\n        svuint8_t vowel_replaced = case_swapped;\n        for (size_t j = 0; j < 10; ++j) {\n            svbool_t match = svcmpeq_u8(pg, case_swapped, svdup_u8(vowels[j]));\n            vowel_replaced = svsel_u8(match, svdup_u8(replacements[j]), vowel_replaced);\n        }\n\n        result = svsel_u8(is_vowel, vowel_replaced, case_swapped);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t *>(encoded.data() + i), result);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return std::string(encoded.begin(), encoded.end());\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        size_t i = 0;\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + i));\n            svbool_t is_lower = svorr_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('a')), svcmple_u8(pg, chars, svdup_u8('z')));\n            svbool_t is_upper = svorr_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('A')), svcmple_u8(pg, chars, svdup_u8('Z')));\n\n            if (!svptest_all(pg, is_lower)) {\n                all_lower = false;\n            }\n            if (!svptest_all(pg, is_upper)) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        size_t index = 0;\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + index));\n\n            svbool_t is_lower = svorr_b_z(pg,\n                svcmpeq_u8(pg, chars, svdup_u8('a')),\n                svand_b_z(pg,\n                    svcmpge_u8(pg, chars, svdup_u8('a')),\n                    svcmple_u8(pg, chars, svdup_u8('z'))\n                )\n            );\n\n            svbool_t is_upper = svorr_b_z(pg,\n                svcmpeq_u8(pg, chars, svdup_u8('A')),\n                svand_b_z(pg,\n                    svcmpge_u8(pg, chars, svdup_u8('A')),\n                    svcmple_u8(pg, chars, svdup_u8('Z'))\n                )\n            );\n\n            if (!svptest_all(pg, is_lower)) {\n                all_lower = false;\n            }\n            if (!svptest_all(pg, is_upper)) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n\n            index += svcntb();\n            pg = svwhilelt_b8(index, len);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        svbool_t lower_mask = svdup_b_z(pg, true);\n        svbool_t upper_mask = svdup_b_z(pg, true);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            pg = svwhilelt_b8(i, len);\n\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + i));\n            svbool_t is_lower = svcmpeq_u8(pg, svand_u8(chars, svdup_u8(0xDF)), chars); // Check lowercase\n            svbool_t is_upper = svcmpeq_u8(pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8(0x41)); // Check uppercase\n\n            lower_mask = svand_b_z(pg, lower_mask, is_lower);\n            upper_mask = svand_b_z(pg, upper_mask, is_upper);\n        }\n\n        if (!svptest_any(svptrue_b8(), lower_mask)) {\n            all_lower = false;\n        }\n        if (!svptest_any(svptrue_b8(), upper_mask)) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        svbool_t lower_mask = svdup_b_z(pg, true);\n        svbool_t upper_mask = svdup_b_z(pg, true);\n\n        size_t i = 0;\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + i));\n\n            svbool_t is_lower = svcmpeq_u8(pg, chars, svand_u8(chars, svdup_u8(0xDF))); // Check lowercase\n            svbool_t is_upper = svcmpeq_u8(pg, chars, svand_u8(chars, svdup_u8(0x20))); // Check uppercase\n\n            lower_mask = svand_b_z(pg, lower_mask, is_lower);\n            upper_mask = svand_b_z(pg, upper_mask, is_upper);\n\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n\n        all_lower &= svptest_any(svptrue_b8(), lower_mask);\n        all_upper &= svptest_any(svptrue_b8(), upper_mask);\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        size_t index = 0;\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + index));\n\n            svbool_t is_lower = svorr_b_z(pg,\n                svand_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('a')), svcmple_u8(pg, chars, svdup_u8('z'))),\n                svcmpeq_u8(pg, chars, svdup_u8(' '))\n            );\n\n            svbool_t is_upper = svorr_b_z(pg,\n                svand_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('A')), svcmple_u8(pg, chars, svdup_u8('Z'))),\n                svcmpeq_u8(pg, chars, svdup_u8(' '))\n            );\n\n            if (!svptest_all(pg, is_lower)) {\n                all_lower = false;\n            }\n            if (!svptest_all(pg, is_upper)) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n\n            index += svcntb();\n            pg = svwhilelt_b8(index, len);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return {};\n    }\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    for (int i = 2; i < n; i += svcntw()) {\n        svint32_t vec = svindex_s32(i, 1); // Generate vector of consecutive integers starting from i\n        svbool_t is_prime = svdup_b_z(pg, 1); // Initialize all lanes as prime\n\n        for (int j = 2; j * j < n; ++j) {\n            svint32_t divisor = svdup_s32(j); // Broadcast divisor\n            svbool_t divisible = svcmpeq(pg, svmod_s32_z(pg, vec, divisor), svdup_s32(0)); // Check divisibility\n            is_prime = svbic_z(pg, is_prime, divisible); // Mask out non-prime numbers\n        }\n\n        // Extract prime numbers from the vector\n        int32_t temp[svcntw()];\n        svst1(pg, temp, vec);\n        svbool_t prime_mask = svwhilelt_b32(i, n);\n        for (int k = 0; k < svcntw() && svptest_any(pg, prime_mask); ++k) {\n            if (svptest_any(pg, svdup_b_z(pg, is_prime[k]))) {\n                primes.push_back(temp[k]);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    int limit = n;\n    svbool_t pg = svwhilelt_b32(0, limit);\n\n    svint32_t indices = svindex_s32(0, 1);\n    svuint32_t is_prime = svdup_u32(1); // Assume all numbers are prime initially\n\n    // Mark non-prime numbers using Sieve of Eratosthenes\n    for (int p = 2; p * p < n; ++p) {\n        svbool_t active = svwhilelt_b32(p, n);\n        svint32_t multiples = svmul_s32_z(active, svdup_s32(p), svindex_s32(p, p));\n\n        svbool_t mask = svcmpeq_s32(active, svmod_s32_z(active, multiples, svdup_s32(p));\n    }\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    svbool_t pg = svptrue_b32();\n    for (int i = 2; i < n; i += svcntw()) {\n        svint32_t vec = svindex_s32(i, 1); // Generate vector of integers starting from i\n        svbool_t mask = svcmple_s32(pg, vec, n - 1); // Mask for values less than n\n\n        svbool_t is_prime = svdup_b_z(pg, 1); // Initialize all as prime\n        for (int j = 2; j <= std::sqrt(n); ++j) {\n            svint32_t divisor = svdup_s32(j);\n            svint32_t remainder = svrem_s32_z(mask, vec, divisor); // Compute remainder\n            svbool_t divisible = svcmpeq_s32(mask, remainder, 0); // Check divisibility\n            is_prime = svbic_b32_z(mask, is_prime, divisible); // Remove non-prime numbers\n        }\n\n        svint32_t prime_candidates = svsel_s32(is_prime, vec, svdup_s32(0)); // Select primes\n        int buffer[svcntw()];\n        svst1_s32(pg, buffer, prime_candidates); // Store results to buffer\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (buffer[j] != 0) primes.push_back(buffer[j]);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n / 2); // Reserve space for potential primes\n\n    // Create a mask for all numbers from 2 to n-1\n    svbool_t pg = svwhilelt_b32(2, n);\n\n    // Initialize a vector of indices\n    svint32_t indices = svindex_s32(2, 1);\n\n    // Create a vector to mark non-prime numbers\n    std::vector<int> is_prime(n, 1); // 1 means prime, 0 means not prime\n\n    // Sieve of Eratosthenes using SVE\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            // Mark multiples of p as non-prime\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                is_prime[multiple] = 0;\n            }\n        }\n    }\n\n    // Use SVE to collect prime numbers\n    while (svptest_any(pg, pg)) {\n        svint32_t current = svadd_s32_x(pg, indices, 0);\n        svbool_t prime_mask = svcmpeq_s32(pg, svld1_s32(pg, is_prime.data()), 1);\n        svint32_t primes_vec = svcompact_s32(pg, current, prime_mask);\n\n        // Extract primes from the vector and add to the result\n        int32_t temp[svcntw()];\n        svst1_s32(pg, temp, primes_vec);\n        for (int i = 0; i < svcntw(); ++i) {\n            if (temp[i] < n && is_prime[temp[i]]) {\n                primes.push_back(temp[i]);\n            }\n        }\n\n        // Update the predicate for the next iteration\n        indices = svadd_s32_x(pg, indices, svcntw());\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) {\n        return {};\n    }\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    // Initialize a mask for marking non-prime numbers\n    svbool_t is_prime = svdup_b_z(pg, true);\n\n    // Sieve of Eratosthenes using SVE\n    for (int p = 2; p * p < n; ++p) {\n        if (svptest_any(pg, svand_b_z(pg, is_prime, svcmpeq(pg, indices, svdup_s32(p))))) {\n            svint32_t multiples = svmul_s32_z(pg, svdup_s32(p), svindex_s32(p, p));\n            svbool_t mask = svcmplt(pg, multiples, svdup_s32(n));\n            is_prime = svbic_b_z(pg, is_prime, svcmpeq(pg, indices, multiples));\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (svptest_any(pg, svand_b_z(pg, is_prime, svcmpeq(pg, indices, svdup_s32(i))))) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    size_t n = s.size();\n    const char *str = s.c_str();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svuint8_t even_mask = svdup_u8(0xFE); // Mask to check even indices\n\n    for (size_t i = 0; svptest_any(svptrue_b8(), pg); i += svcntb()) {\n        svuint8_t indices = svindex_u8(i, 1); // Generate indices\n        svuint8_t even_indices = svand_u8(indices, even_mask); // Mask even indices\n        svbool_t even_pred = svcmpeq_u8(pg, indices, even_indices); // Predicate for even indices\n\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(str + i)); // Load characters\n        svbool_t is_upper = svcmpeq_u8(pg, svand_u8(chars, even_pred), 0); // Check uppercase vowels\n        count+=svcntp(is_upper);\n    }\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    size_t len = s.size();\n    const char *str = s.c_str();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n    svuint8_t indices = svindex_u8(0, 1); // Vector of indices\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)str); // Load characters\n        svbool_t even_mask = svcmpeq_n_u8(pg, svand_n_u8(indices, 1), 0); // Mask for even indices\n\n        svbool_t is_upper = svand_b_z(even_mask, pg, svcmpeq_n_u8(pg, svand_n_u8(chars, 0xDF), 'A'));\n        svbool_t is_vowel = svorr_b_z(\n            is_upper,\n            svcmpeq_n_u8(pg, chars, 'A'),\n            svorr_b_z(\n                is_upper,\n                svcmpeq_n_u8(pg, chars, 'E'),\n                svorr_b_z(\n                    is_upper,\n                    svcmpeq_n_u8(pg, chars, 'I'),\n                    svorr_b_z(\n                        is_upper,\n                        svcmpeq_n_u8(pg, chars, 'O'),\n                        svcmpeq_n_u8(pg, chars, 'U')\n                    )\n                )\n            )\n        );\n\n        count += svcntp_b8(pg, is_vowel); // Count matching elements\n        str += svcntw();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    size_t n = s.size();\n    const char *str = s.c_str();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svuint8_t indices = svindex_u8(0, 1); // Generate indices [0, 1, 2, ...]\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)str); // Load characters\n        svbool_t even_mask = svcmpeq_n_u8(pg, svand_n_u8_x(pg, indices, 1), 0); // Mask for even indices\n\n        svbool_t is_upper = svand_b_z(pg, even_mask, // Combine even indices with uppercase check\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_n_u8(pg, chars, 'A'),\n                    svcmpeq_n_u8(pg, chars, 'E')),\n                svorr_b_z(pg,\n                    svcmpeq_n_u8(pg, chars, 'I'),\n                    svorr_b_z(pg,\n                        svcmpeq_n_u8(pg, chars, 'O'),\n                        svcmpeq_n_u8(pg, chars, 'U')))));\n\n        count += svcntp_b8(svptrue_b8(), is_upper); // Count active elements in the mask\n\n        str += svcntb(); // Move pointer forward by vector length\n        n -= svcntb();   // Reduce remaining size\n        pg = svwhilelt_b8(0, n); // Update predicate for remaining elements\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    size_t n = s.size();\n    const char *data = s.data();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, n);\n    svuint8_t indices = svindex_u8(0, 1); // Generate indices [0, 1, 2, ...]\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)data);\n        svuint8_t even_mask = svand_u8(indices, svdup_u8(1)); // Mask for even indices\n        svbool_t even_pg = svcmpeq_u8(pg, even_mask, svdup_u8(0)); // Select even indices\n\n        svbool_t is_upper = svcmpeq_u8(even_pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8('A'));\n        svbool_t is_vowel = svcmpeq_u8(even_pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8('E')) |\n                            svcmpeq_u8(even_pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8('I')) |\n                            svcmpeq_u8(even_pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8('O')) |\n                            svcmpeq_u8(even_pg, svand_u8(chars, svdup_u8(0xDF)), svdup_u8('U'));\n\n        svbool_t is_upper_vowel = svand_b_z(even_pg, is_upper, is_vowel);\n        count += svcntp_b8(svptrue_b8(), is_upper_vowel);\n\n        data += svcntb();\n        pg = svwhilelt_b8(data - s.data(), n);\n        indices = svadd_u8(indices, svdup_u8(svcntb()));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    size_t n = s.size();\n    const char *data = s.c_str();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, n); // Predicate for active elements\n    svuint8_t even_mask = svdup_u8(0xFE); // Mask to check even indices\n\n    for (size_t i = 0; svptest_any(pg, pg); i += svcntb()) {\n        svuint8_t indices = svindex_u8(i, 1); // Generate indices\n        svbool_t even_pred = svcmpeq_u8(pg, svand_u8(indices, even_mask), indices); // Check even indices\n\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(data + i)); // Load characters\n        svbool_t is_upper = svcmpeq_u8(pg, svand_u8(chars, 0x20), chars); // Check uppercase vowels\n\n        count += svaddv_u8(pg, is_upper);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine the vector length for SVE\n    int vl = svcntw();\n    \n    // Prepare the result vector\n    std::vector<int> result(n);\n\n    // Initialize the base value for the first level\n    int base = n;\n\n    // Create an SVE vector for the base value\n    svint32_t base_vec = svdup_s32(base);\n\n    // Create an increment vector based on whether n is odd or even\n    int increment = (n % 2 == 0) ? 2 : 2;\n    svint32_t increment_vec = svdup_s32(increment);\n\n    // Generate the levels in chunks of vector length\n    for (int i = 0; i < n; i += vl) {\n        // Create an index vector for the current chunk\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Compute the values for the current chunk\n        svint32_t levels_vec = svadd_s32_m(pg, base_vec, svmul_s32_x(pg, increment_vec, svindex_s32(0, 1)));\n\n        // Store the computed values into the result vector\n        svst1_s32(pg, &result[i], levels_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine the vector length for SVE\n    int vl = svcntw();\n    \n    // Create a vector to store the result\n    std::vector<int> result(n);\n\n    // Initialize the first level\n    int start = n;\n\n    // Use SVE to calculate the levels in parallel\n    for (int i = 0; i < n; i += vl) {\n        // Create an index vector\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Calculate the stone count for each level\n        svint32_t stones = svadd_s32_z(pg, svdup_s32(start), svmul_s32_z(pg, indices, svdup_s32(2)));\n\n        // Store the results back to the vector\n        svst1_s32(pg, &result[i], stones);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices starting from 0\n    svint32_t base = svdup_s32(n); // Broadcast n to all lanes\n\n    svint32_t odd_even_offset = svmul_s32_x(pg, indices, 2); // Calculate offsets (0, 2, 4, ...)\n    svint32_t stones = svadd_s32_x(pg, base, odd_even_offset); // Add offsets to n\n\n    // Store the result back to the vector\n    svst1_s32(pg, result.data(), stones);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine the vector length for SVE\n    int vl = svcntw();\n    std::vector<int> result(n);\n\n    // Initialize the base value and step\n    int base = n;\n    int step = (n % 2 == 0) ? 2 : 2;\n\n    // Create SVE vectors for base and step\n    svint32_t base_vec = svdup_s32(base);\n    svint32_t step_vec = svdup_s32(step);\n\n    // Create an index vector\n    svint32_t index_vec = svindex_s32(0, 1);\n\n    // Calculate the stone levels using SVE\n    svint32_t levels_vec = svmla_s32(base_vec, index_vec, step_vec);\n\n    // Store the results back to the output vector\n    svst1_s32(svptrue_b32(), result.data(), levels_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine the SVE vector length\n    int vl = svcntw();\n    std::vector<int> result(n);\n\n    // Initialize the base value for the first level\n    int base = n;\n\n    // Process levels in chunks of vector length\n    for (int i = 0; i < n; i += vl) {\n        // Create an index vector starting from i\n        svint32_t index = svindex_s32(i, 1);\n\n        // Calculate the stone count for each level\n        svint32_t stones = svadd_s32_z(svptrue_b32(), svdup_s32(base), svmul_s32_z(svptrue_b32(), index, svdup_s32(2)));\n\n        // Store the results back to the vector\n        svst1_s32(svptrue_b32(), &result[i], stones);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t range = m - n + 1;\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b64(n, m + 1); // Predicate for active elements\n    svint64_t vec_sum = svdup_s64(0);      // Initialize vector sum to 0\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_n = svindex_s64(n, 1); // Generate vector of integers starting from n\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_n); // Add active elements to the sum\n        n += svcntd(); // Increment n by the vector length\n        pg = svwhilelt_b64(n, m + 1); // Update predicate for remaining elements\n    }\n\n    sum = svaddv_s64(svptrue_b64(), vec_sum); // Reduce vector sum to scalar sum\n\n    int64_t avg = std::round(static_cast<double>(sum) / range); // Compute rounded average\n    return std::bitset<64>(avg).to_string().substr(64 - std::log2(avg + 1)); // Convert to binary\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t range = m - n + 1;\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b64(n, m + 1); // Predicate for active elements\n    svint64_t vec_sum = svdup_s64(0);      // Initialize vector sum to zero\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_n = svindex_s64(n, 1); // Create vector starting from n\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_n); // Add active elements to sum\n        n += svcntd(); // Increment n by the vector length\n        pg = svwhilelt_b64(n, m + 1); // Update predicate for remaining elements\n    }\n\n    sum = svaddv_s64(svptrue_b64(), vec_sum); // Reduce vector sum to scalar\n\n    int64_t avg = std::round(static_cast<double>(sum) / range); // Compute rounded average\n    return std::bitset<64>(avg).to_string(); // Convert to binary string\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t range = m - n + 1;\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec_sum = svdup_s64(0);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_n = svindex_s64(n, 1);\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_n);\n        n += svcntd();\n        pg = svwhilelt_b64(n, m + 1);\n    }\n\n    sum = svaddv_s64(svptrue_b64(), vec_sum);\n    int64_t avg = std::round(static_cast<double>(sum) / range);\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t range = m - n + 1;\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec_n = svindex_s64(n, 1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_sum = svadd_s64_z(pg, svdup_s64(0), vec_n);\n        sum += svaddv_s64(svptrue_b64(), vec_sum);\n        vec_n = svadd_s64_x(pg, vec_n, svdup_s64(svcntd()));\n        pg = svwhilelt_b64(svlastb_s64(vec_n), m + 1);\n    }\n\n    int64_t avg = std::round(static_cast<double>(sum) / range);\n    return std::bitset<64>(avg).to_string().substr(64 - static_cast<int>(std::log2(avg) + 1));\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t range = m - n + 1;\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b64(n, m + 1); // Predicate for active elements\n    svint64_t vec_sum = svdup_s64(0);      // Initialize vector sum to 0\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_n = svindex_s64(n, 1); // Generate vector of integers starting from n\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_n); // Add active elements to the vector sum\n        n += svcntd(); // Increment n by the number of elements processed\n        pg = svwhilelt_b64(n, m + 1); // Update predicate for remaining elements\n    }\n\n    sum = svaddv_s64(svptrue_b64(), vec_sum); // Reduce vector sum to scalar\n\n    int64_t avg = std::round(static_cast<double>(sum) / range); // Compute rounded average\n    return std::bitset<64>(avg).to_string().substr(64 - std::log2(avg + 1) - 1); // Convert to binary\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t is_even = svand_s32_x(pg, indices, svdup_s32(1)); // Check if index is even\n        svbool_t even_mask = svcmpeq_s32(pg, is_even, svdup_s32(0)); // Mask for even indices\n        svbool_t odd_mask = svnot_b_z(pg, even_mask); // Mask for odd indices\n\n        // Compute factorial modulo 10,000 for even indices\n        svint32_t factorial = svdup_s32(1);\n        svint32_t i = svdup_s32(1);\n        svbool_t factorial_pg = svwhilelt_b32(1, n);\n        while (svptest_any(svptrue_b32(), factorial_pg)) {\n            factorial = svmul_s32_x(factorial_pg, factorial, i);\n            i = svadd_s32_x(factorial_pg, i, svdup_s32(1));\n            factorial_pg = svwhilelt_b32(svaddv_s32(svptrue_b32(), i), n);\n        }\n        factorial = svmod_s32_x(even_mask, factorial, svdup_s32(10000));\n\n        // Compute sum of numbers from 1 to i for odd indices\n        svint32_t sum = svmul_s32_x(odd_mask, indices, svadd_s32_x(odd_mask, indices, svdup_s32(1)));\n        sum = svdiv_s32_x(odd_mask, sum, svdup_s32(2));\n\n        // Merge results\n        svint32_t merged = svsel_s32(even_mask, factorial, sum);\n\n        // Store results\n        svst1_s32(pg, result.data(), merged);\n\n        // Update predicate and indices\n        pg = svwhilelt_b32(svaddv_s32(svptrue_b32(), indices), n);\n        indices = svadd_s32_x(pg, indices, svdup_s32(svlen_s32(pg)));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n\n    int i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Calculate factorial for even indices\n        svbool_t even_mask = svcmpeq_s32(pg, svand_s32_x(pg, indices, svdup_s32(1)), svdup_s32(0));\n        svint32_t factorial = svdup_s32(1);\n        svint32_t temp_indices = svsel_s32(even_mask, indices, svdup_s32(1));\n        for (svint32_t j = svdup_s32(1); svptest_any(pg, svcmplt_s32(pg, j, temp_indices)); j = svadd_s32_x(pg, j, svdup_s32(1))) {\n            factorial = svmul_s32_x(pg, factorial, j);\n        }\n        factorial = svmod_s32_x(pg, factorial, svdup_s32(10000));\n\n        // Calculate sum for odd indices\n        svbool_t odd_mask = svnot_b_z(pg, even_mask);\n        svint32_t sum = svmul_s32_x(pg, temp_indices, svadd_s32_x(pg, temp_indices, svdup_s32(1)));\n        sum = svdiv_s32_x(pg, sum, svdup_s32(2));\n\n        // Combine results\n        svint32_t result_vec = svsel_s32(even_mask, factorial, sum);\n\n        // Store results\n        svst1_s32(pg, &result[i], result_vec);\n\n        // Update loop variables\n        i += svcntw();\n        indices = svadd_s32_x(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 1;\n\n    svbool_t pg = svwhilelt_b32(i, n + 1); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t indices = svindex_s32(i, 1); // Generate indices starting from i\n        svbool_t even_mask = svcmpeq_s32(pg, svand_s32_x(pg, indices, 1), 0); // Check if indices are even\n\n        // Compute factorial modulo 10,000 for even indices\n        svint32_t factorial = svdup_s32(1);\n        svint32_t counter = svdup_s32(1);\n        svbool_t fact_pg = svwhilelt_b32(1, svmaxv_s32(pg, indices) + 1);\n        while (svptest_any(svptrue_b32(), fact_pg)) {\n            factorial = svmul_s32_x(fact_pg, factorial, counter);\n            factorial = svmod_s32_x(fact_pg, factorial, svdup_s32(10000)); // Modulo 10,000\n            counter = svadd_s32_x(fact_pg, counter, svdup_s32(1));\n            fact_pg = svwhilelt_b32(svaddv_s32(fact_pg, counter), svmaxv_s32(pg, indices) + 1);\n        }\n\n        // Compute sum of numbers from 1 to i for odd indices\n        svint32_t sum = svmul_s32_x(pg, indices, svadd_s32_x(pg, indices, svdup_s32(1)));\n        sum = svdiv_s32_x(pg, sum, svdup_s32(2)); // Sum formula: i * (i + 1) / 2\n\n        // Select results based on even/odd mask\n        svint32_t result_vec = svsel_s32(even_mask, factorial, sum);\n\n        // Store results back to the vector\n        svst1_s32(pg, &result[i - 1], result_vec);\n\n        // Update loop variables\n        i += svcntw();\n        pg = svwhilelt_b32(i, n + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n\n    svint32_t factorial = svdup_s32(1); // Initialize factorial vector\n    svint32_t sum = svdup_s32(0); // Initialize sum vector\n    svint32_t mod_val = svdup_s32(10000); // Modulo value\n\n    for (int i = 1; svptest_any(pg, pg); i++) {\n        svbool_t even_mask = svcmpeq_s32(pg, svand_s32_x(pg, indices, svdup_s32(1)), svdup_s32(0)); // Check if index is even\n        svbool_t odd_mask = svnot_b_z(pg, even_mask); // Check if index is odd\n\n        // Compute factorial for even indices\n        factorial = svmul_s32_x(even_mask, factorial, indices);\n        factorial = svmod_s32_x(even_mask, factorial, mod_val);\n\n        // Compute sum for odd indices\n        sum = svadd_s32_x(odd_mask, sum, indices);\n\n        // Store results\n        svint32_t result_vec = svsel_s32(even_mask, factorial, sum);\n        svst1_s32(pg, result.data() + (i - 1), result_vec);\n\n        // Increment indices and update predicate\n        indices = svadd_s32_x(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(i * svcntw(), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n\n    svint32_t factorial = svdup_s32(1); // Initialize factorial vector\n    svint32_t sum = svdup_s32(0); // Initialize sum vector\n    svint32_t mod_value = svdup_s32(10000); // Modulo value\n\n    for (int i = 1; svptest_any(pg, pg); i++) {\n        svbool_t is_even = svcmpeq_s32(pg, svand_s32_x(pg, indices, svdup_s32(1)), svdup_s32(0)); // Check if index is even\n        svbool_t is_odd = svnot_b_z(pg, is_even); // Check if index is odd\n\n        // Update factorial for even indices\n        factorial = svmul_s32_x(is_even, factorial, indices);\n        factorial = svmod_s32_x(is_even, factorial, mod_value);\n\n        // Update sum for odd indices\n        sum = svadd_s32_m(is_odd, sum, indices);\n\n        // Store results in the output vector\n        svint32_t result_vec = svsel_s32(is_even, factorial, sum);\n        svst1_s32(pg, result.data() + i - 1, result_vec);\n\n        // Increment indices and update predicate\n        indices = svadd_s32_x(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(i * svcntw(), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\n// Helper function to check if a number is a palindrome\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    int len = s.size();\n    for (int i = 0; i < len / 2; ++i) {\n        if (s[i] != s[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // SVE vector length agnostic loop\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t active = svwhilelt_b32(i, n + 1);\n\n        // Check if numbers are palindromes\n        svint32_t palindromes = svdup_s32(0);\n        for (int j = 0; j < svcntw(); ++j) {\n            int num = svlasta_s32(active, svadd_s32_z(active, indices, svdup_s32(j)));\n            if (is_palindrome(num)) {\n                palindromes = svadd_s32_z(active, palindromes, svdup_s32(1));\n            }\n        }\n\n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_s32(palindromes, svand_s32_z(active, palindromes, svdup_s32(1)));\n        even_count += svcntp_b32(active, is_even);\n        odd_count += svcntp_b32(active, svnot_b_z(active, is_even));\n\n        pg = svwhilelt_b32(i + svcntw(), n + 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    int len = s.size();\n    for (int i = 0; i < len / 2; ++i) {\n        if (s[i] != s[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t nums = svand_s32_z(pg, indices, svdup_s32(n));\n        svbool_t pal_pg = svdup_b32(false);\n\n        for (int i = 0; i < svcntw(); ++i) {\n            int num = svlasta_s32(pg, nums);\n            if (is_palindrome(num)) {\n                pal_pg = svorr_b32(pal_pg, svdup_b32(true));\n            }\n        }\n\n        svbool_t even_pg = svand_b_z(pal_pg, svcmpeq_s32(pg, svand_s32_z(pg, nums, svdup_s32(1)), svdup_s32(0)));\n        svbool_t odd_pg = svand_b_z(pal_pg, svcmpne_s32(pg, svand_s32_z(pg, nums, svdup_s32(1)), svdup_s32(0)));\n\n        even_count += svcntp_b32(pal_pg, even_pg);\n        odd_count += svcntp_b32(pal_pg, odd_pg);\n\n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\n// Helper function to check if a number is a palindrome\nstatic inline bool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    int len = s.size();\n    for (int i = 0; i < len / 2; ++i) {\n        if (s[i] != s[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n\n    // SVE vector length agnostic loop\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t indices = svadd_s32_z(pg, svdup_s32(i), svindex_s32(0, 1));\n        svbool_t valid_indices = svcmple_s32(pg, indices, svdup_s32(n));\n\n        // Check if numbers are palindromes\n        svint32_t palindromes = svdup_s32(0);\n        for (int j = 0; j < svcntw(); ++j) {\n            int num = svlastb_s32(valid_indices, indices);\n            if (is_palindrome(num)) {\n                palindromes = svadd_s32_z(valid_indices, palindromes, svdup_s32(1));\n            }\n        }\n\n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_s32(pg, svand_s32_z(pg, palindromes, svdup_s32(1)), svdup_s32(0));\n        even_count += svcntp_b32(pg, is_even);\n        odd_count += svcntp_b32(pg, svnot_b_z(pg, is_even));\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t numbers = svadd_s32_z(pg, indices, svdup_s32(1));\n        svbool_t is_palindrome_mask = svdup_b32(false);\n\n        for (int i = 0; i < svcntw(); i++) {\n            int num = svlasta_s32(pg, numbers);\n            if (is_palindrome(num)) {\n                is_palindrome_mask = svorr_b_z(pg, is_palindrome_mask, svdup_b32(true));\n            }\n            numbers = svadd_s32_z(pg, numbers, svdup_s32(1));\n        }\n\n        svbool_t even_mask = svand_b_z(pg, is_palindrome_mask, svcmpeq_s32(pg, svand_s32_z(pg, numbers, svdup_s32(1)), svdup_s32(0)));\n        svbool_t odd_mask = svand_b_z(pg, is_palindrome_mask, svcmpne_s32(pg, svand_s32_z(pg, numbers, svdup_s32(1)), svdup_s32(0)));\n\n        even_count += svcntp_b32(pg, even_mask);\n        odd_count += svcntp_b32(pg, odd_mask);\n\n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    return std::equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n\n    svbool_t pg = svwhilelt_b32(1, n);\n    svint32_t indices = svindex_s32(1, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t numbers = svadd_s32_z(pg, indices, svdup_s32(0));\n        svint32_t palindromes = svdup_s32(0);\n\n        svbool_t is_palindrome_mask = svdup_b32(false);\n        for (int i = 0; i < svcntw(); ++i) {\n            int num = svlasta_s32(pg, numbers);\n            if (is_palindrome(num)) {\n                is_palindrome_mask = svorr_b32_z(pg, is_palindrome_mask, svdup_b32(true));\n            }\n        }\n\n        svint32_t evens = svand_s32_z(is_palindrome_mask, numbers, svdup_s32(1));\n        svint32_t odds = svsub_s32_z(is_palindrome_mask, numbers, svdup_s32(1));\n        even_count += svaddv_s32(pg, evens);\n        odd_count += svaddv_s32(pg, odds);\n\n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(svlastb_s32(pg, indices), n);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    const int *data = n.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0);   // Initialize vector count to 0\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector of integers\n        svint32_t abs_vec = svabs_s32_z(pg, vec); // Get absolute values\n\n        svint32_t sum_digits = svdup_s32(0); // Initialize sum of digits\n        while (svptest_any(pg, abs_vec)) {\n            svint32_t digit = svmod_s32_z(pg, abs_vec, svdup_s32(10)); // Extract last digit\n            sum_digits = svadd_s32_m(pg, sum_digits, digit);           // Add digit to sum\n            abs_vec = svdiv_s32_z(pg, abs_vec, svdup_s32(10));         // Remove last digit\n        }\n\n        svbool_t mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0)); // Check sum of digits > 0\n        vec_count = svadd_s32_m(mask, vec_count, svdup_s32(1));    // Increment count for valid elements\n\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    count = svaddv_s32(svptrue_b32(), vec_count); // Reduce vector count to scalar\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t size = n.size();\n    if (size == 0) return 0;\n\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t zero_vec = svdup_s32(0);    // Vector of zeros\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, n.data() + i); // Load vector of integers\n        svint32_t abs_vec = svabs_s32_z(pg, vec);    // Take absolute values\n\n        svint32_t sum_digits = svdup_s32(0);         // Initialize sum of digits\n        while (svptest_any(svptrue_b32(), svcmpgt(pg, abs_vec, zero_vec))) {\n            svint32_t digit = svmod_s32_z(pg, abs_vec, svdup_s32(10)); // Extract last digit\n            sum_digits = svadd_s32_m(pg, sum_digits, digit);           // Add to sum\n            abs_vec = svdiv_s32_z(pg, abs_vec, svdup_s32(10));         // Remove last digit\n        }\n\n        svbool_t mask = svcmpgt(pg, sum_digits, zero_vec); // Check if sum of digits > 0\n        count += svcntp_b32(pg, mask);                    // Count active elements in mask\n\n        pg = svwhilelt_b32(i + svcntw(), size);           // Update predicate for next iteration\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    const int *data = n.data();\n\n    svbool_t pg = svwhilelt_b32(0, size);\n    svint32_t vec_count = svdup_s32(0);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec = svld1(pg, &data[i]);\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n\n        svint32_t sum_digits = svdup_s32(0);\n        while (svptest_any(pg, abs_vec)) {\n            svint32_t digit = svmod_s32_x(pg, abs_vec, svdup_s32(10));\n            sum_digits = svadd_s32_x(pg, sum_digits, digit);\n            abs_vec = svdiv_s32_x(pg, abs_vec, svdup_s32(10));\n        }\n\n        svbool_t mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0));\n        vec_count = svadd_s32_m(mask, vec_count, svdup_s32(1));\n\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n\n    count = svaddv_s32(svptrue_b32(), vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    const int *data = n.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0);   // Initialize vector count to 0\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector of integers\n        svint32_t abs_vec = svabs_s32_m(pg, vec); // Compute absolute values\n\n        svint32_t sum_digits = svdup_s32(0);\n        while (svptest_any(pg, abs_vec)) {\n            svint32_t digit = svmod_s32_m(pg, abs_vec, svdup_s32(10)); // Extract last digit\n            sum_digits = svadd_s32_m(pg, sum_digits, digit);           // Accumulate sum of digits\n            abs_vec = svdiv_s32_m(pg, abs_vec, svdup_s32(10));         // Remove last digit\n        }\n\n        svbool_t mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0)); // Check sum of digits > 0\n        vec_count = svadd_s32_m(pg, vec_count, svdup_s32(1), mask); // Increment count where condition is true\n\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    count = svaddv_s32(svptrue_b32(), vec_count); // Reduce vector count to scalar\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    const int *data = n.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0);   // Initialize vector count to 0\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector of integers\n        svint32_t abs_vec = svabs_s32_x(pg, vec); // Get absolute values\n\n        svint32_t sum_digits = svdup_s32(0); // Initialize sum of digits\n        while (svptest_any(pg, abs_vec)) {   // While there are non-zero elements\n            svint32_t digit = svmod_s32_x(pg, abs_vec, svdup_s32(10)); // Extract last digit\n            sum_digits = svadd_s32_x(pg, sum_digits, digit);           // Add to sum\n            abs_vec = svdiv_s32_x(pg, abs_vec, svdup_s32(10));         // Remove last digit\n        }\n\n        svbool_t mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0)); // Check sum > 0\n        vec_count = svadd_s32_m(mask, vec_count, svdup_s32(1));    // Increment count where mask is true\n\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    count = svaddv_s32(svptrue_b32(), vec_count); // Reduce vector count to scalar\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    // Check if the array is already sorted\n    bool sorted = true;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i - 1]) {\n            sorted = false;\n            break;\n        }\n    }\n    if (sorted) return true;\n\n    // Convert std::vector to raw array for SVE processing\n    int* data = arr.data();\n\n    // Iterate through all possible rotations\n    for (int shift = 0; shift < n; shift++) {\n        // Perform the rotation\n        std::rotate(arr.begin(), arr.begin() + 1, arr.end());\n\n        // Reload data pointer after rotation\n        data = arr.data();\n\n        // Use SVE to check if the array is sorted\n        svbool_t pg = svwhilelt_b32(0, n - 1);\n        bool is_sorted = true;\n        for (int i = 0; i < n - 1; i += svcntw()) {\n            svint32_t vec1 = svld1(pg, &data[i]);\n            svint32_t vec2 = svld1(pg, &data[i + 1]);\n            svbool_t cmp = svcmple(pg, vec1, vec2);\n            if (!svptest_any(pg, cmp)) {\n                is_sorted = false;\n                break;\n            }\n            pg = svwhilelt_b32(i + svcntw(), n - 1);\n        }\n\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Check if the array is already sorted\n    bool sorted = true;\n    for (int i = 1; i < N; i++) {\n        if (arr[i - 1] > arr[i]) {\n            sorted = false;\n            break;\n        }\n    }\n    if (sorted) return true;\n\n    // Prepare a sorted version of the array for comparison\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Use SVE to check all rotations\n    svbool_t pg = svwhilelt_b32(0, N);\n    svint32_t sorted_vec = svld1(pg, sorted_arr.data());\n\n    for (int shift = 0; shift < N; shift++) {\n        // Perform the right shift\n        std::vector<int> shifted_arr(N);\n        for (int i = 0; i < N; i++) {\n            shifted_arr[(i + shift) % N] = arr[i];\n        }\n\n        // Load the shifted array into SVE vector\n        svint32_t shifted_vec = svld1(pg, shifted_arr.data());\n\n        // Compare the shifted array with the sorted array\n        svbool_t cmp = svcmpeq(pg, shifted_vec, sorted_vec);\n        if (svptest_all(pg, cmp)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Check if the array is already sorted\n    bool is_sorted = true;\n    for (int i = 1; i < N; i++) {\n        if (arr[i] < arr[i - 1]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    if (is_sorted) return true;\n\n    // Use SVE to check for sorted order after right shifts\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t vec = svld1(pg, arr.data()); // Load vector into SVE register\n\n    for (int shift = 1; shift < N; shift++) {\n        // Perform right shift\n        std::rotate(arr.begin(), arr.end() - 1, arr.end());\n        vec = svld1(pg, arr.data()); // Reload shifted vector into SVE register\n\n        // Check if the array is sorted using SVE\n        bool sorted = true;\n        for (int i = 1; i < N; i++) {\n            svint32_t prev = svld1(pg, &arr[i - 1]);\n            svint32_t curr = svld1(pg, &arr[i]);\n            svbool_t cmp = svcmple_s32(pg, prev, curr); // Compare elements\n            if (!svptest_all(pg, cmp)) {\n                sorted = false;\n                break;\n            }\n        }\n        if (sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Check if the array is already sorted\n    bool is_sorted = true;\n    for (int i = 1; i < N; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    if (is_sorted) return true;\n\n    // Use SVE to check all rotations\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t vec = svld1(pg, arr.data()); // Load the array into an SVE vector\n\n    for (int shift = 1; shift < N; ++shift) {\n        // Perform a right shift\n        svint32_t rotated = svext(vec, vec, N - shift);\n\n        // Check if the rotated vector is sorted\n        bool sorted = true;\n        for (int i = 1; i < N; ++i) {\n            svint32_t prev = svdup_n_s32(arr[i - 1]);\n            svint32_t curr = svdup_n_s32(arr[i]);\n            svbool_t cmp = svcmple_s32(pg, prev, curr); // Compare elements\n            if (!svptest_any(pg, cmp)) {\n                sorted = false;\n                break;\n            }\n        }\n        if (sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Check if the array is already sorted\n    bool is_sorted = true;\n    for (size_t i = 1; i < N; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    if (is_sorted) return true;\n\n    // Create a copy of the array to simulate rotations\n    std::vector<int> rotated_arr(N);\n\n    // Iterate over all possible rotations\n    for (size_t shift = 1; shift < N; ++shift) {\n        // Perform the rotation\n        svbool_t pg = svwhilelt_b32(0, N);\n        svint32_t vec = svld1(pg, arr.data());\n        svint32_t rotated_vec = svext(vec, vec, shift);\n        svst1(pg, rotated_arr.data(), rotated_vec);\n\n        // Check if the rotated array is sorted\n        bool is_sorted = true;\n        for (size_t i = 1; i < N; ++i) {\n            if (rotated_arr[i - 1] > rotated_arr[i]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    // Convert input vectors to arrays for SVE processing\n    const int* arr1 = lst1.data();\n    const int* arr2 = lst2.data();\n\n    // Allocate masks for lst1 and lst2\n    svbool_t mask1 = svptrue_b32();\n    svbool_t mask2 = svptrue_b32();\n\n    // Check lst1 for odd numbers\n    for (size_t i = 0; i < len1; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len1);\n        svint32_t vec1 = svld1(pg, &arr1[i]);\n        svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32(vec1, 1), 1);\n        mask1 = svorr_b_z(mask1, pg, odd_mask);\n    }\n\n    // Check lst2 for even numbers\n    for (size_t i = 0; i < len2; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len2);\n        svint32_t vec2 = svld1(pg, &arr2[i]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32(vec2, 1), 0);\n        mask2 = svorr_b_z(mask2, pg, even_mask);\n    }\n\n    // If lst1 has odd numbers and lst2 has no even numbers, return \"NO\"\n    if (svptest_any(svptrue_b32(), mask1) && !svptest_any(svptrue_b32(), mask2)) {\n        return \"NO\";\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    // Convert input vectors to arrays for SVE processing\n    const int* arr1 = lst1.data();\n    const int* arr2 = lst2.data();\n\n    // Create masks for even numbers in lst1 and lst2\n    svbool_t mask1, mask2;\n    size_t index1 = 0, index2 = 0;\n\n    // Check if lst1 can be made entirely even\n    while (index1 < len1) {\n        svbool_t pg = svwhilelt_b32(index1, len1);\n        svint32_t vec1 = svld1(pg, &arr1[index1]);\n        mask1 = svcmpeq_n_s32(pg, svand_n_s32(vec1, 1), 0); // Check for even numbers in lst1\n\n        if (!svptest_any(svptrue_b32(), mask1)) {\n            // If lst1 has odd numbers, check lst2 for even replacements\n            while (index2 < len2) {\n                svbool_t pg2 = svwhilelt_b32(index2, len2);\n                svint32_t vec2 = svld1(pg2, &arr2[index2]);\n                mask2 = svcmpeq_n_s32(pg2, svand_n_s32(vec2, 1), 0); // Check for even numbers in lst2\n\n                if (svptest_any(svptrue_b32(), mask2)) {\n                    // Found even number in lst2, replace odd number in lst1\n                    index2 += svcntw();\n                    break;\n                }\n                index2 += svcntw();\n            }\n\n            if (index2 >= len2) {\n                // No even numbers left in lst2 to replace odd numbers in lst1\n                return \"NO\";\n            }\n        }\n        index1 += svcntw();\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    // Convert input vectors to arrays for SVE processing\n    const int* arr1 = lst1.data();\n    const int* arr2 = lst2.data();\n\n    // Check if all elements in lst1 are already even\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n1);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec1 = svld1(pg, &arr1[i]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32(vec1, 1), 0);\n        if (!svptest_all(pg, even_mask)) {\n            break;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n1);\n    }\n    if (!svptest_any(svptrue_b32(), pg)) {\n        return \"YES\";\n    }\n\n    // Check if there are enough even numbers in lst2 to replace odd numbers in lst1\n    size_t even_count_lst2 = 0;\n    i = 0;\n    pg = svwhilelt_b32(i, n2);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec2 = svld1(pg, &arr2[i]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32(vec2, 1), 0);\n        even_count_lst2 += svcntp_b32(pg, even_mask);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n2);\n    }\n\n    // Count odd numbers in lst1\n    size_t odd_count_lst1 = 0;\n    i = 0;\n    pg = svwhilelt_b32(i, n1);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec1 = svld1(pg, &arr1[i]);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_n_s32(vec1, 1), 0);\n        odd_count_lst1 += svcntp_b32(pg, odd_mask);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n1);\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    // Convert std::vector to raw arrays for SVE processing\n    const int* arr1 = lst1.data();\n    const int* arr2 = lst2.data();\n\n    // Track if lst2 contains at least one even number\n    bool has_even_in_lst2 = false;\n\n    // Process lst2 to check for even numbers using SVE\n    svbool_t pg = svwhilelt_b32(0, len2);\n    int index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec2 = svld1(pg, &arr2[index]);\n        svbool_t even_mask = svcmpeq_n_s32(svand_n_s32(vec2, 1), 0);\n        if (svptest_any(svptrue_b32(), even_mask)) {\n            has_even_in_lst2 = true;\n            break;\n        }\n        index += svcntw();\n        pg = svwhilelt_b32(index, len2);\n    }\n\n    if (!has_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Process lst1 to check if all elements can be made even\n    pg = svwhilelt_b32(0, len1);\n    index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec1 = svld1(pg, &arr1[index]);\n        svbool_t odd_mask = svcmpeq_n_s32(svand_n_s32(vec1, 1), 1);\n        if (svptest_any(svptrue_b32(), odd_mask)) {\n            return \"NO\";\n        }\n        index += svcntw();\n        pg = svwhilelt_b32(index, len1);\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    // Convert input vectors to arrays for SVE processing\n    const int* arr1 = lst1.data();\n    const int* arr2 = lst2.data();\n\n    // Allocate buffers for SVE processing\n    svbool_t pg1 = svwhilelt_b32(0, len1);\n    svbool_t pg2 = svwhilelt_b32(0, len2);\n\n    svbool_t all_even = svptrue_b32(); // Mask for checking all elements are even\n\n    // Process lst1\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg1); i += svcntw()) {\n        svint32_t vec1 = svld1(pg1, &arr1[i]);\n        svbool_t even_mask1 = svcmpeq_n_s32(svand_n_s32(vec1, 1), 0); // Check even elements\n        all_even = svand_b_z(pg1, all_even, even_mask1); // Update all_even mask\n        pg1 = svwhilelt_b32(i + svcntw(), len1);\n    }\n\n    // If lst1 already contains only even numbers\n    if (svptest_all(svptrue_b32(), all_even)) {\n        return \"YES\";\n    }\n\n    // Process lst2 to find even numbers\n    svbool_t has_even_in_lst2 = svpfalse_b32();\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg2); i += svcntw()) {\n        svint32_t vec2 = svld1(pg2, &arr2[i]);\n        svbool_t even_mask2 = svcmpeq_n_s32(svand_n_s32(vec2, 1), 0); // Check even elements\n        has_even_in_lst2 = svorr_b_z(pg2, has_even_in_lst2, even_mask2); // Update has_even_in_lst2 mask\n        pg2 = svwhilelt_b32(i + svcntw(), len2);\n    }\n\n    // If lst2 contains even numbers, exchange is possible\n    if (svptest_any(svptrue_b32(), has_even_in_lst2)) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        size_t len = str.size();\n        svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n        svuint8_t vec = svdup_u8(0); // Initialize vector\n        size_t odd_count = 0;\n\n        // Load string into SVE vector and process\n        for (size_t j = 0; j < len; j += svcntb()) {\n            pg = svwhilelt_b8(j, len);\n            vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.data() + j));\n            svuint8_t odd_mask = svand_u8(vec, svdup_u8(1)); // Check odd digits\n            svuint8_t is_odd = svcmpeq_u8(pg, odd_mask, svdup_u8(1));\n            odd_count += svcntp_b8(pg, is_odd); // Count odd digits\n        }\n\n        // Construct the output string\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        size_t len = str.size();\n        svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n        svuint8_t vec = svdup_u8(0);        // Initialize vector to zero\n        size_t odd_count = 0;\n\n        for (size_t j = 0; j < len; j += svcntb()) {\n            pg = svwhilelt_b8(j, len); // Update predicate for active elements\n            svuint8_t digits = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.data() + j));\n            svuint8_t odd_mask = svand_u8(svsub_u8(digits, svdup_u8('0')), svdup_u8(1)); // Check odd digits\n            svuint8_t odd_count_vec = svcntp_b8(pg, odd_mask); // Count odd digits in active elements\n            odd_count += svaddv_u8(pg, odd_count_vec); // Accumulate odd counts\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        const char *input = str.c_str();\n\n        // Initialize SVE variables\n        svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n        svuint8_t odd_mask = svdup_u8(1);   // Mask for odd numbers\n        svuint8_t zero_char = svdup_u8('0'); // ASCII '0' for conversion\n\n        int odd_count = 0;\n        size_t index = 0;\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            // Load characters from the string\n            svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t *>(input + index));\n\n            // Convert characters to integers\n            svuint8_t digits = svsub_u8_x(pg, chars, zero_char);\n\n            // Check if the digits are odd\n            svuint8_t is_odd = svand_u8_x(pg, digits, odd_mask);\n\n            // Count odd digits\n            odd_count += svcntp_b8(pg, svcmpne_u8(pg, is_odd, svdup_u8(0)));\n\n            // Update index and predicate\n            index += svcntw();\n            pg = svwhilelt_b8(index, len);\n        }\n\n        // Construct the output string\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &str = lst[i];\n        size_t len = str.size();\n        size_t odd_count = 0;\n\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svdup_u8(0);\n\n        for (size_t j = 0; svptest_any(svptrue_b8(), pg); j += svcntb()) {\n            svuint8_t digits = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str.data() + j));\n            svuint8_t odd_mask = svand_u8(digits, svdup_u8(1));\n            svuint8_t odd_digits = svcmpeq_u8(pg, odd_mask, svdup_u8(1));\n            odd_count += svcntp_b8(svptrue_b8(), odd_digits);\n            pg = svwhilelt_b8(j + svcntb(), len);\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \n                         \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &str = lst[i];\n        size_t len = str.size();\n        svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n        svuint8_t vec = svdup_u8(0);        // Initialize vector to zero\n        size_t odd_count = 0;\n\n        for (size_t j = 0; j < len; j += svcntb()) {\n            pg = svwhilelt_b8(j, len); // Update predicate for current chunk\n            vec = svld1_u8(pg, reinterpret_cast<const uint8_t *>(str.data() + j)); // Load chunk of characters\n            svuint8_t odd_mask = svand_u8(vec, svdup_u8(1)); // Mask for odd digits\n            svbool_t is_odd = svcmpeq_u8(pg, odd_mask, svdup_u8(1)); // Compare for odd digits\n            odd_count += svcntp_b8(pg, is_odd); // Count odd digits\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t sv_min_sum = svdup_s64(std::numeric_limits<int64_t>::max());\n    svint64_t sv_current_sum = svdup_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svint64_t sv_nums = svld1_s64(pg, nums.data() + i);\n\n        sv_current_sum = svadd_s64_m(pg, sv_current_sum, sv_nums);\n        sv_min_sum = svmin_s64_m(pg, sv_min_sum, sv_current_sum);\n\n        svbool_t reset_mask = svcmplt_s64(pg, sv_current_sum, svdup_s64(0));\n        sv_current_sum = svsel_s64(reset_mask, svdup_s64(0), sv_current_sum);\n    }\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    svst1_s64(pg, &min_sum, sv_min_sum);\n\n    for (size_t i = 0; i < svcntd(); ++i) {\n        if (min_sum > nums[i]) {\n            min_sum = nums[i];\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t min_ending_here = svdup_s64(0);\n    svint64_t min_so_far = svdup_s64(std::numeric_limits<int64_t>::max());\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svint64_t vec = svld1_s64(pg, nums.data() + i);\n\n        min_ending_here = svmin_s64_z(pg, vec, svadd_s64_z(pg, min_ending_here, vec));\n        min_so_far = svmin_s64_z(pg, min_so_far, min_ending_here);\n    }\n\n    int64_t result = std::numeric_limits<int64_t>::max();\n    svst1_s64(pg, &result, min_so_far);\n    for (size_t i = 0; i < svcntd(); ++i) {\n        result = std::min(result, svdup_lane_s64(min_so_far, i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    svint64_t min_sum = svdup_s64(std::numeric_limits<int64_t>::max());\n    svint64_t current_sum = svdup_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svint64_t vec = svld1_s64(pg, nums.data() + i); // Load vector\n        current_sum = svadd_s64_m(pg, current_sum, vec); // Add current vector to running sum\n        min_sum = svmin_s64_m(pg, min_sum, current_sum); // Update minimum sum\n\n        // Reset current_sum to 0 if it becomes positive\n        svbool_t reset_pg = svcmpgt_s64(pg, current_sum, svdup_s64(0));\n        current_sum = svsel_s64(reset_pg, svdup_s64(0), current_sum);\n\n        pg = svwhilelt_b64(i + svcntd(), n); // Update predicate for next iteration\n    }\n\n    // Reduce the min_sum vector to a single scalar value\n    return svminv_s64(svptrue_b64(), min_sum);\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n    svint64_t min_ending_here = svdup_s64(0); // Current subarray minimum\n    svint64_t global_min = svdup_s64(std::numeric_limits<int64_t>::max()); // Global minimum\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t active = svwhilelt_b64(i, n); // Active lanes for current chunk\n        svint64_t vec = svld1_s64(active, &nums[i]); // Load vector chunk\n\n        // Kadane's algorithm: min_ending_here = min(vec, min_ending_here + vec)\n        min_ending_here = svadd_s64_m(active, min_ending_here, vec);\n        min_ending_here = svmin_s64_m(active, min_ending_here, vec);\n\n        // Update global_min\n        global_min = svmin_s64_m(active, global_min, min_ending_here);\n    }\n\n    // Reduce global_min to a single value\n    int64_t result = svminv_s64(pg, global_min);\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    const int64_t* data = nums.data();\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    svint64_t min_sum_vec = svdup_s64(std::numeric_limits<int64_t>::max());\n    svint64_t current_sum_vec = svdup_s64(0);\n\n    size_t index = 0;\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec = svld1_s64(pg, &data[index]);\n        current_sum_vec = svadd_s64_x(pg, current_sum_vec, vec);\n        current_sum_vec = svmin_s64_x(pg, current_sum_vec, vec);\n        min_sum_vec = svmin_s64_x(pg, min_sum_vec, current_sum_vec);\n\n        index += svcntd();\n        pg = svwhilelt_b64(index, n);\n    }\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    for (size_t i = 0; i < svcntd(); ++i) {\n        min_sum = std::min(min_sum, svlastb_s64(min_sum_vec));\n        min_sum_vec = svext_s64(min_sum_vec, min_sum_vec, 1);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int row_buckets = 0;\n\n        // Initialize SVE vector processing\n        svbool_t pg = svwhilelt_b32(0, row_size); // Predicate for active elements\n        int index = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            // Load a vector of elements from the row\n            svint32_t vec = svld1_s32(pg, &row[index]);\n\n            // Count the number of 1s in the vector\n            svint32_t ones = svdup_s32(1);\n            svint32_t matches = svcmpeq_s32(pg, vec, ones);\n            int count = svcadd_s32_z(pg, matches, 0);\n\n            // Accumulate the count into row_buckets\n            row_buckets += count;\n\n            // Move to the next vector\n            index += svcntw();\n            pg = svwhilelt_b32(index, row_size);\n        }\n\n        // Compute the number of buckets required for this row\n        total_buckets += (row_buckets + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        size_t n = row.size();\n        int row_sum = 0;\n\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t vec = svld1(pg, &row[i]);\n            row_sum += svaddv_s32(pg, vec);\n            i += svcntw();\n            pg = svwhilelt_b32(i, n);\n        }\n\n        total_buckets += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int row_sum = 0;\n\n        // Process the row using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(0, row_size); // Predicate for active elements\n        for (int i = 0; i < row_size; i += svcntw()) {\n            svint32_t vec = svld1(pg, &row[i]); // Load elements into vector\n            row_sum += svaddv_s32(pg, vec);    // Sum the active elements\n            pg = svwhilelt_b32(i + svcntw(), row_size); // Update predicate\n        }\n\n        // Calculate the number of buckets needed for this row\n        total_buckets += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_operations = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int row_sum = 0;\n\n        // Use SVE to sum up the row\n        svbool_t pg = svwhilelt_b32(0, row_size);\n        int index = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t vec = svld1_s32(pg, &row[index]);\n            svint32_t sum_vec = svadd_s32_z(pg, vec, svdup_s32(0));\n            row_sum += svaddv_s32(pg, sum_vec);\n\n            index += svcntw();\n            pg = svwhilelt_b32(index, row_size);\n        }\n\n        // Calculate the number of bucket operations for this row\n        total_operations += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        size_t n = row.size();\n        int row_sum = 0;\n\n        svbool_t pg = svwhilelt_b32(0, n);\n        svint32_t sum_vec = svdup_s32(0);\n\n        for (size_t i = 0; i < n; i += svcntw()) {\n            svint32_t vec = svld1(pg, &row[i]);\n            sum_vec = svadd_s32_m(pg, sum_vec, vec);\n            pg = svwhilelt_b32(i + svcntw(), n);\n        }\n\n        row_sum = svaddv_s32(svptrue_b32(), sum_vec);\n        total_buckets += (row_sum + capacity - 1) / capacity; // Ceiling division\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    const int16_t* data = lst.data();\n    svbool_t pg = svwhilelt_b16(0, n); // Predicate for active elements\n    svint16_t sum_vec = svdup_s16(0); // Initialize sum vector to zero\n    int64_t result = 0;\n\n    for (size_t i = 0; svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        svint16_t vec = svld1(pg, &data[i]); // Load vector\n        svbool_t even_pos_mask = svcmpeq_n_u16(svindex_u16(i, 1), 0); // Mask for even positions\n        svbool_t odd_value_mask = svcmpeq_n_u16(svindex_u16(i, 1), 0); // Mask for odd positions\n        svint16_t odd_values = svand_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0); // Apply mask\n        svadd_n_u16(odd_values_mask, 0);"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    const int16_t* data = lst.data();\n    svbool_t pg = svwhilelt_b16(0, n); // Predicate for active elements\n    svint16_t sum_vec = svdup_s16(0); // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &data[i]); // Load vector of 16-bit integers\n        svbool_t odd_mask = svcmpeq_s16(pg,vec,0); // Mask odd positions\n        svbool_t evensum =svsum+0\n        svadd+0\n    }\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n\n    // Create a pointer to the input data\n    const int16_t* data = lst.data();\n\n    // Initialize SVE vector for accumulating the sum\n    svint64_t sum_vec = svdup_s64(0);\n\n    // Process the array in chunks using SVE\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Create a predicate for the active elements\n        svbool_t pg = svwhilelt_b16(i, n);\n\n        // Load 16-bit integers from the array\n        svint16_t vec = svld1_s16(pg, &data[i]);\n\n        // Create a vector of indices\n        svuint16_t indices = svindex_u16(i, 1);\n\n        // Check if indices are even (position check)\n        svbool_t even_pos_mask = svcmpeq_n_u16(pg, svand_n_u16(indices, 1), 0);\n\n        // Check if elements are odd\n        svbool_t odd_elements_mask = svcmpeq_n_s16(pg, svand_n_s16(vec, 1), 1);\n\n        // Combine masks for odd elements in even positions\n        svbool_t combined_mask = svand_b_z(pg, even_pos_mask, odd_elements_mask);\n\n        // Convert 16-bit integers to 64-bit integers for accumulation\n        svint64_t vec_64 = svcvt_s64_s16_x(combined_mask, vec);\n\n        // Accumulate the sum\n        sum_vec = svadd_m(combined_mask, sum_vec, vec_64);\n    }\n\n    // Horizontally reduce the sum vector to a scalar\n    result = svaddv_s64(svptrue_b64(), sum_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    const int16_t* data = lst.data();\n    int64_t sum = 0;\n\n    svbool_t pg = svwhilelt_b16(0, n); // Predicate for active elements\n    svint16_t index = svindex_s16(0, 1); // Vector of indices starting from 0\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec = svld1_s16(pg, data); // Load vector of elements\n        svbool_t even_pos = svcmpeq_n_s16(pg, svand_n_s16_x(pg, index, 1), 0); // Check even positions\n        svbool_t odd_values = svcmpeq_n_s16(pg, svand_n_s16_x(pg, vec, 1), 1); // Check odd values\n        svbool_t mask = svand_b_z(pg, even_pos, odd_values); // Combine conditions\n\n        svint16_t filtered = svsel_s16(mask, vec, svdup_n_s16(0)); // Select valid elements\n        sum += svaddv_s16(mask, filtered); // Accumulate sum of valid elements\n\n        data += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b16(data - lst.data(), n); // Update predicate\n        index = svadd_n_s16_x(pg, index, svcntw()); // Update index\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n\n    svbool_t pg = svwhilelt_b16(0, n); // Predicate for active elements\n    svint16_t sum = svdup_s16(0);      // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(svptrue_b16(), pg); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &lst[i]); // Load vector elements\n        svbool_t even_pos = svcmpeq_n_s16(pg, svindex_s16(i, 1) & 1, 0); // Mask for even positions\n        svbool_t odd_values = svcmpeq_n_s16(pg, vec & 1, 0); // Mask for odd values\n        svbool_t mask = svand_b16(even_pos, odd_values);\n        sum = svadd_s16(sum, svadd_s16(mask,vec);\n    }\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int n = arr.size();\n    int sum = 0;\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, k); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector elements\n        svbool_t two_digit_mask = svand_b_z(pg, svcmple_n_s32(pg, vec, 99), svcmpge_n_s32(pg,vec, 10)); // mask for two digit range\n        sum+=svadd_s32(pg,vec,0)\n    }\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int n = arr.size();\n    int sum = 0;\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, k); // Predicate for processing up to k elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector of integers\n        svbool_t two_digit_mask = svand_b_z(pg, svcmple_n_s32(pg, vec, 99), svcmpge_n_s32(pg, vec, -99)); // Mask for two-digit numbers\n        svint32_t filtered_vec = svsel(two_digit_mask, vec, svdup_n_s32(0)); // Select two-digit numbers, set others to 0\n        sum += svaddv_s32(pg, filtered_vec); // Accumulate the sum of valid elements\n        i += svcntw(); // Move to the next vector chunk\n        pg = svwhilelt_b32(i, k); // Update predicate for remaining elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = arr.size();\n    int *data = arr.data();\n\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for processing up to k elements\n    svint32_t vec_sum = svdup_s32(0);  // Initialize vector sum to 0\n\n    for (int i = 0; i < k; i += svcntw()) {\n        pg = svwhilelt_b32(i, k); // Update predicate for remaining elements\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector elements\n\n        // Mask elements with more than two digits\n        svbool_t mask = svand_b_z(pg, svcmple_s32(pg, vec, 99), svcmpge_s32(pg, vec, -99));\n        vec = svsel_s32(mask, vec, svdup_s32(0)); // Zero out elements that don't meet the condition\n\n        vec_sum = svadd_s32_m(pg, vec_sum, vec); // Accumulate valid elements\n    }\n\n    sum = svaddv_s32(svptrue_b32(), vec_sum); // Reduce vector sum to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int n = arr.size();\n    int sum = 0;\n\n    // Ensure k does not exceed the array size\n    k = (k > n) ? n : k;\n\n    // Pointer to the input array\n    const int *data = arr.data();\n\n    // Initialize sum vector\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Process elements in chunks of SVE vector length\n    for (int i = 0; i < k; i += svcntw()) {\n        // Determine the active vector length for this iteration\n        svbool_t pg = svwhilelt_b32(i, k);\n\n        // Load elements from the array\n        svint32_t vec = svld1_s32(pg, &data[i]);\n\n        // Mask elements with more than two digits\n        svbool_t mask = svand_b_z(pg, svcmple_s32(pg, vec, 99), svcmpge_s32(pg, vec, -99));\n\n        // Add valid elements to the sum vector\n        sum_vec = svadd_m(mask, sum_vec, vec);\n    }\n\n    // Horizontally reduce the sum vector to a scalar\n    sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = arr.size();\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, k); // Predicate for active elements within bounds\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector of integers\n        svbool_t mask = svcmple_n_s32(pg, vec, 99); // Mask for elements <= 99\n        mask = svorr_b_z(mask, mask, svcmpge_n_s32(pg, vec, 10)); // Mask for elements >= 10\n        svint32_t filtered = svsel(mask, vec, svdup_n_s32(0)); // Select valid elements or 0\n        sum += svaddv_s32(pg, filtered); // Accumulate sum of valid elements\n        i += svcntw(); // Move to next vector chunk\n        pg = svwhilelt_b32(i, k); // Update predicate for next chunk\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n    svbool_t duplicate_found = svpfalse_b();\n\n    while (svptest_any(svptrue_b(), pg)) {\n        svint32_t vec1 = svld1(pg, &data[i]);\n        svint32_t vec2 = svld1(pg, &data[i + 1]);\n\n        svbool_t not_sorted = svcmpgt(pg, vec1, vec2);\n        svbool_t duplicates = svcmpeq(pg, vec1, vec2);\n\n        if (svptest_any(svptrue_b(), not_sorted)) return false;\n\n        duplicate_found = svorr_z(pg, duplicate_found, duplicates);\n        if (svptest_any(svptrue_b(), duplicate_found)) {\n            svbool_t multiple_duplicates = svand_z(pg, duplicate_found, duplicates);\n            if (svptest_any(svptrue_b(), multiple_duplicates)) return false;\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svld1(pg, &data[i]);\n        svint32_t next = svld1(pg, &data[i + 1]);\n\n        svbool_t is_ascending = svcmpge(pg, next, current);\n        svbool_t is_duplicate = svcmpeq(pg, next, current);\n\n        if (!svptest_all(pg, is_ascending) || svptest_any(pg, svcntp_b32(pg, is_duplicate) > 1)) {\n            return false;\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n    svbool_t duplicate_check = svptrue_b32();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svld1(pg, &data[i]);\n        svint32_t next = svld1(pg, &data[i + 1]);\n\n        svbool_t is_sorted = svcmpge(pg, next, current);\n        svbool_t is_duplicate = svcmpeq(pg, current, next);\n\n        if (!svptest_all(pg, is_sorted)) return false;\n\n        duplicate_check = svand_b_z(pg, duplicate_check, svnot_z(pg, is_duplicate));\n        if (!svptest_all(pg, duplicate_check)) return false;\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n - 1); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svld1(pg, &data[i]);          // Load current elements\n        svint32_t next = svld1(pg, &data[i + 1]);         // Load next elements\n        svbool_t is_sorted = svcmpge(pg, next, current);  // Check if next >= current\n        svbool_t is_unique = svcmpne(pg, next, current);  // Check if next != current\n\n        if (!svptest_all(pg, is_sorted)) return false;    // If not sorted, return false\n        if (!svptest_all(pg, is_unique)) return false;    // If not unique, return false\n\n        i += svcntw();                                    // Advance by vector width\n        pg = svwhilelt_b32(i, n - 1);                     // Update predicate\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n    svbool_t duplicates_found = svpfalse_b();\n    svbool_t not_sorted = svpfalse_b();\n\n    while (svptest_any(svptrue_b(), pg)) {\n        svint32_t current = svld1(pg, &data[i]);\n        svint32_t next = svld1(pg, &data[i + 1]);\n\n        svbool_t is_equal = svcmpeq(pg, current, next);\n        svbool_t is_greater = svcmpgt(pg, current, next);\n\n        duplicates_found = svorr_z(pg, duplicates_found, svcntp_b32(pg, is_equal) > 1);\n        not_sorted = svorr_z(pg, not_sorted, is_greater);\n\n        if (svptest_any(svptrue_b(), duplicates_found) || svptest_any(svptrue_b(), not_sorted)) {\n            return false;\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, arr.data());\n\n    // Compute magnitudes\n    svint32_t magnitudes = svabs_s32_x(pg, vec);\n\n    // Compute signs\n    svint32_t signs = svdup_s32(1);\n    svbool_t negative_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n    svbool_t zero_mask = svcmpeq_s32(pg, vec, svdup_s32(0));\n    signs = svsel_s32(negative_mask, svdup_s32(-1), signs);\n    signs = svsel_s32(zero_mask, svdup_s32(0), signs);\n\n    // Reduce magnitudes to sum\n    int sum_magnitudes = svaddv_s32(pg, magnitudes);\n\n    // Reduce signs to product\n    int product_signs = svmulv_s32(pg, signs);\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> &arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_sum = svdup_s32(0);\n    svint32_t vec_sign_product = svdup_s32(1);\n\n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + svcntw() <= size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n\n        svint32_t vec_abs = svabs_s32_x(pg, vec);\n        vec_sum = svadd_s32_m(pg, vec_sum, vec_abs);\n\n        svint32_t vec_sign = svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0)), svdup_s32(-1),\n                                       svsel_s32(svcmpeq_s32(pg, vec, svdup_s32(0)), svdup_s32(0), svdup_s32(1)));\n        vec_sign_product = svmul_s32_m(pg, vec_sign_product, vec_sign);\n    }\n\n    int sum = svaddv_s32(pg, vec_sum);\n    int sign_product = svmulv_s32(pg, vec_sign_product);\n\n    for (; i < size; ++i) {\n        sum += std::abs(arr[i]);\n        sign_product *= (arr[i] > 0) - (arr[i] < 0);\n    }\n\n    return sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> &arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_sum = svdup_s32(0);\n    svint32_t vec_sign_product = svdup_s32(1);\n\n    size_t i = 0;\n    size_t n = arr.size();\n\n    while (i < n) {\n        svbool_t active = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(active, &arr[i]);\n\n        // Compute magnitudes\n        svint32_t vec_abs = svabs_s32_x(active, vec);\n\n        // Compute signs\n        svint32_t vec_sign = svsel_s32(\n            svcmpeq_s32(active, vec, svdup_s32(0)), \n            svdup_s32(0), \n            svsel_s32(\n                svcmplt_s32(active, vec, svdup_s32(0)), \n                svdup_s32(-1), \n                svdup_s32(1)\n            )\n        );\n\n        // Accumulate magnitudes\n        vec_sum = svadd_s32_m(active, vec_sum, vec_abs);\n\n        // Accumulate product of signs\n        vec_sign_product = svmul_s32_m(active, vec_sign_product, vec_sign);\n\n        i += svcntw();\n    }\n\n    // Reduce the sum and product across the vector\n    int sum = svaddv_s32(pg, vec_sum);\n    int sign_product = svmulv_s32(pg, vec_sign_product);\n\n    return sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> &arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_sum = svdup_s32(0);\n    int product_of_signs = 1;\n\n    size_t i = 0;\n    size_t n = arr.size();\n\n    while (i < n) {\n        size_t vl = svcntw();\n        size_t chunk_size = (i + vl <= n) ? vl : (n - i);\n\n        svbool_t active_pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(active_pg, &arr[i]);\n\n        svint32_t abs_vec = svabs_s32_m(active_pg, vec);\n        vec_sum = svadd_s32_m(active_pg, vec_sum, abs_vec);\n\n        svint32_t signs = svsign_s32_m(active_pg, vec);\n        int signs_product = svmulv_s32(active_pg, signs);\n        product_of_signs *= signs_product;\n\n        i += chunk_size;\n    }\n\n    int sum_of_magnitudes = svaddv_s32(pg, vec_sum);\n    return sum_of_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> &arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t vec_sum = svdup_s32(0); // Initialize sum of magnitudes\n    int product_of_signs = 1;\n\n    size_t i = 0;\n    size_t n = arr.size();\n\n    while (i < n) {\n        size_t vl = svcntw(); // Get the vector length\n        size_t remaining = n - i;\n        if (remaining < vl) {\n            pg = svwhilelt_b32(i, n); // Adjust predicate for remaining elements\n        }\n\n        svint32_t vec = svld1_s32(pg, &arr[i]); // Load vector\n        svint32_t abs_vec = svabs_s32_m(pg, vec); // Compute absolute values\n        vec_sum = svadd_s32_m(pg, vec_sum, abs_vec); // Accumulate magnitudes\n\n        svint32_t signs = svsign_s32_m(pg, vec); // Compute signs (-1, 0, 1)\n        svint32_t prod_signs_vec = svdup_s32(product_of_signs); // Broadcast current product_of_signs\n        prod_signs_vec = svmul_s32_m(pg, prod_signs_vec, signs); // Multiply signs\n        product_of_signs = svlastb_s32(pg, prod_signs_vec); // Extract last value (reduction)\n\n        i += vl;\n    }\n\n    int sum_of_magnitudes = svaddv_s32(pg, vec_sum); // Reduce sum of magnitudes\n    return sum_of_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> paths(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sv_k = svdup_n_s32(k);\n    svint32_t sv_N = svdup_n_s32(N);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    for (int step = 2; step <= k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                svint32_t sv_i = svdup_n_s32(i);\n                svint32_t sv_j = svdup_n_s32(j);\n                svint32_t sv_min_val = svdup_n_s32(std::numeric_limits<int>::max());\n                std::vector<int> min_path;\n\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (di == 0 && dj == 0) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t sv_ni = svdup_n_s32(ni);\n                            svint32_t sv_nj = svdup_n_s32(nj);\n                            svint32_t sv_val = svdup_n_s32(dp[ni][nj][step - 1] + grid[i][j]);\n\n                            svbool_t cmp = svcmplt_s32(pg, sv_val, sv_min_val);\n                            sv_min_val = svsel_s32(cmp, sv_val, sv_min_val);\n\n                            if (svlastb_s32(cmp)) {\n                                min_path = paths[ni][nj][step - 1];\n                                min_path.push_back(grid[i][j]);\n                            }\n                        }\n                    }\n                }\n\n                dp[i][j][step] = svlastb_s32(pg, sv_min_val);\n                paths[i][j][step] = min_path;\n            }\n        }\n    }\n\n    std::vector<int> result;\n    svint32_t sv_min_val = svdup_n_s32(std::numeric_limits<int>::max());\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            svint32_t sv_val = svdup_n_s32(dp[i][j][k]);\n            svbool_t cmp = svcmplt_s32(pg, sv_val, sv_min_val);\n            sv_min_val = svsel_s32(cmp, sv_val, sv_min_val);\n\n            if (svlastb_s32(cmp)) {\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> path(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    svbool_t pg = svptrue_b32();\n\n    // Initialize dp for paths of length 1\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Compute dp for paths of length 2 to k\n    for (int len = 2; len <= k; ++len) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                svint32_t min_values = svdup_s32(std::numeric_limits<int>::max());\n                std::vector<int> best_path;\n\n                // Iterate over neighbors\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (std::abs(di) + std::abs(dj) != 1) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t current_values = svdup_s32(dp[ni][nj][len - 1]);\n                            svint32_t grid_value = svdup_s32(grid[i][j]);\n                            svint32_t combined = svadd_s32_x(pg, current_values, grid_value);\n\n                            svbool_t mask = svcmplt_s32(pg, combined, min_values);\n                            min_values = svsel_s32(mask, combined, min_values);\n\n                            if (svptest_any(pg, mask)) {\n                                best_path = path[ni][nj][len - 1];\n                                best_path.push_back(grid[i][j]);\n                            }\n                        }\n                    }\n                }\n\n                dp[i][j][len] = svlastb_s32(pg, min_values);\n                path[i][j][len] = best_path;\n            }\n        }\n    }\n\n    // Find the minimum path of length k\n    std::vector<int> result;\n    svint32_t min_values = svdup_s32(std::numeric_limits<int>::max());\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            svint32_t current_values = svdup_s32(dp[i][j][k]);\n            svbool_t mask = svcmplt_s32(pg, current_values, min_values);\n            min_values = svsel_s32(mask, current_values, min_values);\n\n            if (svptest_any(pg, mask)) {\n                result = path[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> path(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    svbool_t pg = svptrue_b32();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    for (int step = 2; step <= k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                svint32_t min_val = svdup_s32(std::numeric_limits<int>::max());\n                std::vector<int> min_path;\n\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (std::abs(di) + std::abs(dj) != 1) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t current_val = svdup_s32(dp[ni][nj][step - 1]);\n                            svbool_t cmp = svcmplt_s32(pg, current_val, min_val);\n                            min_val = svsel_s32(cmp, current_val, min_val);\n                            if (svptest_any(pg, cmp)) {\n                                min_path = path[ni][nj][step - 1];\n                            }\n                        }\n                    }\n                }\n\n                dp[i][j][step] = svlastb_s32(pg, min_val);\n                min_path.push_back(grid[i][j]);\n                path[i][j][step] = min_path;\n            }\n        }\n    }\n\n    std::vector<int> result;\n    svint32_t min_val = svdup_s32(std::numeric_limits<int>::max());\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            svint32_t current_val = svdup_s32(dp[i][j][k]);\n            svbool_t cmp = svcmplt_s32(pg, current_val, min_val);\n            min_val = svsel_s32(cmp, current_val, min_val);\n            if (svptest_any(pg, cmp)) {\n                result = path[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> path(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sv_k = svdup_s32(k);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    for (int step = 2; step <= k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                svint32_t sv_min = svdup_s32(std::numeric_limits<int>::max());\n                std::vector<int> min_path;\n\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (std::abs(di) + std::abs(dj) != 1) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t sv_value = svdup_s32(dp[ni][nj][step - 1]);\n                            sv_min = svmin_s32(pg, sv_min, sv_value);\n\n                            std::vector<int> candidate_path = path[ni][nj][step - 1];\n                            candidate_path.push_back(grid[i][j]);\n                            if (candidate_path < min_path || min_path.empty()) {\n                                min_path = candidate_path;\n                            }\n                        }\n                    }\n                }\n\n                dp[i][j][step] = svlastb_s32(pg, sv_min);\n                path[i][j][step] = min_path;\n            }\n        }\n    }\n\n    std::vector<int> result;\n    svint32_t sv_min = svdup_s32(std::numeric_limits<int>::max());\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            svint32_t sv_value = svdup_s32(dp[i][j][k]);\n            sv_min = svmin_s32(pg, sv_min, sv_value);\n            if (dp[i][j][k] == svlastb_s32(pg, sv_min)) {\n                result = path[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    int max_val = N * N;\n    std::vector<std::vector<std::vector<std::vector<int>>>> dp(\n        k + 1, std::vector<std::vector<std::vector<int>>>(\n                   N, std::vector<std::vector<int>>(N, std::vector<int>(k, max_val))));\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sv_max_val = svdup_s32(max_val);\n\n    // Initialize dp for k = 1\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[1][i][j][0] = grid[i][j];\n        }\n    }\n\n    // Fill dp for k > 1\n    for (int step = 2; step <= k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                svint32_t min_path = sv_max_val;\n\n                // Check all neighbors\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (std::abs(di) + std::abs(dj) != 1) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t neighbor = svld1(pg, dp[step - 1][ni][nj].data());\n                            min_path = svmin_s32_z(pg, min_path, neighbor);\n                        }\n                    }\n                }\n\n                // Update dp\n                svint32_t current_val = svdup_s32(grid[i][j]);\n                svint32_t updated_path = svadd_s32_z(pg, min_path, current_val);\n                svst1(pg, dp[step][i][j].data(), updated_path);\n            }\n        }\n    }\n\n    // Find the lexicographically smallest path\n    std::vector<int> result(k, max_val);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> candidate(dp[k][i][j].begin(), dp[k][i][j].end());\n            if (candidate < result) {\n                result = candidate;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    uint64_t digits[20]; // Maximum digits in a 64-bit number is 20\n    int count = 0;\n\n    // Extract digits from the number\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize SVE vector\n    svbool_t pg = svwhilelt_b64(0, count);\n    svuint64_t vec_digits = svld1(pg, digits);\n\n    // Mask for odd digits\n    svuint64_t ones = svdup_u64(1);\n    svbool_t odd_mask = svcmpeq(pg, svand_z(pg, vec_digits, ones), ones);\n\n    // Extract odd digits\n    svuint64_t odd_digits = svsel(odd_mask, vec_digits, svdup_u64(1));\n\n    // Compute the product of odd digits\n    uint64_t product = 1;\n    while (svptest_any(pg, odd_mask)) {\n        product *= svlastb(pg, odd_digits);\n        pg = svnextb(pg, pg);\n        odd_digits = svld1(pg, digits);\n        odd_mask = svcmpeq(pg, svand_z(pg, odd_digits, ones), ones);\n    }\n\n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    // Extract digits into an array\n    uint8_t digits[20];\n    int count = 0;\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize SVE variables\n    svbool_t pg = svwhilelt_b8(0, count);\n    svuint8_t vec_digits = svld1(pg, digits);\n    svuint8_t vec_odd_mask = svdup_u8(1); // Mask for odd digits\n\n    // Check for odd digits\n    svuint8_t vec_odd = svand_z(pg, vec_digits, vec_odd_mask);\n    svbool_t odd_pred = svcmpne(pg, vec_odd, svdup_u8(0));\n\n    // Extract odd digits\n    svuint8_t vec_filtered = svcompact(pg, odd_pred, vec_digits);\n\n    // Multiply odd digits\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (svptest_any(pg, odd_pred)) {\n        uint8_t odd_digit = svlastb_u8(pg, vec_filtered);\n        product *= odd_digit;\n        has_odd = true;\n        vec_filtered = svcompact(pg, odd_pred, vec_filtered);\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t digits[20]; // Maximum digits in a 64-bit number\n    int count = 0;\n\n    // Extract digits from the number\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    if (count == 0) {\n        return 0;\n    }\n\n    // Load digits into SVE vector\n    svbool_t pg = svwhilelt_b64(0, count);\n    svuint64_t vec_digits = svld1(pg, digits);\n\n    // Mask for odd digits\n    svuint64_t vec_ones = svdup_u64(1);\n    svbool_t odd_mask = svcmpeq(pg, svand_z(pg, vec_digits, vec_ones), vec_ones);\n\n    // Filter odd digits\n    svuint64_t odd_digits = svsel(odd_mask, vec_digits, svdup_u64(1));\n\n    // Compute the product of odd digits\n    uint64_t product = 1;\n    while (svptest_any(pg, odd_mask)) {\n        product *= svlastb(pg, odd_digits);\n        odd_digits = svext(odd_digits, odd_digits, 1);\n        odd_mask = svext(odd_mask, odd_mask, 1);\n        pg = svwhilelt_b64(0, count--);\n    }\n\n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    uint64_t digits[20]; // Maximum number of digits for a 64-bit integer\n    int count = 0;\n\n    // Extract digits from the number\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, count);\n    svuint64_t vec_digits = svld1(pg, digits);\n\n    // Mask for odd digits\n    svuint64_t odd_mask = svdup_u64(1);\n    svuint64_t odd_digits = svand_z(pg, vec_digits, odd_mask);\n\n    // Check if digits are odd\n    svbool_t odd_pg = svcmpne(pg, odd_digits, svdup_u64(0));\n\n    // Initialize product\n    svuint64_t product = svdup_u64(1);\n\n    // Multiply odd digits\n    product = svmul_z(odd_pg, product, vec_digits);\n\n    // Reduce the product across the vector\n    uint64_t result = svaddv_u64(pg, product);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    bool has_odd = false;\n\n    while (n > 0) {\n        // Extract digits into a vector\n        svbool_t pg = svwhilelt_b64(0, n);\n        svuint64_t digits = svdup_u64_z(pg, n % 10);\n        n /= 10;\n\n        // Check for odd digits\n        svuint64_t odd_mask = svand_z(pg, digits, svdup_u64(1));\n        svbool_t is_odd = svcmpne(pg, odd_mask, svdup_u64(0));\n\n        // Multiply odd digits\n        if (svptest_any(pg, is_odd)) {\n            has_odd = true;\n            svuint64_t odd_digits = svsel(is_odd, digits, svdup_u64(1));\n            result *= svlastb_u64(pg, odd_digits);\n        }\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n\n    // Create a pointer to the input data\n    const float *data = lst.data();\n\n    // Initialize the sum\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n\n    // Process the input vector in chunks of SVE vector length\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Load a vector of floats\n        svfloat32_t vec = svld1(pg, &data[i]);\n\n        // Apply ceiling to each element\n        svfloat32_t ceil_vec = svcvt_f32_s32_z(pg, svcvt_s32_f32_z(pg, vec));\n        ceil_vec = svadd_f32_z(pg, ceil_vec, svdup_f32(1.0f));\n    }\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n\n    // Create a pointer to the input data\n    const float *data = lst.data();\n\n    // Initialize the SVE vector for accumulating the sum of squares\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n\n    // Process the input vector in chunks using SVE\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Load a chunk of data into an SVE vector\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &data[i]);\n\n        // Apply ceiling to each element\n        vec = svcvt_f32_s32_x(pg, svcvt_s32_f32_x(pg, vec + 0.999999f));\n\n        // Square each element\n        vec = svmul_f32_x(pg, vec, vec);\n\n        // Accumulate the squared values\n        vec_sum = svadd_f32_m(pg, vec_sum, vec);\n    }\n\n    // Reduce the accumulated vector to a single scalar value\n    result = svcvt_u64_f32(svaddv_f32(svptrue_b32(), vec_sum));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    const float *data = lst.data();\n    uint64_t result = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svuint64_t sum = svdup_u64(0);     // Initialize sum vector\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &data[i]);         // Load vector elements\n        svfloat32_t ceil_vec = svcvt_f32_s32(svceil_f32(vec)); // Apply ceiling\n        svfloat32_t squared_vec = svmul_f32(ceil_vec, ceil_vec); // Square elements\n        svuint64_t squared_int_vec = svcvt_u64_f32(squared_vec); // Convert to integer\n        sum = svadd_u64_m(pg, sum, squared_int_vec);  // Accumulate sum\n        pg = svwhilelt_b32(i + svcntw(), n);          // Update predicate\n    }\n\n    result = svaddv_u64(svptrue_b64(), sum); // Reduce sum across vector\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svfloat32_t sum_vec = svdup_f32(0.0f); // Initialize sum vector to 0\n\n    for (size_t i = 0; svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &lst[i]); // Load elements into vector\n        svfloat32_t ceil_vec = svcvt_f32_s32_z(pg, svcvt_s32_f32_z(pg, vec)); // Apply ceil\n        svfloat32_t squared_vec = svmul_f32_z(pg, ceil_vec, ceil_vec); // Square elements\n        sum_vec = svadd_f32_m(pg, sum_vec, squared_vec); // Accumulate squared values\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    // Horizontal add to compute the final sum\n    result = svcvt_u64_f32(svaddv_f32(svptrue_b32(), sum_vec));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n\n    // Pointer to the input data\n    const float *data = lst.data();\n\n    // Loop over the input vector in chunks of SVE vector length\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint64_t sum_vec = svdup_u64(0); // Initialize sum vector to zero\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a chunk of the input vector\n        svfloat32_t vec = svld1(pg, &data[i]);\n\n        // Apply ceiling to each element\n        svfloat32_t ceil_vec = svcvt_f32_s32_x(pg, svcvt_s32_f32_x(pg, vec));\n        svbool_t ceil_mask = svcmpeq_f32(pg, ceil_vec, vec);\n        ceil_vec = svsel_f32(ceil_mask, ceil_vec, svadd_f32_x(pg, ceil_vec, svdup_f32(1.0f)));\n\n        // Square each element\n        svfloat32_t squared_vec = svmul_f32_x(pg, ceil_vec, ceil_vec);\n\n        // Convert to integer and accumulate\n        svuint64_t squared_int_vec = svcvt_u64_f32_x(pg, squared_vec);\n        sum_vec = svadd_u64_x(pg, sum_vec, squared_int_vec);\n\n        // Move to the next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    // Reduce the sum vector to a scalar\n    result = svaddv_u64(svptrue_b64(), sum_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t vec_prev = svld1(pg, arr.data());\n    svint32_t vec_next = svld1(pg, arr.data() + 1);\n\n    svbool_t cmp_mask = svcmpge_s32(pg, vec_prev, vec_next);\n    svint32_t result_indices = svcompact_s32(cmp_mask, indices);\n\n    int result = -1;\n    if (!svptest_any(svptrue_b32(), cmp_mask)) {\n        return result;\n    }\n\n    svint32_t last_index = svlastb_s32(svptrue_b32(), result_indices);\n    result = svlasta_s32(svptrue_b32(), last_index);\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t vec_prev = svld1(pg, arr.data());\n    svint32_t vec_next = svld1(pg, arr.data() + 1);\n\n    svbool_t cmp = svcmpge_s32(pg, vec_prev, vec_next);\n    svint32_t result_indices = svcompact_s32(cmp, indices);\n\n    int result = -1;\n    if (!svptest_any(svptrue_b32(), cmp)) {\n        return result;\n    }\n\n    int compacted_indices[svcntw()];\n    svst1(svptrue_b32(), compacted_indices, result_indices);\n\n    for (int i = 0; i < svcntw(); ++i) {\n        if (compacted_indices[i] < n - 1) {\n            result = compacted_indices[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t vec_prev, vec_curr;\n\n    int result = -1;\n\n    for (int i = 0; i < n - 1; i += svcntw()) {\n        pg = svwhilelt_b32(i, n - 1); // Update predicate for active elements\n        vec_prev = svld1(pg, &arr[i]); // Load current vector\n        vec_curr = svld1(pg, &arr[i + 1]); // Load next vector\n\n        svbool_t cmp = svcmpge_s32(pg, vec_prev, vec_curr); // Compare elements\n        svint32_t failing_indices = svadd_s32_m(cmp, svdup_s32(-1), indices, svdup_s32(-1));\n    }\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    size_t n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    int result = -1;\n\n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        size_t remaining = n - 1 - i;\n        svbool_t active = svwhilelt_b32(i, n - 1);\n\n        svint32_t vec1 = svld1_s32(active, &arr[i]);\n        svint32_t vec2 = svld1_s32(active, &arr[i + 1]);\n\n        svbool_t cmp = svcmplt_s32(pg, vec2, vec1);\n\n        if (svptest_any(pg, cmp)) {\n            svuint32_t indices = svindex_u32(i, 1);\n            svuint32_t failing_indices = svcompact_u32(cmp, indices);\n            result = svlastb_u32(pg, failing_indices);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    size_t n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for active elements\n    svint32_t indices = svindex_s32(0, 1); // Vector of indices\n    svint32_t result = svdup_s32(-1);      // Initialize result to -1\n\n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        pg = svwhilelt_b32(i, n - 1); // Update predicate for remaining elements\n\n        svint32_t current = svld1_s32(pg, &arr[i]);       // Load current elements\n        svint32_t next = svld1_s32(pg, &arr[i + 1]);      // Load next elements\n        svbool_t cmp = svcmplt_s32(pg, next, current);    // Compare next < current\n\n        result = svsel_s32(cmp, indices, result);         // Update result where cmp is true\n        indices = svadd_s32_x(pg, indices, svdup_s32(1)); // Increment indices\n    }\n\n    // Reduce to find the largest index\n    int final_result = svmaxv_s32(svwhilelt_b32(0, n - 1), result);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n\n    svbool_t pg = svptrue_b32(); // Predicate for active elements\n    size_t n = lst.size();\n    size_t i = 0;\n\n    while (i < n) {\n        // Load a chunk of data into an SVE vector\n        svbool_t active = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(active, &lst[i]);\n\n        // Mask for negative numbers\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svint32_t neg_values = svsel_s32(neg_mask, vec, svdup_s32(std::numeric_limits<int>::min()));\n        largest_negative = svmaxv_s32(pg, svmax_s32(pg, neg_values, svdup_s32(largest_negative)));\n\n        // Mask for positive numbers\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, 0);\n        svint32_t pos_values = svsel_s32(pos_mask, vec, svdup_s32(std::numeric_limits<int>::max()));\n        smallest_positive = svminv_s32(pg, svmin_s32(pg, pos_values, svdup_s32(smallest_positive)));\n\n        i += svcntw();\n    }\n\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {largest_negative, smallest_positive};\n    }\n\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec = svld1(pg, lst.data());\n\n    svint32_t neg_mask = svdup_s32(std::numeric_limits<int>::min());\n    svint32_t pos_mask = svdup_s32(std::numeric_limits<int>::max());\n\n    svint32_t neg_values = svsel(svcmplt_s32(pg, vec, 0), vec, neg_mask);\n    svint32_t pos_values = svsel(svcmpgt_s32(pg, vec, 0), vec, pos_mask);\n\n    largest_negative = svmaxv_s32(pg, neg_values);\n    smallest_positive = svminv_s32(pg, pos_values);\n\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    size_t n = lst.size();\n    size_t i = 0;\n\n    while (i < n) {\n        svbool_t active = svwhilelt_b32(i, n); // Active lanes for remaining elements\n        svint32_t vec = svld1_s32(active, &lst[i]); // Load vector\n\n        // Find largest negative\n        svbool_t is_negative = svcmplt_s32(pg, vec, 0); // Mask for negative numbers\n        svint32_t negatives = svsel_s32(is_negative, vec, svdup_s32(0)); // Select negatives\n        int max_negative = svmaxv_s32(is_negative, negatives); // Max of negatives\n        if (svptest_any(pg, is_negative)) {\n            largest_negative = std::max(largest_negative, max_negative);\n        }\n\n        // Find smallest positive\n        svbool_t is_positive = svcmpgt_s32(pg, vec, 0); // Mask for positive numbers\n        svint32_t positives = svsel_s32(is_positive, vec, svdup_s32(std::numeric_limits<int>::max())); // Select positives\n        int min_positive = svminv_s32(is_positive, positives); // Min of positives\n        if (svptest_any(pg, is_positive)) {\n            smallest_positive = std::min(smallest_positive, min_positive);\n        }\n\n        i += svcntw(); // Increment by vector width\n    }\n\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec_largest_negative = svdup_n_s32(largest_negative);\n    svint32_t vec_smallest_positive = svdup_n_s32(smallest_positive);\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svint32_t vec = svld1(pg, lst.data() + i);\n\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, 0);\n\n        vec_largest_negative = svsel_s32(neg_mask, svmax_s32_m(neg_mask, vec_largest_negative, vec), vec_largest_negative);\n        vec_smallest_positive = svsel_s32(pos_mask, svmin_s32_m(pos_mask, vec_smallest_positive, vec), vec_smallest_positive);\n\n        pg = svwhilelt_b32(i + svcntw(), lst.size());\n    }\n\n    largest_negative = svmaxv_s32(svptrue_b32(), vec_largest_negative);\n    smallest_positive = svminv_s32(svptrue_b32(), vec_smallest_positive);\n\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    const int* data = lst.data();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t largest_neg_vec = svdup_s32(largest_negative);\n    svint32_t smallest_pos_vec = svdup_s32(smallest_positive);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]);\n\n        svbool_t is_negative = svcmplt_s32(pg, vec, 0);\n        svbool_t is_positive = svcmpgt_s32(pg, vec, 0);\n\n        largest_neg_vec = svsel_s32(is_negative, svmax_s32_z(is_negative, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(is_positive, svmin_s32_z(is_positive, smallest_pos_vec, vec), smallest_pos_vec);\n\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    largest_negative = svmaxv_s32(svptrue_b32(), largest_neg_vec);\n    smallest_positive = svminv_s32(svptrue_b32(), smallest_pos_vec);\n\n    if (largest_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64_t limit = i;\n\n        svbool_t pg = svwhilelt_b64(0, limit);\n        svuint64_t indices = svindex_u64(1, 1);\n\n        while (svptest_any(svptrue_b64(), pg)) {\n            svuint64_t masked_indices = svand_z(pg, indices, indices);\n            svuint64_t partial_factorial = svmul_z(pg, masked_indices, factorial);\n            factorial = svlastb(pg, partial_factorial);\n            indices = svadd_z(pg, indices, svdup_u64(1));\n            pg = svwhilelt_b64(svlastb(pg, indices), limit);\n        }\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n\n    svbool_t pg = svwhilelt_b64(1, n);\n    svuint64_t indices = svindex_u64(1, 1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t factorials = svdup_u64(1);\n        svuint64_t current = svmul_u64_x(pg, indices, svdup_u64(1));\n\n        for (uint64_t i = 2; i <= n; i++) {\n            factorials = svmul_u64_x(pg, factorials, svdup_u64(i));\n        }\n\n        result *= svaddv_u64(pg, factorials);\n        pg = svwhilelt_b64(1, n--);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (uint64_t i = n; i > 0; i--) {\n        uint64_t factorial = 1;\n        uint64_t current = i;\n\n        // Compute factorial of 'current' using SVE\n        while (current > 0) {\n            svuint64_t vec_current = svdup_u64_z(pg, current);\n            svuint64_t vec_factorial = svdup_u64_z(pg, factorial);\n            vec_factorial = svmul_u64_m(pg, vec_factorial, vec_current);\n            factorial = svlastb_u64(pg, vec_factorial);\n            current--;\n        }\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        svbool_t pg = svwhilelt_b64(0, i); // Predicate for active elements\n        svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n\n        while (svptest_any(svptrue_b64(), pg)) {\n            svuint64_t active = svmin_u64_z(pg, indices, svdup_u64(i)); // Clamp indices to i\n            factorial *= svaddv_u64(pg, active); // Sum active elements\n            indices = svadd_u64_x(pg, indices, svdup_u64(svcntd())); // Increment indices\n            pg = svwhilelt_b64(svlastb_u64(pg), i); // Update predicate\n        }\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n\n    svbool_t pg = svwhilelt_b64(1, n);\n    svuint64_t indices = svindex_u64(1, 1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t factorials = svdup_u64(1);\n        svuint64_t current = svand_u64_x(pg, indices, svdup_u64(n));\n\n        for (uint64_t i = 1; i <= n; i++) {\n            factorials = svmul_u64_x(pg, factorials, current);\n        }\n\n        result *= svaddv_u64(pg, factorials);\n    }\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    const int *data = lst.data();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t sum_vec = svdup_s32(0);\n    int index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &data[index]);\n        svint32_t indices = svindex_s32(index, 1);\n\n        svbool_t multiple_of_3 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(3)), svdup_s32(0));\n        svbool_t multiple_of_4 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(4)), svdup_s32(0));\n        svbool_t not_multiple_of_3 = svnot_b_z(pg, multiple_of_3);\n        svbool_t cube_condition = svand_b_z(pg, multiple_of_4, not_multiple_of_3);\n\n        svint32_t squared = svmul_s32_x(multiple_of_3, vec, vec);\n        svint32_t cubed = svmul_s32_x(cube_condition, svmul_s32_x(cube_condition, vec, vec), vec);\n\n        svint32_t modified_vec = svsel_s32(multiple_of_3, squared, vec);\n        modified_vec = svsel_s32(cube_condition, cubed, modified_vec);\n\n        sum_vec = svadd_s32_m(pg, sum_vec, modified_vec);\n\n        index += svcntw();\n        pg = svwhilelt_b32(index, n);\n    }\n\n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    const int *data = lst.data();\n    svint32_t sum_vec = svdup_s32(0); // Initialize sum vector to zero\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector elements\n\n        svint32_t idx_vec = svindex_s32(i, 1); // Generate index vector\n        svbool_t is_multiple_of_3 = svcmpeq_s32(pg, svmod_s32_x(pg, idx_vec, svdup_s32(3)), svdup_s32(0));\n        svbool_t is_multiple_of_4 = svcmpeq_s32(pg, svmod_s32_x(pg, idx_vec, svdup_s32(4)), svdup_s32(0));\n        svbool_t is_multiple_of_4_not_3 = svand_b_z(pg, is_multiple_of_4, svnot_b_z(pg, is_multiple_of_3));\n\n        svint32_t squared = svmul_s32_x(pg, vec, vec); // Square elements\n        svint32_t cubed = svmul_s32_x(pg, squared, vec); // Cube elements\n\n        vec = svsel_s32(is_multiple_of_3, squared, vec); // Apply square for multiples of 3\n        vec = svsel_s32(is_multiple_of_4_not_3, cubed, vec); // Apply cube for multiples of 4 not 3\n\n        sum_vec = svadd_s32_m(pg, sum_vec, vec); // Accumulate results\n    }\n\n    return svaddv_s32(svptrue_b32(), sum_vec); // Reduce sum vector to scalar\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    const int *data = lst.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);  // Initialize sum vector to 0\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1); // Vector of indices\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector from memory\n\n        // Check if index is a multiple of 3\n        svbool_t is_multiple_of_3 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(3)), svdup_s32(0));\n\n        // Check if index is a multiple of 4 and not a multiple of 3\n        svbool_t is_multiple_of_4 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(4)), svdup_s32(0));\n        svbool_t not_multiple_of_3 = svnot_b_z(pg, is_multiple_of_3);\n        svbool_t is_multiple_of_4_only = svand_b_z(pg, is_multiple_of_4, not_multiple_of_3);\n\n        // Square elements where index is a multiple of 3\n        svint32_t squared = svmul_s32_m(is_multiple_of_3, vec, vec);\n\n        // Cube elements where index is a multiple of 4 and not a multiple of 3\n        svint32_t cubed = svmul_s32_m(is_multiple_of_4_only, vec, svmul_s32_x(pg, vec, vec));\n\n        // Combine results\n        svint32_t result = svsel_s32(is_multiple_of_3, squared, vec);\n        result = svsel_s32(is_multiple_of_4_only, cubed, result);\n\n        // Accumulate the sum\n        sum_vec = svadd_s32_m(pg, sum_vec, result);\n\n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Horizontal reduction to compute the final sum\n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    const int *data = lst.data();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t sum_vec = svdup_s32(0);  // Initialize sum vector to 0\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1); // Generate indices\n        svint32_t vec = svld1_s32(pg, &data[i]); // Load vector elements\n\n        svbool_t is_multiple_of_3 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(3)), svdup_s32(0));\n        svbool_t is_multiple_of_4 = svcmpeq_s32(pg, svmod_s32_x(pg, indices, svdup_s32(4)), svdup_s32(0));\n        svbool_t is_not_multiple_of_3 = svnot_b_z(pg, is_multiple_of_3);\n        svbool_t condition_cube = svand_b_z(pg, is_multiple_of_4, is_not_multiple_of_3);\n\n        svint32_t squared = svmul_s32_x(pg, vec, vec); // Square elements\n        svint32_t cubed = svmul_s32_x(pg, squared, vec); // Cube elements\n\n        svint32_t result = svsel_s32(condition_cube, cubed, vec); // Apply cube condition\n        result = svsel_s32(is_multiple_of_3, squared, result);   // Apply square condition\n\n        sum_vec = svadd_s32_m(pg, sum_vec, result); // Accumulate sum\n\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    // Horizontal reduction to compute the final sum\n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    const int *data = lst.data();\n    int sum = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t vec_sum = svdup_s32(0);  // Initialize vector sum to 0\n    int index = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_data = svld1(pg, &data[index]); // Load data into vector\n        svint32_t vec_index = svindex_s32(index, 1); // Create index vector\n\n        // Compute mask for indices that are multiples of 3\n        svbool_t mask_multiple_of_3 = svcmpeq_s32(pg, svmod_s32_x(pg, vec_index, svdup_s32(3)), svdup_s32(0));\n\n        // Compute mask for indices that are multiples of 4 and not multiples of 3\n        svbool_t mask_multiple_of_4 = svcmpeq_s32(pg, svmod_s32_x(pg, vec_index, svdup_s32(4)), svdup_s32(0));\n        mask_multiple_of_4 = svand_b_z(pg, mask_multiple_of_4, svnot_b_z(pg, mask_multiple_of_3));\n\n        // Square entries for indices that are multiples of 3\n        svint32_t squared = svmul_s32_x(mask_multiple_of_3, vec_data, vec_data);\n\n        // Cube entries for indices that are multiples of 4 and not multiples of 3\n        svint32_t cubed = svmul_s32_x(mask_multiple_of_4, vec_data, svmul_s32_x(mask_multiple_of_4, vec_data, vec_data));\n\n        // Combine squared, cubed, and original values\n        svint32_t result = svsel_s32(mask_multiple_of_3, squared, vec_data);\n        result = svsel_s32(mask_multiple_of_4, cubed, result);\n\n        // Accumulate the result\n        vec_sum = svadd_s32_m(pg, vec_sum, result);\n\n        // Update index and predicate for next iteration\n        index += svcntw();\n        pg = svwhilelt_b32(index, n);\n    }\n\n    // Horizontal add to compute the final sum\n    sum = svaddv_s32(svptrue_b32(), vec_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    const int *data = nums.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0);   // Initialize vector count to 0\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec_data = svld1_s32(pg, data + i); // Load vector data\n        svbool_t greater_than_10 = svcmpgt_s32(pg, vec_data, svdup_s32(10)); // Compare > 10\n\n        // Extract first and last digits\n        svint32_t abs_data = svabs_s32_m(pg, vec_data); // Absolute values\n        svint32_t first_digit = svdiv_s32_x(pg, abs_data, svdup_s32(10)); // First digit\n        svint32_t last_digit = svmod_s32_x(pg, abs_data, svdup_s32(10));  // Last digit\n\n        // Check if both digits are odd\n        svbool_t first_odd = svcmpeq_s32(pg, svmod_s32_x(pg, first_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t last_odd = svcmpeq_s32(pg, svmod_s32_x(pg, last_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t odd_digits = svand_b_z(pg, first_odd, last_odd);\n\n        // Combine conditions\n        svbool_t valid_elements = svand_b_z(pg, greater_than_10, odd_digits);\n\n        // Count valid elements\n        vec_count = svadd_s32_m(valid_elements, vec_count, svdup_s32(1));\n\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    // Sum up the vector count\n    count = svaddv_s32(svptrue_b32(), vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t n = nums.size();\n    const int *data = nums.data();\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0); // Initialize count vector to 0\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec_nums = svld1_s32(pg, data + i); // Load vector of numbers\n        svbool_t greater_than_10 = svcmpgt_s32(pg, vec_nums, svdup_s32(10)); // Check nums > 10\n\n        // Extract first and last digits\n        svint32_t abs_nums = svabs_s32_m(pg, vec_nums); // Absolute values\n        svint32_t last_digit = svmod_s32_m(pg, abs_nums, svdup_s32(10)); // Last digit\n        svint32_t first_digit = svdiv_s32_m(pg, abs_nums, svdup_s32(10)); // Remove last digit\n        while (svcmpeq_s32(pg, svmod_s32_m(pg, first_digit, svdup_s32(10)), svdup_s32(0)) == svptrue_b32()) {\n            first_digit = svdiv_s32_m(pg, first_digit, svdup_s32(10)); // Extract first digit\n        }\n\n        // Check if both first and last digits are odd\n        svbool_t first_odd = svcmpeq_s32(pg, svand_s32_m(pg, first_digit, svdup_s32(1)), svdup_s32(1));\n        svbool_t last_odd = svcmpeq_s32(pg, svand_s32_m(pg, last_digit, svdup_s32(1)), svdup_s32(1));\n        svbool_t odd_digits = svand_b_z(pg, first_odd, last_odd);\n\n        // Combine conditions\n        svbool_t valid_elements = svand_b_z(pg, greater_than_10, odd_digits);\n\n        // Count valid elements\n        vec_count = svadd_s32_m(valid_elements, vec_count, svdup_s32(1));\n\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    // Sum up the counts\n    count = svaddv_s32(svptrue_b32(), vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t n = nums.size();\n    const int *data = nums.data();\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0); // Initialize vector count to 0\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec_nums = svld1_s32(pg, &data[i]); // Load vector of numbers\n        svbool_t greater_than_10 = svcmpgt_s32(pg, vec_nums, svdup_s32(10)); // Check nums > 10\n\n        // Extract first digit\n        svint32_t abs_nums = svabs_s32_m(pg, vec_nums); // Absolute values\n        svint32_t first_digit = abs_nums;\n        while (svptest_any(pg, svcmpge_s32(pg, first_digit, svdup_s32(10)))) {\n            first_digit = svdiv_s32_z(pg, first_digit, svdup_s32(10));\n        }\n\n        // Extract last digit\n        svint32_t last_digit = svmod_s32_z(pg, abs_nums, svdup_s32(10));\n\n        // Check if both first and last digits are odd\n        svbool_t first_odd = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t last_odd = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t both_odd = svand_b_z(pg, first_odd, last_odd);\n\n        // Combine all conditions\n        svbool_t valid = svand_b_z(pg, greater_than_10, both_odd);\n\n        // Count valid elements\n        vec_count = svadd_s32_m(valid, vec_count, svdup_s32(1));\n\n        pg = svwhilelt_b32(i + svcntw(), n); // Update predicate for next iteration\n    }\n\n    // Sum up the vector count\n    count = svaddv_s32(svptrue_b32(), vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t size = nums.size();\n    const int *data = nums.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svint32_t vec_count = svdup_s32(0);   // Initialize vector count to 0\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t vec_nums = svld1(pg, &data[i]); // Load vector of numbers\n        svbool_t greater_than_10 = svcmpgt_s32(vec_nums, svdup_s32(10)); // Compare > 10\n\n        // Extract first and last digits\n        svint32_t abs_nums = svabs_s32_x(pg, vec_nums); // Absolute values\n        svint32_t last_digit = svmod_s32_x(pg, abs_nums, svdup_s32(10)); // Last digit\n        svint32_t first_digit = svdup_s32(0);\n\n        svbool_t nonzero_pg = svcmpne_s32(abs_nums, svdup_s32(0)); // Non-zero predicate\n        while (svptest_any(svptrue_b32(), nonzero_pg)) {\n            abs_nums = svdiv_s32_x(nonzero_pg, abs_nums, svdup_s32(10)); // Divide by 10\n            svbool_t is_single_digit = svcmpeq_s32(abs_nums, svdup_s32(0)); // Check if single digit\n            first_digit = svsel_s32(is_single_digit, last_digit, abs_nums); // Select first digit\n            nonzero_pg = svcmpne_s32(abs_nums, svdup_s32(0)); // Update predicate\n        }\n\n        // Check if both digits are odd\n        svbool_t first_digit_odd = svcmpeq_s32(svmod_s32_x(pg, first_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t last_digit_odd = svcmpeq_s32(svmod_s32_x(pg, last_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t both_digits_odd = svand_b_z(pg, first_digit_odd, last_digit_odd);\n\n        // Combine conditions\n        svbool_t valid_elements = svand_b_z(pg, greater_than_10, both_digits_odd);\n\n        // Count valid elements\n        vec_count = svadd_s32_m(valid_elements, vec_count, svdup_s32(1));\n\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    // Reduce vector count to scalar\n    count = svaddv_s32(svptrue_b32(), vec_count);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t n = nums.size();\n    size_t i = 0;\n\n    // Process the input vector in chunks using SVE\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n        svint32_t vec = svld1_s32(pg, nums.data() + i); // Load a chunk of the input vector\n\n        // Check if elements are greater than 10\n        svbool_t greater_than_10 = svcmpgt_s32(pg, vec, svdup_s32(10));\n\n        // Get the absolute values of the elements\n        svint32_t abs_vec = svabs_s32_m(greater_than_10, vec);\n\n        // Extract the last digit of each number\n        svint32_t last_digit = svmod_s32_x(greater_than_10, abs_vec, svdup_s32(10));\n\n        // Extract the first digit of each number\n        svint32_t first_digit = abs_vec;\n        while (true) {\n            svbool_t more_than_9 = svcmpgt_s32(pg, first_digit, svdup_s32(9));\n            if (!svptest_any(pg, more_than_9)) break;\n            first_digit = svdiv_s32_x(more_than_9, first_digit, svdup_s32(10));\n        }\n\n        // Check if both first and last digits are odd\n        svint32_t odd_mask = svdup_s32(1);\n        svbool_t first_odd = svcmpeq_s32(pg, svand_s32_x(pg, first_digit, odd_mask), odd_mask);\n        svbool_t last_odd = svcmpeq_s32(pg, svand_s32_x(pg, last_digit, odd_mask), odd_mask);\n        svbool_t both_odd = svand_b_z(pg, first_odd, last_odd);\n\n        // Combine all conditions\n        svbool_t valid = svand_b_z(pg, greater_than_10, both_odd);\n\n        // Count the number of valid elements\n        count += svcntp_b32(pg, valid);\n\n        i += svcntw(); // Move to the next chunk\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    // Allocate memory for the array\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Compute the values of the array using SVE intrinsics\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1); // Start from 1, increment by 1\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t values = svmul_u64_x(pg, indices, indices); // i * i\n        values = svsub_u64_x(pg, values, indices);            // i * i - i\n        values = svadd_u64_x(pg, values, svdup_u64(1));       // i * i - i + 1\n        svst1_u64(pg, a + svcntp_b64(pg, svptrue_b64()), values);\n        indices = svadd_u64_x(pg, indices, svdup_u64(svcntd_u64())); // Increment indices\n        pg = svwhilelt_b64(svcntp_b64(pg, svptrue_b64()), n);\n    }\n\n    // Count triples where the sum is a multiple of 3\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n; i++) {\n        for (uint64_t j = i + 1; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Step 1: Create the vector `a` using SVE intrinsics\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Indices starting from 1\n    svuint64_t a = svmad_u64_z(pg, indices, indices, svdup_u64(1)); // a[i] = i * i - i + 1\n    a = svsub_u64_m(pg, a, indices);\n\n    // Step 2: Count remainders mod 3\n    uint64_t count_mod[3] = {0, 0, 0};\n    svuint64_t mod3 = svmod_u64_z(pg, a, svdup_u64(3)); // a[i] % 3\n    while (svptest_any(pg, pg)) {\n        svuint64_t active_mod3 = svcompact_u64(pg, mod3);\n        uint64_t temp[svcntd()];\n        svst1_u64(pg, temp, active_mod3);\n        for (int i = 0; i < svcntd(); i++) {\n            count_mod[temp[i]]++;\n        }\n        pg = svwhilelt_b64(svlastb_u64(pg, indices) + 1, n);\n    }\n\n    // Step 3: Calculate the number of valid triples\n    uint64_t result = 0;\n    result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6; // All 0 mod 3\n    result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6; // All 1 mod 3\n    result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6; // All 2 mod 3\n    result += count_mod[0] * count_mod[1] * count_mod[2]; // One of each mod 3\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    // Step 1: Create the vector `a` using SVE intrinsics\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Indices starting from 1\n    svuint64_t a = svmul_u64_x(pg, indices, indices); // i * i\n    a = svsub_u64_x(pg, a, indices); // i * i - i\n    a = svadd_u64_x(pg, a, svdup_u64(1)); // i * i - i + 1\n\n    // Step 2: Count remainders modulo 3\n    uint64_t count_mod[3] = {0, 0, 0};\n    svuint64_t mod3 = svmod_u64_x(pg, a, svdup_u64(3)); // a[i] % 3\n    while (svptest_any(pg, pg)) {\n        svuint64_t mod3_active = svcompact_u64(pg, mod3);\n        uint64_t temp[svcntd()];\n        svst1_u64(pg, temp, mod3_active);\n        for (int i = 0; i < svcntd() && i < n; i++) {\n            count_mod[temp[i]]++;\n        }\n        n -= svcntd();\n        pg = svwhilelt_b64(svcntd(), n);\n    }\n\n    // Step 3: Calculate the number of valid triples\n    uint64_t c0 = count_mod[0], c1 = count_mod[1], c2 = count_mod[2];\n    uint64_t result = 0;\n\n    // Case 1: All three numbers are divisible by 3\n    if (c0 >= 3) result += (c0 * (c0 - 1) * (c0 - 2)) / 6;\n\n    // Case 2: One number from each remainder group\n    result += c0 * c1 * c2;\n\n    // Case 3: All three numbers have the same remainder (1 or 2)\n    if (c1 >= 3) result += (c1 * (c1 - 1) * (c1 - 2)) / 6;\n    if (c2 >= 3) result += (c2 * (c2 - 1) * (c2 - 2)) / 6;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Step 1: Generate the vector a\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1); // Generate indices [1, 2, 3, ..., n]\n    svuint64_t a = svmad_u64_z(pg, indices, indices, 1); // a[i] = i * i - i + 1\n\n    // Step 2: Compute a[i] % 3 for all elements in a\n    svuint64_t mod3 = svmod_u64_z(pg, a, svdup_u64(3));\n\n    // Step 3: Count occurrences of each residue mod 3\n    uint64_t counts[3] = {0, 0, 0};\n    while (svptest_any(pg, pg)) {\n        svuint64_t mod3_chunk = svcompact_u64(pg, mod3);\n        for (int i = 0; i < svcntd(); i++) {\n            uint64_t value = svlastb_u64(pg, mod3_chunk);\n            counts[value]++;\n            mod3_chunk = svext_u64(mod3_chunk, mod3_chunk, 1);\n        }\n        pg = svwhilelt_b64(svlastb_u64(pg, indices) + 1, n);\n        indices = svadd_u64_z(pg, indices, svdup_u64(svcntd()));\n        a = svmad_u64_z(pg, indices, indices, 1);\n        mod3 = svmod_u64_z(pg, a, svdup_u64(3));\n    }\n\n    // Step 4: Calculate the number of valid triples\n    uint64_t count0 = counts[0];\n    uint64_t count1 = counts[1];\n    uint64_t count2 = counts[2];\n\n    uint64_t result = 0;\n    // Case 1: All three residues are 0\n    if (count0 >= 3) {\n        result += (count0 * (count0 - 1) * (count0 - 2)) / 6;\n    }\n    // Case 2: All three residues are 1\n    if (count1 >= 3) {\n        result += (count1 * (count1 - 1) * (count1 - 2)) / 6;\n    }\n    // Case 3: All three residues are 2\n    if (count2 >= 3) {\n        result += (count2 * (count2 - 1) * (count2 - 2)) / 6;\n    }\n    // Case 4: One residue from each group (0, 1, 2)\n    result += count0 * count1 * count2;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Step 1: Generate the vector a\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    svuint64_t indices = svindex_u64(1, 1); // Indices from 1 to n\n    svuint64_t a = svmad_u64_z(pg, indices, indices, svdup_u64(1)); // a[i] = i * i - i + 1\n    a = svsub_u64_m(pg, a, indices); // Subtract i from the result\n\n    // Step 2: Count remainders mod 3\n    svuint64_t mod3 = svdup_u64(3);\n    svuint64_t remainders = svmod_u64_z(pg, a, mod3); // Compute a[i] % 3\n    uint64_t count[3] = {0, 0, 0}; // Count of remainders 0, 1, 2\n    while (svptest_any(pg, pg)) {\n        svuint64_t rem = svand_u64_z(pg, remainders, svdup_u64(3)); // Extract active remainders\n        svbool_t is_zero = svcmpeq_u64(pg, rem, svdup_u64(0));\n        svbool_t is_one = svcmpeq_u64(pg, rem, svdup_u64(1));\n        svbool_t is_two = svcmpeq_u64(pg, rem, svdup_u64(2));\n        count[0] += svcntp_b64(pg, is_zero);\n        count[1] += svcntp_b64(pg, is_one);\n        count[2] += svcntp_b64(pg, is_two);\n        pg = svwhilelt_b64(svlastb_u64(pg, indices), n); // Update predicate for next iteration\n    }\n\n    // Step 3: Calculate the number of valid triples\n    uint64_t c0 = count[0], c1 = count[1], c2 = count[2];\n    uint64_t result = 0;\n\n    // Triples of type (0, 0, 0)\n    if (c0 >= 3) result += (c0 * (c0 - 1) * (c0 - 2)) / 6;\n\n    // Triples of type (1, 1, 1)\n    if (c1 >= 3) result += (c1 * (c1 - 1) * (c1 - 2)) / 6;\n\n    // Triples of type (2, 2, 2)\n    if (c2 >= 3) result += (c2 * (c2 - 1) * (c2 - 2)) / 6;\n\n    // Triples of type (0, 1, 2)\n    result += c0 * c1 * c2;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is a prime number using SVE intrinsics\n    if (n < 2) {\n        return y;\n    }\n\n    svbool_t pg = svptrue_b32(); // Create a predicate for active lanes\n    svint32_t vec_n = svdup_n_s32(n); // Duplicate n across vector lanes\n    svint32_t vec_i = svindex_s32(2, 1); // Create a vector of integers starting from 2\n    svint32_t vec_zero = svdup_n_s32(0); // Vector of zeros\n\n    // Check divisibility for all numbers from 2 to sqrt(n)\n    int sqrt_n = (int)__builtin_sqrt(n);\n    for (int i = 2; i <= sqrt_n; i += svcntw()) {\n        svint32_t vec_i = svindex_s32(i, 1); // Create a vector of integers starting from i\n        svint32_t vec_mod = svmod_s32_x(pg, vec_n, vec_i); // Compute n % i for all lanes\n        svbool_t is_divisible = svcmpeq_s32(pg, vec_mod, vec_zero); // Check if n % i == 0\n        if (svptest_any(pg, is_divisible)) {\n            return y; // n is not prime\n        }\n    }\n\n    return x; // n is prime\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n < 2) {\n        return y;\n    }\n\n    // Determine the vector length for SVE\n    svbool_t pg = svptrue_b32();\n    int sqrt_n = (int)sqrt(n);\n\n    // Create a vector of indices from 2 to sqrt(n)\n    svint32_t indices = svindex_s32(2, 1);\n\n    // Mask to limit indices to sqrt(n)\n    svbool_t mask = svwhilelt_b32_s32(2, sqrt_n + 1);\n\n    // Check divisibility in parallel\n    svint32_t n_vec = svdup_s32(n);\n    svint32_t mod_results = svmod_s32_x(pg, n_vec, indices);\n    svbool_t is_divisible = svcmpeq_s32(pg, mod_results, svdup_s32(0));\n\n    // Reduce the mask to check if any divisor exists\n    bool has_divisor = svptest_any(mask, is_divisible);\n\n    return has_divisor ? y : x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n < 2) {\n        return y;\n    }\n\n    int is_prime = 1;\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_n = svdup_s32(n);\n    svint32_t vec_i = svindex_s32(2, 1);\n    svint32_t vec_zero = svdup_s32(0);\n\n    while (svptest_any(pg, svcmplt_s32(pg, vec_i, vec_n))) {\n        svint32_t vec_mod = svmod_s32_x(pg, vec_n, vec_i);\n        svbool_t is_zero = svcmpeq_s32(pg, vec_mod, vec_zero);\n\n        if (svptest_any(pg, is_zero)) {\n            is_prime = 0;\n            break;\n        }\n\n        vec_i = svadd_s32_x(pg, vec_i, svdup_s32(1));\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is a prime number using SVE intrinsics\n    if (n < 2) {\n        return y;\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t vec_n = svdup_n_s32(n); // Broadcast n to all lanes\n    svint32_t vec_i = svindex_s32(2, 1); // Generate indices starting from 2\n    svint32_t vec_zero = svdup_n_s32(0); // Vector of zeros\n\n    // Perform modulo operation in parallel\n    svint32_t vec_mod = svmod_s32_x(pg, vec_n, vec_i);\n\n    // Check for divisors (modulo result == 0)\n    svbool_t is_divisor = svcmpeq_s32(pg, vec_mod, vec_zero);\n\n    // Reduce the result to check if any divisor exists\n    bool has_divisor = svptest_any(pg, is_divisor);\n\n    // Return x if no divisors are found (prime), otherwise return y\n    return has_divisor ? y : x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is a prime number using SVE intrinsics\n    if (n < 2) {\n        return y; // Not a prime number\n    }\n\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n    svint32_t vec_n = svdup_n_s32(n); // Broadcast n across vector lanes\n    svint32_t vec_i = svindex_s32(2, 1); // Generate indices starting from 2\n    svint32_t vec_zero = svdup_n_s32(0); // Vector of zeros\n\n    // Perform modulo operation in parallel\n    svint32_t vec_mod = svmod_s32_x(pg, vec_n, vec_i);\n\n    // Check for divisors in parallel\n    svbool_t is_divisor = svcmpeq_s32(pg, vec_mod, vec_zero);\n\n    // Reduce the result to check if any divisor exists\n    bool has_divisor = svptest_any(pg, is_divisor);\n\n    // Return x if n is prime, otherwise return y\n    return has_divisor ? y : x;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    uint64_t result = 0;\n\n    if (lst.empty()) {\n        return result;\n    }\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load elements into SVE vector\n        svfloat32_t vec = svld1(pg, &lst[i]);\n\n        // Convert to integers (truncate towards zero)\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n\n        // Check if integers are odd and positive\n        svbool_t is_positive = svcmpgt(pg, int_vec, 0);\n        svbool_t is_odd = svcmpeq(pg, svand_x(pg, int_vec, 1), 1);\n        svbool_t valid = svand_b_z(pg, is_positive, is_odd);\n\n        // Square the valid integers\n        svint32_t valid_ints = svsel(valid, int_vec, svdup_s32(0));\n        svint32_t squared = svmul_x(pg, valid_ints, valid_ints);\n\n        // Accumulate the results\n        result += svaddv(pg, squared);\n\n        // Move to the next chunk\n        i += svcntw();\n        pg = svwhilelt_b64(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t result = 0;\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat32_t vec = svld1(pg, lst.data() + index); // Load vector\n        svbool_t is_integer = svcmpeq(pg, svtrn1(svcvt_s32_f32_x(pg, vec), vec), vec); // Check if integer\n        svbool_t is_positive = svcmpgt(pg, vec, svdup_f32(0.0f)); // Check if positive\n        svbool_t is_odd = svcmpeq(pg, svand_x(pg, svcvt_s32_f32_x(pg, vec), svdup_s32(1)), svdup_s32(1)); // Check if odd\n\n        svbool_t valid_mask = svand_b_z(pg, svand_b_z(pg, is_integer, is_positive), is_odd); // Combine conditions\n        svfloat32_t valid_vec = svsel(valid_mask, vec, svdup_f32(0.0f)); // Select valid elements\n\n        svfloat32_t squares = svmul_x(pg, valid_vec, valid_vec); // Square valid elements\n        result += svaddv(pg, squares); // Accumulate sum of squares\n\n        index += svcntw(); // Move to next chunk\n        pg = svwhilelt_b64(index, n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    uint64_t result = 0;\n\n    if (lst.empty()) {\n        return result;\n    }\n\n    size_t size = lst.size();\n    const float *data = lst.data();\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active elements\n    svuint64_t sum = svdup_u64(0);        // Initialize sum to zero\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &data[i]); // Load vector of floats\n        svbool_t is_positive = svcmpgt_f32(pg, vec, svdup_f32(0)); // Check positive\n        svbool_t is_integer = svcmpeq_f32(pg, vec, svtrn1_f32(vec, vec)); // Check integer\n        svbool_t valid = svand_b_z(pg, is_positive, is_integer); // Combine conditions\n\n        svuint32_t int_vec = svcvt_u32_f32_z(valid, vec); // Convert to integer\n        svbool_t is_odd = svcmpeq_u32(pg, svand_u32_z(valid, int_vec, svdup_u32(1)), svdup_u32(1)); // Check odd\n\n        svuint32_t odd_ints = svsel_u32(is_odd, int_vec, svdup_u32(0)); // Select odd integers\n        svuint32_t squares = svmul_u32_z(is_odd, odd_ints, odd_ints); // Compute squares\n        sum = svadd_u64_m(pg, sum, svaddv_u64(pg, svcvt_u64_u32_z(pg, squares))); // Accumulate sum\n        pg = svwhilelt_b32(i + svcntw(), size); // Update predicate for next iteration\n    }\n\n    result = svaddv_u64(svptrue_b64(), sum); // Reduce sum across vector\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    size_t index = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Load a chunk of data\n        svfloat32_t vec = svld1(pg, &lst[index]);\n\n        // Convert to integers and check if the numbers are odd\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t is_odd = svcmpeq(pg, svand_x(pg, int_vec, 1), 1);\n\n        // Check if the numbers are positive\n        svbool_t is_positive = svcmpge(pg, int_vec, 0);\n\n        // Combine predicates for odd and positive numbers\n        svbool_t valid = svand_b_z(pg, is_odd, is_positive);\n\n        // Square the valid integers\n        svint32_t squared = svmul_x(valid, int_vec, int_vec);\n\n        // Accumulate the sum of squares\n        result += svaddv_u64(svptrue_b64(), svcvt_u64_s32_z(valid, squared));\n\n        // Update the predicate and index for the next chunk\n        index += svcntw();\n        pg = svwhilelt_b64(index, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active elements\n    svuint64_t sum_vec = svdup_u64(0); // Vector to accumulate results\n\n    for (size_t i = 0; svptest_any(svptrue_b64(), pg); i += svcntd()) {\n        svfloat32_t vec = svld1(pg, &lst[i]); // Load vector elements\n        svbool_t is_int = svcmpeq_f32(pg, vec, svtrn1_f32(vec, vec)); // Check if elements are integers\n        svbool_t is_positive = svcmpge_f32(pg, vec, svdup_f32(0)); // Check if elements are positive\n        svbool_t is_odd = svcmpeq_u32(pg, svand_u32(svreinterpret_u32_f32(vec), svdup_u32(1)), svdup_u32(1)); // Check if elements are odd\n\n        svbool_t valid_mask = svand_b_z(pg, is_int, svand_b_z(pg, is_positive, is_odd)); // Combine masks\n        svfloat32_t valid_elements = svsel_f32(valid_mask, vec, svdup_f32(0)); // Select valid elements\n        svfloat32_t squared = svmul_f32_x(pg, valid_elements, valid_elements); // Square valid elements\n        svuint64_t squared_int = svreinterpret_u64_f32(squared); // Convert to integer\n        sum_vec = svadd_u64_m(pg, sum_vec, squared_int); // Accumulate results\n\n        pg = svwhilelt_b64(i + svcntd(), n); // Update predicate for next iteration\n    }\n\n    sum = svaddv_u64(svptrue_b64(), sum_vec); // Reduce vector to scalar\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Ensure both vectors are of the same size\n    if (game.size() != guess.size()) {\n        throw std::invalid_argument(\"Vectors must be of the same size\");\n    }\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load game and guess vectors into SVE registers\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Compute absolute difference\n        svint32_t diff_vec = svabs_s32_x(pg, svsub_s32_x(pg, game_vec, guess_vec));\n\n        // Store the result back into the result vector\n        svst1(pg, &result[i], diff_vec);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Compute absolute difference\n        svint32_t diff = svabs_s32_m(pg, svsub_s32_m(pg, game_vec, guess_vec));\n\n        // Store results\n        svst1(pg, &result[i], diff);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    const int* game_ptr = game.data();\n    const int* guess_ptr = guess.data();\n    int* result_ptr = result.data();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1(pg, game_ptr + i);\n        svint32_t guess_vec = svld1(pg, guess_ptr + i);\n\n        svint32_t diff_vec = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32_x(pg, diff_vec);\n\n        svbool_t eq_mask = svcmpeq_s32(pg, game_vec, guess_vec);\n        svint32_t result_vec = svsel_s32(eq_mask, svdup_s32(0), abs_diff_vec);\n\n        svst1(pg, result_ptr + i, result_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Ensure the vectors are of the same size\n    if (game.size() != guess.size()) {\n        return result; // Return empty or incorrect size vector\n    }\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate to handle vectorized loop\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load game and guess vectors into SVE registers\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Compute the absolute difference\n        svint32_t diff_vec = svabs_s32_x(pg, svsub_s32_x(pg, game_vec, guess_vec));\n\n        // Store the result back to the result vector\n        svst1(pg, &result[i], diff_vec);\n\n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active elements\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load game and guess vectors\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Compute absolute difference\n        svint32_t diff = svabs_s32_x(pg, svsub_s32_x(pg, game_vec, guess_vec));\n\n        // Store the result\n        svst1(pg, &result[i], diff);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}

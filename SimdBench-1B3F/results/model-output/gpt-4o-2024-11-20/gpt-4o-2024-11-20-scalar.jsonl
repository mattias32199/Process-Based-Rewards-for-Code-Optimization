{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        dst[r] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        dst[r] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        dst[r] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        dst[r] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_index = r * cols + stride;\n        dst[r] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Perform the gather operation\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Perform the scatter operation\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from `src` to `dst` using `indices` as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from `src` to `dst` using `indices` as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset of the slice in the flattened 1D array\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the elements of the slice into the output array\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t tensor_index = slice_offset + i * dim2 + j;\n            size_t slice_index = i * dim2 + j;\n            slice[slice_index] = tensor[tensor_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset of the slice in the flattened 1D array\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the elements of the slice into the output 2D slice array\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t tensor_index = slice_offset + i * dim2 + j;\n            size_t slice_index = i * dim2 + j;\n            slice[slice_index] = tensor[tensor_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    if (slice_idx >= dim3) {\n        return; // Invalid slice index, do nothing\n    }\n\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    if (slice_idx >= dim3) {\n        return; // Invalid slice index, do nothing\n    }\n\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    if (slice_idx >= dim3) {\n        return; // Invalid slice index, do nothing\n    }\n\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t row_end = (row_block + block_size > rows) ? rows : row_block + block_size;\n            size_t col_end = (col_block + block_size > cols) ? cols : col_block + block_size;\n\n            for (size_t i = row_block; i < row_end; ++i) {\n                for (size_t j = col_block; j < col_end; ++j) {\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = (i + block_size > rows) ? rows : i + block_size;\n            size_t block_col_end = (j + block_size > cols) ? cols : j + block_size;\n\n            for (size_t bi = i; bi < block_row_end; ++bi) {\n                for (size_t bj = j; bj < block_col_end; ++bj) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t block_col_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < block_row_end; ++bi) {\n                for (size_t bj = j; bj < block_col_end; ++bj) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_row_end = (i + block_size > rows) ? rows : i + block_size;\n            size_t block_col_end = (j + block_size > cols) ? cols : j + block_size;\n\n            for (size_t bi = i; bi < block_row_end; ++bi) {\n                for (size_t bj = j; bj < block_col_end; ++bj) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            size_t row_end = (row_block + block_size > rows) ? rows : row_block + block_size;\n            size_t col_end = (col_block + block_size > cols) ? cols : col_block + block_size;\n\n            for (size_t i = row_block; i < row_end; ++i) {\n                for (size_t j = col_block; j < col_end; ++j) {\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\n#include <stddef.h>\n\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\n#include <stddef.h>\n\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\n#include <stddef.h>\n\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\n#include <stddef.h>\n\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\n#include <stddef.h>\n\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i; // Calculate the index for diagonal elements\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            if (src[index] > threshold) {\n                dst[index] = src[index] * scale;\n            } else {\n                dst[index] = src[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            if (src[index] > threshold) {\n                dst[index] = src[index] * scale;\n            } else {\n                dst[index] = src[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            if (src[index] > threshold) {\n                dst[index] = src[index] * scale;\n            } else {\n                dst[index] = src[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stddef.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i]; // Get the source row index from the indices array\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_index * cols + j]; // Copy the row from src to dst\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stddef.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i]; // Get the source row index from the indices array\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_index * cols + j]; // Copy the row from src to dst\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stddef.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stddef.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stddef.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i] + scalar) / 2);\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i] + scalar) / 2);\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i] + scalar) / 2);\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i] + scalar) / 2);\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n            found_even = 1;\n        }\n    }\n\n    return found_even ? min_value : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n            found_even = 1;\n        }\n    }\n\n    return found_even ? min_value : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n            found_even = 1;\n        }\n    }\n\n    return found_even ? min_value : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n            found_even = 1;\n        }\n    }\n\n    return found_even ? min_value : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            found_even = 1;\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n        }\n    }\n\n    return found_even ? min_value : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n\n        // Logical right shift\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n\n        // Sum of arithmetic and logical shifts\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift; // Arithmetic right shift\n        int logical_shift = (int)((uint32_t)src[i] >> shift); // Logical right shift\n        dst[i] = arithmetic_shift + logical_shift; // Add results and store in destination\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n        \n        // Logical right shift\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        \n        // Add the results and store in the destination array\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift; // Arithmetic right shift\n        int logical_shift = (int)((uint32_t)src[i] >> shift); // Logical right shift\n        dst[i] = arithmetic_shift + logical_shift; // Sum of both shifts\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift; // Arithmetic right shift\n        int logical_shift = (int)((uint32_t)src[i] >> shift); // Logical right shift\n        dst[i] = arithmetic_shift + logical_shift; // Add results and store in destination\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1; // Add the least significant bit\n            value >>= 1;        // Shift right by 1 bit\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize the destination matrix C to zero\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Perform matrix multiplication with range filtering\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize the destination matrix C to zero\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Perform matrix multiplication with range filtering\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize the destination matrix C to zero\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Perform matrix multiplication with range filtering\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize the destination matrix C to zero\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Perform matrix multiplication with range filtering\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize the destination matrix C to zero\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Perform matrix multiplication with range filtering\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        // Calculate L^2 norm for the current row\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        // Normalize each element in the row\n        for (size_t j = 0; j < n; j++) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        // Calculate the L^2 norm of the current row\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        // Normalize each element in the row\n        for (size_t j = 0; j < n; j++) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float l2_norm = 0.0f;\n\n        // Calculate L^2 norm for the current row\n        for (size_t j = 0; j < n; j++) {\n            l2_norm += mat[i * n + j] * mat[i * n + j];\n        }\n        l2_norm = sqrtf(l2_norm);\n\n        // Normalize the current row\n        for (size_t j = 0; j < n; j++) {\n            mat[i * n + j] /= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n\n        // Calculate the L^2 norm for the current row\n        for (size_t j = 0; j < n; ++j) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n\n        // Normalize each element in the row\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float l2_norm = 0.0f;\n\n        // Calculate the L^2 norm for the current row\n        for (size_t j = 0; j < n; j++) {\n            float value = mat[i * n + j];\n            l2_norm += value * value;\n        }\n        l2_norm = sqrtf(l2_norm);\n\n        // Normalize the current row\n        for (size_t j = 0; j < n; j++) {\n            mat[i * n + j] /= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            // Transpose the element\n            float value = src[i * cols + j];\n            \n            // Round to the nearest quarter (0.25)\n            value = roundf(value * 4.0f) / 4.0f;\n            \n            // Store in the transposed position\n            dst[j * rows + i] = value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Transpose the element\n            float value = src[r * cols + c];\n            \n            // Round to the nearest quarter (0.25)\n            value = roundf(value * 4.0f) / 4.0f;\n            \n            // Store in the transposed position\n            dst[c * rows + r] = value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            // Transpose the element\n            float value = src[i * cols + j];\n            \n            // Round to the nearest quarter (0.25)\n            value = roundf(value * 4.0f) / 4.0f;\n            \n            // Store in the transposed position\n            dst[j * rows + i] = value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            // Transpose the matrix and round to the nearest quarter\n            float value = src[i * cols + j];\n            float rounded_value = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            // Transpose the matrix and round to the nearest quarter\n            float value = src[i * cols + j];\n            float rounded_value = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0) ? floor(result) : ceil(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <stddef.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        dst[i] = truncf(subtraction_result); // Round towards zero\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <stddef.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff > 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = diff > 0 ? floor(diff) : ceil(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <stddef.h>\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        float difference = tensor1[i] - tensor2[i];\n        dst[i] = (difference > 0) ? floorf(difference) : ceilf(difference);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\n#include <stddef.h>\n\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f; // Initialize the result for row i\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j]; // Perform dot product\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f; // Initialize the destination vector element to 0\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j]; // Perform matrix-vector multiplication\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f; // Initialize the destination vector element\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j]; // Perform the dot product\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f; // Initialize the result for the current row\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j]; // Perform the dot product\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f; // Initialize the destination vector element to 0\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j]; // Perform the dot product\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\n#include <stddef.h>\n\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\n#include <stddef.h>\n\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\n#include <stddef.h>\n\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\n#include <stddef.h>\n\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\n#include <stddef.h>\n\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; j++) {\n            int current = matrix[i * cols + j];\n            int previous = matrix[i * cols + j - 1];\n            if (ascending) {\n                if (current < previous) {\n                    return false;\n                }\n            } else {\n                if (current > previous) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 0; j < cols - 1; ++j) {\n            if (ascending) {\n                if (row[j] > row[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row[j] < row[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; ++j) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            if (ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; j++) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; ++j) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            if (ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = (a * x[i]) - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = (a * x[i]) - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = (y[i] < 0) ? -y[i] : y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = y[i] < 0 ? -y[i] : y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue; // Skip the first block\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t first_block_index = i * cols + j;\n                    size_t current_block_index = (block_row * block_size + i) * cols + (block_col * block_size + j);\n\n                    if (matrix[first_block_index] != matrix[current_block_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Reference block (first block)\n    const int* reference_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            // Pointer to the current block\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            // Compare the current block with the reference block\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t ref_index = i * cols + j;\n                    size_t cur_index = i * cols + j;\n                    if (reference_block[ref_index] != current_block[cur_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            // Skip the first block\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t first_block_index = i * cols + j;\n                    size_t current_block_index = (block_row * block_size + i) * cols + (block_col * block_size + j);\n\n                    if (matrix[first_block_index] != matrix[current_block_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue; // Skip the first block\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t first_block_index = i * cols + j;\n                    size_t current_block_index = (block_row * block_size + i) * cols + (block_col * block_size + j);\n\n                    if (matrix[first_block_index] != matrix[current_block_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < blocks_per_col; ++block_row) {\n        for (size_t block_col = 0; block_col < blocks_per_row; ++block_col) {\n            // Skip the first block\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            // Compare the current block with the first block\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t first_block_idx = i * cols + j;\n                    size_t current_block_idx = (block_row * block_size + i) * cols + (block_col * block_size + j);\n\n                    if (matrix[first_block_idx] != matrix[current_block_idx]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Validate inputs\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate the number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block to the first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx1 = i; // Index in the first block\n            size_t idx2 = block * block_size + i; // Index in the current block\n            if (fabs(vec[idx1] - vec[idx2]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate the number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block to the first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx1 = i; // Index in the first block\n            size_t idx2 = block * block_size + i; // Index in the current block\n            if (fabs(vec[idx1] - vec[idx2]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Validate input\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Determine the number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block to the first block\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t current_index = block_idx * block_size + i;\n            size_t first_block_index = i;\n\n            if (fabs(vec[current_index] - vec[first_block_index]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate the number of complete blocks\n    size_t num_blocks = length / block_size;\n\n    // If no complete blocks, return false\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block with the first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx1 = i; // Index in the first block\n            size_t idx2 = block * block_size + i; // Index in the current block\n\n            // Check if the elements differ by more than the tolerance\n            if (fabs(vec[idx1] - vec[idx2]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate the number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Compare each block to the first block\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t first_block_index = i;\n            size_t current_block_index = block_idx * block_size + i;\n\n            if (fabs(vec[first_block_index] - vec[current_block_index]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double value = matrix[i * cols + j];\n            norm += value * value;\n        }\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            norm += matrix[index] * matrix[index];\n        }\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            norm += matrix[index] * matrix[index];\n        }\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdbool.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            norm += matrix[index] * matrix[index];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double value = matrix[i * cols + j];\n            norm += value * value;\n        }\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t *A, const int8_t *B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t *A, const int8_t *B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i]; // Bitwise XOR for elements before the midpoint\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i]; // Bitwise AND for elements after the midpoint\n        } else {\n            C[i] = A[i]; // Keep the value in A for the midpoint\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i]; // Element-wise XOR for elements before the midpoint\n        } else if (i == midpoint) {\n            C[i] = A[i]; // Keep the value in A for the element at the midpoint\n        } else {\n            C[i] = A[i] & B[i]; // Element-wise AND for elements after the midpoint\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i]; // Element-wise XOR for elements before the midpoint\n        } else if (i == midpoint) {\n            C[i] = A[i]; // Keep the value in A for the midpoint\n        } else {\n            C[i] = A[i] & B[i]; // Element-wise AND for elements after the midpoint\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i]; // Element-wise bitwise XOR for elements before the midpoint\n        } else if (i == midpoint) {\n            C[i] = A[i]; // Keep the value in A for the midpoint element\n        } else {\n            C[i] = A[i] & B[i]; // Element-wise bitwise AND for elements after the midpoint\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i]; // Element-wise XOR for elements before the midpoint\n        } else if (i == midpoint) {\n            C[i] = A[i]; // Keep the value in A for the element at the midpoint\n        } else {\n            C[i] = A[i] & B[i]; // Element-wise AND for elements after the midpoint\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n\n        // Count the number of bits set to 1 in the current value\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n\n        // Count the number of bits set to 1\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t index = i * cols + j;\n            if (A[index] % 3 == 0) {\n                B[index] = abs(A[index]);\n            } else {\n                B[index] = A[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t current = src[i];\n        // Check if the low 4 bits are all 1\n        if ((current & 0xF) == 0xF) {\n            // Perform bitwise rotation toward the low bits\n            dst[i] = (current >> rotate_bits) | (current << (32 - rotate_bits));\n        } else {\n            // Perform bitwise negation\n            dst[i] = ~current;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t current = src[i];\n        // Check if the low 4 bits are all 1 (0xF in hexadecimal)\n        if ((current & 0xF) == 0xF) {\n            // Perform bitwise rotation toward the low bits\n            dst[i] = (current >> rotate_bits) | (current << (32 - rotate_bits));\n        } else {\n            // Perform bitwise negation\n            dst[i] = ~current;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t current = src[i];\n        // Check if the low 4 bits are all 1\n        if ((current & 0xF) == 0xF) {\n            // Perform bitwise rotation toward the low bits\n            dst[i] = (current >> rotate_bits) | (current << (32 - rotate_bits));\n        } else {\n            // Perform bitwise negation\n            dst[i] = ~current;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t current = src[i];\n        // Check if the low 4 bits of the current element are all 1\n        if ((current & 0xF) == 0xF) {\n            // Perform bitwise rotation toward the low bits\n            dst[i] = (current >> rotate_bits) | (current << (32 - rotate_bits));\n        } else {\n            // Perform bitwise negation\n            dst[i] = ~current;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t current = src[i];\n        if ((current & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (current >> rotate_bits) | (current << (32 - rotate_bits));\n        } else {\n            dst[i] = ~current; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)lroundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float division_result = A[i] / B[i];\n        C[i] = (int32_t)lroundf(division_result);\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <stddef.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <stddef.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <stddef.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <stddef.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <stddef.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        // Avoid division by zero\n        return;\n    }\n\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / range;\n            if (normalized < 0.0f) {\n                normalized = 0.0f;\n            } else if (normalized > 1.0f) {\n                normalized = 1.0f;\n            }\n            B[i] = normalized;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        // Avoid division by zero, if range is zero, copy A to B directly\n        for (size_t i = 0; i < size; ++i) {\n            B[i] = A[i];\n        }\n        return;\n    }\n\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / range;\n            if (normalized < 0.0f) {\n                B[i] = 0.0f;\n            } else if (normalized > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = normalized;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        // Avoid division by zero; if range is zero, copy A to B directly.\n        for (size_t i = 0; i < size; i++) {\n            B[i] = A[i];\n        }\n        return;\n    }\n\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        return; // Avoid division by zero\n    }\n\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / range;\n            if (normalized < 0.0f) {\n                normalized = 0.0f;\n            } else if (normalized > 1.0f) {\n                normalized = 1.0f;\n            }\n            B[i] = normalized;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract the high 16 bits of the uint32_t value\n        uint32_t high_16_bits = A[i] >> 16;\n        \n        // Convert the high 16 bits to float\n        float float_value = (float)high_16_bits;\n        \n        // Compute the square root of the float value\n        float sqrt_value = sqrtf(float_value);\n        \n        // Store the result in the destination array\n        B[i] = sqrt_value;\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_16_bits = A[i] >> 16; // Extract high 16 bits\n        float value = (float)high_16_bits; // Convert to float\n        B[i] = sqrtf(value);               // Compute square root and store in B\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract the high 16 bits of the uint32_t value\n        uint32_t high_16_bits = A[i] >> 16;\n        \n        // Convert the high 16 bits to float\n        float float_value = (float)high_16_bits;\n        \n        // Compute the square root of the float value\n        float sqrt_value = sqrtf(float_value);\n        \n        // Store the result in the destination array\n        B[i] = sqrt_value;\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_16_bits = A[i] >> 16; // Extract high 16 bits\n        float float_value = (float)high_16_bits; // Convert to float\n        B[i] = sqrtf(float_value); // Compute square root and store in B\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_16_bits = A[i] >> 16; // Extract the high 16 bits\n        float float_value = (float)high_16_bits; // Convert to float\n        B[i] = sqrtf(float_value); // Compute square root and store in B\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        // Use type-punning via a union to reinterpret the bits directly\n        union {\n            uint32_t i;\n            float f;\n        } pun;\n        pun.i = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]); // Compute difference and convert to float\n        } else {\n            diff[i] = 0.0f; // Set to 0.0f when condition is false\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // The first element is always set to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            // Compute the difference and convert to float\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            // Set to 0.0f when condition is false\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]); // Compute difference and convert to float\n        } else {\n            diff[i] = 0.0f; // Set to 0.0f when condition is false\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]); // Compute difference and convert to float\n        } else {\n            diff[i] = 0.0f; // Set to 0.0f when condition is false\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            // Compute the difference and convert to float\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            // Set diff[i] to 0.0f when cond[i] is false\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < (int16_t)length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < (int16_t)length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < (int16_t)length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < (int16_t)length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < (int16_t)length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_idx = input_row * input_size + input_col;\n\n                    size_t kernel_row = ki;\n                    size_t kernel_col = kj;\n                    size_t kernel_idx = kernel_row * kernel_size + kernel_col;\n\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> &numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> &numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    \n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> &numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> &numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> &numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    double sum_absolute_deviation = 0.0;\n\n    for (double num : numbers) {\n        sum_absolute_deviation += std::abs(num - mean);\n    }\n\n    return sum_absolute_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    double sum_absolute_deviation = 0.0;\n\n    for (double num : numbers) {\n        sum_absolute_deviation += std::abs(num - mean);\n    }\n\n    return sum_absolute_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    double sum_absolute_deviation = 0.0;\n\n    for (double num : numbers) {\n        sum_absolute_deviation += std::abs(num - mean);\n    }\n\n    return sum_absolute_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\n    double sum_absolute_deviation = 0.0;\n\n    for (double num : numbers) {\n        sum_absolute_deviation += std::abs(num - mean);\n    }\n\n    return sum_absolute_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n    \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int current_max = numbers[0];\n    result.push_back(current_max);\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = std::numeric_limits<int>::min();\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n    std::string longestString = strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    return longestString;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n    std::string longestString = strings[0];\n    for (const auto &str : strings) {\n        if (str.size() > longestString.size()) {\n            longestString = str;\n        }\n    }\n    return longestString;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"None\";\n    }\n    \n    std::string longestString = strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    \n    return longestString;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <optional>\n\nstd::optional<std::string> longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    \n    std::string longestString = strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longestString.length()) {\n            longestString = str;\n        }\n    }\n    return longestString;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <optional>\n\nstd::optional<std::string> longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i + 1];\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0, num2 = 0;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i + 1];\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must have at least two elements.\");\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return {closest_pair.first, closest_pair.second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements.\");\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    float first = 0.0, second = 0.0;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i];\n            second = numbers[i + 1];\n        }\n    }\n\n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"The input vector must have at least two elements.\");\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n\n    return {closest_pair.first, closest_pair.second};\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (max_val == min_val) {\n        // Avoid division by zero, return all zeros if all elements are the same\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (max_val == min_val) {\n        // Avoid division by zero, return all zeros if all elements are the same\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        // If all elements are the same, return a vector of zeros\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / range);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // This line is technically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // This line will never be reached for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // This line will never be reached for n > 1\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        for (size_t i = 0; i < result.size(); ++i) {\n            if (std::isalpha(result[i])) {\n                if (std::islower(result[i])) {\n                    result[i] = std::toupper(result[i]);\n                } else {\n                    result[i] = std::tolower(result[i]);\n                }\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        for (size_t i = 0; i < result.size(); ++i) {\n            if (std::isalpha(result[i])) {\n                result[i] = std::islower(result[i]) ? std::toupper(result[i]) : std::tolower(result[i]);\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        for (size_t i = 0; i < result.size(); ++i) {\n            if (std::isalpha(result[i])) {\n                if (std::islower(result[i])) {\n                    result[i] = std::toupper(result[i]);\n                } else {\n                    result[i] = std::tolower(result[i]);\n                }\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string &s) {\n    bool hasLetter = false;\n    std::string result = s;\n\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        for (char &c : result) {\n            if (std::isalpha(c)) {\n                c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        for (char &c : result) {\n            if (std::isalpha(c)) {\n                c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> divisible_by_three;\n\n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace elements at indices divisible by three with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[sorted_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    // Collect elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original elements at indices divisible by 3 with the sorted ones\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[sorted_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> divisible_by_three_indices;\n    std::vector<int> divisible_by_three_values;\n\n    // Collect indices and values of elements divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three_indices.push_back(i);\n            divisible_by_three_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the values at indices divisible by three\n    std::sort(divisible_by_three_values.begin(), divisible_by_three_values.end());\n\n    // Replace the original values at those indices with the sorted values\n    for (size_t i = 0; i < divisible_by_three_indices.size(); ++i) {\n        l[divisible_by_three_indices[i]] = divisible_by_three_values[i];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> divisible_by_three_indices;\n    std::vector<int> divisible_by_three_values;\n\n    // Collect indices and values of elements at positions divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three_indices.push_back(i);\n            divisible_by_three_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the values at positions divisible by three\n    std::sort(divisible_by_three_values.begin(), divisible_by_three_values.end());\n\n    // Replace the original values at those positions with the sorted values\n    for (size_t i = 0; i < divisible_by_three_indices.size(); ++i) {\n        l[divisible_by_three_indices[i]] = divisible_by_three_values[i];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> divisible_by_three;\n\n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original elements at indices divisible by three with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[sorted_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdbool.h>\n\nbool contains_digit_7(int num) {\n    while (num > 0) {\n        if (num % 10 == 7) {\n            return true;\n        }\n        num /= 10;\n    }\n    return false;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && contains_digit_7(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices_values;\n\n    // Collect values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the values at even indices\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Replace values at even indices in the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices_values[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    // Extract the even-indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Replace the even-indexed elements in the original vector with the sorted ones\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices_values;\n    \n    // Collect values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n    \n    // Sort the values at even indices\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n    \n    // Replace the values at even indices in the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices_values[even_index++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices_values;\n\n    // Collect values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the values at even indices\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Replace the values at even indices in the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices_values[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices_values;\n\n    // Collect values at even indices\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_indices_values.push_back(l[i]);\n    }\n\n    // Sort the values at even indices\n    std::sort(even_indices_values.begin(), even_indices_values.end());\n\n    // Replace the values at even indices in the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_indices_values[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        std::unordered_set<int> seen;\n        for (int j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        std::unordered_set<int> seen;\n        for (int j = i + 1; j < n; ++j) {\n            int complement = -(l[i] + l[j]);\n            if (seen.find(complement) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        std::unordered_set<int> seen;\n        for (int j = i + 1; j < n; ++j) {\n            int complement = -(l[i] + l[j]);\n            if (seen.find(complement) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        std::unordered_set<int> seen;\n        for (int j = i + 1; j < n; ++j) {\n            int complement = -(l[i] + l[j]);\n            if (seen.find(complement) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        std::unordered_set<int> seen;\n        for (int j = i + 1; j < n; ++j) {\n            int complement = -(l[i] + l[j]);\n            if (seen.find(complement) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64_t remainder = x % base;\n        result = std::to_string(remainder) + result;\n        x /= base;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        throw std::invalid_argument(\"Base must be between 2 and 9\");\n    }\n    std::string result;\n    do {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    } while (x > 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        throw std::invalid_argument(\"Base must be between 2 and 9.\");\n    }\n    std::string result;\n    do {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    } while (x > 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\"; // Invalid base\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64_t remainder = x % base;\n        result = std::to_string(remainder) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\"; // Invalid base\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int remainder = x % base;\n        result = std::to_string(remainder) + result;\n        x /= base;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && i == s.length() - 1) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && i == s.length() - 1) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && i == s.length() - 1) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            index = i;\n        }\n    }\n\n    if (index == -1) {\n        return {};\n    }\n\n    return {smallest_even, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            index = i;\n        }\n    }\n\n    if (index == -1) {\n        return {};\n    }\n\n    return {smallest_even, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                index = i;\n            }\n        }\n    }\n\n    if (index == -1) { // No even values found\n        return {};\n    }\n\n    return {smallest_even, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            index = i;\n        }\n    }\n\n    if (index == -1) {\n        return {};\n    }\n\n    return {smallest_even, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (arr[i] < smallest_even) {\n                smallest_even = arr[i];\n                index = i;\n            }\n        }\n    }\n\n    if (index == -1) {\n        return {}; // No even values found\n    }\n\n    return {smallest_even, index};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq_map;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map\n    for (const auto& pair : freq_map) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if the frequency is greater than or equal to the integer itself\n        if (freq >= num) {\n            result = std::max(result, num);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq_map;\n\n    // Count the frequency of each integer in the vector\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map to find the greatest integer\n    for (const auto& pair : freq_map) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map\n    for (const auto& [num, count] : freq) {\n        if (count >= num) {\n            result = std::max(result, num);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freqMap;\n\n    // Count the frequency of each number\n    for (int num : lst) {\n        freqMap[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map to find the greatest valid number\n    for (const auto& [num, freq] : freqMap) {\n        if (freq >= num) {\n            result = std::max(result, num);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq_map;\n\n    // Count the frequency of each integer\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    int result = -1;\n\n    // Iterate through the frequency map\n    for (const auto& pair : freq_map) {\n        int num = pair.first;\n        int freq = pair.second;\n\n        // Check if the frequency is greater than or equal to the integer itself\n        if (freq >= num) {\n            result = std::max(result, num);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool is_palindromic(const std::vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindromic(q) && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool is_palindromic(const std::vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindromic(q) && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool is_palindromic(const std::vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindromic(q) && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool is_palindromic(const std::vector<int>& q) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindromic(q) && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool is_palindromic(const std::vector<int>& q) {\n    return std::equal(q.begin(), q.begin() + q.size() / 2, q.rbegin());\n}\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindromic(q) && sum <= w;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& str) {\n            return sum + str.size();\n        });\n    };\n\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) {\n        int total = 0;\n        for (const auto& str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, \n            [](int sum, const std::string& str) { return sum + str.size(); });\n    };\n\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& str) {\n            return sum + str.size();\n        });\n    };\n\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& str) {\n            return sum + str.size();\n        });\n    };\n\n    int total1 = total_chars(lst1);\n    int total2 = total_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 1) {\n        return true; // 1 is a power of any number\n    }\n    if (n <= 1) {\n        return false; // n must be greater than 1 for valid powers\n    }\n\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n    }\n\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // 1 is a power of any number\n    if (n <= 1) return false; // n must be greater than 1 for valid powers\n\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 1) {\n        return true; // 1 is a power of any number (n**0 = 1).\n    }\n    if (n <= 1) {\n        return false; // n must be greater than 1 for valid powers.\n    }\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // 1 is a power of any number\n    if (n <= 1) return false; // n must be greater than 1 for valid powers\n\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 1) return true; // 1 is a power of any number\n    if (n <= 1) return false; // n must be greater than 1 for valid powers\n\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    // Set of hexadecimal digits that are prime\n    std::unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    // Set of hexadecimal digits that are prime numbers\n    std::unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through the input string and count prime hexadecimal digits\n    for (char c : num) {\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    // Set of hexadecimal digits that are prime\n    const std::unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the string\n    for (char c : num) {\n        // Check if the character is in the set of prime hexadecimal digits\n        if (prime_hex_digits.count(c)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    // Set of hexadecimal digits that are prime\n    std::unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through each character in the input string\n    for (char c : num) {\n        // Check if the character is a prime hexadecimal digit\n        if (prime_hex_digits.find(c) != prime_hex_digits.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nint hex_key(const std::string &num) {\n    // Set of hexadecimal digits that are prime\n    const std::unordered_set<char> prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n\n    // Iterate through the input string and count prime hex digits\n    for (char c : num) {\n        if (prime_hex_digits.count(c)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n#include <unordered_set>\n\nbool is_happy(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        std::unordered_set<char> unique_chars = {s[i], s[i + 1], s[i + 2]};\n        if (unique_chars.size() != 3) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string solve(uint64_t N) {\n    int digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    std::string binaryResult;\n    while (digitSum > 0) {\n        binaryResult = std::to_string(digitSum % 2) + binaryResult;\n        digitSum /= 2;\n    }\n    return binaryResult.empty() ? \"0\" : binaryResult;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n\n    // Calculate the sum of digits of N\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    // Convert the sum to binary\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N) {\n    int sum_of_digits = 0;\n    \n    // Calculate the sum of digits of N\n    while (N > 0) {\n        sum_of_digits += N % 10;\n        N /= 10;\n    }\n    \n    // Convert the sum of digits to binary and return as a string\n    return std::bitset<64>(sum_of_digits).to_string().substr(std::bitset<64>(sum_of_digits).to_string().find('1'));\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N) {\n    int sum_of_digits = 0;\n    while (N > 0) {\n        sum_of_digits += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum_of_digits).to_string().substr(std::bitset<64>(sum_of_digits).to_string().find('1'));\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N) {\n    int sum_of_digits = 0;\n    while (N > 0) {\n        sum_of_digits += N % 10;\n        N /= 10;\n    }\n    std::string binary_result;\n    while (sum_of_digits > 0) {\n        binary_result = char((sum_of_digits % 2) + '0') + binary_result;\n        sum_of_digits /= 2;\n    }\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string &s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = 'a' + (c - 'a' + 4) % 26; // Shift by 4 (2 * 2)\n            result += shifted;\n        } else {\n            result += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string &s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = ((c - 'a' + 4) % 26) + 'a';\n            result += shifted;\n        } else {\n            result += c; // If not a lowercase letter, keep the character as is\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string &s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = 'a' + (c - 'a' + 4) % 26;\n            result += shifted;\n        } else {\n            result += c; // Keep non-lowercase letters unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string &s) {\n    std::string result = \"\";\n    int shift = 2 * 2; // Shift by 4 places\n\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char encryptedChar = ((c - 'a' + shift) % 26) + 'a';\n            result += encryptedChar;\n        } else {\n            result += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string &s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            char shifted = 'a' + (c - 'a' + 4) % 26; // Shift by 4 (2 * 2)\n            result += shifted;\n        } else {\n            result += c; // Non-alphabet characters remain unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string &message) {\n    std::string result;\n    for (char ch : message) {\n        char encodedChar = ch;\n\n        // Swap case\n        if (std::islower(ch)) {\n            encodedChar = std::toupper(ch);\n        } else if (std::isupper(ch)) {\n            encodedChar = std::tolower(ch);\n        }\n\n        // Replace vowels\n        if (encodedChar == 'a' || encodedChar == 'A') {\n            encodedChar = 'C';\n        } else if (encodedChar == 'e' || encodedChar == 'E') {\n            encodedChar = 'G';\n        } else if (encodedChar == 'i' || encodedChar == 'I') {\n            encodedChar = 'K';\n        } else if (encodedChar == 'o' || encodedChar == 'O') {\n            encodedChar = 'Q';\n        } else if (encodedChar == 'u' || encodedChar == 'U') {\n            encodedChar = 'W';\n        }\n\n        result += encodedChar;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string &message) {\n    std::string result;\n    for (char ch : message) {\n        if (std::isalpha(ch)) {\n            // Swap case\n            char swapped = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n            \n            // Replace vowels\n            if (std::tolower(swapped) == 'a') swapped = 'C';\n            else if (std::tolower(swapped) == 'e') swapped = 'G';\n            else if (std::tolower(swapped) == 'i') swapped = 'K';\n            else if (std::tolower(swapped) == 'o') swapped = 'Q';\n            else if (std::tolower(swapped) == 'u') swapped = 'W';\n            \n            result += swapped;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string &message) {\n    std::string result;\n    for (char ch : message) {\n        if (std::isalpha(ch)) {\n            // Swap case\n            char swappedCase = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n            \n            // Replace vowels\n            if (std::tolower(swappedCase) == 'a') swappedCase = 'C';\n            else if (std::tolower(swappedCase) == 'e') swappedCase = 'G';\n            else if (std::tolower(swappedCase) == 'i') swappedCase = 'K';\n            else if (std::tolower(swappedCase) == 'o') swappedCase = 'Q';\n            else if (std::tolower(swappedCase) == 'u') swappedCase = 'W';\n            \n            result += swappedCase;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string &message) {\n    std::string result;\n    for (char ch : message) {\n        if (std::isalpha(ch)) {\n            // Swap case\n            char swapped = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n\n            // Replace vowels\n            if (std::tolower(swapped) == 'a') swapped = 'C';\n            else if (std::tolower(swapped) == 'e') swapped = 'G';\n            else if (std::tolower(swapped) == 'i') swapped = 'K';\n            else if (std::tolower(swapped) == 'o') swapped = 'Q';\n            else if (std::tolower(swapped) == 'u') swapped = 'W';\n\n            result += swapped;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string &message) {\n    std::string result = \"\";\n    for (char ch : message) {\n        if (std::isalpha(ch)) {\n            // Swap case\n            char swapped = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n            \n            // Replace vowels\n            if (swapped == 'A' || swapped == 'E' || swapped == 'I' || swapped == 'O' || swapped == 'U' ||\n                swapped == 'a' || swapped == 'e' || swapped == 'i' || swapped == 'o' || swapped == 'u') {\n                if (swapped == 'A') swapped = 'C';\n                else if (swapped == 'E') swapped = 'G';\n                else if (swapped == 'I') swapped = 'K';\n                else if (swapped == 'O') swapped = 'Q';\n                else if (swapped == 'U') swapped = 'W';\n                else if (swapped == 'a') swapped = 'c';\n                else if (swapped == 'e') swapped = 'g';\n                else if (swapped == 'i') swapped = 'k';\n                else if (swapped == 'o') swapped = 'q';\n                else if (swapped == 'u') swapped = 'w';\n            }\n            result += swapped;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool is_lower_case(const std::string& str) {\n    for (char c : str) {\n        if (!std::islower(c)) return false;\n    }\n    return true;\n}\n\nbool is_upper_case(const std::string& str) {\n    for (char c : str) {\n        if (!std::isupper(c)) return false;\n    }\n    return true;\n}\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        if (!is_lower_case(key)) all_lower = false;\n        if (!is_upper_case(key)) all_upper = false;\n\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false; // Key contains non-alphabetic characters\n            }\n            if (std::islower(c)) {\n                all_upper = false;\n            }\n            if (std::isupper(c)) {\n                all_lower = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        for (char ch : key) {\n            if (!std::isalpha(ch)) {\n                return false; // Keys must be alphabetic\n            }\n            if (std::islower(ch)) {\n                allUpper = false;\n            }\n            if (std::isupper(ch)) {\n                allLower = false;\n            }\n        }\n    }\n\n    return allLower || allUpper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        for (char ch : key) {\n            if (!std::isalpha(ch)) {\n                return false; // Non-alphabetic character in key\n            }\n            if (std::islower(ch)) {\n                all_upper = false;\n            } else if (std::isupper(ch)) {\n                all_lower = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        for (char ch : key) {\n            if (!std::isalpha(ch)) {\n                return false; // Non-alphabetic characters in key\n            }\n            if (std::islower(ch)) {\n                all_upper = false;\n            }\n            if (std::isupper(ch)) {\n                all_lower = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num == 2) return true;\n    if (num % 2 == 0) return false;\n    for (int i = 3; i <= std::sqrt(num); i += 2) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (std::isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (std::isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) { // Iterate over even indices\n        char c = s[i];\n        if (std::isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string &s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (std::isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (std::isupper(c) && (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2; // Next even number\n        } else {\n            current += 2; // Next odd number\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2; // Next even number\n        } else {\n            current += 2; // Next odd number\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        current += (n % 2 == 0) ? 2 : 2; // Increment by 2 regardless of odd/even\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (n % 2 == 0) {\n            current += 2; // Increment by 2 for even starting number\n        } else {\n            current += 2; // Increment by 2 for odd starting number\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        if (current_stones % 2 == 0) {\n            current_stones += 2; // Next even number\n        } else {\n            current_stones += 2; // Next odd number\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    int64_t sum = (m - n + 1) * (n + m) / 2; // Sum of integers from n to m\n    int64_t count = m - n + 1; // Number of integers from n to m\n    int64_t avg = sum / count; // Compute average\n    return std::to_string(avg);\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    int64_t sum = (m - n + 1) * (n + m) / 2; // Sum of integers from n to m\n    int64_t count = m - n + 1; // Number of integers\n    int64_t avg = std::round(static_cast<double>(sum) / count); // Rounded average\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = (m - n + 1) * (n + m) / 2; // Sum of integers from n to m\n    int64_t count = m - n + 1; // Total numbers in the range\n    int64_t avg = sum / count; // Compute average\n    return std::to_string(avg); // Convert to binary\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    int64_t sum = (m - n + 1) * (n + m) / 2; // Sum of integers from n to m\n    int64_t count = m - n + 1;              // Number of integers from n to m\n    int64_t avg = sum / count;              // Compute the average\n    std::string binary = \"\";\n\n    // Convert the average to binary\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    int64_t sum = (m - n + 1) * (n + m) / 2; // Sum of integers from n to m\n    int64_t count = m - n + 1; // Number of integers\n    int64_t avg = sum / count; // Average\n    return std::to_string(avg);\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nint factorial_mod(int num, int mod) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\nint sum_to(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorial_mod(i, 10000));\n        } else {\n            result.push_back(sum_to(i));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nint factorialMod(int num, int mod) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\nint sumUpTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorialMod(i, 10000));\n        } else {\n            result.push_back(sumUpTo(i));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nint factorialModulo(int num, int mod) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\nint sumUpTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result[i - 1] = factorialModulo(i, 10000);\n        } else {\n            result[i - 1] = sumUpTo(i);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nint factorialMod(int num, int mod) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\nint sumUpTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorialMod(i, 10000));\n        } else {\n            result.push_back(sumUpTo(i));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nint factorialModulo(int num, int mod) {\n    int result = 1;\n    for (int i = 1; i <= num; ++i) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\nint sumUpTo(int num) {\n    return (num * (num + 1)) / 2;\n}\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            result.push_back(factorialModulo(i, 10000));\n        } else {\n            result.push_back(sumUpTo(i));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0, right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        ++left;\n        --right;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                ++even_count;\n            } else {\n                ++odd_count;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = std::abs(num);\n\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = std::abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    if (is_negative) {\n        sum += num % 10; // Add the signed first digit\n        num = std::abs(num / 10); // Remove the first signed digit\n    } else {\n        num = std::abs(num);\n    }\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = std::abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    bool is_negative = num < 0;\n    num = std::abs(num);\n\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n\n    return is_negative ? -sum : sum;\n}\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (sum_of_digits(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int break_point = 0;\n\n    // Find the number of \"break points\" where the order is violated\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            break_point++;\n        }\n    }\n\n    // If there is at most one break point, it is possible to sort the array\n    return break_point <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int break_point = 0;\n\n    // Find the number of \"breaks\" in the sorted order\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            break_point++;\n        }\n    }\n\n    // If there is at most one \"break\", the array can be sorted by right shifts\n    return break_point <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int break_point = 0;\n\n    // Find the number of break points where the order is violated\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            ++break_point;\n            if (break_point > 1) return false; // More than one break point means not possible\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int break_point = 0;\n\n    // Find the number of \"break points\" where the order is violated\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            break_point++;\n        }\n    }\n\n    // If there is at most one break point, it is possible to sort the array\n    return break_point <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    int break_point = 0;\n\n    // Find the number of break points where the order is violated\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            break_point++;\n        }\n    }\n\n    // If there is at most one break point, it is possible to sort the array\n    return break_point <= 1;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Check if lst1 already contains only even numbers\n    bool all_even = std::all_of(lst1.begin(), lst1.end(), [](int num) { return num % 2 == 0; });\n    if (all_even) {\n        return \"YES\";\n    }\n\n    // Check if lst2 contains at least one even number\n    bool has_even_in_lst2 = std::any_of(lst2.begin(), lst2.end(), [](int num) { return num % 2 == 0; });\n    if (!has_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Check if lst1 can be made entirely even\n    for (int num : lst1) {\n        if (num % 2 != 0) { // If an odd number exists in lst1\n            // Ensure there is an even number in lst2 to replace it\n            if (!has_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Check if lst1 already contains only even numbers\n    bool allEven = std::all_of(lst1.begin(), lst1.end(), [](int x) { return x % 2 == 0; });\n    if (allEven) {\n        return \"YES\";\n    }\n\n    // Check if lst2 contains at least one even number\n    bool hasEvenInLst2 = std::any_of(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n    if (!hasEvenInLst2) {\n        return \"NO\";\n    }\n\n    // Check if lst1 can be made entirely even\n    for (int num : lst1) {\n        if (num % 2 != 0) { // If the number in lst1 is odd\n            // Check if there is an even number in lst2 to replace it\n            if (!hasEvenInLst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Check if lst1 already contains only even numbers\n    bool allEven = true;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            allEven = false;\n            break;\n        }\n    }\n    if (allEven) return \"YES\";\n\n    // Check if lst2 contains at least one even number\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            return \"YES\";\n        }\n    }\n\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Check if lst1 already contains only even numbers\n    bool all_even = true;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            all_even = false;\n            break;\n        }\n    }\n    if (all_even) return \"YES\";\n\n    // Check if lst2 contains enough even numbers to replace odd numbers in lst1\n    int odd_count = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    int even_count_in_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_in_lst2++;\n        }\n    }\n\n    return even_count_in_lst2 >= odd_count ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Check if lst1 already contains only even numbers\n    bool all_even = true;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            all_even = false;\n            break;\n        }\n    }\n    if (all_even) return \"YES\";\n\n    // Check if lst2 contains enough even numbers to replace all odd numbers in lst1\n    int odd_count = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    int even_count_in_lst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_in_lst2++;\n        }\n    }\n\n    return even_count_in_lst2 >= odd_count ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n\n        // Count the number of odd digits in the current string\n        for (char c : lst[i]) {\n            if (std::isdigit(c) && (c - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        // Construct the output string\n        std::string output = \"the number of odd elements \" +\n                             std::to_string(odd_count) + \"n the str\" +\n                             std::to_string(odd_count) + \"ng \" +\n                             std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if (std::isdigit(c) && (c - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) + \"ng \" +\n                             std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if (c >= '0' && c <= '9' && (c - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char ch : lst[i]) {\n            if (std::isdigit(ch) && (ch - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                             \"n the str\" + std::to_string(odd_count) + \n                             \"ng \" + std::to_string(odd_count) + \n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n\n    for (const auto &str : lst) {\n        int odd_count = 0;\n\n        for (char ch : str) {\n            if (std::isdigit(ch) && (ch - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t currentSum = 0;\n    int64_t minSum = INT64_MAX;\n\n    for (int64_t num : nums) {\n        currentSum += num;\n        minSum = std::min(minSum, currentSum);\n        if (currentSum > 0) {\n            currentSum = 0;\n        }\n    }\n\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        global_min = std::min(global_min, current_min);\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = INT64_MAX;\n    int64_t currentSum = 0;\n\n    for (int64_t num : nums) {\n        currentSum = std::min(currentSum + num, num);\n        minSum = std::min(minSum, currentSum);\n    }\n\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        global_min = std::min(global_min, current_min);\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t currentSum = 0;\n    int64_t minSum = INT64_MAX;\n\n    for (int64_t num : nums) {\n        currentSum += num;\n        minSum = std::min(minSum, currentSum);\n        if (currentSum > 0) {\n            currentSum = 0;\n        }\n    }\n\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_operations = 0;\n    \n    for (const auto &row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            water_units += cell;\n        }\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n    \n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_water_units = 0;\n\n    // Calculate the total number of water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water_units += cell;\n        }\n    }\n\n    // Calculate the number of times the bucket needs to be lowered\n    return std::ceil(static_cast<double>(total_water_units) / capacity);\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_water_units = 0;\n\n    // Calculate the total number of water units in the grid\n    for (const auto &row : grid) {\n        for (int cell : row) {\n            total_water_units += cell;\n        }\n    }\n\n    // Calculate the number of times the bucket needs to be lowered\n    return std::ceil(static_cast<double>(total_water_units) / capacity);\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_operations = 0;\n\n    for (const auto &row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            water_units += cell;\n        }\n        total_operations += std::ceil((double)water_units / capacity);\n    }\n\n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_operations = 0;\n\n    for (const auto &row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            water_units += cell;\n        }\n        total_operations += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n\n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // Iterate over even positions\n        if (lst[i] % 2 != 0) { // Check if the element is odd\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the number has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) { // Check if the number has at most two digits\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<int, int> frequency;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check for duplicates\n        frequency[lst[i]]++;\n        if (frequency[lst[i]] > 2) return false;\n\n        // Check for ascending order\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<int, int> frequency;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check if the current number appears more than once\n        frequency[lst[i]]++;\n        if (frequency[lst[i]] > 2) return false;\n\n        // Check if the list is sorted in ascending order\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<int, int> frequency;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i > 0 && lst[i] < lst[i - 1]) {\n            return false;\n        }\n        frequency[lst[i]]++;\n        if (frequency[lst[i]] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<int, int> frequency;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check for duplicates\n        frequency[lst[i]]++;\n        if (frequency[lst[i]] > 2) return false;\n\n        // Check for ascending order\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> &lst) {\n    if (lst.size() <= 1) return true;\n\n    std::unordered_map<int, int> frequency;\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        // Check for duplicates\n        frequency[lst[i]]++;\n        if (frequency[lst[i]] > 2) return false;\n\n        // Check for ascending order\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            sign_product *= 1;\n        } else if (num < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product *= 0;\n        }\n        magnitude_sum += std::abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    for (int num : arr) {\n        sum_magnitudes += std::abs(num);\n        if (num > 0) {\n            product_signs *= 1;\n        } else if (num < 0) {\n            product_signs *= -1;\n        } else {\n            product_signs *= 0;\n        }\n    }\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            sign_product *= 1;\n        } else if (num < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product *= 0;\n        }\n        magnitude_sum += std::abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num == 0) sign_product = 0;\n        else sign_product *= (num > 0 ? 1 : -1);\n        magnitude_sum += std::abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for (int num : arr) {\n        if (num > 0) {\n            sign_product *= 1;\n        } else if (num < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product *= 0;\n        }\n        magnitude_sum += std::abs(num);\n    }\n\n    return magnitude_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n    std::priority_queue<std::tuple<std::vector<int>, int, int>> pq;\n\n    // Push all starting points into the priority queue\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({{-grid[i][j]}, i, j});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [path, x, y] = pq.top();\n        pq.pop();\n\n        std::vector<int> currentPath = path;\n        for"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n    std::priority_queue<std::tuple<std::vector<int>, int, int>> pq;\n\n    // Push all starting points into the priority queue\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({{-grid[i][j]}, i, j});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [path, x, y] = pq.top();\n        pq.pop();\n\n        // Convert path back to positive values\n        std::vector<int> currentPath = path;\n        for (auto &val : currentPath) val = -val;\n\n        // If we have a path of length k, return it\n        if (currentPath.size() == k) {\n            return currentPath;\n        }\n\n        // Explore neighbors\n        std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (auto [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> newPath = currentPath;\n                newPath.push_back(grid[nx][ny]);\n                pq.push({{-newPath[0], nx, ny}});\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k, INT_MAX);\n\n    // Directions for moving in the grid (up, down, left, right)\n    std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Priority queue to perform lexicographical BFS\n    using State = std::tuple<int, int, std::vector<int>>; // (row, col, path)\n    auto cmp = [](const State &a, const State &b) {\n        return std::get<2>(a) > std::get<2>(b); // Compare paths lexicographically\n    };\n    std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);\n\n    // Start from every cell in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({i, j, {grid[i][j]}});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [row, col, path] = pq.top();\n        pq.pop();\n\n        // If the path length is k, check if it's the minimum path\n        if (path.size() == k) {\n            result = std::min(result, path);\n            continue;\n        }\n\n        // Explore neighbors\n        for (const auto &[dr, dc] : directions) {\n            int newRow = row + dr;\n            int newCol = col + dc;\n\n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[newRow][newCol]);\n                pq.push({newRow, newCol, newPath});\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n    std::priority_queue<std::tuple<std::vector<int>, int, int>> pq;\n\n    // Initialize the priority queue with all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({{-grid[i][j]}, i, j});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [path, x, y] = pq.top();\n        pq.pop();\n\n        std::vector<int> currentPath = path;\n        for ("}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n\n    // Priority queue to store paths in lexicographical order\n    // Each entry is a tuple: (current_path, current_x, current_y)\n    std::priority_queue<std::tuple<std::vector<int>, int, int>, \n                        std::vector<std::tuple<std::vector<int>, int, int>>, \n                        std::greater<>> pq;\n\n    // Initialize the priority queue with all starting cells\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({{grid[i][j]}, i, j});\n        }\n    }\n\n    // Directions for moving to neighbor cells\n    std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while (!pq.empty()) {\n        auto [current_path, x, y] = pq.top();\n        pq.pop();\n\n        // If the path length is k, return the result\n        if (current_path.size() == k) {\n            return current_path;\n        }\n\n        // Explore neighbors\n        for (const auto &[dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> new_path = current_path;\n                new_path.push_back(grid[nx][ny]);\n                pq.push({new_path, nx, ny});\n            }\n        }\n    }\n\n    return result; // This line should never be reached\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int hasOdd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = 1;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int hasOdd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = 1;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int hasOdd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = 1;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int hasOdd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = 1;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int hasOdd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = 1;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int rounded = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(rounded * rounded);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int rounded = std::ceil(num); // Round up to the nearest integer\n        sum += rounded * rounded;    // Add the square of the rounded number to the sum\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int rounded = std::ceil(num);\n        sum += static_cast<uint64_t>(rounded * rounded);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int rounded = std::ceil(num);\n        sum += static_cast<uint64_t>(rounded * rounded);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int rounded = std::ceil(num);\n        sum += static_cast<uint64_t>(rounded * rounded);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (!has_negative || num > largest_negative) {\n                largest_negative = num;\n                has_negative = true;\n            }\n        } else if (num > 0) {\n            if (!has_positive || num < smallest_positive) {\n                smallest_positive = num;\n                has_positive = true;\n            }\n        }\n    }\n\n    return {has_negative ? largest_negative : 0, has_positive ? smallest_positive : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int max_negative = std::numeric_limits<int>::min();\n    int min_positive = std::numeric_limits<int>::max();\n\n    for (int num : lst) {\n        if (num < 0 && num > max_negative) {\n            max_negative = num;\n            largest_negative = num;\n        }\n        if (num > 0 && num < min_positive) {\n            min_positive = num;\n            smallest_positive = num;\n        }\n    }\n\n    if (max_negative == std::numeric_limits<int>::min()) {\n        largest_negative = 0;\n    }\n    if (min_positive == std::numeric_limits<int>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (!has_negative || num > largest_negative) {\n                largest_negative = num;\n                has_negative = true;\n            }\n        } else if (num > 0) {\n            if (!has_positive || num < smallest_positive) {\n                smallest_positive = num;\n                has_positive = true;\n            }\n        }\n    }\n\n    return {has_negative ? largest_negative : 0, has_positive ? smallest_positive : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (!has_negative || num > largest_negative) {\n                largest_negative = num;\n                has_negative = true;\n            }\n        } else if (num > 0) {\n            if (!has_positive || num < smallest_positive) {\n                smallest_positive = num;\n                has_positive = true;\n            }\n        }\n    }\n\n    return {has_negative ? largest_negative : 0, has_positive ? smallest_positive : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = std::numeric_limits<int>::min();\n    int smallest_positive = std::numeric_limits<int>::max();\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (int num : lst) {\n        if (num < 0) {\n            has_negative = true;\n            if (num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            has_positive = true;\n            if (num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(const std::vector<int> &nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (std::abs(num) > 10) {\n            int firstDigit = std::abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = std::abs(num) % 10;\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(const std::vector<int> &nums) {\n    int count = 0;\n    for (int num : nums) {\n        int absNum = std::abs(num);\n        if (absNum > 10) {\n            int firstDigit = absNum;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(const std::vector<int> &nums) {\n    int count = 0;\n    for (int num : nums) {\n        int absNum = std::abs(num);\n        if (absNum > 10) {\n            int firstDigit = absNum;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(const std::vector<int> &nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (std::abs(num) > 10) {\n            int firstDigit = std::abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = std::abs(num) % 10;\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool isOdd(int digit) {\n    return digit % 2 != 0;\n}\n\nint specialFilter(const std::vector<int> &nums) {\n    int count = 0;\n    for (int num : nums) {\n        int absNum = std::abs(num);\n        if (absNum > 10) {\n            int firstDigit = absNum;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if (isOdd(firstDigit) && isOdd(lastDigit)) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    std::vector<int> mod_count(3, 0);\n    for (uint64_t i = 0; i < n; ++i) {\n        mod_count[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n    // Case 1: All three numbers have the same remainder\n    for (int i = 0; i < 3; ++i) {\n        if (mod_count[i] >= 3) {\n            result += (mod_count[i] * (mod_count[i] - 1) * (mod_count[i] - 2)) / 6;\n        }\n    }\n\n    // Case 2: Three numbers have different remainders\n    result += mod_count[0] * mod_count[1] * mod_count[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    std::vector<int> mod_count(3, 0);\n    for (uint64_t i = 0; i < n; ++i) {\n        mod_count[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n    // Case 1: All three numbers have the same remainder\n    for (int i = 0; i < 3; ++i) {\n        if (mod_count[i] >= 3) {\n            result += (mod_count[i] * (mod_count[i] - 1) * (mod_count[i] - 2)) / 6;\n        }\n    }\n\n    // Case 2: Three numbers have different remainders\n    result += mod_count[0] * mod_count[1] * mod_count[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    // Create the vector a\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count the remainders of a[i] modulo 3\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    // Calculate the number of valid triples\n    uint64_t result = 0;\n\n    // Case 1: All three numbers have the same remainder\n    for (uint64_t r = 0; r < 3; ++r) {\n        if (count_mod[r] >= 3) {\n            result += (count_mod[r] * (count_mod[r] - 1) * (count_mod[r] - 2)) / 6;\n        }\n    }\n\n    // Case 2: Three numbers have different remainders (0, 1, 2)\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    std::vector<int> mod_count(3, 0);\n    for (uint64_t i = 0; i < n; ++i) {\n        mod_count[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n    // Case 1: All three numbers have the same remainder\n    for (int i = 0; i < 3; ++i) {\n        if (mod_count[i] >= 3) {\n            result += (mod_count[i] * (mod_count[i] - 1) * (mod_count[i] - 2)) / 6;\n        }\n    }\n\n    // Case 2: Three numbers with different remainders\n    result += mod_count[0] * mod_count[1] * mod_count[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    uint64_t count_mod_0 = 0, count_mod_1 = 0, count_mod_2 = 0;\n\n    for (uint64_t i = 0; i < n; ++i) {\n        if (a[i] % 3 == 0) {\n            ++count_mod_0;\n        } else if (a[i] % 3 == 1) {\n            ++count_mod_1;\n        } else {\n            ++count_mod_2;\n        }\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three numbers are mod 0\n    if (count_mod_0 >= 3) {\n        result += (count_mod_0 * (count_mod_0 - 1) * (count_mod_0 - 2)) / 6;\n    }\n\n    // Case 2: One number from each mod group (mod 0, mod 1, mod 2)\n    result += count_mod_0 * count_mod_1 * count_mod_2;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    if (is_prime(n)) {\n        return x;\n    } else {\n        return y;\n    }\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (const auto &num : lst) {\n        if (num >= 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (const auto &num : lst) {\n        if (num > 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (const auto& num : lst) {\n        if (num >= 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (const auto& num : lst) {\n        if (num >= 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (const auto& num : lst) {\n        if (num >= 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}

{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t mask_vec = vld1q_u64((const uint64_t*)&mask[i]);\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        \n        // Create a vector of 64-bit integers with conditional values\n        int64x2_t result_vec = vbslq_s64(mask_vec, src_vec, vdupq_n_s64(0));\n        \n        // Store the result in the destination array\n        vst1q_s64(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t mask_vec = vld1q_u64((const uint64_t*)&mask[i]);\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        \n        // Create a mask for the condition\n        uint64x2_t mask_true = vdupq_n_u64(1);\n        uint64x2_t mask_false = vdupq_n_u64(0);\n        \n        // Select elements based on the mask\n        int64x2_t result_vec = vbslq_s64(mask_vec, src_vec, vdupq_n_s64(0));\n        \n        // Store the result\n        vst1q_s64(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t mask_vec = vld1q_u64((const uint64_t*)&mask[i]);\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        \n        // Create a vector of 64-bit integers to hold the results\n        int64x2_t result_vec = vbslq_s64(mask_vec, src_vec, vdupq_n_s64(0));\n\n        // Store the results back to the destination array\n        vst1q_s64(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t mask_vec = vld1q_u64((const uint64_t*)&mask[i]);\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        \n        // Create a mask for the condition\n        uint64x2_t mask_true = vdupq_n_u64(1);\n        uint64x2_t mask_false = vdupq_n_u64(0);\n        \n        // Select elements based on the mask\n        int64x2_t result_vec = vbslq_s64(mask_vec, src_vec, vdupq_n_s64(0));\n        \n        // Store the results\n        vst1q_s64(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t mask_vec = vld1q_u64((const uint64_t*)&mask[i]);\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        \n        // Create a mask for the condition\n        uint64x2_t mask_true = vdupq_n_u64(1);\n        uint64x2_t mask_false = vdupq_n_u64(0);\n        \n        // Compare mask with true\n        uint64x2_t mask_result = vceqq_u64(mask_vec, mask_true);\n        \n        // Select elements based on mask\n        int64x2_t result = vbslq_s64(mask_result, src_vec, vdupq_n_s64(0));\n        \n        // Store the results in dst\n        vst1q_s64(&dst[i], result);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec_src = vld1q_s32(&src[i]);\n        int32x4_t vec_scale = vdupq_n_s32(scale);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        \n        int32x4_t result = vaddq_s32(vmulq_s32(vec_src, vec_scale), vmulq_s32(tmp1, tmp2));\n        result = vshrq_n_s32(result, 3); // Divide by 7 (approximation)\n        \n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(src + i);\n        int32x4_t v_scale = vdupq_n_s32(scale);\n        \n        int32x4_t v_tmp1 = vshrq_n_s32(vmulq_s32(v_src, v_scale), 3);\n        int32x4_t v_tmp2 = vshlq_n_s32(vmulq_s32(v_src, v_scale), 3);\n        \n        int32x4_t v_result = vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2));\n        v_result = vshrq_n_s32(v_result, 3); // Divide by 7 using right shift\n        \n        vst1q_s32(dst + i, v_result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t scale_vec = vdupq_n_s32(scale);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(src_vec, scale_vec), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(src_vec, scale_vec), 3);\n        \n        int32x4_t result = vaddq_s32(vmulq_s32(src_vec, scale_vec), vmulq_s32(tmp1, tmp2));\n        result = vshrq_n_s32(result, 3); // Divide by 7 (approximation)\n        \n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec_src = vld1q_s32(&src[i]);\n        int32x4_t vec_scale = vdupq_n_s32(scale);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        \n        int32x4_t result = vaddq_s32(vmulq_s32(vec_src, vec_scale), vmulq_s32(tmp1, tmp2));\n        result = vshrq_n_s32(result, 3); // Divide by 7 can be approximated by right shifting by 3\n        \n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec_src = vld1q_s32(&src[i]);\n        int32x4_t vec_scale = vdupq_n_s32(scale);\n        \n        int32x4_t tmp1 = vshrq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        int32x4_t tmp2 = vshlq_n_s32(vmulq_s32(vec_src, vec_scale), 3);\n        \n        int32x4_t result = vaddq_s32(vmulq_s32(vec_src, vec_scale), vmulq_s32(tmp1, tmp2));\n        result = vshrq_n_s32(result, 3); // Divide by 7 (approximation)\n        \n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    for (i = 0; i < rows; i += 2) {\n        if (i + 1 < rows) {\n            float64x2_t data = vld1q_f64(&src[i * cols + stride]);\n            vst1q_f64(&dst[i], data);\n        } else {\n            dst[i] = src[i * cols + stride];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    for (i = 0; i < rows; i += 2) {\n        if (i + 1 < rows) {\n            float64x2_t data = vld1q_f64(&src[i * cols + stride]);\n            vst1q_f64(&dst[i], data);\n        } else {\n            dst[i] = src[i * cols + stride];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 4; i += 4) {\n        float64x2_t data1 = vld1q_f64(src + (i * cols + stride));\n        float64x2_t data2 = vld1q_f64(src + ((i + 1) * cols + stride));\n        float64x2_t data3 = vld1q_f64(src + ((i + 2) * cols + stride));\n        float64x2_t data4 = vld1q_f64(src + ((i + 3) * cols + stride));\n        \n        vst1q_f64(dst + i, data1);\n        vst1q_f64(dst + (i + 1), data2);\n        vst1q_f64(dst + (i + 2), data3);\n        vst1q_f64(dst + (i + 3), data4);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    for (i = 0; i <= rows - 4; i += 4) {\n        float64x2_t val1 = vld1q_f64(&src[i * cols + stride]);\n        float64x2_t val2 = vld1q_f64(&src[(i + 2) * cols + stride]);\n        vst1q_f64(&dst[i], val1);\n        vst1q_f64(&dst[i + 2], val2);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    for (i = 0; i < rows; i += 2) {\n        if (i + 1 < rows) {\n            float64x2_t data = vld1q_f64(&src[i * cols + stride]);\n            vst1q_f64(&dst[i], data);\n        } else {\n            dst[i] = src[i * cols + stride];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t gathered = vld1q_f32(&src[vgetq_lane_s32(idx, 0)]);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(&dst[i], gathered);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t values = vld1q_f32(&src[i]);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 0)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 1)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 2)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 3)], values);\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n\n    // Scatter operation\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t values = vld1q_f32(src + i);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 0), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 1), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 2), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 3), values);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t gathered = vld1q_f32(&src[vgetq_lane_s32(idx, 0)]);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t values = vld1q_f32(&src[i]);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 0)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 1)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 2)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 3)], values);\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(dst + i, gathered);\n    }\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t values = vld1q_f32(src + i);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 0), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 1), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 2), values);\n        vst1q_f32(dst + vgetq_lane_s32(idx, 3), values);\n    }\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t gathered = vld1q_f32(&src[vgetq_lane_s32(idx, 0)]);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(&dst[i], gathered);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t values = vld1q_f32(&src[i]);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 0)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 1)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 2)], values);\n        vst1q_f32(&dst[vgetq_lane_s32(idx, 3)], values);\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i;\n\n    for (i = 0; i < length / 8; i++) {\n        int16x8_t vec1 = vld1q_s16(arr + start + i * 8);\n        int16x8_t vec2 = vld1q_s16(arr + end - (i * 8));\n        vst1q_s16(arr + start + i * 8, vec2);\n        vst1q_s16(arr + end - (i * 8), vec1);\n    }\n\n    for (; i * 8 < length; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i;\n\n    for (i = 0; i < length / 2; i += 8) {\n        if (i + 8 <= length) {\n            int16x8_t vec_start = vld1q_s16(arr + start + i);\n            int16x8_t vec_end = vld1q_s16(arr + end - i - 7);\n            vst1q_s16(arr + start + i, vec_end);\n            vst1q_s16(arr + end - i - 7, vec_start);\n        } else {\n            break;\n        }\n    }\n\n    for (; i < length / 2; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i;\n\n    for (i = 0; i < length / 2; i += 8) {\n        if (i + 8 <= length) {\n            int16x8_t vec_start = vld1q_s16(arr + start + i);\n            int16x8_t vec_end = vld1q_s16(arr + start + length - 8 - i);\n            vst1q_s16(arr + start + i, vec_end);\n            vst1q_s16(arr + start + length - 8 - i, vec_start);\n        } else {\n            break;\n        }\n    }\n\n    // Handle remaining elements if length is odd\n    if (length % 2 != 0) {\n        int16_t temp = arr[start + (length / 2)];\n        arr[start + (length / 2)] = arr[start + (length - 1 - (length / 2))];\n        arr[start + (length - 1 - (length / 2))] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i;\n\n    for (i = 0; i < length / 2; i += 8) {\n        if (i + 8 <= length) {\n            int16x8_t vec_start = vld1q_s16(arr + start + i);\n            int16x8_t vec_end = vld1q_s16(arr + end - i);\n            vst1q_s16(arr + start + i, vec_end);\n            vst1q_s16(arr + end - i, vec_start);\n        } else {\n            break;\n        }\n    }\n\n    for (; i < length / 2; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t half_length = length / 2;\n\n    for (uint64_t i = 0; i < half_length; i += 8) {\n        uint64_t left_index = start + i;\n        uint64_t right_index = end - i;\n\n        if (left_index < right_index) {\n            int16x8_t left_vec = vld1q_s16(arr + left_index);\n            int16x8_t right_vec = vld1q_s16(arr + right_index - 7);\n            vst1q_s16(arr + left_index, right_vec);\n            vst1q_s16(arr + right_index - 7, left_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t data = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t data = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t data = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t data = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t data = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    size_t src_index = (block_row + i) * cols + (block_col + j);\n                    size_t dst_index = (block_col + j) * rows + (block_row + i);\n                    \n                    if ((block_row + i) < rows && (block_col + j) < cols) {\n                        int16x8_t vec = vld1q_s16(&src[src_index]);\n                        vst1q_s16(&dst[dst_index], vec);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; j += 8) {\n                    int16x8_t src_vec = vld1q_s16(&src[(block_row + i) * cols + (block_col + j)]);\n                    vst1q_s16(&dst[(block_col + j) * rows + (block_row + i)], src_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; bj += 8) {\n                    int16x8_t v0 = vld1q_s16(src + (i + bi) * cols + (j + bj));\n                    int16x8_t v1 = vld1q_s16(src + (i + bi) * cols + (j + bj + 1));\n                    int16x8_t v2 = vld1q_s16(src + (i + bi) * cols + (j + bj + 2));\n                    int16x8_t v3 = vld1q_s16(src + (i + bi) * cols + (j + bj + 3));\n                    int16x8_t v4 = vld1q_s16(src + (i + bi) * cols + (j + bj + 4));\n                    int16x8_t v5 = vld1q_s16(src + (i + bi) * cols + (j + bj + 5));\n                    int16x8_t v6 = vld1q_s16(src + (i + bi) * cols + (j + bj + 6));\n                    int16x8_t v7 = vld1q_s16(src + (i + bi) * cols + (j + bj + 7));\n\n                    vst1q_s16(dst + (j + bj) * rows + (i + bi), v0);\n                    vst1q_s16(dst + (j + bj + 1) * rows + (i + bi), v1);\n                    vst1q_s16(dst + (j + bj + 2) * rows + (i + bi), v2);\n                    vst1q_s16(dst + (j + bj + 3) * rows + (i + bi), v3);\n                    vst1q_s16(dst + (j + bj + 4) * rows + (i + bi), v4);\n                    vst1q_s16(dst + (j + bj + 5) * rows + (i + bi), v5);\n                    vst1q_s16(dst + (j + bj + 6) * rows + (i + bi), v6);\n                    vst1q_s16(dst + (j + bj + 7) * rows + (i + bi), v7);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; j += 8) {\n                    int16x8_t row_data = vld1q_s16(&src[(block_row + i) * cols + (block_col + j)]);\n                    vst1q_s16(&dst[(block_col + j) * rows + (block_row + i)], row_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; j += 8) {\n                    int16x8_t row_data = vld1q_s16(&src[(block_row + i) * cols + (block_col + j)]);\n                    vst1q_s16(&dst[(block_col + j) * rows + (block_row + i)], row_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t diag_elements = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum_vec = vaddq_f32(sum_vec, diag_elements);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    float sum = vget_lane_f32(sum_pair, 0);\n\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum_vec = vaddq_f32(sum_vec, data_vec);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    \n    float sum = vget_lane_f32(sum_pair, 0);\n    \n    for (; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum_vec = vaddq_f32(sum_vec, data_vec);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    \n    return vget_lane_f32(sum_pair, 0);\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum_vec = vaddq_f32(sum_vec, data_vec);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    \n    float sum = vget_lane_f32(sum_pair, 0);\n    \n    for (; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t diag_elements = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum_vec = vaddq_f32(sum_vec, diag_elements);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    float sum = vget_lane_f32(sum_pair, 0);\n\n    for (; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        float64x2_t src_vec = vld1q_f64(&src[i]);\n        uint64x2_t cmp = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(cmp, scaled_vec, src_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t src_vec = vld1q_f64(&src[i]);\n        uint64x2_t cmp = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(cmp, scaled_vec, src_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        float64x2_t src_vec = vld1q_f64(&src[i]);\n        uint64x2_t cmp_vec = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(cmp_vec, scaled_vec, src_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t src_vec = vld1q_f64(&src[i]);\n        uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(mask, scaled_vec, src_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t src_vec = vld1q_f64(&src[i]);\n        uint64x2_t cmp = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result_vec = vbslq_f64(cmp, scaled_vec, src_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i] * cols;\n        size_t idx2 = indices[i + 1] * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t row1 = vld1q_f64(&src[idx1 + j]);\n            float64x2_t row2 = vld1q_f64(&src[idx2 + j]);\n\n            vst1q_f64(&dst[i * cols + j], row1);\n            vst1q_f64(&dst[(i + 1) * cols + j], row2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i] * cols;\n        size_t idx2 = indices[i + 1] * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t row1 = vld1q_f64(&src[idx1 + j]);\n            float64x2_t row2 = vld1q_f64(&src[idx2 + j]);\n\n            vst1q_f64(&dst[i * cols + j], row1);\n            vst1q_f64(&dst[(i + 1) * cols + j], row2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t r = 0; r < rows; r += 2) {\n        size_t idx1 = indices[r];\n        size_t idx2 = (r + 1 < rows) ? indices[r + 1] : idx1;\n\n        const double *src_row1 = src + idx1 * cols;\n        const double *src_row2 = src + idx2 * cols;\n\n        for (size_t c = 0; c < cols; c += 2) {\n            float64x2_t data1 = vld1q_f64(src_row1 + c);\n            float64x2_t data2 = vld1q_f64(src_row2 + c);\n            vst1q_f64(dst + (r * cols) + c, data1);\n            if (r + 1 < rows) {\n                vst1q_f64(dst + ((r + 1) * cols) + c, data2);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i] * cols;\n        size_t idx2 = indices[i + 1] * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t row1 = vld1q_f64(&src[idx1 + j]);\n            float64x2_t row2 = vld1q_f64(&src[idx2 + j]);\n\n            vst1q_f64(&dst[i * cols + j], row1);\n            vst1q_f64(&dst[(i + 1) * cols + j], row2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t r = 0; r < rows; r += 2) {\n        size_t idx1 = indices[r];\n        size_t idx2 = (r + 1 < rows) ? indices[r + 1] : idx1;\n\n        const double *src_row1 = src + idx1 * cols;\n        const double *src_row2 = src + idx2 * cols;\n\n        for (size_t c = 0; c < cols; c += 2) {\n            float64x2_t data1 = vld1q_f64(src_row1 + c);\n            float64x2_t data2 = vld1q_f64(src_row2 + c);\n            vst1q_f64(dst + (r * cols) + c, data1);\n            if (r + 1 < rows) {\n                vst1q_f64(dst + ((r + 1) * cols) + c, data2);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t vec_scalar = vdupq_n_s64(scalar);\n    \n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_src1 = vld1q_s64(&src1[i]);\n        int64x2_t vec_src2 = vld1q_s64(&src2[i]);\n        \n        int64x2_t vec_sum = vaddq_s64(vec_src1, vec_src2);\n        vec_sum = vaddq_s64(vec_sum, vec_scalar);\n        vec_sum = vshrq_n_s64(vec_sum, 1);\n        \n        vst1q_s64(&dst[i], vec_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t vec_scalar = vdupq_n_s64(scalar);\n    \n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_src1 = vld1q_s64(&src1[i]);\n        int64x2_t vec_src2 = vld1q_s64(&src2[i]);\n        \n        int64x2_t vec_sum = vaddq_s64(vec_src1, vec_src2);\n        vec_sum = vaddq_s64(vec_sum, vec_scalar);\n        vec_sum = vshrq_n_s64(vec_sum, 1);\n        \n        vst1q_s64(&dst[i], vec_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t vec_scalar = vdupq_n_s64(scalar);\n    \n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_src1 = vld1q_s64(&src1[i]);\n        int64x2_t vec_src2 = vld1q_s64(&src2[i]);\n        \n        int64x2_t vec_sum = vaddq_s64(vec_src1, vec_src2);\n        vec_sum = vaddq_s64(vec_sum, vec_scalar);\n        vec_sum = vshrq_n_s64(vec_sum, 1);\n        \n        vst1q_s64(&dst[i], vec_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t vec_scalar = vdupq_n_s64(scalar);\n    \n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_src1 = vld1q_s64(&src1[i]);\n        int64x2_t vec_src2 = vld1q_s64(&src2[i]);\n        int64x2_t vec_sum = vaddq_s64(vec_src1, vec_src2);\n        vec_sum = vaddq_s64(vec_sum, vec_scalar);\n        vec_sum = vshrq_n_s64(vec_sum, 1);\n        vst1q_s64(&dst[i], vec_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t vec_scalar = vdupq_n_s64(scalar);\n    \n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_src1 = vld1q_s64(&src1[i]);\n        int64x2_t vec_src2 = vld1q_s64(&src2[i]);\n        \n        int64x2_t vec_sum = vaddq_s64(vec_src1, vec_src2);\n        vec_sum = vaddq_s64(vec_sum, vec_scalar);\n        vec_sum = vshrq_n_s64(vec_sum, 1);\n        \n        vst1q_s64(&dst[i], vec_sum);\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        min_vec = vminq_s32(min_vec, data);\n    }\n\n    int32_t min_array[4];\n    vst1q_s32(min_array, min_vec);\n\n    int min_value = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_value) {\n            min_value = min_array[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            if (src[i] < min_value) {\n                min_value = src[i];\n            }\n        }\n    }\n\n    return (min_value == INT_MAX) ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 2 * 2; i += 2) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        min_vec = vminq_s32(min_vec, data);\n    }\n\n    if (length % 2 == 1) {\n        min_vec = vminq_s32(min_vec, vdupq_n_s32(src[length - 1]));\n    }\n\n    int32_t min_array[4];\n    vst1q_s32(min_array, min_vec);\n    \n    int min_value = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_value) {\n            min_value = min_array[j];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 2 * 2; i += 2) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        min_vec = vminq_s32(min_vec, data);\n    }\n\n    if (length % 2 == 1) {\n        min_vec = vminq_s32(min_vec, vdupq_n_s32(src[length - 1]));\n    }\n\n    int32x4_t min_vec_shifted = vextq_s32(min_vec, min_vec, 1);\n    min_vec = vminq_s32(min_vec, min_vec_shifted);\n    \n    int32x2_t min_pair = vget_low_s32(min_vec);\n    min_pair = vpmin_s32(min_pair, vget_high_s32(min_vec));\n    \n    int min_value = vget_lane_s32(min_pair, 0);\n    min_value = vmin_s32(min_value, vget_lane_s32(min_pair, 1));\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        if (i % 2 == 0) {\n            min_vec = vminq_s32(min_vec, data);\n        }\n    }\n\n    int32x4_t min_vec_shifted = vextq_s32(min_vec, min_vec, 1);\n    min_vec = vminq_s32(min_vec, min_vec_shifted);\n    min_vec_shifted = vextq_s32(min_vec, min_vec, 2);\n    min_vec = vminq_s32(min_vec, min_vec_shifted);\n\n    int32_t min_values[4];\n    vst1q_s32(min_values, min_vec);\n    \n    int min_value = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_values[j] < min_value) {\n            min_value = min_values[j];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        min_vec = vminq_s32(min_vec, data);\n    }\n\n    int32_t min_array[4];\n    vst1q_s32(min_array, min_vec);\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_array[0] = vmin_s32(vdup_n_s32(min_array[0]), src[i]);\n        }\n    }\n\n    int min_value = min_array[0];\n    for (int j = 1; j < 4; j++) {\n        min_value = vmin_s32(vdup_n_s32(min_value), min_array[j]);\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(data, shift);\n        \n        // Logical right shift\n        uint32x4_t uint_data = vreinterpretq_u32_s32(data);\n        uint32x4_t logical_shift = vshrq_n_u32(uint_data, shift);\n        int32x4_t log_shift = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arith_shift, log_shift);\n        \n        // Store the result\n        vst1q_s32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4; i++) {\n        int32x4_t data = vld1q_s32(src + i * 4);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(data, shift);\n        \n        // Logical right shift\n        uint32x4_t uint_data = vreinterpretq_u32_s32(data);\n        uint32x4_t logical_shift = vshrq_n_u32(uint_data, shift);\n        int32x4_t log_shift = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arith_shift, log_shift);\n        \n        // Store the result\n        vst1q_s32(dst + i * 4, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(data, shift);\n        \n        // Logical right shift\n        uint32x4_t uint_data = vreinterpretq_u32_s32(data);\n        uint32x4_t logical_shift = vshrq_n_u32(uint_data, shift);\n        \n        // Combine results\n        int32x4_t result = vaddq_s32(arith_shift, vreinterpretq_s32_u32(logical_shift));\n        \n        // Store the result\n        vst1q_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arithmetic_shift = vshrq_n_s32(data, shift);\n        \n        // Logical right shift\n        uint32x4_t uint_data = vreinterpretq_u32_s32(data);\n        uint32x4_t logical_shift = vshrq_n_u32(uint_data, shift);\n        \n        // Convert logical shift back to int\n        int32x4_t logical_shift_int = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arithmetic_shift, logical_shift_int);\n        \n        // Store the result\n        vst1q_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4; i++) {\n        int32x4_t data = vld1q_s32(&src[i * 4]);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(data, shift);\n        \n        // Logical right shift\n        uint32x4_t uint_data = vreinterpretq_u32_s32(data);\n        uint32x4_t logic_shift = vshrq_n_u32(uint_data, shift);\n        int32x4_t logic_shift_int = vreinterpretq_s32_u32(logic_shift);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arith_shift, logic_shift_int);\n        \n        // Store result\n        vst1q_s32(&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        int32x4_t data_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(data_vec));\n    }\n\n    int64_t sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        int32x4_t data_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(data_vec));\n    }\n    \n    int64_t sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        int32x4_t data_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(data_vec));\n    }\n\n    int64_t sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    // Process 4 elements at a time\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    \n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t data_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_u32(vaddl_u32(vget_low_u32(data_vec), vget_high_u32(data_vec))));\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    // Sum the vector elements\n    int64_t temp[2];\n    vst1q_s64(temp, sum_vec);\n    sum += temp[0] + temp[1];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        int32x4_t data_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s64(sum_vec, vreinterpretq_s64_s32(data_vec));\n    }\n\n    int64_t sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_val = vdupq_n_s8(src[0]);\n    size_t max_index = 0;\n    size_t i;\n\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t current = vld1q_s8(src + i);\n        uint8x16_t cmp = vqtgtq_s8(current, max_val);\n        max_val = vmaxq_s8(max_val, current);\n        \n        uint8x16_t indices = vdupq_n_u8(i);\n        max_index = vgetq_lane_u8(vmax_u8(vreinterpret_u8_s8(current), vreinterpret_u8_s8(max_val)), 0);\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > vgetq_lane_s8(max_val, 0)) {\n            max_val = vdupq_n_s8(src[i]);\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_val = vdupq_n_s8(INT8_MIN);\n    uint8x16_t max_idx = vdupq_n_u8(0);\n    size_t max_index = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t data = vld1q_s8(src + i);\n        uint8x16_t indices = vdupq_n_u8(i);\n        \n        uint8x16_t cmp = vcgtq_s8(data, max_val);\n        max_val = vmaxq_s8(max_val, data);\n        max_idx = vbslq_u8(cmp, indices, max_idx);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > vgetq_lane_s8(max_val, 0)) {\n            max_val = vdupq_n_s8(src[i]);\n            max_index = i;\n        }\n    }\n\n    // Find the maximum index\n    uint8x16_t max_idx_array = max_idx;\n    uint8_t max_index_in_array = vgetq_lane_u8(max_idx_array, 0);\n    for (int j = 1; j < 16; j++) {\n        if (vgetq_lane_s8(max_val, j) > vgetq_lane_s8(max_val, max_index_in_array)) {\n            max_index_in_array = j;\n        }\n    }\n\n    return max_index + max_index_in_array;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t vec = vld1q_s8(src + i);\n        int8x16_t cmp = vdupq_n_s8(max_value);\n        uint16x8_t mask = vcgtq_s8(vec, cmp);\n        \n        int8x16_t max_vec = vmaxq_s8(vec, cmp);\n        max_value = vgetq_lane_s8(max_vec, 0);\n        \n        for (int j = 1; j < 16; j++) {\n            if (vgetq_lane_s8(max_vec, j) > max_value) {\n                max_value = vgetq_lane_s8(max_vec, j);\n                max_index = i + j;\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vals = vdupq_n_s8(INT8_MIN);\n    uint8x16_t max_indices = vdupq_n_u8(0);\n    size_t max_index = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t data = vld1q_s8(src + i);\n        uint8x16_t indices = vdupq_n_u8(i);\n\n        uint8x16_t cmp = vcgtq_s8(data, max_vals);\n        max_vals = vmaxq_s8(max_vals, data);\n        max_indices = vbslq_u8(cmp, indices, max_indices);\n    }\n\n    int8_t max_val = vgetq_lane_s8(max_vals, 0);\n    size_t max_idx = vgetq_lane_u8(max_indices, 0);\n\n    for (size_t j = 1; j < 16; j++) {\n        if (vgetq_lane_s8(max_vals, j) > max_val) {\n            max_val = vgetq_lane_s8(max_vals, j);\n            max_idx = vgetq_lane_u8(max_indices, j);\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t vec = vld1q_s8(src + i);\n        int8x16_t max_vec = vec;\n\n        for (int j = 1; j < 16; j++) {\n            max_vec = vmaxq_s8(max_vec, vextq_s8(vec, vec, j));\n        }\n\n        int8_t max_val_arr[16];\n        vst1q_s8(max_val_arr, max_vec);\n        for (int j = 0; j < 16; j++) {\n            if (max_val_arr[j] > max_value) {\n                max_value = max_val_arr[j];\n                max_index = i + j;\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        \n        uint8x8_t index_vec = vdup_n_u8(i);\n        uint8x8_t mask_vec = vdup_n_u8(mask);\n        uint8x8_t and_result = vand_u8(index_vec, mask_vec);\n        uint8x8_t condition = vdup_n_u8(0);\n        condition = vsetq_lane_u8(1, condition, 0); // Set a lane to 1 for comparison\n        \n        uint8x8_t blend_mask = vcgt_u8(and_result, condition);\n        uint16x8_t blended_result = vbslq_u16(blend_mask, src1_vec, src2_vec);\n        \n        vst1q_u16(dst + i, blended_result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 8) {\n        uint16x8_t indices = vld1q_u16(src1 + i);\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n\n        uint16x8_t index_mask = vdupq_n_u16(mask);\n        uint16x8_t index_and = vandq_u16(indices, index_mask);\n        uint16x8_t condition = vdupq_n_u16(0);\n\n        condition = vdupq_n_u16(1);\n        condition = vceqq_u16(index_and, condition);\n\n        uint16x8_t result = vbslq_u16(condition, src1_vec, src2_vec);\n        vst1q_u16(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 8) {\n        uint16x8_t indices = vld1q_u16(src1 + i);\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        \n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask = vandq_u16(indices, mask_vec);\n        \n        uint16x8_t blend_result = vbslq_u16(vneq_u16(index_mask, vdupq_n_u16(0)), src1_vec, src2_vec);\n        \n        vst1q_u16(dst + i, blend_result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 8 * 8; i += 8) {\n        uint16x8_t indices = vld1q_u16((uint16_t*)&i);\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t and_result = vandq_u16(indices, mask_vec);\n        uint16x8_t select_src1 = vld1q_u16(src1 + i);\n        uint16x8_t select_src2 = vld1q_u16(src2 + i);\n        \n        uint16x8_t result = vbslq_u16(vcltq_u16(and_result, vdupq_n_u16(1)), select_src1, select_src2);\n        vst1q_u16(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 8 * 8; i += 8) {\n        uint16x8_t indices = vld1q_u16(src1 + i);\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        \n        uint8x8_t index_mask = vdup_n_u8(mask);\n        uint8x8_t index_and = vand_u8(vreinterpret_u8_u16(indices), index_mask);\n        uint8x8_t condition = vdup_n_u8(0);\n        \n        condition = vdup_n_u8(1);\n        condition = vorr_u8(condition, index_and);\n        \n        uint16x8_t result = vbslq_u16(condition, src1_vec, src2_vec);\n        vst1q_u16(dst + i, result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(data);\n        vst1q_u32(&dst[i], count);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vcntq_u32(data));\n\n        vst1q_u32(dst + i, count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        uint16x8_t a = vld1q_u16(src1 + i * 8);\n        uint16x8_t b = vld1q_u16(src2 + i * 8);\n        uint16x8_t result = vqaddq_u16(a, b);\n        vst1q_u16(dst + i * 8, result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src1[i] > UINT16_MAX - src2[i]) ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        uint16x8_t a = vld1q_u16(src1 + i * 8);\n        uint16x8_t b = vld1q_u16(src2 + i * 8);\n        uint16x8_t result = vqaddq_u16(a, b);\n        vst1q_u16(dst + i * 8, result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src1[i] > UINT16_MAX - src2[i]) ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(dst + i, result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src1[i] > UINT16_MAX - src2[i]) ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        uint16x8_t a = vld1q_u16(src1 + i * 8);\n        uint16x8_t b = vld1q_u16(src2 + i * 8);\n        uint16x8_t result = vqaddq_u16(a, b);\n        vst1q_u16(dst + i * 8, result);\n    }\n    for (; i < length; i++) {\n        dst[i] = (src1[i] > UINT16_MAX - src2[i]) ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t a = vld1q_u16(src1 + i);\n        uint16x8_t b = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(a, b);\n        vst1q_u16(dst + i, result);\n    }\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgtq_f64(a, vdupq_n_f64(-100.0));\n                uint64x2_t mask_b = vcgtq_f64(b, vdupq_n_f64(-100.0));\n                uint64x2_t mask_a_b = vandq_u64(mask_a, mask_b);\n                \n                a = vbslq_f64(mask_a_b, a, vdupq_n_f64(0.0));\n                b = vbslq_f64(mask_a_b, b, vdupq_n_f64(0.0));\n\n                sum = vmlaq_f64(sum, a, b);\n            }\n            C[i * p + j] = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t a_mask = vcgtq_f64(a_vec, vdupq_n_f64(-100.0));\n                uint64x2_t b_mask = vcgtq_f64(b_vec, vdupq_n_f64(-100.0));\n                uint64x2_t a_mask2 = vcltq_f64(a_vec, vdupq_n_f64(100.0));\n                uint64x2_t b_mask2 = vcltq_f64(b_vec, vdupq_n_f64(100.0));\n\n                uint64x2_t valid_mask = vandq_u64(a_mask, b_mask);\n                valid_mask = vandq_u64(valid_mask, a_mask2);\n                valid_mask = vandq_u64(valid_mask, b_mask2);\n\n                float64x2_t product = vmulq_f64(a_vec, b_vec);\n                product = vbslq_f64(valid_mask, product, vdupq_n_f64(0.0));\n\n                sum = vaddq_f64(sum, product);\n            }\n            C[i * p + j] = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vals = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vals = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t a_mask = vcgtq_f64(a_vals, vdupq_n_f64(-100.0));\n                uint64x2_t b_mask = vcgtq_f64(b_vals, vdupq_n_f64(-100.0));\n                uint64x2_t a_mask2 = vcltq_f64(a_vals, vdupq_n_f64(100.0));\n                uint64x2_t b_mask2 = vcltq_f64(b_vals, vdupq_n_f64(100.0));\n\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n                mask = vandq_u64(mask, a_mask2);\n                mask = vandq_u64(mask, b_mask2);\n\n                a_vals = vbslq_f64(mask, a_vals, vdupq_n_f64(0.0));\n                b_vals = vbslq_f64(mask, b_vals, vdupq_n_f64(0.0));\n\n                sum = vmlaq_f64(sum, a_vals, b_vals);\n            }\n            C[i * p + j] = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vals = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vals = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t a_mask = vcgtq_f64(a_vals, vdupq_n_f64(-100.0));\n                a_mask = vandq_u64(a_mask, vcltq_f64(a_vals, vdupq_n_f64(100.0)));\n\n                uint64x2_t b_mask = vcgtq_f64(b_vals, vdupq_n_f64(-100.0));\n                b_mask = vandq_u64(b_mask, vcltq_f64(b_vals, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n\n                sum = vmlaq_f64(sum, a_vals, b_vals);\n                sum = vbslq_f64(mask, sum, sum);\n            }\n            C[i * p + j] = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgtq_f64(a_vec, vdupq_n_f64(-100.0));\n                uint64x2_t mask_b = vcgtq_f64(b_vec, vdupq_n_f64(-100.0));\n                uint64x2_t mask_a_b = vandq_u64(mask_a, vcgtq_f64(b_vec, vdupq_n_f64(100.0)));\n\n                if (vmaxvq_u64(mask_a_b) != 0) {\n                    float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                    sum = vaddq_f64(sum, prod);\n                }\n            }\n            C[i * p + j] = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(C + i, c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(C + i, c);\n    }\n\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        int64x2_t a = vld1q_s64(A + i);\n        int64x2_t b = vld1q_s64(B + i);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(C + i, c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded = vcvtq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(&dst[i], rounded);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded = vcvtq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded = vcvtq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        int32x4_t rounded = vcvtq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n        uint32x4_t v_mask = vcltq_f32(v_diff, vdupq_n_f32(50.0f));\n        \n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vrndpq_f32(v_result); // Round towards positive infinity\n        \n        // Set results to -1 where conditions are not met\n        float32x4_t v_neg_one = vdupq_n_f32(-1.0f);\n        v_result = vbslq_f32(v_mask, v_result, v_neg_one);\n        \n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if (diff < 50.0f) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        float32x4_t v_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t v_mask = vcgtq_f32(v_diff, vdupq_n_f32(50.0f));\n        \n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vroundpq_f32(v_result);\n        \n        // Set results to -1 for elements that do not meet the conditions\n        float32x4_t v_neg_one = vdupq_n_f32(-1.0f);\n        v_result = vbslq_f32(v_mask, v_result, v_neg_one);\n        \n        vst1q_f32(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n        uint32x4_t v_mask = vcgtq_f32(v_diff, vdupq_n_f32(50.0f));\n        \n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vaddq_f32(v_result, vdupq_n_f32(0.999999f)); // for rounding up\n        \n        v_result = vreinterpretq_f32_u32(vandq_u32(v_mask, vreinterpretq_u32_f32(v_result)));\n        v_result = vorrq_u32(vandq_u32(v_mask, vreinterpretq_u32_f32(v_result)), vdupq_n_u32(-1));\n        \n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n        uint32x4_t v_mask = vcltq_f32(v_diff, vdupq_n_f32(50.0f));\n        \n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vrndpq_f32(v_result); // Round towards positive infinity\n        \n        // Set results to -1 for elements not meeting the conditions\n        float32x4_t v_neg_one = vdupq_n_f32(-1.0f);\n        v_result = vbslq_f32(v_mask, v_result, v_neg_one);\n        \n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements if length is not a multiple of 4\n    for (; i < length; i++) {\n        if (fabsf(src1[i] - src2[i]) < 50 && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n        uint32x4_t v_mask = vcltq_f32(v_diff, vdupq_n_f32(50.0f));\n        \n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vceilq_f32(v_result);\n        \n        float32x4_t v_neg_one = vdupq_n_f32(-1.0f);\n        v_result = vbslq_f32(v_mask, v_result, v_neg_one);\n        \n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if (diff < 50.0f) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_squares = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_squares = vmlaq_f32(sum_squares, vec, vec);\n        }\n        \n        float32x2_t sum_squares_low = vadd_f32(vget_low_f32(sum_squares), vget_high_f32(sum_squares));\n        sum_squares_low = vpadd_f32(sum_squares_low, sum_squares_low);\n        float norm = sqrtf(vget_lane_f32(sum_squares_low, 0));\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized_vec = vmulq_f32(vec, vdupq_n_f32(1.0f / norm));\n            vst1q_f32(&mat[i * n + j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_squares = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_squares = vmlaq_f32(sum_squares, vec, vec);\n        }\n        \n        float32x2_t sum_squares_low = vadd_f32(vget_low_f32(sum_squares), vget_high_f32(sum_squares));\n        sum_squares_low = vpadd_f32(sum_squares_low, sum_squares_low);\n        float norm = sqrtf(vget_lane_f32(sum_squares_low, 0));\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized_vec = vmulq_f32(vec, vdupq_n_f32(1.0f / norm));\n            vst1q_f32(&mat[i * n + j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_squares = vdupq_n_f32(0.0f);\n        float* row = mat + i * n;\n\n        // Compute the sum of squares using SIMD\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_squares = vmlaq_f32(sum_squares, vec, vec);\n        }\n\n        // Handle remaining elements\n        float sum = 0.0f;\n        for (; j < n; ++j) {\n            sum += row[j] * row[j];\n        }\n\n        // Horizontal add the sum of squares\n        float32x2_t sum_squares_low = vget_low_f32(sum_squares);\n        float32x2_t sum_squares_high = vget_high_f32(sum_squares);\n        sum_squares_low = vadd_f32(sum_squares_low, sum_squares_high);\n        sum = vget_lane_f32(sum_squares_low, 0) + vget_lane_f32(sum_squares_low, 1) + sum;\n\n        // Calculate the L2 norm\n        float norm = sqrtf(sum);\n\n        // Normalize the row\n        if (norm > 0.0f) {\n            for (j = 0; j <= n - 4; j += 4) {\n                float32x4_t vec = vld1q_f32(row + j);\n                vec = vmulq_f32(vec, vdupq_n_f32(1.0f / norm));\n                vst1q_f32(row + j, vec);\n            }\n            for (; j < n; ++j) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_squares = vdupq_n_f32(0.0f);\n        float* row = mat + i * n;\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_squares = vmlaq_f32(sum_squares, vec, vec);\n        }\n\n        float32x2_t sum_squares_low = vadd_f32(vget_low_f32(sum_squares), vget_high_f32(sum_squares));\n        sum_squares_low = vpadd_f32(sum_squares_low, sum_squares_low);\n        float norm = sqrtf(vget_lane_f32(sum_squares_low, 0));\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vmulq_f32(vec, vdupq_n_f32(1.0f / norm));\n            vst1q_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_squares = vdupq_n_f32(0.0f);\n        float* row = mat + i * n;\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_squares = vmlaq_f32(sum_squares, vec, vec);\n        }\n\n        float32x4_t norm = vsqrtq_f32(sum_squares);\n        float norm_value = vgetq_lane_f32(norm, 0) + vgetq_lane_f32(norm, 1) + vgetq_lane_f32(norm, 2) + vgetq_lane_f32(norm, 3);\n        norm_value = sqrtf(norm_value);\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vmulq_f32(vec, vdupq_n_f32(1.0f / norm_value));\n            vst1q_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n            double result[2];\n            vst1q_f64(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n            double result[2];\n            vst1q_f64(result, sum);\n            dst[i * p + j] = std::round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n            double result[2];\n            vst1q_f64(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n            double result[2];\n            vst1q_f64(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n            double result[2];\n            vst1q_f64(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            float32x4_t tmp0 = vcombine_f32(vget_low_f32(row0), vget_low_f32(row1));\n            float32x4_t tmp1 = vcombine_f32(vget_low_f32(row2), vget_low_f32(row3));\n            float32x4_t tmp2 = vcombine_f32(vget_high_f32(row0), vget_high_f32(row1));\n            float32x4_t tmp3 = vcombine_f32(vget_high_f32(row2), vget_high_f32(row3));\n\n            // Store transposed values\n            vst1q_f32(&dst[j * rows + i], tmp0);\n            vst1q_f32(&dst[j * rows + i + 1], tmp1);\n            vst1q_f32(&dst[j * rows + i + 2], tmp2);\n            vst1q_f32(&dst[j * rows + i + 3], tmp3);\n        }\n    }\n\n    // Rounding to the nearest quarter\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = roundf(dst[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            float32x4x2_t tmp0 = vuzpq_f32(row0, row1);\n            float32x4x2_t tmp1 = vuzpq_f32(row2, row3);\n            float32x4_t t0 = tmp0.val[0];\n            float32x4_t t1 = tmp1.val[0];\n            float32x4_t t2 = tmp0.val[1];\n            float32x4_t t3 = tmp1.val[1];\n\n            // Store transposed values\n            vst1q_f32(&dst[j * rows + i], t0);\n            vst1q_f32(&dst[j * rows + i + 1], t1);\n            vst1q_f32(&dst[j * rows + i + 2], t2);\n            vst1q_f32(&dst[j * rows + i + 3], t3);\n\n            // Round to nearest quarter\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            t0 = vaddq_f32(t0, vdupq_n_f32(0.125f));\n            t1 = vaddq_f32(t1, vdupq_n_f32(0.125f));\n            t2 = vaddq_f32(t2, vdupq_n_f32(0.125f));\n            t3 = vaddq_f32(t3, vdupq_n_f32(0.125f));\n\n            t0 = vmlaq_f32(vdupq_n_f32(0.0f), vqrshrn_n_u32(vreinterpretq_u32_f32(t0), 0), quarter);\n            t1 = vmlaq_f32(vdupq_n_f32(0.0f), vqrshrn_n_u32(vreinterpretq_u32_f32(t1), 0), quarter);\n            t2 = vmlaq_f32(vdupq_n_f32(0.0f), vqrshrn_n_u32(vreinterpretq_u32_f32(t2), 0), quarter);\n            t3 = vmlaq_f32(vdupq_n_f32(0.0f), vqrshrn_n_u32(vreinterpretq_u32_f32(t3), 0), quarter);\n\n            // Store rounded values\n            vst1q_f32(&dst[j * rows + i], t0);\n            vst1q_f32(&dst[j * rows + i + 1], t1);\n            vst1q_f32(&dst[j * rows + i + 2], t2);\n            vst1q_f32(&dst[j * rows + i + 3], t3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            float32x4_t t0 = vcombine_f32(vget_low_f32(row0), vget_low_f32(row1));\n            float32x4_t t1 = vcombine_f32(vget_low_f32(row2), vget_low_f32(row3));\n            float32x4_t t2 = vcombine_f32(vget_high_f32(row0), vget_high_f32(row1));\n            float32x4_t t3 = vcombine_f32(vget_high_f32(row2), vget_high_f32(row3));\n\n            // Store transposed values\n            vst1q_f32(&dst[j * rows + i], t0);\n            vst1q_f32(&dst[j * rows + i + 1], t1);\n            vst1q_f32(&dst[j * rows + i + 2], t2);\n            vst1q_f32(&dst[j * rows + i + 3], t3);\n        }\n    }\n\n    // Rounding to the nearest quarter\n    for (size_t k = 0; k < rows * cols; k += 4) {\n        float32x4_t vec = vld1q_f32(&dst[k]);\n        vec = vaddq_f32(vec, vdupq_n_f32(0.125f)); // Add 0.125 for rounding\n        vec = vmulq_f32(vec, vdupq_n_f32(4.0f)); // Scale to quarter\n        vec = vroundq_f32(vec); // Round to nearest integer\n        vec = vmulq_f32(vec, vdupq_n_f32(0.25f)); // Scale back to quarter\n        vst1q_f32(&dst[k], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            float32x4_t tmp0 = vcombine_f32(vget_low_f32(row0), vget_low_f32(row1));\n            float32x4_t tmp1 = vcombine_f32(vget_low_f32(row2), vget_low_f32(row3));\n            float32x4_t tmp2 = vcombine_f32(vget_high_f32(row0), vget_high_f32(row1));\n            float32x4_t tmp3 = vcombine_f32(vget_high_f32(row2), vget_high_f32(row3));\n\n            float32x4_t t0 = vzip1_f32(tmp0, tmp1);\n            float32x4_t t1 = vzip2_f32(tmp0, tmp1);\n            float32x4_t t2 = vzip1_f32(tmp2, tmp3);\n            float32x4_t t3 = vzip2_f32(tmp2, tmp3);\n\n            // Round to nearest quarter\n            t0 = vaddq_f32(t0, vdupq_n_f32(0.125f));\n            t1 = vaddq_f32(t1, vdupq_n_f32(0.125f));\n            t2 = vaddq_f32(t2, vdupq_n_f32(0.125f));\n            t3 = vaddq_f32(t3, vdupq_n_f32(0.125f));\n\n            t0 = vrndnq_f32(t0);\n            t1 = vrndnq_f32(t1);\n            t2 = vrndnq_f32(t2);\n            t3 = vrndnq_f32(t3);\n\n            // Store transposed and rounded values\n            vst1q_f32(&dst[j * rows + i], t0);\n            vst1q_f32(&dst[j * rows + i + 1], t1);\n            vst1q_f32(&dst[j * rows + i + 2], t2);\n            vst1q_f32(&dst[j * rows + i + 3], t3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            float32x4_t temp0 = vcombine_f32(vget_low_f32(row0), vget_low_f32(row1));\n            float32x4_t temp1 = vcombine_f32(vget_low_f32(row2), vget_low_f32(row3));\n            float32x4_t temp2 = vcombine_f32(vget_high_f32(row0), vget_high_f32(row1));\n            float32x4_t temp3 = vcombine_f32(vget_high_f32(row2), vget_high_f32(row3));\n\n            // Store transposed values\n            vst1q_f32(&dst[j * rows + i], temp0);\n            vst1q_f32(&dst[j * rows + i + 1], temp1);\n            vst1q_f32(&dst[j * rows + i + 2], temp2);\n            vst1q_f32(&dst[j * rows + i + 3], temp3);\n        }\n    }\n\n    // Round to nearest quarter\n    for (size_t k = 0; k < rows * cols; k += 4) {\n        float32x4_t vec = vld1q_f32(&dst[k]);\n        vec = vaddq_f32(vec, vdupq_n_f32(0.125f)); // Add 0.125 to round to nearest quarter\n        vec = vrndnq_f32(vec); // Round to nearest integer\n        vec = vmlaq_f32(vdupq_n_f32(0.25f), vec, vdupq_n_f32(0.25f)); // Scale back to quarter\n        vst1q_f32(&dst[k], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vcvtq_f32_s32(vcvtq_s32_f32(result)); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vcvtq_f32_s32(vcvtq_s32_f32(result)); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vcvtq_f32_s32(vcvtq_s32_f32(result)); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vcvtq_f32_s32(vcvtq_s32_f32(result)); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t result = vsubq_f32(v1, v2);\n        result = vcvtq_f32_s32(vcvtq_s32_f32(result)); // Round towards zero\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (float)((int)(tensor1[i] - tensor2[i])) : (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        float64x2_t a = vld1q_f64(&mat1[i]);\n        float64x2_t b = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vec = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_vec);\n        }\n        float32x2_t sum_low = vget_low_f32(sum);\n        float32x2_t sum_high = vget_high_f32(sum);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_low, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vmovq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vec = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_vec);\n        }\n        float32x2_t sum_low = vget_low_f32(sum);\n        float32x2_t sum_high = vget_high_f32(sum);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_low, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_val = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_val);\n        }\n        float32x2_t sum_pair = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        sum_pair = vpadd_f32(sum_pair, sum_pair);\n        dst[i] = vget_lane_f32(sum_pair, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_val = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_val);\n        }\n        float32x2_t sum_low = vget_low_f32(sum);\n        float32x2_t sum_high = vget_high_f32(sum);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_low, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vmovq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vec = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, mat_vec, vec_vec);\n        }\n        float32x2_t sum_low = vget_low_f32(sum);\n        float32x2_t sum_high = vget_high_f32(sum);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_low, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vectorized_elements = total_elements / 4;\n    double sum = 0.0;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vectorized_elements; ++i) {\n        float64x2_t vec1 = vld1q_f64(mat + i * 4);\n        sum_vec = vaddq_f64(sum_vec, vec1);\n    }\n\n    // Horizontal add to sum the elements in sum_vec\n    float64x2_t sum_vec_h = vpaddq_f64(sum_vec, sum_vec);\n    sum += vgetq_lane_f64(sum_vec_h, 0) + vgetq_lane_f64(sum_vec_h, 1);\n\n    // Handle remaining elements\n    for (size_t i = vectorized_elements * 4; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_count = total_elements / 2;\n    size_t remaining_elements = total_elements % 2;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vector_count; ++i) {\n        sum_vec = vaddq_f64(sum_vec, vld1q_f64(mat + i * 2));\n    }\n\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    for (size_t i = total_elements - remaining_elements; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vectorized_elements = total_elements / 4;\n    double sum = 0.0;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vectorized_elements; ++i) {\n        float64x2_t vec1 = vld1q_f64(mat + i * 4);\n        sum_vec = vaddq_f64(sum_vec, vec1);\n    }\n\n    // Horizontal add to get the total sum from the vector\n    double temp[2];\n    vst1q_f64(temp, sum_vec);\n    sum = temp[0] + temp[1];\n\n    // Handle remaining elements\n    for (size_t i = vectorized_elements * 4; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vectorized_elements = total_elements / 4;\n    double sum = 0.0;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vectorized_elements; ++i) {\n        float64x2_t vec1 = vld1q_f64(mat + i * 4);\n        sum_vec = vaddq_f64(sum_vec, vec1);\n    }\n\n    // Horizontal addition of the sum vector\n    double temp[2];\n    vst1q_f64(temp, sum_vec);\n    sum = temp[0] + temp[1];\n\n    // Handle remaining elements\n    for (size_t i = vectorized_elements * 4; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_count = total_elements / 4;\n    size_t remaining_elements = total_elements % 4;\n\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i < vector_count; ++i) {\n        float64x2_t vec1 = vld1q_f64(mat + i * 4);\n        float64x2_t vec2 = vld1q_f64(mat + i * 4 + 2);\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n    }\n\n    double sum_array[2];\n    vst1q_f64(sum_array, sum_vec);\n    double total_sum = sum_array[0] + sum_array[1];\n\n    for (size_t j = 0; j < remaining_elements; ++j) {\n        total_sum += mat[vector_count * 4 + j];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool is_sorted = true;\n\n        if (cols < 2) continue;\n\n        if (directions[r]) { // Ascending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t vec1 = vld1q_s32(row + c);\n                int32x4_t vec2 = vld1q_s32(row + c + 1);\n                int32x4_t cmp = vcltq_s32(vec2, vec1);\n                if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n        } else { // Descending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t vec1 = vld1q_s32(row + c);\n                int32x4_t vec2 = vld1q_s32(row + c + 1);\n                int32x4_t cmp = vcgtq_s32(vec2, vec1);\n                if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (is_sorted) {\n            // Check the last few elements if cols is not a multiple of 4\n            for (size_t c = (cols / 4) * 4; c < cols - 1; ++c) {\n                if ((directions[r] && row[c] > row[c + 1]) || \n                    (!directions[r] && row[c] < row[c + 1])) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!is_sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool is_sorted = true;\n\n        if (directions[r]) { // Ascending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t vec1 = vld1q_s32(row + c);\n                int32x4_t vec2 = vld1q_s32(row + c + 1);\n                is_sorted &= vgetq_lane_u32(vcltq_s32(vec2, vec1), 0) == 0;\n            }\n        } else { // Descending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t vec1 = vld1q_s32(row + c);\n                int32x4_t vec2 = vld1q_s32(row + c + 1);\n                is_sorted &= vgetq_lane_u32(vcgtq_s32(vec2, vec1), 0) == 0;\n            }\n        }\n\n        // Check remaining elements\n        for (size_t c = (cols / 4) * 4; c < cols - 1; ++c) {\n            if (directions[r]) {\n                if (row[c] > row[c + 1]) {\n                    is_sorted = false;\n                    break;\n                }\n            } else {\n                if (row[c] < row[c + 1]) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!is_sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n        bool sorted = true;\n\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t v1 = vld1q_s32(row + c);\n            int32x4_t v2 = vld1q_s32(row + c + 1);\n            int32x4_t cmp = ascending ? vcltq_s32(v2, v1) : vcgtq_s32(v2, v1);\n            uint32x4_t mask = vceqq_u32(cmp, vdupq_n_s32(0));\n\n            if (vmaxvq_u32(mask) != 0) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (sorted && (cols % 4 != 0)) {\n            for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n                if ((ascending && row[c] > row[c + 1]) || (!ascending && row[c] < row[c + 1])) {\n                    sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool is_sorted = true;\n\n        if (cols < 2) continue;\n\n        if (directions[r]) { // Ascending\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t v1 = vld1q_s32(row + c);\n                int32x4_t v2 = vld1q_s32(row + c + 1);\n                is_sorted &= (vmaxvq_s32(v1) <= vmaxvq_s32(v2));\n            }\n        } else { // Descending\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t v1 = vld1q_s32(row + c);\n                int32x4_t v2 = vld1q_s32(row + c + 1);\n                is_sorted &= (vminvq_s32(v1) >= vminvq_s32(v2));\n            }\n        }\n\n        if (!is_sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool is_sorted = true;\n\n        if (directions[r]) { // Ascending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t v1 = vld1q_s32(row + c);\n                int32x4_t v2 = vld1q_s32(row + c + 1);\n                is_sorted &= vgetq_lane_s32(v1, 3) <= vgetq_lane_s32(v2, 0);\n            }\n        } else { // Descending order\n            for (size_t c = 0; c < cols - 4; c += 4) {\n                int32x4_t v1 = vld1q_s32(row + c);\n                int32x4_t v2 = vld1q_s32(row + c + 1);\n                is_sorted &= vgetq_lane_s32(v1, 0) >= vgetq_lane_s32(v2, 3);\n            }\n        }\n\n        if (!is_sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(base);\n    int16x8_t base_minus_one_vec = vdupq_n_s16(base - 1);\n    \n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_vec = vld1q_s16(&src[i]);\n        \n        int16x8_t quotient_vec = vshrq_n_s16(src_vec, 1); // Divide by 2\n        int16x8_t multiple_vec = vqdmulhq_s16(quotient_vec, base_vec); // Multiply by base\n        \n        int16x8_t remainder_vec = vsubq_s16(src_vec, multiple_vec);\n        int16x8_t mask_vec = vcleq_s16(remainder_vec, base_minus_one_vec);\n        \n        multiple_vec = vbslq_s16(mask_vec, multiple_vec, vsubq_s16(multiple_vec, base_vec));\n        \n        vst1q_s16(&dst[i], multiple_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16((int16_t)base);\n    int16x8_t base_minus_one_vec = vdupq_n_s16((int16_t)(base - 1));\n\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t src_vec = vld1q_s16(src + i);\n        int16x8_t remainder_vec = vmodq_s16(src_vec, base_vec);\n        int16x8_t nearest_vec = vsubq_s16(src_vec, remainder_vec);\n        nearest_vec = vaddq_s16(nearest_vec, base_minus_one_vec);\n        nearest_vec = vsubq_s16(nearest_vec, vmodq_s16(nearest_vec, base_vec));\n        vst1q_s16(dst + i, nearest_vec);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(base);\n    int16x8_t base_minus_one_vec = vdupq_n_s16(base - 1);\n    \n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t src_vec = vld1q_s16(&src[i]);\n        \n        int16x8_t div_vec = vshrq_n_s16(src_vec, 1); // Divide by 2\n        int16x8_t mul_vec = vmulq_s16(div_vec, base_vec);\n        int16x8_t nearest_vec = vminq_s16(mul_vec, src_vec);\n        \n        // Calculate the nearest multiple\n        int16x8_t result_vec = vsubq_s16(nearest_vec, vandq_s16(nearest_vec, base_minus_one_vec));\n        \n        vst1q_s16(&dst[i], result_vec);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(static_cast<int16_t>(base));\n    int16x8_t base_minus_one = vdupq_n_s16(static_cast<int16_t>(base - 1));\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t src_vec = vld1q_s16(&src[i]);\n        int16x8_t quotient = vshrq_n_s16(src_vec, 1); // Divide by 2\n        int16x8_t multiple = vqdmulhq_s16(quotient, base_vec); // Multiply by base\n        int16x8_t nearest = vminq_s16(multiple, src_vec); // Ensure it's <= src\n\n        vst1q_s16(&dst[i], nearest);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16((int16_t)base);\n    int16x8_t base_minus_one = vdupq_n_s16((int16_t)(base - 1));\n\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t src_vec = vld1q_s16(&src[i]);\n        int16x8_t quotient = vshrq_n_s16(src_vec, 1); // Divide by 2\n        int16x8_t multiple = vqdmulhq_n_s16(quotient, base_vec); // Multiply by base\n        int16x8_t nearest = vminq_s16(multiple, src_vec); // Ensure it's <= src\n        vst1q_s16(&dst[i], nearest);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n        if (dst[i] > src[i]) {\n            dst[i] -= base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols % 2 != 0) return false; // Ensure cols is even for SIMD\n\n    float64x2_t vec = vld1q_f64(vector);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t mat_row = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(mat_row, vec);\n            uint64x2_t result = vpmax_u64(vreinterpret_u64_u8(cmp), vreinterpret_u64_u8(cmp));\n            if (vgetq_lane_u64(result, 0) != 0 || vgetq_lane_u64(result, 1) != 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols % 2 != 0) return false; // Ensure cols is even for SIMD processing\n\n    float64x2_t vec = vld1q_f64(vector);\n    \n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t mat_row = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(mat_row, vec);\n            uint64x2_t result = vpmax_u64(cmp, cmp);\n            if (vmax_u64(result, result)[0] != 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    float64x2_t vec = vld1q_f64(vector);\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t row1 = vld1q_f64(matrix + i * cols);\n        float64x2_t row2 = vld1q_f64(matrix + i * cols + 2);\n        \n        uint64x2_t cmp1 = vceqq_f64(row1, vec);\n        uint64x2_t cmp2 = vceqq_f64(row2, vec);\n        \n        if (vmax_u64(vget_low_u64(cmp1), vget_high_u64(cmp1)) || \n            vmax_u64(vget_low_u64(cmp2), vget_high_u64(cmp2))) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols % 2 != 0) return false; // Ensure cols is even for SIMD processing\n\n    float64x2_t vec = vld1q_f64(vector);\n    \n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t mat_row = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(mat_row, vec);\n            uint64x2_t result = vand_u64(cmp, vdupq_n_u64(1));\n\n            if (vmax_u64(result) != 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols % 2 != 0) return false; // Ensure cols is even for SIMD processing\n\n    float64x2_t vec = vld1q_f64(vector);\n    \n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t mat_row = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(mat_row, vec);\n            uint64x2_t result = vpmax_u64(cmp, cmp);\n            if (vgetq_lane_u64(result, 0) || vgetq_lane_u64(result, 1)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    // Process 16 elements at a time\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        \n        // Compare elements\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec);\n        \n        // Count the number of equal elements\n        uint64x2_t count_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq_vec)));\n        count += vgetq_lane_u64(count_vec, 0) + vgetq_lane_u64(count_vec, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec);\n        \n        // Sum the number of equal elements\n        uint64x2_t sum_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq_vec)));\n        count += vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    // Process 16 elements at a time\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        \n        // Compare the vectors\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec);\n        \n        // Count the number of equal elements\n        uint64x2_t count_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq_vec)));\n        \n        count += vgetq_lane_u64(count_vec, 0) + vgetq_lane_u64(count_vec, 1);\n    }\n\n    // Handle remaining elements\n    for (size_t i = total_elements - (total_elements % 16); i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    // Process 16 elements at a time\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec);\n        \n        // Count the number of equal elements\n        uint64x2_t sum_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq_vec)));\n        count += vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t eq_vec = vceqq_u8(a_vec, b_vec);\n        \n        // Sum the number of equal elements\n        uint64x2_t sum_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq_vec)));\n        count += vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t a_vec = vdupq_n_s64(a);\n    \n    for (; i <= length - 2; i += 2) {\n        int64x2_t x_vec = vld1q_s64(&x[i]);\n        int64x2_t mul_vec = vmulq_s64(a_vec, x_vec);\n        int64x2_t abs_vec = vabsq_s64(mul_vec);\n        int64x2_t y_vec = vsubq_s64(abs_vec, x_vec);\n        vst1q_s64(&y[i], y_vec);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]) - x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64_t a_vec[2] = {a, a};\n    int64x2_t a_simd = vld1q_s64(a_vec);\n\n    size_t i;\n    for (i = 0; i < length; i += 2) {\n        int64x2_t x_simd = vld1q_s64(&x[i]);\n        int64x2_t mul_simd = vmulq_s64(a_simd, x_simd);\n        int64x2_t abs_simd = vabsq_s64(mul_simd);\n        vst1q_s64(&y[i], abs_simd);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t scalar = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t product = vmulq_s64(scalar, vec_x);\n        int64x2_t abs_y = vabsq_s64(vec_x);\n        int64x2_t result = vsubq_s64(product, abs_y);\n        vst1q_s64(&y[i], result);\n    }\n\n    for (; i < length; i++) {\n        y[i] = a * x[i] - abs(x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t a_vec = vdupq_n_s64(a);\n    size_t i;\n\n    for (i = 0; i < length; i += 2) {\n        int64x2_t x_vec = vld1q_s64(&x[i]);\n        int64x2_t mul_vec = vmulq_s64(a_vec, x_vec);\n        int64x2_t abs_vec = vabsq_s64(mul_vec);\n        vst1q_s64(&y[i], abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t scalar = vdupq_n_s64(a);\n    size_t i;\n\n    for (i = 0; i < length; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n\n        // Scalar-vector multiplication\n        int64x2_t mul_result = vmulq_s64(scalar, vec_x);\n\n        // Absolute value of vector y\n        int64x2_t abs_y = vabsq_s64(vec_y);\n\n        // Element-wise subtraction\n        int64x2_t result = vsubq_s64(mul_result, abs_y);\n\n        // Store the result\n        vst1q_s64(&y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t i;\n\n    // Process 8 elements at a time\n    for (i = 0; i < length / 8 * 8; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        int16x8_t min_v = vminq_s16(v, vdupq_n_s16(result.min_num));\n        int16x8_t max_v = vmaxq_s16(v, vdupq_n_s16(result.max_num));\n        \n        result.min_num = vgetq_lane_s16(min_v, 0);\n        result.max_num = vgetq_lane_s16(max_v, 0);\n        \n        for (int j = 1; j < 8; j++) {\n            result.min_num = vmin_s16(result.min_num, vgetq_lane_s16(min_v, j));\n            result.max_num = vmax_s16(result.max_num, vgetq_lane_s16(max_v, j));\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t i;\n    int16x8_t min_vec = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vec = vdupq_n_s16(INT16_MIN);\n\n    for (i = 0; i + 8 <= length; i += 8) {\n        int16x8_t data = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, data);\n        max_vec = vmaxq_s16(max_vec, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        if (value < vgetq_lane_s16(min_vec, 0)) {\n            min_vec = vsetq_lane_s16(value, min_vec, 0);\n        }\n        if (value > vgetq_lane_s16(max_vec, 0)) {\n            max_vec = vsetq_lane_s16(value, max_vec, 0);\n        }\n    }\n\n    // Compute final min and max\n    result.min_num = vmin_s16(vget_low_s16(min_vec), vget_high_s16(min_vec));\n    result.min_num = vmin_s16(result.min_num, vgetq_lane_s16(min_vec, 0));\n    \n    result.max_num = vmax_s16(vget_low_s16(max_vec), vget_high_s16(max_vec));\n    result.max_num = vmax_s16(result.max_num, vgetq_lane_s16(max_vec, 0));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t i;\n    int16x8_t min_vec = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vec = vdupq_n_s16(INT16_MIN);\n\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t data_vec = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, data_vec);\n        max_vec = vmaxq_s16(max_vec, data_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        if (value < vgetq_lane_s16(min_vec, 0)) {\n            min_vec = vdupq_n_s16(value);\n        }\n        if (value > vgetq_lane_s16(max_vec, 0)) {\n            max_vec = vdupq_n_s16(value);\n        }\n    }\n\n    // Reduce min_vec and max_vec to find final min and max\n    int16_t min_result = vgetq_lane_s16(min_vec, 0);\n    for (int j = 1; j < 8; j++) {\n        min_result = min(min_result, vgetq_lane_s16(min_vec, j));\n    }\n\n    int16_t max_result = vgetq_lane_s16(max_vec, 0);\n    for (int j = 1; j < 8; j++) {\n        max_result = max(max_result, vgetq_lane_s16(max_vec, j));\n    }\n\n    result.min_num = min_result;\n    result.max_num = max_result;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_vec = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vec = vdupq_n_s16(INT16_MIN);\n\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t data = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, data);\n        max_vec = vmaxq_s16(max_vec, data);\n    }\n\n    int16_t min_array[8], max_array[8];\n    vst1q_s16(min_array, min_vec);\n    vst1q_s16(max_array, max_vec);\n\n    int16_t min_num = min_array[0];\n    int16_t max_num = max_array[0];\n    for (int j = 1; j < 8; j++) {\n        min_num = min(min_num, min_array[j]);\n        max_num = max(max_num, max_array[j]);\n    }\n\n    for (; i < length; i++) {\n        min_num = min(min_num, vec[i]);\n        max_num = max(max_num, vec[i]);\n    }\n\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t i;\n    int16x8_t min_vec = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vec = vdupq_n_s16(INT16_MIN);\n\n    for (i = 0; i < length; i += 8) {\n        int16x8_t data_vec = vld1q_s16(&vec[i]);\n        min_vec = vminq_s16(min_vec, data_vec);\n        max_vec = vmaxq_s16(max_vec, data_vec);\n    }\n\n    int16_t min_array[8], max_array[8];\n    vst1q_s16(min_array, min_vec);\n    vst1q_s16(max_array, max_vec);\n\n    for (i = 0; i < 8; i++) {\n        if (min_array[i] < result.min_num) {\n            result.min_num = min_array[i];\n        }\n        if (max_array[i] > result.max_num) {\n            result.max_num = max_array[i];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 1);\n            int32x4_t cmp = vcltq_s32(current, next);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) == 0) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 1);\n            int32x4_t cmp = vcltq_s32(current, next);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) == 0) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 1);\n            int32x4_t cmp = vcltq_s32(current, next);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) == 0) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 1);\n            int32x4_t cmp = vcltq_s32(current, next);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) == 0) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 1);\n            int32x4_t cmp = vcltq_s32(current, next);\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) == 0) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            for (size_t i = 0; i < block_size; ++i) {\n                int32x4_t first_row = vld1q_s32(first_block + i * cols);\n                int32x4_t current_row = vld1q_s32(current_block + i * cols);\n                if (vmaxvq_s32(veceq_s32(first_row, current_row)) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue;\n\n            const int* current_block = matrix + (i * block_size * cols + j * block_size);\n\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; bj += 4) {\n                    int32x4_t first = vld1q_s32(first_block + bi * cols + bj);\n                    int32x4_t current = vld1q_s32(current_block + bi * cols + bj);\n                    uint32x4_t cmp = vceqq_s32(first, current);\n                    if (vmaxvq_u32(cmp) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            if (current_block == first_block) continue;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                int32x4_t first_row = vld1q_s32(first_block + i * cols);\n                int32x4_t current_row = vld1q_s32(current_block + i * cols);\n                \n                if (vmaxvq_s32(veorq_s32(first_row, current_row)) != 0) {\n                    return false;\n                }\n\n                if (block_size % 4 != 0) {\n                    for (size_t j = block_size - (block_size % 4); j < block_size; ++j) {\n                        if (first_block[i * cols + j] != current_block[i * cols + j]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            for (size_t i = 0; i < block_size; ++i) {\n                int32x4_t first_row = vld1q_s32(first_block + i * cols);\n                int32x4_t current_row = vld1q_s32(current_block + i * cols);\n                if (vmaxvq_s32(veceq_s32(first_row, current_row)) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            for (size_t i = 0; i < block_size; ++i) {\n                int32x4_t first_row = vld1q_s32(first_block + i * cols);\n                int32x4_t current_row = vld1q_s32(current_block + i * cols);\n                if (vmaxvq_s32(veceq_s32(first_row, current_row)) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    double64x2_t first_block = vld1q_f64(vec);\n    for (size_t i = block_size; i < length; i += block_size) {\n        double64x2_t current_block = vld1q_f64(vec + i);\n        double64x2_t diff = vsubq_f64(first_block, current_block);\n        double64x2_t abs_diff = vabsq_f64(diff);\n        double64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n        uint64x2_t cmp = vcltq_f64(abs_diff, tolerance_vec);\n        \n        if (vmaxvq_u64(cmp) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    double64x2_t first_block = vld1q_f64(vec);\n    double64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    \n    for (size_t i = block_size; i < length; i += block_size) {\n        double64x2_t current_block = vld1q_f64(vec + i);\n        double64x2_t diff = vsubq_f64(current_block, first_block);\n        double64x2_t abs_diff = vabsq_f64(diff);\n        \n        uint64x2_t cmp = vcltq_f64(abs_diff, tolerance_vec);\n        if (vmaxvq_u64(cmp) == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    double64x1_t first_block = vld1q_f64(vec);\n    double64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    \n    for (size_t i = block_size; i < length; i += block_size) {\n        double64x1_t current_block = vld1q_f64(vec + i);\n        \n        double64x2_t diff = vsubq_f64(current_block, first_block);\n        double64x2_t abs_diff = vabsq_f64(diff);\n        \n        if (vmaxvq_f64(abs_diff) > tolerance) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || (length % block_size) != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    double64x2_t first_block = vld1q_f64(vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        double64x2_t current_block = vld1q_f64(vec + i * block_size);\n        double64x2_t diff = vsubq_f64(current_block, first_block);\n        double64x2_t abs_diff = vabsq_f64(diff);\n        double64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n        uint64x2_t cmp = vcleq_f64(abs_diff, tolerance_vec);\n\n        if (vgetq_lane_u64(cmp, 0) == 0 && vgetq_lane_u64(cmp, 1) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || (length % block_size) != 0) {\n        return false;\n    }\n\n    double64x2_t first_block = vld1q_f64(vec);\n    double64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    \n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        double64x2_t current_block = vld1q_f64(vec + i);\n        double64x2_t diff = vabdq_f64(first_block, current_block);\n        if (vmaxvq_f64(diff) > tolerance) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double64x2_t sum = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            double64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            sum = vmlaq_f64(sum, vec, vec);\n        }\n        double norm = sqrt(vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            sum = vmlaq_f64(sum, vec, vec);\n        }\n        double norm = sqrt(vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double64x2_t sum = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            double64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            sum = vmlaq_f64(sum, vec, vec);\n        }\n        double norm = sqrt(vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double64x2_t sum = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            double64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            sum = vmlaq_f64(sum, vec, vec);\n        }\n        double norm = sqrt(vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double32x4_t sum = vdupq_n_f32(0.0);\n        for (size_t j = 0; j < cols; j += 4) {\n            double32x4_t vec = vld1q_f32(matrix + i * cols + j);\n            sum = vmlaq_f32(sum, vec, vec);\n        }\n        double32x2_t sum_low = vget_low_f32(sum);\n        double32x2_t sum_high = vget_high_f32(sum);\n        sum_low = vadd_f32(sum_low, sum_high);\n        double result_norm = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n        result_norm = sqrt(result_norm);\n        \n        result[i] = result_norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4; i++) {\n        uint32x4_t a = vld1q_u32(A + i * 4);\n        uint32x4_t b = vld1q_u32(B + i * 4);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i * 4, c);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i, c);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4; i++) {\n        uint32x4_t a = vld1q_u32(A + i * 4);\n        uint32x4_t b = vld1q_u32(B + i * 4);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i * 4, c);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i, c);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i, c);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i;\n    for (i = 0; i < length; i += 16) {\n        int16x8_t sum_squares_vec = vdupq_n_s16(0);\n        int16x8_t sum_products_vec = vdupq_n_s16(0);\n\n        int8x16_t a_vec = vld1q_s8(A + i);\n        int8x16_t b_vec = vld1q_s8(B + i);\n\n        int16x8_t a_square_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        int16x8_t a_square_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        sum_squares_vec = vaddq_s16(sum_squares_vec, vaddq_s16(a_square_low, a_square_high));\n\n        int16x8_t b_square_low = vmull_s8(vget_low_s8(b_vec), vget_low_s8(b_vec));\n        int16x8_t b_square_high = vmull_s8(vget_high_s8(b_vec), vget_high_s8(b_vec));\n        sum_squares_vec = vaddq_s16(sum_squares_vec, vaddq_s16(b_square_low, b_square_high));\n\n        int16x8_t product_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        int16x8_t product_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        sum_products_vec = vaddq_s16(sum_products_vec, vaddq_s16(product_low, product_high));\n\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(sum_squares_vec), 0);\n        sum_products += vgetq_lane_s64(vpaddlq_s16(sum_products_vec), 0);\n    }\n\n    return (sum_squares - sum_products);\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i;\n    for (i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int16x8_t a_sq = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        a_sq = vmlal_s8(a_sq, vget_high_s8(a), vget_high_s8(a));\n        \n        int16x8_t b_sq = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n        b_sq = vmlal_s8(b_sq, vget_high_s8(b), vget_high_s8(b));\n\n        int16x8_t prod = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n        prod = vmlal_s8(prod, vget_high_s8(a), vget_high_s8(b));\n\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(a_sq), 0) + vgetq_lane_s64(vpaddlq_s16(b_sq), 0);\n        sum_products += vgetq_lane_s64(vpaddlq_s16(prod), 0);\n    }\n\n    for (; i < length; i++) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i;\n    for (i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int16x8_t a_sq = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        a_sq = vmlal_s8(a_sq, vget_high_s8(a), vget_high_s8(a));\n        \n        int16x8_t b_sq = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n        b_sq = vmlal_s8(b_sq, vget_high_s8(b), vget_high_s8(b));\n\n        int16x8_t prod = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n        prod = vmlal_s8(prod, vget_high_s8(a), vget_high_s8(b));\n\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(a_sq), 0) + vgetq_lane_s64(vpaddlq_s16(b_sq), 0);\n        sum_products += vgetq_lane_s64(vpaddlq_s16(prod), 0);\n    }\n\n    for (; i < length; ++i) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int16x8_t a_squared = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        a_squared = vmlal_s8(a_squared, vget_high_s8(a), vget_high_s8(a));\n\n        int16x8_t b_squared = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n        b_squared = vmlal_s8(b_squared, vget_high_s8(b), vget_high_s8(b));\n\n        int16x8_t product = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n        product = vmlal_s8(product, vget_high_s8(a), vget_high_s8(b));\n\n        sum_of_squares += vgetq_lane_s64(vpaddlq_s16(a_squared), 0);\n        sum_of_squares += vgetq_lane_s64(vpaddlq_s16(b_squared), 0);\n        sum_of_products += vgetq_lane_s64(vpaddlq_s16(product), 0);\n    }\n\n    for (; i < length; i++) {\n        sum_of_squares += A[i] * A[i] + B[i] * B[i];\n        sum_of_products += A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i;\n    for (i = 0; i < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int16x8_t a_sq_low = vmull_s8(vget_low_s8(a), vget_low_s8(a));\n        int16x8_t a_sq_high = vmull_s8(vget_high_s8(a), vget_high_s8(a));\n        int16x8_t b_sq_low = vmull_s8(vget_low_s8(b), vget_low_s8(b));\n        int16x8_t b_sq_high = vmull_s8(vget_high_s8(b), vget_high_s8(b));\n\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(a_sq_low), 0);\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(a_sq_high), 0);\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(b_sq_low), 0);\n        sum_squares += vgetq_lane_s64(vpaddlq_s16(b_sq_high), 0);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(a), vget_low_s8(b));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(a), vget_high_s8(b));\n\n        sum_products += vgetq_lane_s64(vpaddlq_s16(prod_low), 0);\n        sum_products += vgetq_lane_s64(vpaddlq_s16(prod_high), 0);\n    }\n\n    return (sum_squares - sum_products);\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t b_neg = vmvnq_u64(b);\n        uint64x2_t c = vandq_u64(a, b_neg);\n        vst1q_u64(&C[i], c);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 2; i++) {\n        uint64x2_t a = vld1q_u64(A + 2 * i);\n        uint64x2_t b = vld1q_u64(B + 2 * i);\n        uint64x2_t result = vandq_u64(a, vmvnq_u64(b));\n        vst1q_u64(C + 2 * i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t b_neg = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, b_neg);\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t b_neg = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, b_neg);\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(A + i);\n        uint64x2_t b = vld1q_u64(B + i);\n        uint64x2_t b_neg = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, b_neg);\n        vst1q_u64(C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n        \n        uint8x16_t result_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t result_neg = vandq_u8(a_neg, b_neg);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(result_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(result_neg, vdupq_n_s8(-1), result);\n        \n        vst1q_s8(C + i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t result_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t result_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(result_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(result_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n        \n        uint8x16_t result_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t result_neg = vandq_u8(a_neg, b_neg);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(result_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(result_neg, vdupq_n_s8(-1), result);\n        \n        vst1q_s8(C + i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t result_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t result_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(result_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(result_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Keep the midpoint value from A\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint with AND\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    // Process elements before the midpoint with XOR\n    for (i = 0; i < midpoint / 8 * 8; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Store the midpoint value from A\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint with AND\n    for (i = midpoint + 1; i < length / 8 * 8; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t xor_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, xor_vec);\n    }\n\n    // Store the midpoint value from A\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t and_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, and_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    // Process elements before the midpoint with XOR\n    for (i = 0; i < midpoint / 8 * 8; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Store the midpoint value from A\n    if (length % 2 == 0 && midpoint > 0) {\n        C[midpoint - 1] = A[midpoint - 1];\n    }\n\n    // Process elements after the midpoint with AND\n    for (i = midpoint; i < length / 8 * 8; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    // Process elements before the midpoint\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (; i < length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t result_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t cond1_true = vshlq_n_u32(cond1_vec, 1);\n        uint32x4_t cond2_true = vshlq_n_u32(cond2_vec, 1);\n\n        uint32x4_t select_A = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t select_B = vandq_u32(cond1_vec, vmvnq_u32(cond2_vec));\n        uint32x4_t select_C = vandq_u32(vmvnq_u32(cond1_vec), cond2_vec);\n        uint32x4_t select_D = vandq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n\n        float32x4_t result = vbslq_f32(select_A, A_vec, vbslq_f32(select_B, B_vec, vbslq_f32(select_C, C_vec, D_vec)));\n\n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t cond1_true = vandq_u32(cond1_vec, vdupq_n_u32(1));\n        uint32x4_t cond2_true = vandq_u32(cond2_vec, vdupq_n_u32(1));\n\n        float32x4_t out_vec = vbslq_f32(cond1_true, A_vec, B_vec);\n        out_vec = vbslq_f32(cond2_true, C_vec, out_vec);\n        out_vec = vbslq_f32(vandq_u32(vnotq_u32(cond1_true), vnotq_u32(cond2_true)), D_vec, out_vec);\n\n        vst1q_f32(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t cond1_true = vshlq_n_u32(cond1_vec, 1);\n        uint32x4_t cond2_true = vshlq_n_u32(cond2_vec, 1);\n\n        uint32x4_t select_A = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t select_B = vandq_u32(cond1_vec, vmvnq_u32(cond2_vec));\n        uint32x4_t select_C = vandq_u32(vmvnq_u32(cond1_vec), cond2_vec);\n        uint32x4_t select_D = vandq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n\n        float32x4_t result = vbslq_f32(select_A, A_vec, vbslq_f32(select_B, B_vec, vbslq_f32(select_C, C_vec, D_vec)));\n        \n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = cond1[i] ? (cond2[i] ? A[i] : B[i]) : (cond2[i] ? C[i] : D[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t cond1_true = vshlq_n_u32(cond1_vec, 1);\n        uint32x4_t cond2_true = vshlq_n_u32(cond2_vec, 1);\n\n        uint32x4_t select_A = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t select_B = vandq_u32(cond1_vec, vmvnq_u32(cond2_vec));\n        uint32x4_t select_C = vandq_u32(vmvnq_u32(cond1_vec), cond2_vec);\n        uint32x4_t select_D = vandq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n\n        float32x4_t result = vbslq_f32(select_A, A_vec, vbslq_f32(select_B, B_vec, vbslq_f32(select_C, C_vec, D_vec)));\n\n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = cond1[i] ? (cond2[i] ? A[i] : B[i]) : (cond2[i] ? C[i] : D[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t cond1_vec = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t cond2_vec = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        float32x4_t A_vec = vld1q_f32(&A[i]);\n        float32x4_t B_vec = vld1q_f32(&B[i]);\n        float32x4_t C_vec = vld1q_f32(&C[i]);\n        float32x4_t D_vec = vld1q_f32(&D[i]);\n\n        uint32x4_t cond1_true = vshlq_n_u32(cond1_vec, 1);\n        uint32x4_t cond2_true = vshlq_n_u32(cond2_vec, 1);\n\n        uint32x4_t select_A = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t select_B = vandq_u32(cond1_vec, vmvnq_u32(cond2_vec));\n        uint32x4_t select_C = vandq_u32(vmvnq_u32(cond1_vec), cond2_vec);\n        uint32x4_t select_D = vandq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n\n        float32x4_t result = vbslq_f32(select_A, A_vec, vbslq_f32(select_B, B_vec, vbslq_f32(select_C, C_vec, D_vec)));\n\n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        out[i] = (cond1[i] && cond2[i]) ? A[i] :\n                  (cond1[i] && !cond2[i]) ? B[i] :\n                  (!cond1[i] && cond2[i]) ? C[i] : D[i];\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&A[i]);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vandq_u32(data, vdupq_n_u32(0x55555555))); // Count bits in odd positions\n        count = vaddq_u32(count, vshrq_n_u32(data, 1));\n        count = vaddq_u32(count, vandq_u32(count, vdupq_n_u32(0x33333333))); // Count bits in pairs\n        count = vaddq_u32(count, vshrq_n_u32(count, 2));\n        count = vaddq_u32(count, vandq_u32(count, vdupq_n_u32(0x0F0F0F0F))); // Count bits in nibbles\n        count = vaddq_u32(count, vshrq_n_u32(count, 4));\n        count = vaddq_u32(count, vandq_u32(count, vdupq_n_u32(0x00FF00FF))); // Count bits in bytes\n        count = vaddq_u32(count, vshrq_n_u32(count, 8));\n        count = vaddq_u32(count, vdupq_n_u32(0x000000FF)); // Final count\n\n        uint8x8_t result = vuzpq_u8(vreinterpret_u8_u32(count), vreinterpret_u8_u32(count))[0];\n        vst1_u8(&out[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        uint32_t data = A[i];\n        uint32_t count = (data & 0x55555555) + ((data >> 1) & 0x55555555);\n        count = (count & 0x33333333) + ((count >> 2) & 0x33333333);\n        count = (count & 0x0F0F0F0F) + ((count >> 4) & 0x0F0F0F0F);\n        count = (count & 0x00FF00FF) + ((count >> 8) & 0x00FF00FF);\n        count = (count & 0x0000FFFF) + (count >> 16);\n        out[i] = static_cast<uint8_t>(count);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vshrq_n_u32(data, 1));\n        count = vaddq_u32(count, vshrq_n_u32(data, 2));\n        count = vaddq_u32(count, vshrq_n_u32(data, 3));\n        count = vaddq_u32(count, vshrq_n_u32(data, 4));\n        count = vaddq_u32(count, vshrq_n_u32(data, 5));\n        count = vaddq_u32(count, vshrq_n_u32(data, 6));\n        count = vaddq_u32(count, vshrq_n_u32(data, 7));\n        count = vaddq_u32(count, vshrq_n_u32(data, 8));\n        count = vaddq_u32(count, vshrq_n_u32(data, 9));\n        count = vaddq_u32(count, vshrq_n_u32(data, 10));\n        count = vaddq_u32(count, vshrq_n_u32(data, 11));\n        count = vaddq_u32(count, vshrq_n_u32(data, 12));\n        count = vaddq_u32(count, vshrq_n_u32(data, 13));\n        count = vaddq_u32(count, vshrq_n_u32(data, 14));\n        count = vaddq_u32(count, vshrq_n_u32(data, 15));\n\n        uint32x2_t sum_low = vadd_u32(vget_low_u32(count), vget_high_u32(count));\n        sum_low = vpadd_u32(sum_low, sum_low);\n        sum_low = vpadd_u32(sum_low, sum_low);\n\n        out[i] = vget_lane_u32(sum_low, 0);\n        out[i + 1] = vget_lane_u32(sum_low, 1);\n        out[i + 2] = vget_lane_u32(sum_low, 2);\n        out[i + 3] = vget_lane_u32(sum_low, 3);\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t data = A[i];\n        out[i] = __builtin_popcount(data);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&A[i]);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vandq_u32(data, vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 1), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 2), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 3), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 4), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 5), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 6), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 7), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 8), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 9), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 10), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 11), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 12), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 13), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 14), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 15), vdupq_n_u32(1)));\n\n        uint32x2_t sum = vadd_u32(vget_low_u32(count), vget_high_u32(count));\n        uint32x2_t result = vpadd_u32(sum, sum);\n        out[i] = vget_lane_u32(result, 0);\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t data = A[i];\n        out[i] = (data & 1) + ((data >> 1) & 1) + ((data >> 2) & 1) + ((data >> 3) & 1) +\n                             ((data >> 4) & 1) + ((data >> 5) & 1) + ((data >> 6) & 1) + ((data >> 7) & 1) +\n                             ((data >> 8) & 1) + ((data >> 9) & 1) + ((data >> 10) & 1) + ((data >> 11) & 1) +\n                             ((data >> 12) & 1) + ((data >> 13) & 1) + ((data >> 14) & 1) + ((data >> 15) & 1);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(&A[i]);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vandq_u32(data, vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 1), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 2), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 3), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 4), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 5), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 6), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 7), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 8), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 9), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 10), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 11), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 12), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 13), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 14), vdupq_n_u32(0x1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 15), vdupq_n_u32(0x1)));\n\n        uint32x2_t sum1 = vadd_u32(vget_low_u32(count), vget_high_u32(count));\n        uint32x2_t sum2 = vpadd_u32(sum1, sum1);\n        uint32_t result = vget_lane_u32(sum2, 0);\n\n        out[i] = result > 255 ? 255 : (uint8_t)result;\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t data = A[i];\n        uint8_t count = 0;\n        while (data) {\n            count += data & 1;\n            data >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint32x4_t count = vdupq_n_u32(0);\n\n        count = vaddq_u32(count, vandq_u32(data, vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 1), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 2), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 3), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 4), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 5), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 6), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 7), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 8), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 9), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 10), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 11), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 12), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 13), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 14), vdupq_n_u32(1)));\n        count = vaddq_u32(count, vandq_u32(vshrq_n_u32(data, 15), vdupq_n_u32(1)));\n\n        uint32x2_t sum_low = vadd_u32(vget_low_u32(count), vget_high_u32(count));\n        uint32x2_t sum_high = vpadd_u32(sum_low, sum_low);\n        uint32_t total_count = vget_lane_u32(sum_high, 0);\n\n        out[i] = total_count;\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t data = A[i];\n        uint8_t count = 0;\n        while (data) {\n            count += data & 1;\n            data >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t condition = vandq_u32(vshrq_n_u32(vdupq_n_u32(3), 0), vdupq_n_u32(0xFFFFFFFF));\n        uint32x4_t divisible = vceqq_s32(vandq_s32(a, condition), vdupq_n_s32(0));\n\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(divisible, abs_a, a);\n\n        vst1q_s32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    for (i = 0; i < size; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t condition = vandq_u32(vceqq_s32(a, vdupq_n_s32(0)), vdupq_n_u32(1));\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(condition, abs_a, a);\n        vst1q_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t condition = vandq_u32(vceqq_s32(a, vdupq_n_s32(0)), vdupq_n_u32(1));\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(condition, abs_a, a);\n        vst1q_s32(&B[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t condition = vandq_u32(vshrq_n_u32(vdupq_n_u32(3), 0), vshlq_n_u32(vdupq_n_u32(1), 0));\n        uint32x4_t divisible = vceqq_u32(vandq_u32(a, condition), vdupq_n_u32(0));\n\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(divisible, abs_a, a);\n        \n        vst1q_s32(&B[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        uint32x4_t condition = vandq_u32(vshrq_n_u32(vdupq_n_u32(3), 0), vdupq_n_u32(1));\n        uint32x4_t divisible = vdupq_n_u32(3);\n\n        uint32x4_t mod_result = vmodq_u32(a, divisible);\n        uint32x4_t mask = vceqq_u32(mod_result, vdupq_n_u32(0));\n\n        int32x4_t abs_a = vabsq_s32(a);\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n\n        vst1q_s32(&B[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t rotate_mask = vdupq_n_u32(0xF); // Mask for checking low 4 bits\n    uint32x4_t rotate_amount = vdupq_n_u32(rotate_bits);\n    \n    for (i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, rotate_mask);\n        uint32x4_t condition = vceqq_u32(low_bits, rotate_mask);\n        \n        // Rotate right by rotate_bits\n        uint32x4_t rotated = vorrq_u32(vshlq_u32(src_vec, rotate_amount), vshrq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_amount)));\n        \n        // Select between rotated and negated based on condition\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        \n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t rotate_mask = vdupq_n_u32(0xF); // Mask for low 4 bits\n    uint32x4_t rotate_amount = vdupq_n_u32(rotate_bits);\n    \n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low_bits = vandq_u32(src_vec, rotate_mask);\n        uint32x4_t condition = vceqq_u32(low_bits, rotate_mask);\n\n        // Rotate right\n        uint32x4_t rotated = vorrq_u32(vshlq_u32(src_vec, rotate_amount), vshrq_n_u32(src_vec, 32 - rotate_bits));\n\n        // Select between rotated and negated values\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        vst1q_u32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t rotate_mask = vdupq_n_u32(0xF); // Mask for checking low 4 bits\n    uint32x4_t rotate_amount = vdupq_n_u32(rotate_bits); // Rotate amount\n    uint32x4_t src_vec, dst_vec, condition_mask, negated_vec;\n\n    for (i = 0; i < length; i += 4) {\n        // Load 4 elements from src\n        src_vec = vld1q_u32(src + i);\n        \n        // Check if low 4 bits are all 1\n        condition_mask = vandq_u32(src_vec, rotate_mask);\n        condition_mask = vceqq_u32(condition_mask, rotate_mask);\n        \n        // Perform rotation\n        uint32x4_t rotated_vec = vorrq_u32(vshlq_u32(src_vec, rotate_amount), vshrq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_amount)));\n        \n        // Negate src_vec\n        negated_vec = vmvnq_u32(src_vec);\n        \n        // Select between rotated and negated based on condition\n        dst_vec = vbslq_u32(condition_mask, rotated_vec, negated_vec);\n        \n        // Store the result in dst\n        vst1q_u32(dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t rotate_mask = vdupq_n_u32(0xF); // Mask for low 4 bits\n    uint32x4_t rotate_amount = vdupq_n_u32(rotate_bits);\n    \n    for (i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, rotate_mask);\n        uint32x4_t condition = vceqq_u32(low_bits, rotate_mask); // Check if low 4 bits are all 1\n\n        // Rotate src_vec right by rotate_bits\n        uint32x4_t rotated = vorrq_u32(vshrq_n_u32(src_vec, rotate_bits), vshlq_n_u32(src_vec, 32 - rotate_bits));\n\n        // Select between rotated and negated based on condition\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t rotate_mask = vdupq_n_u32(0x0F); // Mask for low 4 bits\n    uint32x4_t rotate_amount = vdupq_n_u32(rotate_bits);\n    \n    for (i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, rotate_mask);\n        uint32x4_t condition = vceqq_u32(low_bits, rotate_mask);\n        \n        uint32x4_t rotated = vorrq_u32(vshlq_u32(src_vec, rotate_amount), \n                                       vshrq_n_u32(src_vec, 32 - rotate_bits));\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(a, b);\n        float32x4_t abs_diff = vabsq_f32(diff);\n\n        uint32x4_t greater = vcgtq_f32(diff, epsilon_vec);\n        uint32x4_t less = vcltq_f32(diff, vnegq_f32(epsilon_vec));\n        uint32x4_t equal = vcleq_f32(abs_diff, epsilon_vec);\n\n        int32x4_t result = vdupq_n_s32(0);\n        result = vbslq_s32(greater, vdupq_n_s32(1), result);\n        result = vbslq_s32(less, vdupq_n_s32(-1), result);\n\n        vst1q_s32((int32_t*)(out + i), result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n\n        uint32x4_t greater_than = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t less_than = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n        \n        int32x4_t result = vdupq_n_s32(0);\n        result = vbslq_int32(greater_than, vdupq_n_s32(1), result);\n        result = vbslq_int32(less_than, vdupq_n_s32(-1), result);\n\n        vst1q_s8(out + i, vqmovn_s32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n\n        uint32x4_t greater_than_epsilon = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t less_than_neg_epsilon = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n\n        int32x4_t result = vdupq_n_s32(0);\n        result = vbslq_int32(greater_than_epsilon, vdupq_n_s32(1), result);\n        result = vbslq_int32(less_than_neg_epsilon, vdupq_n_s32(-1), result);\n\n        int8x16_t out_vec = vreinterpretq_s8_u32(vshlq_n_u32(vreinterpretq_u32_s32(result), 24));\n        vst1q_s8(out + i, out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    \n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n        \n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n        uint32x4_t greater_vec = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t less_vec = vcltq_f32(diff_vec, vnegq_f32(epsilon_vec));\n        \n        int8x8_t result_vec = vdup_n_s8(0);\n        result_vec = vbslx8(greater_vec, vdup_n_s8(1), result_vec);\n        result_vec = vbslx8(less_vec, vdup_n_s8(-1), result_vec);\n        \n        vst1_s8(out + i, vget_low_s8(result_vec));\n        vst1_s8(out + i + 4, vget_high_s8(result_vec));\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t epsilon_vec = vdupq_n_f32(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(a, b);\n        \n        float32x4_t abs_diff = vabsq_f32(diff);\n        uint32x4_t greater_than = vcgtq_f32(diff, epsilon_vec);\n        uint32x4_t less_than = vcltq_f32(diff, vnegq_f32(epsilon_vec));\n        \n        int32x4_t result = vdupq_n_s32(0);\n        result = vbslq_int32(greater_than, vdupq_n_s32(1), result);\n        result = vbslq_int32(less_than, vdupq_n_s32(-1), result);\n        \n        vst1q_s8(out + i, vqmovn_s32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n    \n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(A + i);\n        vec = vmaxq_f32(vec, min_float);\n        vec = vminq_f32(vec, max_float);\n        int32x4_t result = vcvtq_s32_f32(vec);\n        vst1q_s32(B + i, result);\n    }\n    \n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n    float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t src = vld1q_f32(A + i);\n        src = vmaxq_f32(src, min_val);\n        src = vminq_f32(src, max_val);\n        int32x4_t dst = vcvtq_s32_f32(src);\n        vst1q_s32(B + i, dst);\n    }\n\n    for (; i < size; ++i) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_val = vdupq_n_f32(INT32_MAX);\n    float32x4_t min_val = vdupq_n_f32(INT32_MIN);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t src = vld1q_f32(A + i);\n        src = vmaxq_f32(src, min_val);\n        src = vminq_f32(src, max_val);\n        int32x4_t dst = vcvtq_s32_f32(src);\n        vst1q_s32(B + i, dst);\n    }\n\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n    float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t src = vld1q_f32(A + i);\n        src = vmaxq_f32(src, min_val);\n        src = vminq_f32(src, max_val);\n        int32x4_t dst = vcvtq_s32_f32(src);\n        vst1q_s32(B + i, dst);\n    }\n\n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n    \n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(A + i);\n        vec = vmaxq_f32(vec, min_float);\n        vec = vminq_f32(vec, max_float);\n        int32x4_t result = vcvtq_s32_f32(vec);\n        vst1q_s32(B + i, result);\n    }\n    \n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (; i <= size - 4; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vcvtq_f32_s32(scale_vec));\n        vst1q_f32(B + i, b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i]) * static_cast<float>(scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vcvtq_f32_s32(scale_vec));\n        vst1q_f32(&B[i], b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i]) * static_cast<float>(scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (; i <= size - 4; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vcvtq_f32_s32(scale_vec));\n        vst1q_f32(&B[i], b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i]) * static_cast<float>(scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (i = 0; i < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vcvtq_f32_s32(scale_vec));\n        vst1q_f32(&B[i], b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (; i <= size - 4; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vcvtq_f32_s32(scale_vec));\n        vst1q_f32(&B[i], b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i]) * static_cast<float>(scale);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t result = vdivq_f32(a, b);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f)); // Round to nearest\n        int32x4_t rounded = vcvtq_s32_f32(result);\n        vst1q_s32(C + i, rounded);\n    }\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(A[i] / B[i] + 0.5f); // Handle remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t result = vdivq_f32(a, b);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f)); // Round to nearest\n        int32x4_t rounded = vcvtq_s32_f32(result); // Convert to int32\n        vst1q_s32(&C[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t result = vdivq_f32(a, b);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f)); // Add 0.5 for rounding\n        int32x4_t rounded = vcvtq_s32_f32(result); // Convert to int32\n        vst1q_s32(&C[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t result = vdivq_f32(a, b);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f)); // Round to nearest\n        int32x4_t rounded = vcvtq_s32_f32(result);\n        vst1q_s32(&C[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t result = vdivq_f32(a, b);\n        int32x4_t rounded = vcvtq_s32_f32(result);\n        vst1q_s32(&C[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t d = vld1q_f64(&A[i]);\n        float32x4_t f = vcvtq_f32_f64(d);\n\n        float32x4_t max_val = vdupq_n_f32(max_float);\n        float32x4_t min_val = vdupq_n_f32(min_float);\n\n        f = vminq_f32(f, max_val);\n        f = vmaxq_f32(f, min_val);\n\n        vst1q_f32(&B[i], f);\n    }\n\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > max_float) {\n            B[i] = max_float;\n        } else if (val < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t d = vld1q_f64(&A[i]);\n        float32x4_t f = vcvtq_f32_f64(d);\n\n        float32x4_t max_val = vdupq_n_f32(max_float);\n        float32x4_t min_val = vdupq_n_f32(min_float);\n\n        f = vminq_f32(f, max_val);\n        f = vmaxq_f32(f, min_val);\n\n        vst1q_f32(&B[i], f);\n    }\n\n    for (; i < size; i++) {\n        double value = A[i];\n        if (value > max_float) {\n            B[i] = max_float;\n        } else if (value < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t d = vld1q_f64(&A[i]);\n        float32x4_t f = vcvtq_f32_f64(d);\n        \n        // Saturate values\n        float32x4_t max_val = vdupq_n_f32(max_float);\n        float32x4_t min_val = vdupq_n_f32(min_float);\n        \n        f = vminq_f32(f, max_val);\n        f = vmaxq_f32(f, min_val);\n        \n        vst1q_f32(&B[i], f);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        double value = A[i];\n        if (value > max_float) {\n            B[i] = max_float;\n        } else if (value < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t d_vals = vld1q_f64(A + i);\n        float32x4_t f_vals = vcvtq_f32_f64(d_vals);\n\n        // Saturate values\n        float32x4_t saturated_vals = vminq_f32(vmaxq_f32(f_vals, vdupq_n_f32(min_float)), vdupq_n_f32(max_float));\n\n        vst1q_f32(B + i, saturated_vals);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > max_float) {\n            B[i] = max_float;\n        } else if (val < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t d = vld1q_f64(A + i);\n        float32x4_t f = vcvtq_f32_f64(d);\n\n        float32x4_t saturated = vminq_f32(vmaxq_f32(f, vdupq_n_f32(min_float)), vdupq_n_f32(max_float));\n        vst1q_f32(B + i, saturated);\n    }\n\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > max_float) {\n            B[i] = max_float;\n        } else if (val < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec_a = vld1q_s16(A + i);\n        int32x4_t vec_low = vmovl_s16(vget_low_s16(vec_a));\n        int32x4_t vec_high = vmovl_s16(vget_high_s16(vec_a));\n        vst1q_s32(B + i, vec_low);\n        vst1q_s32(B + i + 4, vec_high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size / 8; i++) {\n        int16x8_t vec = vld1q_s16(A + i * 8);\n        int32x4_t low = vmovl_s16(vget_low_s16(vec));\n        int32x4_t high = vmovl_s16(vget_high_s16(vec));\n        vst1q_s32(B + i * 8, low);\n        vst1q_s32(B + i * 8 + 4, high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size / 8; i++) {\n        int16x8_t vec = vld1q_s16(A + i * 8);\n        int32x4_t low = vmovl_s16(vget_low_s16(vec));\n        int32x4_t high = vmovl_s16(vget_high_s16(vec));\n        vst1q_s32(B + i * 8, low);\n        vst1q_s32(B + i * 8 + 4, high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(A + i);\n        int32x4_t low = vmovl_s16(vget_low_s16(vec));\n        int32x4_t high = vmovl_s16(vget_high_s16(vec));\n        vst1q_s32(B + i, low);\n        vst1q_s32(B + i + 4, high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size / 8; i++) {\n        int16x8_t vec = vld1q_s16(A + i * 8);\n        int32x4_t low = vmovl_s16(vget_low_s16(vec));\n        int32x4_t high = vmovl_s16(vget_high_s16(vec));\n        vst1q_s32(B + i * 8, low);\n        vst1q_s32(B + i * 8 + 4, high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t max_val_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vsubq_f32(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n        \n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n        \n        // Normalize A if control > 0\n        float32x4_t normalized = vsubq_f32(A_vec, min_val_vec);\n        normalized = vdivq_f32(normalized, range_vec);\n        normalized = vmaxq_f32(normalized, vdupq_n_f32(0.0f));\n        normalized = vminq_f32(normalized, vdupq_n_f32(1.0f));\n        \n        // Select between normalized and original A based on control\n        float32x4_t result = vbslq_f32(mask, normalized, A_vec);\n        \n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t max_val_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vsubq_f32(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n        \n        // Check control values\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n        \n        // Normalize values where control > 0\n        float32x4_t normalized = vsubq_f32(A_vec, min_val_vec);\n        normalized = vdivq_f32(normalized, range_vec);\n        \n        // Clamp values to [0, 1]\n        normalized = vmaxq_f32(normalized, vdupq_n_f32(0.0f));\n        normalized = vminq_f32(normalized, vdupq_n_f32(1.0f));\n        \n        // Select between normalized and original values based on control\n        float32x4_t result = vbslq_f32(mask, normalized, A_vec);\n        \n        // Store the result\n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t max_val_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vsubq_f32(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n        \n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n        \n        float32x4_t normalized = vsubq_f32(A_vec, min_val_vec);\n        normalized = vdivq_f32(normalized, range_vec);\n        normalized = vmaxq_f32(normalized, vdupq_n_f32(0.0f));\n        normalized = vminq_f32(normalized, vdupq_n_f32(1.0f));\n        \n        float32x4_t result = vbslq_f32(mask, normalized, A_vec);\n        \n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t max_val_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vsubq_f32(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n        \n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n        \n        float32x4_t normalized = vsubq_f32(A_vec, min_val_vec);\n        normalized = vdivq_f32(normalized, range_vec);\n        normalized = vmaxq_f32(normalized, vdupq_n_f32(0.0f));\n        normalized = vminq_f32(normalized, vdupq_n_f32(1.0f));\n        \n        float32x4_t result = vbslq_f32(mask, normalized, A_vec);\n        \n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t max_val_vec = vdupq_n_f32(max_val);\n    float32x4_t range_vec = vsubq_f32(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t control_vec = vld1q_s32(control + i);\n        float32x4_t A_vec = vld1q_f32(A + i);\n        \n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n        \n        // Normalization\n        float32x4_t normalized = vsubq_f32(A_vec, min_val_vec);\n        normalized = vdivq_f32(normalized, range_vec);\n        normalized = vmaxq_f32(normalized, vdupq_n_f32(0.0f));\n        normalized = vminq_f32(normalized, vdupq_n_f32(1.0f));\n        \n        // Select between normalized and original based on control\n        float32x4_t result = vbslq_f32(mask, normalized, A_vec);\n        \n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(B + i, sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a_vec, 16);\n        float32x4_t float_vec = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        vst1q_f32(B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(data, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(a_vec, 16);\n        float32x4_t float_vec = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        vst1q_f32(B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        float32x4_t fvec = vreinterpretq_f32_u32(vec);\n        vst1q_f32(B + i, fvec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        float32x4_t fvec = vreinterpretq_f32_u32(vec);\n        vst1q_f32(B + i, fvec);\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(&A[i]);\n        float32x4_t b_vec = vreinterpretq_f32_u32(a_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = reinterpret_cast<const float*>(&A[i])[0];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size / 4 * 4; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(&A[i]);\n        float32x4_t b_vec = vreinterpretq_f32_u32(a_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        float32x4_t b_vec = vreinterpretq_f32_u32(a_vec);\n        vst1q_f32(B + i, b_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t condition = vld1q_u32((const uint32_t*)&cond[i]);\n\n        int32x4_t diff_vec = vsubq_s32(a_curr, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_vec);\n\n        // Mask the results based on the condition\n        uint32x4_t mask = vceqq_u32(condition, vdupq_n_u32(1));\n        float32x4_t result = vbslq_f32(mask, diff_float, vdupq_n_f32(0.0f));\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t condition = vld1q_u32((const uint32_t*)&cond[i]);\n\n        int32x4_t diff_vec = vsubq_s32(a_curr, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_vec);\n\n        float32x4_t result = vbslq_f32(condition, diff_float, vdupq_n_f32(0.0f));\n        vst1q_f32(&diff[i], result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n    size_t i = 1;\n\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t condition = vld1q_u32((const uint32_t*)&cond[i]);\n\n        int32x4_t diff_vec = vsubq_s32(a_curr, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_vec);\n\n        // Set diff to 0.0f where condition is false\n        uint32x4_t mask = vceqq_u32(condition, vdupq_n_u32(1));\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(mask, diff_float, zero_vec);\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t diff_vec = vsubq_s32(a_curr, a_prev);\n\n        uint32x4_t cond_vec = vld1q_u32((const uint32_t*)&cond[i]);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_vec);\n\n        // Set diff to 0.0f where cond is false\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(cond_vec, diff_float, zero_vec);\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f; // First element is always 0.0f\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t condition = vld1q_u32((const uint32_t*)&cond[i]);\n\n        int32x4_t diff_vec = vsubq_s32(a_curr, a_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_vec);\n\n        // Set diff to 0.0f where condition is false\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t result = vbslq_f32(condition, diff_float, zero_vec);\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t high_vec = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t low_vec2 = vmovl_u32(vget_high_u32(src_vec));\n        \n        vst1q_u64(dst + i, vorrq_u64(low_vec, high_vec));\n        vst1q_u64(dst + i + 2, vorrq_u64(low_vec2, high_vec));\n    }\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high_vec = vmovl_u32(vget_high_u32(src_vec));\n        \n        low_vec = vorrq_u64(low_vec, vshlq_n_u64(vdupq_n_u64(1), 32));\n        high_vec = vorrq_u64(high_vec, vshlq_n_u64(vdupq_n_u64(1), 32));\n        \n        vst1q_u64(dst + i, low_vec);\n        vst1q_u64(dst + i + 2, high_vec);\n    }\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | ((uint64_t)1 << 32));\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t high_vec = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t low_vec2 = vmovl_u32(vget_high_u32(src_vec));\n        \n        vst1q_u64(dst + i, vorrq_u64(low_vec, high_vec));\n        vst1q_u64(dst + i + 2, vorrq_u64(low_vec2, high_vec));\n    }\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high_vec = vmovl_u32(vget_high_u32(src_vec));\n        \n        low_vec = vorrq_u64(low_vec, vshlq_n_u64(vdupq_n_u64(1), 32));\n        high_vec = vorrq_u64(high_vec, vshlq_n_u64(vdupq_n_u64(1), 32));\n        \n        vst1q_u64(dst + i, low_vec);\n        vst1q_u64(dst + i + 2, high_vec);\n    }\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i] | ((uint64_t)1 << 32));\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high_vec = vmovl_u32(vget_high_u32(src_vec));\n        \n        low_vec = vorrq_u64(low_vec, vdupq_n_u64(0xFFFFFFFF00000000));\n        high_vec = vorrq_u64(high_vec, vdupq_n_u64(0xFFFFFFFF00000000));\n        \n        vst1q_u64(dst + i, low_vec);\n        vst1q_u64(dst + i + 2, high_vec);\n    }\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double32x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        float64x2_t vals = vld1q_f64(&vec[vgetq_lane_s16(idx, 0)]);\n        sum_vec = vaddq_f64(sum_vec, vals);\n        \n        if (i + 1 < length) {\n            vals = vld1q_f64(&vec[vgetq_lane_s16(idx, 1)]);\n            sum_vec = vaddq_f64(sum_vec, vals);\n        }\n    }\n    \n    double result[2];\n    vst1q_f64(result, sum_vec);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 indices at a time\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]); // Load 2 indices\n        float64x2_t vec_vals = vld1q_f64(&vec[vgetq_lane_s16(idx, 0)]); // Load vec[index[i]]\n        vec_vals = vmlaq_f64(vec_vals, vld1q_f64(&vec[vgetq_lane_s16(idx, 1)]), vdupq_n_f64(1.0)); // Load vec[index[i + 1]] and sum\n        sum += vgetq_lane_f64(vec_vals, 0) + vgetq_lane_f64(vec_vals, 1); // Accumulate the sum\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 indices at a time\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]); // Load 2 indices\n        float64x2_t vec_vals = vld1q_f64(&vec[vgetq_lane_s16(idx, 0)]); // Load vec[index[i]]\n        vec_vals = vmlaq_f64(vec_vals, vld1q_f64(&vec[vgetq_lane_s16(idx, 1)]), vdupq_n_f64(1.0)); // Load vec[index[i+1]] and sum\n        sum += vgetq_lane_f64(vec_vals, 0) + vgetq_lane_f64(vec_vals, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 indices at a time\n    for (; i <= length - 2; i += 2) {\n        int16x8_t idx = vld1q_s16(&index[i]); // Load 2 indices\n        float64x2_t vec_values = vld1q_f64(&vec[vgetq_lane_s16(idx, 0)]); // Load vec[index[i]]\n        vec_values = vmlaq_f64(vec_values, vld1q_f64(&vec[vgetq_lane_s16(idx, 1)]), vdupq_n_f64(1.0)); // Load vec[index[i+1]] and sum\n        sum += vgetq_lane_f64(vec_values, 0) + vgetq_lane_f64(vec_values, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    int64_t vector_length = length / 4 * 4; // Process in chunks of 4\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i < vector_length; i += 4) {\n        int16x4_t idx = vld1_s16(index + i); // Load 4 indices\n        float64x2_t vec1 = vld1q_f64(vec + vgetq_lane_s16(idx, 0)); // Load vec[index[i]]\n        float64x2_t vec2 = vld1q_f64(vec + vgetq_lane_s16(idx, 1)); // Load vec[index[i+1]]\n        float64x2_t vec3 = vld1q_f64(vec + vgetq_lane_s16(idx, 2)); // Load vec[index[i+2]]\n        float64x2_t vec4 = vld1q_f64(vec + vgetq_lane_s16(idx, 3)); // Load vec[index[i+3]]\n\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n        sum_vec = vaddq_f64(sum_vec, vec3);\n        sum_vec = vaddq_f64(sum_vec, vec4);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    // Horizontal add the sum_vec\n    sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    float64x2_t input_vec = vld1q_f64(&input[input_index]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[kernel_index]);\n\n                    sum = vmlaq_f64(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_index]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    sum = vmlaq_f64(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    float64x2_t input_vec = vld1q_f64(&input[input_index]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[kernel_index]);\n\n                    sum = vmlaq_f64(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    float64x2_t k = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    float64x2_t x = vld1q_f64(&input[(i + ki) * input_size + (j + kj)]);\n                    sum = vmlaq_f64(sum, k, x);\n                }\n            }\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    float64x2_t k = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    float64x2_t x = vld1q_f64(&input[(i + ki) * input_size + (j + kj)]);\n                    sum = vmlaq_f64(sum, k, x);\n                }\n            }\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            for (int j = i + 1; j < n; j++) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vsubq_f64(vec1, vec2);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                if (vmaxvq_f64(abs_diff) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            for (int j = 0; j < i; j += 2) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vsubq_f64(vec1, vec2);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vcgtq_f64(abs_diff, threshold_vec);\n                if (vmax_u64(cmp) != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            for (int j = i + 1; j < n; j++) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vabdq_f64(vec1, vec2);\n                uint64x2_t cmp = vcgtq_f64(diff, threshold_vec);\n                if (vmax_u64(cmp) != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            for (int j = i + 1; j < n; j++) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vabdq_f64(vec1, vec2);\n                if (vmaxvq_f64(diff) < vgetq_lane_f64(threshold_vec, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            for (int j = i + 1; j < n; j++) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vsubq_f64(vec1, vec2);\n                float64x2_t abs_diff = vabsq_f64(diff);\n                uint64x2_t cmp = vcltq_f64(abs_diff, threshold_vec);\n                if (vmaxvq_u64(cmp) != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t op = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, op);\n        \n        // Check if any element in balance is below zero\n        int32x4_t cmp = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n            return true;\n        }\n    }\n    \n    // Handle remaining elements if size is not a multiple of 4\n    for (int i = size - (size % 4); i < size; ++i) {\n        balance = vaddq_s32(balance, vdupq_n_s32(operations[i]));\n        if (vgetq_lane_s32(balance, 0) < 0 || \n            (size > 1 && vgetq_lane_s32(balance, 1) < 0) ||\n            (size > 2 && vgetq_lane_s32(balance, 2) < 0) ||\n            (size > 3 && vgetq_lane_s32(balance, 3) < 0)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t op = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, op);\n        \n        // Check if any element in balance is below zero\n        uint32x4_t below_zero_mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(below_zero_mask) != 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t op = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, op);\n        \n        if (vminvq_s32(balance) < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t op = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, op);\n        \n        if (vminvq_s32(balance) < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int size = operations.size();\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t op = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, op);\n        \n        // Check if any element in balance is below zero\n        int32x4_t cmp = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    double sum_abs_dev = 0.0;\n\n    // Calculate mean\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Process in chunks of 2 (using double precision)\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n        float64x2_t abs_dev_vec = vabsq_f64(vsubq_f64(vec, mean_vec));\n        sum_abs_dev += vgetq_lane_f64(abs_dev_vec, 0) + vgetq_lane_f64(abs_dev_vec, 1);\n    }\n\n    // Handle any remaining elements\n    for (; i < n; i++) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    double sum_abs_dev = 0.0;\n    int i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n        float64x2_t abs_dev = vabsq_f64(vsubq_f64(vec, mean_vec));\n        sum_abs_dev += vgetq_lane_f64(abs_dev, 0) + vgetq_lane_f64(abs_dev, 1);\n    }\n\n    for (; i < n; ++i) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    double mean = 0.0;\n\n    // Calculate mean\n    for (double num : numbers) {\n        sum += num;\n    }\n    mean = sum / n;\n\n    // Calculate Mean Absolute Deviation using SIMD\n    double32x4_t v_mean = vdupq_n_f32(static_cast<float>(mean));\n    double32x4_t v_sum_abs_diff = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < n; i += 4) {\n        double32x4_t v_nums = vld1q_f32(reinterpret_cast<float*>(&numbers[i]));\n        double32x4_t v_diff = vsubq_f32(v_nums, v_mean);\n        v_diff = vabsq_f32(v_diff);\n        v_sum_abs_diff = vaddq_f32(v_sum_abs_diff, v_diff);\n    }\n\n    float32x4_t v_sum_abs_diff_f32 = vaddq_f32(v_sum_abs_diff, v_sum_abs_diff);\n    float32x2_t v_sum_abs_diff_final = vadd_f32(vget_low_f32(v_sum_abs_diff_f32), vget_high_f32(v_sum_abs_diff_f32));\n    float sum_abs_diff = vget_lane_f32(v_sum_abs_diff_final, 0) + vget_lane_f32(v_sum_abs_diff_final, 1);\n\n    return sum_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    double sum_abs_dev = 0.0;\n    int i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        float64x2_t data = vld1q_f64(&numbers[i]);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n        float64x2_t abs_dev = vabsq_f64(vsubq_f64(data, mean_vec));\n        sum_abs_dev += vgetq_lane_f64(abs_dev, 0) + vgetq_lane_f64(abs_dev, 1);\n    }\n\n    for (; i < n; i++) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    double sum_abs_dev = 0.0;\n    int i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t mean_vec = vdupq_n_f64(mean);\n        float64x2_t abs_dev = vabsq_f64(vsubq_f64(vec, mean_vec));\n        sum_abs_dev += vgetq_lane_f64(abs_dev, 0) + vgetq_lane_f64(abs_dev, 1);\n    }\n\n    for (; i < n; i++) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[i * 2], num_vec);\n        vst1q_s32(&result[i * 2 + 4], delim_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    if (n > 0) {\n        result[new_size - 1] = numbers[n - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t numbers_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[i * 2], numbers_vec);\n        vst1q_s32(&result[i * 2 + 4], delimiter_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    if (n > 0) {\n        result[new_size - 1] = numbers[n - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    int n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result;\n    result.reserve(n + (n - 1)); // Space for original numbers and delimiters\n\n    int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n    int32x4_t numbers_vec;\n    \n    for (size_t i = 0; i < n; i += 4) {\n        size_t count = std::min(4, n - i);\n        numbers_vec = vld1q_s32(&numbers[i]);\n        \n        for (size_t j = 0; j < count; ++j) {\n            result.push_back(vgetq_lane_s32(numbers_vec, j));\n            if (j < count - 1 || (i + count) < n) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t numbers_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[i * 2], numbers_vec);\n        vst1q_s32(&result[i * 2 + 4], delimiter_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    if (n > 0) {\n        result[new_size - 1] = numbers[n - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    \n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[i * 2], num_vec);\n        vst1q_s32(&result[i * 2 + 4], delim_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    if (n > 0) {\n        result[new_size - 1] = numbers[n - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int remainder = size % 8;\n    int loop_count = size / 8;\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_prod = vdupq_n_s16(1);\n\n    for (int i = 0; i < loop_count; i++) {\n        int16x8_t vec = vld1q_s16(&numbers[i * 8]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_prod = vmulq_s16(vec_prod, vec);\n    }\n\n    int16_t sum_array[8];\n    int16_t prod_array[8];\n    vst1q_s16(sum_array, vec_sum);\n    vst1q_s16(prod_array, vec_prod);\n\n    for (int i = 0; i < 8; i++) {\n        sum += sum_array[i];\n        product *= prod_array[i];\n    }\n\n    for (int i = size - remainder; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int32_t length = numbers.size();\n    int32_t vec_length = length / 8;\n    int32_t remainder = length % 8;\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_prod = vdupq_n_s16(1);\n\n    for (int32_t i = 0; i < vec_length; ++i) {\n        int16x8_t vec = vld1q_s16(&numbers[i * 8]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_prod = vmulq_s16(vec_prod, vec);\n    }\n\n    int16_t sum_array[8];\n    int16_t prod_array[8];\n    vst1q_s16(sum_array, vec_sum);\n    vst1q_s16(prod_array, vec_prod);\n\n    for (int32_t i = 0; i < 8; ++i) {\n        sum += sum_array[i];\n        product *= prod_array[i];\n    }\n\n    for (int32_t i = length - remainder; i < length; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    int size = numbers.size();\n    int vector_size = size / 8 * 8; // Process in chunks of 8\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_prod = vdupq_n_s16(1);\n\n    for (int i = 0; i < vector_size; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_prod = vmulq_s16(vec_prod, vec);\n    }\n\n    // Horizontal sum\n    int16x4_t sum_low = vget_low_s16(vec_sum);\n    int16x4_t sum_high = vget_high_s16(vec_sum);\n    sum_low = vadd_s16(sum_low, sum_high);\n    sum_low = vpadd_s16(sum_low, sum_low);\n    sum += vget_lane_s16(sum_low, 0);\n    \n    // Horizontal product\n    int16x4_t prod_low = vget_low_s16(vec_prod);\n    int16x4_t prod_high = vget_high_s16(vec_prod);\n    prod_low = vmul_s16(prod_low, prod_high);\n    prod_low = vpadd_s16(prod_low, prod_low);\n    product *= vget_lane_s16(prod_low, 0);\n    \n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int vector_size = size / 8 * 8; // Process in chunks of 8\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_prod = vdupq_n_s16(1);\n\n    for (int i = 0; i < vector_size; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_prod = vmulq_s16(vec_prod, vec);\n    }\n\n    // Horizontal addition for sum\n    int16x4_t sum_low = vget_low_s16(vec_sum);\n    int16x4_t sum_high = vget_high_s16(vec_sum);\n    sum_low = vadd_s16(sum_low, sum_high);\n    sum_low = vadd_s16(sum_low, vext_s16(sum_low, sum_low, 2));\n    sum += vget_lane_s16(sum_low, 0) + vget_lane_s16(sum_low, 1);\n\n    // Horizontal multiplication for product\n    int16x4_t prod_low = vget_low_s16(vec_prod);\n    int16x4_t prod_high = vget_high_s16(vec_prod);\n    prod_low = vmul_s16(prod_low, prod_high);\n    prod_low = vmul_s16(prod_low, vext_s16(prod_low, prod_low, 2));\n    product *= vget_lane_s16(prod_low, 0) * vget_lane_s16(prod_low, 1);\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int remainder = size % 8;\n    int vector_size = size - remainder;\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_prod = vdupq_n_s16(1);\n\n    for (int i = 0; i < vector_size; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_prod = vmulq_s16(vec_prod, vec);\n    }\n\n    int16_t sum_array[8];\n    int16_t prod_array[8];\n    vst1q_s16(sum_array, vec_sum);\n    vst1q_s16(prod_array, vec_prod);\n\n    for (int i = 0; i < 8; ++i) {\n        sum += sum_array[i];\n        product *= prod_array[i];\n    }\n\n    for (int i = vector_size; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    int32x4_t current_max = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        \n        if (i + 3 < n) {\n            vst1q_s32(&result[i], current_max);\n        } else {\n            for (int j = i; j < n; j++) {\n                result[j] = vgetq_lane_s32(current_max, 0);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        result[i] = std::max(result[i - 1], result[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    int32x4_t current_max = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        \n        if (i + 3 < n) {\n            vst1q_s32(&result[i], current_max);\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = std::max(result[j - 1], numbers[j]);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = std::max(result[i - 1], result[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    int32x4_t current_max = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        current_max = vmaxq_s32(current_max, input);\n        \n        if (i + 3 < n) {\n            vst1q_s32(&result[i], current_max);\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = vgetq_lane_s32(current_max, 0);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        \n        if (i + 3 < n) {\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = vgetq_lane_s32(max_vec, 0);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = std::max(result[i - 1], result[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        \n        if (i + 3 < n) {\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            for (int j = i; j < n; j++) {\n                result[j] = vgetq_lane_s32(max_vec, 0);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    // Process 16 characters at a time\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vxor);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    // Process 16 characters at a time\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vec_result);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.size();\n    std::string result(length, '0');\n\n    // Process 16 characters at a time\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vxor);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.size();\n    std::string result(length, '0');\n\n    // Process 16 characters at a time\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.c_str() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.c_str() + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    // Process 16 characters at a time\n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vxor);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t index = 0;\n\n    size_t n = strings.size();\n    size_t i = 0;\n\n    // Process 16 strings at a time\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            lengths[j] = strings[i + j].size();\n        }\n\n        uint8x16_t max_lengths = vmaxq_u8(lengths, lengths);\n        uint8x16_t max_index = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            if (lengths[j] > max_length) {\n                max_length = lengths[j];\n                index = i + j;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (; i < n; ++i) {\n        size_t length = strings[i].size();\n        if (length > max_length) {\n            max_length = length;\n            index = i;\n        }\n    }\n\n    return strings[index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    std::string longest_string;\n\n    size_t size = strings.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        for (int j = 0; j < 4; ++j) {\n            lengths = vsetq_lane_u8(strings[i + j].length(), lengths, j);\n        }\n\n        uint8x16_t max_lengths = vmaxq_u8(lengths, lengths);\n        uint8_t max_length_array[16];\n        vst1q_u8(max_length_array, max_lengths);\n        \n        for (int j = 0; j < 4; ++j) {\n            if (max_length_array[j] > max_length) {\n                max_length = max_length_array[j];\n                longest_string = strings[i + j];\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t simd_size = 4; // Process 4 strings at a time\n    size_t i = 0;\n\n    for (; i + simd_size <= num_strings; i += simd_size) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        for (size_t j = 0; j < simd_size; ++j) {\n            lengths = vsetq_lane_u8(strings[i + j].length(), lengths, j);\n        }\n\n        uint8x16_t max_lengths = vmaxq_u8(lengths, lengths);\n        uint8_t max_length_array[16];\n        vst1q_u8(max_length_array, max_lengths);\n        \n        for (size_t j = 0; j < simd_size; ++j) {\n            if (max_length_array[j] > max_length) {\n                max_length = max_length_array[j];\n                max_index = i + j;\n            }\n        }\n    }\n\n    for (; i < num_strings; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t n = strings.size();\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        for (int j = 0; j < 4; ++j) {\n            lengths = vsetq_lane_u8(strings[i + j].length(), lengths, j);\n        }\n\n        uint8x16_t max_lengths = vmaxq_u8(lengths, vdupq_n_u8(max_length));\n        uint8x16_t mask = vceqq_u8(max_lengths, lengths);\n        uint8x16_t indices = vdupq_n_u8(i);\n        indices = vaddq_u8(indices, vdupq_n_u8(0));\n        max_index = vgetq_lane_u8(indices, vmaxvq_u8(mask));\n        max_length = vgetq_lane_u8(max_lengths, 0);\n    }\n\n    for (; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t index = 0;\n\n    size_t size = strings.size();\n    size_t simd_size = 4; // Process 4 strings at a time\n    size_t i = 0;\n\n    for (; i + simd_size <= size; i += simd_size) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        for (size_t j = 0; j < simd_size; ++j) {\n            lengths = vsetq_lane_u8(strings[i + j].length(), lengths, j);\n        }\n\n        uint8x16_t max_lengths = vmaxq_u8(lengths, lengths);\n        uint8x16_t max_index = vdupq_n_u8(0);\n        for (size_t j = 0; j < simd_size; ++j) {\n            if (vgetq_lane_u8(lengths, j) > vgetq_lane_u8(max_lengths, 0)) {\n                max_lengths = vdupq_n_u8(vgetq_lane_u8(lengths, j));\n                max_index = vdupq_n_u8(j);\n            }\n        }\n\n        size_t current_max_length = vgetq_lane_u8(max_lengths, 0);\n        if (current_max_length > max_length) {\n            max_length = current_max_length;\n            index = i + vgetq_lane_u8(max_index, 0);\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            index = i;\n        }\n    }\n\n    return strings[index];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t result = 0;\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (vgetq_lane_u64(va, 0) != 0 && vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vmod = vdupq_n_u64(0);\n        vmod = vmodq_u64(vgetq_lane_u64(va, 0) % vgetq_lane_u64(vb, 0));\n        va = vb;\n        vb = vmod;\n    }\n    \n    result = vgetq_lane_u64(va, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t result = 0;\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (vgetq_lane_u64(va, 0) != 0 && vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t temp = vb;\n        vb = vdupq_n_u64(vgetq_lane_u64(va, 0) % vgetq_lane_u64(vb, 0));\n        va = temp;\n    }\n\n    result = vgetq_lane_u64(va, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t result = 0;\n    uint64_t temp_a = a;\n    uint64_t temp_b = b;\n\n    while (temp_b != 0) {\n        uint64_t temp = temp_b;\n        temp_b = temp_a % temp_b;\n        temp_a = temp;\n    }\n    result = temp_a;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t result = 0;\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (vgetq_lane_u64(va, 0) != 0 && vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vmod = vdupq_n_u64(0);\n        vmod = vmodq_u64(vgetq_lane_u64(va, 0) % vgetq_lane_u64(vb, 0));\n        va = vb;\n        vb = vmod;\n    }\n    \n    result = vgetq_lane_u64(va, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t result = 0;\n\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    \n    result = a;\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n < 2) return {};\n\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair[2];\n\n    for (int i = 0; i < n - 1; i += 4) {\n        float32x4_t a = vld1q_f32(&sorted_numbers[i]);\n        float32x4_t b = vld1q_f32(&sorted_numbers[i + 1]);\n        float32x4_t diff = vabsq_f32(vsubq_f32(b, a));\n\n        uint32x4_t mask = vcltq_f32(diff, min_diff);\n        if (vmaxvq_u32(mask) > 0) {\n            min_diff = vminq_f32(min_diff, diff);\n            closest_pair[0] = a;\n            closest_pair[1] = b;\n        }\n    }\n\n    float min_diff_value = vgetq_lane_f32(min_diff, 0);\n    float closest1 = 0, closest2 = 0;\n\n    for (int i = 0; i < n - 1; ++i) {\n        float diff = std::abs(sorted_numbers[i + 1] - sorted_numbers[i]);\n        if (diff == min_diff_value) {\n            closest1 = sorted_numbers[i];\n            closest2 = sorted_numbers[i + 1];\n            break;\n        }\n    }\n\n    return {std::min(closest1, closest2), std::max(closest1, closest2)};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair[2];\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j++) {\n            float32x4_t vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(vec, vec2));\n            float32x4_t mask = vcgtq_f32(diff, min_diff);\n            if (vmaxvq_u32(vreinterpretq_u32_f32(mask))) {\n                min_diff = vminq_f32(min_diff, diff);\n                closest_pair[0] = vec;\n                closest_pair[1] = vec2;\n            }\n        }\n    }\n\n    float32x4_t min_val = vminq_f32(closest_pair[0], closest_pair[1]);\n    float32x4_t max_val = vmaxq_f32(closest_pair[0], closest_pair[1]);\n\n    std::vector<float> result = {vgetq_lane_f32(min_val, 0), vgetq_lane_f32(max_val, 0)};\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n < 2) return {};\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair[2];\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        for (int j = i; j < n; j++) {\n            if (j != i) {\n                float32x4_t diff = vabsq_f32(vsubq_f32(vec, vdupq_n_f32(numbers[j])));\n                float32x4_t mask = vcgtq_f32(min_diff, diff);\n                min_diff = vbslq_f32(mask, diff, min_diff);\n                closest_pair[0] = vbslq_f32(mask, vec, closest_pair[0]);\n                closest_pair[1] = vbslq_f32(mask, vdupq_n_f32(numbers[j]), closest_pair[1]);\n            }\n        }\n    }\n\n    float min_diff_array[4];\n    vst1q_f32(min_diff_array, min_diff);\n    float closest[2] = {closest_pair[0][0], closest_pair[1][0]};\n    \n    for (int i = 1; i < 4; i++) {\n        if (min_diff_array[i] < min_diff_array[0]) {\n            closest[0] = closest_pair[i][0];\n            closest[1] = closest_pair[i][1];\n        }\n    }\n\n    std::sort(closest, closest + 2);\n    return {closest[0], closest[1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n < 2) return {};\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair[2];\n\n    for (int i = 0; i < n - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        float32x4_t vec2 = vld1q_f32(&numbers[i + 1]);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n        uint32x4_t mask = vcgtq_f32(min_diff, diff);\n        min_diff = vbslq_f32(mask, diff, min_diff);\n\n        for (int j = 0; j < 4; j++) {\n            if (i + j + 1 < n) {\n                float diff_val = numbers[i + j + 1] - numbers[i + j];\n                if (std::abs(diff_val) < vgetq_lane_f32(min_diff, 0)) {\n                    closest_pair[0] = vdupq_n_f32(std::min(numbers[i + j], numbers[i + j + 1]));\n                    closest_pair[1] = vdupq_n_f32(std::max(numbers[i + j], numbers[i + j + 1]));\n                }\n            }\n        }\n    }\n\n    float closest[2] = {vgetq_lane_f32(closest_pair[0], 0), vgetq_lane_f32(closest_pair[1], 0)};\n    return {closest[0], closest[1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n < 2) return {};\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair[2];\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        for (int j = i; j < n; j++) {\n            if (j == i) continue;\n            float32x4_t diff = vabsq_f32(vsubq_f32(vec, vdupq_n_f32(numbers[j])));\n            min_diff = vminq_f32(min_diff, diff);\n            if (vgetq_lane_f32(min_diff, 0) == vgetq_lane_f32(diff, 0)) {\n                closest_pair[0] = vec;\n                closest_pair[1] = vdupq_n_f32(numbers[j]);\n            }\n        }\n    }\n\n    float closest[4];\n    vst1q_f32(closest, closest_pair[0]);\n    float min_diff_val = vgetq_lane_f32(min_diff, 0);\n    \n    std::vector<float> result;\n    for (int i = 0; i < 4; i++) {\n        if (closest[i] != 0 && std::abs(closest[i] - closest_pair[1][0]) == min_diff_val) {\n            result.push_back(std::min(closest[i], closest_pair[1][0]));\n            result.push_back(std::max(closest[i], closest_pair[1][0]));\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(numbers.size());\n    int size = numbers.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t min_vec = vdupq_n_f32(min_val);\n        float32x4_t range_vec = vdupq_n_f32(range);\n        \n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range_vec);\n        \n        vst1q_f32(&result[i], vec);\n    }\n\n    for (; i < size; i++) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t range_vec = vdupq_n_f32(range);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&numbers[i]);\n        input_vec = vsubq_f32(input_vec, min_vec);\n        input_vec = vdivq_f32(input_vec, range_vec);\n        vst1q_f32(&result[i], input_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    float32x4_t min_val = vdupq_n_f32(*std::min_element(numbers.begin(), numbers.end()));\n    float32x4_t max_val = vdupq_n_f32(*std::max_element(numbers.begin(), numbers.end()));\n    float32x4_t range = vsubq_f32(max_val, min_val);\n\n    std::vector<float> result(size);\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_val);\n        vec = vdivq_f32(vec, range);\n        vst1q_f32(&result[i], vec);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t range_vec = vdupq_n_f32(range);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&numbers[i]);\n        float32x4_t scaled_vec = vsubq_f32(input_vec, min_vec);\n        scaled_vec = vdivq_f32(scaled_vec, range_vec);\n        vst1q_f32(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    float32x4_t min_val = vdupq_n_f32(*std::min_element(numbers.begin(), numbers.end()));\n    float32x4_t max_val = vdupq_n_f32(*std::max_element(numbers.begin(), numbers.end()));\n    float32x4_t range = vsubq_f32(max_val, min_val);\n\n    std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t input = vld1q_f32(&numbers[i]);\n        float32x4_t adjusted = vsubq_f32(input, min_val);\n        float32x4_t scaled = vdivq_f32(adjusted, range);\n        vst1q_f32(&result[i], scaled);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 0; // No divisors less than n for n <= 2\n\n    uint64_t largest_divisor = 1;\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisor_vec = vdupq_n_u64(1);\n\n    for (uint64_t i = 2; i < n; i += 2) {\n        divisor_vec = vdupq_n_u64(i);\n        uint64x2_t result = vdivq_u64(n_vec, divisor_vec);\n        uint64x2_t is_divisor = vceqq_u64(vmulq_u64(result, divisor_vec), n_vec);\n        \n        if (vmax_u64(vgetq_lane_u64(is_divisor, 0), vgetq_lane_u64(is_divisor, 1))) {\n            largest_divisor = i;\n        }\n    }\n\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case for n <= 2\n\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_i = vdupq_n_u64(1);\n    uint64x2_t vec_limit = vdupq_n_u64(n / 2);\n\n    for (int i = 0; i < 64; i += 2) {\n        vec_i = vaddq_u64(vec_i, vdupq_n_u64(1));\n        uint64x2_t vec_divisor = vec_i;\n\n        uint64x2_t vec_mod = vmodq_u64(vec_n, vec_divisor);\n        uint64x2_t vec_is_divisor = vceqq_u64(vec_mod, vdupq_n_u64(0));\n\n        if (vmax_u64(vgetq_lane_u64(vec_is_divisor, 0), vgetq_lane_u64(vec_is_divisor, 1))) {\n            vec_limit = vec_i;\n        }\n        \n        if (vgetq_lane_u64(vec_limit, 0) == n / 2 || vgetq_lane_u64(vec_limit, 1) == n / 2) {\n            break;\n        }\n    }\n\n    return vmax_u64(vgetq_lane_u64(vec_limit, 0), vgetq_lane_u64(vec_limit, 1));\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 0; // No divisors for 1 or 2\n\n    uint64x2_t num = vdupq_n_u64(n);\n    uint64x2_t result = vdupq_n_u64(0);\n    \n    for (uint64_t i = n - 1; i > 1; i -= 2) {\n        uint64x2_t div = vdupq_n_u64(i);\n        uint64x2_t mod = vmodq_u64(num, div);\n        uint64x2_t is_divisor = vceqq_u64(mod, vdupq_n_u64(0));\n        \n        if (vgetq_lane_u64(is_divisor, 0) || vgetq_lane_u64(is_divisor, 1)) {\n            result = div;\n            break;\n        }\n    }\n    \n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t largest_divisor = 1;\n    uint64_t limit = n / 2;\n\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t largest_vec = vdupq_n_u64(1);\n    \n    for (uint64_t i = 2; i <= limit; i += 2) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        uint64x2_t mod_vec = vmodq_u64(n_vec, i_vec);\n\n        uint64x2_t is_divisor = vceqq_u64(mod_vec, vdupq_n_u64(0));\n        largest_vec = vbslq_u64(is_divisor, i_vec, largest_vec);\n    }\n\n    largest_divisor = vmax_u64(vgetq_lane_u64(largest_vec, 0), vgetq_lane_u64(largest_vec, 1));\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t result = 1;\n    uint64_t half_n = n / 2;\n\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_half_n = vdupq_n_u64(half_n);\n\n    for (uint64_t i = 2; i <= half_n; i += 2) {\n        uint64x2_t vec_i = vdupq_n_u64(i);\n        uint64x2_t mod = vmodq_u64(vec_n, vec_i);\n        uint64x2_t is_divisor = vceqq_u64(mod, vdupq_n_u64(0));\n\n        if (vmaxvq_u64(is_divisor) != 0) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_two = vdupq_n_s32(2);\n    int32x4_t vec_factors[4];\n    int count = 0;\n\n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            if (count < 4) {\n                vec_factors[count] = vdupq_n_s32(i);\n                count++;\n            }\n            n /= i;\n        }\n        if (n < i) break;\n    }\n\n    for (int i = 0; i < count; i++) {\n        factors.push_back(vgetq_lane_s32(vec_factors[i], 0));\n    }\n\n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_two = vdupq_n_s32(2);\n    int32x4_t vec_five = vdupq_n_s32(5);\n    int32x4_t vec_seven = vdupq_n_s32(7);\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_two = vdupq_n_s32(2);\n    int32x4_t vec_five = vdupq_n_s32(5);\n    int32x4_t vec_seven = vdupq_n_s32(7);\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    while (n % 3 == 0) {\n        factors.push_back(3);\n        n /= 3;\n    }\n    \n    for (int i = 5; i * i <= n; i += 6) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        while (n % (i + 2) == 0) {\n            factors.push_back(i + 2);\n            n /= (i + 2);\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vec_n = vdupq_n_s32(n);\n    \n    for (int i = 2; i <= n / 2; ++i) {\n        int32x4_t vec_i = vdupq_n_s32(i);\n        int32x4_t div_result = vshrq_n_s32(vec_n, 1);\n        int32x4_t mod_result = vmodq_s32(vec_n, vec_i);\n        \n        while (vgetq_lane_s32(mod_result, 0) == 0 || vgetq_lane_s32(mod_result, 1) == 0 || \n               vgetq_lane_s32(mod_result, 2) == 0 || vgetq_lane_s32(mod_result, 3) == 0) {\n            factors.push_back(i);\n            vec_n = div_result;\n            div_result = vshrq_n_s32(vec_n, 1);\n            mod_result = vmodq_s32(vec_n, vec_i);\n        }\n    }\n    \n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_two = vdupq_n_s32(2);\n    int32x4_t vec_five = vdupq_n_s32(5);\n    int32x4_t vec_seven = vdupq_n_s32(7);\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    while (n % 3 == 0) {\n        factors.push_back(3);\n        n /= 3;\n    }\n    \n    for (int32_t i = 5; i * i <= n; i += 6) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        while (n % (i + 2) == 0) {\n            factors.push_back(i + 2);\n            n /= (i + 2);\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(data, zero);\n        float32x4_t positives = vbslq_f32(mask, data, zero);\n        result.push_back(vgetq_lane_f32(positives, 0));\n        result.push_back(vgetq_lane_f32(positives, 1));\n        result.push_back(vgetq_lane_f32(positives, 2));\n        result.push_back(vgetq_lane_f32(positives, 3));\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    // Remove zeros from the result\n    result.erase(std::remove(result.begin(), result.end(), 0.0f), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t size = l.size();\n    std::vector<float> result;\n    result.reserve(size);\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(data, zero);\n        float32x4_t positives = vbslq_f32(mask, data, zero);\n        float32x4_t temp = positives;\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(mask, j)) {\n                result.push_back(vgetq_lane_f32(temp, j));\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(data, zero);\n        float32x4_t positives = vbslq_f32(mask, data, zero);\n        result.push_back(vgetq_lane_f32(positives, 0));\n        result.push_back(vgetq_lane_f32(positives, 1));\n        result.push_back(vgetq_lane_f32(positives, 2));\n        result.push_back(vgetq_lane_f32(positives, 3));\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n        float32x4_t positives = vbslq_f32(mask, vec, zero);\n        result.push_back(vgetq_lane_f32(positives, 0));\n        result.push_back(vgetq_lane_f32(positives, 1));\n        result.push_back(vgetq_lane_f32(positives, 2));\n        result.push_back(vgetq_lane_f32(positives, 3));\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    result.erase(std::remove(result.begin(), result.end(), 0.0f), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t size = l.size();\n    std::vector<float> result;\n    result.reserve(size);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(data, zero);\n        float32x4_t positives = vbslq_f32(mask, data, zero);\n        \n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(mask, j)) {\n                result.push_back(vgetq_lane_f32(positives, j));\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = static_cast<int64_t>(std::sqrt(n));\n    int64_t i = 3;\n\n    // Prepare SIMD vectors\n    int64_t vec[2] = {i, i + 2};\n    int64x2_t primes = vld1q_s64(vec);\n\n    while (i <= limit) {\n        // Check for divisibility using SIMD\n        int64x2_t div = vdupq_n_s64(n / i);\n        int64x2_t mod = vdupq_n_s64(n % i);\n        int64x2_t is_divisible = vceqq_s64(mod, vdupq_n_s64(0));\n\n        if (vmaxvq_u8(vreinterpret_u8_s64(is_divisible)) != 0) {\n            return false;\n        }\n\n        i += 2;\n        vec[0] = i;\n        vec[1] = i + 2;\n        primes = vld1q_s64(vec);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    int64_t i = 5;\n    int64x2_t vec_i = vdupq_n_s64(i);\n    int64x2_t vec_limit = vdupq_n_s64(limit);\n    \n    while (vgetq_lane_s64(vec_i, 0) <= limit) {\n        int64x2_t vec_mod = vdupq_n_s64(n);\n        vec_mod = vmodq_s64(vec_mod, vec_i);\n        \n        if (vgetq_lane_s64(vec_mod, 0) == 0 || vgetq_lane_s64(vec_mod, 1) == 0) {\n            return false;\n        }\n        \n        vec_i = vaddq_s64(vec_i, vdupq_n_s64(6));\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    int64_t i = 3;\n    \n    // Prepare the SIMD vector for checking divisibility\n    int64x2_t vec_i = vdupq_n_s64(i);\n    int64x2_t vec_limit = vdupq_n_s64(limit);\n    \n    while (i <= limit) {\n        // Load the next two odd numbers to check\n        vec_i = vaddq_s64(vec_i, vdupq_n_s64(2));\n        \n        // Check if we have exceeded the limit\n        if (vgetq_lane_s64(vec_i, 0) > limit && vgetq_lane_s64(vec_i, 1) > limit) {\n            break;\n        }\n\n        // Check divisibility\n        int64x2_t vec_n = vdupq_n_s64(n);\n        int64x2_t vec_mod = vmodq_s64(vec_n, vec_i);\n        \n        // Check if any of the mod results are zero\n        if (vgetq_lane_s64(vec_mod, 0) == 0 || vgetq_lane_s64(vec_mod, 1) == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = static_cast<int64_t>(std::sqrt(n));\n    int64_t i = 3;\n\n    while (i <= limit) {\n        int64x2_t vec_i = vld1q_dup_s64(&i);\n        int64x2_t vec_limit = vld1q_dup_s64(&limit);\n        \n        // Check if i is greater than limit\n        uint64x2_t cmp = vcgtq_s64(vec_i, vec_limit);\n        if (vmaxvq_u64(cmp) != 0) break;\n\n        // Check divisibility\n        int64x2_t vec_n = vld1q_dup_s64(&n);\n        int64x2_t vec_div = vshlq_n_s64(vec_i, 1);\n        int64x2_t vec_mod = vmodq_s64(vec_n, vec_div);\n        \n        // Check if mod is zero\n        uint64x2_t is_divisible = vceqq_s64(vec_mod, vdupq_n_s64(0));\n        if (vmaxvq_u64(is_divisible) != 0) return false;\n\n        i += 2; // Increment by 2 to check only odd numbers\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    int64_t i = 3;\n\n    // Create an array to hold the results of primality tests\n    uint8x16_t results = vdupq_n_u8(1); // Assume all are prime initially\n\n    for (; i <= limit; i += 16) {\n        int64x2_t vec_i = vld1q_s64((int64_t*)&i);\n        int64x2_t vec_n = vdupq_n_s64(n);\n        int64x2_t vec_div = vdivq_s64(vec_n, vec_i);\n        int64x2_t vec_mod = vmodq_s64(vec_n, vec_i);\n\n        // Check if any of the mod results are zero\n        uint8x16_t mod_zero = vceqq_s64(vec_mod, vdupq_n_s64(0));\n        results = vandq_u8(results, vmvnq_u8(mod_zero));\n\n        // Increment i by 2 for the next odd number\n        i += 2;\n    }\n\n    // Check if any result is still true (1)\n    uint8x16_t is_prime = vdupq_n_u8(0);\n    for (int j = 0; j < 16; j++) {\n        if (vgetq_lane_u8(results, j) == 1) {\n            is_prime = vdupq_n_u8(1);\n            break;\n        }\n    }\n\n    return vgetq_lane_u8(is_prime, 0) == 1;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    if (len == 0) return result;\n\n    bool has_letters = false;\n    for (size_t i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        \n        uint8x16_t is_lower = vandq_u8(vgeq_u8(data, vdupq_n_u8('a')), vltq_u8(data, vdupq_n_u8('z' + 1)));\n        uint8x16_t is_upper = vandq_u8(vgeq_u8(data, vdupq_n_u8('A')), vltq_u8(data, vdupq_n_u8('Z' + 1)));\n\n        uint8x16_t toggled = vbslq_u8(is_lower, veorq_u8(data, lower_mask), data);\n        toggled = vbslq_u8(is_upper, veorq_u8(toggled, upper_mask), toggled);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), toggled);\n    }\n\n    for (; i < len; ++i) {\n        if (isalpha(s[i])) {\n            result[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]);\n        } else {\n            result[i] = s[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    if (len == 0) return result;\n\n    bool has_letters = false;\n    uint8x16_t lower_mask = vdupq_n_u8(0x20); // Mask for case conversion\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vgeq_u8(data, vdupq_n_u8('a')) & vltq_u8(data, vdupq_n_u8('z' + 1));\n        uint8x16_t is_upper = vgeq_u8(data, vdupq_n_u8('A')) & vltq_u8(data, vdupq_n_u8('Z' + 1));\n\n        has_letters |= vmaxvq_u8(is_lower) || vmaxvq_u8(is_upper);\n\n        uint8x16_t upper_case = veorq_u8(data, lower_mask);\n        data = vbslq_u8(is_lower, upper_case, data);\n        data = vbslq_u8(is_upper, upper_case, data);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), data);\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    if (len == 0) return result;\n\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t is_lower = vandq_u8(vshrq_n_u8(data, 5), vdupq_n_u8(0x1F));\n        uint8x16_t is_upper = vandq_u8(data, vdupq_n_u8(0x1F));\n\n        uint8x16_t result_data = vbslq_u8(vandq_u8(vceqq_u8(is_lower, vdupq_n_u8(0x1)), vdupq_n_u8(0x1)), \n                                           veorq_u8(data, lower_mask), \n                                           veorq_u8(data, lower_mask));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), result_data);\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            result[i] = islower(c) ? toupper(c) : tolower(c);\n        } else {\n            result[i] = c;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        \n        uint8x16_t is_lower = vcltq_u8(data, vdupq_n_u8('a' + 1));\n        uint8x16_t is_upper = vcgtq_u8(data, vdupq_n_u8('Z'));\n        uint8x16_t is_letter = vorrq_u8(vandq_u8(is_lower, vdupq_n_u8(0)), vandq_u8(is_upper, vdupq_n_u8(0)));\n\n        uint8x16_t toggled_case = vbslq_u8(is_letter, veorq_u8(data, lower_mask), data);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), toggled_case);\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32;\n        } else {\n            result[i] = c;\n        }\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        \n        uint8x16_t is_lower = vshrq_n_u8(data, 5);\n        uint8x16_t is_upper = vshrq_n_u8(data, 5);\n        is_lower = vandq_u8(is_lower, vdupq_n_u8(0x1));\n        is_upper = vandq_u8(is_upper, vdupq_n_u8(0x2));\n\n        uint8x16_t toggled = vbslq_u8(is_lower, veorq_u8(data, lower_mask), data);\n        toggled = vbslq_u8(is_upper, veorq_u8(toggled, upper_mask), toggled);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), toggled);\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32;\n        } else {\n            result[i] = c;\n        }\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    std::vector<int> third_indices;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n\n    std::sort(third_indices.begin(), third_indices.end());\n\n    size_t j = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = third_indices[j++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_elements.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Replace the elements in the result vector\n    for (size_t i = 0, j = 0; i < n; i += 3) {\n        if (i < n) result[i] = third_elements[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_elements.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Place sorted elements back into the result vector\n    size_t index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (index < third_elements.size()) {\n                result[i] = third_elements[index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> third_indices_values;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) {\n            third_indices_values.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    std::sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Replace the values in the result vector at indices divisible by 3\n    for (size_t i = 0, j = 0; i < n; i += 3) {\n        if (i < n) {\n            result[i] = third_indices_values[j++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_elements.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Place sorted elements back into the result vector\n    for (size_t i = 0, j = 0; i < n; i += 3) {\n        if (i < n) result[i] = third_elements[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t max_val = vdupq_n_f32(-FLT_MAX);\n    \n    for (int i = 0; i < n; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, data);\n    }\n    \n    float32x2_t max_pair = vmax_f32(vget_low_f32(max_val), vget_high_f32(max_val));\n    max_pair = vpmax_f32(max_pair, max_pair);\n    \n    return vget_lane_f32(max_pair, 0);\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float32x4_t max_vec = vdupq_n_f32(-FLT_MAX);\n    \n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, data_vec);\n    }\n\n    float32x2_t max_pair = vmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max_pair = vpmax_f32(max_pair, max_pair);\n    \n    return vget_lane_f32(max_pair, 0);\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) return std::numeric_limits<float>::quiet_NaN();\n\n    float32x4_t max_val = vdupq_n_f32(-std::numeric_limits<float>::infinity());\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t data = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, data);\n    }\n\n    float32x2_t max_pair = vmax_f32(vget_low_f32(max_val), vget_high_f32(max_val));\n    max_pair = vpmax_f32(max_pair, max_pair);\n    \n    return vget_lane_f32(max_pair, 0);\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float32x4_t max_vec = vdupq_n_f32(-FLT_MAX);\n\n    for (int i = 0; i < size; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, data_vec);\n    }\n\n    float32x2_t max_pair = vmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max_pair = vpmax_f32(max_pair, max_pair);\n    \n    return vget_lane_f32(max_pair, 0);\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float32x4_t max_vec = vdupq_n_f32(-FLT_MAX);\n    \n    for (int i = 0; i < size; i += 4) {\n        float32x4_t data_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, data_vec);\n    }\n    \n    float32x2_t max_pair = vmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max_pair = vmax_f32(max_pair, vdup_n_f32(-FLT_MAX));\n    \n    return std::max(vget_lane_f32(max_pair, 0), vget_lane_f32(max_pair, 1));\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t seven_vec = vdupq_n_s32(7);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t idx_vec = vld1q_s32((int32_t*)&i);\n        int32x4_t div11 = vceqq_s32(vshrq_n_s32(idx_vec, 1), vdupq_n_s32(11));\n        int32x4_t div13 = vceqq_s32(vshrq_n_s32(idx_vec, 1), vdupq_n_s32(13));\n        int32x4_t is_divisible = vorrq_s32(div11, div13);\n        \n        int32x4_t digit_count = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            if (i + j < n && (vgetq_lane_s32(is_divisible, j) != 0)) {\n                int temp = i + j;\n                while (temp > 0) {\n                    if (temp % 10 == 7) {\n                        digit_count = vaddq_s32(digit_count, seven_vec);\n                    }\n                    temp /= 10;\n                }\n            }\n        }\n        count_vec = vaddq_s32(count_vec, digit_count);\n    }\n    \n    count += vgetq_lane_s32(count_vec, 0);\n    count += vgetq_lane_s32(count_vec, 1);\n    count += vgetq_lane_s32(count_vec, 2);\n    count += vgetq_lane_s32(count_vec, 3);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t seven_vec = vdupq_n_s32(7);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t num_vec = vld1q_s32((int32_t*)&i);\n        int32x4_t divisible_vec = vorrq_s32(vandq_s32(vshrq_n_s32(num_vec, 1), vdupq_n_s32(1)), \n                                                vandq_s32(vshrq_n_s32(num_vec, 2), vdupq_n_s32(1)));\n        \n        int32x4_t is_seven_vec = vceqq_s32(num_vec, seven_vec);\n        count_vec = vaddq_s32(count_vec, vandq_s32(is_seven_vec, divisible_vec));\n        \n        if (i + 4 > n) {\n            break;\n        }\n    }\n    \n    count += vgetq_lane_s32(count_vec, 0);\n    count += vgetq_lane_s32(count_vec, 1);\n    count += vgetq_lane_s32(count_vec, 2);\n    count += vgetq_lane_s32(count_vec, 3);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t seven = vdupq_n_s32(7);\n    int32x4_t divisor11 = vdupq_n_s32(11);\n    int32x4_t divisor13 = vdupq_n_s32(13);\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t nums = vld1q_s32((int32_t*)&i);\n        int32x4_t divisible = vorrq_s32(vceqq_s32(vremq_s32(nums, divisor11), zero), \n                                         vceqq_s32(vremq_s32(nums, divisor13), zero));\n        int32x4_t digits = vdupq_n_s32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            if (i + j < n) {\n                int temp = i + j;\n                while (temp > 0) {\n                    if (temp % 10 == 7) {\n                        digits = vaddq_s32(digits, vdupq_n_s32(1));\n                    }\n                    temp /= 10;\n                }\n            }\n        }\n        \n        count += vaddvq_s32(vandq_s32(divisible, digits));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t seven_vec = vdupq_n_s32(7);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t nums = vld1q_s32((int32_t*)&i);\n        int32x4_t divisible_by_11 = vorrq_s32(vandq_s32(vshrq_n_s32(nums, 11), vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t divisible_by_13 = vorrq_s32(vandq_s32(vshrq_n_s32(nums, 13), vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t is_divisible = vorrq_s32(divisible_by_11, divisible_by_13);\n        \n        int32x4_t digit_count = zero_vec;\n        for (int j = 0; j < 4; j++) {\n            if (is_divisible[j]) {\n                int temp = nums[j];\n                while (temp > 0) {\n                    if (temp % 10 == 7) {\n                        digit_count = vaddq_s32(digit_count, seven_vec);\n                    }\n                    temp /= 10;\n                }\n            }\n        }\n        count += vgetq_lane_s32(digit_count, 0) + vgetq_lane_s32(digit_count, 1) + vgetq_lane_s32(digit_count, 2) + vgetq_lane_s32(digit_count, 3);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t seven_vec = vdupq_n_s32(7);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t idx_vec = vld1q_s32((int32_t*)&i);\n        int32x4_t divisible_by_11 = vorrq_s32(vandq_s32(vshrq_n_s32(idx_vec, 11), vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t divisible_by_13 = vorrq_s32(vandq_s32(vshrq_n_s32(idx_vec, 13), vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t divisible = vorrq_s32(divisible_by_11, divisible_by_13);\n        \n        uint32x4_t mask = vceqq_s32(divisible, vdupq_n_s32(0));\n        int32x4_t digits = vdupq_n_s32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            if (i + j < n) {\n                int temp = i + j;\n                while (temp > 0) {\n                    if (temp % 10 == 7) {\n                        digits = vaddq_s32(digits, vdupq_n_s32(1));\n                    }\n                    temp /= 10;\n                }\n            }\n        }\n        \n        count_vec = vaddq_s32(count_vec, digits);\n    }\n    \n    int32_t result[4];\n    vst1q_s32(result, count_vec);\n    for (int i = 0; i < 4; i++) {\n        count += result[i];\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Load even indexed elements into a temporary array\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Store sorted even elements back into the result vector\n    for (size_t i = 0, j = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_elements[j++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Load even indexed elements into a temporary array\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Store sorted even elements back into the result vector\n    for (size_t i = 0, j = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_elements[j++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Extract even indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Load sorted even elements into a Neon vector\n    float32x4_t even_vec;\n    for (size_t i = 0; i < even_elements.size(); i += 4) {\n        even_vec = vld1q_f32(&even_elements[i]);\n        vst1q_f32(&result[i * 2], even_vec);\n    }\n\n    // Copy odd indexed elements\n    for (size_t i = 1; i < n; i += 2) {\n        result[i] = l[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Load even indices into a temporary array\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    // Sort the even indices\n    std::sort(even_indices.begin(), even_indices.end());\n\n    // Store sorted even indices back into the result vector\n    for (size_t i = 0, j = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_indices[j++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Load even indices into a temporary array\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    // Sort the even indices\n    std::sort(even_indices.begin(), even_indices.end());\n\n    // Store sorted even indices back into the result\n    for (size_t i = 0; i < even_indices.size(); ++i) {\n        result[i * 2] = even_indices[i];\n    }\n\n    // Copy odd indices from the original vector\n    for (size_t i = 1; i < n; i += 2) {\n        result[i] = l[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int sum = l[i] + l[j];\n            if (seen.count(-sum) && -sum != l[i] && -sum != l[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        for (int j = 0; j < i; j++) {\n            int32x4_t vec_j = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec, vec_j);\n            for (int k = j + 1; k < n; k++) {\n                int32x4_t vec_k = vld1q_s32(&l[k]);\n                int32x4_t total = vaddq_s32(sum, vec_k);\n                int32x4_t zero_vec = vdupq_n_s32(0);\n                if (vmaxvq_s32(vabsq_s32(total)) == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        for (int j = 0; j < i; j++) {\n            int32x4_t target = vsubq_s32(vec, vdupq_n_s32(l[j]));\n            int32x4_t cmp = vdupq_n_s32(0);\n            for (int k = 0; k < 4; k++) {\n                if (i + k < n) {\n                    cmp = vorrq_s32(cmp, vceqq_s32(target, vdupq_n_s32(l[j])));\n                }\n            }\n            if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n                return true;\n            }\n        }\n        for (int k = 0; k < 4 && i + k < n; k++) {\n            seen.insert(l[i + k]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end()) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int sum = l[i] + l[j];\n            if (seen.count(-sum) && -sum != l[i] && -sum != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int sum = l[i] + l[j];\n            if (seen.count(-sum) && -sum != l[i] && -sum != l[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&result[i], vec);\n    }\n    \n    for (; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&result[i], vec);\n    }\n    \n    for (; i < size; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&result[i], vec);\n    }\n    \n    for (; i < n; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n    std::vector<int> result(size);\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&result[i], vec);\n    }\n\n    for (; i < size; i++) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&result[i], vec);\n    }\n    \n    for (; i < size; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    int size = l.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        int32x4_t cmp = vceqq_s32(vec, neg_vec);\n        if (vmaxvq_u32(vreinterpretq_u32_s32(cmp)) != 0) {\n            return true;\n        }\n\n        for (int j = 0; j < 4; j++) {\n            seen.insert(l[i + j]);\n        }\n    }\n\n    for (; i < size; i++) {\n        if (seen.count(-l[i])) {\n            return true;\n        }\n        seen.insert(l[i]);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n        \n        // Check for matches in the seen set\n        for (int j = 0; j < 4; j++) {\n            int32_t value = vgetq_lane_s32(vec, j);\n            if (seen.count(value) || seen.count(vgetq_lane_s32(neg_vec, j))) {\n                return true;\n            }\n        }\n\n        // Add current values to the seen set\n        for (int j = 0; j < 4; j++) {\n            seen.insert(vgetq_lane_s32(vec, j));\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int value = l[i];\n        if (seen.count(value) || seen.count(-value)) {\n            return true;\n        }\n        seen.insert(value);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        // Check for matches in the seen set\n        for (int j = 0; j < 4; j++) {\n            int32_t value = vgetq_lane_s32(vec, j);\n            if (seen.count(value) || seen.count(vgetq_lane_s32(neg_vec, j))) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; i++) {\n        if (seen.count(l[i]) || seen.count(-l[i])) {\n            return true;\n        }\n        seen.insert(l[i]);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process elements in chunks of 4 using Neon\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        // Check for pairs in the seen set\n        for (int j = 0; j < 4; ++j) {\n            int32_t value = vgetq_lane_s32(vec, j);\n            if (seen.count(value) || seen.count(vgetq_lane_s32(neg_vec, j))) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (seen.count(l[i]) || seen.count(-l[i])) {\n            return true;\n        }\n        seen.insert(l[i]);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    int size = l.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        int32x4_t cmp = vceqq_s32(vec, neg_vec);\n        if (vmaxvq_u32(vreinterpret_u32_s32(cmp)) != 0) {\n            return true;\n        }\n\n        for (int j = 0; j < 4; j++) {\n            seen.insert(l[i + j]);\n        }\n    }\n\n    for (; i < size; i++) {\n        if (seen.count(-l[i])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<int8_t> digits;\n    \n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n\n    int length = digits.size();\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int8x16_t zero_vec = vdupq_n_s8(0);\n    \n    std::string result;\n    for (int i = 0; i < length; i += 16) {\n        int8x16_t current_vec = vdupq_n_s8(0);\n        int count = std::min(16, length - i);\n        \n        for (int j = 0; j < count; j++) {\n            current_vec = vsetq_lane_s8(digits[i + j], current_vec, j);\n        }\n        \n        // Convert to characters\n        current_vec = vaddq_s8(current_vec, zero_vec);\n        for (int j = 0; j < count; j++) {\n            result += static_cast<char>(vgetq_lane_s8(current_vec, j) + '0');\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<int8_t> digits;\n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n\n    int length = digits.size();\n    int remainder = length % 16;\n    int full_blocks = length / 16;\n\n    uint8x16_t base_vec = vdupq_n_u8(base);\n    uint8x16_t zero_vec = vdupq_n_u8(0);\n    std::string result;\n\n    for (int i = 0; i < full_blocks; i++) {\n        uint8x16_t x_vec = vld1q_u8(digits.data() + i * 16);\n        uint8x16_t char_vec = vaddq_u8(x_vec, zero_vec);\n        for (int j = 0; j < 16; j++) {\n            result += '0' + vgetq_lane_u8(char_vec, j);\n        }\n    }\n\n    if (remainder > 0) {\n        uint8x16_t x_vec = vld1q_u8(digits.data() + full_blocks * 16);\n        uint8x16_t char_vec = vaddq_u8(x_vec, zero_vec);\n        for (int j = 0; j < remainder; j++) {\n            result += '0' + vgetq_lane_u8(char_vec, j);\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<int8_t> digits;\n    \n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n\n    int length = digits.size();\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int8x16_t zero_vec = vdupq_n_s8(0);\n    \n    std::string result;\n    for (int i = 0; i < length; i += 16) {\n        int8x16_t current_vec = vdupq_n_s8(0);\n        int count = std::min(16, length - i);\n        \n        for (int j = 0; j < count; j++) {\n            current_vec = vsetq_lane_s8(digits[i + j], current_vec, j);\n        }\n\n        int8x16_t converted_vec = vmlaq_s8(zero_vec, current_vec, base_vec);\n        \n        for (int j = 0; j < count; j++) {\n            result += std::to_string(vgetq_lane_s8(converted_vec, j));\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<int8_t> digits;\n    while (x > 0) {\n        digits.push_back(x % base);\n        x /= base;\n    }\n\n    int length = digits.size();\n    int remainder = length % 16;\n    int full_blocks = length / 16;\n\n    uint8x16_t base_vec = vdupq_n_u8(base);\n    uint8x16_t result_vec;\n\n    for (int i = 0; i < full_blocks; i++) {\n        uint8x16_t x_vec = vld1q_u8(digits.data() + i * 16);\n        result_vec = vaddq_u8(x_vec, base_vec);\n        vst1q_u8(digits.data() + i * 16, result_vec);\n    }\n\n    if (remainder > 0) {\n        uint8x16_t x_vec = vld1q_u8(digits.data() + full_blocks * 16);\n        result_vec = vaddq_u8(x_vec, base_vec);\n        vst1q_u8(digits.data() + full_blocks * 16, result_vec);\n    }\n\n    std::string result;\n    for (int i = digits.size() - 1; i >= 0; i--) {\n        result += std::to_string(digits[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<int8_t> digits;\n    \n    while (x > 0) {\n        int64_t remainder = x % base;\n        digits.push_back(static_cast<int8_t>(remainder));\n        x /= base;\n    }\n\n    int length = digits.size();\n    std::string result(length, '0');\n\n    int8x8_t base_vec = vdup_n_s8(base);\n    int8x8_t zero_vec = vdup_n_s8(0);\n    \n    for (int i = 0; i < length; i += 8) {\n        int8x8_t input_vec = vld1_s8(digits.data() + i);\n        int8x8_t output_vec = vadd_s8(input_vec, zero_vec);\n        vst1_s8(&result[i], output_vec);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    const char* str = text.c_str();\n    int half_len = len / 2;\n\n    for (int i = 0; i < half_len; i += 16) {\n        uint8x16_t left = vld1q_u8((const uint8_t*)(str + i));\n        uint8x16_t right = vld1q_u8((const uint8_t*)(str + len - i - 16));\n\n        if (vmaxvq_u8(vceqq_u8(left, right)) == 0) {\n            return false;\n        }\n    }\n\n    if (len % 2 != 0) {\n        if (str[half_len] != str[len - half_len - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    int half_len = len / 2;\n\n    for (int i = 0; i < half_len; i += 16) {\n        uint8x16_t left = vld1q_u8((const uint8_t*)(str + i));\n        uint8x16_t right = vld1q_u8((const uint8_t*)(str + len - 1 - i));\n\n        if (vmaxvq_u8(vceqq_u8(left, right)) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int half_len = len / 2;\n    for (int i = 0; i < half_len; i += 16) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[i]));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[len - 1 - i]));\n\n        // Reverse the right vector\n        right = vrev64q_u8(right);\n        \n        // Compare left and reversed right\n        uint8x16_t cmp = vceqq_u8(left, right);\n        uint64x2_t result = vpaddlq_u64(vpaddlq_u32(vpaddlq_u16(cmp)));\n\n        if (vgetq_lane_u64(result, 0) != 16 && vgetq_lane_u64(result, 1) != 16) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int half_len = len / 2;\n    for (int i = 0; i < half_len; i += 16) {\n        uint8x16_t left = vld1q_u8((const uint8_t*)&text[i]);\n        uint8x16_t right = vld1q_u8((const uint8_t*)&text[len - i - 16]);\n\n        if (vmaxvq_u8(vceqq_u8(left, right)) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int half_len = len / 2;\n    for (int i = 0; i < half_len; i += 16) {\n        uint8x16_t left = vld1q_u8((const uint8_t*)text.c_str() + i);\n        uint8x16_t right = vld1q_u8((const uint8_t*)text.c_str() + (len - i - 16));\n\n        if (vmaxvq_u8(vceqq_u8(left, right)) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    size_t length = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(input, vdupq_n_u8(5));\n        // Wrap around for characters less than 'a'\n        uint8x16_t wrapped = vmlaq_u8(decoded, vdupq_n_u8(26), vcgtq_u8(decoded, vdupq_n_u8('z')));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), wrapped);\n    }\n\n    // Handle remaining characters\n    for (; i < length; i++) {\n        char w = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n        out += w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    int length = s.length();\n    out.resize(length);\n    \n    int i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vsubq_u8(input, vdupq_n_u8(5));\n        input = vaddq_u8(input, vdupq_n_u8('a'));\n        input = vminq_u8(input, vdupq_n_u8('z'));\n        input = vmaxq_u8(input, vdupq_n_u8('a'));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), input);\n    }\n    \n    for (; i < length; i++) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    int length = s.length();\n    out.resize(length);\n    \n    int i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vsubq_u8(input, vdupq_n_u8(5)); // Shift back by 5\n        input = vaddq_u8(input, vdupq_n_u8('a')); // Adjust to 'a'\n        input = vminq_u8(input, vdupq_n_u8('z')); // Clamp to 'z'\n        input = vmaxq_u8(input, vdupq_n_u8('a')); // Clamp to 'a'\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), input);\n    }\n    \n    for (; i < length; i++) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vsubq_u8(input, vdupq_n_u8(5)); // Shift back by 5\n        input = vaddq_u8(input, vdupq_n_u8('a')); // Adjust to 'a'\n        input = vminq_u8(input, vdupq_n_u8('z')); // Clamp to 'z'\n        input = vmaxq_u8(input, vdupq_n_u8('a')); // Clamp to 'a'\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), input);\n    }\n\n    // Handle remaining characters\n    for (; i < length; i++) {\n        char w = (s[i] - 5);\n        if (w < 'a') w += 26; // Wrap around if below 'a'\n        out += w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    int length = s.length();\n    out.resize(length);\n\n    int i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vsubq_u8(input, vdupq_n_u8(5));\n        input = vaddq_u8(input, vdupq_n_u8('a'));\n        input = vminq_u8(input, vdupq_n_u8('z'));\n        input = vmaxq_u8(input, vdupq_n_u8('a'));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), input);\n    }\n\n    for (; i < length; ++i) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int32x4_t threshold = vdupq_n_s32(t);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        int32x4_t cmp = vcltq_s32(data, threshold);\n        uint32x4_t mask = vceqq_u32(vreinterpretq_u32_s32(cmp), vdupq_n_u32(0xFFFFFFFF));\n        \n        if (vmaxvq_u32(mask) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int32x4_t threshold = vdupq_n_s32(t);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(data, threshold);\n        uint32x4_t all_below = vandq_u32(cmp, vdupq_n_u32(1));\n        \n        if (vmaxvq_u32(all_below) == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int32x4_t threshold = vdupq_n_s32(t);\n    int32x4_t result = vdupq_n_s32(1); // Assume all are below threshold\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        int32x4_t cmp = vcltq_s32(data, threshold);\n        result = vandq_s32(result, cmp);\n    }\n\n    // Check the result\n    uint32x4_t check = vceqq_s32(result, vdupq_n_s32(1));\n    return (vmaxvq_u32(check) == 1);\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int vector_size = 4; // We will process 4 integers at a time\n    int i = 0;\n\n    // Load the threshold into a Neon vector\n    int32x4_t threshold_vec = vdupq_n_s32(t);\n\n    for (; i <= size - vector_size; i += vector_size) {\n        // Load 4 integers from the vector\n        int32x4_t data_vec = vld1q_s32(&l[i]);\n        // Compare with the threshold\n        uint32x4_t cmp_result = vcltq_s32(data_vec, threshold_vec);\n        // Check if all comparisons are true (all bits set)\n        if (vmaxvq_u32(cmp_result) == 0) {\n            return false; // Found an element not below the threshold\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (l[i] >= t) {\n            return false; // Found an element not below the threshold\n        }\n    }\n\n    return true; // All elements are below the threshold\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int32x4_t threshold = vdupq_n_s32(t);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(data, threshold);\n        \n        if (vaddvq_u32(cmp) != 4) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i < length; i += 16) {\n        int32x4_t open_count = vdupq_n_s32(0);\n        int32x4_t close_count = vdupq_n_s32(0);\n\n        int remaining = std::min(16, length - i);\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n\n        for (int j = 0; j < remaining; ++j) {\n            if (brackets[i + j] == '<') {\n                open_count = vaddq_s32(open_count, vdupq_n_s32(1));\n            } else if (brackets[i + j] == '>') {\n                close_count = vaddq_s32(close_count, vdupq_n_s32(1));\n            }\n        }\n\n        count += vgetq_lane_s32(open_count, 0) + vgetq_lane_s32(open_count, 1) +\n                 vgetq_lane_s32(open_count, 2) + vgetq_lane_s32(open_count, 3);\n        count -= vgetq_lane_s32(close_count, 0) + vgetq_lane_s32(close_count, 1) +\n                 vgetq_lane_s32(close_count, 2) + vgetq_lane_s32(close_count, 3);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.size();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i < length; i += 16) {\n        int remaining = std::min(16, length - i);\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n\n        // Create masks for '<' and '>'\n        uint8x16_t less_than_mask = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t greater_than_mask = vceqq_u8(data, vdupq_n_u8('>'));\n\n        // Count '<' and '>'\n        uint8x16_t less_than_count = vandq_u8(less_than_mask, vdupq_n_u8(1));\n        uint8x16_t greater_than_count = vandq_u8(greater_than_mask, vdupq_n_u8(1));\n\n        // Sum counts\n        count += vaddvq_u8(less_than_count);\n        count -= vaddvq_u8(greater_than_count);\n    }\n\n    // Check for remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '<') {\n            count++;\n        } else if (brackets[i] == '>') {\n            count--;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i < length; i += 16) {\n        int remaining = std::min(16, length - i);\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n\n        // Create masks for '<' and '>'\n        uint8x16_t less_than_mask = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t greater_than_mask = vceqq_u8(data, vdupq_n_u8('>'));\n\n        // Count '<' and '>'\n        uint8x16_t less_than_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(less_than_mask), vget_high_u8(less_than_mask)));\n        uint8x16_t greater_than_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(greater_than_mask), vget_high_u8(greater_than_mask)));\n\n        // Sum counts\n        count += vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(less_than_count)), 0);\n        count -= vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(greater_than_count)), 0);\n    }\n\n    // Check if the count is zero\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i < length; i += 16) {\n        int remaining = std::min(16, length - i);\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n\n        // Create masks for '<' and '>'\n        uint8x16_t less_than_mask = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t greater_than_mask = vceqq_u8(data, vdupq_n_u8('>'));\n\n        // Count '<' and '>'\n        uint8x16_t less_than_count = vaddq_u8(less_than_mask, vdupq_n_u8(0));\n        uint8x16_t greater_than_count = vaddq_u8(greater_than_mask, vdupq_n_u8(0));\n\n        // Sum counts\n        count += vaddvq_u8(less_than_count);\n        count -= vaddvq_u8(greater_than_count);\n    }\n\n    // Check if count is zero for balanced brackets\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i < length; i += 16) {\n        int remaining = std::min(16, length - i);\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n\n        // Create masks for '<' and '>'\n        uint8x16_t less_than_mask = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t greater_than_mask = vceqq_u8(data, vdupq_n_u8('>'));\n\n        // Count '<' and '>'\n        uint8x16_t less_than_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(less_than_mask), vget_high_u8(less_than_mask)));\n        uint8x16_t greater_than_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(greater_than_mask), vget_high_u8(greater_than_mask)));\n\n        // Sum counts\n        count += vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(less_than_count)), 0);\n        count -= vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(greater_than_count)), 0);\n    }\n\n    // Check for remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '<') {\n            count++;\n        } else if (brackets[i] == '>') {\n            count--;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        uint8x16_t open = vdupq_n_u8('(');\n        uint8x16_t close = vdupq_n_u8(')');\n\n        // Compare for '(' and ')'\n        uint8x16_t is_open = vceqq_u8(data, open);\n        uint8x16_t is_close = vceqq_u8(data, close);\n\n        // Count '(' and ')'\n        uint8x16_t open_count = vreinterpretq_u8_u32(vaddq_u32(vshrq_n_u32(vreinterpretq_u32_u8(is_open), 0), \n                                                               vshrq_n_u32(vreinterpretq_u32_u8(is_open), 1)));\n        uint8x16_t close_count = vreinterpretq_u8_u32(vaddq_u32(vshrq_n_u32(vreinterpretq_u32_u8(is_close), 0), \n                                                                vshrq_n_u32(vreinterpretq_u32_u8(is_close), 1)));\n\n        count += vaddvq_u32(vreinterpretq_u32_u8(open_count));\n        count -= vaddvq_u32(vreinterpretq_u32_u8(close_count));\n    }\n\n    // Handle remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '(') {\n            count++;\n        } else if (brackets[i] == ')') {\n            count--;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n        uint8x16_t open = vdupq_n_u8('(');\n        uint8x16_t close = vdupq_n_u8(')');\n        \n        // Compare characters\n        uint8x16_t is_open = vceqq_u8(chars, open);\n        uint8x16_t is_close = vceqq_u8(chars, close);\n        \n        // Count open and close brackets\n        uint8x16_t open_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(is_open), vget_high_u8(is_open)));\n        uint8x16_t close_count = vreinterpretq_u8_u32(vaddl_u8(vget_low_u8(is_close), vget_high_u8(is_close)));\n        \n        count += vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(open_count)), 0);\n        count -= vgetq_lane_u32(vpaddlq_u16(vpaddlq_u8(close_count)), 0);\n        \n        if (count < 0) return false;\n    }\n\n    // Process remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '(') {\n            count++;\n        } else if (brackets[i] == ')') {\n            count--;\n        }\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n        uint8x16_t open_mask = vdupq_n_u8('(');\n        uint8x16_t close_mask = vdupq_n_u8(')');\n\n        // Count '(' and ')'\n        uint8x16_t open_count = vceqq_u8(chars, open_mask);\n        uint8x16_t close_count = vceqq_u8(chars, close_mask);\n\n        // Convert to int32x4_t for summation\n        uint32x4_t open_sum = vaddw_u8(vdupq_n_u32(0), vget_low_u8(open_count));\n        open_sum = vaddw_u8(open_sum, vget_high_u8(open_count));\n        uint32x4_t close_sum = vaddw_u8(vdupq_n_u32(0), vget_low_u8(close_count));\n        close_sum = vaddw_u8(close_sum, vget_high_u8(close_count));\n\n        // Update the total counts\n        count += vgetq_lane_u32(open_sum, 0) + vgetq_lane_u32(open_sum, 1) + \n                 vgetq_lane_u32(open_sum, 2) + vgetq_lane_u32(open_sum, 3);\n        count -= vgetq_lane_u32(close_sum, 0) + vgetq_lane_u32(close_sum, 1) + \n                 vgetq_lane_u32(close_sum, 2) + vgetq_lane_u32(close_sum, 3);\n    }\n\n    // Process remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '(') {\n            count++;\n        } else if (brackets[i] == ')') {\n            count--;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.c_str() + i));\n        uint8x16_t open = vdupq_n_u8('(');\n        uint8x16_t close = vdupq_n_u8(')');\n        \n        // Compare and create masks\n        uint8x16_t open_mask = vceqq_u8(data, open);\n        uint8x16_t close_mask = vceqq_u8(data, close);\n        \n        // Count the number of '(' and ')'\n        uint8x16_t open_count = vandq_u8(open_mask, vdupq_n_u8(1));\n        uint8x16_t close_count = vandq_u8(close_mask, vdupq_n_u8(1));\n        \n        // Accumulate counts\n        count += vaddvq_u8(open_count);\n        count -= vaddvq_u8(close_count);\n        \n        // Early exit if count goes negative\n        if (count < 0) return false;\n    }\n\n    // Process remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '(') {\n            count++;\n        } else if (brackets[i] == ')') {\n            count--;\n        }\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int count = 0;\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        uint8x16_t open = vdupq_n_u8('(');\n        uint8x16_t close = vdupq_n_u8(')');\n\n        // Compare characters\n        uint8x16_t is_open = vceqq_u8(chars, open);\n        uint8x16_t is_close = vceqq_u8(chars, close);\n\n        // Count open and close brackets\n        uint8x16_t open_count = vreinterpretq_u8_u32(vaddq_u32(vshlq_n_u32(vmovn_u64(vpaddlq_u64(vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(is_open))))), 0), 0));\n        uint8x16_t close_count = vreinterpretq_u8_u32(vaddq_u32(vshlq_n_u32(vmovn_u64(vpaddlq_u64(vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(is_close))))), 0), 0));\n\n        count += vgetq_lane_u32(open_count, 0) + vgetq_lane_u32(open_count, 1) + vgetq_lane_u32(open_count, 2) + vgetq_lane_u32(open_count, 3);\n        count -= vgetq_lane_u32(close_count, 0) + vgetq_lane_u32(close_count, 1) + vgetq_lane_u32(close_count, 2) + vgetq_lane_u32(close_count, 3);\n    }\n\n    // Handle remaining characters\n    for (int i = length - (length % 16); i < length; ++i) {\n        if (brackets[i] == '(') {\n            count++;\n        } else if (brackets[i] == ')') {\n            count--;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    int i = 0;\n\n    // Process 4 coefficients at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n        float32x4_t indices = vld1q_f32(&xs[i + 1]);\n\n        // Calculate the derivative coefficients\n        float32x4_t derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], derivative);\n\n        // Update indices for the next coefficients\n        indices = vaddq_f32(indices, vdupq_n_f32(1.0f));\n        coeffs = vld1q_f32(&xs[i + 2]);\n        derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i + 4], derivative);\n    }\n\n    // Handle remaining coefficients\n    for (; i < n - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    int i = 0;\n\n    // Process 4 coefficients at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n        float32x4_t indices = vld1q_f32(&xs[i + 1]);\n        float32x4_t powers = vdupq_n_f32(1.0f);\n\n        // Calculate the derivative coefficients\n        float32x4_t derivative = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], derivative);\n\n        // Update powers for next iteration\n        powers = vmulq_f32(powers, indices);\n    }\n\n    // Handle remaining coefficients\n    for (; i < n - 1; i++) {\n        result[i] = xs[i] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = vld1q_f32(&xs[i]);\n        float32x4_t powers = vdupq_n_f32(1.0f);\n        \n        for (int j = 1; j < 4; j++) {\n            powers = vmulq_f32(powers, indices);\n            coeffs = vmulq_f32(coeffs, vdupq_n_f32(static_cast<float>(j)));\n            indices = vdupq_n_f32(static_cast<float>(j + 1));\n        }\n        \n        vst1q_f32(&result[i], coeffs);\n    }\n\n    for (; i < n - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    if (n < 2) return result;\n\n    float32x4_t coeffs;\n    float32x4_t indices;\n    for (int i = 1; i < n; i += 4) {\n        coeffs = vld1q_f32(&xs[i - 1]); // Load coefficients\n        indices = vdupq_n_f32(static_cast<float>(i)); // Load index\n        float32x4_t derivative = vmulq_f32(coeffs, indices); // Multiply coeffs by their indices\n        vst1q_f32(&result[i - 1], derivative); // Store result\n    }\n\n    // Handle remaining coefficients if n is not a multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    if (n < 2) return {}; // No derivative for constant or empty polynomial\n\n    std::vector<float> result(n - 1);\n    int vec_size = n / 4 * 4; // Process in multiples of 4\n\n    float32x4_t coeffs, powers;\n    for (int i = 1; i < vec_size; i += 4) {\n        coeffs = vld1q_f32(&xs[i - 1]); // Load coefficients\n        powers = vdupq_n_f32(static_cast<float>(i)); // Load powers (1, 2, 3, 4)\n        float32x4_t deriv = vmulq_f32(coeffs, powers); // Multiply coeffs by powers\n        vst1q_f32(&result[i - 1], deriv); // Store result\n    }\n\n    // Handle remaining coefficients\n    for (int i = vec_size; i < n - 1; ++i) {\n        result[i] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Load vowels into a Neon register\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n    \n    // Process the string in chunks of 16 characters\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        uint8x16_t cmp = vceqq_u8(data, vowels);\n        uint8x16_t result = vpaddlq_u8(cmp);\n        count += vgetq_lane_u32(result, 0) + vgetq_lane_u32(result, 1);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check for 'y' at the end of the string\n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        uint8x16_t vowels_mask = vdupq_n_u8(0);\n        \n        // Create masks for vowels 'a', 'e', 'i', 'o', 'u', 'y'\n        vowels_mask = vorrq_u8(vowels_mask, vceqq_u8(data, vdupq_n_u8('a')));\n        vowels_mask = vorrq_u8(vowels_mask, vceqq_u8(data, vdupq_n_u8('e')));\n        vowels_mask = vorrq_u8(vowels_mask, vceqq_u8(data, vdupq_n_u8('i')));\n        vowels_mask = vorrq_u8(vowels_mask, vceqq_u8(data, vdupq_n_u8('o')));\n        vowels_mask = vorrq_u8(vowels_mask, vceqq_u8(data, vdupq_n_u8('u')));\n        \n        // Count the number of vowels\n        count += vaddvq_u8(vandq_u8(vowels_mask, vdupq_n_u8(1)));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check for 'y' at the end of the string\n    if (length > 0 && s[length - 1] == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Load vowels into a Neon register\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vdupq_n_u8('a'), vdupq_n_u8('e')), \n                                         vdupq_n_u8('i')), vdupq_n_u8('o')), \n                                         vdupq_n_u8('u'));\n    vowels = vorrq_u8(vowels, vdupq_n_u8('y'));\n\n    // Process the string in chunks of 16 characters\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        uint8x16_t cmp = vceqq_u8(data, vowels);\n        count += vaddvq_u8(vreinterpret_u8_u32(vshrq_n_u32(vreinterpret_u32_u8(cmp), 0)));\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (i == length - 1 && c == 'y')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        uint8x16_t lower_data = vaddq_u8(data, vdupq_n_u8(32)); // Convert to lowercase\n\n        // Create a mask for vowels\n        uint8x16_t vowels_mask = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vceqq_u8(lower_data, vdupq_n_u8('a'))),\n                                                              vceqq_u8(lower_data, vdupq_n_u8('e'))),\n                                                              vceqq_u8(lower_data, vdupq_n_u8('i'))),\n                                                              vceqq_u8(lower_data, vdupq_n_u8('o'))),\n                                                              vceqq_u8(lower_data, vdupq_n_u8('u')));\n\n        // Count the number of vowels\n        uint8x16_t count_mask = vandq_u8(vowels_mask, vdupq_n_u8(1));\n        count += vaddvq_u8(count_mask);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check for 'y' at the end of the string\n    if (length > 0 && tolower(s[length - 1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int length = s.length();\n    int vector_length = length / 16;\n    int remaining = length % 16;\n\n    uint8x16_t vowels_mask = vdupq_n_u8(0);\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('a'));\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('e'));\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('i'));\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('o'));\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('u'));\n    vowels_mask = vorrq_u8(vowels_mask, vdupq_n_u8('y'));\n\n    for (int i = 0; i < vector_length * 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        uint8x16_t cmp = vceqq_u8(data, vowels_mask);\n        count += vaddvq_u8(cmp);\n    }\n\n    for (int i = vector_length * 16; i < length; i++) {\n        if (s[i] == 'y' && i == length - 1) {\n            count++;\n        } else if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int length = s.length();\n    int i = 0;\n\n    uint8x16_t upper_mask = vdupq_n_u8(0x20); // Mask to check for uppercase letters\n    uint8x16_t ascii_offset = vdupq_n_u8('A'); // ASCII offset for uppercase letters\n    uint8x16_t zero = vdupq_n_u8(0); // Zero vector for comparison\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_upper = vcltq_u8(data, vaddq_u8(ascii_offset, upper_mask)); // Check if character is upper\n        uint8x16_t upper_chars = vandq_u8(data, is_upper); // Get upper characters\n        sum += vaddvq_u8(upper_chars); // Sum ASCII values of upper characters\n    }\n\n    for (; i < length; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upper_mask = vdupq_n_u8(0x20); // Mask for upper case letters\n        uint8x16_t is_upper = vandq_u8(chars, upper_mask);\n        uint8x16_t upper_chars = vbslq_u8(vceqq_u8(is_upper, vdupq_n_u8(0)), chars, vdupq_n_u8(0));\n        sum += vaddvq_u8(upper_chars);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<int>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t upper_mask = vdupq_n_u8(0);\n        uint8x16_t ascii_sum = vdupq_n_u8(0);\n\n        // Create a mask for uppercase letters (A-Z)\n        upper_mask = vorrq_u8(upper_mask, vandq_u8(vandq_u8(data, vdupq_n_u8(0xDF)), vdupq_n_u8(0x20)));\n        upper_mask = vceqq_u8(upper_mask, vdupq_n_u8(0x20));\n\n        // Sum ASCII values of uppercase letters\n        ascii_sum = vbslq_u8(upper_mask, data, ascii_sum);\n        sum += vaddvq_u8(ascii_sum);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<int>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t upper_mask = vdupq_n_u8(0x20); // Mask for upper case letters\n        uint8x16_t is_upper = vcleq_u8(chars, vdupq_n_u8('Z')) & vcgtq_u8(chars, vdupq_n_u8('@'));\n        uint8x16_t ascii_sum = vandq_u8(chars, is_upper);\n        sum += vaddvq_u8(ascii_sum);\n    }\n\n    // Handle remaining characters\n    for (; i < length; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<int>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int length = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF); // Mask for upper case letters\n        uint8x16_t is_upper = vceqq_u8(chars, vandq_u8(chars, upper_mask));\n\n        // Convert to ASCII values and sum only upper case letters\n        uint8x16_t ascii_values = vsubq_u8(chars, vdupq_n_u8(65)); // 'A' is 65\n        uint8x16_t ascii_sum = vbslq_u8(is_upper, ascii_values, vdupq_n_u8(0));\n        sum += vaddvq_u8(ascii_sum);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<int>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int size = arr.size();\n    if (size == 0) return {};\n\n    int32x4_t min_even_value = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t min_even_index = vdupq_n_s32(-1);\n    int32x4_t index_vector = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(data, vdupq_n_s32(1));\n        int32x4_t even_mask = vceqq_s32(is_even, vdupq_n_s32(0));\n        \n        // Update indices\n        int32x4_t current_indices = vaddq_s32(index_vector, vdupq_n_s32(i));\n        \n        // Compare and select minimum even values\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_s32(even_mask, j) != 0) {\n                if (vgetq_lane_s32(data, j) < vgetq_lane_s32(min_even_value, 0)) {\n                    min_even_value = vdupq_n_s32(vgetq_lane_s32(data, j));\n                    min_even_index = vdupq_n_s32(vgetq_lane_s32(current_indices, j));\n                }\n            }\n        }\n        \n        index_vector = vaddq_s32(index_vector, vdupq_n_s32(4));\n    }\n\n    int smallest_value = vgetq_lane_s32(min_even_value, 0);\n    int smallest_index = vgetq_lane_s32(min_even_index, 0);\n    \n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n    \n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int size = arr.size();\n    if (size == 0) return {};\n\n    int32x4_t min_even_value = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t min_even_index = vdupq_n_s32(-1);\n    int32x4_t indices = vdupq_n_s32(0);\n    \n    int i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        uint32x4_t is_even = vandq_u32(vshrq_n_u32(vreinterpretq_u32_s32(vec), 1), vdupq_n_u32(1));\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(is_even, j)) {\n                if (vgetq_lane_s32(vec, j) < vgetq_lane_s32(min_even_value, 0)) {\n                    min_even_value = vdupq_n_s32(vgetq_lane_s32(vec, j));\n                    min_even_index = vdupq_n_s32(i + j);\n                }\n            }\n        }\n    }\n\n    for (; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < vgetq_lane_s32(min_even_value, 0)) {\n                min_even_value = vdupq_n_s32(arr[i]);\n                min_even_index = vdupq_n_s32(i);\n            }\n        }\n    }\n\n    if (vgetq_lane_s32(min_even_index, 0) == -1) return {};\n    \n    return {vgetq_lane_s32(min_even_value, 0), vgetq_lane_s32(min_even_index, 0)};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int size = arr.size();\n    if (size == 0) return {};\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    int vec_size = size / 4 * 4; // Process in multiples of 4\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        uint32x4_t even_mask = vandq_u32(vshrq_n_u32(vreinterpretq_u32_s32(data), 1), vdupq_n_u32(1));\n        \n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_u32(even_mask, j) && vgetq_lane_s32(data, j) < min_even) {\n                min_even = vgetq_lane_s32(data, j);\n                min_index = i + j;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < size; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int size = arr.size();\n    if (size == 0) return {};\n\n    int32x4_t min_even = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t min_index = vdupq_n_s32(-1);\n    int32x4_t indices = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(vec, vdupq_n_s32(1)); // Check if even\n        is_even = vceqq_s32(is_even, vdupq_n_s32(0)); // Convert to boolean\n        \n        int32x4_t even_values = vbslq_s32(is_even, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n        min_even = vminq_s32(min_even, even_values);\n        \n        int32x4_t current_indices = vld1q_s32(&indices[0]);\n        current_indices = vaddq_s32(current_indices, vdupq_n_s32(4));\n        min_index = vbslq_s32(vceqq_s32(even_values, min_even), current_indices, min_index);\n        \n        indices = current_indices;\n    }\n\n    int32x4_t min_even_index = vminq_s32(min_index, min_index);\n    int32_t min_value_arr[4], min_index_arr[4];\n    vst1q_s32(min_value_arr, min_even);\n    vst1q_s32(min_index_arr, min_index);\n\n    int min_value = std::numeric_limits<int>::max();\n    int min_idx = -1;\n    for (int j = 0; j < 4; j++) {\n        if (min_value_arr[j] < min_value) {\n            min_value = min_value_arr[j];\n            min_idx = min_index_arr[j];\n        }\n    }\n\n    if (min_value == std::numeric_limits<int>::max()) return {};\n    return {min_value, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    int32x4_t min_even = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t min_index = vdupq_n_s32(-1);\n    int32x4_t indices = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(vec, vdupq_n_s32(1));\n        int32x4_t mask = vceqq_s32(is_even, vdupq_n_s32(0));\n\n        // Update indices\n        int32x4_t current_indices = vaddq_s32(indices, vdupq_n_s32(i));\n        indices = vaddq_s32(indices, vdupq_n_s32(4));\n\n        // Select even values\n        vec = vbslq_s32(mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n        \n        // Compare and find minimum even value\n        min_even = vminq_s32(min_even, vec);\n        min_index = vbslq_s32(vceqq_s32(min_even, vec), current_indices, min_index);\n    }\n\n    // Handle remaining elements if n is not a multiple of 4\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < vgetq_lane_s32(min_even, 0)) {\n                min_even = vdupq_n_s32(arr[i]);\n                min_index = vdupq_n_s32(i);\n            }\n        }\n    }\n\n    int min_val = vgetq_lane_s32(min_even, 0);\n    int min_idx = vgetq_lane_s32(min_index, 0);\n    \n    if (min_val == std::numeric_limits<int>::max()) return {};\n    \n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int max_value = 0;\n    int size = lst.size();\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> frequency_map;\n    for (int num : lst) {\n        frequency_map[num]++;\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    // Prepare to check frequencies using Neon\n    int32x4_t max_freq = vdupq_n_s32(-1);\n    int32x4_t indices = vdupq_n_s32(0);\n    \n    for (int i = 1; i <= max_value; i += 4) {\n        int32x4_t current = vld1q_s32(&frequency_map[i]);\n        int32x4_t condition = vcgeq_s32(current, vdupq_n_s32(i));\n        \n        // Update max_freq if condition is met\n        max_freq = vmaxq_s32(max_freq, vandq_s32(current, condition));\n        \n        // Store the index of the valid maximum\n        indices = vbslq_s32(condition, vdupq_n_s32(i), indices);\n    }\n\n    // Find the maximum value from max_freq\n    int32x4_t max_val = vmaxq_s32(max_freq, vextq_s32(max_freq, max_freq, 1));\n    max_val = vmaxq_s32(max_val, vextq_s32(max_val, max_val, 2));\n    \n    int result = vgetq_lane_s32(max_val, 0);\n    if (result <= 0) return -1;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int max_value = 0;\n    int size = lst.size();\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> frequency_map;\n    for (int num : lst) {\n        frequency_map[num]++;\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    // Prepare to find the greatest integer with the required frequency\n    int result = -1;\n\n    // Use Neon to check frequencies in parallel\n    for (int i = 1; i <= max_value; i += 4) {\n        uint8x8_t indices = vld1_u8((const uint8_t*)&i);\n        uint8x8_t freqs = {0, 0, 0, 0};\n\n        for (int j = 0; j < 4 && (i + j) <= max_value; j++) {\n            int current = i + j;\n            freqs[j] = frequency_map[current] >= current ? current : 0;\n        }\n\n        // Find the maximum value in freqs\n        uint8x8_t max_vals = vmax_u8(freqs, vdup_n_u8(0));\n        uint8_t max_val_array[8];\n        vst1_u8(max_val_array, max_vals);\n        \n        for (int j = 0; j < 4; j++) {\n            if (max_val_array[j] > result) {\n                result = max_val_array[j];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int max_value = 0;\n    int size = lst.size();\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> frequency_map;\n    for (int num : lst) {\n        frequency_map[num]++;\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    // Prepare to find the greatest integer with the required frequency\n    int result = -1;\n\n    // Use Neon to check frequencies\n    for (int i = 1; i <= max_value; i += 4) {\n        uint8x8_t indices = vld1_u8((uint8_t*)&frequency_map[i]);\n        uint8x8_t freqs = vld1_u8((uint8_t*)&frequency_map[i + 1]);\n        uint8x8_t freqs2 = vld1_u8((uint8_t*)&frequency_map[i + 2]);\n        uint8x8_t freqs3 = vld1_u8((uint8_t*)&frequency_map[i + 3]);\n\n        uint8x8_t conditions = vdup_n_u8(0);\n        conditions = vorr_u8(conditions, vcgt_u8(indices, vdup_n_u8(i)));\n        conditions = vorr_u8(conditions, vcgt_u8(freqs, vdup_n_u8(i + 1)));\n        conditions = vorr_u8(conditions, vcgt_u8(freqs2, vdup_n_u8(i + 2)));\n        conditions = vorr_u8(conditions, vcgt_u8(freqs3, vdup_n_u8(i + 3)));\n\n        uint8x8_t result_mask = vand_u8(conditions, vdup_n_u8(1));\n        uint8x8_t max_result = vdup_n_u8(result);\n\n        for (int j = 0; j < 4; j++) {\n            if (result_mask[j] && (i + j) > max_result[0]) {\n                max_result[0] = i + j;\n            }\n        }\n        result = max_result[0];\n    }\n\n    return result > 0 ? result : -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int max_value = 0;\n    int size = lst.size();\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> frequency_map;\n    for (int num : lst) {\n        frequency_map[num]++;\n        if (num > max_value) {\n            max_value = num;\n        }\n    }\n\n    // Prepare to check frequencies using Neon\n    int32x4_t max_freq = vdupq_n_s32(-1);\n    int32x4_t indices = vdupq_n_s32(0);\n    \n    for (int i = 1; i <= max_value; i += 4) {\n        int32x4_t current = vld1q_s32(&frequency_map[i]);\n        max_freq = vmaxq_s32(max_freq, current);\n        indices = vsetq_lane_s32(i, indices, 0);\n        indices = vsetq_lane_s32(i + 1, indices, 1);\n        indices = vsetq_lane_s32(i + 2, indices, 2);\n        indices = vsetq_lane_s32(i + 3, indices, 3);\n    }\n\n    // Find the greatest integer with the required frequency\n    int32x4_t result = vdupq_n_s32(-1);\n    for (int i = 0; i < 4; i++) {\n        int32_t freq = vgetq_lane_s32(max_freq, i);\n        if (freq >= vgetq_lane_s32(indices, i) && freq > 0) {\n            result = vsetq_lane_s32(vgetq_lane_s32(indices, i), result, i);\n        }\n    }\n\n    // Check the result\n    int32_t final_result = vgetq_lane_s32(result, 0);\n    for (int i = 1; i < 4; i++) {\n        final_result = std::max(final_result, vgetq_lane_s32(result, i));\n    }\n\n    return final_result == -1 ? -1 : final_result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int max_value = 0;\n    std::unordered_map<int, int> frequency_map;\n\n    // Count frequencies using SIMD\n    int size = lst.size();\n    int remainder = size % 4;\n    int vector_size = size - remainder;\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            int value = vgetq_lane_s32(vec, j);\n            if (value > 0) {\n                frequency_map[value]++;\n                max_value = std::max(max_value, value);\n            }\n        }\n    }\n\n    for (int i = vector_size; i < size; i++) {\n        int value = lst[i];\n        if (value > 0) {\n            frequency_map[value]++;\n            max_value = std::max(max_value, value);\n        }\n    }\n\n    for (int i = max_value; i > 0; i--) {\n        if (frequency_map[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false; // Not balanced\n        }\n    }\n\n    // Calculate the sum using SIMD\n    int sum = 0;\n    int remainder = n % 4;\n    int i = 0;\n\n    // Process in chunks of 4\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum += vaddvq_s32(vec); // Sum the elements in the vector\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using SIMD\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    int sum = vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 1) + \n              vgetq_lane_s32(sum_vec, 2) + vgetq_lane_s32(sum_vec, 3);\n    \n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using SIMD\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    int32_t sum = vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 1) +\n                  vgetq_lane_s32(sum_vec, 2) + vgetq_lane_s32(sum_vec, 3);\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using SIMD\n    int sum = 0;\n    int remaining = n % 4;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < n - remaining; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (int i = n - remaining; i < n; i++) {\n        sum += q[i];\n    }\n\n    // Horizontal add the SIMD sum\n    sum += vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 1) + \n           vgetq_lane_s32(sum_vec, 2) + vgetq_lane_s32(sum_vec, 3);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using SIMD\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, data_vec);\n    }\n\n    // Handle remaining elements\n    int sum = vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 1) + \n              vgetq_lane_s32(sum_vec, 2) + vgetq_lane_s32(sum_vec, 3);\n    for (; i < n; i++) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        // Compare left and right elements\n        uint32x4_t eq = vceqq_s32(left, right);\n\n        // Count mismatches\n        changes += 4 - vaddvq_u32(eq);\n    }\n\n    if (n % 2 != 0) {\n        // If the length is odd, the middle element does not need to be changed\n        changes += 0;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - 1 - i]);\n\n        // Compare elements\n        uint32x4_t cmp = vceqq_s32(left, right);\n        uint32x4_t mask = vdupq_n_u32(1);\n        mask = vbslq_u32(cmp, vdupq_n_u32(0), mask);\n\n        // Count the number of changes needed\n        changes += vaddvq_u32(mask);\n    }\n\n    // Handle the case for odd length arrays\n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Process pairs from both ends towards the center\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - 1 - i]);\n\n        // Compare left and right elements\n        uint32x4_t eq = vceqq_s32(left, right);\n        uint32x4_t mask = vdupq_n_u32(1);\n        mask = vbslq_u32(eq, vdupq_n_u32(0), mask); // Set mask to 0 if equal, 1 if not\n\n        // Count the number of changes needed\n        changes += vaddvq_u32(mask);\n    }\n\n    // Handle the case where the array has an odd number of elements\n    if (n % 2 == 1) {\n        changes += (arr[n / 2] != arr[n / 2]) ? 1 : 0;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 1]);\n\n        // Compare left and right elements\n        uint32x4_t cmp = vceqq_s32(left, right);\n        // Count the number of matches\n        int32x4_t count = vreinterpretq_s32_u32(vcntq_u32(cmp));\n\n        // Sum the counts\n        changes += 4 - vgetq_lane_s32(count, 0) - vgetq_lane_s32(count, 1) - \n                   vgetq_lane_s32(count, 2) - vgetq_lane_s32(count, 3);\n    }\n\n    // Handle the case for odd length arrays\n    if (n % 2 != 0) {\n        changes += 0; // Middle element does not need to be changed\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        // Compare left and right elements\n        uint32x4_t cmp = vceqq_s32(left, right);\n        // Count the number of equal elements\n        int32x4_t count = vaddq_s32(vdupq_n_s32(1), vreinterpretq_s32_u32(cmp));\n        changes += 4 - vaddvq_s32(count);\n    }\n\n    // Handle the case where the array size is odd\n    if (n % 2 != 0) {\n        changes += 1; // The middle element doesn't need to be changed\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    // Compare total character counts\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    uint64_t result = 1;\n    uint64_t n_vec[2] = {n, n};\n    uint64x2_t n_simd = vld1q_u64(n_vec);\n\n    while (result < x) {\n        result *= n;\n        if (result == x) return true;\n\n        uint64x2_t result_vec = vdupq_n_u64(result);\n        uint64x2_t x_vec = vdupq_n_u64(x);\n        uint64x2_t cmp = vceqq_u64(result_vec, x_vec);\n\n        if (vmaxvq_u64(cmp) == 1) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n; // Handle edge cases for n = 0, 1\n    if (x < 1) return false; // Handle case where x < 1\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t result = vdupq_n_u64(1);\n    \n    while (vgetq_lane_u64(result, 0) <= x && vgetq_lane_u64(result, 1) <= x) {\n        result = vmulq_u64(result, vec_n);\n        if (vgetq_lane_u64(result, 0) == x || vgetq_lane_u64(result, 1) == x) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    uint64_t power = n;\n    uint64_t result[2] = {0, 0};\n    uint64x2_t v_power = vdupq_n_u64(power);\n    uint64x2_t v_x = vdupq_n_u64(x);\n    \n    for (int i = 0; i < 64; i += 2) {\n        uint64x2_t v_result = vdupq_n_u64(1);\n        for (int j = 0; j < 64; j++) {\n            v_result = vmulq_u64(v_result, v_power);\n            uint64x2_t cmp = vceqq_u64(v_result, v_x);\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n; // Handle edge cases for n = 0, 1\n    if (x < 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t power = vdupq_n_u64(1);\n    \n    while (vgetq_lane_u64(power, 0) <= x && vgetq_lane_u64(power, 1) <= x) {\n        if (vgetq_lane_u64(power, 0) == x || vgetq_lane_u64(power, 1) == x) {\n            return true;\n        }\n        power = vmulq_u64(power, vec_n);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n; // Handle cases where n is 0 or 1\n\n    uint64_t result = 1;\n    uint64_t n_vec[2] = {n, n}; // Prepare n for SIMD\n    uint64x2_t n_simd = vld1q_u64(n_vec);\n\n    while (result < x) {\n        result *= n;\n        if (result >= x) break;\n    }\n\n    return result == x;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    int i = 0;\n\n    // Prepare a mask for prime hexadecimal digits: 2, 3, 5, 7, B, D\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x02)); // 2\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x03)); // 3\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x05)); // 5\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x07)); // 7\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0B)); // B\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0D)); // D\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t hex_digits = vld1q_u8(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        uint8x16_t is_prime = vandq_u8(hex_digits, prime_mask);\n        count += vaddvq_u8(vceqq_u8(is_prime, prime_mask));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char digit = num[i];\n        if (digit == '2' || digit == '3' || digit == '5' || digit == '7' || digit == 'B' || digit == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    int i = 0;\n\n    // Prepare a mask for prime hexadecimal digits: 2, 3, 5, 7, B, D\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x02)); // 2\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x03)); // 3\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x05)); // 5\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x07)); // 7\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0B)); // B\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0D)); // D\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t hex_digits = vld1q_u8(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        uint8x16_t is_prime = vceqq_u8(hex_digits, prime_mask);\n        count += vaddvq_u8(is_prime);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char digit = num[i];\n        if (digit == '2' || digit == '3' || digit == '5' || digit == '7' || digit == 'B' || digit == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    int i = 0;\n\n    // Define a mask for prime hexadecimal digits: 2, 3, 5, 7, B, D\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x02)); // 2\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x03)); // 3\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x05)); // 5\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x07)); // 7\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0B)); // B\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0D)); // D\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t hex_digits = vld1q_u8(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        // Convert ASCII to hexadecimal value\n        hex_digits = vsubq_u8(hex_digits, vdupq_n_u8('0'));\n        uint8x16_t mask = vdupq_n_u8(0x0F);\n        uint8x16_t hex_values = vandq_u8(hex_digits, mask);\n        \n        // Count primes\n        uint8x16_t is_prime = vceqq_u8(hex_values, prime_mask);\n        count += vaddvq_u8(is_prime);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        char hex_digit = num[i];\n        if (hex_digit >= '0' && hex_digit <= '9') {\n            if (hex_digit == '2' || hex_digit == '3' || hex_digit == '5' || hex_digit == '7') {\n                count++;\n            }\n        } else if (hex_digit >= 'A' && hex_digit <= 'F') {\n            if (hex_digit == 'B' || hex_digit == 'D') {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    int i = 0;\n\n    // Define a mask for prime hexadecimal digits: 2, 3, 5, 7, B (11), D (13)\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x02)); // 2\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x03)); // 3\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x05)); // 5\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x07)); // 7\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0B)); // B\n    prime_mask = vorrq_u8(prime_mask, vdupq_n_u8(0x0D)); // D\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t hex_digits = vld1q_u8(reinterpret_cast<const uint8_t*>(num.data() + i));\n        uint8x16_t is_prime = vceqq_u8(hex_digits, prime_mask);\n        count += vaddvq_u8(is_prime);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' || \n            num[i] == 'B' || num[i] == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const uint8x16_t primes_mask = vdupq_n_u8(0);\n    uint8x16_t prime_digits = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    \n    // Set mask for prime hexadecimal digits\n    // 2 (0x2), 3 (0x3), 5 (0x5), 7 (0x7), B (0xB), D (0xD)\n    primes_mask = vdupq_n_u8(0);\n    prime_digits = vsetq_lane_u8(1, prime_digits, 2); // 2\n    prime_digits = vsetq_lane_u8(1, prime_digits, 3); // 3\n    prime_digits = vsetq_lane_u8(1, prime_digits, 5); // 5\n    prime_digits = vsetq_lane_u8(1, prime_digits, 7); // 7\n    prime_digits = vsetq_lane_u8(1, prime_digits, 11); // B\n    prime_digits = vsetq_lane_u8(1, prime_digits, 13); // D\n\n    int count = 0;\n    size_t length = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t hex_digits = vld1q_u8(reinterpret_cast<const uint8_t*>(num.data() + i));\n        uint8x16_t is_prime = vtbl1q_u8(prime_digits, hex_digits);\n        count += vaddvq_u8(is_prime);\n    }\n\n    for (; i < length; ++i) {\n        char digit = num[i];\n        if (digit == '2' || digit == '3' || digit == '5' || digit == '7' || digit == 'B' || digit == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int length = s.length();\n    if (length < 3) return false;\n\n    const char* str = s.c_str();\n    int i = 0;\n\n    // Process the string in chunks of 16 bytes (16 characters)\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t unique_mask = vdupq_n_u8(0);\n\n        for (int j = 0; j < 16; j++) {\n            uint8_t current_char = vgetq_lane_u8(data, j);\n            uint8x16_t char_mask = vdupq_n_u8(current_char);\n            unique_mask = vorrq_u8(unique_mask, vceqq_u8(data, char_mask));\n        }\n\n        // Check if there are any duplicates in the first 14 characters\n        if (vmaxvq_u8(unique_mask) > 1) return false;\n    }\n\n    // Handle the remaining characters\n    for (; i <= length - 3; i++) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    int i = 0;\n\n    for (; i <= len - 3; i += 3) {\n        uint8x8_t chars = vld1_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x8_t unique_mask = vdup_n_u8(0);\n        \n        // Check for distinct characters\n        for (int j = 0; j < 3; ++j) {\n            uint8_t char_val = vget_lane_u8(chars, j);\n            unique_mask = vorr_u8(unique_mask, vshl_n_u8(vdup_n_u8(1), char_val));\n        }\n\n        // If unique_mask has more than 3 bits set, then they are not distinct\n        if (vmax_u8(unique_mask) > 3) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        if (i > 0 && str[i] == str[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const char *str = s.c_str();\n    int i = 0;\n\n    // Process the string in chunks of 16 bytes (16 characters)\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t distinct_mask = vdupq_n_u8(0);\n\n        for (int j = 0; j < 16; j++) {\n            uint8x16_t cmp = vceqq_u8(chars, vdupq_n_u8(vgetq_lane_u8(chars, j)));\n            distinct_mask = vorrq_u8(distinct_mask, cmp);\n        }\n\n        // Check if there are any duplicates in the first 16 characters\n        if (vmaxvq_u8(distinct_mask) != 0xFF) return false;\n    }\n\n    // Handle the remaining characters\n    for (; i <= len - 3; i++) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    int i = 0;\n\n    // Process the string in chunks of 3 characters\n    for (; i <= len - 3; i += 3) {\n        uint8x8_t chars = vld1_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x8_t unique_mask = vdup_n_u8(0);\n\n        // Check for distinct characters\n        for (int j = 0; j < 3; j++) {\n            uint8_t char_val = vget_lane_u8(chars, j);\n            unique_mask = vorr_u8(unique_mask, vshl_n_u8(vdup_n_u8(1), char_val));\n        }\n\n        // If the count of unique characters is not 3, return false\n        if (vaddv_u8(vand_u8(unique_mask, vdup_n_u8(1))) != 3) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (i > 0 && str[i] == str[i - 1]) return false;\n        if (i > 1 && str[i] == str[i - 2]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    int i = 0;\n\n    for (; i <= len - 3; i += 3) {\n        uint8x8_t chars = vld1_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x8_t unique_mask = vdup_n_u8(0);\n\n        // Check for distinct characters\n        for (int j = 0; j < 3; ++j) {\n            uint8x8_t cmp = vdup_n_u8(vget_lane_u8(chars, j));\n            unique_mask = vorr_u8(unique_mask, vceqq_u8(chars, cmp));\n        }\n\n        // If any character is repeated, return false\n        if (vmax_u8(unique_mask) != vdup_n_u8(0xFF)) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        if (i >= 2 && str[i] == str[i - 1] || str[i] == str[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    \n    // Check if length is less than 16 for SIMD processing\n    if (length < 16) {\n        return is_prime(length);\n    }\n\n    // Use Neon to check for prime length\n    uint8x16_t lengths = vdupq_n_u8(length);\n    uint8x16_t is_prime_mask = vdupq_n_u8(1); // Assume all are prime initially\n\n    // Check divisibility by 2 and 3\n    uint8x16_t even_mask = vdupq_n_u8(2);\n    uint8x16_t three_mask = vdupq_n_u8(3);\n\n    is_prime_mask = vbslq_u8(vceqq_u8(lengths, even_mask), vdupq_n_u8(0), is_prime_mask);\n    is_prime_mask = vbslq_u8(vceqq_u8(lengths, three_mask), vdupq_n_u8(0), is_prime_mask);\n\n    // Check for other factors\n    for (int i = 5; i * i <= length; i += 6) {\n        uint8x16_t factor_mask = vdupq_n_u8(i);\n        uint8x16_t factor_plus_two_mask = vdupq_n_u8(i + 2);\n\n        is_prime_mask = vbslq_u8(vceqq_u8(lengths, factor_mask), vdupq_n_u8(0), is_prime_mask);\n        is_prime_mask = vbslq_u8(vceqq_u8(lengths, factor_plus_two_mask), vdupq_n_u8(0), is_prime_mask);\n    }\n\n    // Check if any value in is_prime_mask is still 1 (true)\n    return vmaxvq_u8(is_prime_mask) != 0;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    \n    // Using Neon to check if the length is prime\n    uint8x16_t lengths = vdupq_n_u8(length);\n    uint8x16_t primes = vdupq_n_u8(1); // Assume all are prime initially\n\n    // Check for non-prime conditions\n    uint8x16_t non_prime_conditions = vdupq_n_u8(0);\n    non_prime_conditions = vorrq_u8(non_prime_conditions, vceqq_u8(lengths, vdupq_n_u8(0))); // length <= 1\n    non_prime_conditions = vorrq_u8(non_prime_conditions, vceqq_u8(lengths, vdupq_n_u8(1))); // length <= 1\n    non_prime_conditions = vorrq_u8(non_prime_conditions, vceqq_u8(lengths, vdupq_n_u8(2))); // length == 2\n    non_prime_conditions = vorrq_u8(non_prime_conditions, vceqq_u8(lengths, vdupq_n_u8(3))); // length == 3\n\n    // If length is 2 or 3, it's prime\n    if (vmaxvq_u8(non_prime_conditions) != 0) {\n        return true;\n    }\n\n    // Check for even numbers\n    uint8x16_t even_check = vandq_u8(lengths, vdupq_n_u8(1));\n    primes = vbslq_u8(even_check, vdupq_n_u8(0), primes); // Set to 0 if even\n\n    // Check for divisibility by numbers from 5 to sqrt(length)\n    for (int i = 5; i * i <= length; i += 6) {\n        uint8x16_t divisor = vdupq_n_u8(i);\n        uint8x16_t divisor_plus_2 = vdupq_n_u8(i + 2);\n        uint8x16_t divisible_by_i = vceqq_u8(vandq_u8(lengths, vdupq_n_u8(i)), vdupq_n_u8(0));\n        uint8x16_t divisible_by_i_plus_2 = vceqq_u8(vandq_u8(lengths, vdupq_n_u8(i + 2)), vdupq_n_u8(0));\n        primes = vbslq_u8(divisible_by_i, vdupq_n_u8(0), primes);\n        primes = vbslq_u8(divisible_by_i_plus_2, vdupq_n_u8(0), primes);\n    }\n\n    return vmaxvq_u8(primes) != 0;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    int result = is_prime(length);\n    \n    uint8x8_t length_vec = vdup_n_u8(length);\n    uint8x8_t prime_vec = vdup_n_u8(result ? 1 : 0);\n    \n    uint8x8_t comparison = vceqq_u8(length_vec, prime_vec);\n    return vget_lane_u8(comparison, 0) != 0;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 16) {\n        return is_prime(length);\n    }\n\n    uint8x16_t lengths = vdupq_n_u8(length);\n    uint8x16_t primes = vdupq_n_u8(1); // Assume all are prime initially\n\n    for (int i = 2; i <= 15; i++) {\n        uint8x16_t i_vec = vdupq_n_u8(i);\n        uint8x16_t is_divisible = vceqq_u8(vandq_u8(lengths, vdupq_n_u8(i)), vdupq_n_u8(0));\n        primes = vbslq_u8(is_divisible, vdupq_n_u8(0), primes);\n    }\n\n    uint8x16_t result = vceqq_u8(primes, vdupq_n_u8(1));\n    return vgetq_lane_u8(result, 0) != 0;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    \n    // Using Neon to check if the length is prime\n    uint8x16_t lengths = vdupq_n_u8(length);\n    uint8x16_t is_prime_mask = vdupq_n_u8(1); // Assume prime initially\n\n    // Check for small numbers\n    uint8x16_t small_primes = vdupq_n_u8(1);\n    small_primes = vbslq_u8(vceqq_u8(lengths, vdupq_n_u8(0)), vdupq_n_u8(0), small_primes);\n    small_primes = vbslq_u8(vceqq_u8(lengths, vdupq_n_u8(1)), vdupq_n_u8(0), small_primes);\n    small_primes = vbslq_u8(vceqq_u8(lengths, vdupq_n_u8(2)), vdupq_n_u8(1), small_primes);\n    small_primes = vbslq_u8(vceqq_u8(lengths, vdupq_n_u8(3)), vdupq_n_u8(1), small_primes);\n    \n    // Check for even numbers greater than 2\n    is_prime_mask = vbslq_u8(vandq_u8(vceqq_u8(lengths, vdupq_n_u8(2)), vdupq_n_u8(0)), is_prime_mask, small_primes);\n    is_prime_mask = vbslq_u8(vandq_u8(vcltq_u8(lengths, vdupq_n_u8(2)), vdupq_n_u8(0)), is_prime_mask, small_primes);\n\n    // Check for divisibility by 2 and 3\n    is_prime_mask = vbslq_u8(vandq_u8(vceqq_u8(vandq_u8(lengths, vdupq_n_u8(1)), vdupq_n_u8(0)), vdupq_n_u8(0)), is_prime_mask, small_primes);\n    is_prime_mask = vbslq_u8(vandq_u8(vceqq_u8(vandq_u8(lengths, vdupq_n_u8(3)), vdupq_n_u8(0)), vdupq_n_u8(0)), is_prime_mask, small_primes);\n\n    // Final check for larger numbers\n    if (is_prime(length)) {\n        return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t count = 0;\n    while (N > 0) {\n        count += (N & 1);\n        N >>= 1;\n    }\n\n    uint64_t sum = count;\n    std::string binary = std::bitset<64>(sum).to_string();\n    \n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    if (pos != std::string::npos) {\n        return binary.substr(pos);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 0xF; // Mask for 4 bits\n    uint64_t temp = N;\n\n    // Process 16 bits at a time\n    uint64x2_t vec = vdupq_n_u64(0);\n    for (int i = 0; i < 16; i++) {\n        vec = vaddq_u64(vec, vdupq_n_u64((temp & mask) ? 1 : 0));\n        temp >>= 4;\n    }\n\n    // Sum the vector elements\n    uint64_t result[2];\n    vst1q_u64(result, vec);\n    sum = result[0] + result[1];\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    return pos == std::string::npos ? \"0\" : binary.substr(pos);\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 0xF; // Mask to extract 4 bits at a time\n    uint64_t temp = N;\n\n    // Process 16 bits at a time using Neon\n    uint64x2_t vec = vdupq_n_u64(0);\n    for (int i = 0; i < 16; i++) {\n        vec = vaddq_u64(vec, vdupq_n_u64((temp & mask) ? 1 : 0));\n        temp >>= 4;\n    }\n\n    // Sum the results\n    sum = vgetq_lane_u64(vec, 0) + vgetq_lane_u64(vec, 1);\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    return binary.substr(binary.find('1')); // Remove leading zeros\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t count = 0;\n    while (N > 0) {\n        count += (N & 1);\n        N >>= 1;\n    }\n\n    // Convert count to binary string\n    std::string binary = std::bitset<64>(count).to_string();\n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    if (pos != std::string::npos) {\n        return binary.substr(pos);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t count = 0;\n    while (N > 0) {\n        count += (N & 1);\n        N >>= 1;\n    }\n\n    uint64_t result = 1;\n    for (int i = 0; i < count - 1; ++i) {\n        result <<= 1;\n        result |= 1;\n    }\n\n    return std::bitset<64>(result).to_string().substr(64 - (count > 0 ? count : 1));\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 1; i < size; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vandq_s32(data_vec, vdupq_n_s32(1)); // Mask to check even numbers\n        even_mask = vceqq_s32(even_mask, vdupq_n_s32(0)); // Create mask for even numbers\n        sum_vec = vaddq_s32(sum_vec, vandq_s32(data_vec, even_mask)); // Add even numbers\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 1; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int32x4_t mask = vandq_s32(data, vdupq_n_s32(1)); // mask for even numbers\n        int32x4_t even_elements = vbslq_s32(mask, data, vdupq_n_s32(0)); // select even elements\n        sum_vec = vaddq_s32(sum_vec, even_elements);\n    }\n    \n    int32_t result[4];\n    vst1q_s32(result, sum_vec);\n    \n    for (int j = 0; j < 4; j++) {\n        sum += result[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 1; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int32x4_t mask = vandq_s32(data, vdupq_n_s32(1)); // Mask to check even numbers\n        int32x4_t even_elements = vbslq_s32(mask, data, vdupq_n_s32(0)); // Select even elements\n        sum_vec = vaddq_s32(sum_vec, even_elements);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 1; i < size; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vandq_s32(data_vec, vdupq_n_s32(1)); // Mask for even numbers\n        int32x4_t odd_indices_mask = vdupq_n_s32(0);\n        \n        // Create mask for odd indices\n        odd_indices_mask = vdupq_n_s32(0);\n        odd_indices_mask = vorrq_s32(odd_indices_mask, vdupq_n_s32(0xFFFFFFFF));\n        odd_indices_mask = vshrq_n_s32(odd_indices_mask, 1);\n        \n        // Apply masks\n        data_vec = vandq_s32(data_vec, odd_indices_mask);\n        data_vec = vandq_s32(data_vec, even_mask);\n        \n        sum_vec = vaddq_s32(sum_vec, data_vec);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 1; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vandq_s32(data, vdupq_n_s32(1)); // Mask to check for even numbers\n        int32x4_t odd_indices_mask = vdupq_n_s32(1); // Mask for odd indices\n        odd_indices_mask = vshlq_n_s32(odd_indices_mask, 1); // Shift to start from the second element\n        \n        // Select even numbers at odd indices\n        int32x4_t result = vbslq_s32(odd_indices_mask, data, vdupq_n_s32(0));\n        result = vandq_s32(result, vdupq_n_s32(1)); // Keep only even numbers\n        \n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n    size_t length = s.size();\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vaddq_u8(input, vdupq_n_u8(2 * 2)); // Shift by 4\n        uint8x16_t mask = vdupq_n_u8(0x1F); // Mask for alphabet\n        input = vandq_u8(input, mask); // Wrap around alphabet\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), input);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 4) % 26 + 'a'; // Shift by 4\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n    size_t length = s.size();\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vaddq_u8(input, vdupq_n_u8(2 * 2)); // Rotate by 4\n        input = vminq_u8(input, vdupq_n_u8('z')); // Clamp to 'z'\n        input = vmaxq_u8(input, vdupq_n_u8('a')); // Clamp to 'a'\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), input);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c += 4;\n            if (c > 'z') c = 'a' + (c - 'z' - 1);\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n    size_t length = s.size();\n    \n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vaddq_u8(input, vdupq_n_u8(2 * 2)); // Rotate by 4\n        input = vminq_u8(input, vdupq_n_u8('z')); // Clamp to 'z'\n        input = vmaxq_u8(input, vdupq_n_u8('a')); // Clamp to 'a'\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), input);\n    }\n    \n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c += 4;\n            if (c > 'z') c = 'a' + (c - 'z' - 1);\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        input = vaddq_u8(input, vdupq_n_u8(2)); // Shift by 2\n        input = vaddq_u8(input, vdupq_n_u8(2)); // Shift by 2 again\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), input);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 4) % 26 + 'a'; // Rotate within lowercase letters\n        } else if (c >= 'A' && c <= 'Z') {\n            c = (c - 'A' + 4) % 26 + 'A'; // Rotate within uppercase letters\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        input = vaddq_u8(input, vdupq_n_u8(2 * 2)); // Shift by 4\n        input = vminq_u8(input, vdupq_n_u8('z')); // Clamp to 'z'\n        input = vmaxq_u8(input, vdupq_n_u8('a')); // Clamp to 'a'\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), input);\n    }\n\n    for (; i < length; ++i) {\n        char ch = s[i];\n        if (ch >= 'a' && ch <= 'z') {\n            ch += 4;\n            if (ch > 'z') ch = 'a' + (ch - 'z' - 1);\n        }\n        result[i] = ch;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_case = vandq_u8(input, vdupq_n_u8(0xDF)); // To upper case\n        uint8x16_t lower_case = vorrq_u8(input, lower_mask); // To lower case\n        uint8x16_t swapped_case = vbslq_u8(vcltq_u8(input, vdupq_n_u8('a')), upper_case, lower_case);\n\n        // Replace vowels\n        uint8x16_t vowels = vdupq_n_u8(0);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t e = vdupq_n_u8('e');\n        uint8x16_t i_char = vdupq_n_u8('i');\n        uint8x16_t o = vdupq_n_u8('o');\n        uint8x16_t u = vdupq_n_u8('u');\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vceqq_u8(swapped_case, a), vceqq_u8(swapped_case, e)), \n                                                         vceqq_u8(swapped_case, i_char)), \n                                                         vceqq_u8(swapped_case, o)), \n                                                         vceqq_u8(swapped_case, u));\n\n        uint8x16_t replacement = vaddq_u8(swapped_case, vdupq_n_u8(2));\n        uint8x16_t encoded = vbslq_u8(is_vowel, replacement, swapped_case);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encoded);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'A' && c <= 'Z') {\n            c = c + 32; // to lower case\n        } else if (c >= 'a' && c <= 'z') {\n            c = c - 32; // to upper case\n        }\n\n        if (c == 'a') c = 'c';\n        else if (c == 'e') c = 'g';\n        else if (c == 'i') c = 'k';\n        else if (c == 'o') c = 'q';\n        else if (c == 'u') c = 'w';\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        uint8x16_t lower = vdupq_n_u8('a');\n        uint8x16_t upper = vdupq_n_u8('A');\n        uint8x16_t vowels = vdupq_n_u8(0);\n        \n        // Swap case\n        uint8x16_t swapped = veorq_u8(input, vshrq_n_u8(vandq_u8(input, vdupq_n_u8(0x20)), 5));\n        \n        // Identify vowels\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vceqq_u8(swapped, vdupq_n_u8('a')), vceqq_u8(swapped, vdupq_n_u8('e'))),\n                                       vorrq_u8(vceqq_u8(swapped, vdupq_n_u8('i')), vorrq_u8(vceqq_u8(swapped, vdupq_n_u8('o')), vceqq_u8(swapped, vdupq_n_u8('u')))));\n        \n        // Replace vowels\n        uint8x16_t replacement = vaddq_u8(swapped, vdupq_n_u8(2));\n        vowels = vbslq_u8(is_vowel, replacement, swapped);\n        \n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vowels);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (isalpha(c)) {\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            if (strchr(\"aeiouAEIOU\", swapped)) {\n                swapped = (swapped == 'a') ? 'c' : (swapped == 'e') ? 'g' : (swapped == 'i') ? 'k' : (swapped == 'o') ? 'q' : (swapped == 'u') ? 'w' : swapped;\n            }\n            result[i] = swapped;\n        } else {\n            result[i] = c;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.c_str() + i));\n        \n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t swapped_case = veorq_u8(input, lower_mask);\n        \n        // Replace vowels\n        uint8x16_t vowels = vdupq_n_u8(0);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t e = vdupq_n_u8('e');\n        uint8x16_t i_char = vdupq_n_u8('i');\n        uint8x16_t o = vdupq_n_u8('o');\n        uint8x16_t u = vdupq_n_u8('u');\n        \n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vceqq_u8(swapped_case, a), \n                                                            vceqq_u8(swapped_case, e)), \n                                                            vceqq_u8(swapped_case, i_char)), \n                                                            vceqq_u8(swapped_case, o));\n        is_vowel = vorrq_u8(is_vowel, vceqq_u8(swapped_case, u));\n        \n        uint8x16_t two_ahead = vaddq_u8(swapped_case, vdupq_n_u8(2));\n        uint8x16_t replaced = vbslq_u8(is_vowel, two_ahead, swapped_case);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), replaced);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Swap case\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Swap case\n        }\n        \n        if (c == 'a' || c == 'A') c = 'C';\n        else if (c == 'e' || c == 'E') c = 'G';\n        else if (c == 'i' || c == 'I') c = 'K';\n        else if (c == 'o' || c == 'O') c = 'Q';\n        else if (c == 'u' || c == 'U') c = 'W';\n        \n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t swapped_case = veorq_u8(input, lower_mask);\n\n        // Replace vowels\n        uint8x16_t vowels = vdupq_n_u8('A');\n        uint8x16_t a = vdupq_n_u8('A' - 2);\n        uint8x16_t e = vdupq_n_u8('E' - 2);\n        uint8x16_t i_char = vdupq_n_u8('I' - 2);\n        uint8x16_t o = vdupq_n_u8('O' - 2);\n        uint8x16_t u = vdupq_n_u8('U' - 2);\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vceqq_u8(swapped_case, vowels)), \n                                                  vceqq_u8(swapped_case, a)),\n                                       vorrq_u8(vceqq_u8(swapped_case, e),\n                                                 vorrq_u8(vceqq_u8(swapped_case, i_char),\n                                                           vorrq_u8(vceqq_u8(swapped_case, o), \n                                                                     vceqq_u8(swapped_case, u)))));\n\n        uint8x16_t replaced_vowels = vaddq_u8(swapped_case, vdupq_n_u8(2));\n        swapped_case = vbslq_u8(is_vowel, replaced_vowels, swapped_case);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swapped_case);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 32; // to upper case\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c + 32; // to lower case\n        }\n        if (c == 'A') c = 'C';\n        else if (c == 'E') c = 'G';\n        else if (c == 'I') c = 'K';\n        else if (c == 'O') c = 'Q';\n        else if (c == 'U') c = 'W';\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.data() + i));\n        uint8x16_t swapped_case = veorq_u8(input, vdupq_n_u8(0x20));\n\n        uint8x16_t vowels = vdupq_n_u8(0);\n        uint8x16_t replacements = vdupq_n_u8(0);\n\n        for (int j = 0; j < 16; j++) {\n            uint8_t ch = vgetq_lane_u8(swapped_case, j);\n            if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' ||\n                ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n                vowels = vsetq_lane_u8(1, vowels, j);\n                replacements = vsetq_lane_u8(ch + 2, replacements, j);\n            } else {\n                vowels = vsetq_lane_u8(0, vowels, j);\n                replacements = vsetq_lane_u8(ch, replacements, j);\n            }\n        }\n\n        uint8x16_t final_result = vbslq_u8(vowels, replacements, swapped_case);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), final_result);\n    }\n\n    for (; i < length; ++i) {\n        char ch = message[i];\n        if (isalpha(ch)) {\n            if (islower(ch)) {\n                ch = toupper(ch);\n            } else {\n                ch = tolower(ch);\n            }\n            if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U') {\n                ch += 2;\n            }\n        }\n        result[i] = ch;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i < len) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vcltq_u8(vec, vdupq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(vec, vdupq_n_u8('Z'));\n            uint8x16_t digit_mask = vcltq_u8(vec, vdupq_n_u8('0'));\n            digit_mask = vorrq_u8(digit_mask, vcltq_u8(vec, vdupq_n_u8('A')));\n            digit_mask = vorrq_u8(digit_mask, vcltq_u8(vec, vdupq_n_u8('a')));\n\n            uint8x16_t lower_check = vorrq_u8(lower_mask, digit_mask);\n            uint8x16_t upper_check = vorrq_u8(upper_mask, digit_mask);\n\n            all_lower = all_lower && (vmaxvq_u8(lower_check) == 0);\n            all_upper = all_upper && (vmaxvq_u8(upper_check) == 0);\n\n            i += 16;\n            if (i >= len) break;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i + 16 <= len) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vshrq_n_u8(chars, 5); // 'a' - 'A' = 32\n            uint8x16_t upper_mask = vshrq_n_u8(chars, 5); // 'A' - 'a' = -32\n\n            all_lower &= (vmax_u8(chars, lower_mask) == chars);\n            all_upper &= (vmin_u8(chars, upper_mask) == chars);\n            i += 16;\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c < 'a' || c > 'z') all_lower = false;\n            if (c < 'A' || c > 'Z') all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        \n        if (len % 16 != 0) {\n            // Pad the string to 16 bytes for SIMD processing\n            std::string padded_key = key;\n            padded_key.resize((len / 16 + 1) * 16, '\\0');\n            key = padded_key;\n            len = key.length();\n        }\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vdupq_n_u8(0x20); // ASCII difference between lower and upper case\n            uint8x16_t lower_check = vorrq_u8(vandq_u8(data, lower_mask), vdupq_n_u8(0x60));\n            uint8x16_t upper_check = vandq_u8(data, lower_mask);\n\n            uint8x16_t is_lower = vceqq_u8(data, lower_check);\n            uint8x16_t is_upper = vceqq_u8(data, upper_check);\n\n            uint64x2_t lower_result = vpaddlq_u8(is_lower);\n            uint64x2_t upper_result = vpaddlq_u8(is_upper);\n\n            if (vgetq_lane_u64(lower_result, 0) + vgetq_lane_u64(lower_result, 1) != 16) {\n                all_lower = false;\n            }\n            if (vgetq_lane_u64(upper_result, 0) + vgetq_lane_u64(upper_result, 1) != 16) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i + 16 <= len) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vcltq_u8(data, vdupq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(data, vdupq_n_u8('Z'));\n            uint8x16_t lower_case_mask = vcleq_u8(data, vdupq_n_u8('z'));\n            uint8x16_t upper_case_mask = vcleq_u8(data, vdupq_n_u8('Z'));\n\n            all_lower &= (vmaxvq_u8(lower_mask) == 0);\n            all_upper &= (vmaxvq_u8(upper_mask) == 0 && vmaxvq_u8(lower_case_mask) == 0);\n            i += 16;\n        }\n\n        while (i < len) {\n            char c = key[i];\n            if (c < 'a') all_lower = false;\n            if (c > 'Z' || c < 'A') all_upper = false;\n            i++;\n        }\n\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        \n        if (len % 16 != 0) {\n            // Pad the string to the next multiple of 16 for SIMD processing\n            std::string padded_key = key;\n            padded_key.resize(len + (16 - len % 16), ' '); // Padding with spaces\n            len = padded_key.length();\n            key = padded_key;\n        }\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vdupq_n_u8(0x20); // Mask for lower case check\n            uint8x16_t upper_mask = vdupq_n_u8(0x20); // Mask for upper case check\n\n            uint8x16_t lower_check = vandq_u8(data, lower_mask);\n            uint8x16_t upper_check = vceqq_u8(data, vdupq_n_u8(' ')); // Check for space\n\n            all_lower = all_lower && (vmaxvq_u8(vceqq_u8(lower_check, data)) == 0);\n            all_upper = all_upper && (vmaxvq_u8(vceqq_u8(upper_check, data)) == 0);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_2 = vdupq_n_s32(2);\n    int32x4_t vec_3 = vdupq_n_s32(3);\n    \n    for (int i = 2; i < n; i += 4) {\n        int32x4_t vec_i = vld1q_s32(&i);\n        uint32x4_t mask = vcltq_u32(vcgtq_s32(vec_i, vec_n), vdupq_n_u32(1));\n\n        for (int j = 0; j < 4; j++) {\n            if (i + j < n && is_prime(i + j)) {\n                primes.push_back(i + j);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    int count = 0;\n    int max_count = (n < 64) ? n : 64; // Limit to 64 for SIMD processing\n    uint8x8_t is_prime_vec = vdup_n_u8(1); // Assume all are prime initially\n\n    for (int i = 2; i < max_count; i += 8) {\n        uint8x8_t current_numbers = vld1_u8(reinterpret_cast<const uint8_t*>(&i));\n        for (int j = 0; j < 8 && (i + j) < n; ++j) {\n            if (!is_prime(i + j)) {\n                is_prime_vec = vsetq_lane_u8(0, is_prime_vec, j);\n            }\n        }\n        vst1_u8(reinterpret_cast<uint8_t*>(&is_prime_vec), is_prime_vec);\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    int32x4_t mask = vdupq_n_s32(0);\n    for (int i = 2; i < n; i += 4) {\n        int32x4_t indices = vld1q_s32(&is_prime[i]);\n        mask = vorrq_s32(mask, indices);\n    }\n\n    for (int i = 2; i < n; i++) {\n        if (vgetq_lane_s32(mask, i % 4) && is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    int count = 0;\n    int max_count = n / 2; // Rough estimate of how many primes there could be\n    int32x4_t indices = {0, 1, 2, 3}; // Initial indices for checking primes\n    int32x4_t results = {0, 0, 0, 0}; // To store found primes\n    int32x4_t n_vec = vdupq_n_s32(n);\n\n    for (int i = 2; i < n; i += 4) {\n        int32x4_t current_indices = vaddq_s32(indices, vdupq_n_s32(i));\n        uint32x4_t is_prime_mask = vdupq_n_u32(1);\n\n        for (int j = 2; j * j < n; j++) {\n            int32x4_t divisor = vdupq_n_s32(j);\n            uint32x4_t divisible_mask = vceqq_s32(vremq_s32(current_indices, divisor), vdupq_n_s32(0));\n            is_prime_mask = vbslq_u32(divisible_mask, vdupq_n_u32(0), is_prime_mask);\n        }\n\n        results = vbslq_s32(is_prime_mask, current_indices, results);\n        indices = vaddq_s32(indices, vdupq_n_s32(4));\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int prime = vgetq_lane_s32(results, i);\n        if (prime < n && prime != 0) {\n            primes.push_back(prime);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_two = vdupq_n_s32(2);\n    int32x4_t vec_prime_mask = vdupq_n_s32(1);\n    \n    for (int i = 2; i < n; i += 4) {\n        int32x4_t vec_i = vld1q_s32(&i);\n        uint32x4_t is_prime_mask = vdupq_n_u32(1);\n\n        for (int j = 2; j * j <= i + 3; ++j) {\n            if (j * j >= n) break;\n            int32x4_t vec_j = vdupq_n_s32(j);\n            int32x4_t vec_j_squared = vmulq_s32(vec_j, vec_j);\n            uint32x4_t div_mask = vcltq_s32(vec_j_squared, vec_n);\n            int32x4_t vec_div = vdivq_s32(vec_i, vec_j);\n            uint32x4_t mod_mask = vceqq_s32(vec_i, vmulq_s32(vec_div, vec_j));\n\n            is_prime_mask = vbic_u32(is_prime_mask, vand_u32(mod_mask, div_mask));\n        }\n\n        for (int k = 0; k < 4; ++k) {\n            if (vgetq_lane_u32(is_prime_mask, k) && (i + k) < n) {\n                primes.push_back(i + k);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    int i;\n\n    // Process 16 characters at a time\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t mask = vdupq_n_u8(0);\n        \n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('A')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('E')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('I')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('O')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('U')), vdupq_n_u8(1)));\n\n        // Count the number of set bits in the mask\n        uint8x16_t count_mask = vshrq_n_u8(mask, 7);\n        count += vaddvq_u8(count_mask);\n    }\n\n    // Process remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    int i;\n\n    // Process in chunks of 16 bytes\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t mask = vdupq_n_u8(0);\n        \n        // Create masks for uppercase vowels A, E, I, O, U\n        uint8x16_t a_mask = vceqq_u8(data, vdupq_n_u8('A'));\n        uint8x16_t e_mask = vceqq_u8(data, vdupq_n_u8('E'));\n        uint8x16_t i_mask = vceqq_u8(data, vdupq_n_u8('I'));\n        uint8x16_t o_mask = vceqq_u8(data, vdupq_n_u8('O'));\n        uint8x16_t u_mask = vceqq_u8(data, vdupq_n_u8('U'));\n        \n        mask = vorrq_u8(mask, a_mask);\n        mask = vorrq_u8(mask, e_mask);\n        mask = vorrq_u8(mask, i_mask);\n        mask = vorrq_u8(mask, o_mask);\n        mask = vorrq_u8(mask, u_mask);\n        \n        // Count the number of set bits in the mask\n        uint8_t count_mask[16];\n        vst1q_u8(count_mask, mask);\n        for (int j = 0; j < 16; j++) {\n            count += (count_mask[j] != 0);\n        }\n    }\n\n    // Handle remaining characters\n    for (; i < length; i++) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    int i;\n\n    // Process 16 bytes at a time\n    for (i = 0; i < length - 15; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t mask = vdupq_n_u8(0);\n        \n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('A')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('E')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('I')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('O')), vdupq_n_u8(1)));\n        mask = vorrq_u8(mask, vandq_u8(vceqq_u8(data, vdupq_n_u8('U')), vdupq_n_u8(1)));\n\n        // Count the number of set bits in the mask\n        uint8x16_t count_mask = vandq_u8(mask, vdupq_n_u8(1));\n        count += vaddvq_u8(count_mask);\n    }\n\n    // Handle remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    int i;\n\n    // Process in chunks of 16 bytes\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t mask = vdupq_n_u8(0);\n        \n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        uint8x16_t vowels = vdupq_n_u8(0);\n        vowels = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vdupq_n_u8('A'), vdupq_n_u8('E')), vdupq_n_u8('I')), vdupq_n_u8('O')), vdupq_n_u8('U'));\n\n        // Check for uppercase vowels at even indices\n        for (int j = 0; j < 16; j += 2) {\n            uint8x8_t even_chars = vuzpq_u8(vget_low_u8(data), vget_high_u8(data)).val[0];\n            uint8x8_t is_vowel = vceqq_u8(even_chars, vget_low_u8(vowels));\n            mask = vorrq_u8(mask, is_vowel);\n        }\n\n        // Count the number of set bits in mask\n        uint8_t mask_array[16];\n        vst1q_u8(mask_array, mask);\n        for (int j = 0; j < 16; j++) {\n            count += (mask_array[j] != 0);\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; i++) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    int i;\n\n    // Process in chunks of 16 bytes\n    for (i = 0; i < length - 15; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t mask = vdupq_n_u8(0);\n        \n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        uint8x16_t vowels = vdupq_n_u8(0);\n        vowels = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vdupq_n_u8('A'), vdupq_n_u8('E')), vdupq_n_u8('I')), vdupq_n_u8('O')), vdupq_n_u8('U'));\n\n        // Check for uppercase letters\n        uint8x16_t is_upper = vandq_u8(vandq_u8(data, vdupq_n_u8(0xDF)), vdupq_n_u8(0x20));\n        uint8x16_t is_vowel = vceqq_u8(is_upper, vowels);\n\n        // Count the vowels at even indices\n        uint8x16_t even_mask = vdupq_n_u8(0xAA); // 10101010 in binary\n        uint8x16_t even_indices = vandq_u8(is_vowel, even_mask);\n        \n        // Sum the counts\n        count += vaddvq_u8(even_indices);\n    }\n\n    // Handle remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t stones;\n\n    if (n % 2 == 0) {\n        stones = vdupq_n_s32(n); // Start with n (even)\n    } else {\n        stones = vdupq_n_s32(n + 1); // Start with n + 1 (next odd)\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        if (i > 0) {\n            stones = vaddq_s32(stones, vdupq_n_s32(2)); // Increment by 2 for next level\n        }\n        if (i + 3 < n) {\n            vst1q_s32(&result[i], stones); // Store 4 elements at once\n        } else {\n            for (int j = 0; j < n - i; ++j) {\n                result[i + j] = vgetq_lane_s32(stones, j);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t stones;\n\n    if (n % 2 == 0) {\n        stones = vdupq_n_s32(n); // Start with n (even)\n        for (int i = 0; i < n; i += 4) {\n            if (i < n) {\n                vst1q_s32(&result[i], stones);\n            }\n            stones = vaddq_s32(stones, vdupq_n_s32(2)); // Increment by 2 for next level\n        }\n    } else {\n        stones = vdupq_n_s32(n); // Start with n (odd)\n        for (int i = 0; i < n; i += 4) {\n            if (i < n) {\n                vst1q_s32(&result[i], stones);\n            }\n            stones = vaddq_s32(stones, vdupq_n_s32(2)); // Increment by 2 for next level\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t stones;\n    \n    if (n % 2 == 0) {\n        stones = vdupq_n_s32(n); // Start with n (even)\n    } else {\n        stones = vdupq_n_s32(n + 1); // Start with n + 1 (next odd)\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        if (i > 0) {\n            stones = vaddq_s32(stones, vdupq_n_s32(2)); // Increment by 2 for next level\n        }\n        if (i + 4 <= n) {\n            vst1q_s32(&result[i], stones); // Store 4 values at once\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = vgetq_lane_s32(stones, j - i);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t stones = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(2);\n    \n    for (int i = 0; i < n; i += 4) {\n        if (i > 0) {\n            stones = vaddq_s32(stones, increment);\n        }\n        if (i < n) {\n            vst1q_s32(&result[i], stones);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    int32x4_t base = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(2);\n    \n    for (int i = 0; i < levels; i += 4) {\n        int32x4_t current = base;\n        if (i > 0) {\n            current = vaddq_s32(current, vdupq_n_s32(i % 2 == 0 ? 0 : 2));\n        }\n        vst1q_s32(&stones[i], current);\n        base = vaddq_s32(base, increment);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_m = vdupq_n_s64(m);\n    int64x2_t vec_count = vdupq_n_s64(count);\n\n    // Calculate the sum using SIMD\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vec_i = vld1q_s64(&i);\n        sum += vgetq_lane_s64(vec_i, 0) + vgetq_lane_s64(vec_i, 1);\n    }\n\n    // Calculate average\n    int64_t avg = sum / count;\n\n    // Round down\n    int64_t rounded_avg = std::floor(avg);\n\n    // Convert to binary\n    std::string binary;\n    while (rounded_avg > 0) {\n        binary.insert(binary.begin(), (rounded_avg % 2) + '0');\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t m_vec = vdupq_n_s64(m);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        if (i + 1 <= m) {\n            sum_vec = vaddq_s64(sum_vec, vdupq_n_s64(i));\n            sum_vec = vaddq_s64(sum_vec, vdupq_n_s64(i + 1));\n        } else {\n            sum_vec = vaddq_s64(sum_vec, vdupq_n_s64(i));\n        }\n    }\n\n    sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    int64_t avg = sum / count;\n\n    if (sum % count >= count / 2) {\n        avg++;\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_m = vdupq_n_s64(m);\n    int64x2_t vec_count = vdupq_n_s64(count);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vec_i = vld1q_s64(&i);\n        sum += vaddvq_s64(vec_i);\n    }\n\n    int64_t avg = sum / count;\n    int64_t rounded_avg = std::floor((double)sum / count);\n\n    std::string binary;\n    while (rounded_avg > 0) {\n        binary = std::to_string(rounded_avg % 2) + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_m = vdupq_n_s64(m);\n    int64x2_t vec_count = vdupq_n_s64(count);\n\n    // Calculate the sum using SIMD\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vec_i = vld1q_s64(&i);\n        sum += vaddvq_s64(vec_i);\n    }\n\n    // Calculate average\n    int64_t avg = sum / count;\n\n    // Round down\n    int64_t rounded_avg = std::floor(avg);\n\n    // Convert to binary\n    std::string binary;\n    while (rounded_avg > 0) {\n        binary.insert(binary.begin(), (rounded_avg % 2) + '0');\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t m_vec = vdupq_n_s64(m);\n    \n    for (int64_t i = n; i <= m; i += 2) {\n        sum_vec = vaddq_s64(sum_vec, vdupq_n_s64(i));\n        if (i + 1 <= m) {\n            sum_vec = vaddq_s64(sum_vec, vdupq_n_s64(i + 1));\n        }\n    }\n\n    sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    int64_t avg = sum / count;\n\n    if (sum % count >= count / 2) {\n        avg++;\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t factorial = vdupq_n_s32(1);\n    int32x4_t sum = vdupq_n_s32(0);\n    \n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t indices = vld1q_s32((int32_t[]){i, i + 1, i + 2, i + 3});\n        int32x4_t is_even = vandq_s32(vshrq_n_s32(indices, 1), vdupq_n_s32(1));\n        \n        // Calculate factorial for even indices\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            if ((i + j) % 2 == 0) {\n                int32x4_t idx = vdupq_n_s32(i + j);\n                factorial = vmulq_s32(factorial, idx);\n                result[i + j - 1] = vgetq_lane_s32(factorial, 0) % 10000;\n            } else {\n                sum = vaddq_s32(sum, vdupq_n_s32(1));\n                for (int k = 1; k <= (i + j); k++) {\n                    sum = vaddq_s32(sum, vdupq_n_s32(k));\n                }\n                result[i + j - 1] = vgetq_lane_s32(sum, 0);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint8x8_t indices = vld1_u8((uint8_t[]){i + 1, i + 2, i + 3, i + 4, 0, 0, 0, 0});\n        uint8x8_t even_mask = vdup_n_u8(0);\n        uint8x8_t odd_mask = vdup_n_u8(0);\n        \n        for (int j = 0; j < 4; j++) {\n            if ((i + j + 1) % 2 == 0) {\n                even_mask[j] = 1;\n            } else {\n                odd_mask[j] = 1;\n            }\n        }\n\n        uint8x8_t factorials = {1, 1, 1, 1, 0, 0, 0, 0};\n        for (int j = 1; j <= 4; j++) {\n            factorials[j] = factorials[j - 1] * (j + 1);\n        }\n        factorials = vmodq_u8(factorials, vdupq_n_u8(10000));\n\n        uint8x8_t sums = {0, 0, 0, 0, 0, 0, 0, 0};\n        for (int j = 0; j < 4; j++) {\n            sums[j] = (indices[j] * (indices[j] + 1)) / 2;\n        }\n\n        uint8x8_t result_vec = vbsl_u8(even_mask, factorials, sums);\n        vst1_u8((uint8_t*)&result[i], result_vec);\n    }\n\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint8x8_t indices = vld1_u8((uint8_t[]){i + 1, i + 2, i + 3, i + 4});\n        uint8x8_t even_mask = vand_u8(indices, vdup_n_u8(1)); // Mask for even indices\n        uint8x8_t odd_mask = vmvn_u8(even_mask);\n\n        // Calculate factorial for even indices\n        uint8x8_t factorials = {1, 1, 1, 1};\n        for (int j = 0; j < 4; ++j) {\n            int idx = i + j + 1;\n            if (idx % 2 == 0) {\n                for (int k = 1; k <= idx; ++k) {\n                    factorials[j] = (factorials[j] * k) % 10000;\n                }\n            }\n        }\n\n        // Calculate sum for odd indices\n        uint8x8_t sums = {0, 0, 0, 0};\n        for (int j = 0; j < 4; ++j) {\n            int idx = i + j + 1;\n            if (idx % 2 != 0) {\n                sums[j] = (idx * (idx + 1)) / 2; // Sum of first idx numbers\n            }\n        }\n\n        // Combine results\n        uint8x8_t results = vbsl_u8(even_mask, factorials, sums);\n        vst1_u8((uint8_t*)&result[i], results);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            result[i] = (i * (i + 1)) / 2; // Sum of first i numbers\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint8x8_t indices = vld1_u8((uint8_t[]){i + 1, i + 2, i + 3, i + 4});\n        uint8x8_t even_mask = vand_u8(indices, vdup_n_u8(1)); // Check if even\n        uint8x8_t factorials = vdup_n_u8(1);\n        uint8x8_t sums = vdup_n_u8(0);\n\n        for (int j = 1; j <= 4; ++j) {\n            uint8x8_t idx = vdup_n_u8(j);\n            factorials = vmul_u8(factorials, idx);\n            sums = vadd_u8(sums, idx);\n        }\n\n        uint8x8_t results = vbsl_u8(even_mask, vdup_n_u8(10000), sums);\n        vst1_u8((uint8_t*)&result[i], results);\n    }\n\n    for (; i < n; ++i) {\n        if (i % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint8x8_t indices = vld1_u8((uint8_t[]){i + 1, i + 2, i + 3, i + 4});\n        uint8x8_t even_mask = vdup_n_u8(0);\n        uint8x8_t odd_mask = vdup_n_u8(0);\n        \n        for (int j = 0; j < 4; j++) {\n            if ((i + j + 1) % 2 == 0) {\n                even_mask[j] = 1;\n            } else {\n                odd_mask[j] = 1;\n            }\n        }\n\n        uint8x8_t factorials = {1, 1, 1, 1};\n        for (int j = 1; j <= 4; j++) {\n            factorials = vmul_u8(factorials, vdup_n_u8(j));\n        }\n        factorials = vmod_u8(factorials, vdup_n_u8(10000));\n\n        uint8x8_t sums = {0, 0, 0, 0};\n        for (int j = 0; j < 4; j++) {\n            sums[j] = (i + j + 1) * (i + j + 2) / 2;\n        }\n\n        uint8x8_t result_vec = vbsl_u8(even_mask, factorials, sums);\n        vst1_u8((uint8_t*)&result[i], result_vec);\n    }\n\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i + 1; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = (i + 1) * (i + 2) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Initialize vectors for counting\n    uint8x8_t even_vec = vdup_n_u8(0);\n    uint8x8_t odd_vec = vdup_n_u8(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t numbers = vld1_u8(reinterpret_cast<uint8_t*>(&i));\n        uint8x8_t palindromes = vdup_n_u8(0);\n\n        // Check for palindromes\n        for (int j = 0; j < 8 && (i + j) <= n; j++) {\n            int num = i + j;\n            int reversed = 0, original = num;\n\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n\n            if (original == reversed) {\n                palindromes = vsetq_lane_u8(1, palindromes, j);\n            }\n        }\n\n        // Count even and odd palindromes\n        for (int j = 0; j < 8 && (i + j) <= n; j++) {\n            if (vget_lane_u8(palindromes, j) == 1) {\n                if ((i + j) % 2 == 0) {\n                    even_vec = vadd_u8(even_vec, vdup_n_u8(1));\n                } else {\n                    odd_vec = vadd_u8(odd_vec, vdup_n_u8(1));\n                }\n            }\n        }\n    }\n\n    even_count = vget_lane_u8(even_vec, 0) + vget_lane_u8(even_vec, 1) + \n                 vget_lane_u8(even_vec, 2) + vget_lane_u8(even_vec, 3) +\n                 vget_lane_u8(even_vec, 4) + vget_lane_u8(even_vec, 5) +\n                 vget_lane_u8(even_vec, 6) + vget_lane_u8(even_vec, 7);\n\n    odd_count = vget_lane_u8(odd_vec, 0) + vget_lane_u8(odd_vec, 1) + \n                vget_lane_u8(odd_vec, 2) + vget_lane_u8(odd_vec, 3) +\n                vget_lane_u8(odd_vec, 4) + vget_lane_u8(odd_vec, 5) +\n                vget_lane_u8(odd_vec, 6) + vget_lane_u8(odd_vec, 7);\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector to hold the counts\n    int32x4_t counts = vdupq_n_s32(0); // Initialize counts to zero\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t nums = {i, i + 1, i + 2, i + 3};\n        uint32x4_t is_palindrome = vdupq_n_u32(0);\n\n        // Check for palindromes\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            int num = i + j;\n            int rev = 0, original = num;\n\n            while (num > 0) {\n                rev = rev * 10 + num % 10;\n                num /= 10;\n            }\n\n            if (original == rev) {\n                is_palindrome = vorrq_u32(is_palindrome, vshlq_n_u32(vdupq_n_u32(1), j));\n            }\n        }\n\n        // Count even and odd palindromes\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            if (vgetq_lane_u32(is_palindrome, j) != 0) {\n                if ((i + j) % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Process numbers in SIMD fashion\n    for (int i = 1; i <= n; i += 4) {\n        uint8x8_t nums = vld1_u8((uint8_t*)&i);\n        uint8x8_t palindromes = vdup_n_u8(0);\n        \n        // Check for palindromes\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            int num = i + j;\n            int rev = 0, original = num;\n\n            while (num > 0) {\n                rev = rev * 10 + num % 10;\n                num /= 10;\n            }\n\n            if (original == rev) {\n                palindromes = vsetq_lane_u8((original % 2 == 0) ? 1 : 0, palindromes, j);\n            }\n        }\n\n        // Count even and odd palindromes\n        uint8x8_t even_mask = vdup_n_u8(1);\n        uint8x8_t odd_mask = vdup_n_u8(1);\n        \n        for (int j = 0; j < 4; j++) {\n            if ((i + j) <= n) {\n                if (vget_lane_u8(palindromes, j) == 1) {\n                    if ((i + j) % 2 == 0) {\n                        even_count++;\n                    } else {\n                        odd_count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Prepare a vector to hold the counts\n    int32x4_t counts = vdupq_n_s32(0); // Initialize counts to (0, 0, 0, 0)\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t numbers = {i, i + 1, i + 2, i + 3};\n        uint32x4_t is_palindrome = vdupq_n_u32(0);\n\n        // Check for palindromes\n        for (int j = 0; j < 4; j++) {\n            int num = vgetq_lane_s32(numbers, j);\n            if (num < 10 || (num % 10 == num / 10)) {\n                is_palindrome = vorrq_u32(is_palindrome, vshlq_n_u32(vdupq_n_u32(1), j));\n            }\n        }\n\n        // Count even and odd palindromes\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(is_palindrome, j)) {\n                if (vgetq_lane_s32(numbers, j) % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    // Handle the remaining numbers if n is not a multiple of 4\n    for (int i = (n / 4) * 4 + 1; i <= n; i++) {\n        if (i < 10 || (i % 10 == i / 10)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector to hold the counts\n    int32x4_t counts = vdupq_n_s32(0); // Initialize counts to (0, 0, 0, 0)\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t nums = {i, i + 1, i + 2, i + 3};\n        uint32x4_t is_palindrome = vdupq_n_u32(0);\n\n        // Check for palindromes\n        for (int j = 0; j < 4; j++) {\n            int num = vgetq_lane_s32(nums, j);\n            if (num < 10 || (num % 10 == (num / 10) % 10)) {\n                is_palindrome = vorrq_u32(is_palindrome, vshlq_n_u32(vdupq_n_u32(1), j));\n            }\n        }\n\n        // Count even and odd palindromes\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(is_palindrome, j)) {\n                if (vgetq_lane_s32(nums, j) % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    // Handle remaining numbers if n is not a multiple of 4\n    for (int i = (n / 4) * 4 + 1; i <= n; i++) {\n        if (i < 10 || (i % 10 == (i / 10) % 10)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int vec_size = size / 4;\n    int remainder = size % 4;\n\n    uint32x4_t sum_digits = vdupq_n_u32(0);\n\n    for (int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        uint32x4_t abs_vec = vabsq_s32(vec);\n        \n        uint32x4_t digits_sum = vdupq_n_u32(0);\n        for (int j = 0; j < 4; j++) {\n            int32_t num = vgetq_lane_s32(vec, j);\n            if (num != 0) {\n                int sum = 0;\n                while (num != 0) {\n                    sum += abs(num % 10);\n                    num /= 10;\n                }\n                digits_sum = vsetq_lane_u32(sum, digits_sum, j);\n            }\n        }\n        sum_digits = vaddq_u32(sum_digits, digits_sum);\n    }\n\n    for (int i = vec_size * 4; i < size; i++) {\n        if (n[i] != 0) {\n            int sum = 0;\n            int num = abs(n[i]);\n            while (num != 0) {\n                sum += num % 10;\n                num /= 10;\n            }\n            if (sum > 0) count++;\n        }\n    }\n\n    uint32_t results[4];\n    vst1q_u32(results, sum_digits);\n    for (int i = 0; i < 4; i++) {\n        if (results[i] > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int vec_size = size / 4;\n    int remainder = size % 4;\n\n    uint32x4_t sum_digits = vdupq_n_u32(0);\n\n    for (int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        uint32x4_t abs_vec = vabsq_s32(vec);\n        \n        uint32x4_t digits_sum = vdupq_n_u32(0);\n        for (int j = 0; j < 32; j++) {\n            uint32x4_t mask = vshrq_n_u32(abs_vec, j);\n            uint32x4_t digit = vandq_u32(mask, vdupq_n_u32(0xF));\n            digits_sum = vaddq_u32(digits_sum, digit);\n        }\n\n        sum_digits = vaddq_u32(sum_digits, digits_sum);\n    }\n\n    for (int i = 0; i < 4; i++) {\n        count += (vgetq_lane_u32(sum_digits, i) > 0) ? 1 : 0;\n    }\n\n    for (int i = vec_size * 4; i < size; i++) {\n        if (n[i] < 0) {\n            count += (n[i] < -1) ? 1 : 0;\n        } else {\n            count += (n[i] > 0) ? 1 : 0;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int vec_size = size / 4;\n    int remainder = size % 4;\n\n    uint32x4_t sum_digits = vdupq_n_u32(0);\n    \n    for (int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        \n        // Calculate absolute values\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        // Sum the digits\n        uint32x4_t digits_sum = vdupq_n_u32(0);\n        for (int j = 0; j < 4; ++j) {\n            int32_t num = vgetq_lane_s32(abs_nums, j);\n            while (num > 0) {\n                digits_sum = vaddq_u32(digits_sum, vdupq_n_u32(num % 10));\n                num /= 10;\n            }\n        }\n        \n        // Count numbers with sum of digits > 0\n        uint32x4_t is_positive = vcgtq_u32(digits_sum, vdupq_n_u32(0));\n        count += vaddvq_u32(is_positive);\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size * 4; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        num = abs(num);\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int vec_size = size / 4;\n    int remainder = size % 4;\n\n    uint32x4_t sum_digits = vdupq_n_u32(0);\n\n    for (int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        uint32x4_t abs_vec = vabsq_s32(vec);\n        \n        uint32x4_t digit_sum = vdupq_n_u32(0);\n        for (int j = 0; j < 4; j++) {\n            int32_t num = vgetq_lane_s32(vec, j);\n            while (num != 0) {\n                digit_sum = vaddq_u32(digit_sum, vdupq_n_u32(abs(num % 10)));\n                num /= 10;\n            }\n        }\n        sum_digits = vaddq_u32(sum_digits, digit_sum);\n    }\n\n    for (int i = vec_size * 4; i < size; i++) {\n        int num = n[i];\n        while (num != 0) {\n            count += abs(num % 10);\n            num /= 10;\n        }\n    }\n\n    uint32_t result[4];\n    vst1q_u32(result, sum_digits);\n    count += (result[0] > 0) + (result[1] > 0) + (result[2] > 0) + (result[3] > 0);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int vec_size = size / 4;\n    int remainder = size % 4;\n\n    uint32x4_t sum_digits = vdupq_n_u32(0);\n    \n    for (int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        \n        // Calculate sum of digits for each number\n        for (int j = 0; j < 4; j++) {\n            int32_t num = vgetq_lane_s32(nums, j);\n            int32_t abs_num = num < 0 ? -num : num;\n            int32_t digit_sum = 0;\n\n            while (abs_num > 0) {\n                digit_sum += abs_num % 10;\n                abs_num /= 10;\n            }\n            digit_sum += (num < 0) ? -1 : 0; // Adjust for negative first digit\n            sum_digits = vsetq_lane_u32(digit_sum, sum_digits, j);\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size * 4; i < size; i++) {\n        int32_t num = n[i];\n        int32_t abs_num = num < 0 ? -num : num;\n        int32_t digit_sum = 0;\n\n        while (abs_num > 0) {\n            digit_sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        digit_sum += (num < 0) ? -1 : 0; // Adjust for negative first digit\n        if (digit_sum > 0) count++;\n    }\n\n    // Count the number of elements with sum of digits > 0\n    uint32x4_t cmp = vcgtq_u32(sum_digits, vdupq_n_u32(0));\n    count += vaddvq_u32(cmp);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Load the array into a Neon register\n    int32x4_t vec1, vec2;\n    int32x4_t max_val = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_val = vdupq_n_s32(INT32_MAX);\n    \n    for (int i = 0; i < N; i += 4) {\n        vec1 = vld1q_s32(&arr[i]);\n        max_val = vmaxq_s32(max_val, vec1);\n        min_val = vminq_s32(min_val, vec1);\n    }\n\n    // Check if the max value is less than or equal to the min value after a full rotation\n    return vgetq_lane_s32(max_val, 0) <= vgetq_lane_s32(min_val, 0);\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int32x4_t max_val = vdupq_n_s32(arr[0]);\n    int32x4_t min_val = vdupq_n_s32(arr[0]);\n    bool sorted = true;\n\n    for (int i = 0; i < N; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        max_val = vmaxq_s32(max_val, vec);\n        min_val = vminq_s32(min_val, vec);\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (arr[i] < vgetq_lane_s32(min_val, 0) || arr[i] > vgetq_lane_s32(max_val, 0)) {\n            sorted = false;\n            break;\n        }\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32x4_t max_val = vdupq_n_s32(arr[0]);\n    int32x4_t min_val = vdupq_n_s32(arr[0]);\n    bool is_sorted = true;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        max_val = vmaxq_s32(max_val, vec);\n        min_val = vminq_s32(min_val, vec);\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < vgetq_lane_s32(min_val, 0) || arr[i] > vgetq_lane_s32(max_val, 0)) {\n            is_sorted = false;\n            break;\n        }\n    }\n\n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int32x4_t max_val = vdupq_n_s32(arr[0]);\n    int32x4_t min_val = vdupq_n_s32(arr[0]);\n    bool is_sorted = true;\n\n    for (int i = 0; i < N; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        max_val = vmaxq_s32(max_val, data);\n        min_val = vminq_s32(min_val, data);\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (arr[i] < vgetq_lane_s32(min_val, 0) || arr[i] > vgetq_lane_s32(max_val, 0)) {\n            is_sorted = false;\n            break;\n        }\n    }\n\n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Load the array into a Neon vector\n    int32x4_t vec1, vec2;\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    \n    for (int i = 0; i < N; i += 4) {\n        vec1 = vld1q_s32(&arr[i]);\n        min_vec = vminq_s32(min_vec, vec1);\n        max_vec = vmaxq_s32(max_vec, vec1);\n    }\n\n    // Check if the max element is less than or equal to the min element\n    // after a full rotation, which means we can sort it\n    int32x4_t result = vceqq_s32(min_vec, max_vec);\n    return vmaxvq_s32(result) == 0;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    bool has_even = false;\n    bool has_odd = false;\n\n    // Process lst1\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        uint32x4_t even_mask = vandq_u32(vcgtq_s32(vec1, vdupq_n_s32(0)), vdupq_n_u32(1));\n        uint32x4_t odd_mask = veorq_u32(even_mask, vdupq_n_u32(1));\n\n        has_even |= vmaxvq_u32(even_mask) > 0;\n        has_odd |= vmaxvq_u32(odd_mask) > 0;\n    }\n\n    // Process lst2\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n        uint32x4_t even_mask = vandq_u32(vcgtq_s32(vec2, vdupq_n_s32(0)), vdupq_n_u32(1));\n\n        has_even |= vmaxvq_u32(even_mask) > 0;\n    }\n\n    if (has_even && !has_odd) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    bool has_even = false;\n    bool has_odd = false;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n\n        // Check for even numbers in lst1\n        uint32x4_t even_mask1 = vshrq_n_u32(vandq_u32(vreinterpretq_u32_s32(vec1), vdupq_n_s32(1)), 0);\n        has_odd |= (vmaxvq_u32(even_mask1) != 0);\n\n        // Check for even numbers in lst2\n        uint32x4_t even_mask2 = vshrq_n_u32(vandq_u32(vreinterpretq_u32_s32(vec2), vdupq_n_s32(1)), 0);\n        has_even |= (vmaxvq_u32(even_mask2) == 0);\n    }\n\n    return (has_odd && has_even) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int size = lst1.size();\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Process lst1\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst1[i]);\n        uint32x4_t is_even = vandq_u32(vshrq_n_u32(vreinterpretq_u32_s32(vec), 1), vdupq_n_u32(1));\n        even_count += vaddvq_u32(is_even);\n        odd_count += 4 - vaddvq_u32(is_even);\n    }\n\n    // Process lst2\n    int available_even = 0;\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst2[i]);\n        uint32x4_t is_even = vandq_u32(vshrq_n_u32(vreinterpretq_u32_s32(vec), 1), vdupq_n_u32(1));\n        available_even += vaddvq_u32(is_even);\n    }\n\n    if (even_count + available_even >= size) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int size = lst1.size();\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Process lst1\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst1[i]);\n        uint32x4_t even_mask = vandq_u32(vcgtq_s32(vec, vdupq_n_s32(0)), vdupq_n_u32(1));\n        even_count += vaddvq_u32(even_mask);\n        odd_count += 4 - vaddvq_u32(even_mask);\n    }\n\n    // Process lst2\n    int lst2_even_count = 0;\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst2[i]);\n        uint32x4_t even_mask = vandq_u32(vcgtq_s32(vec, vdupq_n_s32(0)), vdupq_n_u32(1));\n        lst2_even_count += vaddvq_u32(even_mask);\n    }\n\n    if (odd_count <= lst2_even_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int size = lst1.size();\n    bool has_even = false;\n    bool has_odd = false;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n\n        // Check for even numbers in lst1\n        uint32x4_t even_mask1 = vandq_u32(vcgtq_s32(vec1, vdupq_n_s32(0)), vdupq_n_u32(1));\n        uint32x4_t odd_mask1 = vmvnq_u32(even_mask1);\n\n        // Check for even numbers in lst2\n        uint32x4_t even_mask2 = vandq_u32(vcgtq_s32(vec2, vdupq_n_s32(0)), vdupq_n_u32(1));\n        uint32x4_t odd_mask2 = vmvnq_u32(even_mask2);\n\n        // Accumulate presence of even and odd numbers\n        has_even |= vmaxvq_u32(even_mask1) || vmaxvq_u32(even_mask2);\n        has_odd |= vmaxvq_u32(odd_mask1) || vmaxvq_u32(odd_mask2);\n    }\n\n    return (has_even && has_odd) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        int length = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odd_mask = vdupq_n_u8(0);\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('1')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('3')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('5')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('7')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('9')), vdupq_n_u8(1)));\n\n            odd_count += vaddvq_u8(odd_mask);\n        }\n\n        // Process remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count \n            << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        int length = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odd_mask = vdupq_n_u8(0);\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('1')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('3')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('5')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('7')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('9')), vdupq_n_u8(1)));\n\n            odd_count += vaddvq_u8(odd_mask);\n        }\n\n        // Handle remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        int length = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odd_mask = vdupq_n_u8(0);\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('1')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('3')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('5')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('7')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('9')), vdupq_n_u8(1)));\n\n            odd_count += vaddvq_u8(odd_mask);\n        }\n\n        // Process remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        int length = str.length();\n        int i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odd_mask = vdupq_n_u8(0);\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('1')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('3')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('5')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('7')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('9')), vdupq_n_u8(1)));\n\n            odd_count += vaddvq_u8(odd_mask);\n        }\n\n        // Process remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        int length = str.length();\n        int i = 0;\n\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odd_mask = vdupq_n_u8(0);\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('1')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('3')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('5')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('7')), vdupq_n_u8(1)));\n            odd_mask = vorrq_u8(odd_mask, vandq_u8(vceqq_u8(digits, vdupq_n_u8('9')), vdupq_n_u8(1)));\n\n            odd_count += vaddvq_u8(odd_mask);\n        }\n\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i <= size - 2; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        current_sum += vminvq_s64(vec);\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum + vgetq_lane_s64(vec, 0), vgetq_lane_s64(vec, 1));\n    }\n\n    // Process remaining element if size is odd\n    if (i < size) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i <= size - 2; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        current_sum += vminvq_s64(vec);\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum + vgetq_lane_s64(vec, 0), vgetq_lane_s64(vec, 1));\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum, static_cast<int64_t>(nums[i]));\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i + 1 < size; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        int64x2_t min_vec = vminq_s64(vec, vdupq_n_s64(min_sum));\n        min_sum = std::min(min_sum, vgetq_lane_s64(min_vec, 0));\n        min_sum = std::min(min_sum, vgetq_lane_s64(min_vec, 1));\n    }\n\n    // Handle the last element if the size is odd\n    if (i < size) {\n        min_sum = std::min(min_sum, nums[i]);\n    }\n\n    // Calculate the minimum subarray sum using Kadane's algorithm\n    current_sum = 0;\n    for (size_t j = 0; j < size; ++j) {\n        current_sum += nums[j];\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i <= size - 2; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        current_sum += vminvq_s64(vec);\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum + vgetq_lane_s64(vec, 0), vgetq_lane_s64(vec, 1));\n    }\n\n    // Process remaining element if size is odd\n    if (i < size) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i <= size - 2; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        current_sum += vminvq_s64(vec);\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum + vgetq_lane_s64(vec, 0), vgetq_lane_s64(vec, 1));\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum, static_cast<int64_t>(nums[i]));\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int count = 0;\n        for (int j = 0; j < cols; j += 16) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&grid[i][j]));\n            count += vaddvq_u8(data);\n        }\n        total_buckets += (count + capacity - 1) / capacity; // Ceiling division\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int count = 0;\n        for (int j = 0; j < cols; j += 4) {\n            uint8x8_t data = vld1_u8((const uint8_t*)&grid[i][j]);\n            uint8x8_t count_mask = vdup_n_u8(1);\n            uint8x8_t result = vand_u8(data, count_mask);\n            count += vaddv_u8(result);\n        }\n        total_buckets += (count + capacity - 1) / capacity;\n    }\n    \n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_count = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int count = 0;\n        for (int j = 0; j < cols; j += 4) {\n            uint8x8_t well_data = vld1_u8(reinterpret_cast<const uint8_t*>(&grid[i][j]));\n            uint8x8_t water_count = vpadd_u8(well_data, well_data);\n            water_count = vpadd_u8(water_count, water_count);\n            count += vget_lane_u8(water_count, 0) + vget_lane_u8(water_count, 1);\n        }\n        total_count += (count + capacity - 1) / capacity; // Ceiling division\n    }\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int count = 0;\n        for (int j = 0; j < cols; j += 4) {\n            uint8x8_t data = vld1_u8((const uint8_t*)&grid[i][j]);\n            uint8x8_t mask = vdup_n_u8(1);\n            uint8x8_t result = vand_u8(data, mask);\n            count += vaddv_u8(result);\n        }\n        total_buckets += (count + capacity - 1) / capacity;\n    }\n    \n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_drops = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        int sum = 0;\n        for (int j = 0; j < cols; j += 4) {\n            uint8x8_t data = vld1_u8(reinterpret_cast<const uint8_t*>(&grid[i][j]));\n            uint16x4_t sum_vec = vpaddl_u8(data);\n            sum += vget_lane_u16(sum_vec, 0) + vget_lane_u16(sum_vec, 1);\n        }\n        total_drops += (sum + capacity - 1) / capacity; // Ceiling division\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    int i;\n\n    // Process elements in pairs\n    for (i = 0; i < size / 8 * 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t even_positions = vshlq_n_s16(vec, 1); // Shift left to get even positions\n        even_positions = vuzpq_s16(even_positions, vec).val[0]; // Interleave to get odd elements in even positions\n\n        // Check for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_positions), vdupq_n_u16(1));\n        even_positions = vbslq_s16(odd_mask, even_positions, vdupq_n_s16(0)); // Zero out non-odd elements\n\n        // Sum the results\n        sum += vaddvq_s16(even_positions);\n    }\n\n    // Process remaining elements\n    for (; i < size; i += 2) {\n        if (i < size && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 8 elements at a time\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t even_pos = vshlq_n_s16(vec, 1); // Shift left to get even positions\n        even_pos = vuzpq_s16(even_pos, vec).val[0]; // Get elements at even positions\n\n        // Check for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_pos), vdupq_n_u16(1));\n        int16x8_t odd_elements = vbslq_s16(odd_mask, even_pos, vdupq_n_s16(0));\n\n        // Sum the odd elements\n        sum += vaddvq_s16(odd_elements);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    // Process elements in pairs\n    for (i = 0; i + 8 <= size; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t even_pos = vshlq_n_s16(vec, 1); // Shift left to get even positions\n        even_pos = vqtbl1q_s16(vec, vdupq_n_u8(0b01010101)); // Select even indexed elements\n        uint16x8_t odd_mask = vdupq_n_u16(1);\n        uint16x8_t odd_elements = vandq_u16(vreinterpretq_u16_s16(even_pos), odd_mask);\n        sum += vaddvq_s16(odd_elements);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    // Process elements in pairs\n    for (i = 0; i + 8 <= size; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t even_positions = vshlq_n_s16(vec, 1); // Shift left to get even positions\n        even_positions = vuzpq_s16(even_positions, vec).val[0]; // Get even indexed elements\n\n        // Check for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_positions), vdupq_n_u16(1));\n        even_positions = vbslq_s16(odd_mask, even_positions, vdupq_n_s16(0)); // Zero out even positions that are not odd\n\n        // Sum the results\n        sum += vaddvq_s16(even_positions);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (i < size && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    // Process elements in chunks of 8\n    for (i = 0; i + 8 <= size; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t even_positions = vdupq_n_s16(0);\n        \n        // Extract elements at even positions\n        even_positions = vcombine_s16(vget_low_s16(vec), vget_high_s16(vec));\n        \n        // Mask to get odd elements\n        uint16x8_t odd_mask = vdupq_n_u16(1);\n        uint16x8_t is_odd = vandq_u16(vreinterpretq_u16_s16(even_positions), odd_mask);\n        \n        // Filter odd elements\n        even_positions = vbslq_s16(is_odd, even_positions, vdupq_n_s16(0));\n        \n        // Sum the filtered elements\n        sum += vaddvq_s16(even_positions);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < k; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&arr[i]);\n        uint32x4_t mask = vcleq_s32(data_vec, vdupq_n_s32(99));\n        data_vec = vandq_s32(data_vec, vreinterpretq_s32_u32(mask));\n        sum_vec = vaddq_s32(sum_vec, data_vec);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int i = 0; i < 4; i++) {\n        sum += temp[i];\n    }\n    \n    for (int i = k - (k % 4); i < k; i++) {\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process up to k elements\n    for (; i <= k - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        // Mask to check for two-digit numbers (10 to 99)\n        uint32x4_t mask = vcgtq_s32(data, vdupq_n_s32(9)); // greater than 9\n        uint32x4_t mask2 = vcltq_s32(data, vdupq_n_s32(100)); // less than 100\n        uint32x4_t combined_mask = vandq_u32(mask, mask2); // between 10 and 99\n\n        // Set elements to zero if they are not in the range\n        data = vbslq_s32(combined_mask, data, vdupq_n_s32(0));\n        sum += vaddvq_s32(data); // Sum the valid elements\n    }\n\n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < k; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&arr[i]);\n        int32x4_t mask = vceqq_s32(data_vec, vdupq_n_s32(0)); // mask for non-zero elements\n        int32x4_t is_two_digit = vshrq_n_s32(data_vec, 10); // shift right to check for two digits\n        is_two_digit = vceqq_s32(is_two_digit, vdupq_n_s32(0)); // mask for two digits\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(vreinterpretq_u32_s32(mask), vreinterpretq_u32_s32(is_two_digit));\n        \n        // Select valid elements\n        data_vec = vandq_s32(data_vec, vreinterpretq_s32_u32(valid_mask));\n        \n        // Sum the valid elements\n        sum_vec = vaddq_s32(sum_vec, data_vec);\n    }\n    \n    // Horizontal add to get the final sum\n    sum += vgetq_lane_s32(sum_vec, 0);\n    sum += vgetq_lane_s32(sum_vec, 1);\n    sum += vgetq_lane_s32(sum_vec, 2);\n    sum += vgetq_lane_s32(sum_vec, 3);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < k; i += 4) {\n        int32x4_t data_vec = vld1q_s32(&arr[i]);\n        uint32x4_t abs_vec = vabsq_s32(data_vec);\n        uint32x4_t mask = vcleq_u32(abs_vec, vdupq_n_u32(99));\n        data_vec = vandq_s32(data_vec, vreinterpretq_s32_u32(mask));\n        sum_vec = vaddq_s32(sum_vec, data_vec);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n    \n    for (int i = (k / 4) * 4; i < k; i++) {\n        if (abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int count = 0;\n\n    // Process up to k elements\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        uint32x4_t abs_vec = vabsq_s32(vec);\n        uint32x4_t mask = vcleq_u32(abs_vec, vdupq_n_u32(99)); // Mask for two-digit numbers\n        int32x4_t filtered = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Sum the filtered values\n        sum += vaddvq_s32(filtered);\n        count += vaddvq_u32(mask); // Count valid elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) return true;\n\n    int n = lst.size();\n    int i = 0;\n\n    // Load the first elements\n    int32x4_t prev = vld1q_s32(&lst[i]);\n    i += 4;\n\n    // Check for sorted order and duplicates\n    while (i < n) {\n        int32x4_t curr = vld1q_s32(&lst[i]);\n        \n        // Check if current elements are less than or equal to previous elements\n        uint32x4_t cmp = vcltq_s32(curr, prev);\n        if (vmaxvq_u32(cmp) != 0) return false; // Found an element that is less than the previous\n\n        // Check for duplicates\n        uint32x4_t dup_check = vceqq_s32(curr, prev);\n        if (vmaxvq_u32(dup_check) != 0) return false; // Found a duplicate\n\n        prev = curr;\n        i += 4;\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 0 && lst[i] == lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int32x4_t prev = vld1q_s32(&lst[0]);\n    int32x4_t curr;\n    bool sorted = true;\n    bool has_duplicates = false;\n\n    for (int i = 4; i < n; i += 4) {\n        curr = vld1q_s32(&lst[i]);\n        int32x4_t cmp = vcltq_s32(curr, prev);\n        int32x4_t dup = vceqq_s32(curr, prev);\n\n        if (vmaxvq_u32(vreinterpret_u32q_s32(cmp)) != 0) {\n            sorted = false;\n            break;\n        }\n        if (vmaxvq_u32(vreinterpret_u32q_s32(dup)) != 0) {\n            has_duplicates = true;\n        }\n\n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        if (lst[i] < lst[i - 1]) {\n            sorted = false;\n            break;\n        }\n        if (i > 0 && lst[i] == lst[i - 1]) {\n            has_duplicates = true;\n        }\n    }\n\n    return sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) return true;\n\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t next_vec = vld1q_s32(&lst[i + 1]);\n\n        // Check if current elements are greater than or equal to the next\n        uint32x4_t cmp = vcgeq_s32(vec, next_vec);\n        if (vmaxvq_u32(cmp) != 0) return false;\n\n        // Check for duplicates\n        int32x4_t dup_check = vuzpq_s32(vec, next_vec).val[0];\n        if (vmaxvq_s32(dup_check) == 0) return false;\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (lst[i] >= lst[i + 1] || (i > 0 && lst[i] == lst[i - 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int32x4_t prev = vld1q_s32(&lst[0]);\n    int32x4_t curr;\n    bool sorted = true;\n    bool has_duplicates = false;\n\n    for (int i = 4; i < n; i += 4) {\n        curr = vld1q_s32(&lst[i]);\n        int32x4_t cmp = vcltq_s32(curr, prev);\n        int32x4_t dup = vceqq_s32(curr, prev);\n        \n        if (vmaxvq_u32(vreinterpret_u32q_s32(cmp)) != 0) {\n            sorted = false;\n            break;\n        }\n        \n        if (vmaxvq_u32(vreinterpret_u32q_s32(dup)) != 0) {\n            has_duplicates = true;\n            break;\n        }\n        \n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        if (lst[i] < lst[i - 1]) {\n            sorted = false;\n            break;\n        }\n        if (i > 0 && lst[i] == lst[i - 1]) {\n            has_duplicates = true;\n            break;\n        }\n    }\n\n    return sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) return true;\n\n    int n = lst.size();\n    int i = 0;\n\n    // Load the first elements into a vector\n    int32x4_t prev = vld1q_s32(&lst[i]);\n    i += 4;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t curr = vld1q_s32(&lst[i]);\n        \n        // Compare current and previous vectors\n        uint32x4_t cmp = vcltq_s32(curr, prev);\n        if (vmaxvq_u32(cmp) != 0) return false; // If any current is less than previous\n\n        // Check for duplicates\n        uint32x4_t dup_check = vceqq_s32(curr, prev);\n        if (vmaxvq_u32(dup_check) != 0) return false; // If any current is equal to previous\n\n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (lst[i] < lst[i - 1] || lst[i] == lst[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t product_signs = vdupq_n_s32(1);\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31);\n        sign_vec = vaddq_s32(sign_vec, vdupq_n_s32(1)); // Convert -1, 0, 1 to 0, 1, 2\n        product_signs = vmulq_s32(product_signs, sign_vec);\n    }\n\n    int32_t sum = vgetq_lane_s32(sum_magnitudes, 0) + vgetq_lane_s32(sum_magnitudes, 1) +\n                  vgetq_lane_s32(sum_magnitudes, 2) + vgetq_lane_s32(sum_magnitudes, 3);\n    int32_t prod = vgetq_lane_s32(product_signs, 0) * vgetq_lane_s32(product_signs, 1) *\n                   vgetq_lane_s32(product_signs, 2) * vgetq_lane_s32(product_signs, 3);\n\n    for (; i < size; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        if (arr[i] != 0) {\n            prod *= sign;\n            sum += abs(arr[i]);\n        }\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31);\n        sign_vec = vaddq_s32(sign_vec, vdupq_n_s32(1)); // Convert -1, 0, 1 to 0, 1, 2\n        prod_signs = vmulq_s32(prod_signs, sign_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        if (sign == 0) return 0;\n        prod_signs = vmulq_s32(prod_signs, vdupq_n_s32(sign));\n        sum_magnitudes = vaddq_s32(sum_magnitudes, vdupq_n_s32(abs(arr[i])));\n    }\n\n    int32_t sum = vgetq_lane_s32(sum_magnitudes, 0) + vgetq_lane_s32(sum_magnitudes, 1) +\n                  vgetq_lane_s32(sum_magnitudes, 2) + vgetq_lane_s32(sum_magnitudes, 3);\n    int32_t product = vgetq_lane_s32(prod_signs, 0);\n\n    return sum * product;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31);\n        sign_vec = vaddq_s32(sign_vec, vdupq_n_s32(1)); // Convert -1, 0, 1 to 0, 1, 2\n        sign_vec = vminq_s32(sign_vec, vdupq_n_s32(1)); // Clamp to 0 or 1\n        prod_signs = vmulq_s32(prod_signs, sign_vec);\n    }\n\n    int32_t sum_result[4];\n    vst1q_s32(sum_result, sum_magnitudes);\n    int32_t total_magnitude = sum_result[0] + sum_result[1] + sum_result[2] + sum_result[3];\n\n    for (; i < size; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        if (sign == 0) return 0;\n        prod_signs = vmulq_s32(prod_signs, vdupq_n_s32(sign));\n        total_magnitude += abs(arr[i]);\n    }\n\n    return total_magnitude * vgetq_lane_s32(prod_signs, 0);\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n    int32x4_t zero = vdupq_n_s32(0);\n    int32x4_t neg_one = vdupq_n_s32(-1);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t signs = vshrq_n_s32(vec, 31); // Get sign bits\n        signs = vaddq_s32(signs, vdupq_n_s32(1)); // Convert to 0, 1, -1\n        signs = vaddq_s32(signs, vshrq_n_s32(vec, 31)); // Adjust for negative\n\n        prod_signs = vmulq_s32(prod_signs, signs);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        if (sign == 0) return 0;\n        prod_signs = vmulq_s32(prod_signs, vdupq_n_s32(sign));\n        sum_magnitudes = vaddq_s32(sum_magnitudes, vdupq_n_s32(abs(arr[i])));\n    }\n\n    int32_t sum_magnitudes_array[4];\n    int32_t prod_signs_array[4];\n    vst1q_s32(sum_magnitudes_array, sum_magnitudes);\n    vst1q_s32(prod_signs_array, prod_signs);\n\n    int total_magnitude = sum_magnitudes_array[0] + sum_magnitudes_array[1] + sum_magnitudes_array[2] + sum_magnitudes_array[3];\n    int total_sign = prod_signs_array[0];\n\n    return total_sign * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31);\n        sign_vec = vaddq_s32(sign_vec, vdupq_n_s32(1)); // Convert -1, 0, 1 to 0, 1, 2\n        sign_vec = vminq_s32(sign_vec, vdupq_n_s32(1)); // Clamp to 0 or 1\n        prod_signs = vmulq_s32(prod_signs, sign_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        if (sign == 0) return 0;\n        prod_signs = vmulq_s32(prod_signs, vdupq_n_s32(sign));\n        sum_magnitudes = vaddq_s32(sum_magnitudes, vdupq_n_s32(abs(arr[i])));\n    }\n\n    int32_t sum = vgetq_lane_s32(sum_magnitudes, 0) + vgetq_lane_s32(sum_magnitudes, 1) +\n                  vgetq_lane_s32(sum_magnitudes, 2) + vgetq_lane_s32(sum_magnitudes, 3);\n    int32_t prod = vgetq_lane_s32(prod_signs, 0);\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path;\n\n    // Flatten the grid into a single vector for easier processing\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path.push_back(grid[i][j]);\n        }\n    }\n\n    // Initialize the minimum path with a large value\n    std::vector<int> minPath(k, INT_MAX);\n\n    // Iterate through each cell as a starting point\n    for (int start = 0; start < N * N; ++start) {\n        std::vector<int> currentPath;\n        int x = start / N;\n        int y = start % N;\n\n        // Use a queue for BFS or DFS to explore paths\n        std::vector<std::pair<int, int>> queue;\n        queue.push_back({x, y});\n        currentPath.push_back(grid[x][y]);\n\n        while (!queue.empty() && currentPath.size() < k) {\n            auto [cx, cy] = queue.back();\n            queue.pop_back();\n\n            // Check all 4 possible directions\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1) {\n                    if (abs(dx) + abs(dy) == 1) { // Only horizontal and vertical moves\n                        int nx = cx + dx;\n                        int ny = cy + dy;\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            currentPath.push_back(grid[nx][ny]);\n                            queue.push_back({nx, ny});\n                        }\n                    }\n                }\n            }\n        }\n\n        // If the current path is of length k, compare it with the minimum path\n        if (currentPath.size() == k) {\n            if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n                minPath = currentPath;\n            }\n        }\n    }\n\n    return minPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Flatten the grid into a 1D array for SIMD processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path\n    std::vector<int> min_path(k, INT_MAX);\n    \n    // Process each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int idx = i * N + j;\n            int current_value = flat_grid[idx];\n\n            // Use SIMD to explore paths of length k\n            int8x8_t current_values = vdup_n_s8(current_value);\n            for (int step = 0; step < k; ++step) {\n                // Update the minimum path using SIMD\n                int8x8_t min_values = vld1_s8(min_path.data() + step);\n                min_values = vmin_s8(min_values, current_values);\n                vst1_s8(min_path.data() + step, min_values);\n            }\n        }\n    }\n\n    // Convert the result to a vector of integers\n    for (int i = 0; i < k; ++i) {\n        result[i] = min_path[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> flatGrid(N * N);\n    \n    // Flatten the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flatGrid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path\n    std::vector<int> minPath(k, INT_MAX);\n    \n    // SIMD processing\n    for (int start = 0; start < N * N; ++start) {\n        std::vector<int> currentPath;\n        int currentIndex = start;\n        \n        // Build the path of length k\n        for (int step = 0; step < k; ++step) {\n            currentPath.push_back(flatGrid[currentIndex]);\n            int row = currentIndex / N;\n            int col = currentIndex % N;\n\n            // Possible moves (up, down, left, right)\n            int moves[4] = {\n                (row > 0) ? currentIndex - N : -1,\n                (row < N - 1) ? currentIndex + N : -1,\n                (col > 0) ? currentIndex - 1 : -1,\n                (col < N - 1) ? currentIndex + 1 : -1\n            };\n\n            // Find the minimum value among the neighbors\n            int minValue = INT_MAX;\n            int nextIndex = -1;\n            for (int m = 0; m < 4; ++m) {\n                if (moves[m] != -1 && flatGrid[moves[m]] < minValue) {\n                    minValue = flatGrid[moves[m]];\n                    nextIndex = moves[m];\n                }\n            }\n            currentIndex = nextIndex != -1 ? nextIndex : currentIndex; // Stay if no move\n        }\n\n        // Compare lexicographically\n        if (currentPath < minPath) {\n            minPath = currentPath;\n        }\n    }\n\n    return minPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Flatten the grid into a single array\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Use Neon intrinsics to find the minimum path\n    for (int step = 0; step < k; ++step) {\n        int min_value = INT_MAX;\n        int min_index = -1;\n\n        for (int i = 0; i < N * N; i += 4) {\n            int32x4_t values = vld1q_s32(&flat_grid[i]);\n            int32x4_t min_vals = vdupq_n_s32(min_value);\n            uint32x4_t mask = vcgtq_s32(min_vals, values);\n            min_vals = vbslq_s32(mask, values, min_vals);\n            min_value = std::min(min_value, vgetq_lane_s32(min_vals, 0));\n            min_index = (min_value == vgetq_lane_s32(min_vals, 0)) ? i : min_index;\n            min_value = std::min(min_value, vgetq_lane_s32(min_vals, 1));\n            min_index = (min_value == vgetq_lane_s32(min_vals, 1)) ? i + 1 : min_index;\n            min_value = std::min(min_value, vgetq_lane_s32(min_vals, 2));\n            min_index = (min_value == vgetq_lane_s32(min_vals, 2)) ? i + 2 : min_index;\n            min_value = std::min(min_value, vgetq_lane_s32(min_vals, 3));\n            min_index = (min_value == vgetq_lane_s32(min_vals, 3)) ? i + 3 : min_index;\n        }\n\n        result[step] = min_value;\n        flat_grid[min_index] = INT_MAX; // Mark as visited\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Flatten the grid into a 1D array\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path\n    std::vector<int> min_path(k, INT_MAX);\n    \n    // Process each cell as a starting point\n    for (int start = 0; start < N * N; ++start) {\n        std::vector<int> current_path;\n        int x = start / N;\n        int y = start % N;\n\n        // Use a queue for BFS\n        std::vector<std::pair<int, int>> queue;\n        queue.emplace_back(x, y);\n        \n        while (!queue.empty() && current_path.size() < k) {\n            auto [cx, cy] = queue.back();\n            queue.pop_back();\n            current_path.push_back(grid[cx][cy]);\n\n            // Check neighbors\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (abs(dx) + abs(dy) == 1) { // Only horizontal and vertical moves\n                        int nx = cx + dx;\n                        int ny = cy + dy;\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            queue.emplace_back(nx, ny);\n                        }\n                    }\n                }\n            }\n        }\n\n        // If we have a valid path of length k, compare it with the minimum path\n        if (current_path.size() == k) {\n            if (std::lexicographical_compare(current_path.begin(), current_path.end(), min_path.begin(), min_path.end())) {\n                min_path = current_path;\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer as string\n    snprintf(str, sizeof(str), \"%llu\", n);\n\n    // Load digits into a vector\n    uint8x8_t digits = vdup_n_u8(0);\n    int count = 0;\n\n    for (int i = 0; str[i] != '\\0'; i++) {\n        digits[count++] = str[i] - '0'; // Convert char to int\n    }\n\n    // Process the digits in parallel\n    for (int i = 0; i < count; i += 8) {\n        uint8x8_t current_digits = vld1_u8(digits + i);\n        uint8x8_t odd_mask = vdup_n_u8(1);\n        uint8x8_t is_odd = vand_u8(current_digits, odd_mask);\n        uint8x8_t odd_digits = vbsl_u8(is_odd, current_digits, vdup_n_u8(1)); // Keep odd digits, replace even with 1\n\n        // Calculate product of odd digits\n        uint8x8_t product_vec = vdup_n_u8(1);\n        product_vec = vmul_u8(product_vec, odd_digits);\n        \n        // Accumulate the product\n        product *= vget_lane_u8(product_vec, 0);\n        has_odd |= vget_lane_u8(is_odd, 0);\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    int length = strlen(str);\n    uint8_t digits[16] = {0}; // To hold up to 16 digits\n\n    for (int i = 0; i < length; i++) {\n        digits[i] = str[i] - '0'; // Convert char to digit\n    }\n\n    uint8x16_t vec_digits = vld1q_u8(digits);\n    uint8x16_t odd_mask = vdupq_n_u8(1); // Mask for odd digits\n    uint8x16_t is_odd = vandq_u8(vec_digits, odd_mask); // Check odd digits\n\n    // Initialize product vector\n    uint8x16_t product_vec = vdupq_n_u8(1);\n    uint8x16_t zero_vec = vdupq_n_u8(0);\n\n    for (int i = 0; i < 10; i += 2) {\n        uint8x16_t mask = vdupq_n_u8(i);\n        uint8x16_t is_current_odd = vceqq_u8(vec_digits, mask);\n        uint8x16_t current_digit = vbslq_u8(is_current_odd, vec_digits, zero_vec);\n        product_vec = vmulq_u8(product_vec, current_digit);\n    }\n\n    // Calculate the final product\n    uint8_t result[16];\n    vst1q_u8(result, product_vec);\n\n    for (int i = 0; i < 16; i++) {\n        if (result[i] != 0) {\n            product *= result[i];\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n\n    // Process digits in chunks of 16\n    int len = strlen(str);\n    int i = 0;\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t digits = vld1q_u8((uint8_t*)&str[i]);\n        digits = vsubq_u8(digits, vdupq_n_u8('0')); // Convert ASCII to integer (0-9)\n\n        uint8x16_t odd_mask = vandq_u8(vdupq_n_u8(1), vshrq_n_u8(digits, 1)); // Mask for odd digits\n        uint8x16_t odd_digits = vandq_u8(digits, odd_mask); // Keep only odd digits\n\n        // Calculate product of odd digits\n        for (int j = 0; j < 16; j++) {\n            uint8_t digit = vgetq_lane_u8(odd_digits, j);\n            if (digit > 0) {\n                product *= digit;\n                has_odd = 1;\n            }\n        }\n    }\n\n    // Process remaining digits\n    for (; i < len; i++) {\n        uint8_t digit = str[i] - '0';\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert number to string to extract digits\n    char digits[20]; // Enough to hold 64-bit number\n    snprintf(digits, sizeof(digits), \"%llu\", n);\n\n    // Load digits into a Neon register\n    uint8x8_t odd_digits = vdup_n_u8(1); // Initialize with 1 for multiplication\n    uint8x8_t even_mask = vdup_n_u8(0); // Mask for even digits\n\n    for (int i = 0; digits[i] != '\\0'; i += 8) {\n        uint8x8_t current_digits = vld1_u8((uint8_t*)&digits[i]);\n        current_digits = vsub_u8(current_digits, vdup_n_u8('0')); // Convert ASCII to integer\n\n        // Create a mask for odd digits\n        uint8x8_t is_odd = vand_u8(vand_u8(current_digits, vdup_n_u8(1)), vdup_n_u8(0xFF));\n        odd_digits = vmul_u8(odd_digits, vbsl_u8(is_odd, current_digits, vdup_n_u8(1))); // Multiply odd digits\n        even_mask = vorr_u8(even_mask, vbsl_u8(is_odd, vdup_n_u8(0), current_digits)); // Collect even digits\n    }\n\n    // Check if there are any odd digits\n    has_odd = vmax_u8(vget_low_u8(odd_digits), vget_high_u8(odd_digits));\n    if (vmax_u8(has_odd, even_mask)[0] == 1) {\n        return 0; // All digits were even\n    }\n\n    // Calculate final product\n    product = vget_lane_u8(odd_digits, 0);\n    for (int i = 1; i < 8; i++) {\n        product *= vget_lane_u8(odd_digits, i);\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer as string\n    snprintf(str, sizeof(str), \"%llu\", n);\n\n    // Load digits into a vector\n    uint8x8_t digits = vdup_n_u8(0);\n    int count = 0;\n\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (count < 8) {\n            digits[count] = str[i] - '0';\n            count++;\n        } else {\n            break;\n        }\n    }\n\n    // Process the digits in parallel\n    uint8x8_t odd_mask = vdup_n_u8(0);\n    uint8x8_t odd_digits = vdup_n_u8(1);\n\n    for (int i = 0; i < count; i++) {\n        uint8x8_t current_digit = vdup_n_u8(digits[i]);\n        uint8x8_t is_odd = vshl_n_u8(vand_u8(current_digit, vdup_n_u8(1)), 1);\n        odd_mask = vorr_u8(odd_mask, is_odd);\n        odd_digits = vmul_u8(odd_digits, vadd_u8(current_digit, vdup_n_u8(1 - is_odd[0])));\n    }\n\n    // Check if there are any odd digits\n    has_odd = vmax_u8(odd_mask, odd_mask);\n    if (has_odd == 0) {\n        return 0;\n    }\n\n    // Calculate the product of odd digits\n    for (int i = 0; i < 8; i++) {\n        if (odd_mask[i] != 0) {\n            product *= odd_digits[i];\n        }\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    uint64_t sum = 0;\n\n    // Process 4 floats at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec); // Ceiling\n        vec = vmulq_f32(vec, vec); // Square\n        sum += vaddvq_u32(vcvtq_u32_f32(vec)); // Sum of squares\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec); // Ceiling\n        vec = vmulq_f32(vec, vec); // Square\n        sum += vaddvq_f32(vec); // Sum\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    uint64_t sum = 0;\n\n    // Process 4 floats at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec); // Ceiling\n        vec = vmulq_f32(vec, vec); // Square\n        sum += vaddvq_u32(vcvtq_u32_f32(vec)); // Sum\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t sum = 0;\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec); // Ceiling operation\n        vec = vmulq_f32(vec, vec); // Square the elements\n        sum += vaddvq_f32(vec); // Sum the squared elements\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    uint64_t sum = 0;\n    \n    // Process 4 floats at a time\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec); // Ceiling operation\n        vec = vmulq_f32(vec, vec); // Square the elements\n        uint32x4_t vec_int = vcvtq_u32_f32(vec); // Convert to unsigned int\n        uint64x2_t sum_vec = vpaddlq_u32(vec_int); // Pairwise add\n        sum += vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    int32x4_t index = vdupq_n_s32(-1);\n    int32x4_t result = vdupq_n_s32(-1);\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t cmp = vcltq_s32(current, prev);\n        uint32x4_t mask = vshlq_n_u32(vreinterpretq_u32_s32(cmp), 31);\n        int32x4_t indices = vdupq_n_s32(i);\n        indices = vaddq_s32(indices, vdupq_n_s32(-1));\n\n        result = vbslq_s32(mask, indices, result);\n        prev = current;\n    }\n\n    int32x4_t max_index = vmaxq_s32(result, index);\n    int32x4_t max_index_shifted = vshrq_n_s32(max_index, 31);\n    int32_t final_result = vgetq_lane_s32(max_index_shifted, 0);\n\n    for (int i = 1; i < 4; ++i) {\n        final_result = std::max(final_result, vgetq_lane_s32(max_index_shifted, i));\n    }\n\n    return final_result == -1 ? -1 : final_result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    int32x4_t index = vdupq_n_s32(-1);\n    int32x4_t result = vdupq_n_s32(-1);\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcgeq_s32(curr, prev);\n        int32x4_t mask = vreinterpretq_s32_u32(vshlq_n_u32(cmp, 31));\n        index = vorrq_s32(index, vandq_s32(mask, vdupq_n_s32(i)));\n        prev = curr;\n\n        if (i + 4 > n) {\n            break;\n        }\n    }\n\n    int32x4_t max_index = vmaxq_s32(index, result);\n    int32x4_t max_val = vdupq_n_s32(-1);\n    result = vmaxq_s32(max_index, result);\n\n    int32_t res[4];\n    vst1q_s32(res, result);\n    \n    for (int i = 0; i < 4; i++) {\n        if (res[i] != -1) {\n            return res[i];\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    int32x4_t index = vdupq_n_s32(-1);\n    int32x4_t result = vdupq_n_s32(-1);\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcgtq_s32(prev, current);\n        if (vmaxvq_u32(cmp) != 0) {\n            index = vdupq_n_s32(i);\n            result = vdupq_n_s32(i - 1);\n        }\n        prev = current;\n    }\n\n    int32_t res[4];\n    vst1q_s32(res, result);\n    for (int i = 0; i < 4; i++) {\n        if (res[i] != -1) return res[i];\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    int32x4_t index = vdupq_n_s32(-1);\n    int32x4_t result = vdupq_n_s32(-1);\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcgtq_s32(prev, curr);\n        int32x4_t mask = vreinterpretq_s32_u32(cmp);\n\n        if (vmaxvq_s32(mask) != 0) {\n            index = vsetq_lane_s32(i, index, 0);\n            result = vsetq_lane_s32(i, result, 0);\n        }\n\n        prev = curr;\n    }\n\n    int32_t idx[4];\n    vst1q_s32(idx, index);\n    int max_index = -1;\n    for (int j = 0; j < 4; j++) {\n        if (idx[j] != -1) {\n            max_index = idx[j];\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vdupq_n_s32(arr[0]);\n    int32x4_t index = vdupq_n_s32(-1);\n    int32x4_t result = vdupq_n_s32(-1);\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t cmp = vcltq_s32(current, prev);\n        uint32x4_t mask = vshlq_n_u32(vreinterpretq_u32_s32(cmp), 31);\n        int32x4_t indices = vdupq_n_s32(i);\n        indices = vaddq_s32(indices, vdupq_n_s32(-1));\n\n        result = vbslq_s32(mask, indices, result);\n        prev = current;\n    }\n\n    int32x4_t max_result = vmaxq_s32(result, index);\n    int32x4_t max_result_shifted = vextq_s32(max_result, max_result, 3);\n    max_result = vmaxq_s32(max_result, max_result_shifted);\n\n    int32_t output[4];\n    vst1q_s32(output, max_result);\n    \n    for (int j = 0; j < 4; j++) {\n        if (output[j] != -1) {\n            return output[j];\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        max_neg = vmaxq_s32(max_neg, vbslq_s32(neg_mask, vec, max_neg));\n        min_pos = vminq_s32(min_pos, vbslq_s32(pos_mask, vec, min_pos));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg = vmaxq_s32(max_neg, vdupq_n_s32(lst[i]));\n        } else if (lst[i] > 0) {\n            min_pos = vminq_s32(min_pos, vdupq_n_s32(lst[i]));\n        }\n    }\n\n    int32_t largest_neg = vgetq_lane_s32(max_neg, 0);\n    int32_t smallest_pos = vgetq_lane_s32(min_pos, 0);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(vec, zero);\n        int32x4_t pos_mask = vcgtq_s32(vec, zero);\n\n        max_neg = vmaxq_s32(max_neg, vbslq_s32(neg_mask, vec, max_neg));\n        min_pos = vminq_s32(min_pos, vbslq_s32(pos_mask, vec, min_pos));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg = vmaxq_s32(max_neg, vdupq_n_s32(lst[i]));\n        } else if (lst[i] > 0) {\n            min_pos = vminq_s32(min_pos, vdupq_n_s32(lst[i]));\n        }\n    }\n\n    int32_t largest_neg = vgetq_lane_s32(max_neg, 0);\n    int32_t smallest_pos = vgetq_lane_s32(min_pos, 0);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n    int32x4_t zero = vdupq_n_s32(0);\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(vec, zero);\n        int32x4_t pos_mask = vcgtq_s32(vec, zero);\n\n        max_neg = vmaxq_s32(max_neg, vbslq_s32(neg_mask, vec, max_neg));\n        min_pos = vminq_s32(min_pos, vbslq_s32(pos_mask, vec, min_pos));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int32_t val = lst[i];\n        if (val < 0) {\n            max_neg = vmaxq_s32(max_neg, vdupq_n_s32(val));\n        } else if (val > 0) {\n            min_pos = vminq_s32(min_pos, vdupq_n_s32(val));\n        }\n    }\n\n    int32_t largest_neg = vgetq_lane_s32(max_neg, 0);\n    int32_t smallest_pos = vgetq_lane_s32(min_pos, 0);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        max_neg = vmaxq_s32(max_neg, vbslq_s32(neg_mask, vec, max_neg));\n        min_pos = vminq_s32(min_pos, vbslq_s32(pos_mask, vec, min_pos));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg = vmaxq_s32(max_neg, vdupq_n_s32(lst[i]));\n        } else if (lst[i] > 0) {\n            min_pos = vminq_s32(min_pos, vdupq_n_s32(lst[i]));\n        }\n    }\n\n    int32_t largest_neg = vgetq_lane_s32(max_neg, 0);\n    int32_t smallest_pos = vgetq_lane_s32(min_pos, 0);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        max_neg = vmaxq_s32(max_neg, vbslq_s32(neg_mask, vec, max_neg));\n        min_pos = vminq_s32(min_pos, vbslq_s32(pos_mask, vec, min_pos));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg = vmaxq_s32(max_neg, vdupq_n_s32(lst[i]));\n        } else if (lst[i] > 0) {\n            min_pos = vminq_s32(min_pos, vdupq_n_s32(lst[i]));\n        }\n    }\n\n    int32_t largest_neg = vgetq_lane_s32(max_neg, 0);\n    int32_t smallest_pos = vgetq_lane_s32(min_pos, 0);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[16] = {1}; // Store factorials from 0! to 15!\n\n    for (uint64_t i = 1; i <= 15; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    uint64x2_t prod = vdupq_n_u64(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        if (i + 1 <= n) {\n            uint64x2_t temp = vdupq_n_u64(factorials[i]);\n            temp = vmulq_u64(temp, vdupq_n_u64(factorials[i + 1]));\n            prod = vmulq_u64(prod, temp);\n        } else {\n            prod = vmulq_u64(prod, vdupq_n_u64(factorials[i]));\n        }\n    }\n\n    result = vgetq_lane_u64(prod, 0) * vgetq_lane_u64(prod, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[16]; // Assuming n <= 15 for simplicity\n    uint64_t i;\n\n    // Calculate factorials in parallel using Neon\n    for (i = 0; i <= n; i += 2) {\n        uint64x2_t v = {1, 1};\n        for (uint64_t j = 1; j <= i; j++) {\n            v = vmulq_u64(v, (uint64x2_t){j, j});\n        }\n        factorials[i] = vgetq_lane_u64(v, 0);\n        if (i + 1 <= n) {\n            factorials[i + 1] = vgetq_lane_u64(v, 1);\n        }\n    }\n\n    // Calculate the Brazilian factorial\n    for (i = 1; i <= n; i++) {\n        result *= factorials[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[16] = {1}; // Store factorials from 0! to 15!\n    \n    for (uint64_t i = 1; i <= 15; ++i) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    uint64x2_t prod = vdupq_n_u64(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        uint64x2_t f = vld1q_u64(&factorials[i]);\n        prod = vmulq_u64(prod, f);\n    }\n\n    result *= vgetq_lane_u64(prod, 0);\n    result *= vgetq_lane_u64(prod, 1);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[16] = {1}; // Store factorials up to 15!\n\n    for (uint64_t i = 1; i <= n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    uint64x2_t prod = vdupq_n_u64(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        if (i + 1 <= n) {\n            uint64x2_t vals = vld1q_u64(&factorials[i]);\n            prod = vmulq_u64(prod, vals);\n        } else {\n            prod = vmulq_u64(prod, vdupq_n_u64(factorials[i]));\n        }\n    }\n\n    uint64_t result_array[2];\n    vst1q_u64(result_array, prod);\n    result = result_array[0] * result_array[1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[16] = {1}; // Store factorials from 0! to 15!\n\n    for (uint64_t i = 1; i <= 15; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    uint64x2_t prod = vdupq_n_u64(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        if (i < n) {\n            uint64x2_t f = vld1q_u64(&factorials[i]);\n            prod = vmulq_u64(prod, f);\n        } else {\n            prod = vmulq_u64(prod, vdupq_n_u64(factorials[i]));\n        }\n    }\n\n    uint64_t result_array[2];\n    vst1q_u64(result_array, prod);\n    result = result_array[0] * result_array[1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n    int remainder = size % 4;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size - remainder; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = vld1q_s32(&lst[i]); // Using the same vector for indices\n\n        // Create masks for multiples of 3 and 4\n        int32x4_t mask3 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t mask4 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0));\n        \n        // Square for multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask3, squared, vec);\n\n        // Cube for multiples of 4 and not multiples of 3\n        int32x4_t cubed = vmulq_s32(vmulq_s32(vec, vec), vec);\n        vec = vbslq_s32(mask4, cubed, vec);\n\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Horizontal sum\n    int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    sum_pair = vadd_s32(sum_pair, vuzp1_s32(sum_pair, sum_pair));\n    sum += vget_lane_s32(sum_pair, 0);\n\n    // Handle remaining elements\n    for (int i = size - remainder; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n    int remainder = size % 4;\n    int iterations = size / 4;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < iterations; ++i) {\n        int32x4_t vec = vld1q_s32(&lst[i * 4]);\n        int32x4_t indices = vdupq_n_s32(i * 4);\n\n        // Square if index is multiple of 3\n        int32x4_t mask_square = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask_square, squared, vec);\n\n        // Cube if index is multiple of 4 and not multiple of 3\n        int32x4_t mask_cube = vceqq_s32(vandq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0));\n        mask_cube = vbslq_s32(vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0)), vdupq_n_s32(0), mask_cube);\n        int32x4_t cubed = vmulq_s32(vmull_s32(vget_low_s32(vec), vget_low_s32(vec)), vget_low_s32(vec));\n        vec = vbslq_s32(mask_cube, cubed, vec);\n\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (int i = size - remainder; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    // Sum up the vector\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n    int remainder = size % 4;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size - remainder; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = vld1q_s32(&lst[i]); // Using the same vector for indices\n\n        // Create masks for multiples of 3 and 4\n        int32x4_t mask3 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t mask4 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0));\n        \n        // Square for multiples of 3\n        vec = vbslq_s32(mask3, vmulq_s32(vec, vec), vec);\n        \n        // Cube for multiples of 4 (not multiples of 3)\n        int32x4_t temp = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask4, vmulq_s32(temp, vec), vec);\n        \n        // Sum the results\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (int i = size - remainder; i < size; i++) {\n        int value = lst[i];\n        if (i % 3 == 0) {\n            sum += value * value;\n        } else if (i % 4 == 0) {\n            sum += value * value * value;\n        } else {\n            sum += value;\n        }\n    }\n\n    // Sum the vector\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int32x4_t result = data;\n\n        int32x4_t index = vdupq_n_s32(i);\n        uint32x4_t mask_square = vceqq_u32(vand_u32(vshrq_n_u32(vreinterpretq_u32_s32(index), 1), vdupq_n_u32(1)), vdupq_n_u32(1));\n        uint32x4_t mask_cube = vceqq_u32(vand_u32(vshrq_n_u32(vreinterpretq_u32_s32(index), 2), vdupq_n_u32(1)), vdupq_n_u32(1));\n\n        result = vbslq_s32(mask_square, vmulq_s32(data, data), result);\n        result = vbslq_s32(mask_cube, vmulq_s32(vmulq_s32(data, data), data), result);\n\n        sum_vec = vaddq_s32(sum_vec, result);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int i = 0; i < 4; ++i) {\n        sum += temp[i];\n    }\n\n    for (int i = size - (size % 4); i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int size = lst.size();\n    int remainder = size % 4;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size - remainder; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t index_vec = vdupq_n_s32(i);\n        \n        int32x4_t square_mask = vceqq_s32(vandq_s32(index_vec, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t cube_mask = vceqq_s32(vandq_s32(index_vec, vdupq_n_s32(4)), vdupq_n_s32(0));\n        \n        vec = vbslq_s32(square_mask, vmulq_s32(vec, vec), vec);\n        vec = vbslq_s32(cube_mask, vmulq_s32(vmulq_s32(vec, vec), vec), vec);\n        \n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int i = 0; i < 4; i++) {\n        sum += temp[i];\n    }\n\n    for (int i = size - remainder; i < size; i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int vector_size = size / 4 * 4; // Process in multiples of 4\n    uint32x4_t odd_mask = vdupq_n_u32(0xAAAAAAAA); // Mask for odd digits\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t data = vld1q_s32(&nums[i]);\n        uint32x4_t greater_than_10 = vcgtq_s32(data, vdupq_n_s32(10));\n        \n        // Extract first and last digits\n        uint32x4_t first_digit = vdupq_n_u32(0);\n        uint32x4_t last_digit = vdupq_n_u32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            int32_t num = vgetq_lane_s32(data, j);\n            if (num < 0) num = -num; // Handle negative numbers\n            \n            // Get last digit\n            last_digit = vsetq_lane_u32(num % 10, last_digit, j);\n            // Get first digit\n            while (num >= 10) num /= 10;\n            first_digit = vsetq_lane_u32(num, first_digit, j);\n        }\n\n        // Check if both first and last digits are odd\n        uint32x4_t first_odd = vandq_u32(vandq_u32(first_digit, odd_mask), vdupq_n_u32(1));\n        uint32x4_t last_odd = vandq_u32(vandq_u32(last_digit, odd_mask), vdupq_n_u32(1));\n        uint32x4_t both_odd = vandq_u32(first_odd, last_odd);\n        \n        // Combine conditions\n        uint32x4_t valid = vandq_u32(greater_than_10, both_odd);\n        count += vaddvq_u32(valid);\n    }\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int first_digit = num < 0 ? -num : num;\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = num < 0 ? -num : num % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int vec_size = size / 4 * 4; // Process in multiples of 4\n    uint32x4_t odd_mask = vdupq_n_u32(0xAAAAAAAA); // Mask for odd digits (1, 3, 5, 7, 9)\n\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t data = vld1q_s32(&nums[i]);\n        uint32x4_t greater_than_ten = vcgtq_s32(data, vdupq_n_s32(10));\n        \n        // Extract first and last digits\n        uint32x4_t first_digit = vshrq_n_u32(vabsq_s32(data), 28); // Right shift to get first digit\n        uint32x4_t last_digit = vdupq_n_u32(0);\n        last_digit = vorrq_u32(last_digit, vandq_u32(data, vdupq_n_u32(0xF))); // Mask to get last digit\n\n        // Check if both first and last digits are odd\n        uint32x4_t first_odd = vandq_u32(greater_than_ten, vorrq_u32(vandq_u32(first_digit, odd_mask), vdupq_n_u32(0)));\n        uint32x4_t last_odd = vandq_u32(greater_than_ten, vorrq_u32(vandq_u32(last_digit, odd_mask), vdupq_n_u32(0)));\n        \n        uint32x4_t result = vandq_u32(first_odd, last_odd);\n        count += vaddvq_u32(result);\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = std::abs(nums[i]) % 10;\n            if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int remainder = size % 4;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n    \n    for (int i = 0; i < size - remainder; i += 4) {\n        int32x4_t data = vld1q_s32(&nums[i]);\n        uint32x4_t greater_than_10 = vcgtq_s32(data, vdupq_n_s32(10));\n\n        int32x4_t first_digit = vabsq_s32(data);\n        first_digit = vdivq_s32(first_digit, vdupq_n_s32(10));\n        first_digit = vmodq_s32(first_digit, vdupq_n_s32(10));\n        \n        int32x4_t last_digit = vabsq_s32(data);\n        last_digit = vdupq_n_s32(10);\n        last_digit = vmodq_s32(last_digit, vdupq_n_s32(10));\n\n        uint32x4_t first_odd = vorrq_u32(vandq_u32(vceqq_s32(first_digit, vdupq_n_s32(1)), greater_than_10),\n                                          vandq_u32(vceqq_s32(first_digit, vdupq_n_s32(3)), greater_than_10));\n        first_odd = vorrq_u32(first_odd, vandq_u32(vceqq_s32(first_digit, vdupq_n_s32(5)), greater_than_10));\n        first_odd = vorrq_u32(first_odd, vandq_u32(vceqq_s32(first_digit, vdupq_n_s32(7)), greater_than_10));\n        first_odd = vorrq_u32(first_odd, vandq_u32(vceqq_s32(first_digit, vdupq_n_s32(9)), greater_than_10));\n\n        uint32x4_t last_odd = vorrq_u32(vandq_u32(vceqq_s32(last_digit, vdupq_n_s32(1)), greater_than_10),\n                                         vandq_u32(vceqq_s32(last_digit, vdupq_n_s32(3)), greater_than_10));\n        last_odd = vorrq_u32(last_odd, vandq_u32(vceqq_s32(last_digit, vdupq_n_s32(5)), greater_than_10));\n        last_odd = vorrq_u32(last_odd, vandq_u32(vceqq_s32(last_digit, vdupq_n_s32(7)), greater_than_10));\n        last_odd = vorrq_u32(last_odd, vandq_u32(vceqq_s32(last_digit, vdupq_n_s32(9)), greater_than_10));\n\n        uint32x4_t result = vandq_u32(first_odd, last_odd);\n        count_vec = vaddq_u32(count_vec, result);\n    }\n\n    count += vgetq_lane_u32(count_vec, 0);\n    count += vgetq_lane_u32(count_vec, 1);\n    count += vgetq_lane_u32(count_vec, 2);\n    count += vgetq_lane_u32(count_vec, 3);\n\n    for (int i = size - remainder; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = abs(nums[i]) % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int vectorSize = size / 4 * 4; // Process in multiples of 4\n    int32x4_t threshold = vdupq_n_s32(10);\n    int32x4_t oddMask = vdupq_n_s32(0xAAAAAAAA); // Mask for odd digits (1, 3, 5, 7, 9)\n\n    for (int i = 0; i < vectorSize; i += 4) {\n        int32x4_t data = vld1q_s32(&nums[i]);\n        uint32x4_t greaterThanTen = vcgtq_s32(data, threshold);\n\n        // Extract first and last digits\n        int32x4_t firstDigit = vdupq_n_s32(0);\n        int32x4_t lastDigit = vdupq_n_s32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            int32_t num = vgetq_lane_s32(data, j);\n            if (num < 0) num = -num; // Make positive for digit extraction\n            firstDigit = vsetq_lane_s32(num / 10, firstDigit, j);\n            lastDigit = vsetq_lane_s32(num % 10, lastDigit, j);\n        }\n\n        // Check if first and last digits are odd\n        uint32x4_t firstOdd = vandq_u32(vshrq_n_u32(vreinterpretq_u32_s32(firstDigit), 1), oddMask);\n        uint32x4_t lastOdd = vandq_u32(vreinterpretq_u32_s32(lastDigit), oddMask);\n        uint32x4_t bothOdd = vandq_u32(firstOdd, lastOdd);\n\n        // Combine conditions\n        uint32x4_t result = vandq_u32(greaterThanTen, bothOdd);\n        count += vaddvq_u32(result);\n    }\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int first = std::abs(num);\n            while (first >= 10) first /= 10;\n            int last = std::abs(num) % 10;\n            if ((first % 2 != 0) && (last % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int remainder = size % 4;\n    int vector_size = size - remainder;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t data = vld1q_s32(&nums[i]);\n        uint32x4_t greater_than_ten = vcgtq_s32(data, vdupq_n_s32(10));\n\n        int32x4_t first_digit = vabsq_s32(data);\n        first_digit = vdivq_s32(first_digit, vdupq_n_s32(10));\n        first_digit = vdupq_n_s32(1) + vdupq_n_s32(3) + vdupq_n_s32(5) + vdupq_n_s32(7) + vdupq_n_s32(9);\n        uint32x4_t first_digit_odd = vandq_u32(greater_than_ten, vdupq_n_u32(1));\n\n        int32x4_t last_digit = vabsq_s32(data);\n        last_digit = vdupq_n_s32(1) + vdupq_n_s32(3) + vdupq_n_s32(5) + vdupq_n_s32(7) + vdupq_n_s32(9);\n        uint32x4_t last_digit_odd = vandq_u32(greater_than_ten, vdupq_n_u32(1));\n\n        uint32x4_t result = vandq_u32(first_digit_odd, last_digit_odd);\n        count_vec = vaddq_u32(count_vec, result);\n    }\n\n    count += vgetq_lane_u32(count_vec, 0);\n    count += vgetq_lane_u32(count_vec, 1);\n    count += vgetq_lane_u32(count_vec, 2);\n    count += vgetq_lane_u32(count_vec, 3);\n\n    for (int i = vector_size; i < size; i++) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = std::abs(nums[i]) % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    uint64_t a[4]; // To hold the values for the last 4 iterations\n    uint64x2_t v_count = vdupq_n_u64(0);\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        uint64x2_t idx = vld1q_u64((uint64_t[]){i, i + 1});\n        uint64x2_t a_vals = vmlaq_n_u64(vmulq_u64(idx, idx), vdupq_n_u64(-1), 1);\n        \n        vst1q_u64(a, a_vals);\n        \n        for (int j = 0; j < 2; j++) {\n            for (int k = j + 1; k < 2; k++) {\n                for (int l = k + 1; l < 2; l++) {\n                    if ((a[j] + a[k] + a[l]) % 3 == 0) {\n                        v_count = vaddq_u64(v_count, vdupq_n_u64(1));\n                    }\n                }\n            }\n        }\n    }\n\n    count += vgetq_lane_u64(v_count, 0) + vgetq_lane_u64(v_count, 1);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t a[4]; // To hold the values for SIMD processing\n    uint64_t total_elements = (n + 3) / 4; // Number of 4-element groups\n    uint64x2_t sum = vdupq_n_u64(0);\n    \n    for (uint64_t i = 0; i < total_elements; i++) {\n        uint64_t start = i * 4 + 1;\n        uint64x4_t indices = {start, start + 1, start + 2, start + 3};\n        uint64x4_t values = vmlaq_n_u64(vmulq_u64(indices, indices), vdupq_n_u64(-1), 1);\n        \n        // Calculate the sum of the values\n        sum = vaddq_u64(sum, values);\n        \n        // Store the values in a for further processing\n        vst1q_u64(a, values);\n    }\n    \n    // Count valid triples\n    for (uint64_t i = 0; i < total_elements; i++) {\n        for (uint64_t j = i + 1; j < total_elements; j++) {\n            for (uint64_t k = j + 1; k < total_elements; k++) {\n                uint64_t sum_triplet = a[i] + a[j] + a[k];\n                if (sum_triplet % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    uint64_t a[4]; // To hold the values for the last 4 elements\n    uint64x2_t sum_count = vdupq_n_u64(0);\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        uint64x2_t idx = vdupq_n_u64(i);\n        uint64x2_t idx2 = vdupq_n_u64(i + 1);\n        uint64x2_t idx3 = vdupq_n_u64(i + 2);\n        uint64x2_t idx4 = vdupq_n_u64(i + 3);\n\n        uint64x2_t a1 = vmlaq_n_u64(vmulq_u64(idx, idx), vdupq_n_u64(-1), 1);\n        uint64x2_t a2 = vmlaq_n_u64(vmulq_u64(idx2, idx2), vdupq_n_u64(-1), 1);\n        uint64x2_t a3 = vmlaq_n_u64(vmulq_u64(idx3, idx3), vdupq_n_u64(-1), 1);\n        uint64x2_t a4 = vmlaq_n_u64(vmulq_u64(idx4, idx4), vdupq_n_u64(-1), 1);\n\n        uint64x2_t a_vec[4] = { a1, a2, a3, a4 };\n\n        for (int j = 0; j < 4; j++) {\n            a[j] = vgetq_lane_u64(a_vec[j], 0);\n            a[j + 1] = vgetq_lane_u64(a_vec[j], 1);\n        }\n\n        for (int j = 0; j < 4; j++) {\n            for (int k = j + 1; k < 4; k++) {\n                for (int l = k + 1; l < 4; l++) {\n                    if ((a[j] + a[k] + a[l]) % 3 == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    uint64_t a[3] = {0};\n    uint64_t *results = (uint64_t*)malloc(n * sizeof(uint64_t));\n\n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t idx = vld1q_u64((uint64_t[]){i + 1, i + 2});\n        uint64x2_t values = vmlaq_n_u64(vshlq_n_u64(idx, 1), idx, -1);\n        values = vaddq_u64(values, vdupq_n_u64(1));\n        vst1q_u64(results + i, values);\n    }\n\n    for (uint64_t i = 0; i < n; i++) {\n        a[i % 3] = results[i] % 3;\n        if (i >= 2) {\n            count += (a[0] == 0) + (a[1] == 0) + (a[2] == 0);\n        }\n    }\n\n    free(results);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    uint64_t a[3] = {0};\n    uint64_t *arr = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t idx = vdupq_n_u64(i + 1);\n        uint64x2_t values = vmlaq_n_u64(vmulq_u64(idx, idx), vdupq_n_u64(-1), vdupq_n_u64(1));\n        if (i < n) {\n            vst1q_u64(arr + i, values);\n        }\n        if (i + 1 < n) {\n            vst1q_u64(arr + i + 1, values);\n        }\n    }\n\n    for (uint64_t i = 0; i < n; i++) {\n        a[i % 3] = arr[i] % 3;\n        if (i >= 2) {\n            count += (a[0] + a[1] + a[2]) % 3 == 0;\n        }\n    }\n\n    free(arr);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    \n    int32x4_t result = vdupq_n_s32(y); // Default to y\n    uint32x4_t prime_mask = vdupq_n_u32(0);\n\n    // Check if n is prime\n    prime_mask = vdupq_n_u32(is_prime(n)); // This will only work for a single value of n\n\n    // If prime_mask is 1, set result to x\n    result = vbslq_s32(prime_mask, x_vec, result);\n\n    return vgetq_lane_s32(result, 0); // Return the first element\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    \n    int32x4_t result_vec = vdupq_n_s32(y); // Default to y\n    int32x4_t prime_mask = vdupq_n_s32(0); // Mask for prime numbers\n\n    // Check if n is prime\n    int prime = is_prime(n);\n    prime_mask = vdupq_n_s32(prime);\n\n    // If prime, set result to x\n    result_vec = vbslq_s32(prime_mask, x_vec, result_vec);\n\n    return vgetq_lane_s32(result_vec, 0); // Return the first element\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int result = y;\n    if (is_prime(n)) {\n        result = x;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    \n    int32x4_t result = vdupq_n_s32(y); // Default to y\n    int32x4_t prime_mask = vdupq_n_s32(0); // Mask for prime check\n\n    // Check if n is prime\n    prime_mask = vdupq_n_s32(is_prime(n)); // This will set to 1 if prime, 0 otherwise\n\n    // Use the prime mask to select x or y\n    result = vbslq_s32(prime_mask, x_vec, y_vec);\n\n    return vgetq_lane_s32(result, 0); // Return the first element\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    \n    int32x4_t result = vdupq_n_s32(y); // Default to y\n    int32x4_t prime_mask = vdupq_n_s32(0);\n\n    // Check if n is prime\n    prime_mask = vdupq_n_s32(is_prime(n));\n\n    // If prime, set result to x\n    result = vbslq_s32(prime_mask, x_vec, result);\n    \n    return vgetq_lane_s32(result, 0); // Return the first element\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t odd_mask = vandq_u32(vcgtq_f32(vec, vdupq_n_f32(0.0f)), vshrq_n_u32(vcgtq_f32(vec, vdupq_n_f32(0.0f)), 1));\n        float32x4_t odd_vec = vbslq_f32(odd_mask, vec, vdupq_n_f32(0.0f));\n        sum_vec = vmlaq_f32(sum_vec, odd_vec, odd_vec);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    sum += vget_lane_f32(sum_pair, 0);\n\n    for (; i < size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    \n    if (size == 0) return 0;\n\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    int32x4_t odd_mask = vdupq_n_s32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        float32x4_t data = vld1q_f32(&lst[i]);\n        int32x4_t int_data = vcvtq_s32_f32(data);\n        \n        // Create a mask for odd numbers\n        odd_mask = vandq_s32(int_data, vdupq_n_s32(1));\n        odd_mask = vceqq_s32(odd_mask, vdupq_n_s32(1));\n        \n        // Square the numbers\n        float32x4_t squared = vmulq_f32(data, data);\n        \n        // Zero out the squares of even numbers\n        squared = vbslq_f32(odd_mask, squared, vdupq_n_f32(0.0f));\n        \n        // Accumulate the results\n        sum_vec = vaddq_f32(sum_vec, squared);\n    }\n    \n    // Horizontal add to get the final sum\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    \n    return static_cast<uint64_t>(vget_lane_f32(sum_pair, 0));\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int n = lst.size();\n    \n    if (n == 0) return 0;\n\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t odd_mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        uint32x4_t is_odd = vandq_u32(vshrq_n_u32(vreinterpretq_u32_f32(vec), 1), vdupq_n_u32(1));\n        uint32x4_t valid_mask = vandq_u32(odd_mask, is_odd);\n        \n        vec = vmulq_f32(vec, vec);\n        vec = vbslq_f32(valid_mask, vec, vdupq_n_f32(0.0f));\n        \n        sum_vec = vaddq_f32(sum_vec, vec);\n    }\n\n    float32x2_t sum_low = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_low = vpadd_f32(sum_low, sum_low);\n    sum += vget_lane_f32(sum_low, 0);\n\n    for (; i < n; i++) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    float32x4_t odd_mask = vdupq_n_f32(1.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    float32x4_t sum_vec = zero;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t data = vld1q_f32(&lst[i]);\n        uint32x4_t odd_mask_vec = vcgtq_f32(data, zero);\n        uint32x4_t is_odd = vandq_u32(odd_mask_vec, vdupq_n_u32(1));\n\n        data = vmulq_f32(data, vdupq_n_f32(1.0f));\n        data = vmulq_f32(data, data);\n        data = vbslq_f32(is_odd, data, zero);\n\n        sum_vec = vaddq_f32(sum_vec, data);\n    }\n\n    float32x4_t sum_vec_h = vaddq_f32(sum_vec, vextq_f32(sum_vec, sum_vec, 1));\n    sum_vec_h = vaddq_f32(sum_vec_h, vextq_f32(sum_vec_h, sum_vec_h, 2));\n    \n    sum += vgetq_lane_u32(vreinterpretq_u32_f32(sum_vec_h), 0);\n    \n    for (; i < size; i++) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t odd_mask = vandq_u32(vcgtq_f32(vec, vdupq_n_f32(0)), vshrq_n_u32(vcgtq_f32(vec, vdupq_n_f32(0)), 1));\n        vec = vmulq_f32(vec, vcvtq_f32_u32(odd_mask));\n        sum_vec = vmlaq_f32(sum_vec, vec, vec);\n    }\n\n    float32x2_t sum_pair = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    sum += vget_lane_f32(sum_pair, 0);\n\n    for (; i < size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n    \n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n    \n    for (; i < length; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n    \n    for (; i < length; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}

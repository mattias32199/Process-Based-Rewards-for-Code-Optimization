{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = vsetvl_e64(length);\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n        vbool64_t mask_vec = vle64(mask + i);\n        vint64m1_t src_vec = vle64(src + i);\n        vint64m1_t dst_vec = vselect(mask_vec, src_vec, vmv_v_x_i64m1(0, current_length));\n        vse64(dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i); // Set vector length\n        vbool64_t mask_vec = vle64_v_b64(mask + i); // Load mask\n        vint64m1_t src_vec = vle64_v_i64m1(src + i); // Load source\n        vint64m1_t dst_vec = vselect_v_i64m1(mask_vec, src_vec, vmv_v_x_i64m1(0, vl)); // Conditional select\n        vse64_v_i64m1(dst + i, dst_vec); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i); // Set vector length\n        vbool64_t mask_vec = vle64_v_b64(mask + i); // Load mask\n        vint64m1_t src_vec = vle64_v_i64m1(src + i); // Load source\n        \n        // Conditional copy\n        vse64_v_i64m1(dst + i, src_vec, mask_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i); // Set vector length\n        vbool64_t mask_vec = vle64_v_b64(mask + i); // Load mask\n        vint64m1_t src_vec = vle64_v_i64m1(src + i); // Load source\n        \n        // Conditional move\n        vse64_v_i64m1(dst + i, src_vec, mask_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = vsetvl_e64(length);\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e64(length - i);\n        vbool64_t mask_vec = vle64_v_b64(mask + i);\n        vuint64m1_t src_vec = vle64_v_u64(src + i);\n        vse64_v_u64(dst + i, src_vec, mask_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_scale = vmv_v_x_u32m1(scale, vl);\n        \n        vuint32m1_t v_tmp1 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), 3, vl);\n        vuint32m1_t v_tmp2 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), -3, vl);\n        \n        vuint32m1_t v_result = vdiv_vv_u32m1(vadd_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), vmul_vv_u32m1(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        \n        vse32_v_u32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_scale = vmv_v_x_u32m1(scale, vl);\n        \n        vuint32m1_t v_tmp1 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), 3, vl);\n        vuint32m1_t v_tmp2 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), -3, vl);\n        \n        vuint32m1_t v_result = vadd_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), vmul_vv_u32m1(v_tmp1, v_tmp2, vl), vl);\n        v_result = vdiv_vv_u32m1(v_result, vmv_v_x_u32m1(7, vl), vl);\n        \n        vse32_v_u32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_scale = vmv_v_x_u32m1(scale, vl);\n        \n        vuint32m1_t v_tmp1 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), 3, vl);\n        vuint32m1_t v_tmp2 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), -3, vl);\n        \n        vuint32m1_t v_result = vdiv_vv_u32m1(vadd_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), vmul_vv_u32m1(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        \n        vse32_v_u32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    vtype<int> v_scale = vsetvl_e32(length);\n    for (size_t i = 0; i < length; i += v_scale) {\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], v_scale);\n        vuint32m1_t v_tmp1 = vssrl_v_u32m1(vmul_vx_u32m1(v_src, scale, v_scale), 3, v_scale);\n        vuint32m1_t v_tmp2 = vshl_v_u32m1(vmul_vx_u32m1(v_src, scale, v_scale), 3, v_scale);\n        vuint32m1_t v_result = vdiv_v_u32m1(vadd_v_u32m1(vmul_v_u32m1(v_src, scale, v_scale), vmul_v_u32m1(v_tmp1, v_tmp2, v_scale), v_scale), 7, v_scale);\n        vse32_v_u32m1(&dst[i], v_result, v_scale);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_scale = vmv_v_x_u32m1(scale, vl);\n        \n        vuint32m1_t v_tmp1 = vssrl_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), 3, vl);\n        vuint32m1_t v_tmp2 = vssll_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), 3, vl);\n        \n        vuint32m1_t v_result = vdiv_vv_u32m1(vadd_vv_u32m1(vmul_vv_u32m1(v_src, v_scale, vl), vmul_vv_u32m1(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        \n        vse32_v_u32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64(1); // Set vector length to 1 for scalar operation\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m1_t val = vle64_v_f64m1(&src[index], vl);\n        vse64_v_f64m1(&dst[r], val, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length to 1 for scalar load/store\n    for (size_t r = 0; r < rows; r += vl) {\n        size_t actual_vl = vl <= (rows - r) ? vl : (rows - r);\n        vfloat64m1_t data = vle64_v_f64m1(&src[r * cols + stride], actual_vl);\n        vse64_v_f64m1(&dst[r], data, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length for 64-bit floats\n    for (size_t r = 0; r < rows; r += vl) {\n        size_t actual_vl = vl;\n        if (r + vl > rows) {\n            actual_vl = rows - r; // Adjust vector length if it exceeds rows\n        }\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[r * cols + stride], actual_vl);\n        vse64_v_f64m1(&dst[r], v_src, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length to 1 for scalar operations\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[index], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1); // Vector length for 64-bit double\n    for (size_t r = 0; r < rows; r += vl) {\n        size_t actual_vl = vl;\n        if (r + vl > rows) {\n            actual_vl = rows - r; // Adjust for the last iteration\n        }\n        vfloat64m1_t data = vle64_v_f64m1(&src[r * cols + stride], actual_vl);\n        vse64_v_f64m1(&dst[r], data, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e32(length - i);\n        vuint32m1_t idx = vle32_v_u32m1(&indices[i], current_vl);\n        vfloat32m1_t gathered = vld_v_f32m1(&src[idx], current_vl);\n        vse32_v_f32m1(&dst[i], gathered, current_vl);\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e32(length - i);\n        vuint32m1_t idx = vle32_v_u32m1(&indices[i], current_vl);\n        vfloat32m1_t values_to_scatter = vle32_v_f32m1(&src[i], current_vl);\n        vsseg32_v_f32m1(&dst[idx], values_to_scatter, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e32(length - i);\n        vuint32m1_t idx = vle32_v_u32m1(&indices[i], current_vl);\n        vfloat32m1_t gathered = vld_v_f32m1(&src[idx], current_vl);\n        vse32_v_f32m1(&dst[i], gathered, current_vl);\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e32(length - i);\n        vuint32m1_t idx = vle32_v_u32m1(&indices[i], current_vl);\n        vfloat32m1_t values_to_scatter = vle32_v_f32m1(&src[i], current_vl);\n        vsw_v_f32m1(&dst[idx], values_to_scatter, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t v_src = vle32_v_f32m1(&src[i], vl);\n        vint32m1_t v_indices = vle32_v_i32m1(&indices[i], vl);\n        \n        // Gather operation\n        vfloat32m1_t gathered_values = vld_v_f32m1(src, v_indices);\n        vse32_v_f32m1(&dst[i], gathered_values, vl);\n        \n        // Scatter operation\n        vse32_v_f32m1(&dst[v_indices], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    \n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n        v_indices = vle32_v_i32m1(&indices[i], current_length);\n        v_src = vld_v_f32m1(&src[0], current_length);\n        vfloat32m1_t gathered = vld_v_f32m1(&src[v_indices], current_length);\n        vse32_v_f32m1(&dst[i], gathered, current_length);\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n        v_indices = vle32_v_i32m1(&indices[i], current_length);\n        v_src = vle32_v_f32m1(&src[i], current_length);\n        vsw_v_f32m1(&dst[0], v_src, v_indices, current_length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        \n        vfloat32m1_t src_vec = vle32_v_f32m1(&src[i], vl);\n        vint32m1_t indices_vec = vle32_v_i32m1(&indices[i], vl);\n        \n        // Gather operation\n        vfloat32m1_t gathered = vld_v_f32m1(src_vec, indices_vec);\n        vse32_v_f32m1(&dst[i], gathered, vl);\n        \n        // Scatter operation\n        vse32_v_f32m1(&dst[indices[i]], src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = vsetvl_e16m1(length);\n    \n    for (uint64_t i = 0; i < length / 2; i += vec_len) {\n        vuint16m1_t vec_start = vle16_v_u16m1(&arr[start + i], vec_len);\n        vuint16m1_t vec_end = vle16_v_u16m1(&arr[end - i], vec_len);\n        \n        vse16_v_u16m1(&arr[start + i], vec_end, vec_len);\n        vse16_v_u16m1(&arr[end - i], vec_start, vec_len);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = vsetvl_e16(length);\n    \n    for (uint64_t i = 0; i < length / 2; i += vec_len) {\n        vuint16m1_t vec_start = vle16_v_u16m1(&arr[start + i], vec_len);\n        vuint16m1_t vec_end = vle16_v_u16m1(&arr[end - i], vec_len);\n        \n        vse16_v_u16m1(&arr[start + i], vec_end, vec_len);\n        vse16_v_u16m1(&arr[end - i], vec_start, vec_len);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = vsetvl_e16m1(length);\n    \n    vuint16m1_t vec_start = vle16_v_u16m1(&arr[start]);\n    vuint16m1_t vec_end = vle16_v_u16m1(&arr[end - length + 1]);\n    \n    for (uint64_t i = 0; i < length / 2; i += vec_len) {\n        vuint16m1_t temp_start = vle16_v_u16m1(&arr[start + i]);\n        vuint16m1_t temp_end = vle16_v_u16m1(&arr[end - i]);\n        \n        vse16_v_u16m1(&arr[start + i], temp_end);\n        vse16_v_u16m1(&arr[end - i], temp_start);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = vsetvl_e16(length);\n    \n    for (uint64_t i = 0; i < length / 2; i += vec_len) {\n        vuint16m1_t vec_start = vle16_v_u16m1(&arr[start + i], vec_len);\n        vuint16m1_t vec_end = vle16_v_u16m1(&arr[end - i], vec_len);\n        \n        vse16_v_u16m1(&arr[start + i], vec_end, vec_len);\n        vse16_v_u16m1(&arr[end - i], vec_start, vec_len);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = vsetvl_e16(len);\n    \n    vuint16m1_t vec_start = vle16_v_u16m1(&arr[start], vec_len);\n    vuint16m1_t vec_end = vle16_v_u16m1(&arr[end - len + 1], vec_len);\n    \n    for (uint64_t i = 0; i < len; i++) {\n        vse16_v_u16m1(&arr[start + i], vslide1down_u16m1(vec_end, vec_start, i));\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += VEC_SIZE) {\n        vuint8m1_t vec_data = vle8_v_u8m1(tensor + slice_offset + i);\n        vse8_v_u8m1(slice + i, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + (slice_idx * slice_size);\n    \n    size_t vl = vsetvl_e8m1(slice_size);\n    for (size_t i = 0; i < slice_size; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > slice_size) {\n            current_vl = slice_size - i;\n        }\n        vuint8m1_t v_data = vle8_v_u8m1(src + i);\n        vse8_v_u8(slice + i, v_data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * slice_size;\n    \n    size_t vl = vsetvl_e8m1(slice_size);\n    for (size_t i = 0; i < slice_size; i += vl) {\n        size_t n = slice_size - i < vl ? slice_size - i : vl;\n        vuint8m1_t data = vle8_v_u8m1(src + i);\n        vse8_v_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *source = tensor + slice_idx * slice_size;\n\n    size_t vl = vsetvl_e8m1(slice_size);\n    for (size_t i = 0; i < slice_size; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > slice_size) {\n            current_vl = slice_size - i;\n        }\n        vuint8m1_t data = vle8_v_u8m1(source + i);\n        vse8_v_u8m1(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n\n    for (size_t i = 0; i < slice_size; i += VEC_SIZE) {\n        vuint8m1_t vec_data = vle8_v_u8m1(tensor + offset + i);\n        vse8_v_u8m1(slice + i, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t num_blocks_row = (rows + block_size - 1) / block_size;\n    size_t num_blocks_col = (cols + block_size - 1) / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            size_t row_start = block_row * block_size;\n            size_t col_start = block_col * block_size;\n            size_t row_end = (row_start + block_size < rows) ? row_start + block_size : rows;\n            size_t col_end = (col_start + block_size < cols) ? col_start + block_size : cols;\n\n            for (size_t i = row_start; i < row_end; i++) {\n                for (size_t j = col_start; j < col_end; j++) {\n                    size_t src_index = i * cols + j;\n                    size_t dst_index = j * rows + i;\n                    vuint16m1_t vec_src = vle16_v_u16m1(&src[src_index], vl);\n                    vse16_v_u16m1(&dst[dst_index], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t num_blocks_row = (rows + block_size - 1) / block_size;\n    size_t num_blocks_col = (cols + block_size - 1) / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            size_t row_start = block_row * block_size;\n            size_t col_start = block_col * block_size;\n            size_t row_end = (row_start + block_size < rows) ? row_start + block_size : rows;\n            size_t col_end = (col_start + block_size < cols) ? col_start + block_size : cols;\n\n            for (size_t i = row_start; i < row_end; i++) {\n                for (size_t j = col_start; j < col_end; j++) {\n                    size_t src_index = i * cols + j;\n                    size_t dst_index = j * rows + i;\n\n                    vuint16m1_t vec_src = vle16_v_u16m1(&src[src_index], vl);\n                    vse16_v_u16m1(&dst[dst_index], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t num_blocks_row = (rows + block_size - 1) / block_size;\n    size_t num_blocks_col = (cols + block_size - 1) / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            size_t row_start = block_row * block_size;\n            size_t col_start = block_col * block_size;\n            size_t row_end = (row_start + block_size < rows) ? row_start + block_size : rows;\n            size_t col_end = (col_start + block_size < cols) ? col_start + block_size : cols;\n\n            for (size_t i = row_start; i < row_end; ++i) {\n                for (size_t j = col_start; j < col_end; ++j) {\n                    size_t src_index = i * cols + j;\n                    size_t dst_index = j * rows + i;\n\n                    vuint16m1_t vec_src = vle16_v_u16m1(&src[src_index], vl);\n                    vse16_v_u16m1(&dst[dst_index], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t num_blocks_row = (rows + block_size - 1) / block_size;\n    size_t num_blocks_col = (cols + block_size - 1) / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            size_t row_start = block_row * block_size;\n            size_t col_start = block_col * block_size;\n            size_t row_end = row_start + block_size < rows ? row_start + block_size : rows;\n            size_t col_end = col_start + block_size < cols ? col_start + block_size : cols;\n\n            for (size_t i = row_start; i < row_end; i++) {\n                for (size_t j = col_start; j < col_end; j += VEC_SIZE) {\n                    vuint16m1_t vec_src = vle16_v_u16m1(&src[i * cols + j]);\n                    vse16_v_u16m1(&dst[j * rows + i], vec_src);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t num_blocks_row = (rows + block_size - 1) / block_size;\n    size_t num_blocks_col = (cols + block_size - 1) / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            size_t row_start = block_row * block_size;\n            size_t col_start = block_col * block_size;\n            size_t row_end = row_start + block_size < rows ? row_start + block_size : rows;\n            size_t col_end = col_start + block_size < cols ? col_start + block_size : cols;\n\n            for (size_t i = row_start; i < row_end; i++) {\n                for (size_t j = col_start; j < col_end; j += VEC_SIZE) {\n                    vuint16m1_t vec_src = vle16_v_u16m1(&src[i * cols + j]);\n                    vse16_v_u16m1(&dst[j * rows + i], vec_src);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t n = dim * dim * dim;\n    float sum = 0.0f;\n    size_t vec_len = vsetvl_e32(1); // Set vector length to 1 for scalar operations\n    size_t i;\n\n    for (i = 0; i < dim; i += vec_len) {\n        vfloat32m1_t vec_sum = vfmv_v_f_f32m1(0.0f); // Initialize vector sum to 0\n        size_t j;\n        for (j = 0; j < vec_len && (i + j) < dim; j++) {\n            size_t index = (i + j) * dim * dim + (i + j) * dim + (i + j);\n            vec_sum = vfadd_vv_f32m1(vec_sum, vfmv_v_f_f32m1(array[index]));\n        }\n        sum += vfmv_f_s_f32m1(vec_sum);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t diagonal_length = dim;\n    size_t vector_length = vsetvl_e32m1(diagonal_length);\n    float sum = 0.0f;\n\n    for (size_t i = 0; i < diagonal_length; i += vector_length) {\n        vfloat32m1_t vec = vle32_v_f32m1(&array[i * (dim + 1)], vector_length);\n        sum += vfredusum_vs_f32m1(vsum_f32m1(vec), sum, sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t total_elements = dim * dim * dim;\n    size_t diagonal_length = dim;\n    float sum = 0.0f;\n\n    for (size_t i = 0; i < diagonal_length; i += VLEN / sizeof(float)) {\n        vfloat32m1_t vec_sum = vfmv_v_f_f32m1(0.0f);\n        size_t remaining = diagonal_length - i;\n\n        if (remaining < VLEN / sizeof(float)) {\n            for (size_t j = 0; j < remaining; j++) {\n                sum += array[i + j * (dim * dim + 1)];\n            }\n        } else {\n            vfloat32m1_t vec_diag = vle32_v_f32m1(&array[i * (dim * dim + 1)], remaining);\n            vec_sum = vadd_vv_f32m1(vec_sum, vec_diag);\n            sum += vfmv_f_s_f32(vec_sum);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t num_elements = dim * dim * dim;\n    size_t diagonal_length = dim; // Number of diagonal elements\n    float sum = 0.0f;\n\n    // Vector length\n    size_t vl = vsetvl_e32(diagonal_length);\n\n    // Load diagonal elements and compute sum\n    for (size_t i = 0; i < diagonal_length; i += vl) {\n        vfloat32m1_t vec = vle32_v_f32m1(&array[i * (dim * dim + 1)], vl);\n        sum += vfredusum_vs_f32m1_f32m1(sum, vec, sum, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t total_elements = dim * dim * dim;\n    size_t diagonal_elements = dim; // Number of diagonal elements\n    float sum = 0.0f;\n\n    // Vector length\n    size_t vl = vsetvl_e32(diagonal_elements);\n\n    // Load diagonal elements into a vector\n    vfloat32m1_t vec_sum = vfmv_v_f_f32m1(0.0f, vl);\n    for (size_t i = 0; i < diagonal_elements; i += vl) {\n        size_t actual_vl = vsetvl_e32(diagonal_elements - i);\n        vfloat32m1_t vec_diag = vle32_v_f32m1(&array[i * (dim + 1)], actual_vl);\n        vec_sum = vfredusum_vs_f32m1_f32m1(vec_sum, vec_diag, vec_sum, actual_vl);\n    }\n\n    // Reduce the vector sum to a scalar\n    float result = vfmv_f_s_f32(vec_sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, vl);\n    vfloat64m1_t v_scale = vfmv_v_f_f64m1(scale, vl);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i], vl);\n        vbool64_t mask = vfsgt_vv_f64m1(v_src, v_threshold, vl);\n        vfloat64m1_t v_result = vfmerge_vv_f64m1(v_src, vfmul_vv_f64m1(v_src, v_scale, vl), mask, vl);\n        vse64_v_f64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, vl);\n    vfloat64m1_t v_scale = vfmv_v_f_f64m1(scale, vl);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i], current_vl);\n        vbool64_t mask = vfsgt_vv_f64m1(v_src, v_threshold, current_vl);\n        vfloat64m1_t v_result = vfadd_vv_f64m1(v_src, vfmul_vv_f64m1(v_scale, v_src, mask, current_vl), current_vl);\n        vse64_v_f64m1(&dst[i], v_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_threshold = vle64_v_f64m1(&threshold);\n    vfloat64m1_t v_scale = vle64_v_f64m1(&scale);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i]);\n        vbool64_t mask = vfredge_vf_f64m1(vle64_v_f64m1(&src[i]), v_threshold, current_vl);\n        vfloat64m1_t v_result = vfadd_vv_f64m1(v_src, vfmul_vv_f64m1(v_scale, mask, current_vl), current_vl);\n        vse64_v_f64m1(&dst[i], v_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, vl);\n    vfloat64m1_t v_scale = vfmv_v_f_f64m1(scale, vl);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i], current_vl);\n        vbool64_t mask = vfsgt_vv_f64m1(v_src, v_threshold, current_vl);\n        vfloat64m1_t v_result = vfmerge_vv_f64m1(v_src, vfmul_vv_f64m1(v_src, v_scale, current_vl), mask, current_vl);\n        vse64_v_f64m1(&dst[i], v_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold);\n    vfloat64m1_t v_scale = vfmv_v_f_f64m1(scale);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i]);\n        vbool64_t mask = vfsgt_vv_f64m1(v_src, v_threshold);\n        vfloat64m1_t v_result = vfmerge_vfm_f64m1(v_src, vfmul_vv_f64m1(v_src, v_scale, current_vl), mask);\n        vse64_v_f64m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length for double\n\n    for (size_t r = 0; r < rows; r++) {\n        size_t idx = indices[r];\n        for (size_t c = 0; c < cols; c += vl) {\n            size_t vl_actual = vsetvl_e64m1(cols - c < vl ? cols - c : vl);\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[idx * cols + c], vl_actual);\n            vse64_v_f64m1(&dst[r * cols + c], src_vec, vl_actual);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length for double\n    for (size_t i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += vl) {\n            size_t vl_actual = vsetvl_e64m1(cols - j < vl ? cols - j : vl);\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[index * cols + j], vl_actual);\n            vse64_v_f64m1(&dst[i * cols + j], src_vec, vl_actual);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64(1); // Set vector length to 1 for double\n    for (size_t i = 0; i < rows; i++) {\n        size_t row_index = indices[i];\n        for (size_t j = 0; j < cols; j += vl) {\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[row_index * cols + j], vl);\n            vse64_v_f64m1(&dst[i * cols + j], src_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64m1(1); // Set vector length for double\n    for (size_t i = 0; i < rows; i++) {\n        size_t row_index = indices[i];\n        for (size_t j = 0; j < cols; j += vl) {\n            size_t vl_actual = vsetvl_e64m1(cols - j);\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[row_index * cols + j], vl_actual);\n            vse64_v_f64m1(&dst[i * cols + j], src_vec, vl_actual);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = vsetvl_e64(1); // Set vector length to 1 for double\n    for (size_t i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += vl) {\n            size_t vl_actual = vsetvl_e64(cols - j < vl ? cols - j : vl);\n            vfloat64m1_t src_vec = vle64_v_f64m1(&src[index * cols + j], vl_actual);\n            vse64_v_f64m1(&dst[i * cols + j], src_vec, vl_actual);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i); // Set vector length\n        vuint64m8_t v_src1 = vle64_v_u64m8(&src1[i], vl);\n        vuint64m8_t v_src2 = vle64_v_u64m8(&src2[i], vl);\n        vuint64m8_t v_result = vadd_vv_u64m8(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m8(v_result, scalar, vl);\n        v_result = vssra_vu64m8(v_result, 1, vl); // Divide by 2 (right shift)\n        vse64_v_u64m8(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t v_src1 = vle64_v_u64m1(&src1[i], vl);\n        vuint64m1_t v_src2 = vle64_v_u64m1(&src2[i], vl);\n        vuint64m1_t v_result = vadd_vv_u64m1(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m1(v_result, scalar, vl);\n        v_result = vssra_vi_u64m1(v_result, 1, vl);\n        vse64_v_u64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t v_src1 = vle64_v_u64m1(&src1[i], vl);\n        vuint64m1_t v_src2 = vle64_v_u64m1(&src2[i], vl);\n        vuint64m1_t v_result = vadd_vv_u64m1(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m1(v_result, scalar, vl);\n        v_result = vssrl_vu_u64m1(v_result, 1, vl);\n        vse64_v_u64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i); // Set vector length\n        vuint64m8_t v_src1 = vle64_v_u64m8(&src1[i], vl);\n        vuint64m8_t v_src2 = vle64_v_u64m8(&src2[i], vl);\n        vuint64m8_t v_result = vadd_vv_u64m8(v_src1, v_src2, vl);\n        vuint64m8_t v_scalar = vdup_v_u64m8(scalar, vl);\n        v_result = vadd_vv_u64m8(v_result, v_scalar, vl);\n        v_result = vssrl_v_u64m8(v_result, 1, vl); // Divide by 2 (round-toward-zero)\n        vse64_v_u64m8(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t v_src1 = vle64_v_u64m1(&src1[i], vl);\n        vuint64m1_t v_src2 = vle64_v_u64m1(&src2[i], vl);\n        vuint64m1_t v_result = vadd_vv_u64m1(v_src1, v_src2, vl);\n        v_result = vadd_vi_u64m1(v_result, scalar, vl);\n        v_result = vssra_vi_u64m1(v_result, 1, vl);\n        vse64_v_u64m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    vuint32m1_t min_val = vundefined_u32m1();\n    size_t vec_len = vsetvl_e32m1(1);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (i + 1 < length) {\n            vuint32m1_t data = vle32_v_u32m1(&src[i], vec_len);\n            min_val = vminu_vv_u32m1(min_val, data);\n        } else {\n            vuint32m1_t data = vle32_v_u32m1(&src[i], vec_len);\n            min_val = vminu_vv_u32m1(min_val, data);\n        }\n    }\n\n    uint32_t result = vget_u32m1(min_val, 0);\n    for (size_t i = 1; i < vgetvl_e32m1(1); i++) {\n        uint32_t temp = vget_u32m1(min_val, i);\n        if (temp < result) {\n            result = temp;\n        }\n    }\n\n    return result == UINT32_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    vuint32m1_t min_val = vundefined_u32m1();\n    size_t vec_len = vsetvl_e32m1(1);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        vuint32m1_t data = vle32_v_u32m1(&src[i], vec_len);\n        min_val = vminu_vv_u32m1(min_val, data, vec_len);\n    }\n\n    uint32_t min_result = vget_u32m1(min_val, 0);\n    for (size_t i = 1; i < vec_len; i++) {\n        uint32_t temp = vget_u32m1(min_val, i);\n        if (temp < min_result) {\n            min_result = temp;\n        }\n    }\n\n    return min_result == UINT32_MAX ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    vuint32m1_t min_vec = vundefined_u32m1();\n    size_t vec_len = vsetvl_e32m1(length / 2);\n    \n    for (size_t i = 0; i < length; i += 2) {\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vec_len);\n        min_vec = vminu_vv_u32m1(min_vec, src_vec, vec_len);\n    }\n\n    uint32_t min_val = vget_u32m1(min_vec, 0);\n    for (size_t i = 1; i < vec_len; i++) {\n        uint32_t temp = vget_u32m1(min_vec, i);\n        if (temp < min_val) {\n            min_val = temp;\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vec_len = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vundefined_i32m1();\n    int min_value = INT_MAX;\n\n    for (size_t i = 0; i < length; i += 2) {\n        vint32m1_t src_vec = vle32_v_i32m1(&src[i], vec_len);\n        min_vec = vmin_vv_i32m1(min_vec, src_vec, vec_len);\n    }\n\n    for (size_t i = 0; i < vec_len; i++) {\n        int value = vfmv_f_s_i32_m1(min_vec, i);\n        if (value < min_value) {\n            min_value = value;\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    vtype *v_src = (vtype *)src;\n    size_t vec_len = length / 2; // Only consider even indexed elements\n    vtype min_val = vundefined_vtype(); // Initialize min_val to undefined\n\n    for (size_t i = 0; i < vec_len; i += VLEN / sizeof(int)) {\n        vtype vec = vle32_v_i32(v_src + 2 * i); // Load even indexed elements\n        min_val = vmin_vv_i32(min_val, vec); // Compute minimum\n    }\n\n    // Reduce the vector to find the minimum value\n    int min_result = INT_MAX;\n    for (size_t i = 0; i < VLEN / sizeof(int); i++) {\n        int temp = vextract_i32(min_val, i);\n        if (temp < min_result) {\n            min_result = temp;\n        }\n    }\n\n    return (min_result == INT_MAX) ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    vuint32m1_t src_uint = vle32_v_u32m1(src, vl);\n    vint32m1_t src_int = vle32_v_i32m1(src, vl);\n    \n    vint32m1_t arith_shift = vssra_vx_i32m1(src_int, shift, vl);\n    vuint32m1_t logical_shift = vssrl_vx_u32m1(src_uint, shift, vl);\n    vint32m1_t logical_shift_int = vreinterpret_v_u32m1_i32m1(logical_shift);\n    \n    vint32m1_t result = vadd_vv_i32m1(arith_shift, logical_shift_int, vl);\n    vse32_v_i32m1(dst, result, vl);\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vuint32m1_t src_uint;\n    vint32m1_t src_int;\n    vint32m1_t arith_shifted;\n    vuint32m1_t logical_shifted;\n    \n    for (size_t i = 0; i < length; i += VEC_SIZE) {\n        vl = vsetvl_e32m1(length - i);\n        \n        src_int = vle32_v_i32m1(&src[i], vl);\n        arith_shifted = vashr_vx_i32m1(src_int, shift, vl);\n        \n        src_uint = vreinterpret_v_u32m1(src_int);\n        logical_shifted = vlsr_vx_u32m1(src_uint, shift, vl);\n        \n        vint32m1_t result = vadd_vv_i32m1(arith_shifted, vreinterpret_v_i32m1(logical_shifted), vl);\n        vse32_v_i32m1(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t src_uint = vle32_v_u32m1(&src[i], vl);\n        vint32m1_t src_int = vle32_v_i32m1(&src[i], vl);\n\n        vint32m1_t arith_shift = vssra_vx_i32m1(src_int, shift, vl);\n        vuint32m1_t logical_shift = vssrl_vx_u32m1(src_uint, shift, vl);\n        vint32m1_t logical_shift_int = vreinterpret_v_u32m1_i32m1(logical_shift);\n\n        vint32m1_t result = vadd_vv_i32m1(arith_shift, logical_shift_int, vl);\n        vse32_v_i32m1(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t src_uint = vle32_v_u32m1(&src[i], vl);\n        vint32m1_t src_int = vle32_v_i32m1(&src[i], vl);\n\n        vint32m1_t arith_shift = vssra_vx_i32m1(src_int, shift, vl);\n        vuint32m1_t logical_shift = vssrl_vx_u32m1(src_uint, shift, vl);\n        vint32m1_t logical_shift_int = vreinterpret_v_i32m1_u32m1(logical_shift);\n\n        vint32m1_t result = vadd_vv_i32m1(arith_shift, logical_shift_int, vl);\n        vse32_v_i32m1(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t src_uint = vle32_v_u32m1(&src[i], vl);\n        vint32m1_t src_int = vle32_v_i32m1(&src[i], vl);\n        \n        vint32m1_t arith_shift = vssra_vx_i32m1(src_int, shift, vl);\n        vuint32m1_t logical_shift = vlsr_vx_u32m1(src_uint, shift, vl);\n        vint32m1_t logical_shift_int = vreinterpret_v_u32m1_i32m1(logical_shift);\n        \n        vint32m1_t result = vadd_vv_i32m1(arith_shift, logical_shift_int, vl);\n        vse32_v_i32m1(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    size_t vl = vsetvl_e32(total_elements);\n    vuint32m1_t v_sum = vundefined_u32m1();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e32(total_elements - i);\n        vuint32m1_t v_data = vle32_v_u32m1(&matrix[i], current_vl);\n        v_sum = vadd_vv_u32m1(v_sum, v_data, current_vl);\n    }\n\n    sum = vsum_v_u32m1(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl = vsetvl_e32(total_elements);\n\n    vuint32m1_t v_sum = vundefined_u32m1();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i);\n        vuint32m1_t v_data = vle32_v_u32m1(&matrix[i], vl);\n        v_sum = vadd_u32m1(v_sum, v_data);\n    }\n\n    uint32_t temp[8];\n    vse32_v_u32m1(temp, v_sum, vl);\n    for (size_t j = 0; j < vl; j++) {\n        sum += temp[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl = vsetvl_e32m1(total_elements);\n\n    vuint32m1_t vec_sum = vundefined_u32m1();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m1(total_elements - i);\n        vuint32m1_t vec_data = vle32_v_u32m1(&matrix[i], vl);\n        vec_sum = vadd_u32m1(vec_sum, vec_data);\n    }\n\n    uint32_t temp_sum[8] = {0};\n    vse32_v_u32m1(temp_sum, vec_sum, vl);\n    \n    for (size_t j = 0; j < vl; j++) {\n        sum += temp_sum[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    size_t vl = vsetvl_e32m1(total_elements);\n    vuint32m1_t vec_sum = vundefined_u32m1();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m1(total_elements - i);\n        vuint32m1_t vec_data = vle32_v_u32m1(&matrix[i], vl);\n        vec_sum = vadd_u32m1(vec_sum, vec_data);\n    }\n\n    uint32_t temp_sum[8];\n    vse32_v_u32m1(temp_sum, vec_sum, vl);\n    \n    for (size_t j = 0; j < vl; j++) {\n        sum += temp_sum[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl = vsetvl_e32(total_elements);\n\n    vuint32m1_t v_sum = vundefined_u32m1();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i);\n        vuint32m1_t v_data = vle32_v_u32m1(&matrix[i], vl);\n        v_sum = vadd_u32m1(v_sum, v_data);\n    }\n\n    // Horizontal sum of vector\n    uint32_t temp[8] = {0};\n    vse32_v_u32(temp, v_sum, vl);\n    for (size_t j = 0; j < vl; j++) {\n        sum += temp[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl = vsetvl_e8m1(length);\n    vuint8m1_t vec_src = vle8_v_u8m1(src, vl);\n    vuint8m1_t vec_max = vmv_v_x_u8m1(max_value, vl);\n    size_t index = 0;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vec_src = vle8_v_u8m1(src + i, vl);\n        vbool8_t mask = vmslt_vx_u8m1(vec_src, vec_max, vl);\n        \n        if (vfirst_m(mask, vl) != -1) {\n            size_t local_index = i + vfirst_m(mask, vl);\n            max_value = src[local_index];\n            max_index = local_index;\n        }\n        \n        vec_max = vmaxu_vv_u8m1(vec_max, vec_src, vl);\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl = vsetvl_e8m1(length);\n    vuint8m1_t vec_src = vle8_v_u8m1(src, vl);\n    vuint8m1_t vec_max = vslide1up_v_u8m1(vec_src, 0, vl);\n    vuint8m1_t vec_indices = vseq_v_u8m1(vle8_v_u8m1(src, vl), vec_max, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vec_src = vle8_v_u8m1(src + i, vl);\n        vec_max = vmax_vv_u8m1(vec_max, vec_src, vl);\n        vec_indices = vseq_v_u8m1(vec_src, vec_max, vl);\n    }\n\n    for (size_t i = 0; i < vl; ++i) {\n        if (vget_u8m1(vec_indices, i)) {\n            max_index = i + (i / vl) * vl;\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl = vsetvl_e8m1(length);\n    vuint8m1_t vec_src = vle8_v_u8m1(src, vl);\n    vuint8m1_t vec_max = vmv_v_x_u8m1(max_value, vl);\n    vuint8m1_t vec_index = vmv_v_x_u8m1(0, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vec_src = vle8_v_u8m1(src + i, vl);\n        \n        vbool8_t mask = vmslt_vv_u8m1(vec_src, vec_max, vl);\n        vec_max = vmerge_vxm(mask, vec_max, vec_src, vl);\n        \n        vuint8m1_t indices = vadd_vx_u8m1(vmv_v_x_u8m1(i, vl), vseq_vx_u8m1(vl), vl);\n        vec_index = vmerge_vxm(mask, vec_index, indices, vl);\n    }\n\n    max_index = vfirst_m(mask, vec_index);\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl = vsetvl_e8m1(length);\n    vuint8m1_t vec_src = vle8_v_u8m1(src, vl);\n    vuint8m1_t vec_max = vslide1up_v_u8m1(vec_src, 0, vl);\n    vuint8m1_t vec_indices = vseq_v_u8m1(vle8_v_u8m1(src, vl), vec_max, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vec_src = vle8_v_u8m1(src + i, vl);\n        vec_max = vmax_v_u8m1(vec_max, vec_src, vl);\n        vuint8m1_t new_indices = vseq_v_u8m1(vec_src, vec_max, vl);\n        vec_indices = vor_v_u8m1(vec_indices, new_indices, vl);\n    }\n\n    for (size_t i = 0; i < vl; i++) {\n        if (vget_u8m1(vec_indices, i)) {\n            max_index = i + (length - vl);\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl = vsetvl_e8m1(length);\n    vuint8m1_t vec_src = vle8_v_u8m1(src, vl);\n    vuint8m1_t vec_max = vslide1down_v_u8m1(vec_src, vec_src, 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vec_src = vle8_v_u8m1(src + i, vl);\n        vec_max = vmaxu_vv_u8m1(vec_max, vec_src);\n        \n        // Find the index of the maximum value\n        for (size_t j = 0; j < vl; j++) {\n            if (vec_src[j] == vec_max[j]) {\n                max_index = i + j;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        \n        vuint16m1_t v_indices = vmv_v_x_u16m1(i, vl);\n        vuint16m1_t v_mask = vmv_v_x_u16m1(mask, vl);\n        vuint16m1_t v_and = vand_vu16m1(v_indices, v_mask, vl);\n        \n        vbool16_t mask_condition = vmsltu_vu16m1(v_and, vmv_v_x_u16m1(0, vl), vl);\n        vuint16m1_t v_result = select(mask_condition, v_src1, v_src2, vl);\n        \n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_indices = vmv_v_x_u16m1(i, vl);\n        vuint16m1_t v_mask = vmv_v_x_u16m1(mask, vl);\n        \n        vuint16m1_t v_result = vmerge_vv_u16m1(v_src1, v_src2, vand_vx_u16m1(v_indices, v_mask, vl), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_indices = vmv_v_x_u16m1(i, vl);\n        vuint16m1_t v_mask = vmv_v_x_u16m1(mask, vl);\n        \n        vuint16m1_t v_result = vselect_u16m1(vand_vx_u16m1(v_indices, v_mask), v_src1, v_src2);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i); // Set vector length\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        \n        // Create a vector of indices\n        vuint32m1_t v_indices = vmv_v_x_u32m1(i, vl);\n        vuint32m1_t v_mask = vmv_v_x_u32m1(mask, vl);\n        \n        // Compute the condition (index & mask) != 0\n        vuint32m1_t v_condition = vand_vv_u32m1(v_indices, v_mask);\n        vbool1_t v_blend_mask = vmsne_vv_u32m1(v_condition, vmv_v_x_u32m1(0, vl), vl);\n        \n        // Blend the two sources based on the condition\n        vuint16m1_t v_result = vmerge_vv_u16m1(v_src2, v_src1, v_blend_mask);\n        \n        // Store the result\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        \n        vuint32m1_t v_index = vmv_v_x_u32m1(i, vl);\n        vuint32m1_t v_mask = vmv_v_x_u32m1(mask, vl);\n        \n        vuint32m1_t v_and = vand_vv_u32m1(v_index, v_mask);\n        vbool32_t mask_condition = vmsltu_vv_u32m1(v_and, vmv_v_x_u32m1(1, vl));\n        \n        vuint16m1_t v_result = vmerge_vv_u16m1(v_src2, v_src1, mask_condition);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_count = vpopcount_v_u32m1(v_src, vl);\n        vse32_v_u32m1(&dst[i], v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e32m1(VEC_LEN);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_count = vpopcount_u32m1(v_src, vl);\n        vse32_v_u32m1(&dst[i], v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_count = vpopcount_u32m1(v_src, vl);\n        vse32_v_u32m1(&dst[i], v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_SIZE) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_dst = vpopcount_v_u32m1(v_src, vl);\n        vse32_v_u32m1(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VEC_LEN) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint32m1_t v_count = vpopcount_v_u32m1(v_src, vl);\n        vse32_v_u32m1(&dst[i], v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_result = vadd_vv_u16m1(v_src1, v_src2, vl);\n        v_result = vminu_v_u16m1(v_result, vundefined_u16m1(), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_result = vadd_vv_u16m1(v_src1, v_src2, vl);\n        v_result = vminu_v_u16m1(v_result, vundefined_u16m1(), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_result = vadd_vv_u16m1(v_src1, v_src2, vl);\n        v_result = vminu_v_u16m1(v_result, vundefined_u16m1(), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_result = vadd_vv_u16m1(v_src1, v_src2, vl);\n        v_result = vminu_v_u16m1(v_result, vundefined_u16m1(), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src1 = vle16_v_u16m1(&src1[i], vl);\n        vuint16m1_t v_src2 = vle16_v_u16m1(&src2[i], vl);\n        vuint16m1_t v_result = vadd_vv_u16m1(v_src1, v_src2, vl);\n        v_result = vminu_v_u16m1(v_result, vundefined_u16m1(), vl);\n        vse16_v_u16m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VLEN) {\n                size_t vl = (k + VLEN <= n) ? VLEN : (n - k);\n                vfloat64m1_t a_vec = vle64_v_f64m1(&A[i * n + k], vl);\n                vfloat64m1_t b_vec = vle64_v_f64m1(&B[k * p + j], vl);\n                \n                vbool64_t mask_a = vmslt_v_f64m1(a_vec, 100.0);\n                vbool64_t mask_b = vmslt_v_f64m1(b_vec, 100.0);\n                vbool64_t mask = vand_vb(mask_a, mask_b);\n                \n                a_vec = vmerge_vx_f64m1(a_vec, vfmv_v_f_f64m1(0.0, 1), vmseq_v_f64m1(a_vec, a_vec));\n                b_vec = vmerge_vx_f64m1(b_vec, vfmv_v_f_f64m1(0.0, 1), vmseq_v_f64m1(b_vec, b_vec));\n                \n                sum = vfmacc_vv_f64m1(sum, a_vec, b_vec);\n            }\n            C[i * p + j] = vfmv_f_s_f64(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t a_vec = vle64_v_f64m1(&A[i * n + k]);\n                vfloat64m1_t b_vec = vle64_v_f64m1(&B[k * p + j]);\n                \n                vbool64_t mask_a = vmslt_v_f64m1(a_vec, 100.0);\n                vbool64_t mask_b = vmslt_v_f64m1(b_vec, 100.0);\n                vbool64_t mask = vand_vb(mask_a, mask_b);\n                \n                vfloat64m1_t a_filtered = vmerge_vxm_f64m1(a_vec, a_vec, mask);\n                vfloat64m1_t b_filtered = vmerge_vxm_f64m1(b_vec, b_vec, mask);\n                \n                sum = vfmacc_vv_f64m1(sum, a_filtered, b_filtered);\n            }\n            C[i * p + j] = vfmv_f_s_f64(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t a_vec = vle64_v_f64m1(&A[i * n + k]);\n                vfloat64m1_t b_vec = vle64_v_f64m1(&B[k * p + j]);\n                \n                vbool64_t a_mask = vmslt_v_f64m1(a_vec, 100.0);\n                vbool64_t b_mask = vmslt_v_f64m1(b_vec, 100.0);\n                vbool64_t mask = vand_vb64(a_mask, b_mask);\n                \n                a_vec = vmerge_vv_f64m1(a_vec, vfmv_v_f_f64m1(0.0, 1), mask);\n                b_vec = vmerge_vv_f64m1(b_vec, vfmv_v_f_f64m1(0.0, 1), mask);\n                \n                sum = vfmacc_vv_f64m1(sum, a_vec, b_vec);\n            }\n            C[i * p + j] = vfmv_f_s_f64(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VLEN) {\n                size_t vl = (k + VLEN > n) ? (n - k) : VLEN;\n                vfloat64m1_t a_vec = vle64_v_f64m1(&A[i * n + k], vl);\n                vfloat64m1_t b_vec = vle64_v_f64m1(&B[k * p + j], vl);\n                \n                vbool64_t mask_a = vmslt_v_f64m1_b64(a_vec, 100.0);\n                vbool64_t mask_b = vmslt_v_f64m1_b64(b_vec, 100.0);\n                vbool64_t mask = vand_vb64(mask_a, mask_b);\n                \n                sum = vfadd_vv_f64m1(sum, vfmul_vv_f64m1(a_vec, b_vec, mask));\n            }\n            vse64_v_f64m1(&C[i * p + j], sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t a_vec = vle64_v_f64m1(&A[i * n + k]);\n                vfloat64m1_t b_vec = vle64_v_f64m1(&B[k * p + j]);\n\n                vbool64_t a_mask = vmslt_v_f64m1_b64(a_vec, 100.0);\n                vbool64_t b_mask = vmslt_v_f64m1_b64(b_vec, 100.0);\n                vbool64_t mask = vandb(a_mask, b_mask);\n\n                sum = vfadd_vv_f64m1(sum, vfmv_v_f_f64m1(0.0, 1), mask);\n                sum = vfadd_vv_f64m1(sum, vfmul_vv_f64m1(a_vec, b_vec, mask));\n            }\n            C[i * p + j] = vfmv_f_s_f64(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vc = vadd_vv_u64m1(va, vb);\n        vse64_v_u64m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t c_vec = vadd_vv_u64m1(a_vec, b_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t c_vec = vadd_vv_u64m1(a_vec, b_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t c_vec = vadd_vv_u64m1(a_vec, b_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t c_vec = vadd_vv_u64m1(a_vec, b_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_result = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_result, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl); // Load src1\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl); // Load src2\n        vfloat32m1_t v_sum = vadd_vv_f32m1(v_src1, v_src2, vl); // Element-wise addition\n        vint32m1_t v_rounded = vrndne_v_f32m1(v_sum, vl); // Round to nearest integer\n        vse32_v_i32m1(&dst[i], v_rounded, vl); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl); // Load src1\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl); // Load src2\n        vfloat32m1_t v_sum = vadd_vv_f32m1(v_src1, v_src2, vl); // Element-wise addition\n        vint32m1_t v_result = vrndne_v_f32m1(v_sum, vl); // Round to nearest integer\n        vse32_v_i32m1(&dst[i], v_result, vl); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_result = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_rounded = vrndne_v_f32m1(v_result, vl);\n        vse32_v_f32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        vfloat32m1_t v_result = vadd_vv_f32m1(v_src1, v_src2, vl);\n        vint32m1_t v_rounded = vrndne_v_f32m1(v_result, vl);\n        vse32_v_i32m1(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i]);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i]);\n        \n        vfloat32m1_t v_diff = vfredusum_vs_f32m1(v_src1, v_src2, v_src1);\n        vfloat32m1_t v_abs_diff = vfredusum_vs_f32m1(v_src1, v_src2, v_src2);\n        \n        vbool32_t mask = vmsltu_vv_f32m1(v_abs_diff, vfmv_v_f32m1(50.0f));\n        vbool32_t index_mask = vmsltu_vv_f32m1(vsetvl_e32m1(i), vfmv_v_f32m1(2.0f));\n        \n        vbool32_t final_mask = vand_vv_b32(mask, index_mask);\n        \n        vfloat32m1_t v_result = vfmv_v_f32m1(-1.0f);\n        v_result = vfmul_vv_f32m1(v_src1, v_src2);\n        v_result = vrndup_v_f32m1(v_result);\n        \n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m4(length - i); // Set vector length\n        vfloat32m4_t v_src1 = vle32_v_f32m4(&src1[i]);\n        vfloat32m4_t v_src2 = vle32_v_f32m4(&src2[i]);\n        \n        vfloat32m4_t v_diff = vsub_vv_f32m4(v_src1, v_src2);\n        vfloat32m4_t v_abs_diff = vfredusum_vs_f32m4(vfsgn_v_f32m4(v_diff), v_f32m4(0), v_f32m4(0));\n        \n        vbool4_t mask_diff = vmsltu_vx_f32m4(v_abs_diff, 50.0f);\n        vbool4_t mask_index = vmsltu_vx_f32m4(vsetvl_e32m4(i), 2);\n        vbool4_t mask = vandb(mask_diff, mask_index);\n        \n        vfloat32m4_t v_result = vfmul_vv_f32m4(v_src1, v_src2);\n        v_result = vfrintp_v_f32m4(v_result); // Round towards positive infinity\n        \n        vfloat32m4_t v_default = vfmv_v_f_f32m4(-1.0f);\n        vfloat32m4_t v_final = vmerge_vv_f32m4(v_default, v_result, mask);\n        \n        vse32_v_f32m4(&dst[i], v_final);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i]);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i]);\n        \n        vfloat32m1_t v_diff = vfredusum_vs_f32m1(v_src1, v_src2, v_src1);\n        vfloat32m1_t v_abs_diff = vfsqrt_v_f32m1(vfsub_vv_f32m1(v_src1, v_src2));\n        \n        vbool32_t mask = vmslt_vf_f32m1(v_abs_diff, 50.0f);\n        vbool32_t index_mask = vmseq_vx_i32m1(vsrl_vx_i32m1(vsetvl_e32m1(i), 1), 0);\n        \n        vbool32_t final_mask = vand_vv_b32(mask, index_mask);\n        \n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_src1, v_src2);\n        v_result = vrndup_v_f32m1(v_result);\n        \n        vfloat32m1_t v_default = vfmv_v_f_f32m1(-1.0f);\n        v_result = vmerge_vv_f32m1(v_default, v_result, final_mask);\n        \n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m4(length - i); // Set vector length\n        vfloat32m4_t v_src1 = vle32_v_f32m4(&src1[i]);\n        vfloat32m4_t v_src2 = vle32_v_f32m4(&src2[i]);\n        \n        vfloat32m4_t v_diff = vsub_vv_f32m4(v_src1, v_src2);\n        vfloat32m4_t v_abs_diff = vfredusum_vs_f32m4(vfsgnj_vf_f32m4(v_diff, v_f32m4(1.0)), v_f32m4(0.0), v_f32m4(0.0));\n        \n        vbool4_t mask = vmslt_vv_f32m4(v_abs_diff, v_f32m4(50.0));\n        vbool4_t index_mask = vmslt_vx_i32m4(vseql_v_i32m4(vsetvl_e32m4(i), 2), 0);\n        vbool4_t final_mask = vand_vv_b4(mask, index_mask);\n        \n        vfloat32m4_t v_result = vmul_vv_f32m4(v_src1, v_src2);\n        v_result = vrndup_v_f32m4(v_result);\n        \n        vfloat32m4_t v_default = vfmv_v_f_f32m4(-1.0);\n        vfloat32m4_t v_final_result = vmerge_vv_f32m4(v_default, v_result, final_mask);\n        \n        vse32_v_f32m4(&dst[i], v_final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += VLEN) {\n        vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i]);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i]);\n        \n        vfloat32m1_t v_diff = vfredusum_vs_f32m1(v_src1, v_src2, v_src1);\n        vfloat32m1_t v_abs_diff = vfmv_f_s_f32m1(v_abs_diff, 0);\n        \n        vbool32_t mask = vmslt_vv_f32m1(v_abs_diff, vfmv_f_s_f32m1(50.0f));\n        vbool32_t index_mask = vmslt_vv_i32m1(vsetvl_e32m1(i), vfmv_f_s_i32m1(2));\n        \n        vbool32_t final_mask = vand_vv_b32(mask, index_mask);\n        \n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_src1, v_src2);\n        v_result = vrndau_v_f32m1(v_result);\n        \n        vfloat32m1_t v_neg_one = vfmv_f_s_f32m1(-1.0f);\n        v_result = vmerge_vv_f32m1(v_result, v_neg_one, final_mask);\n        \n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t vec_scalar = vfmv_v_f_f64m1(scalar, vl);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > total_elements) {\n            current_vl = total_elements - i;\n        }\n        vfloat64m1_t vec_mat = vle64_v_f64m1(&mat[i], current_vl);\n        vfloat64m1_t vec_result = vfmul_vv_f64m1(vec_mat, vec_scalar, current_vl);\n        vse64_v_f64m1(&dst[i], vec_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_scalar = vfmv_v_f_f64m1(scalar, vl);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > total_elements) {\n            current_vl = total_elements - i;\n        }\n        \n        vfloat64m1_t v_mat = vle64_v_f64m1(&mat[i], current_vl);\n        vfloat64m1_t v_result = vfmul_vv_f64m1(v_mat, v_scalar, current_vl);\n        vse64_v_f64m1(&dst[i], v_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = vsetvl_e64(total_elements);\n    \n    vfloat64m1_t v_scalar = vfmv_v_f_f64m1(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat = vle64_v_f64m1(&mat[i]);\n        vfloat64m1_t v_result = vfmul_vv_f64m1(v_mat, v_scalar);\n        vse64_v_f64m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t vec_scalar = vfmv_v_f_f64m1(scalar, vl);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = (i + vl > total_elements) ? total_elements - i : vl;\n        vfloat64m1_t vec_mat = vle64_v_f64m1(&mat[i], current_vl);\n        vfloat64m1_t vec_dst = vfmul_vv_f64m1(vec_mat, vec_scalar, current_vl);\n        vse64_v_f64m1(&dst[i], vec_dst, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = vsetvl_e64(total_elements);\n\n    vfloat64m1_t v_scalar = vfmv_v_f_f64m1(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > total_elements) {\n            current_vl = total_elements - i;\n        }\n        \n        vfloat64m1_t v_mat = vle64_v_f64m1(&mat[i]);\n        vfloat64m1_t v_result = vfmul_vv_f64m1(v_mat, v_scalar);\n        vse64_v_f64m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum_squares = vfmv_v_f_f32m1(0.0f, 1);\n        size_t j = 0;\n\n        for (; j + 8 <= n; j += 8) {\n            vfloat32m8_t vec = vle32_v_f32m8(&mat[i * n + j]);\n            sum_squares = vfredusum_vs_f32m8_f32m1(sum_squares, vfmul_vv_f32m8(vec, vec, 1), sum_squares);\n        }\n\n        float norm = sqrt(vfmv_f_s_f32m1(sum_squares));\n\n        for (; j < n; j++) {\n            mat[i * n + j] /= norm;\n        }\n\n        // Normalize the vectorized part\n        j = 0;\n        for (; j + 8 <= n; j += 8) {\n            vfloat32m8_t vec = vle32_v_f32m8(&mat[i * n + j]);\n            vec = vfmul_vf_f32m8(vec, 1.0f / norm, 1);\n            vse32_v_f32m8(&mat[i * n + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t vec_sum = vfmv_v_f_f32m1(0.0f, vsetvl_e32m1(n));\n        vfloat32m1_t vec_row = vle32_v_f32m1(&mat[i * n], vsetvl_e32m1(n));\n\n        vec_sum = vfredusum_vs_f32m1(vec_sum, vec_row, vec_sum, vsetvl_e32m1(n));\n        float l2_norm = sqrt(vfmv_f_f32(vec_sum));\n\n        vec_row = vfmul_vf_f32m1(vec_row, 1.0f / l2_norm, vsetvl_e32m1(n));\n        vse32_v_f32m1(&mat[i * n], vec_row, vsetvl_e32m1(n));\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum_squares = vfmv_v_f_f32m1(0.0f, 1);\n        size_t j = 0;\n\n        for (; j + 8 <= n; j += 8) {\n            vfloat32m8_t vec = vle32_v_f32m8(&mat[i * n + j]);\n            sum_squares = vfredusum_vs_f32m8_f32m1(sum_squares, vfmul_vv_f32m8(vec, vec, 1), sum_squares);\n        }\n\n        float norm = sqrt(vfmv_f_s_f32(sum_squares));\n\n        for (; j < n; j++) {\n            mat[i * n + j] /= norm;\n        }\n\n        // Normalize the vectorized part\n        for (size_t k = 0; k < j; k += 8) {\n            vfloat32m8_t vec = vle32_v_f32m8(&mat[i * n + k]);\n            vec = vfmul_vf_f32m8(vec, 1.0f / norm, 1);\n            vse32_v_f32m8(&mat[i * n + k], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t row_offset = i * n;\n        vfloat32m1_t sum_squares = vfmv_v_f_f32m1(0.0f, n);\n        \n        for (size_t j = 0; j < n; j += VEC_LEN) {\n            vfloat32m1_t vec = vle32_v_f32m1(&mat[row_offset + j]);\n            sum_squares = vfredusum_vs_f32m1(sum_squares, vfmul_vv_f32m1(vec, vec, n), sum_squares);\n        }\n        \n        float norm = sqrt(vfmv_f_s_f32(sum_squares));\n        \n        for (size_t j = 0; j < n; j += VEC_LEN) {\n            vfloat32m1_t vec = vle32_v_f32m1(&mat[row_offset + j]);\n            vfloat32m1_t normalized_vec = vfmul_vf_f32m1(vec, 1.0f / norm, n);\n            vse32_v_f32m1(&mat[row_offset + j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum_squares = vfmv_v_f_f32m1(0.0f, n);\n        size_t j = 0;\n\n        for (; j + VEC_LEN <= n; j += VEC_LEN) {\n            vfloat32m1_t vec = vle32_v_f32m1(&mat[i * n + j]);\n            sum_squares = vfredusum_vs_f32m1(sum_squares, vfmul_vv_f32m1(vec, vec, n), sum_squares);\n        }\n\n        float norm = sqrt(vfmv_f_s_f32(sum_squares));\n\n        for (; j < n; j++) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t a = vle64_v_f64m1(&mat1[i * n + k]);\n                vfloat64m1_t b = vle64_v_f64m1(&mat2[k * p + j]);\n                sum = vfmacc_vv_f64m1(sum, a, b);\n            }\n            double result = vfmv_f_s_f64m1(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t k = 0; k < n; k += vsetvl_e64m1(n)) {\n                size_t vl = vsetvl_e64m1(n - k);\n                vfloat64m1_t a = vle64_v_f64m1(&mat1[i * n + k], vl);\n                vfloat64m1_t b = vle64_v_f64m1(&mat2[k * p + j], vl);\n                sum = vfmacc_vv_f64m1(sum, a, b);\n            }\n            double result;\n            vse64_v_f64m1(&result, sum, 1);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i * n + k]);\n                vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[k * p + j]);\n                sum = vfadd_vv_f64m1(sum, vfmul_vv_f64m1(v_mat1, v_mat2));\n            }\n            double result = vfmv_f_s_f64(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k]);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[k * p + j]);\n                sum = vfmacc_vv_f64m1(sum, vec1, vec2);\n            }\n            double result = vfmv_f_s_f64(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t k = 0; k < n; k += VEC_LEN) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k]);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[k * p + j]);\n                sum = vfmacc_vv_f64m1(sum, vec1, vec2);\n            }\n            double result = vfmv_f_s_f64(sum, 1);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32(0); // Vector length\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32(cols - j); // Update vector length for remaining elements\n            vfloat32m1_t v_src = vle32_v_f32m1(&src[i * cols + j], vl);\n            vfloat32m1_t v_dst = vfmul_vf_f32m1(v_src, 4.0f); // Scale to quarter\n            v_dst = vfround_vf_f32m1(v_dst); // Round to nearest integer\n            v_dst = vfmul_vf_f32m1(v_dst, 0.25f); // Scale back to quarter\n            vse32_v_f32m1(&dst[j * rows + i], v_dst, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32(0); // Vector length\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32(cols - j); // Update vector length for remaining elements\n            vfloat32m1_t src_vec = vle32_v_f32m1(&src[i * cols + j], vl);\n            vfloat32m1_t rounded_vec = vfmul_vf_f32m1(src_vec, 4.0f);\n            rounded_vec = vrndne_v_f32m1(rounded_vec);\n            rounded_vec = vfmul_vf_f32m1(rounded_vec, 0.25f);\n            vse32_v_f32m1(&dst[j * rows + i], rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32(0); // Vector length\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32(cols - j); // Update vector length for remaining elements\n            vfloat32m1_t src_vec = vle32_v_f32m1(&src[i * cols + j], vl);\n            vfloat32m1_t rounded_vec = vfmul_vf_f32m1(src_vec, 4.0f);\n            rounded_vec = vrndne_v_f32m1(rounded_vec);\n            rounded_vec = vfmul_vf_f32m1(rounded_vec, 0.25f);\n            vse32_v_f32m1(&dst[j * rows + i], rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vector_length = vsetvl_e32m4(0); // Set vector length for 32-bit floats\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vector_length) {\n            vfloat32m4_t vec = vle32_v_f32m4(&src[i * cols + j]);\n            vec = vfmul_vf_f32m4(vec, 4.0f); // Scale to nearest quarter\n            vec = vfround_vf_f32m4(vec, RVV_RND_NEAR); // Round to nearest\n            vec = vfmul_vf_f32m4(vec, 0.25f); // Scale back down\n            vse32_v_f32m4(&dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vec_len = vsetvl_e32m1(1);\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vec_len) {\n            vfloat32m1_t vec = vle32_v_f32m1(&src[i * cols + j]);\n            vfloat32m1_t rounded = vfmul_vf_f32m1(vec, 4.0f);\n            rounded = vrndne_v_f32m1(rounded);\n            rounded = vfmul_vf_f32m1(rounded, 0.25f);\n            vse32_v_f32m1(&dst[j * rows + i], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i]);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i]);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ);\n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i]);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i]);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ);\n        vse32_v_f32m1(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i); // Set vector length\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl); // Round towards zero\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n\n    vfloat32m1_t v_tensor1, v_tensor2, v_result;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > total_elements) {\n            current_vl = total_elements - i;\n        }\n\n        v_tensor1 = vle32_v_f32m1(&tensor1[i], current_vl);\n        v_tensor2 = vle32_v_f32m1(&tensor2[i], current_vl);\n        v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, current_vl);\n        \n        // Round towards zero\n        v_result = vrnd_zo_v_f32m1(v_result, current_vl);\n        \n        vse32_v_f32m1(&dst[i], v_result, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32(total_elements - i);\n        vfloat32m1_t v_tensor1 = vle32_v_f32m1(&tensor1[i], vl);\n        vfloat32m1_t v_tensor2 = vle32_v_f32m1(&tensor2[i], vl);\n        vfloat32m1_t v_result = vsub_vv_f32m1(v_tensor1, v_tensor2, vl);\n        v_result = vrnd_v_f32m1(v_result, RVV_RNDZ, vl);\n        vse32_v_f32m1(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i); // Set vector length\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]); // Load mat1\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]); // Load mat2\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2); // Element-wise multiplication\n        vse64_v_f64m1(&dst[i], v_dst); // Store result in dst\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i); // Set vector length\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i], vl);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i], vl);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2, vl);\n        vse64_v_f64m1(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2);\n        vse64_v_f64m1(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2);\n        vse64_v_f64m1(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64(total_elements - i);\n        vfloat64m1_t v_mat1 = vle64_v_f64m1(&mat1[i]);\n        vfloat64m1_t v_mat2 = vle64_v_f64m1(&mat2[i]);\n        vfloat64m1_t v_dst = vfmul_vv_f64m1(v_mat1, v_mat2);\n        vse64_v_f64m1(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f, 1); // Initialize sum to 0\n        for (size_t j = 0; j < n; j += VLEN) {\n            size_t vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t mat_vec = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t vec_vec = vle32_v_f32m1(&vec[j], vl);\n            sum = vfmacc_vv_f32m1(sum, mat_vec, vec_vec, vl); // Accumulate\n        }\n        dst[i] = vfmv_f_s_f32(sum, 1); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f, 1);\n        for (size_t j = 0; j < n; j += VEC_LEN) {\n            size_t vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t mat_vec = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t vec_vec = vle32_v_f32m1(&vec[j], vl);\n            sum = vfmacc_vv_f32m1(sum, mat_vec, vec_vec, vl);\n        }\n        dst[i] = vfmv_f_s_f32(sum, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f, 1);\n        for (size_t j = 0; j < n; j += VLEN / sizeof(float)) {\n            size_t vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t mat_vec = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t vec_vec = vle32_v_f32m1(&vec[j], vl);\n            sum = vfmacc_vv_f32m1(sum, mat_vec, vec_vec, vl);\n        }\n        dst[i] = vfmv_f_s_f32(sum, 1);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f, 1); // Initialize sum to 0\n        for (size_t j = 0; j < n; j += vsetvl_e32m1(n)) {\n            size_t vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t mat_vec = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t vec_vec = vle32_v_f32m1(&vec[j], vl);\n            sum = vfmacc_vv_f32m1(sum, mat_vec, vec_vec, vl); // Accumulate the products\n        }\n        dst[i] = vfmv_f_s_f32(sum, 1); // Store the result in dst\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f); // Initialize sum to zero\n        for (size_t j = 0; j < n; j += VLEN) {\n            size_t vl = (j + VLEN > n) ? (n - j) : VLEN; // Vector length\n            vfloat32m1_t mat_vec = vle32_v_f32m1(&mat[i * n + j], vl); // Load matrix row\n            vfloat32m1_t vec_vec = vle32_v_f32m1(&vec[j], vl); // Load vector\n            sum = vfmacc_vv_f32m1(sum, mat_vec, vec_vec); // Multiply and accumulate\n        }\n        dst[i] = vfmv_f_s_f32m1(sum); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_length = vsetvl_e64m1(total_elements);\n    \n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, vector_length);\n    \n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += vector_length) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t mat_vec = vle64_v_f64m1(&mat[i * n + j], vl);\n            sum_vec = vfredusum_vs_f64m1(sum_vec, mat_vec, sum_vec, vl);\n        }\n    }\n    \n    double sum[1];\n    vfmv_f_s_f64(sum, sum_vec, vector_length);\n    \n    return sum[0] / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_length = vsetvl_e64m1(total_elements);\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, vector_length);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += vector_length) {\n            size_t vl = n - j < vector_length ? n - j : vector_length;\n            vfloat64m1_t mat_vec = vle64_v_f64m1(&mat[i * n + j], vl);\n            sum_vec = vadd_vv_f64m1(sum_vec, mat_vec, vl);\n        }\n    }\n    \n    double sum[vector_length];\n    vse64_v_f64m1(sum, sum_vec, vector_length);\n    \n    double total_sum = 0.0;\n    for (size_t k = 0; k < vector_length; k++) {\n        total_sum += sum[k];\n    }\n    \n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_length = vsetvl_e64m1(total_elements);\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, vector_length);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += vector_length) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t vec = vle64_v_f64m1(&mat[i * n + j], vl);\n            sum_vec = vfadd_vv_f64m1(sum_vec, vec, vl);\n        }\n    }\n\n    double sum[vector_length];\n    vse64_v_f64m1(sum, sum_vec, vector_length);\n    \n    double total_sum = 0.0;\n    for (size_t i = 0; i < vector_length; i++) {\n        total_sum += sum[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_length = vsetvl_e64m1(total_elements);\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, vector_length);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += vector_length) {\n            size_t vl = n - j < vector_length ? n - j : vector_length;\n            vfloat64m1_t mat_vec = vle64_v_f64m1(&mat[i * n + j], vl);\n            sum_vec = vfredusum_vs_f64m1(sum_vec, mat_vec, sum_vec, vl);\n        }\n    }\n    \n    double sum[1];\n    vse64_v_f64m1(sum, sum_vec, vector_length);\n    return sum[0] / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vector_length = vsetvl_e64m1(total_elements);\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, vector_length);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += vector_length) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t vec = vle64_v_f64m1(&mat[i * n + j], vl);\n            sum_vec = vfredusum_vs_f64m1(sum_vec, vec, sum_vec, vl);\n        }\n    }\n    \n    double sum[1];\n    vse64_v_f64m1(sum, sum_vec, vector_length);\n    return sum[0] / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        vbool8_t sorted = vtrue_b8();\n        \n        for (size_t c = 0; c < cols - 1; c += 8) {\n            vint32m8_t v1 = vle32_v_i32m8(row + c);\n            vint32m8_t v2 = vle32_v_i32m8(row + c + 1);\n            vbool8_t cmp = vmslt_vv_i32m8(v1, v2);\n            if (!directions[r]) {\n                cmp = vmseq_vv_i32m8(v1, v2);\n            }\n            sorted = vand_vb8(sorted, cmp);\n        }\n        \n        if (vfirst_m_b8(sorted) == -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        vbool32_t sorted = vtrue_b32();\n        \n        for (size_t c = 0; c < cols - 1; c += 8) {\n            vint32m8_t v1 = vle32_v_i32m8(row + c);\n            vint32m8_t v2 = vle32_v_i32m8(row + c + 1);\n            vbool8_t cmp = vmslt_vv_i32m8(v1, v2);\n            vbool8_t cmp_desc = vmslt_vv_i32m8(v2, v1);\n            \n            if (directions[r]) {\n                sorted = vand_vb(sorted, cmp);\n            } else {\n                sorted = vand_vb(sorted, cmp_desc);\n            }\n        }\n        \n        if (vfirst_m_b(sorted) != -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        bool direction = directions[r];\n        size_t vl = vsetvl_e32(cols);\n        \n        vbool32_t sorted = vtrue_b32();\n        for (size_t c = 0; c < cols - 1; c += vl) {\n            vuint32m1_t v1 = vle32_v_u32m1(row + c);\n            vuint32m1_t v2 = vle32_v_u32m1(row + c + 1);\n            vbool32_t cmp = vmsltu_vv_u32m1(v1, v2);\n            if (!direction) {\n                cmp = vmseq_vv_u32m1(v1, v2);\n                sorted = vand_vb32(sorted, vnot_vb32(cmp));\n            } else {\n                sorted = vand_vb32(sorted, cmp);\n            }\n        }\n        \n        if (vfirst_m_b32(sorted) != -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        vbool32_t sorted = vmslt_vx_i32(vle32_v_i32(row), vle32_v_i32(row + 1), cols - 1);\n        vbool32_t result = vtrue_v_b32();\n\n        if (directions[r]) {\n            result = vmerge_vx_b32(result, sorted, vnot_v_b32(sorted));\n        } else {\n            result = vmerge_vx_b32(result, vnot_v_b32(sorted), sorted);\n        }\n\n        if (vredor_v_b32(result)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        vbool8_t sorted = vtrue_b8();\n        \n        for (size_t c = 0; c < cols - 1; c += 8) {\n            vuint32m8_t vec1 = vle32_v_u32m8(row + c);\n            vuint32m8_t vec2 = vle32_v_u32m8(row + c + 1);\n            vbool8_t cmp;\n\n            if (directions[r]) {\n                cmp = vmsltu_vv_u32m8(vec1, vec2);\n            } else {\n                cmp = vmsltu_vv_u32m8(vec2, vec1);\n            }\n\n            sorted = vand_vb8(sorted, cmp);\n        }\n\n        if (vfirst_m_b8(sorted) == -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vuint16m1_t v_base = vmv_v_x_u16m1(base, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_src = vle16_v_i16m1(&src[i], vl);\n        \n        vuint16m1_t v_div = vdiv_u16m1(v_src, v_base);\n        vuint16m1_t v_nearest = vmul_u16m1(v_div, v_base);\n        \n        vse16_v_i16m1(&dst[i], v_nearest, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16(length);\n    vuint16m1_t base_vec = vmv_v_x_u16m1(base, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t src_vec = vle16_v_u16m1(&src[i], vl);\n        \n        vuint16m1_t multiple = vdiv_u16m1(src_vec, base_vec);\n        multiple = vmul_u16m1(multiple, base_vec);\n        \n        vse16_v_u16m1(&dst[i], multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16(length);\n    vuint16m1_t v_base = vmv_v_x_u16m1(base, vl);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e16(length - i);\n        vint16m1_t v_src = vle16_v_i16m1(&src[i], vl);\n        \n        // Calculate the nearest multiple of base\n        vint16m1_t v_nearest = vdiv_vx_i16m1(v_src, base, vl);\n        v_nearest = vmul_vx_i16m1(v_nearest, base, vl);\n        \n        // Store the result\n        vse16_v_i16m1(&dst[i], v_nearest, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src = vle16_v_u16m1(&src[i], vl);\n        vuint16m1_t v_base = vmv_v_x_u16m1(base, vl);\n        \n        vuint16m1_t v_multiple = vdiv_u16m1(v_src, v_base);\n        v_multiple = vmul_u16m1(v_multiple, v_base);\n        \n        vse16_v_u16m1(&dst[i], v_multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t v_src = vle16_v_u16m1(&src[i], vl);\n        vuint16m1_t v_base = vmv_v_x_u16m1(base, vl);\n        \n        vuint16m1_t v_multiple = vdiv_u16m1(v_src, v_base);\n        v_multiple = vmul_u16m1(v_multiple, v_base);\n        \n        vse16_v_u16m1(&dst[i], v_multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vmslt_vv_f64m1(vle64_v_f64m1(matrix), vle64_v_f64m1(vector));\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t mat_row = vle64_v_f64m1(matrix + i * cols);\n        vfloat64m1_t vec = vle64_v_f64m1(vector);\n        vbool64_t match = vmfne_vv_f64m1(mat_row, vec);\n        if (vfirst_m_b64(match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vmslt_vv_f64m1(vle64_v_f64m1(matrix), vle64_v_f64m1(vector));\n    for (size_t i = 0; i < rows; i++) {\n        vdouble64m1_t mat_row = vle64_v_f64m1(&matrix[i * cols]);\n        vbool64_t cmp = vmfne_vv_f64m1(mat_row, vle64_v_f64m1(vector));\n        if (vfirst_m_b64(cmp) != -1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vmslt_vv_f64m1(vle64_v_f64m1(matrix), vle64_v_f64m1(vector));\n    for (size_t i = 0; i < rows; i++) {\n        vdouble64m1_t mat_row = vle64_v_f64m1(matrix + i * cols);\n        vbool64_t cmp = vmfne_vv_f64m1(mat_row, vle64_v_f64m1(vector));\n        if (vfirst_m_b64(cmp)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vundefined_b64();\n    for (size_t i = 0; i < rows; i++) {\n        vdouble64m1_t mat_row = vle64_v_f64m1(matrix + i * cols);\n        vdouble64m1_t vec = vle64_v_f64m1(vector);\n        vbool64_t cmp = vfmv_v_f_f64m1(mat_row, vec);\n        result = vorr_v_b64(result, cmp);\n    }\n    return vredmin_vs_i64m1(result, 0);\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    vbool64_t result = vmslt_vv_f64m1(vle64_v_f64m1(vector, 1), vle64_v_f64m1(matrix, 1));\n    \n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t mat_row = vle64_v_f64m1(matrix + i * cols, 1);\n        vbool64_t cmp_result = vmfne_vv_f64m1(mat_row, vle64_v_f64m1(vector, 1));\n        \n        if (vfirst_m_b64(cmp_result) == -1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t va, vb;\n    vbool1_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        va = vle8_v_u8m1(&A[i]);\n        vb = vle8_v_u8m1(&B[i]);\n        mask = vmseq_vv_u8m1(va, vb);\n        count += vpopc_m(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a;\n    vuint8m1_t vec_b;\n    vbool8_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(&A[i], current_vl);\n        vec_b = vle8_v_u8m1(&B[i], current_vl);\n        mask = vmseq_vv_u8m1(vec_a, vec_b, current_vl);\n        count += vpopc_m(mask, current_vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a;\n    vuint8m1_t vec_b;\n    vbool8_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(&A[i], current_vl);\n        vec_b = vle8_v_u8m1(&B[i], current_vl);\n        mask = vmseq_vv_u8m1(vec_a, vec_b, current_vl);\n        count += vpopc_m(mask, current_vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a;\n    vuint8m1_t vec_b;\n    vbool8_t mask;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(&A[i], current_vl);\n        vec_b = vle8_v_u8m1(&B[i], current_vl);\n        \n        mask = vmseq_vv_u8m1(vec_a, vec_b, current_vl);\n        count += vpopc_m(mask, current_vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vec_a;\n    vuint8m1_t vec_b;\n    vuint8m1_t vec_eq;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(&A[i]);\n        vec_b = vle8_v_u8m1(&B[i]);\n        vec_eq = vwmul_vv_u8m1(vec_a, vec_b);\n        \n        count += vpopc_u8m1(vec_eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    vtype *vx = (vtype *)x;\n    vtype *vy = (vtype *)y;\n    vtype va = vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vtype v_x = vle64_v_i64m1(&vx[i]);\n        vtype v_a = vmv_v_x_i64m1(a, vl);\n        vtype v_y = vabs_v_i64m1(v_x);\n        vtype v_result = vsub_vv_i64m1(v_a, v_y);\n        vse64_v_i64m1(&vy[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = vsetvl_e64(length);\n    vuint64m1_t vec_a = vmv_v_x_u64m1(a, vl);\n    vint64m1_t vec_x;\n    vint64m1_t vec_y;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e64(length - i);\n        vec_x = vle64_v_i64m1(&x[i], current_vl);\n        vec_y = vsub_vv_i64m1(vmul_vv_i64m1(vec_a, vec_x, current_vl), vec_x, current_vl);\n        vse64_v_i64m1(&y[i], vec_y, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    vtype *vx = vle64_v_i64(x, length);\n    vtype va = vmv_v_x_i64(a, length);\n    vtype vy = vabs_v_i64(vx, length);\n    vtype result = vsub_vv_i64(va, vy, length);\n    vse64_v_i64(y, result, length);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    vtype *vx = vle64_v_i64(x, length);\n    vtype va = vsetvl_e64m1(length);\n    vtype va_scalar = vmv_v_x_i64(va, a);\n    \n    vtype v_result = vwmul_vv_i64(vx, va_scalar, va);\n    vtype v_abs = vabs_v_i64(v_result, va);\n    \n    vse64_v_i64(y, v_abs, length);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    vtype *vx = vld_v_i64m1(x, length);\n    vtype va = vmv_v_x_i64m1(a);\n    vtype vy = vabs_v_i64m1(vx);\n    vtype result = vsub_vv_i64m1(va, vy);\n    vse_v_i64m1(y, result, length);\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vuint16m1_t max_val = vundefined_u16m1();\n    vuint16m1_t min_val = vundefined_u16m1();\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vuint16m1_t data = vle16_v_u16m1(&vec[i], vl);\n        \n        if (i == 0) {\n            max_val = data;\n            min_val = data;\n        } else {\n            max_val = vmaxu_vv_u16m1(max_val, data, vl);\n            min_val = vminu_vv_u16m1(min_val, data, vl);\n        }\n    }\n\n    MinMaxPair result;\n    result.max_num = vmv_x_s16m1(vmaxu_vv_u16m1(max_val, max_val, vl));\n    result.min_num = vmv_x_s16m1(vminu_vv_u16m1(min_val, min_val, vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vuint16m1_t max_val = vundefined_u16m1();\n    vuint16m1_t min_val = vundefined_u16m1();\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t data = vle16_v_i16m1(&vec[i], vl);\n        \n        if (i == 0) {\n            max_val = data;\n            min_val = data;\n        } else {\n            max_val = vmax_vv_u16m1(max_val, data, vl);\n            min_val = vmin_vv_u16m1(min_val, data, vl);\n        }\n    }\n\n    MinMaxPair result;\n    result.max_num = vmv_x_s_i16m1(vmax_vv_u16m1(max_val, vundefined_u16m1(), vl));\n    result.min_num = vmv_x_s_i16m1(vmin_vv_u16m1(min_val, vundefined_u16m1(), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    vtype<int16_t> v_min = vundefined<int16_t>();\n    vtype<int16_t> v_max = vundefined<int16_t>();\n    \n    size_t vl = vsetvl_e16(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vtype<int16_t> v_data = vle16_v_i16m1(&vec[i], vl);\n        v_min = vmin_vv_i16m1(v_min, v_data, vl);\n        v_max = vmax_vv_i16m1(v_max, v_data, vl);\n    }\n\n    MinMaxPair result;\n    result.min_num = vget_first_i16m1(v_min);\n    result.max_num = vget_first_i16m1(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vuint16m1_t max_val = vundefined_u16m1();\n    vuint16m1_t min_val = vundefined_u16m1();\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e16m1(length - i);\n        vint16m1_t data = vle16_v_i16m1(&vec[i], current_vl);\n        \n        if (i == 0) {\n            max_val = data;\n            min_val = data;\n        } else {\n            max_val = vmax_vv_u16m1(max_val, data, current_vl);\n            min_val = vmin_vv_u16m1(min_val, data, current_vl);\n        }\n    }\n\n    MinMaxPair result;\n    result.max_num = vget_first_i16m1(max_val);\n    result.min_num = vget_first_i16m1(min_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16(length);\n    vuint16m1_t max_val = vundefined_u16m1();\n    vuint16m1_t min_val = vundefined_u16m1();\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vint16m1_t data = vle16_v_i16m1(&vec[i], vl);\n        \n        if (i == 0) {\n            max_val = vsrl_vx_u16m1(data, 0);\n            min_val = vsrl_vx_u16m1(data, 0);\n        } else {\n            max_val = vmax_vv_u16m1(max_val, data);\n            min_val = vmin_vv_u16m1(min_val, data);\n        }\n    }\n\n    MinMaxPair result;\n    result.max_num = vmv_x_s_i16m1(vmax_vv_u16m1(max_val, max_val), 0);\n    result.min_num = vmv_x_s_i16m1(vmin_vv_u16m1(min_val, min_val), 0);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t vec_len = vsetvl_e32m1(cols - 1);\n        \n        for (size_t c = 0; c < cols - 1; c += vec_len) {\n            vuint32m1_t a = vle32_v_u32m1(row + c);\n            vuint32m1_t b = vle32_v_u32m1(row + c + 1);\n            vbool8_t cmp = vmsltu_vv_u32m1(a, b);\n            if (vmfirst_m_b8(cmp) == -1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t c = 0;\n\n        for (; c + VSET - 1 < cols; c += VSET) {\n            vuint32m1_t v1 = vle32_v_u32m1(row + c);\n            vuint32m1_t v2 = vle32_v_u32m1(row + c + 1);\n            vbool8_t cmp = vmsltu_vv_u32m1(v1, v2);\n            if (vmfirst_m_b8(cmp) == -1) return false;\n        }\n\n        for (; c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t vec_len = vsetvl_e32m1(cols - 1);\n        vbool32_t all_increasing = vmslt_vx_i32m1(vle32_v_i32m1(row + 1, vec_len), vle32_v_i32m1(row, vec_len));\n\n        if (vfirst_m_b32(all_increasing) != -1) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t vec_len = vsetvl_e32m1(cols - 1);\n        vbool32_t result = vmslt_vx_i32m1(vle32_v_i32m1(row + 1, vec_len), vle32_v_i32m1(row, vec_len));\n\n        if (vpopc(result) != vec_len) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j + VSET < cols; j += VSET) {\n            vuint32m1_t v1 = vle32_v_u32m1(row + j);\n            vuint32m1_t v2 = vle32_v_u32m1(row + j + 1);\n            vbool32_t cmp = vmsltu_vv_u32m1(v1, v2);\n            if (vmfirst_m_b32(cmp) == -1) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            const int* current_block = matrix + (i * block_size * cols + j * block_size);\n            vbool32_t equal = vmsne_vx_i32_b32(vle32_v_i32(current_block, block_elements), vle32_v_i32(first_block, block_elements), 0);\n            if (vfirst_m_b32(equal) != -1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            vbool32_t equal = vmslt_vx_i32_b32(vle32_v_i32(current_block), vle32_v_i32(first_block), block_size_squared);\n            if (vfirst_m_b32(equal) != -1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block to compare against\n    vuint32m1_t first_block = vle32_v_u32m1(matrix);\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            vuint32m1_t current_block_vec = vle32_v_u32m1(current_block);\n\n            // Compare the current block with the first block\n            vbool8_t comparison = vmseq_vv_u32m1(first_block, current_block_vec);\n            if (vmsne_vi_u32m1(comparison, block_elements) != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            vbool32_t equal = vmslt_vx_i32_b32(vle32_v_i32(current_block, block_size_squared), vle32_v_i32(first_block, block_size_squared));\n\n            if (vfirst_m_b32(equal) != -1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            vbool32_t equal = vmslt_vx_i32_b32(vle32_v_i32(current_block, block_size_squared), vle32_v_i32(first_block, block_size_squared));\n\n            if (vfirst_m_b32(equal) != -1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size);\n        vfloat64m1_t diff = vfredusum_vs_f64m1(first_block, current_block, 0.0);\n        vfloat64m1_t abs_diff = vfwredusum_vs_f64m1(vfsgnj_v_f64m1(current_block, first_block), diff, 0.0);\n        \n        if (vfirst_m_b64m1(vfsgt_v_f64m1(abs_diff, vfmv_v_f64m1_f64(tolerance))) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vbool64_t all_equal = vmslt_vf_f64(vle64_v_f64(vec), vle64_v_f64(vec), tolerance);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t block = vle64_v_f64(&vec[i * block_size]);\n        vfloat64m1_t first_block = vle64_v_f64(vec);\n        \n        vbool64_t equal = vmsle_vf_f64(first_block, block, tolerance);\n        all_equal = vand_vb(all_equal, equal);\n        \n        if (vfirst_m_b(all_equal)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size);\n        vfloat64m1_t diff = vfredusum_vs_f64m1_f64m1(vfsub_vv_f64m1(current_block, first_block), \n                                                       vfmv_v_f_f64m1(0.0), \n                                                       vsetvl_e64m1(block_size));\n        vfloat64m1_t abs_diff = vfabs_v_f64m1(diff);\n        vbool64_t mask = vmslt_vv_f64m1(abs_diff, vfmv_v_f_f64m1(tolerance));\n        \n        if (vpopc(mask) != block_size) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vbool64_t all_equal = vmslt_v_f64m1(vle64_v_f64m1(&vec[0]), vle64_v_f64m1(&vec[0]), tolerance);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t block = vle64_v_f64m1(&vec[i * block_size]);\n        vbool64_t equal = vmslt_v_f64m1(block, vle64_v_f64m1(&vec[0]), tolerance);\n        all_equal = vand_vb_i64m1(all_equal, equal);\n    }\n\n    return vfirst_m_b(all_equal) == -1;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size);\n        vfloat64m1_t diff = vsub_vv_f64m1(first_block, current_block);\n        vfloat64m1_t abs_diff = vfredusum_vs_f64m1_f64m1(vfsgnj_vv_f64m1(first_block, current_block), diff, 0);\n        \n        if (vfirst_m_b64m1(vle64_v_f64m1(vec + i * block_size), vmslt_vv_f64m1(abs_diff, vfmv_v_f_f64m1(tolerance)))) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t vec_sum = vfmv_v_f_f64m1(0.0, 1);\n        for (size_t j = 0; j < cols; j += VLEN) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_data = vle64_v_f64m1(&matrix[i * cols + j]);\n            vec_sum = vfredusum_vs_f64m1(vec_sum, vfmul_vv_f64m1(vec_data, vec_data, vl), vec_sum, vl);\n        }\n        double norm = sqrt(vfmv_f_s_f64m1(vec_sum, vl));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t vec_sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n        for (size_t j = 0; j < cols; j += VEC_LEN) {\n            vfloat64m1_t vec_data = vle64_v_f64m1(&matrix[i * cols + j]);\n            vec_sum = vfredusum_vs_f64m1(vec_data, vec_sum, vec_sum);\n        }\n        double norm = sqrt(vfmv_f_f64m1(vec_sum)); // Compute the square root of the sum\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, vl);\n        for (size_t j = 0; j < cols; j += vsetvl_e64m1(cols)) {\n            vfloat64m1_t vec = vle64_v_f64m1(&matrix[i * cols + j], vl);\n            sum = vfmacc_vv_f64m1(sum, vec, vec, vl);\n        }\n        double norm = sqrt(vfredusum_f64m1(sum, 0.0, vl));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t vec_sum = vfmv_v_f_f64m1(0.0, vl);\n        for (size_t j = 0; j < cols; j += VLEN) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_data = vle64_v_f64m1(&matrix[i * cols + j], vl);\n            vec_sum = vfredusum_vs_f64m1_f64m1(vec_sum, vfmul_vv_f64m1(vec_data, vec_data, vl), vec_sum, vl);\n        }\n        double norm = sqrt(vfmv_f_s_f64m1(vec_sum));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m1_t vec_sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n        for (size_t j = 0; j < cols; j += vsetvl_e64m1(cols)) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_data = vle64_v_f64m1(&matrix[i * cols + j]);\n            vec_sum = vfredusum_vs_f64m1(vec_sum, vfmul_vv_f64m1(vec_data, vec_data, vl), vec_sum, vl);\n        }\n        double norm = sqrt(vfmv_f_s_f64m1(vec_sum, vl));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl); // Load A\n        vuint32m1_t b_vec = vle32_v_u32m1(&B[i], vl); // Load B\n        vuint32m1_t c_vec = vor_vu32m1(a_vec, b_vec); // Element-wise OR\n        vse32_v_u32m1(&C[i], c_vec, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl); // Load A\n        vuint32m1_t vb = vle32_v_u32m1(&B[i], vl); // Load B\n        vuint32m1_t vc = vor_vv_u32m1(va, vb); // Bitwise OR\n        vse32_v_u32m1(&C[i], vc, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vuint32m1_t b_vec = vle32_v_u32m1(&B[i], vl);\n        vuint32m1_t c_vec = vor_vu32m1(a_vec, b_vec, vl);\n        vse32_v_u32m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl); // Load A\n        vuint32m1_t vb = vle32_v_u32m1(&B[i], vl); // Load B\n        vuint32m1_t vc = vor_vv_u32m1(va, vb); // Bitwise OR\n        vse32_v_u32m1(&C[i], vc, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl); // Load A\n        vuint32m1_t vb = vle32_v_u32m1(&B[i], vl); // Load B\n        vuint32m1_t vc = vor_vv_u32m1(va, vb); // Bitwise OR\n        vse32_v_u32m1(&C[i], vc, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i], vl);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i], vl);\n\n        vuint16m1_t a_squared = vmul_vv_u16m1(vreinterpret_vu8_u16m1(a_vec), vreinterpret_vu8_u16m1(a_vec), vl);\n        vuint16m1_t b_squared = vmul_vv_u16m1(vreinterpret_vu8_u16m1(b_vec), vreinterpret_vu8_u16m1(b_vec), vl);\n        vuint16m1_t product = vmul_vv_u16m1(a_vec, b_vec, vl);\n\n        sum_squares += vreduce_add_u16m1(a_squared, vl);\n        sum_squares += vreduce_add_u16m1(b_squared, vl);\n        sum_products += vreduce_add_u16m1(product, vl);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i], vl);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i], vl);\n\n        // Calculate squares and products\n        vuint16m1_t a_squared = vmul_vv_u16m1(a_vec, a_vec, vl);\n        vuint16m1_t products = vmul_vv_u16m1(a_vec, b_vec, vl);\n\n        // Sum the squares and products\n        sum_squares += vfredsum_vs_u16m1(a_squared, 0, vl);\n        sum_products += vfredsum_vs_u16m1(products, 0, vl);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t va = vle8_v_u8m1(&A[i], vl);\n        vuint8m1_t vb = vle8_v_u8m1(&B[i], vl);\n\n        vuint16m1_t va_squared = vmul_vv_u16m1(va, va, vl);\n        vuint16m1_t ab_product = vmul_vv_u16m1(va, vb, vl);\n\n        sum_squares += vreduce_add_u16m1(va_squared, vl);\n        sum_products += vreduce_add_u16m1(ab_product, vl);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i); // Set vector length\n\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n\n        // Compute squares and products\n        vuint16m1_t a_sq = vmul_vv_u16m1(vreinterpret_vu8_u16m1(a_vec), vreinterpret_vu8_u16m1(a_vec));\n        vuint16m1_t prod = vmul_vv_u16m1(vreinterpret_vu8_u16m1(a_vec), vreinterpret_vu8_u16m1(b_vec));\n\n        // Sum the squares and products\n        sum_squares += vreduce_add_u16m1(a_sq);\n        sum_products += vreduce_add_u16m1(prod);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i], vl);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i], vl);\n\n        // Compute squares and products\n        vuint16m1_t a_squared = vmul_vv_u16m1(a_vec, a_vec, vl);\n        vuint16m1_t products = vmul_vv_u16m1(a_vec, b_vec, vl);\n\n        // Sum the results\n        sum_squares += vfredsum_vs_u16m1_u64(a_squared, 0, vl);\n        sum_products += vfredsum_vs_u16m1_u64(products, 0, vl);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t a_vec = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t b_vec = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t b_neg_vec = vnot_v_u64m1(b_vec, vl);\n        vuint64m1_t c_vec = vand_vv_u64m1(a_vec, b_neg_vec, vl);\n        vse64_v_u64m1(&C[i], c_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vneg_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vneg_b, vl);\n        vse64_v_u64m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vneg_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vneg_b, vl);\n        vse64_v_u64m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i); // Set vector length\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl); // Load A\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl); // Load B\n        vuint64m1_t vb_neg = vnot_v_u64m1(vb, vl); // Bitwise negation of B\n        vuint64m1_t vc = vand_vv_u64m1(va, vb_neg, vl); // Element-wise AND\n        vse64_v_u64m1(&C[i], vc, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vneg_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vneg_b, vl);\n        vse64_v_u64m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n        \n        vbool8_t pos_mask = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t neg_mask = vmsltu_v_u8m1(b_vec, 0);\n        \n        vuint8m1_t c_vec = vdup_u8m1(0);\n        c_vec = vsel_v_u8m1(c_vec, pos_mask, vdup_u8m1(1));\n        c_vec = vsel_v_u8m1(c_vec, neg_mask, vdup_u8m1(255)); // -1 in 8-bit two's complement\n        \n        vse8_v_u8m1(&C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n        \n        vbool8_t pos_mask = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t neg_mask = vmsltu_v_u8m1(b_vec, 0);\n        \n        vuint8m1_t result = vdup_u8m1(0);\n        result = vsel_v_u8m1(pos_mask, vdup_u8m1(1), result);\n        result = vsel_v_u8m1(neg_mask, vdup_u8m1(-1), result);\n        \n        vse8_v_u8m1(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n        \n        vbool8_t a_pos = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t b_pos = vmsltu_v_u8m1(b_vec, 0);\n        \n        vbool8_t both_pos = vand_vb8(a_pos, b_pos);\n        vbool8_t both_neg = vand_vb8(vmsltu_v_u8m1(a_vec, 0), vmsltu_v_u8m1(b_vec, 0));\n        \n        vuint8m1_t result = vdup_v_u8m1(0);\n        result = vsel_v_u8m1(both_pos, vdup_v_u8m1(1), result);\n        result = vsel_v_u8m1(both_neg, vdup_v_u8m1(255), result); // -1 is represented as 255 in unsigned 8-bit\n        \n        vse8_v_u8m1(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = (length - i < vl) ? (length - i) : vl;\n\n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n\n        vbool8_t a_pos = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t b_pos = vmsltu_v_u8m1(b_vec, 0);\n\n        vuint8m1_t c_vec = vundefined_u8m1();\n        c_vec = vmerge_vxm_u8m1(a_pos, c_vec, vdup_u8m1(0));\n        c_vec = vmerge_vxm_u8m1(b_pos, c_vec, vdup_u8m1(0));\n\n        vbool8_t both_pos = vand_vv_bool8(a_pos, b_pos);\n        vbool8_t both_neg = vand_vv_bool8(vmsltu_v_u8m1(a_vec, 0), vmsltu_v_u8m1(b_vec, 0));\n\n        c_vec = vmerge_vxm_u8m1(both_pos, c_vec, vdup_u8m1(1));\n        c_vec = vmerge_vxm_u8m1(both_neg, c_vec, vdup_u8m1(255)); // -1 in 8-bit unsigned\n\n        vse8_v_u8m1(&C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl_actual = vsetvl_e8m1(length - i);\n        \n        vuint8m1_t a_vec = vle8_v_u8m1(&A[i]);\n        vuint8m1_t b_vec = vle8_v_u8m1(&B[i]);\n        \n        vbool8_t a_pos = vmsltu_v_u8m1(a_vec, 0);\n        vbool8_t b_pos = vmsltu_v_u8m1(b_vec, 0);\n        \n        vuint8m1_t c_vec = vdup_v_u8m1(0);\n        c_vec = vsel_v_u8m1(a_pos, b_pos, vdup_v_u8m1(1), c_vec);\n        c_vec = vsel_v_u8m1(vand_vb_u8m1(a_pos, b_pos), vdup_v_u8m1(-1), c_vec);\n        \n        vse8_v_u8m1(&C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16(length);\n\n    vuint16m1_t va, vb, vc;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += vl) {\n        size_t vl = vsetvl_e16(midpoint - i);\n        va = vle16_v_u16m1(&A[i]);\n        vb = vle16_v_u16m1(&B[i]);\n        vc = vxor_vv_u16m1(va, vb);\n        vse16_v_u16m1(&C[i], vc);\n    }\n\n    // Keep the midpoint value from A\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        size_t vl = vsetvl_e16(length - i);\n        va = vle16_v_u16m1(&A[i]);\n        vb = vle16_v_u16m1(&B[i]);\n        vc = vand_vv_u16m1(va, vb);\n        vse16_v_u16m1(&C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t vl = vsetvl_e16m1(mid);\n    \n    vuint16m1_t va, vb, vc_xor, vc_and;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < mid; i += vl) {\n        size_t vl_actual = vsetvl_e16m1(mid - i);\n        va = vle16_v_u16m1(&A[i]);\n        vb = vle16_v_u16m1(&B[i]);\n        vc_xor = vxor_vv_u16m1(va, vb);\n        vse16_v_u16m1(&C[i], vc_xor);\n    }\n\n    // Midpoint element\n    C[mid] = A[mid];\n\n    // Process elements after the midpoint\n    for (size_t i = mid + 1; i < length; i += vl) {\n        size_t vl_actual = vsetvl_e16m1(length - i);\n        va = vle16_v_u16m1(&A[i]);\n        vb = vle16_v_u16m1(&B[i]);\n        vc_and = vand_vv_u16m1(va, vb);\n        vse16_v_u16m1(&C[i], vc_and);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m1(midpoint);\n    \n    // Perform XOR for elements before the midpoint\n    vuint16m1_t va = vle16_v_u16m1(A, vl);\n    vuint16m1_t vb = vle16_v_u16m1(B, vl);\n    vuint16m1_t result_xor = vxor_vv_u16m1(va, vb);\n    vse16_v_u16m1(C, result_xor, vl);\n    \n    // Keep the value in A at the midpoint\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    } else {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Perform AND for elements after the midpoint\n    vl = vsetvl_e16m1(length - midpoint - 1);\n    va = vle16_v_u16m1(A + midpoint + 1, vl);\n    vb = vle16_v_u16m1(B + midpoint + 1, vl);\n    vuint16m1_t result_and = vand_vv_u16m1(va, vb);\n    vse16_v_u16m1(C + midpoint + 1, result_and, vl);\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    vuint16m1_t va, vb, vc;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += VEC_LEN) {\n        size_t vl = vsetvl_e16m1(VEC_LEN);\n        va = vle16_v_u16m1(&A[i], vl);\n        vb = vle16_v_u16m1(&B[i], vl);\n        vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n\n    // Process the midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += VEC_LEN) {\n        size_t vl = vsetvl_e16m1(VEC_LEN);\n        va = vle16_v_u16m1(&A[i], vl);\n        vb = vle16_v_u16m1(&B[i], vl);\n        vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16(length);\n\n    // Load vectors\n    vuint16m1_t va = vle16_v_u16m1(A, vl);\n    vuint16m1_t vb = vle16_v_u16m1(B, vl);\n\n    // Perform operations\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = vsetvl_e16(midpoint - i);\n        vuint16m1_t va_chunk = vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb_chunk = vle16_v_u16m1(B + i, vl);\n        vuint16m1_t result_xor = vxor_vv_u16m1(va_chunk, vb_chunk);\n        vse16_v_u16m1(C + i, result_xor, vl);\n    }\n\n    // Midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Perform AND operation for elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        vl = vsetvl_e16(length - i);\n        vuint16m1_t va_chunk = vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb_chunk = vle16_v_u16m1(B + i, vl);\n        vuint16m1_t result_and = vand_vv_u16m1(va_chunk, vb_chunk);\n        vse16_v_u16m1(C + i, result_and, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vbool32_t v_cond1 = vle32_v_b32(cond1 + i);\n        vbool32_t v_cond2 = vle32_v_b32(cond2 + i);\n        \n        vfloat32m1_t v_A = vle32_v_f32(A + i);\n        vfloat32m1_t v_B = vle32_v_f32(B + i);\n        vfloat32m1_t v_C = vle32_v_f32(C + i);\n        vfloat32m1_t v_D = vle32_v_f32(D + i);\n        \n        vfloat32m1_t v_out = vfmv_f_f32m1(0.0f); // Initialize output vector\n\n        v_out = vsel(v_cond1, v_cond2, v_A, v_B); // If cond1 true, select from A or B\n        v_out = vsel(v_cond1, v_cond2, v_out, v_C); // If cond1 false, select from C\n        v_out = vsel(v_cond1, v_cond2, v_out, v_D); // If both false, select from D\n\n        vse32_v_f32(out + i, v_out);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vbool32_t v_cond1 = vle32_v_b32(cond1 + i);\n        vbool32_t v_cond2 = vle32_v_b32(cond2 + i);\n        \n        vfloat32m1_t v_A = vle32_v_f32(A + i);\n        vfloat32m1_t v_B = vle32_v_f32(B + i);\n        vfloat32m1_t v_C = vle32_v_f32(C + i);\n        vfloat32m1_t v_D = vle32_v_f32(D + i);\n        \n        vfloat32m1_t v_out = vselect(v_cond1, v_A, v_B);\n        v_out = vselect(v_cond2, v_C, v_out);\n        v_out = vselect(vnot(v_cond1), v_D, v_out);\n        \n        vse32_v_f32(out + i, v_out);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vbool32_t v_cond1 = vle32_v_b32(cond1 + i);\n        vbool32_t v_cond2 = vle32_v_b32(cond2 + i);\n        \n        vfloat32m1_t v_A = vle32_v_f32(A + i);\n        vfloat32m1_t v_B = vle32_v_f32(B + i);\n        vfloat32m1_t v_C = vle32_v_f32(C + i);\n        vfloat32m1_t v_D = vle32_v_f32(D + i);\n        \n        vfloat32m1_t v_out = vfmv_v_f_f32m1(0.0f); // Initialize output\n        \n        v_out = vsel(v_cond1, v_cond2, v_A, v_out); // If cond1 and cond2 are true, select A\n        v_out = vsel(v_cond1, !v_cond2, v_B, v_out); // If cond1 is true and cond2 is false, select B\n        v_out = vsel(!v_cond1, v_cond2, v_C, v_out); // If cond1 is false and cond2 is true, select C\n        v_out = vsel(!v_cond1, !v_cond2, v_D, v_out); // If cond1 and cond2 are false, select D\n        \n        vse32_v_f32(out + i, v_out);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vbool32_t v_cond1 = vle32_v_b32(cond1 + i);\n        vbool32_t v_cond2 = vle32_v_b32(cond2 + i);\n        \n        vfloat32m1_t v_A = vle32_v_f32(A + i);\n        vfloat32m1_t v_B = vle32_v_f32(B + i);\n        vfloat32m1_t v_C = vle32_v_f32(C + i);\n        vfloat32m1_t v_D = vle32_v_f32(D + i);\n        \n        vfloat32m1_t v_out = vfmv_v_f_f32(0.0f); // Initialize output vector\n        \n        v_out = vsel(v_cond1, v_cond2, v_A, v_B); // Select A or B based on cond1 and cond2\n        v_out = vsel(v_cond1, v_out, v_C, v_D); // Select C or D based on cond1 and cond2\n        \n        vse32_v_f32(out + i, v_out);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vbool32_t cond1_vec = vle32_v_b32(cond1 + i);\n        vbool32_t cond2_vec = vle32_v_b32(cond2 + i);\n        \n        vfloat32m1_t A_vec = vle32_v_f32(A + i);\n        vfloat32m1_t B_vec = vle32_v_f32(B + i);\n        vfloat32m1_t C_vec = vle32_v_f32(C + i);\n        vfloat32m1_t D_vec = vle32_v_f32(D + i);\n        \n        vfloat32m1_t out_vec = vfmv_v_f_f32(0.0f); // Initialize output vector\n\n        // Select based on conditions\n        vfloat32m1_t selected_A = vfmv_v_f_f32(0.0f);\n        vfloat32m1_t selected_B = vfmv_v_f_f32(0.0f);\n        vfloat32m1_t selected_C = vfmv_v_f_f32(0.0f);\n        vfloat32m1_t selected_D = vfmv_v_f_f32(0.0f);\n\n        selected_A = vselect_vb_f32(cond1_vec, A_vec, selected_A);\n        selected_B = vselect_vb_f32(cond1_vec, B_vec, selected_B);\n        selected_C = vselect_vb_f32(cond2_vec, C_vec, selected_C);\n        selected_D = vselect_vb_f32(cond2_vec, D_vec, selected_D);\n\n        out_vec = vmerge_vb_f32(cond1_vec, selected_A, selected_B);\n        out_vec = vmerge_vb_f32(cond2_vec, selected_C, out_vec);\n        out_vec = vmerge_vb_f32(vnot_vb(cond1_vec), selected_D, out_vec);\n\n        vse32_v_f32(out + i, out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t count_vec = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t bit = 0; bit < 32; ++bit) {\n            vuint32m1_t mask = vmv_v_x_u32m1(1u << bit, vl);\n            vuint32m1_t bit_set = vand_vv_u32m1(a_vec, mask);\n            vuint32m1_t is_set = vmsne_vv_u32m1(bit_set, vmv_v_x_u32m1(0, vl));\n            count_vec = vadd_vv_i32m1(count_vec, is_set);\n        }\n\n        vse8_v_u8(&out[i], vmv_x_s_u8(count_vec, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t count = vredsum_vs_u32m1_i32m1(va, 0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            uint32_t value = vextract_u32m1(count, j);\n            out[i + j] = __builtin_popcount(value);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t count_vec = vcreate_vint32m1(0);\n\n        for (int j = 0; j < 32; j++) {\n            count_vec = vadd_vx_i32m1(count_vec, vsrl_vx_u32m1(a_vec, j, vl), vl);\n        }\n\n        vuint8m1_t out_vec = vmv_v_x_u8m1(0, vl);\n        out_vec = vadd_vx_u8m1(out_vec, vpopc_v_u32m1(count_vec, vl), vl);\n        \n        vse8_v_u8m1(&out[i], out_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t count = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t bit = 0; bit < 32; ++bit) {\n            vuint32m1_t mask = vmv_v_x_u32m1(1 << bit, vl);\n            vuint32m1_t result = vand_vv_u32m1(va, mask);\n            count = vadd_vv_i32m1(count, vmsne_vi_u32m1(result, 0, vl));\n        }\n        \n        vse8_v_u8(&out[i], (vuint8m1_t)count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = vsetvl_e32(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t count_vec = vcreate_vint32m1(0);\n        \n        for (size_t bit = 0; bit < 32; ++bit) {\n            vint32m1_t mask = vslidedown_vx_u32m1(vcreate_vuint32m1(1), bit);\n            count_vec = vadd_vv_i32m1(count_vec, vand_vv_u32m1(a_vec, mask));\n        }\n        \n        vuint8m1_t out_vec = vmv_v_x_u8m1(0);\n        for (size_t j = 0; j < vl; ++j) {\n            out_vec = vinsert_vx_u8m1(out_vec, __builtin_popcount(A[i + j]), j);\n        }\n        \n        vse8_v_u8m1(&out[i], out_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vbool32_t mask = vmul_vv_u32m1(a_vec, vundefined_u32m1(), vl);\n        mask = vmsltu_vx_u32m1(mask, 3, vl);\n        \n        vint32m1_t abs_vec = vabs_v_i32m1(a_vec, vl);\n        vse32_v_i32m1(&B[i], vmerge_vx_i32m1(mask, abs_vec, a_vec, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vuint32m1_t condition = vremu_vv_u32m1(a_vec, vsetvl_e32(3), vl);\n        vuint32m1_t abs_vec = vabs_v_u32m1(a_vec, vl);\n        vuint32m1_t result = vmerge_vv_u32m1(a_vec, abs_vec, vmsltu_vv_u32m1(condition, vsetvl_e32(0), vl), vl);\n        vse32_v_u32m1(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t vl = vsetvl_e32(size);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vbool32_t mask = vmul_vv_u32m1(a_vec, vundefined_u32m1(), vl);\n        mask = vmsltu_vx_u32m1(a_vec, 0, vl); // Create mask for negative values\n        vuint32m1_t abs_vec = vabs_v_u32m1(a_vec, vl);\n        \n        vuint32m1_t result_vec = vmerge_vx_u32m1(a_vec, abs_vec, mask, vl);\n        vse32_v_u32m1(&B[i], result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vbool32_t mask = vmul_vx_u32m1(a_vec, 1) % 3 == 0;\n\n        vint32m1_t abs_vec = vabs_v_i32m1(a_vec);\n        vse32_v_i32m1(&B[i], vmerge_vx_i32m1(mask, a_vec, abs_vec, vl));\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl = vsetvl_e32(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vuint32m1_t a_vec = vle32_v_u32m1(&A[i], vl);\n        vbool32_t mask = vmul_vx_u32m1(a_vec, 1) % 3 == 0;\n\n        vint32m1_t abs_vec = vabs_v_i32m1(a_vec);\n        vse32_v_i32m1(&B[i], vmerge_vx_i32m1(mask, a_vec, abs_vec));\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    vuint32m1_t src_vec;\n    vuint32m1_t dst_vec;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t negated_src;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n\n        src_vec = vle32_v_u32m1(&src[i], current_length);\n        negated_src = vnot_v_u32m1(src_vec, current_length);\n\n        mask = vandi_vx_u32m1(mask, src_vec, 0x0F, current_length);\n        vbool32_t condition = vmseq_vx_u32m1(mask, 0x0F, current_length);\n\n        dst_vec = vslid_vx_u32m1(src_vec, rotate_bits, current_length);\n        dst_vec = vmerge_vx_u32m1(dst_vec, negated_src, condition, current_length);\n\n        vse32_v_u32m1(&dst[i], dst_vec, current_length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    vuint32m1_t src_vec, dst_vec;\n    vuint32m1_t mask = vmv_v_x_u32m1(0x0F); // Mask for low 4 bits\n    vuint32m1_t all_ones = vmv_v_x_u32m1(0x0F); // All low 4 bits set to 1\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n\n        src_vec = vle32_v_u32m1(&src[i]);\n        vuint32m1_t low_bits = vand_vu32m1(src_vec, mask);\n        vbool32_t condition = vmseq_vv_u32m1(low_bits, all_ones);\n\n        // Rotate right by rotate_bits\n        vuint32m1_t rotated = vshf_vv_u32m1(src_vec, src_vec, vundefined_u32m1());\n        rotated = vshf_vv_u32m1(rotated, rotated, vundefined_u32m1());\n\n        // Apply the condition\n        dst_vec = vbsl_vv_u32m1(condition, rotated, vnot_v_u32m1(src_vec));\n\n        vse32_v_u32m1(&dst[i], dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t src_vec, dst_vec;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        src_vec = vle32_v_u32m1(&src[i], vl);\n        \n        vuint32m1_t mask = vslidedown_u32m1(src_vec, 4);\n        vuint32m1_t condition = vmsltu_u32m1(mask, vundefined_u32m1());\n        \n        vuint32m1_t rotated = vshf_u32m1(src_vec, vslide1down_u32m1(src_vec, rotate_bits), rotate_bits);\n        dst_vec = vmerge_vx_u32m1(src_vec, rotated, condition);\n        \n        vse32_v_u32m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = vsetvl_e32(length);\n    vuint32m1_t src_vec;\n    vuint32m1_t dst_vec;\n    vuint32m1_t mask = vundefined_u32m1();\n    vuint32m1_t rotated;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        src_vec = vle32_v_u32m1(&src[i], vl);\n        \n        // Create a mask for the condition (low 4 bits are all 1)\n        vuint32m1_t condition_mask = vand_vx_u32m1(src_vec, 0xF);\n        vbool32_t condition = vmseq_vx_u32m1(condition_mask, 0xF);\n        \n        // Perform rotation\n        rotated = vshl_vx_u32m1(src_vec, rotate_bits);\n        vuint32m1_t rotated_low = vshr_vx_u32m1(src_vec, 32 - rotate_bits);\n        rotated = vorr_vv_u32m1(rotated, rotated_low);\n        \n        // Negate src_vec\n        vuint32m1_t negated = vnot_v_u32m1(src_vec);\n        \n        // Select based on condition\n        dst_vec = vbselect_vx_u32m1(condition, rotated, negated);\n        \n        // Store result\n        vse32_v_u32m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    vuint32m1_t v_src;\n    vuint32m1_t v_dst;\n    vuint32m1_t v_mask = vundefined_u32m1();\n    vuint32m1_t v_negate;\n\n    size_t vl;\n    for (size_t i = 0; i < length; i += VSET) {\n        vl = vsetvl_e32m1(length - i);\n        v_src = vle32_v_u32m1(&src[i], vl);\n        \n        v_mask = vandi_vx_u32m1(v_mask, v_src, 0xF);\n        v_negate = vnot_v_u32m1(v_src);\n        \n        v_dst = vrotate_right_vx_u32m1(v_src, rotate_bits);\n        v_dst = vbsl_v_u32m1(v_mask, v_dst, v_negate);\n        \n        vse32_v_u32m1(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        \n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        vdiff = vsub_vv_f32m1(va, vb, vl);\n        \n        vfloat32m1_t vepsilon = vfmv_v_f_f32m1(epsilon, vl);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vl);\n        \n        vout = vundefined_i8m1();\n        vout = vmerge_vx_i8m1(vout, vadd_vi8m1(vgt_vv_f32m1(vdiff, vepsilon, vl), 1), vl);\n        vout = vmerge_vx_i8m1(vout, vadd_vi8m1(vlt_vv_f32m1(vdiff, vneg_v_f32m1(vepsilon, vl), vl), -1), vl);\n        vout = vmerge_vx_i8m1(vout, vadd_vi8m1(vle_vv_f32m1(vabs_diff, vepsilon, vl), 0), vl);\n        \n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        vdiff = vsub_vv_f32m1(va, vb, vl);\n\n        vfloat32m1_t vabs_epsilon = vfmv_v_f_f32m1(fabsf(epsilon), vl);\n        vfloat32m1_t vabs_diff = vfmv_v_f_f32m1(0.0f, vl);\n        vabs_diff = vfredmax_vs_f32m1(vabs_diff, vdiff, vabs_diff, vl);\n        \n        vout = vmv_v_x_i8m1(0, vl);\n        vout = vmerge_vx_i8m1(vout, vmv_v_x_i8m1(1, vl), vgt_vv_f32m1(vdiff, vabs_epsilon, vl));\n        vout = vmerge_vx_i8m1(vout, vmv_v_x_i8m1(-1, vl), vlt_vv_f32m1(vdiff, vneg_v_f32m1(vabs_epsilon, vl), vl));\n\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    float abs_epsilon = (epsilon < 0) ? -epsilon : epsilon;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl_actual = vsetvl_e32m1(length - i);\n        \n        va = vle32_v_f32m1(&A[i], vl_actual);\n        vb = vle32_v_f32m1(&B[i], vl_actual);\n        vdiff = vsub_vv_f32m1(va, vb, vl_actual);\n\n        vfloat32m1_t vabs_diff = vfredusum_vs_f32m1(vdiff, vfmv_v_f32m1(0.0f, vl_actual), vl_actual);\n        vfloat32m1_t vabs_epsilon = vfmv_v_f32m1(abs_epsilon, vl_actual);\n        \n        vout = vmslt_vv_f32m1(vabs_diff, vabs_epsilon, vl_actual);\n        vout = vadd_vv_i8m1(vout, vmsgt_vv_f32m1(vdiff, vfmv_v_f32m1(0.0f, vl_actual), vl_actual), vl_actual);\n        vout = vadd_vv_i8m1(vout, vmslt_vv_f32m1(vdiff, vfmv_v_f32m1(0.0f, vl_actual), vl_actual), vl_actual);\n        \n        vse8_v_i8m1(&out[i], vout, vl_actual);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        vdiff = vsub_vv_f32m1(va, vb, vl);\n        \n        vfloat32m1_t vepsilon = vfmv_v_f_f32m1(epsilon, vl);\n        vfloat32m1_t vabs_diff = vfmv_v_f_f32m1(0.0f, vl);\n        \n        vabs_diff = vfredusum_vs_f32m1(vabs_diff, vabs_v_f32m1(vdiff, vl), vl);\n        \n        vout = vundefined_i8m1();\n        vout = vmerge_vx_i8m1(vout, vadd_vx_i8m1(vle8_v_i8m1(out, vl), 1, vl), vsgt_vv_f32m1(vdiff, vepsilon, vl));\n        vout = vmerge_vx_i8m1(vout, vadd_vx_i8m1(vle8_v_i8m1(out, vl), -1, vl), vslti_vv_f32m1(vdiff, vneg_v_f32m1(vepsilon, vl), vl));\n        vout = vmerge_vx_i8m1(vout, vadd_vx_i8m1(vle8_v_i8m1(out, vl), 0, vl), vle_v_f32m1(vabs_diff, vepsilon, vl));\n        \n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t va, vb, vdiff;\n    vint8m1_t vout;\n\n    float abs_epsilon = (epsilon < 0) ? -epsilon : epsilon;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        vdiff = vsub_vv_f32m1(va, vb, vl);\n\n        vfloat32m1_t vabs_diff = vfredusum_vs_f32m1(vdiff, vfmv_f_s_f32m1(0, vl), vl);\n        vfloat32m1_t vabs_epsilon = vfmv_f_s_f32m1(abs_epsilon, vl);\n\n        vout = vmslt_vv_f32m1(vabs_diff, vabs_epsilon, vl);\n        vout = vadd_vv_i8m1(vout, vmsgt_vv_f32m1(vdiff, vabs_epsilon, vl), vl);\n        vout = vadd_vv_i8m1(vout, vmslt_vv_f32m1(vdiff, vneg_v_f32m1(vabs_epsilon, vl), vl), vl);\n\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]); // Load float values\n        vint32m1_t vb = vfcvt_x_f_v_i32m1(va); // Convert to int32_t\n        \n        // Create masks for saturation\n        vint32m1_t max_val = vmv_v_x_i32m1(INT32_MAX);\n        vint32m1_t min_val = vmv_v_x_i32m1(INT32_MIN);\n        \n        // Apply saturation\n        vb = vmin_vv_i32m1(vb, max_val); // Saturate to INT32_MAX\n        vb = vmax_vv_i32m1(vb, min_val); // Saturate to INT32_MIN\n        \n        vse32_v_i32m1(&B[i], vb); // Store results\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t vb = vfcvt_x_f_v_i32m1(va, vl);\n        \n        vint32m1_t vmax = vmv_v_x_i32m1(INT32_MAX, vl);\n        vint32m1_t vmin = vmv_v_x_i32m1(INT32_MIN, vl);\n        \n        vb = vmin(vmax(vb, vmin), vmax);\n        \n        vse32_v_i32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]);\n        vint32m1_t vb = vfcvt_s32_f32m1(va);\n        \n        // Saturate values\n        vint32m1_t vmin = vmv_v_x_i32m1(INT32_MIN);\n        vint32m1_t vmax = vmv_v_x_i32m1(INT32_MAX);\n        vb = vmin(vb, vmax);\n        \n        vse32_v_i32m1(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]); // Load float values\n        vint32m1_t vb = vfcvt_rzi_v_f32m1(va); // Convert to int32_t with rounding\n        \n        // Create masks for saturation\n        vint32m1_t max_val = vmv_v_x_i32m1(INT32_MAX);\n        vint32m1_t min_val = vmv_v_x_i32m1(INT32_MIN);\n        \n        // Apply saturation\n        vb = vmin_vv_i32m1(vb, max_val); // Saturate to INT32_MAX\n        vb = vmax_vv_i32m1(vb, min_val); // Saturate to INT32_MIN\n        \n        vse32_v_i32m1(&B[i], vb); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]); // Load float vector\n        vint32m1_t vb = vfcvt_rzi_v_f32m1(va); // Convert to int32_t with rounding\n\n        // Create masks for saturation\n        vint32m1_t max_val = vmv_v_x_i32m1(INT32_MAX);\n        vint32m1_t min_val = vmv_v_x_i32m1(INT32_MIN);\n        \n        // Apply saturation\n        vb = vmin_vv_i32m1(vb, max_val); // Saturate to INT32_MAX\n        vb = vmax_vv_i32m1(vb, min_val); // Saturate to INT32_MIN\n        \n        vse32_v_i32m1(&B[i], vb); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load int32_t values\n        vfloat32m1_t vb = vcvt_f_f32_u32m1(va); // Convert to float\n        vb = vfadd_vf_f32m1(vb, (float)scale); // Scale the values\n        vse32_v_f32m1(&B[i], vb); // Store the results\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t va_signed = (vint32m1_t)va;\n        vfloat32m1_t vb = vcvt_f_f32_v_i32m1(va_signed);\n        vb = vfadd_vf_f32m1(vb, (float)scale, vl);\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load int32_t values\n        vfloat32m1_t vb = vfcvt_f_fm1_v_u32m1(va); // Convert to float\n        vb = vfadd_vf_f32m1(vb, (float)scale); // Scale the values\n        vse32_v_f32m1(&B[i], vb); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load int32_t values\n        vfloat32m1_t vb = vfcvt_f_fm1_u32m1(va); // Convert to float\n        vb = vfadd_vf_f32m1(vb, (float)scale); // Scale the values\n        vse32_v_f32m1(&B[i], vb); // Store the results\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load int32_t values\n        vfloat32m1_t vb = vcvt_f32_u32m1(va); // Convert to float\n        vb = vfadd_vf_f32m1(vb, (float)scale); // Scale the values\n        vse32_v_f32m1(&B[i], vb); // Store the results\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t a_vec = vle32_v_f32m1(&A[i], vl);\n        vfloat32m1_t b_vec = vle32_v_f32m1(&B[i], vl);\n        vfloat32m1_t result_vec = vdiv_vv_f32m1(a_vec, b_vec, vl);\n        vint32m1_t rounded_vec = vrndne_v_f32m1(result_vec, vl);\n        vse32_v_i32m1(&C[i], rounded_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], vl);\n        vfloat32m1_t vb = vle32_v_f32m1(&B[i], vl);\n        vfloat32m1_t vresult = vdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vrounded = vrndne_v_f32m1(vresult, vl);\n        vse32_v_i32m1(&C[i], vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t a_vec = vle32_v_f32m1(&A[i], vl); // Load A\n        vfloat32m1_t b_vec = vle32_v_f32m1(&B[i], vl); // Load B\n        vfloat32m1_t result_vec = vdiv_vv_f32m1(a_vec, b_vec, vl); // Element-wise division\n        vint32m1_t rounded_vec = vrndne_v_f32m1(result_vec, vl); // Round to nearest integer\n        vse32_v_i32m1(&C[i], rounded_vec, vl); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]); // Load A\n        vfloat32m1_t vb = vle32_v_f32m1(&B[i]); // Load B\n        vfloat32m1_t vresult = vdiv_vv_f32m1(va, vb); // Element-wise division\n        vint32m1_t vrounded = vrndne_v_f32m1(vresult); // Round to nearest integer\n        vse32_v_i32m1(&C[i], vrounded); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vfloat32m1_t va = vle32_v_f32m1(&A[i]); // Load A\n        vfloat32m1_t vb = vle32_v_f32m1(&B[i]); // Load B\n        vfloat32m1_t vdiv = vfmul_vf_f32m1(vfdiv_vv_f32m1(va, vb), 1.0f); // Element-wise division\n        vint32m1_t vround = vfcvt_rtn_v_f32m1(vdiv); // Round to nearest integer\n        vse32_v_i32m1(&C[i], vround); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i); // Set vector length based on remaining elements\n        vfloat64m1_t v_a = vle64_v_f64m1(&A[i], vl);\n        vfloat32m1_t v_b = vfcvt_f_f_v_f64m1(v_a, vl);\n        \n        // Saturate values\n        vfloat32m1_t v_max = vfmv_v_f_f32m1(max_float, vl);\n        vfloat32m1_t v_min = vfmv_v_f_f32m1(min_float, vl);\n        \n        v_b = vmin_vv_f32m1(v_b, v_max, vl);\n        v_b = vmax_vv_f32m1(v_b, v_min, vl);\n        \n        vse32_v_f32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i); // Set vector length based on remaining elements\n        vfloat64m1_t va = vle64_v_f64m1(&A[i], vl);\n        vfloat32m1_t vb = vfcvt_f32_f64_v_f64m1(va, vl);\n\n        // Create masks for saturation\n        vbool1_t mask_max = vmslt_v_f32m1(vb, max_float);\n        vbool1_t mask_min = vmsgt_v_f32m1(vb, min_float);\n\n        // Apply saturation\n        vb = vmerge_vx_f32m1(vb, vfmv_v_f_f32m1(max_float, vl), mask_max);\n        vb = vmerge_vx_f32m1(vb, vfmv_v_f_f32m1(min_float, vl), mask_min);\n\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i); // Set vector length\n        vfloat64m1_t v_a = vle64_v_f64m1(&A[i], vl); // Load double values\n        vfloat32m1_t v_b = vfcvt_f_f_v_f64m1(v_a, vl); // Convert to float\n\n        // Saturate values\n        vfloat32m1_t v_max = vfmv_v_f_f32m1(max_float, vl);\n        vfloat32m1_t v_min = vfmv_v_f_f32m1(min_float, vl);\n        v_b = vmin_vv_f32m1(v_b, v_max, vl); // Apply max saturation\n        v_b = vmax_vv_f32m1(v_b, v_min, vl); // Apply min saturation\n\n        vse32_v_f32m1(&B[i], v_b, vl); // Store results\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i); // Set vector length\n\n        vfloat64m1_t va = vle64_v_f64m1(&A[i], vl); // Load double values\n        vfloat32m1_t vb = vfcvt_f_f32_v_f64m1(va, vl); // Convert to float\n\n        // Saturate values\n        vfloat32m1_t v_max = vfmv_v_f_f32m1(max_float, vl);\n        vfloat32m1_t v_min = vfmv_v_f_f32m1(min_float, vl);\n        \n        vb = vmin_vv_f32m1(vb, v_max, vl); // Apply upper saturation\n        vb = vmax_vv_f32m1(vb, v_min, vl); // Apply lower saturation\n\n        vse32_v_f32m1(&B[i], vb, vl); // Store results\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const float max_float = FLT_MAX;\n    const float min_float = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i); // Set vector length based on remaining elements\n        vfloat64m1_t v_a = vle64_v_f64m1(&A[i], vl);\n        vfloat32m1_t v_b = vfcvt_f_f_v_f64m1(v_a, vl);\n        \n        // Saturate values\n        vfloat32m1_t v_max = vfmv_v_f_f32m1(max_float, vl);\n        vfloat32m1_t v_min = vfmv_v_f_f32m1(min_float, vl);\n        \n        v_b = vmin_v_f32m1(v_b, v_max, vl);\n        v_b = vmax_v_f32m1(v_b, v_min, vl);\n        \n        vse32_v_f32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i);\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl);\n        vint32m1_t v_b = vmv_v_x_i32m1(0);\n        v_b = vnsra_w_u16m1(v_a, 0);\n        vse32_v_i32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i);\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl);\n        vint32m1_t v_b = vmv_v_x_i32m1(0);\n        v_b = vwadd_vx_i32m1(v_b, v_a, 0, vl);\n        vse32_v_i32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32(size - i); // Set vector length\n        vuint16m1_t a_vec = vle16_v_u16m1(&A[i], vl); // Load 16-bit integers\n        vint32m1_t b_vec = vmv_v_x_i32m1(0); // Initialize destination vector\n        b_vec = vnsra_w_u16m1(b_vec, a_vec, 0); // Convert to 32-bit integers\n        vse32_v_i32m1(&B[i], b_vec, vl); // Store results\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i);\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl);\n        vint32m1_t v_b = vmv_v_x_i32m1(0);\n        v_b = vwadd_vx_i32m1(v_b, (vint32m1_t)v_a, 0);\n        vse32_v_i32m1(&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16(size - i); // Set vector length based on remaining elements\n        vuint16m1_t v_a = vle16_v_u16m1(&A[i], vl); // Load int16_t values\n        vint32m1_t v_b = vmv_v_x_i32m1(0); // Initialize int32_t vector\n        v_b = vnsra_vx_i32m1(v_b, v_a, 0); // Convert to int32_t\n        vse32_v_i32m1(&B[i], v_b, vl); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vmin_val = vfmv_v_f_f32m1(min_val, 1), vmax_val = vfmv_v_f_f32m1(max_val, 1);\n    vint32m1_t vcontrol;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        va = vle32_v_f32m1(&A[i]);\n        vcontrol = vle32_v_i32m1(&control[i]);\n\n        vint32m1_t mask = vmslt_v_i32m1(vcontrol, vmv_v_x_i32m1(0, vl));\n        vfloat32m1_t normalized = vfmul_vf_f32m1(vfsub_vv_f32m1(va, vmin_val), vfmv_v_f_f32m1(1.0f / (max_val - min_val), vl));\n\n        normalized = vfmax_vf_f32m1(normalized, 0.0f, vl);\n        normalized = vfmin_vf_f32m1(normalized, 1.0f, vl);\n\n        vfloat32m1_t result = vmerge_vv_f32m1(vreinterpret_v_i32m1_f32m1(vcontrol), normalized, mask);\n        \n        vse32_v_f32m1(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float inv_range = 1.0f / (max_val - min_val);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32(size - i);\n        \n        vfloat32m1_t A_vec = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t control_vec = vle32_v_i32m1(&control[i], vl);\n        \n        vfloat32m1_t normalized = vfmul_vf_f32m1(vfsub_vf_f32m1(A_vec, min_val, vl), inv_range, vl);\n        vfloat32m1_t result = vfmv_v_f_f32m1(0.0f, vl);\n        \n        result = vmin_vf_f32m1(result, normalized, vl);\n        result = vmax_vf_f32m1(result, 1.0f, vl);\n        \n        vfloat32m1_t B_vec = vselect_v_i32m1(control_vec, result, A_vec, vl);\n        \n        vse32_v_f32m1(&B[i], B_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vmin_val = vfmv_v_f_f32(min_val, 1), vmax_val = vfmv_v_f_f32(max_val, 1);\n    vint32m1_t vcontrol;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        va = vle32_v_f32m1(&A[i]);\n        vcontrol = vle32_v_i32m1(&control[i]);\n\n        vint32m1_t mask = vmslt_v_i32m1(vcontrol, vmv_v_x_i32m1(1));\n        vfloat32m1_t normalized = vfmul_vf_f32m1(vfsub_vv_f32m1(va, vmin_val), vfmv_v_f_f32(1.0f / (max_val - min_val), vl));\n\n        normalized = vfmin_vf_f32m1(normalized, 1.0f);\n        normalized = vfmax_vf_f32m1(normalized, 0.0f);\n\n        vfloat32m1_t result = vmerge_v_f32m1(vfconvert_f32_i32m1(vcontrol), normalized, mask);\n        vse32_v_f32m1(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float inv_range = 1.0f / (max_val - min_val);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        vfloat32m1_t a_vec = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t control_vec = vle32_v_i32m1(&control[i], vl);\n        \n        vfloat32m1_t normalized = vfmul_vf_f32m1(vfsub_vf_f32m1(a_vec, min_val, vl), inv_range, vl);\n        vfloat32m1_t result = vfmax_vf_f32m1(vfmin_vf_f32m1(normalized, 1.0f, vl), 0.0f, vl);\n        \n        vfloat32m1_t final_result = vbsl_v_i32m1(control_vec, result, a_vec, vl);\n        \n        vse32_v_f32m1(&B[i], final_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float inv_range = 1.0f / (max_val - min_val);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32(size - i);\n        \n        vfloat32m1_t a_vec = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t control_vec = vle32_v_i32m1(&control[i], vl);\n        \n        vfloat32m1_t normalized = vfmul_vf_f32m1(vfsub_vf_f32m1(a_vec, min_val, vl), inv_range, vl);\n        vfloat32m1_t result = vfmv_v_f_f32m1(0.0f, vl);\n        \n        result = vmerge_vx_f32m1(result, normalized, vmsgt_vx_i32m1(control_vec, 0, vl));\n        result = vmerge_vx_f32m1(result, a_vec, vmsle_vx_i32m1(control_vec, 0, vl));\n        \n        result = vfmin_vf_f32m1(result, 1.0f, vl);\n        \n        vse32_v_f32m1(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load uint32_t values\n        vuint32m1_t high_bits = vsrl_vx_u32m1(va, 16); // Shift right to get high 16 bits\n        vfloat32m1_t vf = vfcvt_f_u32_v_f32m1(high_bits); // Convert to float\n        vf = vfsqrt_v_f32m1(vf); // Compute square root\n        vse32_v_f32m1(&B[i], vf); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl);\n        vint32m1_t high_bits = vsrl_vx_u32m1(va, 16);\n        vfloat32m1_t vf = vcvt_f_f32_u32m1(high_bits);\n        vfloat32m1_t vsqrt = vfsqrt_v_f32m1(vf, vl);\n        vse32_v_f32m1(&B[i], vsqrt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load uint32_t vector\n        vuint32m1_t high_bits = vsrl_vx_u32m1(va, 16); // Shift right to get high 16 bits\n        vfloat32m1_t vb = vcvt_f_f32_u32m1(high_bits); // Convert to float\n        vb = vsqrt_v_f32m1(vb); // Compute square root\n        vse32_v_f32m1(&B[i], vb); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load vector of uint32_t\n        vuint32m1_t high_bits = vsrl_vx_u32m1(va, 16); // Shift right to get high 16 bits\n        vfloat32m1_t vf = vcvt_f_u32_v_f32m1(high_bits); // Convert to float\n        vf = vfsqrt_v_f32m1(vf); // Compute square root\n        vse32_v_f32m1(&B[i], vf); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i]);\n        vuint32m1_t high_bits = vshri_v_u32m1(va, 16);\n        vfloat32m1_t vb = vcvt_f32_u32_m(0, high_bits);\n        vb = vsqrt_v_f32m1(vb);\n        vse32_v_f32m1(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i]); // Load uint32_t values\n        vfloat32m1_t vb = vreinterpret_vu32_vf32m1(va); // Reinterpret bits as float\n        vse32_v_f32m1(&B[i], vb); // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vl) {\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl);\n        vfloat32m1_t vb = vreinterpret_v_f32_u32m1(va);\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i); // Set vector length\n        vuint32m1_t va = vle32_v_u32m1(&A[i], vl); // Load uint32_t values\n        vfloat32m1_t vb = vreinterpret_vu32_vf32m1(va); // Reinterpret bits as float\n        vse32_v_f32m1(&B[i], vb, vl); // Store the resulting float values\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vl) {\n        size_t current_vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(&A[i], current_vl);\n        vfloat32m1_t vb = vreinterpret_vu32_vf32m1(va);\n        vse32_v_f32m1(&B[i], vb, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vl) {\n        vuint32m1_t va = vle32_v_u32m1(&A[i]);\n        vfloat32m1_t vb = vreinterpret_v_f32_u32m1(va);\n        vse32_v_f32m1(&B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    vbool32_t mask;\n\n    // Set the first element to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        size_t current_vl = vsetvl_e32m1(size - i);\n        \n        // Load the condition array and create a mask\n        mask = vle32_v_b32(cond + i, current_vl);\n        \n        // Load the source array\n        vuint32m1_t A_curr = vle32_v_u32m1(A + i, current_vl);\n        vuint32m1_t A_prev = vle32_v_u32m1(A + i - 1, current_vl);\n        \n        // Compute the difference\n        vint32m1_t diff_int = vsub_vv_i32m1(A_curr, A_prev, current_vl);\n        \n        // Convert to float\n        vfloat32m1_t diff_float = vcvt_f_f32m1(diff_int, current_vl);\n        \n        // Store results based on the mask\n        vse32_v_f32m1(diff + i, vmerge_vx_f32m1(vfmv_f_f32(0.0f, current_vl), diff_float, mask), current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    vbool32_t mask;\n\n    // Set the first element to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > size) {\n            current_vl = size - i;\n        }\n\n        // Load the condition and source arrays\n        vbool32_t cond_vec = vle32_v_b32(cond + i);\n        vint32m1_t A_vec = vle32_v_i32(A + i);\n        vint32m1_t A_prev_vec = vle32_v_i32(A + i - 1);\n\n        // Compute the difference\n        vint32m1_t diff_vec = vsub_vv_i32m1(A_vec, A_prev_vec);\n\n        // Convert to float\n        vfloat32m1_t diff_float_vec = vcvt_f_f32_v_i32m1(diff_vec);\n\n        // Apply the condition\n        vfloat32m1_t result_vec = vfmv_v_f_f32m1(0.0f, current_vl);\n        result_vec = vselect_vf_f32m1(cond_vec, diff_float_vec, result_vec);\n\n        // Store the result\n        vse32_v_f32(diff + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    vbool32_t v_cond;\n    vint32m1_t v_A_curr, v_A_prev;\n    vfloat32m1_t v_diff;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load current and previous elements\n        v_A_curr = vle32_v_i32m1(&A[i], vl);\n        v_A_prev = vle32_v_i32m1(&A[i - 1], vl);\n        \n        // Load condition\n        v_cond = vle32_v_i32m1((const int32_t*)&cond[i], vl);\n        \n        // Compute differences where condition is true\n        v_diff = vfcvt_f32_v_i32m1(vsub_vv_i32m1(v_A_curr, v_A_prev, vl), vl);\n        \n        // Set diff to 0.0f where condition is false\n        v_diff = vsel(v_cond, v_diff, vfmv_v_f_f32m1(0.0f, vl), vl);\n        \n        // Store the results\n        vse32_v_f32m1(&diff[i], v_diff, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    vbool64_t v_cond;\n    vint32m8_t v_A, v_A_prev;\n    vfloat32m8_t v_diff;\n    \n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 8) {\n        size_t vl = vsetvl_e32m8(size - i);\n        \n        // Load the current and previous elements\n        v_A = vle32_v_i32m8(&A[i], vl);\n        v_A_prev = vle32_v_i32m8(&A[i - 1], vl);\n        \n        // Load the condition array\n        v_cond = vle32_v_i32m8((const int32_t*)&cond[i], vl);\n        \n        // Compute the difference\n        v_diff = vsubl_vx_i32m8_f32m8(v_A, v_A_prev);\n        \n        // Store the results based on the condition\n        vse32_v_f32m8(&diff[i], v_cond ? v_diff : vfmv_v_f_f32m8(0.0f, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m1(size);\n    vbool32_t mask;\n\n    // Set the first element to 0.0f\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        size_t n = size - i < vl ? size - i : vl;\n\n        // Load the condition array\n        mask = vle32_v_b32(cond + i, n);\n\n        // Load the source array\n        vuint32m1_t a_curr = vle32_v_u32m1(A + i, n);\n        vuint32m1_t a_prev = vle32_v_u32m1(A + i - 1, n);\n\n        // Compute the difference\n        vint32m1_t diff_vec = vsub_vv_i32m1(a_curr, a_prev);\n\n        // Convert to float\n        vfloat32m1_t float_diff = vcvt_f_f32m1(diff_vec);\n\n        // Store results based on the condition\n        vse32_v_f32m1(diff + i, float_diff, mask);\n        \n        // Set elements to 0.0f where condition is false\n        vfloat32m1_t zero_vec = vfmv_v_f_f32m1(0.0f, n);\n        vse32_v_f32m1(diff + i, zero_vec, vnot_v_b32(mask));\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vl);\n        vuint64m1_t dst_vec = vshl_vx_u64m1(vreinterpret_vu32m1_u64m1(src_vec), 32);\n        dst_vec = vorr_vv_u64m1(dst_vec, vmv_v_x_u64m1(0xFFFFFFFF, vl));\n        vse64_v_u64m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vl);\n        vuint64m1_t dst_vec = vshl_vx_u64m1(vreinterpret_vu32_u64m1(src_vec), 32);\n        dst_vec = vorr_vv_u64m1(dst_vec, vmv_v_x_u64m1(0xFFFFFFFF, vl));\n        vse64_v_u64m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vl);\n        vuint64m1_t dst_vec = vshl_vx_u64m1(vreinterpret_vu32m1_u64m1(src_vec), 32);\n        vse64_v_u64m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vl);\n        vuint64m1_t dst_vec = vshl_vx_u64m1(vreinterpret_vu32_u64m1(src_vec), 32);\n        vuint64m1_t high_bits = vmv_v_x_u64m1(0xFFFFFFFF, vl);\n        dst_vec = vorr_vv_u64m1(dst_vec, high_bits);\n        vse64_v_u64m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl = vsetvl_e64m1(length);\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint32m1_t src_vec = vle32_v_u32m1(&src[i], vl);\n        vuint64m1_t dst_vec = vshl_vx_u64m1(vreinterpret_vu32m1_u64m1(src_vec), 32);\n        vuint64m1_t ones_vec = vmv_v_x_u64m1(0xFFFFFFFF, vl);\n        dst_vec = vorr_vv_u64m1(dst_vec, ones_vec);\n        vse64_v_u64m1(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n    size_t vl = vsetvl_e64m1(1); // Vector length for 64-bit floats\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = (i + vl > length) ? length - i : vl;\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], current_length); // Load indices\n        vfloat64m1_t vec_elements = vle64_v_f64m1(&vec[vle16_v_i16m1(&index[i], current_length)], current_length); // Load elements from vec\n        sum_vec = vadd_vv_f64m1(sum_vec, vec_elements); // Sum the elements\n    }\n\n    double result = 0.0;\n    result = vfmv_f_s_f64m1(result, sum_vec); // Move the result from vector to scalar\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n    size_t vl = vsetvl_e64m1(1); // Vector length for 64-bit floats\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], current_length); // Load indices\n        vfloat64m1_t vec_vec = vle64_v_f64m1(&vec[vle16_v_i16m1(&index[i], current_length)], current_length); // Load corresponding vec elements\n        sum_vec = vfredusum_vs_f64m1_f64m1(sum_vec, vec_vec, sum_vec, current_length); // Sum the elements\n    }\n\n    double result;\n    vfmerge_vv_f64m1(&result, sum_vec, sum_vec, 1); // Merge the result\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n    size_t vl = vsetvl_e64m1(1); // Vector length\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vl;\n        if (i + vl > length) {\n            current_vl = length - i; // Adjust for remaining elements\n        }\n\n        // Load indices\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], current_vl);\n        // Convert indices to 64-bit\n        vuint64m1_t idx_vec_u = vnsrl_vx_u64m1(vreinterpret_v_i16m1_u(idx_vec), 0);\n        \n        // Load corresponding values from vec\n        vfloat64m1_t vec_vec = vle64_v_f64m1(&vec[vextract_v_i16m1_u(idx_vec_u)], current_vl);\n        \n        // Sum the values\n        sum_vec = vfredusum_vs_f64m1(sum_vec, vec_vec, sum_vec);\n    }\n\n    double result;\n    vfsgnj_vv_f64m1(&result, sum_vec, sum_vec); // Extract the result\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n    size_t vl = vsetvl_e64m1(1); // Vector length\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = (i + vl > length) ? length - i : vl;\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], current_length); // Load indices\n        vfloat64m1_t vec_vec = vle64_v_f64m1(&vec[vle16_v_i16m1(&index[i], current_length)], current_length); // Load corresponding vec elements\n        sum_vec = vfredusum_vs_f64m1_f64m1(sum_vec, vec_vec, sum_vec, current_length); // Sum up\n    }\n\n    double result;\n    vfmv_f_s_f64(&result, sum_vec); // Move result to scalar\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    vfloat64m1_t sum_vec = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n    size_t vl = vsetvl_e64m1(1); // Vector length for 64-bit floats\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t current_length = length - i < vl ? length - i : vl;\n        vint16m1_t idx = vle16_v_i16m1(&index[i], current_length); // Load indices\n        vfloat64m1_t vec_elements = vle64_v_f64m1(&vec[vget_v_i16m1(idx)], current_length); // Gather elements\n        sum_vec = vfredusum_vs_f64m1_f64m1(sum_vec, vec_elements, sum_vec, current_length); // Sum elements\n    }\n\n    double result;\n    vfsgnj_v_f64m1(&result, sum_vec, sum_vec); // Store the result\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_index], 1);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[kernel_index], 1);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum, 1);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_index]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[kernel_index]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            vfloat64m1_t relu_result = vfmax_vv_f64m1(sum, vfmv_v_f_f64m1(0.0, 1));\n            vse64_v_f64m1(&output[i * output_size + j], relu_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_row * input_size + input_col]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[ki * kernel_size + kj]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1); // Initialize sum to 0.0\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_index], 1);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[kernel_index], 1);\n                    sum = vfadd_vv_f64m1(sum, vfmul_vv_f64m1(input_vec, kernel_vec, 1), 1);\n                }\n            }\n            vfloat64m1_t relu_result = vfmax_vf_f64m1(sum, 0.0, 1);\n            vse64_v_f64m1(&output[i * output_size + j], relu_result, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, 1);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    vfloat64m1_t input_vec = vle64_v_f64m1(&input[input_row * input_size + input_col]);\n                    vfloat64m1_t kernel_vec = vle64_v_f64m1(&kernel[ki * kernel_size + kj]);\n                    sum = vfmacc_vv_f64m1(sum, input_vec, kernel_vec);\n                }\n            }\n            double result = vfmv_f_s_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t vec1, vec2;\n    for (size_t i = 0; i < n; i += VSET) {\n        size_t vl = std::min(VSET, n - i);\n        vec1 = vle64_v_f64m1(&numbers[i], vl);\n\n        for (size_t j = i + 1; j < n; j += VSET) {\n            size_t vl2 = std::min(VSET, n - j);\n            vec2 = vle64_v_f64m1(&numbers[j], vl2);\n\n            vfloat64m1_t diff = vsub_vv_f64m1(vec1, vec2);\n            vfloat64m1_t abs_diff = vfmv_f_s_f64m1(0.0, vl); // Initialize to 0\n            abs_diff = vfmv_f_s_f64m1(0.0, vl);\n            abs_diff = vabs_v_f64m1(diff, vl);\n\n            if (vfirst_m(vle64_v_f64m1(&threshold, vl), abs_diff) != -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t vec_threshold = vfmv_v_f_f64m1(threshold, 1);\n    \n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t len = std::min(VEC_SIZE, n - i);\n        vfloat64m1_t vec_a = vle64_v_f64m1(&numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += VEC_SIZE) {\n            size_t len_j = std::min(VEC_SIZE, n - j);\n            vfloat64m1_t vec_b = vle64_v_f64m1(&numbers[j]);\n            \n            vfloat64m1_t diff = vfsub_vv_f64m1(vec_a, vec_b);\n            vfloat64m1_t abs_diff = vfwabs_v_f64m1(diff);\n            vbool64_t mask = vfredmin_vs_f64m1(vle64_v_f64m1(&numbers[j]), abs_diff, vec_threshold);\n            \n            if (vmfirst_m(mask) != -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t vec1, vec2;\n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t vl = std::min(VEC_SIZE, n - i);\n        vec1 = vle64_v_f64m1(&numbers[i], vl);\n\n        for (size_t j = i + 1; j < n; j += VEC_SIZE) {\n            size_t vl2 = std::min(VEC_SIZE, n - j);\n            vec2 = vle64_v_f64m1(&numbers[j], vl2);\n\n            vfloat64m1_t diff = vfredusum_vs_f64m1(vec1, vec2, vfmv_v_f_f64m1(0.0), vl);\n            vbool64_t mask = vmslt_vv_f64m1(diff, vfmv_v_f_f64m1(threshold), vl);\n            if (vmfirst_m(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t vec1, vec2;\n    for (size_t i = 0; i < n; i += VEC_LEN) {\n        size_t len = std::min(VEC_LEN, n - i);\n        vec1 = vle64_v_f64m1(&numbers[i], len);\n\n        for (size_t j = i + 1; j < n; j += VEC_LEN) {\n            size_t len2 = std::min(VEC_LEN, n - j);\n            vec2 = vle64_v_f64m1(&numbers[j], len2);\n\n            vfloat64m1_t diff = vsub_vv_f64m1(vec1, vec2);\n            vfloat64m1_t abs_diff = vfmv_f_s_f64m1(0.0, len) + vabs_v_f64m1(diff);\n            if (vfirst_m_b64(abs_diff, vmslt_vv_f64m1(abs_diff, vfmv_f_s_f64m1(threshold, len)))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t vec_threshold = vfmv_v_f_f64m1(threshold, 1);\n    \n    for (size_t i = 0; i < n; i += VEC_LEN) {\n        size_t len = std::min(VEC_LEN, n - i);\n        vfloat64m1_t vec_a = vle64_v_f64m1(&numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += VEC_LEN) {\n            size_t len_b = std::min(VEC_LEN, n - j);\n            vfloat64m1_t vec_b = vle64_v_f64m1(&numbers[j]);\n            \n            vfloat64m1_t diff = vfsub_vv_f64m1(vec_a, vec_b);\n            vfloat64m1_t abs_diff = vfwabs_v_f64m1(diff);\n            \n            if (vfredmin_vs_f64m1(abs_diff, vec_threshold) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    vtype<int> v_zero = vsetvl_e32m1(1);\n    vtype<int> v_balance = v_zero;\n    \n    for (int i = 0; i < n; i += VLEN) {\n        vtype<int> v_ops = vle32_v_i32m1(&operations[i]);\n        v_balance = v_add_vv_i32m1(v_balance, v_ops);\n        \n        if (vfirst_m_b(vmslt_vv_i32m1(v_balance, v_zero))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int32_t balance = 0;\n    vbool32_t below_zero = vmslt_vx_i32_b32(vle32_v_i32(&balance, 0), 0);\n    \n    for (size_t i = 0; i < n; i += 32) {\n        size_t vl = std::min(32UL, n - i);\n        vint32m1_t op = vle32_v_i32(&operations[i], vl);\n        balance += vreduce_add_i32(op);\n        \n        if (vmslt_vx_i32_b32(vle32_v_i32(&balance, 0), 0)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    vtype<int> balance = vsetvl_n_i32(n);\n    vint32m1_t acc = vmv_v_x_i32m1(0, balance);\n    \n    for (size_t i = 0; i < n; i += balance) {\n        size_t vl = vsetvl_n_i32(n - i);\n        vint32m1_t op = vle32_v_i32m1(&operations[i], vl);\n        acc = vadd_vv_i32m1(acc, op, vl);\n        \n        if (vmax_i32m1(acc, vl) < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vl = vsetvl_e32(n);\n    vbool32_t result = vmslt_vx_i32(vle32_v_i32(&operations[0], vl), 0);\n    \n    int32_t balance = 0;\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32(n - i);\n        vint32m1_t op = vle32_v_i32(&operations[i], vl);\n        balance += vreduce_add_i32(op);\n        \n        if (vfirst_m_b32(result) != -1) {\n            return true;\n        }\n        \n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    vtype<int> v_zero = vsetvl_n_i32(0);\n    vint32m1_t balance = vdup_v_i32m1(0);\n    \n    for (int i = 0; i < n; i += vlen) {\n        int vl = vsetvl_n_i32(n - i);\n        vint32m1_t op = vle32_v_i32m1(&operations[i], vl);\n        balance = vadd_vv_i32m1(balance, op);\n        \n        if (vfirst_m_b32m1(vle32_v_i32m1(&balance, vl) < v_zero) != -1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Prepare for SIMD computation\n    size_t vl = vsetvl_e64(n);\n    vfloat64m1_t vec_numbers = vle64_v_f64m1(numbers.data(), vl);\n    vfloat64m1_t vec_mean = vfmv_v_f_f64m1(mean, vl);\n    \n    // Calculate absolute differences\n    vfloat64m1_t abs_diff = vfsub_vv_f64m1(vec_numbers, vec_mean, vl);\n    abs_diff = vfwabs_v_f64m1(abs_diff, vl);\n\n    // Sum absolute differences\n    double mad_sum = 0.0;\n    for (size_t i = 0; i < n; i += vl) {\n        size_t current_vl = vsetvl_e64(n - i);\n        mad_sum += vfredusum_vs_f64m1_f64m1(abs_diff, mad_sum, vl);\n    }\n\n    // Calculate Mean Absolute Deviation\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize vector registers\n    vfloat64m1_t vec_numbers;\n    vfloat64m1_t vec_mean = vfmv_v_f_f64m1(mean, n);\n    vfloat64m1_t vec_abs_diff;\n    \n    // Calculate absolute differences\n    size_t vl;\n    for (size_t i = 0; i < n; i += VLEN / sizeof(double)) {\n        vl = std::min(VLEN / sizeof(double), n - i);\n        vec_numbers = vle64_v_f64m1(&numbers[i], vl);\n        vec_abs_diff = vfredusum_vs_f64m1(vec_numbers, vec_mean, vfmv_v_f_f64m1(0.0, vl), vl);\n    }\n\n    // Calculate Mean Absolute Deviation\n    double mad = vfmv_f_s_f64m1(vec_abs_diff, vl) / n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Prepare for vector operations\n    vfloat64m1_t vec_mean = vfmv_v_f_f64m1(mean, n);\n    vfloat64m1_t vec_sum_abs_diff = vfmv_v_f_f64m1(0.0, n);\n\n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m1(n - i);\n        vfloat64m1_t vec_numbers = vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t vec_diff = vfsub_vv_f64m1(vec_numbers, vec_mean, vl);\n        vfloat64m1_t vec_abs_diff = vfwabs_v_f64m1(vec_diff, vl);\n        vec_sum_abs_diff = vfredusum_vs_f64m1(vec_sum_abs_diff, vec_abs_diff, vec_sum_abs_diff, vl);\n    }\n\n    double sum_abs_diff = vfmv_f_s_f64(vec_sum_abs_diff);\n    return sum_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize vector registers\n    vfloat64m1_t vec_numbers;\n    vfloat64m1_t vec_mean = vfmv_v_f_f64m1(mean, n);\n    vfloat64m1_t vec_abs_diff;\n    \n    // Calculate absolute differences and sum them\n    double total_abs_diff = 0.0;\n    size_t vl;\n    for (size_t i = 0; i < n; i += VSET) {\n        vl = std::min(VSET, n - i);\n        vec_numbers = vle64_v_f64m1(&numbers[i], vl);\n        vec_abs_diff = vfabs_v_f64m1(vfsub_vv_f64m1(vec_numbers, vec_mean, vl), vl);\n        total_abs_diff += vfredusum_vs_f64m1(vec_abs_diff, vfmv_v_f_f64m1(0.0, vl), vl);\n    }\n\n    // Calculate Mean Absolute Deviation\n    return total_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize vector registers\n    vfloat64m1_t vec_sum = vfmv_v_f_f64m1(0.0, n);\n    vfloat64m1_t vec_mean = vfmv_v_f_f64m1(mean, n);\n    \n    // Load data into vector\n    vfloat64m1_t vec_numbers = vle64_v_f64m1(numbers.data(), n);\n    \n    // Calculate absolute differences\n    vfloat64m1_t vec_diff = vfsub_vv_f64m1(vec_numbers, vec_mean);\n    vec_diff = vfabs_v_f64m1(vec_diff);\n    \n    // Sum absolute differences\n    vec_sum = vfredusum_vs_f64m1(vec_diff, vec_sum, vec_sum);\n    \n    // Calculate Mean Absolute Deviation\n    double mad = vfmv_f_s_f64(vec_sum) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n == 0 ? 0 : 2 * n - 1;\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    vtype<int> *vec_numbers = (vtype<int> *)numbers.data();\n    vtype<int> *vec_result = (vtype<int> *)result.data();\n\n    size_t i = 0;\n    size_t vec_len = n / VLEN;\n    size_t remaining = n % VLEN;\n\n    for (; i < vec_len; ++i) {\n        vtype<int> v_nums = vle32_v_i32(vec_numbers + i * VLEN);\n        vse32_v_i32(vec_result + i * (VLEN + 1), v_nums);\n        for (size_t j = 0; j < VLEN - 1; ++j) {\n            vec_result[i * (VLEN + 1) + j + 1] = delimeter;\n        }\n    }\n\n    if (remaining > 0) {\n        vtype<int> v_nums = vle32_v_i32(vec_numbers + i * VLEN);\n        vse32_v_i32(vec_result + i * (VLEN + 1), v_nums);\n        for (size_t j = 0; j < remaining - 1; ++j) {\n            vec_result[i * (VLEN + 1) + j + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    vtype<int> *vec_numbers = (vtype<int> *)numbers.data();\n    vtype<int> *vec_result = (vtype<int> *)result.data();\n\n    size_t i = 0;\n    size_t vec_size = vsetvl_e32m8(n);\n    size_t j = 0;\n\n    for (; i + vec_size <= n; i += vec_size, j += vec_size + 1) {\n        vtype<int> v_numbers = vle32_v_i32m8(vec_numbers + i);\n        vse32_v_i32m8(vec_result + j, v_numbers);\n        for (size_t k = 0; k < vec_size; ++k) {\n            vec_result[j + k + 1] = delimeter;\n        }\n    }\n\n    for (; i < n; ++i, ++j) {\n        vec_result[j] = numbers[i];\n        if (j + 1 < new_size) {\n            vec_result[j + 1] = delimeter;\n            ++j;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    int *numbers_ptr = numbers.data();\n    int *result_ptr = result.data();\n\n    size_t vl = vsetvl_e32(n);\n    size_t i = 0;\n\n    for (; i + vl <= n; i += vl) {\n        vint32m1_t vec_numbers = vle32_v_i32m1(numbers_ptr + i, vl);\n        vse32_v_i32m1(result_ptr + 2 * i, vec_numbers, vl);\n        for (size_t j = 0; j < vl; j++) {\n            result_ptr[2 * i + j + 1] = delimeter;\n        }\n    }\n\n    for (; i < n; i++) {\n        result_ptr[2 * i] = numbers_ptr[i];\n        if (i < n - 1) {\n            result_ptr[2 * i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    vtype<int> *vec_numbers = (vtype<int> *)numbers.data();\n    vtype<int> *vec_result = (vtype<int> *)result.data();\n\n    size_t i = 0;\n    size_t vec_len = n / 8; // Assuming 8 elements can be processed in parallel\n    size_t remainder = n % 8;\n\n    for (; i < vec_len; i++) {\n        vtype<int> v_nums = vle32_v_i32(vec_numbers + i * 8);\n        vse32_v_i32(vec_result + i * 9, v_nums);\n        vtype<int> v_delim = vmv_v_x_i32(delimeter, 8);\n        vse32_v_i32(vec_result + i * 9 + 8, v_delim);\n    }\n\n    if (remainder > 0) {\n        vtype<int> v_nums = vle32_v_i32(vec_numbers + i * 8);\n        vse32_v_i32(vec_result + i * 9, v_nums);\n        if (remainder > 1) {\n            vtype<int> v_delim = vmv_v_x_i32(delimeter, remainder - 1);\n            vse32_v_i32(vec_result + i * 9 + 8, v_delim);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    vtype<int> *vec_numbers = (vtype<int> *)numbers.data();\n    vtype<int> *vec_result = (vtype<int> *)result.data();\n\n    size_t i = 0;\n    size_t vec_len = vsetvl_e32m1(new_size);\n    \n    for (; i + vec_len <= n; i += vec_len) {\n        vtype<int> vec_data = vle32_v_i32m1(vec_numbers + i);\n        vse32_v_i32m1(vec_result + i * 2, vec_data);\n        for (size_t j = 0; j < vec_len; j++) {\n            vec_result[i * 2 + j + 1] = delimeter;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        vec_result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            vec_result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    vtype<int16_t> vlen = vsetvl_e16(n);\n    vuint16m1_t vec_sum = vundefined_u16m1();\n    vuint16m1_t vec_prod = vundefined_u16m1();\n\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e16(n - i);\n        vuint16m1_t vec = vle16_v_u16m1(&numbers[i], vl);\n        \n        vec_sum = vadd_u16m1(vec_sum, vec);\n        vec_prod = vmul_u16m1(vec_prod, vec);\n    }\n\n    sum += vreduce_add_u16m1(vec_sum);\n    product *= vreduce_mul_u16m1(vec_prod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    vtype<int16_t> vtype = vsetvl_e16(n);\n    vuint16m1_t vec_sum = vredsum_vs_i16m1(vle16_v_i16m1(numbers.data(), vtype), 0, vtype);\n    vuint16m1_t vec_prod = vmul_vv_i16m1(vle16_v_i16m1(numbers.data(), vtype), vsetvl_e16(1), vtype);\n\n    sum = vget_v_i64m1(vec_sum);\n    product = vget_v_i64m1(vec_prod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    vtype<int16_t> vlen = vsetvl_e16(n);\n    vuint16m1_t vec_sum = vundefined_u16m1();\n    vuint16m1_t vec_prod = vundefined_u16m1();\n\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e16(n - i);\n        vuint16m1_t vec_nums = vle16_v_u16m1(&numbers[i], vl);\n        \n        vec_sum = vadd_u16m1(vec_sum, vec_nums);\n        vec_prod = vmul_u16m1(vec_prod, vec_nums);\n    }\n\n    sum = vreduce_add_u16m1(vec_sum);\n    product = vreduce_mul_u16m1(vec_prod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    vtype<int16_t> v_numbers = vload_v<int16_t>(numbers.data(), n);\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int16_t> v_temp = vload_v<int16_t>(numbers.data() + i, vl);\n        \n        sum += vreduce_add(v_temp, vl);\n        product *= vreduce_mul(v_temp, vl);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    vtype<int16_t> v_numbers = vle16_v_i16m1(numbers.data(), n);\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    // Calculate sum using RVV\n    for (size_t i = 0; i < n; i += VLEN / sizeof(int16_t)) {\n        size_t vl = std::min(n - i, (size_t)(VLEN / sizeof(int16_t)));\n        vuint16m1_t v_sum = vredsum_vs_i16m1(v_numbers, 0, vl);\n        sum += vmv_x_s_i16m1(v_sum, vl);\n    }\n\n    // Calculate product using RVV\n    for (size_t i = 0; i < n; i += VLEN / sizeof(int16_t)) {\n        size_t vl = std::min(n - i, (size_t)(VLEN / sizeof(int16_t)));\n        vuint16m1_t v_product = vmul_vv_i16m1(v_numbers, v_numbers, vl);\n        product *= vmv_x_s_i16m1(v_product, vl);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    vtype<int> v_max = vundefined<int>();\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> v_numbers = vle32_v_i32(&numbers[i], vl);\n        \n        if (i == 0) {\n            v_max = v_numbers;\n        } else {\n            v_max = vmax_vv_i32(v_max, v_numbers);\n        }\n        \n        vse32_v_i32(&result[i], v_max, vl);\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    vtype<int> v_max = vundefined<int>();\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vuint32m1_t v_numbers = vle32_v_u32m1(&numbers[i], vl);\n        v_max = vmax_vv_i32m1(v_max, v_numbers, vl);\n        vse32_v_i32m1(&result[i], v_max, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    vtype<int> v_max = vundefined<int>();\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> v_numbers = vle32_v_i32(&numbers[i], vl);\n        \n        if (i == 0) {\n            v_max = v_numbers;\n        } else {\n            v_max = vmax_v_i32(v_max, v_numbers);\n        }\n        \n        vse32_v_i32(&result[i], v_max, vl);\n    }\n\n    for (size_t i = 1; i < n; i++) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    vtype<int> v_max = vundefined<int>();\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> v_numbers = vle32_v_i32(&numbers[i], vl);\n        \n        if (i == 0) {\n            v_max = v_numbers;\n        } else {\n            v_max = vmax_vv_i32(v_max, v_numbers);\n        }\n        \n        vse32_v_i32(&result[i], v_max, vl);\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    vtype<int> v_max = vundefined<int>();\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> v_numbers = vle32_v_i32(&numbers[i], vl);\n        \n        if (i == 0) {\n            v_max = v_numbers;\n        } else {\n            v_max = vmax_vv_i32(v_max, v_numbers, vl);\n        }\n        \n        vse32_v_i32(&result[i], v_max, vl);\n    }\n\n    for (size_t i = 1; i < n; i++) {\n        result[i] = std::max(result[i - 1], result[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    size_t vector_length = vsetvl_e8m1(len); // Set vector length based on the number of elements\n    vuint8m1_t va = vle8_v_u8m1((const uint8_t*)a.c_str(), vector_length);\n    vuint8m1_t vb = vle8_v_u8m1((const uint8_t*)b.c_str(), vector_length);\n    \n    vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vector_length);\n    \n    vse8_v_u8m1((uint8_t*)result.data(), vxor, vector_length);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    std::string result(n, '0');\n\n    size_t vector_length = vsetvl_e8m1(n);\n    vuint8m1_t va = vle8_v_u8m1((const uint8_t*)a.c_str(), vector_length);\n    vuint8m1_t vb = vle8_v_u8m1((const uint8_t*)b.c_str(), vector_length);\n    \n    vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vector_length);\n    \n    vse8_v_u8m1((uint8_t*)result.data(), vxor, vector_length);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    size_t vector_length = vsetvl_e8m1(len);\n    vuint8m1_t va = vle8_v_u8m1((const uint8_t*)a.c_str(), vector_length);\n    vuint8m1_t vb = vle8_v_u8m1((const uint8_t*)b.c_str(), vector_length);\n    \n    vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vector_length);\n    \n    vse8_v_u8m1((uint8_t*)result.data(), vxor, vector_length);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    vuint8m1_t va, vb, vr;\n    for (size_t i = 0; i < len; i += VLEN) {\n        size_t vl = std::min(VLEN, len - i);\n        va = vle8_v_u8m1((const uint8_t*)&a[i], vl);\n        vb = vle8_v_u8m1((const uint8_t*)&b[i], vl);\n        vr = vxor_vv_u8m1(va, vb, vl);\n        vse8_v_u8m1((uint8_t*)&result[i], vr, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    // Vector length\n    size_t vl = vsetvl_e8(len);\n\n    // Load strings into vectors\n    vuint8m1_t va = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.data()), vl);\n    vuint8m1_t vb = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.data()), vl);\n\n    // Perform XOR operation\n    vuint8m1_t vxor = vpxor_vv_u8m1(va, vb, vl);\n\n    // Store the result back to the string\n    vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), vxor, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    vuint64m1_t lengths = vundefined_u64m1();\n    for (size_t i = 0; i < n; i += 8) {\n        size_t vl = std::min(8UL, n - i);\n        for (size_t j = 0; j < vl; j++) {\n            lengths = vinsert_u64m1(lengths, strings[i + j].length(), j);\n        }\n        vuint64m1_t max_lengths = vmax_u64m1(lengths, lengths);\n        size_t max_idx = vfirst_u64m1(max_lengths);\n        if (max_idx != -1) {\n            size_t current_length = vextract_u64m1(lengths, max_idx);\n            if (current_length > max_length) {\n                max_length = current_length;\n                max_index = i + max_idx;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    vuint64m1_t lengths = vundefined_u64m1();\n    for (size_t i = 0; i < n; i += 8) {\n        size_t count = std::min(size_t(8), n - i);\n        for (size_t j = 0; j < count; ++j) {\n            lengths = vslide1down_u64m1(lengths, lengths, 0);\n            lengths = vset_u64m1(lengths, j, strings[i + j].length());\n        }\n\n        vuint64m1_t max_lengths = vmax_u64m1(lengths, vundefined_u64m1());\n        size_t idx = vfirst_u64m1(max_lengths);\n        if (idx != -1) {\n            size_t current_length = strings[i + idx].length();\n            if (current_length > max_length) {\n                max_length = current_length;\n                max_index = i + idx;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    vuint64m1_t lengths = vundefined_u64m1();\n    for (size_t i = 0; i < n; i += 8) {\n        size_t count = std::min(size_t(8), n - i);\n        for (size_t j = 0; j < count; ++j) {\n            lengths = vslide1down_u64m1(lengths, vsetvl_e64m1(1), strings[i + j].length());\n        }\n        vuint64m1_t max_lengths = vmaxu_vv_u64m1(lengths, lengths);\n        size_t max_idx = vfirst_m(mask, max_lengths);\n        if (max_lengths[max_idx] > max_length) {\n            max_length = max_lengths[max_idx];\n            max_index = i + max_idx;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    vuint64m1_t lengths = vundefined_u64m1();\n    for (size_t i = 0; i < n; i += 8) {\n        size_t chunk_size = std::min(size_t(8), n - i);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            lengths = vset_v_u64m1(lengths, j, i);\n        }\n        vuint64m1_t current_lengths = vundefined_u64m1();\n        for (size_t j = 0; j < chunk_size; ++j) {\n            current_lengths = vset_v_u64m1(current_lengths, strings[i + j].length(), j);\n        }\n        lengths = vadd_u64m1(lengths, current_lengths);\n        \n        vuint64m1_t max_lengths = vmaxu_vv_u64m1(lengths, max_length);\n        max_length = vmv_x_s_u64(max_lengths);\n        max_index = vmv_x_s_u64(vcompress_u64m1(max_lengths, lengths));\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    vuint64m1_t lengths = vundefined_u64m1();\n    for (size_t i = 0; i < n; i += vsetvl_e64m1(n - i)) {\n        size_t vl = vsetvl_e64m1(n - i);\n        for (size_t j = 0; j < vl && (i + j) < n; j++) {\n            lengths = vslide1down_u64m1(lengths, vuint64m1_t{strings[i + j].length()}, j);\n        }\n        vuint64m1_t max_lengths = vmaxu_vv_u64m1(lengths, lengths);\n        size_t idx = vfirst_m(vle64_v_u64m1(max_lengths));\n        if (lengths[idx] > max_length) {\n            max_length = lengths[idx];\n            max_index = i + idx;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va = vsetvl_e64m1(1);\n    vuint64m1_t vb = vsetvl_e64m1(1);\n    va = vslide1down_v_u64m1(va, a);\n    vb = vslide1down_v_u64m1(vb, b);\n    \n    while (vb != 0) {\n        vuint64m1_t temp = vb;\n        vb = va % vb;\n        va = temp;\n    }\n    \n    return va;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va = vsetvl_e64m1(1);\n    vuint64m1_t vb = vsetvl_e64m1(1);\n    va = vlev_v_u64m1(&a, 1);\n    vb = vlev_v_u64m1(&b, 1);\n    \n    while (vfirst_m_b64m1(vand_vb64m1(va, vb)) != -1) {\n        vuint64m1_t temp = va;\n        va = vb;\n        vb = vsub_vv_u64m1(temp, vb);\n    }\n    \n    return vfirst_m_b64m1(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va = vsetvl_e64m1(1);\n    vuint64m1_t vb = vsetvl_e64m1(1);\n    va = vlev_v_u64m1(&a, 1);\n    vb = vlev_v_u64m1(&b, 1);\n    \n    while (vmaxu_v_u64m1(va, vb) != 0) {\n        vuint64m1_t temp = vcopy_v_u64m1(vb);\n        vb = vand_vv_u64m1(va, vb);\n        va = temp;\n    }\n    \n    uint64_t result;\n    vsev_v_u64m1(&result, va, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va = vsetvl_e64m1(1);\n    vuint64m1_t vb = vsetvl_e64m1(1);\n    va = vlev_v_u64m1(&a, 1);\n    vb = vlev_v_u64m1(&b, 1);\n    \n    while (vfirst_m_b64m1(vand_vb64m1(va, vb)) == 0) {\n        vuint64m1_t vtemp = va;\n        va = vb;\n        vb = vsub_vv_u64m1(vtemp, vb);\n    }\n    \n    return vfirst_m_b64m1(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va = vsetvl_e64m1(1);\n    vuint64m1_t vb = vsetvl_e64m1(1);\n    va = vlev_v_u64m1(&a, 1);\n    vb = vlev_v_u64m1(&b, 1);\n    \n    while (vfirst_m_b64m1(vand_vx_u64m1(vsrl_vx_u64m1(va, 1), 1)) != -1) {\n        vuint64m1_t temp = va;\n        va = vb;\n        vb = vand_vx_u64m1(temp, 1);\n    }\n    \n    return vfirst_m_b64m1(va);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> closest_pair(2);\n    float min_diff = std::numeric_limits<float>::max();\n\n    vfloat32m1_t vec_numbers = vle32_v_f32m1(numbers.data());\n    vfloat32m1_t vec_diff;\n    vfloat32m1_t vec_min_diff = vmv_v_f_f32m1(min_diff);\n    \n    for (size_t i = 0; i < n; i += 2) {\n        for (size_t j = i + 1; j < n; j += 2) {\n            vfloat32m1_t vec_num1 = vle32_v_f32m1(&numbers[i]);\n            vfloat32m1_t vec_num2 = vle32_v_f32m1(&numbers[j]);\n            vec_diff = vsub_vv_f32m1(vec_num1, vec_num2);\n            vec_diff = vabs_v_f32m1(vec_diff);\n            \n            vfloat32m1_t mask = vmslt_vv_f32m1(vec_diff, vec_min_diff);\n            if (vmfirst_m(mask) != -1) {\n                min_diff = vfirst_m(mask);\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n                vec_min_diff = vmin_vv_f32m1(vec_diff, vec_min_diff);\n            }\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_pair[2] = {0.0f, 0.0f};\n\n    vfloat32m1_t vec_a, vec_b, vec_diff;\n    for (size_t i = 0; i < n - 1; i += 4) {\n        vec_a = vle32_v_f32m1(&sorted_numbers[i]);\n        vec_b = vle32_v_f32m1(&sorted_numbers[i + 1]);\n        vec_diff = vfredmin_vs_f32m1(vec_a, vec_b, vfmv_f_s_f32m1(0.0f), &min_diff);\n\n        for (size_t j = 0; j < 4 && (i + j + 1) < n; j++) {\n            float diff = sorted_numbers[i + j + 1] - sorted_numbers[i + j];\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = sorted_numbers[i + j];\n                closest_pair[1] = sorted_numbers[i + j + 1];\n            }\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(2);\n    \n    vfloat32m1_t vec_numbers = vle32_v_f32m1(numbers.data());\n    vfloat32m1_t vec_diff;\n    vfloat32m1_t min_diff = vfmv_v_f_f32m1(std::numeric_limits<float>::max());\n    \n    for (size_t i = 0; i < n; i++) {\n        for (size_t j = i + 1; j < n; j++) {\n            vfloat32m1_t diff = vfmv_v_f_f32m1(numbers[j]) - vfmv_v_f_f32m1(numbers[i]);\n            vec_diff = vfmv_v_f_f32m1(std::abs(vfirst_f32m1(diff)));\n            min_diff = vmin_vv_f32m1(min_diff, vec_diff);\n        }\n    }\n\n    float min_value = vfirst_f32m1(min_diff);\n    for (size_t i = 0; i < n; i++) {\n        if (std::abs(numbers[i] - min_value) < 1e-6) {\n            result[0] = numbers[i];\n            break;\n        }\n    }\n\n    for (size_t j = 0; j < n; j++) {\n        if (std::abs(numbers[j] - min_value) < 1e-6 && numbers[j] != result[0]) {\n            result[1] = numbers[j];\n            break;\n        }\n    }\n\n    if (result[0] > result[1]) {\n        std::swap(result[0], result[1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_pair[2] = {0.0f, 0.0f};\n\n    vfloat32m1_t vec1, vec2, diff;\n    for (size_t i = 0; i < n - 1; i += 4) {\n        vec1 = vle32_v_f32m1(&sorted_numbers[i]);\n        vec2 = vle32_v_f32m1(&sorted_numbers[i + 1]);\n        diff = vsub_vv_f32m1(vec2, vec1);\n        \n        float min_diff_local[4];\n        vse32_v_f32m1(min_diff_local, diff);\n        \n        for (size_t j = 0; j < 4; j++) {\n            if (min_diff_local[j] < min_diff) {\n                min_diff = min_diff_local[j];\n                closest_pair[0] = sorted_numbers[i + j];\n                closest_pair[1] = sorted_numbers[i + j + 1];\n            }\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_pair[2] = {0.0f, 0.0f};\n\n    vfloat32m1_t vec_a, vec_b, vec_diff;\n    for (size_t i = 0; i < n - 1; i += 2) {\n        vec_a = vle32_v_f32m1(&sorted_numbers[i]);\n        vec_b = vle32_v_f32m1(&sorted_numbers[i + 1]);\n        vec_diff = vsub_vv_f32m1(vec_b, vec_a);\n        \n        float diff[2];\n        vse32_v_f32m1(diff, vec_diff);\n        \n        for (size_t j = 0; j < 2; ++j) {\n            if (diff[j] < min_diff) {\n                min_diff = diff[j];\n                closest_pair[0] = sorted_numbers[i + j];\n                closest_pair[1] = sorted_numbers[i + j + 1];\n            }\n        }\n    }\n\n    if (n % 2 == 1) {\n        float last = sorted_numbers[n - 1];\n        for (size_t i = 0; i < n - 1; ++i) {\n            float diff = std::abs(last - sorted_numbers[i]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(last, sorted_numbers[i]);\n                closest_pair[1] = std::max(last, sorted_numbers[i]);\n            }\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    vfloat32m1_t vec_min = vfmv_v_f_f32m1(numbers[0], n);\n    vfloat32m1_t vec_max = vfmv_v_f_f32m1(numbers[0], n);\n\n    for (size_t i = 0; i < n; i += 8) {\n        vfloat32m1_t vec = vle32_v_f32m1(&numbers[i]);\n        vec_min = vmin_vv_f32m1(vec_min, vec);\n        vec_max = vmax_vv_f32m1(vec_max, vec);\n    }\n\n    float min_val = vfmv_f_f32(vec_min);\n    float max_val = vfmv_f_f32(vec_max);\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    for (size_t i = 0; i < n; i += 8) {\n        vfloat32m1_t vec = vle32_v_f32m1(&numbers[i]);\n        vfloat32m1_t scaled = vdiv_vf_f32m1(vsub_vv_f32m1(vec, vfmv_v_f_f32m1(min_val, 8)), range);\n        vse32_v_f32m1(&result[i], scaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    vfloat32m1_t v_min = vle32_v_f32m1(&min_val, 1);\n    vfloat32m1_t v_range = vle32_v_f32m1(&range, 1);\n\n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_numbers = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t v_rescaled = vfmul_vv_f32m1(vfsub_vv_f32m1(v_numbers, v_min), vfmul_vf_f32m1(vfdiv_vv_f32m1(vfsub_vv_f32m1(v_numbers, v_min), v_range), 1.0f));\n        vse32_v_f32m1(&result[i], v_rescaled, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    vfloat32m1_t v_min = vfmv_v_f_f32m1(min_val, n);\n    vfloat32m1_t v_range = vfmv_v_f_f32m1(range, n);\n\n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_numbers = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t v_rescaled = vfmul_vv_f32m1(vfsub_vv_f32m1(v_numbers, v_min, vl), \n                                                  vfmv_v_f_f32m1(1.0f / range, vl), vl);\n        vse32_v_f32m1(&result[i], v_rescaled, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    vfloat32m1_t v_min = vfmv_v_f_f32m1(min_val, n);\n    vfloat32m1_t v_range = vfmv_v_f_f32m1(range, n);\n\n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_numbers = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t v_rescaled = vfmul_vv_f32m1(vsub_vv_f32m1(v_numbers, v_min, vl), \n                                                  vfmv_v_f_f32m1(1.0f / range, vl), vl);\n        vse32_v_f32m1(&result[i], v_rescaled, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    std::vector<float> result(n);\n    vfloat32m1_t v_min = vfmv_v_f_f32m1(min_val, n);\n    vfloat32m1_t v_max = vfmv_v_f_f32m1(max_val, n);\n    \n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_numbers = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t v_rescaled = vdiv_vv_f32m1(vsub_vv_f32m1(v_numbers, v_min, vl), \n                                                 vsub_vv_f32m1(v_max, v_min, vl), vl);\n        vse32_v_f32m1(&result[i], v_rescaled, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    vuint64m1_t vec_n = vsetvl_e64m1(1);\n    vuint64m1_t vec_i = vsetvl_e64m1(1);\n    vuint64m1_t vec_divisor = vundefined_u64m1();\n\n    for (uint64_t i = n - 1; i > 1; i--) {\n        vec_i = vsetvl_e64m1(1);\n        vec_divisor = vadd_u64m1(vec_i, -1);\n        vec_n = vsetvl_e64m1(n);\n        \n        vbool64_t mask = vmul_u64m1(vec_n, vdiv_u64m1(vec_n, vec_divisor));\n        if (vfirst_m(mask)) {\n            return vfirst_m(mask) ? vget_u64m1(vec_divisor, 0) : 1;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    vuint64m1_t vec_n = vsetvl_e64m1(1);\n    vuint64m1_t vec_i = vsetvl_e64m1(1);\n    vuint64m1_t vec_divisor = vundefined_u64m1();\n    \n    for (uint64_t i = n - 1; i > 1; i -= 2) {\n        vec_i = vslide1down_u64m1(vec_i, vec_n);\n        vec_divisor = vmerge_u64m1(vec_divisor, vec_i, vmsltu_vv_u64m1(vec_i, vec_n));\n    }\n\n    return vget_u64m1(vmaxu_vv_u64m1(vec_divisor, vec_n));\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    vuint64m1_t vec_n = vsetvl_e64m1(1);\n    vec_n = vle64_v_u64m1(&n, vec_n);\n    \n    vuint64m1_t vec_i = vsetvl_e64m1(1);\n    vuint64m1_t largest_divisor = vdup64m1(0);\n\n    for (uint64_t i = n / 2; i > 0; i--) {\n        vec_i = vsetvl_e64m1(1);\n        vec_i = vdup64m1(i);\n        \n        vbool64_t mask = vmsltu_vv_u64m1(vec_n, vec_i);\n        if (vmfirst_m(mask) != -1) {\n            largest_divisor = vec_i;\n            break;\n        }\n    }\n\n    return vfirst_m(largest_divisor);\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    vuint64m1_t vec_n = vsetvl_e64m1(1);\n    vuint64m1_t vec_i = vsetvl_e64m1(1);\n    vuint64m1_t vec_divisor = vsetvl_e64m1(1);\n    \n    for (uint64_t i = n - 1; i > 1; i--) {\n        vec_i = vmv_v_x_u64m1(i, vec_n);\n        vec_divisor = vdiv_u64m1(vec_n, vec_i);\n        vbool64_t mask = vmsltu_vv_u64m1(vec_divisor, vec_n);\n        \n        if (vfirst_m(mask) != -1) {\n            return i;\n        }\n    }\n    return 1; // Fallback\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    vuint64m1_t vec_n = vsetvl_e64m1(1);\n    vuint64m1_t vec_i = vsetvl_e64m1(1);\n    vuint64m1_t vec_divisor = vundefined_u64m1();\n    vuint64m1_t vec_result = vundefined_u64m1();\n\n    for (uint64_t i = n - 1; i > 0; i -= 4) {\n        vec_i = vadd_vx_u64m1(vec_i, 1);\n        vec_divisor = vset_v_u64m1(i);\n        vbool64_t mask = vmslt_vx_u64m1(vec_n, vec_divisor);\n        vec_result = vmerge_vxm_u64m1(mask, vec_result, vec_divisor);\n        vec_result = vmerge_vxm_u64m1(vmslt_vx_u64m1(vec_divisor, vec_n), vec_result, vec_divisor);\n    }\n\n    return vget_first_u64m1(vec_result);\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int i = 2;\n\n    while (i * i <= n) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        i++;\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Using RVV intrinsics to create a vector of factors\n    size_t num_factors = factors.size();\n    vtype<int> v_factors = vundefined<int>(vsetvl(num_factors));\n\n    for (size_t j = 0; j < num_factors; j++) {\n        v_factors[j] = factors[j];\n    }\n\n    std::vector<int> result;\n    for (size_t j = 0; j < num_factors; j++) {\n        result.push_back(v_factors[j]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int i = 2;\n\n    while (n > 1) {\n        int count = 0;\n        while (n % i == 0) {\n            n /= i;\n            count++;\n        }\n        if (count > 0) {\n            factors.insert(factors.end(), count, i);\n        }\n        i++;\n    }\n\n    // Use RVV to vectorize the insertion of factors\n    size_t size = factors.size();\n    size_t vector_length = vsetvl_e32(size);\n    vuint32m1_t v_factors = vundefined_u32m1();\n\n    for (size_t j = 0; j < size; j += vector_length) {\n        size_t vl = std::min(vector_length, size - j);\n        v_factors = vle32_v_u32m1(&factors[j], vl);\n        vse32_v_u32m1(&factors[j], v_factors, vl);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n    int limit = std::sqrt(n) + 1;\n\n    for (int i = 2; i <= limit; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Vectorizing the output\n    size_t size = factors.size();\n    vtype<int> v_factors = vundefined<int>();\n    size_t vector_length = vsetvl_e32(size);\n\n    for (size_t i = 0; i < size; i += vector_length) {\n        size_t vl = std::min(vector_length, size - i);\n        v_factors = vload<int>(&factors[i], vl);\n        vstore<int>(&factors[i], v_factors, vl);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n    \n    // Vector initialization\n    vtype<int> v_n = vsetvl_e32(1);\n    vtype<int> v_factors[32]; // Assuming a maximum of 32 factors for simplicity\n    int count = 0;\n\n    // Factor out 2s\n    while (n % 2 == 0) {\n        v_factors[count++] = 2;\n        n /= 2;\n    }\n\n    // Factor out odd numbers\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            v_factors[count++] = i;\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        v_factors[count++] = n;\n    }\n\n    // Resize the vector to the number of factors found\n    factors.resize(count);\n    \n    // Store factors in the result vector\n    for (int i = 0; i < count; ++i) {\n        factors[i] = v_factors[i];\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            int count = 0;\n            while (n % i == 0) {\n                n /= i;\n                count++;\n            }\n            // Vectorize the addition of factors\n            vtype<int> v_factors = vundefined<int>(vsetvlmax_e32());\n            for (int j = 0; j < count; j++) {\n                v_factors[j] = i;\n            }\n            factors.insert(factors.end(), v_factors.data(), v_factors.data() + count);\n        }\n        i++;\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    size_t result_size = 0;\n\n    vfloat32m1_t vec;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i += 8) {\n        size_t chunk_size = std::min(size_t(8), n - i);\n        vec = vle32_v_f32m1(&l[i], chunk_size);\n        mask = vmslt_v_f32m1(vec, vfmv_v_f_f32m1(0.0f));\n        vec = vmandnot_v_f32m1(vec, mask, vec);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if (l[i + j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    size_t result_size = 0;\n\n    vfloat32m1_t vec;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i += 32) {\n        size_t chunk_size = std::min(size_t(32), n - i);\n        vec = vle32_v_f32m1(&l[i], chunk_size);\n        mask = vmslt_v_f32m1(vec, vfmv_v_f32_m1(0.0f));\n        vec = vselect_v_f32m1(mask, vfmv_v_f32_m1(0.0f), vec);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if (l[i + j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(l.data(), vl);\n    vbool32_t mask = vmslt_v_f32m1_b32(vec, 0.0f);\n    vfloat32m1_t positive_vec = vselect_v_b32(mask, vec, vfmv_v_f_f32m1(0.0f));\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32(n - i);\n        vec = vle32_v_f32m1(l.data() + i, vl);\n        mask = vmslt_v_f32m1_b32(vec, 0.0f);\n        positive_vec = vselect_v_b32(mask, vec, vfmv_v_f_f32m1(0.0f));\n\n        for (size_t j = 0; j < vl; j++) {\n            if (positive_vec[j] > 0.0f) {\n                result.push_back(positive_vec[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    size_t result_size = 0;\n\n    // Create a vector of floats from the input\n    vfloat32m1_t vec = vle32_v_f32m1(l.data());\n\n    // Create a mask for positive values\n    vbool32_t mask = vmslt_v_f32m1(vec, 0.0f);\n    \n    // Count the number of positive values\n    for (size_t i = 0; i < n; i += 32) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t sub_vec = vle32_v_f32m1(l.data() + i);\n        vbool32_t sub_mask = vmslt_v_f32m1(sub_vec, 0.0f);\n        result_size += vpopc_m(sub_mask);\n    }\n\n    // Allocate space for the result\n    result.reserve(result_size);\n\n    // Store positive values in the result vector\n    for (size_t i = 0; i < n; i += 32) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t sub_vec = vle32_v_f32m1(l.data() + i);\n        vbool32_t sub_mask = vmslt_v_f32m1(sub_vec, 0.0f);\n        vfloat32m1_t positive_vec = vmerge_vxm(sub_mask, sub_vec, vfmv_v_f_f32m1(0.0f));\n        vse32_v_f32m1(result.data() + result.size(), positive_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    size_t result_size = 0;\n\n    vfloat32m1_t vec;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i += 32) {\n        size_t chunk_size = std::min(size_t(32), n - i);\n        vec = vle32_v_f32m1(&l[i], chunk_size);\n        mask = vmslt_v_f32m1(vec, vfmv_v_f_f32m1(0.0f));\n        vec = vmerge_vxm_f32m1(vec, vfmv_v_f_f32m1(0.0f), mask);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if (l[i + j] > 0) {\n                result.push_back(l[i + j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    vbool64_t is_prime = vtrue_b64();\n    vint64m1_t i = vmv_v_x_i64m1(3);\n    vint64m1_t step = vmv_v_x_i64m1(2);\n    \n    for (; vmslt_vx_i64m1(is_prime, i, limit); i = vadd_vv_i64m1(i, step)) {\n        vint64m1_t remainder = vrem_vv_i64m1(vmv_v_x_i64m1(n), i);\n        is_prime = vand(is_prime, vmsne_vv_i64m1(remainder, vmv_v_x_i64m1(0)));\n    }\n\n    return vfirst_m_b64(is_prime) != -1;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    vbool64_t is_prime_vec = vtrue_b64();\n    vint64m1_t i_vec = vmv_v_x_i64m1(3);\n    vint64m1_t limit_vec = vmv_v_x_i64m1(limit);\n    vint64m1_t step_vec = vmv_v_x_i64m1(2);\n    \n    while (vfirst_m(is_prime_vec) >= 0) {\n        vbool64_t mask = vmslt_vx_i64m1(is_prime_vec, limit_vec);\n        if (vfirst_m(mask) < 0) break;\n\n        vint64m1_t div_vec = i_vec;\n        vbool64_t div_mask = vmslt_vx_i64m1(div_vec, limit_vec);\n        \n        is_prime_vec = vand_vb64(is_prime_vec, vnot_m(div_mask));\n        i_vec = vadd_vv_i64m1(i_vec, step_vec);\n    }\n\n    return vfirst_m(is_prime_vec) >= 0;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    vbool64_t is_prime = vtrue_b64();\n    vuint64m1_t i = vmv_v_x_u64m1(3);\n    vuint64m1_t step = vmv_v_x_u64m1(2);\n    \n    for (; vmsltu_vx_u64m1(i, limit, 64); i = vadd_u64m1(i, step)) {\n        vuint64m1_t mod = vrem_u64m1(vmv_v_x_u64m1(n), i);\n        is_prime = vand_b64(is_prime, vmsne_u64m1(mod, vmv_v_x_u64m1(0)));\n    }\n\n    return vfirstb(is_prime) == -1;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    vbool64_t is_prime_vec = vmslt_vx_i64_b64(vsetvl_e64m1(1), 1);\n    int64_t i = 3;\n    int64_t step = 2;\n\n    for (; i <= limit; i += step) {\n        vuint64m1_t vec_i = vsetvl_e64m1(1);\n        vuint64m1_t vec_n = vsetvl_e64m1(n);\n        vuint64m1_t vec_div = vdivu_vv_u64m1(vec_n, vec_i);\n        vbool64_t is_divisible = vmule_vv_i64_b64(vec_div, vec_i);\n\n        is_prime_vec = vand_vv_b64(is_prime_vec, vnot_b64(is_divisible));\n    }\n\n    return vfirstb(is_prime_vec);\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    vbool64_t is_prime = vtrue_b64();\n    vuint64m1_t i = vmv_v_x_u64m1(3);\n    vuint64m1_t step = vmv_v_x_u64m1(2);\n    \n    for (; vmsltu_vx_u64m1(i, limit, 64); i = vadd_u64m1(i, step)) {\n        vuint64m1_t num = vmv_v_x_u64m1(n);\n        vuint64m1_t divisor = i;\n        vbool64_t divisible = vmul_u64m1(num, vdiv_u64m1(num, divisor));\n        is_prime = vand(is_prime, vnot(divisible));\n    }\n\n    return vfirst_m(is_prime);\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    vuint8m1_t mask_lower = vmv_v_x_u8m1(0x20); // Mask for case conversion\n    vuint8m1_t mask_upper = vmv_v_x_u8m1(0xDF); // Uppercase mask\n\n    size_t vector_length = vsetvl_e8m1(len);\n    size_t i = 0;\n\n    for (; i + vector_length <= len; i += vector_length) {\n        vuint8m1_t v_data = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i));\n        vuint8m1_t v_result = v_data;\n\n        // Check for lowercase letters\n        vbool8_t lower_mask = vmsltu_vx_u8m1(v_data, 0x7B); // 'z' + 1\n        lower_mask = vand_vb_u8m1(lower_mask, vmsgeu_vx_u8m1(v_data, 0x61)); // 'a'\n\n        // Check for uppercase letters\n        vbool8_t upper_mask = vmsltu_vx_u8m1(v_data, 0x61); // 'a'\n        upper_mask = vand_vb_u8m1(upper_mask, vmsgeu_vx_u8m1(v_data, 0x41)); // 'A'\n\n        // Reverse case\n        v_result = vxor_vv_u8m1(v_result, mask_lower, lower_mask);\n        v_result = vxor_vv_u8m1(v_result, mask_upper, upper_mask);\n\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), v_result);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32; // Convert to uppercase\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32; // Convert to lowercase\n        } else {\n            result[i] = c; // Keep as is\n        }\n    }\n\n    // Check if there are no letters\n    if (std::none_of(s.begin(), s.end(), [](char c) { return std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    vuint8m1_t mask_lower = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), 'a');\n    vuint8m1_t mask_upper = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), 'A');\n    \n    for (size_t i = 0; i < len; i += VLEN) {\n        size_t vl = std::min(VLEN, len - i);\n        vuint8m1_t data = vle8_v_u8m1(s.data() + i);\n        \n        vuint8m1_t lower_case = vand_vv_u8m1(data, mask_lower);\n        vuint8m1_t upper_case = vand_vv_u8m1(data, mask_upper);\n        \n        vuint8m1_t result_lower = vadd_vx_u8m1(lower_case, 'A' - 'a');\n        vuint8m1_t result_upper = vadd_vx_u8m1(upper_case, 'a' - 'A');\n        \n        vuint8m1_t result_data = vor_vv_u8m1(result_lower, result_upper);\n        vse8_v_u8m1(result.data() + i, result_data);\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    vuint8m1_t mask = vundefined_u8m1();\n    vuint8m1_t lower_mask = vmv_v_x_u8m1(0x20); // Mask for toggling case\n    vuint8m1_t ascii_a = vmv_v_x_u8m1('a');\n    vuint8m1_t ascii_z = vmv_v_x_u8m1('z');\n    vuint8m1_t ascii_A = vmv_v_x_u8m1('A');\n    vuint8m1_t ascii_Z = vmv_v_x_u8m1('Z');\n\n    size_t vector_length = vsetvl_e8m1(n);\n    for (size_t i = 0; i < n; i += vector_length) {\n        size_t vl = std::min(vector_length, n - i);\n        vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), vl);\n\n        vbool8_t is_lower = vmslt_u8m1(vec, ascii_z);\n        vbool8_t is_upper = vmsge_u8m1(vec, ascii_A);\n        vbool8_t is_letter = vandb(is_lower, is_upper);\n\n        vuint8m1_t toggled_case = vxor_vv_u8m1(vec, lower_mask);\n        vec = vmerge_vx_u8m1(vec, toggled_case, is_letter);\n\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), vec, vl);\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    vuint8m1_t mask_lower = vmv_v_x_u8m1(0x20); // Mask for case conversion\n    vuint8m1_t mask_upper = vmv_v_x_u8m1(0xDF); // Mask for case conversion\n    vbool8_t is_letter_mask;\n    \n    for (size_t i = 0; i < len; i += 8) {\n        size_t vl = std::min(8UL, len - i);\n        vuint8m1_t vec_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), vl);\n        \n        is_letter_mask = vmsltu_vx_u8m1(vec_chars, 0x5B); // Check if less than 'Z'+1\n        is_letter_mask = vmand(is_letter_mask, vmsgeu_vx_u8m1(vec_chars, 0x61)); // Check if greater than 'a'-1\n        \n        vuint8m1_t upper_case = vand(is_letter_mask, vadd_vx_u8m1(vec_chars, mask_lower)); // Convert to upper case\n        vuint8m1_t lower_case = vandnot(is_letter_mask, vadd_vx_u8m1(vec_chars, mask_upper)); // Convert to lower case\n        \n        vec_chars = vor(upper_case, lower_case); // Combine results\n        \n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), vec_chars, vl);\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    vuint8m1_t mask_lower = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), 'a');\n    vuint8m1_t mask_upper = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), 'A');\n    vuint8m1_t mask_digit = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), '0');\n    vuint8m1_t mask_special = vmsltu_vx_u8m1(vle8_v_u8m1(s.data()), 'Z');\n\n    for (size_t i = 0; i < len; i += VLEN) {\n        size_t vl = std::min(VLEN, len - i);\n        vuint8m1_t vec = vle8_v_u8m1(s.data() + i);\n        \n        vuint8m1_t lower_case = vmsltu_vx_u8m1(vec, 'a');\n        vuint8m1_t upper_case = vmsltu_vx_u8m1(vec, 'A');\n        \n        vec = vadd_vx_u8m1(vec, 32); // Toggle case\n        vec = vmerge_vxm_u8m1(vec, vec, lower_case); // Keep original if not lower\n        vec = vmerge_vxm_u8m1(vec, vec, upper_case); // Keep original if not upper\n        \n        vse8_v_u8m1(result.data() + i, vec);\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Place sorted elements back into the result vector\n    size_t sort_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (sort_index < to_sort.size()) {\n                result[i] = to_sort[sort_index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_len = vsetvl_e32(n);\n    vtype<int> v_l = vle32_v_i32(l.data(), vec_len);\n    \n    std::vector<int> sorted_third;\n    \n    for (size_t i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            sorted_third.push_back(l[i]);\n            sorted_third.push_back(l[i + 1]);\n            sorted_third.push_back(l[i + 2]);\n        } else {\n            for (size_t j = i; j < n; ++j) {\n                sorted_third.push_back(l[j]);\n            }\n        }\n    }\n\n    std::sort(sorted_third.begin(), sorted_third.end());\n\n    std::vector<int> result(n);\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            result[i] = sorted_third.back();\n            sorted_third.pop_back();\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_len = vsetvl_e32(n);\n    std::vector<int> result(n);\n    \n    // Step 1: Collect elements at indices divisible by 3\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    // Step 2: Sort the collected elements\n    std::sort(to_sort.begin(), to_sort.end());\n    \n    // Step 3: Fill the result vector\n    size_t sort_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = to_sort[sort_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_len = vsetvl_e32(n);\n    vtype<int> vec_l[vec_len];\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        size_t len = std::min(vec_len, n - i);\n        for (size_t j = 0; j < len; j++) {\n            vec_l[j] = l[i + j];\n        }\n\n        // Sort values at indices divisible by 3\n        std::vector<int> to_sort;\n        for (size_t j = 0; j < len; j++) {\n            if ((i + j) % 3 == 0) {\n                to_sort.push_back(vec_l[j]);\n            }\n        }\n        std::sort(to_sort.begin(), to_sort.end());\n\n        // Place sorted values back into the vector\n        size_t sort_index = 0;\n        for (size_t j = 0; j < len; j++) {\n            if ((i + j) % 3 == 0) {\n                vec_l[j] = to_sort[sort_index++];\n            }\n        }\n\n        for (size_t j = 0; j < len; j++) {\n            l[i + j] = vec_l[j];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_len = vsetvl_e32(n);\n    vtype<int> v_l = vle32_v_i32(&l[0], vec_len);\n    \n    std::vector<int> sorted_third;\n    \n    for (size_t i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            sorted_third.push_back(l[i]);\n            sorted_third.push_back(l[i + 1]);\n            sorted_third.push_back(l[i + 2]);\n        } else {\n            for (size_t j = i; j < n; j++) {\n                sorted_third.push_back(l[j]);\n            }\n        }\n    }\n    \n    std::vector<int> third_values;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i + 2 < n) {\n            third_values.push_back(l[i + 2]);\n        }\n    }\n    \n    std::sort(third_values.begin(), third_values.end());\n    \n    for (size_t i = 0, j = 0; i < n; i++) {\n        if (i % 3 == 0 && j < third_values.size()) {\n            l[i] = third_values[j++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return 0; // Handle empty vector case if needed\n\n    vfloat32m1_t max_vec = vfmv_v_f_f32m1(l[0], n);\n    for (size_t i = 1; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = std::min(n - i, (size_t) vsetvl_e32m1(n - i));\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vl);\n        max_vec = vfredmax_vs_f32m1(max_vec, vec, max_vec);\n    }\n\n    float max_val = 0;\n    vfmv_f_s_f32(&max_val, max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    vfloat32m1_t max_vec = vfmv_v_f_f32m1(l[0], n);\n    \n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vl);\n        max_vec = vmax_vv_f32m1(max_vec, vec, vl);\n    }\n    \n    float max_val = vfmv_f_s_f32(max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return 0; // Handle empty case, though the problem states non-empty vector\n\n    vfloat32m1_t max_vec = vfmv_v_f_f32m1(l[0], n);\n    for (size_t i = 1; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = std::min(n - i, (size_t) vsetvl_e32m1(n - i));\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vl);\n        max_vec = vfredmax_vs_f32m1(max_vec, vec, max_vec);\n    }\n\n    float max_val = vfmv_f_s_f32(max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n\n    for (size_t i = 0; i < n; i += VLEN / sizeof(float)) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i]);\n        max_val = std::max(max_val, vfredmax_vs_f32m1(vec, max_val, 0));\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n\n    for (size_t i = 0; i < n; i += VEC_LEN) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i]);\n        max_val = std::max(max_val, vfredmax_vs_f32m1(vec, max_val, vundefined_f32m1()));\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_digit_seven(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = vsetvl_e32(8); // Set vector length for 32-bit integers\n    vuint32m8_t indices = vundefined_u32m8(); // Vector to hold indices\n    vuint32m8_t results = vundefined_u32m8(); // Vector to hold results\n\n    for (int i = 0; i < n; i += vector_size) {\n        // Load indices\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n) {\n                indices = vset_v_u32m8(i + j);\n            }\n        }\n\n        // Check divisibility by 11 or 13\n        vbool8_t mask = vmslt_u32m8(indices, vset_v_u32m8(n));\n        vbool8_t divisible = vmand_b8(mask, vmsle_u32m8(vremu32m8(indices, vset_v_u32m8(11)), vset_v_u32m8(0)));\n        divisible = vmand_b8(divisible, vmsle_u32m8(vremu32m8(indices, vset_v_u32m8(13)), vset_v_u32m8(0)));\n\n        // Count occurrences of digit 7\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n && vtest_u8(mask, j)) {\n                results[j] = count_digit_seven(i + j);\n            }\n        }\n\n        // Sum up results\n        count += vreduce_add_u32m8(results);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint count_digit_seven(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz_simd(int n) {\n    int total_count = 0;\n    int vector_size = vsetvl_e32(8); // Set vector length for 32-bit integers\n    vuint32m8_t indices = vundefined_u32m8(); // Vector to hold indices\n    vuint32m8_t results = vundefined_u32m8(); // Vector to hold results\n\n    for (int i = 0; i < n; i += vector_size) {\n        // Load indices into vector\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n) {\n                indices = vslide1down_u32m8(indices, vundefined_u32m8(), i + j);\n            }\n        }\n\n        // Check divisibility by 11 or 13\n        vbool8_t mask = vmslt_u32m8(indices, vsetvl_e32(11));\n        vbool8_t mask2 = vmslt_u32m8(indices, vsetvl_e32(13));\n        vbool8_t final_mask = vior_b8(mask, mask2);\n\n        // Count occurrences of digit 7\n        results = vundefined_u32m8();\n        for (int j = 0; j < vector_size; j++) {\n            if (final_mask[j]) {\n                results[j] = count_digit_seven(indices[j]);\n            }\n        }\n\n        // Sum up results\n        total_count += vreduce_add_u32m8(results);\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint count_digit_seven(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = vsetvl_e32(8); // Set vector length for 32-bit integers\n    vuint32m8_t indices = vundefined_u32m8(); // Vector to hold indices\n    vuint32m8_t results = vundefined_u32m8(); // Vector to hold results\n\n    for (int i = 0; i < n; i += vector_size) {\n        indices = vadd_vx_u32m8(vle32_v_u32m8(&i, vector_size), vsetvl_e32(0)); // Load indices\n        vbool8_t mask = vmsltu_vx_u32m8(indices, n); // Create mask for valid indices\n\n        vuint32m8_t divisible_by_11 = vremu_vx_u32m8(indices, 11); // Check divisibility by 11\n        vuint32m8_t divisible_by_13 = vremu_vx_u32m8(indices, 13); // Check divisibility by 13\n        vbool8_t is_divisible = vorr_vv_mask_u32m8(mask, vmsne_vx_u32m8(divisible_by_11, 0), vmsne_vx_u32m8(divisible_by_13, 0)); // Combine masks\n\n        results = vadd_vx_u32m8(results, vle32_v_u32m8(&count_digit_seven(i), vector_size)); // Count digit 7\n        count += vpopc_m(mask, results); // Count the number of 7s\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = vsetvl_e32(8); // Set vector length for 32-bit integers\n    vuint32m8_t indices = vundefined_u32m8(); // Vector to hold indices\n    vuint32m8_t results = vundefined_u32m8(); // Vector to hold results\n    vuint32m8_t seven_count = vundefined_u32m8(); // Vector to count occurrences of 7\n\n    for (int i = 0; i < n; i += vector_size) {\n        // Load indices into vector\n        indices = vle32_v_u32m8(&i, vector_size);\n        \n        // Check divisibility by 11 or 13\n        vbool8_t mask = vmsltu_vx_u32m8(indices, n);\n        vuint32m8_t divisible = vand_vx_u32m8(indices, 11);\n        vuint32m8_t divisible_by_13 = vand_vx_u32m8(indices, 13);\n        results = vor_vv_u32m8(divisible, divisible_by_13);\n        \n        // Count occurrences of digit 7\n        for (int j = 0; j < vector_size; j++) {\n            if (mask[j]) {\n                int num = indices[j];\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        seven_count[j]++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    // Sum up the counts\n    count = vreduce_add_u32m8(seven_count);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint count_digit_7(int num) {\n    int count = 0;\n    while (num > 0) {\n        if (num % 10 == 7) {\n            count++;\n        }\n        num /= 10;\n    }\n    return count;\n}\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = vsetvl_e32(8); // Set vector length for 32-bit integers\n    vuint32m8_t indices = vundefined_u32m8(); // Vector to hold indices\n    vuint32m8_t results = vundefined_u32m8(); // Vector to hold results\n\n    for (int i = 0; i < n; i += vector_size) {\n        // Load indices\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n) {\n                indices = vslide1down_u32m8(indices, vundefined_u32m8(), i + j);\n            }\n        }\n\n        // Check divisibility by 11 or 13\n        vbool8_t mask = vmslt_u32m8(indices, vsetvl_e32(11));\n        vbool8_t mask13 = vmslt_u32m8(indices, vsetvl_e32(13));\n        vbool8_t combined_mask = vorr_vb(mask, mask13);\n\n        // Count occurrences of digit 7\n        results = vundefined_u32m8();\n        for (int j = 0; j < vector_size; j++) {\n            if (combined_mask[j]) {\n                results[j] = count_digit_7(i + j);\n            }\n        }\n\n        // Sum the results\n        count += vreduce_add_u32m8(results);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2; // Count of even indices\n\n    // Create a vector to hold even indexed elements\n    std::vector<float> even_elements(even_count);\n    size_t even_index = 0;\n\n    // Extract even indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements[even_index++] = l[i];\n    }\n\n    // Sort the even indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create a result vector\n    std::vector<float> result(n);\n\n    // Fill the result vector with sorted even elements and original odd elements\n    size_t even_pos = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_elements[even_pos++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2; // Count of even indices\n    std::vector<float> even_values(even_count);\n\n    // Extract even indexed values\n    for (size_t i = 0; i < n; i += 2) {\n        even_values[i / 2] = l[i];\n    }\n\n    // Sort the even indexed values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Create the result vector\n    std::vector<float> result(n);\n    size_t even_index = 0;\n\n    // Fill the result vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2; // Count of even indices\n    std::vector<float> even_values(even_count);\n\n    // Extract even indexed values\n    for (size_t i = 0; i < n; i += 2) {\n        even_values[i / 2] = l[i];\n    }\n\n    // Sort the even indexed values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Create the result vector\n    std::vector<float> result(n);\n    size_t even_index = 0;\n\n    // Fill the result vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2; // Count of even indices\n    std::vector<float> even_values(even_count);\n\n    // Extract even indexed values\n    for (size_t i = 0; i < n; i += 2) {\n        even_values[i / 2] = l[i];\n    }\n\n    // Sort the even indexed values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Create the result vector\n    std::vector<float> result(n);\n    size_t even_index = 0;\n\n    // Fill the result vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2; // Count of even indices\n    std::vector<float> even_values(even_count);\n\n    // Extract even indexed values\n    for (size_t i = 0; i < n; i += 2) {\n        even_values[i / 2] = l[i];\n    }\n\n    // Sort the even indexed values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Create the result vector\n    std::vector<float> result(n);\n    size_t even_index = 0;\n\n    // Fill the result vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_values[even_index++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; i++) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; i++) {\n        std::unordered_set<int> seen;\n        vint32m4_t vec_a = vle32_v_i32m4(&l[i], n - i);\n        \n        for (int j = i + 1; j < n; j++) {\n            int complement = -l[i] - l[j];\n            if (seen.find(complement) != seen.end()) {\n                return true;\n            }\n            seen.insert(l[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        vint32m4_t vec_a = vle32_v_i32m4(&l[i], 1);\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            vint32m4_t vec_b = vle32_v_i32m4(&l[j], 1);\n            for (size_t k = j + 1; k < n; ++k) {\n                vint32m4_t vec_c = vle32_v_i32m4(&l[k], 1);\n                vint32m4_t sum = vadd_vv_i32m4(vec_a, vec_b);\n                sum = vadd_vv_i32m4(sum, vec_c);\n                if (vredsum_vs_i32m4(sum, 0) == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        vint32m4_t vi = vle32_v_i32m4(&l[i], 1);\n        for (int j = i + 1; j < n - 1; ++j) {\n            vint32m4_t vj = vle32_v_i32m4(&l[j], 1);\n            for (int k = j + 1; k < n; ++k) {\n                vint32m4_t vk = vle32_v_i32m4(&l[k], 1);\n                vint32m4_t sum = vadd_vv_i32m4(vi, vj);\n                sum = vadd_vv_i32m4(sum, vk);\n                if (vfirst_m_b32(sum, 0) == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        vint32m4_t a = vle32_v_i32m4(&l[i], n - i);\n        for (int j = i + 1; j < n - 1; ++j) {\n            vint32m4_t b = vle32_v_i32m4(&l[j], n - j);\n            for (int k = j + 1; k < n; ++k) {\n                vint32m4_t c = vle32_v_i32m4(&l[k], n - k);\n                vint32m4_t sum = vadd_vv_i32m4(a, b);\n                sum = vadd_vv_i32m4(sum, c);\n                if (vfirst_m_b32(sum) == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    int *input_ptr = l.data();\n    int *output_ptr = result.data();\n    \n    size_t vl;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32(n - i);\n        vuint32m1_t v_input = vle32_v_u32m1(input_ptr + i, vl);\n        v_input = vadd_vx_u32m1(v_input, 1, vl);\n        vse32_v_u32m1(output_ptr + i, v_input, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Define the vector length\n    size_t vl = vsetvl_e32(n);\n\n    // Load the input vector\n    vuint32m1_t vec = vle32_v_u32m1(l.data(), vl);\n    \n    // Increment the vector\n    vuint32m1_t incremented_vec = vadd_vv_u32m1(vec, vmv_v_x_u32m1(1, vl), vl);\n    \n    // Store the result\n    vse32_v_u32m1(result.data(), incremented_vec, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    int *input_ptr = l.data();\n    int *output_ptr = result.data();\n    \n    size_t vl = vsetvl_e32(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32(n - i);\n        vuint32m1_t v_input = vle32_v_u32m1(input_ptr + i);\n        vuint32m1_t v_output = vadd_vu_u32m1(v_input, 1);\n        vse32_v_u32m1(output_ptr + i, v_output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Create a vector of integers with value 1\n    vtype<int> increment_vector = vsetvl_n_u32(1);\n    \n    // Process the vector in chunks\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = vsetvl_n_u32(n - i);\n        vuint32m1_t input_vector = vle32_v_u32m1(&l[i], vl);\n        vuint32m1_t output_vector = vadd_vv_u32m1(input_vector, increment_vector, vl);\n        vse32_v_u32m1(&result[i], output_vector, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Load vector elements\n    vtype<int> v_l = vle32_v_i32(l.data(), n);\n    \n    // Increment each element by 1\n    vtype<int> v_result = vadd_vv_i32(v_l, vmv_v_x_i32(1, n));\n    \n    // Store the result back to the output vector\n    vse32_v_i32(result.data(), v_result, n);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    vtype<int> v_len = vsetvl_e32(n);\n    vtype<int> v_zero = vundefined_e32();\n    vtype<int> v_neg = vundefined_e32();\n    \n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += v_len) {\n        vtype<int> v_data = vle32_v_i32(&l[i]);\n        vtype<int> v_neg_data = vsub_vv_i32(v_zero, v_data);\n        \n        for (size_t j = 0; j < v_len; j++) {\n            int element = v_data[j];\n            if (seen.count(element) > 0) {\n                return true;\n            }\n            seen.insert(v_neg_data[j]);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    vtype<int> vec_size = vsetvl_e32(n);\n    vtype<int> vec_l = vle32_v_i32(l.data(), vec_size);\n    \n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = std::min(vlen, n - i);\n        vtype<int> vec_l_part = vle32_v_i32(l.data() + i, vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int value = vec_l_part[j];\n            if (seen.count(-value)) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    vtype<int> *vec = new vtype<int>[n];\n    for (size_t i = 0; i < n; i++) {\n        vec[i] = l[i];\n    }\n\n    std::unordered_set<int> seen;\n    size_t vl = vsetvl_e32(n);\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t current_vl = std::min(vl, n - i);\n        vtype<int> v = vle32_v_i32(vec + i, current_vl);\n\n        for (size_t j = 0; j < current_vl; j++) {\n            int value = v[j];\n            if (seen.count(-value)) {\n                delete[] vec;\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n\n    delete[] vec;\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    vtype<int> v_size = vsetvl_e32(n);\n    vtype<int> v_elements = vle32_v_i32(l.data(), v_size);\n    \n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += v_size) {\n        vtype<int> v_current = vle32_v_i32(l.data() + i, vsetvl_e32(n - i));\n        for (size_t j = 0; j < v_size; ++j) {\n            int current = v_current[j];\n            if (seen.count(-current)) {\n                return true;\n            }\n            seen.insert(current);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    vtype<int> v_size = vsetvl_e32(n);\n    vtype<int> v_data = vle32_v_i32(l.data(), v_size);\n    \n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; i += v_size) {\n        vtype<int> v_chunk = vle32_v_i32(l.data() + i, vsetvl_e32(n - i));\n        for (size_t j = 0; j < v_size; ++j) {\n            int value = v_chunk[j];\n            if (seen.count(-value)) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\"; // Invalid base check\n\n    std::vector<char> result;\n    int64_t num = x;\n\n    while (num > 0) {\n        int64_t remainder = num % base;\n        result.push_back('0' + remainder);\n        num /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    // Convert to string\n    std::string result_str(result.begin(), result.end());\n    return result_str;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::vector<char> result;\n    int64_t temp = x;\n\n    while (temp > 0) {\n        result.push_back((temp % base) + '0');\n        temp /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    size_t len = result.size();\n    vuint8m1_t vec_result = vundefined_u8m1();\n    for (size_t i = 0; i < len; i += 8) {\n        size_t n = std::min(size_t(8), len - i);\n        vuint8m1_t vec_digits = vle8_v_u8m1(&result[i]);\n        vec_result = vadd_vv_u8m1(vec_result, vec_digits);\n    }\n\n    std::string final_result;\n    for (size_t i = 0; i < len; i++) {\n        final_result.push_back(result[i]);\n    }\n\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t temp = x;\n\n    while (temp > 0) {\n        result.push_back(temp % base + '0');\n        temp /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    // Convert vector to string\n    std::string str_result(result.begin(), result.end());\n    return str_result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t temp = x;\n    \n    while (temp > 0) {\n        result.push_back(temp % base + '0');\n        temp /= base;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    \n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\"; // Invalid base\n\n    std::vector<char> result;\n    int64_t num = x;\n    while (num > 0) {\n        result.push_back((num % base) + '0');\n        num /= base;\n    }\n\n    std::reverse(result.begin(), result.end());\n\n    size_t len = result.size();\n    vuint8m1_t vec_result = vundefined_u8m1();\n    for (size_t i = 0; i < len; i += 16) {\n        size_t count = std::min(size_t(16), len - i);\n        vuint8m1_t vec_digits = vle8_v_u8m1(&result[i]);\n        vse8_v_u8m1(&vec_result, vec_digits);\n    }\n\n    std::string str_result(reinterpret_cast<char*>(&vec_result), len);\n    return str_result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int vector_length = vsetvl_e8m1(len);\n    vuint8m1_t left, right;\n\n    for (int i = 0; i < len / 2; i += vector_length) {\n        int remaining = len - i;\n        int vl = remaining < vector_length ? remaining : vector_length;\n\n        left = vle8_v_u8m1((const uint8_t*)text.c_str() + i, vl);\n        right = vle8_v_u8m1((const uint8_t*)text.c_str() + (len - i - vl), vl);\n\n        if (vmfirst_m(vmsne_vv_u8m1(left, right, vl))) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n == 0) return true;\n\n    vuint8m1_t vec_left, vec_right;\n    for (int i = 0; i < n / 2; i += 16) {\n        int len = std::min(16, n / 2 - i);\n        vec_left = vle8_v_u8m1((const uint8_t*)(text.c_str() + i));\n        vec_right = vle8_v_u8m1((const uint8_t*)(text.c_str() + n - 1 - i - len + 1));\n\n        if (vredsum_vs_u8m1(vec_left, vec_right, 0) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    vuint8m1_t vec_left, vec_right;\n    for (int i = 0; i < len / 2; i += VEC_WIDTH) {\n        int remaining = len - i;\n        int load_size = remaining < VEC_WIDTH ? remaining : VEC_WIDTH;\n\n        vec_left = vle8_v_u8m1((const uint8_t*)&text[i]);\n        vec_right = vle8_v_u8m1((const uint8_t*)&text[len - i - load_size]);\n\n        if (vredsum_vs_u8m1(vec_left, vec_right, 0) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int vector_length = vsetvl_e8m1(len);\n    vbool8_t result = vmslt_vx_i8m1(vle8_v_i8m1((const int8_t*)text.c_str(), vector_length), 0);\n    \n    for (int i = 0; i < len / 2; i += vector_length) {\n        vuint8m1_t left = vle8_v_u8m1((const uint8_t*)text.c_str() + i, vector_length);\n        vuint8m1_t right = vle8_v_u8m1((const uint8_t*)text.c_str() + len - i - vector_length, vector_length);\n        \n        vbool8_t cmp = vmfne_vv_u8m1(left, right, vector_length);\n        result = vorr_vv_b8(result, cmp);\n    }\n\n    return vfirst_m_b8(result) == -1;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int vector_length = vsetvl_e8m1(len);\n    vuint8m1_t left, right;\n\n    for (int i = 0; i < len / 2; i += vector_length) {\n        int vl = std::min(vector_length, len / 2 - i);\n        left = vle8_v_u8m1((const uint8_t*)text.c_str() + i, vl);\n        right = vle8_v_u8m1((const uint8_t*)text.c_str() + len - 1 - i, vl);\n        \n        if (vredsum_vs_u8m1(left, right, vl) != vl) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    int len = s.length();\n    std::string out(len, ' ');\n\n    // Vector length and initialization\n    const int vector_length = 64; // Assuming a vector length of 64 bytes\n    int num_vectors = (len + vector_length - 1) / vector_length;\n\n    for (int v = 0; v < num_vectors; v++) {\n        int start = v * vector_length;\n        int end = std::min(start + vector_length, len);\n\n        // Load characters into vector\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + start));\n\n        // Decode by shifting back 5 positions\n        vuint8m1_t vec_decoded = vadd_vu8m1(vec_chars, 251); // 251 = 256 - 5\n        vec_decoded = vsub_vu8m1(vec_decoded, 1); // Adjust for modulo wrap around\n\n        // Store the result back to output string\n        vse8_v_u8m1((uint8_t*)(out.data() + start), vec_decoded);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8m1(len);\n\n    // Load characters into vector\n    vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)s.data(), vl);\n\n    // Decode by shifting back 5\n    vuint8m1_t vec_decoded = vadd_vx_u8m1(vec_chars, -5, vl);\n    vec_decoded = vmsub_vx_u8m1(vec_decoded, 1, 26, vl); // Wrap around for underflow\n    vec_decoded = vadd_vx_u8m1(vec_decoded, 26, vl); // Ensure non-negative\n\n    // Store the result back to output string\n    vse8_v_u8m1((uint8_t*)out.data(), vec_decoded, vl);\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    int len = s.length();\n    std::string out(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8m1(len);\n\n    // Load characters into vector\n    vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)s.data(), vl);\n\n    // Decode by shifting back by 5\n    vuint8m1_t vec_decoded = vadd_vx_u8m1(vec_chars, -5, vl);\n    vec_decoded = vremu_vx_u8m1(vec_decoded, 26, vl);\n    vec_decoded = vadd_vx_u8m1(vec_decoded, 'a', vl);\n\n    // Store the result back to output string\n    vse8_v_u8m1((uint8_t*)out.data(), vec_decoded, vl);\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    int len = s.length();\n    std::string out(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8m1(len);\n\n    // Load the input string into a vector\n    vuint8m1_t vec_input = vle8_v_u8m1((const uint8_t*)s.c_str(), vl);\n\n    // Subtract 5 and wrap around using modulo 26\n    vuint8m1_t vec_decoded = vadd_vx_u8m1(vec_input, -5, vl);\n    vec_decoded = vadd_vx_u8m1(vec_decoded, 26, vl);\n    vec_decoded = vremu_vx_u8m1(vec_decoded, 26, vl);\n    vec_decoded = vadd_vx_u8m1(vec_decoded, 'a', vl);\n\n    // Store the result back to the output string\n    vse8_v_u8m1((uint8_t*)out.data(), vec_decoded, vl);\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    int len = s.length();\n    std::string out(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8m1(len);\n\n    // Process in chunks\n    for (int i = 0; i < len; i += vl) {\n        // Load characters into vector\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)&s[i]);\n\n        // Decode by shifting back 5\n        vuint8m1_t vec_decoded = vadd_vx_u8m1(vec_chars, -5);\n\n        // Wrap around for characters less than 'a'\n        vuint8m1_t vec_a = vmv_v_x_u8m1('a');\n        vuint8m1_t vec_z = vmv_v_x_u8m1('z');\n        vuint8m1_t vec_mask = vmsltu_vv_u8m1(vec_decoded, vec_a);\n        vec_decoded = vadd_vx_u8m1(vec_decoded, 26);\n        vec_decoded = vmerge_vv_u8m1(vec_decoded, vec_chars, vec_mask);\n\n        // Store the result back to output string\n        vse8_v_u8m1((uint8_t*)&out[i], vec_decoded);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl = vsetvl_e32(n);\n    vbool32_t result = vmslt_vx_i32(vle32_v_i32(l.data(), vl), t, vl);\n    \n    for (size_t i = 0; i < vl; i++) {\n        if (!result[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    vbool32_t result = vmslt_vx_i32(vle32_v_i32(l.data()), t);\n    for (size_t i = 0; i < n; i += 32) {\n        size_t vl = std::min(32, n - i);\n        vbool32_t temp = vmslt_vx_i32(vle32_v_i32(l.data() + i), t);\n        result = vand_vb(result, temp);\n    }\n    return vmfirst_m(result) == -1;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    vtype<int> v_t = vsetvl_n_u32(n);\n    vint32m1_t v_threshold = vmv_v_x_i32m1(t, v_t);\n    vint32m1_t v_result = vundefined_i32m1();\n\n    for (size_t i = 0; i < n; i += vsetvl_n_u32(n)) {\n        vint32m1_t v_data = vle32_v_i32m1(&l[i]);\n        v_result = vredmin_vs_i32m1(v_result, v_data, v_result);\n    }\n\n    return vmsltu_vv_i32m1(v_result, v_threshold);\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    vtype<int> v_t = vsetvl_e32(n);\n    vint32m1_t v_threshold = vmv_v_x_i32m1(t, v_t);\n    vint32m1_t v_data;\n\n    for (size_t i = 0; i < n; i += vsetvl_e32(n)) {\n        size_t vl = vsetvl_e32(n - i);\n        v_data = vle32_v_i32m1(&l[i], vl);\n        if (vredmin_i32m1(vle32_v_i32m1(&l[i], vl), v_data) >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    vtype<int> threshold = vsetvl_e32m1(n);\n    vint32m1_t v_threshold = vmv_v_x_i32m1(t, threshold);\n    vint32m1_t v_result = vmv_v_x_i32m1(1, threshold); // Initialize to true (1)\n\n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_data = vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = vmslt_vx_i32m1(v_data, v_threshold);\n        v_result = vand_vx_i32m1(v_result, mask);\n    }\n\n    return vfirst_m_b32(v_result) == 0; // If all are true, return true\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    if (n % 2 != 0) return false;\n\n    vuint8m1_t open_count = vdup_u8(0);\n    vuint8m1_t close_count = vdup_u8(0);\n\n    for (int i = 0; i < n; i += 16) {\n        vuint8m1_t vec = vle8_v_u8m1(&brackets[i]);\n        vuint8m1_t open_mask = vmseq_vx_u8m1(vec, '<');\n        vuint8m1_t close_mask = vmseq_vx_u8m1(vec, '>');\n\n        open_count = vadd_vv_u8m1(open_count, vmsum_vx_u8m1(open_mask, 1));\n        close_count = vadd_vv_u8m1(close_count, vmsum_vx_u8m1(close_mask, 1));\n    }\n\n    uint8_t open_sum = vreduce_add_u8(open_count);\n    uint8_t close_sum = vreduce_add_u8(close_count);\n\n    return open_sum == close_sum;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    int vector_length = vsetvl_e8m1(len);\n    vuint8m1_t open_count = vundefined_u8m1();\n    vuint8m1_t close_count = vundefined_u8m1();\n\n    for (int i = 0; i < len; i += vector_length) {\n        int vl = std::min(vector_length, len - i);\n        vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        \n        open_count = vadd_u8(open_count, vwmul_vx_u8(vle8_v_u8m1(reinterpret_cast<const uint8_t*>(\"<\"), 1), vl));\n        close_count = vadd_u8(close_count, vwmul_vx_u8(vle8_v_u8m1(reinterpret_cast<const uint8_t*>(\">\"), 1), vl));\n        \n        for (int j = 0; j < vl; j++) {\n            if (vec[j] == '<') {\n                open_count++;\n            } else if (vec[j] == '>') {\n                close_count++;\n            }\n        }\n    }\n\n    return vmsltu_vv_u8m1(open_count, close_count) == 0 && vmsltu_vv_u8m1(close_count, open_count) == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    int vector_length = vsetvl_e8m1(n);\n    vuint8m1_t open_count = vdup_v_u8m1(0);\n    vuint8m1_t close_count = vdup_v_u8m1(0);\n\n    for (int i = 0; i < n; i += vector_length) {\n        int vl = std::min(vector_length, n - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t *)(brackets.data() + i), vl);\n        \n        open_count = vadd_vv_u8m1(open_count, vwmul_vx_u8m1(vsltu_vx_u8m1(vec, 60), 1, vl), vl);\n        close_count = vadd_vv_u8m1(close_count, vwmul_vx_u8m1(vsltu_vx_u8m1(vec, 62), 1, vl), vl);\n    }\n\n    uint8_t open_result[vector_length];\n    uint8_t close_result[vector_length];\n    vse8_v_u8m1(open_result, open_count, vector_length);\n    vse8_v_u8m1(close_result, close_count, vector_length);\n\n    int total_open = 0, total_close = 0;\n    for (int j = 0; j < vector_length; j++) {\n        total_open += open_result[j];\n        total_close += close_result[j];\n    }\n\n    return total_open == total_close;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    size_t vl = vsetvl_e8m1(n);\n    vuint8m1_t open_count = vdup_v_u8m1(0);\n    vuint8m1_t close_count = vdup_v_u8m1(0);\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t current_vl = std::min(vl, n - i);\n        vuint8m1_t v_brackets = vle8_v_u8m1(&brackets[i]);\n        \n        open_count = vadd_vv_u8m1(open_count, vwmul_vx_u8m1(v_brackets, 1)); // Count '<'\n        close_count = vadd_vv_u8m1(close_count, vwmul_vx_u8m1(v_brackets, 2)); // Count '>'\n    }\n\n    uint8_t total_open = vreduce_add_u8m1(open_count);\n    uint8_t total_close = vreduce_add_u8m1(close_count);\n\n    return total_open == total_close;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    if (n % 2 != 0) return false;\n\n    vuint8m1_t open_count = vdup_u8(0);\n    vuint8m1_t close_count = vdup_u8(0);\n    \n    for (int i = 0; i < n; i += vsetvl_e8m1(n - i)) {\n        int vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)brackets.c_str() + i, vl);\n        \n        open_count = vadd_u8(open_count, vwmul_vx_u8m1(vle8_v_u8m1((const uint8_t*)brackets.c_str() + i, vl), vdup_u8(1), vl));\n        close_count = vadd_u8(close_count, vwmul_vx_u8m1(vle8_v_u8m1((const uint8_t*)brackets.c_str() + i, vl), vdup_u8(0), vl));\n    }\n\n    uint8_t open_result = vreduce_add_u8(open_count);\n    uint8_t close_result = vreduce_add_u8(close_count);\n\n    return open_result == close_result;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    int vector_length = vsetvl_e8m1(n); // Set vector length based on the size of the input\n    vuint8m1_t count_open = vdup_u8(0); // Vector to count '('\n    vuint8m1_t count_close = vdup_u8(0); // Vector to count ')'\n\n    for (int i = 0; i < n; i += vector_length) {\n        int vl = std::min(vector_length, n - i);\n        vuint8m1_t vec_brackets = vle8_v_u8m1(&brackets[i], vl);\n\n        // Count '('\n        count_open = vadd_u8(count_open, vmseq_vx_u8m1(vec_brackets, '(', vl));\n        // Count ')'\n        count_close = vadd_u8(count_close, vmseq_vx_u8m1(vec_brackets, ')', vl));\n    }\n\n    // Sum up the counts\n    uint8_t open_count = vreduce_add_u8(count_open);\n    uint8_t close_count = vreduce_add_u8(count_close);\n\n    return open_count == close_count;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    if (n == 0) return true;\n\n    vuint8m1_t open_count = vdup_u8(0);\n    vuint8m1_t close_count = vdup_u8(0);\n\n    for (int i = 0; i < n; i += 8) {\n        vuint8m1_t vec = vle8_v_u8(&brackets[i]);\n        open_count = vadd_u8(open_count, vwmul_vx_u8(vle8_v_u8(&brackets[i]), 1));\n        close_count = vadd_u8(close_count, vwmul_vx_u8(vle8_v_u8(&brackets[i]), -1));\n    }\n\n    uint8_t open_sum = vreduce_add_u8(open_count);\n    uint8_t close_sum = vreduce_add_u8(close_count);\n\n    return open_sum == close_sum && open_sum >= 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    if (n == 0) return true;\n\n    // Vector length\n    const int vl = vsetvl_e8m1(n);\n    vint8m1_t count = vdup_v_i8m1(0); // Initialize count vector\n\n    for (int i = 0; i < n; i += vl) {\n        int vl_actual = vsetvl_e8m1(n - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)brackets.c_str() + i, vl_actual);\n        \n        // Count '(' and ')' in the vector\n        vint8m1_t open = vadd_vx_i8m1(count, vmslt_vx_u8m1(vec, '('), vl_actual);\n        vint8m1_t close = vadd_vx_i8m1(count, vmslt_vx_u8m1(vec, ')'), vl_actual);\n        \n        count = vsub_vv_i8m1(open, close, vl_actual);\n    }\n\n    // Check if the final count is zero\n    int final_count = 0;\n    for (int i = 0; i < vl; i++) {\n        final_count += vget_i8m1(count, i);\n    }\n\n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    size_t vector_length = vsetvl_e8m1(n); // Set vector length based on the size of the input\n    vuint8m1_t count_open = vdup_v_u8m1(0); // Vector to count '('\n    vuint8m1_t count_close = vdup_v_u8m1(0); // Vector to count ')'\n\n    for (size_t i = 0; i < n; i += vector_length) {\n        size_t vl = std::min(vector_length, n - i);\n        vuint8m1_t vec_brackets = vle8_v_u8m1(&brackets[i], vl);\n        \n        count_open = vadd_vv_u8m1(count_open, vmsltu_vx_u8m1(vec_brackets, '(', vl));\n        count_close = vadd_vv_u8m1(count_close, vmsltu_vx_u8m1(vec_brackets, ')', vl));\n    }\n\n    uint8_t open_count[vector_length];\n    uint8_t close_count[vector_length];\n    vse8_v_u8m1(open_count, count_open, vector_length);\n    vse8_v_u8m1(close_count, count_close, vector_length);\n\n    int total_open = 0;\n    int total_close = 0;\n    for (size_t j = 0; j < vector_length; j++) {\n        total_open += open_count[j];\n        total_close += close_count[j];\n    }\n\n    return total_open == total_close && total_open > 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.size();\n    int vector_length = vsetvl_e8m1(n);\n    vbool8_t mask = vmslt_vx_i8m1(vle8_v_i8m1((const int8_t*)brackets.c_str(), vector_length), 0);\n    \n    vint8m1_t count_open = vdup_v_i8m1(0);\n    vint8m1_t count_close = vdup_v_i8m1(0);\n    \n    for (int i = 0; i < n; i += vector_length) {\n        int vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vec_brackets = vle8_v_u8m1((const uint8_t*)brackets.c_str() + i, vl);\n        \n        vbool8_t is_open = vmseq_vx_u8m1(vec_brackets, '(', vl);\n        vbool8_t is_close = vmseq_vx_u8m1(vec_brackets, ')', vl);\n        \n        count_open = vadd_vx_i8m1(count_open, vmerge_vx_i8m1(is_open, vdup_v_i8m1(1), vdup_v_i8m1(0)), vl);\n        count_close = vadd_vx_i8m1(count_close, vmerge_vx_i8m1(is_close, vdup_v_i8m1(1), vdup_v_i8m1(0)), vl);\n    }\n    \n    int total_open = vreduce_add_i8m1(count_open);\n    int total_close = vreduce_add_i8m1(count_close);\n    \n    return total_open == total_close && total_open > 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    vfloat32m1_t coeffs = vle32_v_f32m1(xs.data());\n    vuint32m1_t indices = vseq_v_u32m1(0, 1, n - 1);\n\n    for (size_t i = 1; i < n; i++) {\n        vfloat32m1_t x = vfmul_vf_f32m1(coeffs, (float)i);\n        vse32_v_f32m1(result.data() + i - 1, x);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    if (n <= 1) return result;\n\n    vfloat32m1_t coeffs = vle32_v_f32m1(xs.data());\n    vuint32m1_t indices = vseq_v_u32m1(0, 1, n - 1);\n    vfloat32m1_t powers = vmul_vf_f32m1(coeffs, vcast_f32m1(1.0f));\n    \n    for (size_t i = 1; i < n; ++i) {\n        vfloat32m1_t term = vmul_vf_f32m1(powers, (float)i);\n        vse32_v_f32m1(result.data() + i - 1, term);\n        powers = vmul_vf_f32m1(powers, vcast_f32m1(xs[i]));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    vfloat32m1_t coeffs = vle32_v_f32m1(xs.data(), n);\n    vuint32m1_t indices = vseq_v_u32m1(0, 1, n);\n    \n    for (size_t i = 1; i < n; i++) {\n        vfloat32m1_t x_pow = vfmul_vv_f32m1(coeffs, vfmul_vf_f32m1(vfmv_v_f32m1(i), vfmv_v_f32m1(i)));\n        vse32_v_f32m1(result.data() + i - 1, x_pow, n - 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    if (n < 2) return result; // Return empty if not enough coefficients\n\n    vfloat32m1_t coeffs = vle32_v_f32m1(xs.data());\n    vuint32m1_t indices = vseq_v_u32m1(0, 1, n - 1);\n    \n    for (size_t i = 1; i < n; ++i) {\n        vfloat32m1_t x = vfmul_vf_f32m1(coeffs, (float)i);\n        vse32_v_f32m1(result.data() + i - 1, x);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    if (n < 2) return result;\n\n    vfloat32m1_t coeffs = vle32_v_f32m1(xs.data());\n    vfloat32m1_t indices = vseq_v_f32m1(0, 1, n - 1);\n    \n    for (size_t i = 1; i < n; ++i) {\n        vfloat32m1_t term = vfmul_vv_f32m1(coeffs, indices);\n        vse32_v_f32m1(result.data() + i - 1, term);\n        coeffs = vslide1down_v_f32m1(coeffs, coeffs, 1);\n        indices = vadd_vf_f32m1(indices, 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    int vector_length = vsetvl_e8m1(len);\n    vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)s.c_str(), vector_length);\n    \n    vuint8m1_t vowels_mask = vundefined_u8m1();\n    vuint8m1_t y_mask = vundefined_u8m1();\n    \n    // Load vowel characters\n    vuint8m1_t a_mask = vmv_v_x_u8m1('a', vector_length);\n    vuint8m1_t e_mask = vmv_v_x_u8m1('e', vector_length);\n    vuint8m1_t i_mask = vmv_v_x_u8m1('i', vector_length);\n    vuint8m1_t o_mask = vmv_v_x_u8m1('o', vector_length);\n    vuint8m1_t u_mask = vmv_v_x_u8m1('u', vector_length);\n    \n    // Combine vowel masks\n    vowels_mask = vor(vor(vor(vor(a_mask, e_mask), i_mask), o_mask), u_mask);\n    \n    // Check for 'y' at the end\n    if (len > 0) {\n        vuint8m1_t last_char_mask = vmv_v_x_u8m1(s[len - 1], vector_length);\n        y_mask = vmv_v_x_u8m1('y', vector_length);\n        y_mask = vmsltu_vv_u8m1(last_char_mask, y_mask);\n    }\n    \n    // Count vowels\n    vuint8m1_t result_mask = vmsltu_vv_u8m1(vec_chars, vowels_mask);\n    vuint8m1_t final_mask = vor(result_mask, y_mask);\n    \n    // Sum the counts\n    count += vpopc_m_u8m1(final_mask);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int length = s.length();\n    int count = 0;\n    \n    // Create a vector of characters\n    vuint8m1_t vec_chars;\n    vuint8m1_t vec_vowels = vundefined_u8m1();\n    vuint8m1_t vec_y_end = vundefined_u8m1();\n    \n    // Load vowels into a vector\n    uint8_t vowels[6] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    vec_vowels = vle8_v_u8m1(vowels);\n    \n    // Count vowels\n    for (int i = 0; i < length; i += vsetvl_e8m1(length - i)) {\n        int vl = vsetvl_e8m1(length - i);\n        vec_chars = vle8_v_u8m1((uint8_t*)&s[i]);\n        \n        // Compare with vowels\n        vbool8_t mask = vmseq_vv_u8m1(vec_chars, vec_vowels);\n        count += popcount(vmsum_v_b(mask, vl));\n    }\n    \n    // Check for 'y' at the end\n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int length = s.length();\n    int count = 0;\n    \n    // Create a vector of characters for processing\n    vuint8m1_t vec_chars;\n    vuint8m1_t vec_vowels = vundefined_u8m1();\n    vuint8m1_t vec_y_end = vundefined_u8m1();\n    \n    // Load vowels into a vector\n    vec_vowels = vslide1down_u8m1(vec_vowels, 0, vundefined_u8m1());\n    vec_vowels = vinsert_u8m1(vec_vowels, 'a', 0);\n    vec_vowels = vinsert_u8m1(vec_vowels, 'e', 1);\n    vec_vowels = vinsert_u8m1(vec_vowels, 'i', 2);\n    vec_vowels = vinsert_u8m1(vec_vowels, 'o', 3);\n    vec_vowels = vinsert_u8m1(vec_vowels, 'u', 4);\n    \n    // Process the string in chunks\n    for (int i = 0; i < length; i += vsetvl_e8m1(length - i)) {\n        int vl = vsetvl_e8m1(length - i);\n        vec_chars = vle8_v_u8m1((const uint8_t*)s.c_str() + i, vl);\n        \n        // Count vowels\n        vuint8m1_t mask = vmslt_u8m1(vec_chars, vec_vowels);\n        count += vpopc_u8m1(mask);\n    }\n    \n    // Check for 'y' at the end\n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t vector_length = vsetvl_e8m1(len); // Set vector length based on input size\n    vuint8m1_t vec_chars = vle8_v_u8m1(s.c_str(), vector_length);\n    \n    vuint8m1_t vowels_mask = vmv_v_x_u8m1(0, vector_length);\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('a', vector_length));\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('e', vector_length));\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('i', vector_length));\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('o', vector_length));\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('u', vector_length));\n    vowels_mask = vorr_vv_u8m1(vowels_mask, vmv_v_x_u8m1('y', vector_length));\n\n    vuint8m1_t end_y_mask = vmv_v_x_u8m1(0, vector_length);\n    if (len > 0) {\n        end_y_mask = vslidedown_vx_u8m1(vle8_v_u8m1(s.c_str(), vector_length), 1, vector_length);\n        end_y_mask = vmand_vv_u8m1(end_y_mask, vmv_v_x_u8m1('y', vector_length));\n    }\n\n    vuint8m1_t result_mask = vand_vv_u8m1(vec_chars, vowels_mask);\n    vuint8m1_t end_y_result = vand_vv_u8m1(vec_chars, end_y_mask);\n\n    count += vpopc_u8m1(result_mask);\n    count += vpopc_u8m1(end_y_result);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    int vector_length = 64; // Assuming a vector length of 64 for RVV\n    vuint8m1_t mask_a = vmv_v_x_u8m1('a', vector_length);\n    vuint8m1_t mask_e = vmv_v_x_u8m1('e', vector_length);\n    vuint8m1_t mask_i = vmv_v_x_u8m1('i', vector_length);\n    vuint8m1_t mask_o = vmv_v_x_u8m1('o', vector_length);\n    vuint8m1_t mask_u = vmv_v_x_u8m1('u', vector_length);\n    vuint8m1_t mask_y = vmv_v_x_u8m1('y', vector_length);\n    \n    for (int i = 0; i < len; i += vector_length) {\n        int remaining = len - i < vector_length ? len - i : vector_length;\n        vuint8m1_t data = vle8_v_u8m1((const uint8_t*)(s.c_str() + i));\n        \n        vbool8_t is_vowel = vmsltu_vv_u8m1(data, mask_a) | vmsltu_vv_u8m1(data, mask_e) |\n                            vmsltu_vv_u8m1(data, mask_i) | vmsltu_vv_u8m1(data, mask_o) |\n                            vmsltu_vv_u8m1(data, mask_u);\n        \n        count += popcount(vredsum_vs_u8m1(is_vowel, 0, remaining));\n        \n        if (i + remaining - 1 < len && s[i + remaining - 1] == 'y') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vl = vsetvl_e8(len);\n    vuint8m1_t vec_chars = vle8_v_u8m1(s.c_str(), vl);\n    vuint8m1_t vec_upper = vmsltu_v_u8m1(vec_chars, vlev_v_u8m1('Z' + 1, vl)); // Check if char <= 'Z'\n    vuint8m1_t vec_lower = vmsltu_v_u8m1(vec_chars, vlev_v_u8m1('A' + 1, vl)); // Check if char < 'A'\n    vuint8m1_t vec_is_upper = vand_vv_u8m1(vec_upper, vec_lower); // Is upper case\n    vuint8m1_t vec_ascii = vmul_vv_u8m1(vec_chars, vec_is_upper); // Get ASCII values of upper case chars\n    sum += vreduce_add_u8m1(vec_ascii); // Reduce to sum\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vl = vsetvl_e8(len);\n    vuint8m1_t v_sum = vundefined_u8m1();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t current_vl = std::min(vl, len - i);\n        vuint8m1_t v_chars = vle8_v_u8m1(s.data() + i);\n        vuint8m1_t v_mask = vmsltu_vx_u8m1(v_chars, 91); // ASCII 'Z' = 90\n        v_mask = vmand_vv_u8m1(v_mask, vmsgeu_vx_u8m1(v_chars, 65)); // ASCII 'A' = 65\n        v_chars = vand_vv_u8m1(v_chars, v_mask);\n\n        v_sum = vadd_vv_u8m1(v_sum, v_chars);\n    }\n\n    uint8_t result[16];\n    vse8_v_u8m1(result, v_sum);\n    for (size_t j = 0; j < current_vl; j++) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8m1(len); // Set vector length based on input size\n    vuint8m1_t vec_chars = vle8_v_u8m1(s.c_str(), vec_len);\n    vuint8m1_t vec_upper = vmsltu_v_u8m1(vec_chars, 91); // Check if char < 'Z' + 1\n    vuint8m1_t vec_lower = vmsltu_v_u8m1(vec_chars, 97); // Check if char < 'a'\n    vuint8m1_t vec_is_upper = vmand_v_u8m1(vec_upper, vec_lower); // Logical AND to find uppercase letters\n\n    vuint8m1_t vec_ascii = vadd_vu8m1(vec_chars, vec_is_upper); // Add ASCII values of uppercase letters\n    sum = vreduce_add_u8m1(vec_ascii); // Reduce to sum\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8(len);\n    vuint8m1_t vec_chars = vle8_v_u8m1(s.c_str(), vec_len);\n    vuint8m1_t vec_upper_mask = vmv_v_x_u8m1(0x20, vec_len); // Mask for upper case check\n    vuint8m1_t vec_upper_chars = vsub_vv_u8m1(vec_chars, vec_upper_mask); // Convert to ASCII if upper case\n    vbool8_t mask = vmsltu_vx_u8m1(vec_upper_chars, 91); // Check if char is less than 'Z' + 1\n\n    for (size_t i = 0; i < vec_len; i++) {\n        if (mask[i]) {\n            sum += vec_upper_chars[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t vl = vsetvl_e8(len);\n    vuint8m1_t vec_chars = vle8_v_u8m1(s.c_str(), vl);\n    vuint8m1_t upper_mask = vmseq_vx_u8m1(vec_chars, 'A', vl);\n    vuint8m1_t lower_mask = vmslt_vx_u8m1(vec_chars, 'Z' + 1, vl);\n    vuint8m1_t is_upper = vand_vv_u8m1(upper_mask, lower_mask, vl);\n    \n    vuint8m1_t ascii_sum = vmul_vv_u8m1(vec_chars, is_upper, vl);\n    sum += vreduce_add_u8m1(ascii_sum, vl);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return {};\n\n    vtype<int> min_even_value = vundefined<int>();\n    vtype<int> min_even_index = vundefined<int>();\n    vtype<int> indices = vseq<int>(0, 1, n); // Create a vector of indices\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> vec = vle<int>(&arr[i], vl);\n        vtype<int> idx_vec = vle<int>(&indices[i], vl);\n\n        // Mask for even numbers\n        vtype<bool> mask = (vec % 2 == 0);\n        \n        // Select even numbers and their indices\n        vtype<int> even_values = vselect(mask, vec, vundefined<int>());\n        vtype<int> even_indices = vselect(mask, idx_vec, vundefined<int>());\n\n        // Find the minimum even value and its index\n        for (size_t j = 0; j < vl; j++) {\n            if (mask[j] && (min_even_value == vundefined<int>() || even_values[j] < min_even_value)) {\n                min_even_value = even_values[j];\n                min_even_index = even_indices[j];\n            }\n        }\n    }\n\n    if (min_even_value == vundefined<int>()) return {};\n\n    return {min_even_value, min_even_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return {};\n\n    vtype<int> min_even = vundefined<int>();\n    vtype<int> min_index = vundefined<int>();\n    vtype<int> indices = vseq<int>(0, 1); // Vector of indices\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vtype<int> vec = vle<int>(&arr[i], vl);\n        vtype<int> idx_vec = vle<int>(&indices[i], vl);\n\n        // Create a mask for even numbers\n        vmask_t mask = vmslt<int>(vec, vundefined<int>());\n        vtype<int> even_vals = vselect(mask, vec, vundefined<int>());\n        vtype<int> even_indices = vselect(mask, idx_vec, vundefined<int>());\n\n        // Find the minimum even value and its index\n        for (size_t j = 0; j < vl; j++) {\n            if (even_vals[j] != vundefined<int>() && (min_even == vundefined<int>() || even_vals[j] < min_even)) {\n                min_even = even_vals[j];\n                min_index = even_indices[j];\n            }\n        }\n    }\n\n    if (min_even == vundefined<int>()) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    vtype<int> v_arr = vundefined<int>();\n    vtype<int> v_index = vundefined<int>();\n    vtype<int> v_min_even = vundefined<int>();\n    vtype<int> v_min_index = vundefined<int>();\n\n    int vector_length = vsetvl_e32(n);\n    v_min_even = vsetvl_e32(std::numeric_limits<int>::max());\n    v_min_index = vsetvl_e32(-1);\n\n    for (int i = 0; i < n; i += vector_length) {\n        int vl = std::min(vector_length, n - i);\n        v_arr = vle32_v_i32(&arr[i], vl);\n        v_index = vadd_vx_i32(vle32_v_i32(&i, vl), 0, vl);\n\n        for (int j = 0; j < vl; j++) {\n            if (v_arr[j] % 2 == 0 && v_arr[j] < v_min_even) {\n                v_min_even = v_arr[j];\n                v_min_index = v_index[j];\n            }\n        }\n    }\n\n    if (v_min_even == std::numeric_limits<int>::max()) return {};\n\n    return {v_min_even, v_min_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    vtype<int> min_even_value = vundefined<int>();\n    vtype<int> min_even_index = vundefined<int>();\n    vtype<int> zero = vsetvl_e32m1(0);\n    \n    int index = 0;\n    int min_value = std::numeric_limits<int>::max();\n    int min_idx = -1;\n\n    for (int i = 0; i < n; i += VLEN) {\n        int vl = vsetvl_e32m1(n - i);\n        vtype<int> vec = vle32_v_i32m1(&arr[i], vl);\n        vtype<int> mask = vmslt_vx_i32m1(vec, zero, vl);\n        \n        for (int j = 0; j < vl; ++j) {\n            if (mask[j] && (vec[j] % 2 == 0)) {\n                if (vec[j] < min_value) {\n                    min_value = vec[j];\n                    min_idx = i + j;\n                }\n            }\n        }\n    }\n\n    if (min_idx == -1) return {};\n    return {min_value, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    vtype<int> vec_size = vsetvl_e32(n);\n    vint32m1_t vec_arr = vle32_v_i32m1(arr.data(), vec_size);\n    vint32m1_t vec_even_mask = vmul_vx_i32m1(vec_arr, 0);\n    vint32m1_t vec_even_values = vmand_vv_i32m1(vec_arr, vec_even_mask, vec_size);\n\n    int smallest_value = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int i = 0; i < n; i += vlen) {\n        vec_size = vsetvl_e32(n - i);\n        vint32m1_t current_values = vle32_v_i32m1(arr.data() + i, vec_size);\n        vbool32_t is_even = vmul_vx_i32m1(current_values, 0);\n\n        for (int j = 0; j < vec_size; j++) {\n            if (is_even[j]) {\n                if (current_values[j] < smallest_value) {\n                    smallest_value = current_values[j];\n                    smallest_index = i + j;\n                }\n            }\n        }\n    }\n\n    if (smallest_index == -1) return {};\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int *data = lst.data();\n    int max_val = *std::max_element(data, data + n);\n    \n    // Create a frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Load data into vector registers and count frequencies\n    for (int i = 0; i < n; i += VECT_SIZE) {\n        vtype<int> vec = vle32_v_i32(data + i);\n        for (int j = 0; j < VECT_SIZE; j++) {\n            if (i + j < n) {\n                int value = vec[j];\n                if (value > 0) {\n                    freq[value]++;\n                }\n            }\n        }\n    }\n\n    // Find the greatest integer with the required frequency\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int *data = lst.data();\n    vtype<int> vlen = vsetvl_e32(n);\n    vuint32m1_t freq = vundefined_u32m1();\n    \n    // Count frequencies\n    for (int i = 0; i < n; i += vlen) {\n        vuint32m1_t vec = vle32_v_u32m1(data + i);\n        freq = vadd_u32m1(freq, vcreate_u32m1(vle32_v_u32m1(data + i)));\n    }\n    \n    // Find the maximum integer that meets the criteria\n    int max_value = -1;\n    for (int i = 1; i <= n; ++i) {\n        if (freq[i] >= i) {\n            max_value = i;\n        }\n    }\n    \n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int *data = lst.data();\n    vtype<int> v_data = vle32_v_i32(data, n);\n    \n    std::unordered_map<int, int> frequency_map;\n    for (int i = 0; i < n; i++) {\n        frequency_map[data[i]]++;\n    }\n\n    int max_value = -1;\n    for (const auto& pair : frequency_map) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (value > 0 && frequency >= value) {\n            max_value = std::max(max_value, value);\n        }\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int *data = lst.data();\n    vtype<int> vlen = vsetvl_n_u32(n);\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    for (int i = 0; i < n; i++) {\n        freq_map[data[i]]++;\n    }\n\n    // Prepare to find the maximum valid integer\n    int max_value = -1;\n\n    // Iterate through the frequency map\n    for (const auto& pair : freq_map) {\n        int value = pair.first;\n        int frequency = pair.second;\n\n        if (value > 0 && frequency >= value) {\n            max_value = std::max(max_value, value);\n        }\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int *data = lst.data();\n    vtype<int> vdata = vle32_v_i32(data, n);\n    \n    // Count frequencies using a hash map\n    std::unordered_map<int, int> freq_map;\n    \n    for (int i = 0; i < n; i += VLEN) {\n        int vl = std::min(VLEN, n - i);\n        vtype<int> vcount = vle32_v_i32(data + i, vl);\n        \n        for (int j = 0; j < vl; j++) {\n            freq_map[vcount[j]]++;\n        }\n    }\n    \n    int result = -1;\n    \n    for (const auto& pair : freq_map) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (value > 0 && frequency >= value) {\n            result = std::max(result, value);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for palindromic property\n    vbool64_t is_palindrome = vmslt_vx_i32(vle32_v_i32(&q[0]), vle32_v_i32(&q[n-1]));\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int i = 0; i < n; i += 16) {\n        vuint32m8_t vec = vle32_v_u32(&q[i]);\n        sum += vreduce_add_u32_m(is_palindrome, vec);\n    }\n\n    return (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is balanced (palindromic)\n    vbool8_t is_equal = vmslt_vx_i32(vle32_v_i32(&q[0]), vle32_v_i32(&q[n-1]), n);\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int i = 0; i < n; i += 8) {\n        vuint32m8_t vec = vle32_v_u32(&q[i]);\n        sum += vreduce_add_u32(vec);\n    }\n\n    return (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for balance (palindromic)\n    vbool8_t is_equal = vmsne_vx_i32_b8(vle32_v_i32(q.data()), vle32_v_i32(q.data() + n - 1), 0);\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int i = 0; i < n; i += 8) {\n        vuint32m8_t vec = vle32_v_u32(q.data() + i);\n        sum += vreduce_add_u32_m(vmsltu_vx_u32_b8(vec, 0), vec);\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic\n    vbool64_t is_palindrome = vtrue_b64();\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            is_palindrome = vfalse_b64();\n            break;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    int vl = vsetvl_e32(n);\n    vint32m1_t vec_q = vle32_v_i32m1(q.data(), vl);\n    sum = vreduce_add_i32m1(vec_q, vl);\n\n    // Check conditions\n    return (sum <= w) && (is_palindrome);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is balanced (palindromic)\n    vbool8_t is_palindrome = vmslt_vx_i32(vle32_v_i32(&q[0]), vle32_v_i32(&q[n - 1]));\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of elements\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += q[i];\n    }\n\n    // Check if the sum is less than or equal to the maximum weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Create vectors for the left and right halves\n    vtype<int> v_left, v_right;\n    \n    for (int i = 0; i < n / 2; i += VLEN) {\n        // Load elements from both ends\n        v_left = vle32_v_i32(&arr[i]);\n        v_right = vle32_v_i32(&arr[n - 1 - i]);\n\n        // Compare elements\n        vbool32_t mask = vmv_v_x_i32(0);\n        for (int j = 0; j < VLEN && i + j < n / 2; j++) {\n            if (v_left[j] != v_right[j]) {\n                mask = vset_bit(mask, j);\n            }\n        }\n\n        // Count mismatches\n        changes += vpopcount(mask);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += VLEN / sizeof(int)) {\n        vint32m1_t left = vle32_v_i32m1(&arr[i]);\n        vint32m1_t right = vle32_v_i32m1(&arr[n - 1 - i]);\n\n        // Compare left and right elements\n        vbool32_t mask = vmfne_vv_i32m1(left, right);\n        changes += vpopc_m(mask);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Create vectors for processing\n    vtype<int> v_arr = vload_v_i32(arr.data(), n);\n    vtype<int> v_rev_arr = vload_v_i32(arr.data() + n - 1, n);\n\n    for (int i = 0; i < n / 2; i += VLEN) {\n        vtype<int> v_left = vset_v_i32(v_arr, i);\n        vtype<int> v_right = vset_v_i32(v_rev_arr, i);\n\n        // Count mismatches\n        vtype<int> v_mismatch = vne(v_left, v_right);\n        changes += vpopcount(v_mismatch);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += VLEN / sizeof(int)) {\n        vint32m1_t left = vle32_v_i32m1(&arr[i]);\n        vint32m1_t right = vle32_v_i32m1(&arr[n - 1 - i]);\n\n        // Compare left and right elements\n        vbool32_t mask = vmfne_vv_i32m1(left, right);\n        changes += vpopc_m(mask);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += VLEN / sizeof(int)) {\n        vint32m1_t left = vle32_v_i32m1(&arr[i]);\n        vint32m1_t right = vle32_v_i32m1(&arr[n - 1 - i]);\n\n        // Compare left and right elements\n        vbool32_t mask = vmfne_vv_i32m1(left, right);\n        changes += vpopc_m(mask);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    size_t vec_size = 0;\n    if (len1 > len2) {\n        vec_size = len1;\n    } else {\n        vec_size = len2;\n    }\n\n    vuint64m1_t v_total_chars1 = vundefined_u64m1();\n    vuint64m1_t v_total_chars2 = vundefined_u64m1();\n\n    for (size_t i = 0; i < len1; i += 8) {\n        size_t count = std::min(8UL, len1 - i);\n        vuint64m1_t v_chars = vundefined_u64m1();\n        for (size_t j = 0; j < count; j++) {\n            v_chars = vadd_u64m1(v_chars, vset_u64(lst1[i + j].size()));\n        }\n        v_total_chars1 = vadd_u64m1(v_total_chars1, v_chars);\n    }\n\n    for (size_t i = 0; i < len2; i += 8) {\n        size_t count = std::min(8UL, len2 - i);\n        vuint64m1_t v_chars = vundefined_u64m1();\n        for (size_t j = 0; j < count; j++) {\n            v_chars = vadd_u64m1(v_chars, vset_u64(lst2[i + j].size()));\n        }\n        v_total_chars2 = vadd_u64m1(v_total_chars2, v_chars);\n    }\n\n    total_chars1 += vreduce_add_u64m1(v_total_chars1);\n    total_chars2 += vreduce_add_u64m1(v_total_chars2);\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    size_t vec_size = std::max(len1, len2);\n    size_t vectorized_size = (vec_size + 7) / 8 * 8; // Round up to nearest multiple of 8\n\n    vuint8m1_t v_total_chars1 = vdup_u8(0);\n    vuint8m1_t v_total_chars2 = vdup_u8(0);\n\n    for (size_t i = 0; i < vectorized_size; i += 8) {\n        vuint8m1_t v_chars1 = vdup_u8(0);\n        vuint8m1_t v_chars2 = vdup_u8(0);\n\n        for (size_t j = 0; j < 8; ++j) {\n            if (i + j < len1) {\n                v_chars1 = vadd_u8(v_chars1, vset_u8(lst1[i + j].size()));\n            }\n            if (i + j < len2) {\n                v_chars2 = vadd_u8(v_chars2, vset_u8(lst2[i + j].size()));\n            }\n        }\n\n        v_total_chars1 = vadd_u8(v_total_chars1, v_chars1);\n        v_total_chars2 = vadd_u8(v_total_chars2, v_chars2);\n    }\n\n    total_chars1 = vreduce_add_u8(v_total_chars1);\n    total_chars2 = vreduce_add_u8(v_total_chars2);\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    size_t max_len = std::max(len1, len2);\n    vuint64m1_t v_total_chars1 = vundefined_u64m1();\n    vuint64m1_t v_total_chars2 = vundefined_u64m1();\n\n    for (size_t i = 0; i < max_len; i += VEC_SIZE) {\n        size_t count1 = std::min(VEC_SIZE, len1 - i);\n        size_t count2 = std::min(VEC_SIZE, len2 - i);\n\n        vuint64m1_t v_chars1 = vundefined_u64m1();\n        vuint64m1_t v_chars2 = vundefined_u64m1();\n\n        for (size_t j = 0; j < count1; ++j) {\n            v_chars1 = vadd_u64m1(v_chars1, vset_u64m1(lst1[i + j].size()));\n        }\n        for (size_t j = 0; j < count2; ++j) {\n            v_chars2 = vadd_u64m1(v_chars2, vset_u64m1(lst2[i + j].size()));\n        }\n\n        v_total_chars1 = vadd_u64m1(v_total_chars1, v_chars1);\n        v_total_chars2 = vadd_u64m1(v_total_chars2, v_chars2);\n    }\n\n    total_chars1 += vredsum_u64m1(v_total_chars1, 0);\n    total_chars2 += vredsum_u64m1(v_total_chars2, 0);\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    // Process lst1\n    for (size_t i = 0; i < len1; i++) {\n        total_chars1 += lst1[i].size();\n    }\n\n    // Process lst2\n    for (size_t i = 0; i < len2; i++) {\n        total_chars2 += lst2[i].size();\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else if (total_chars2 < total_chars1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    // Process lst1\n    for (size_t i = 0; i < len1; i++) {\n        total_chars1 += lst1[i].size();\n    }\n\n    // Process lst2\n    for (size_t i = 0; i < len2; i++) {\n        total_chars2 += lst2[i].size();\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else if (total_chars2 < total_chars1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    vuint64m1_t vec_x = vundefined_u64m1();\n    vuint64m1_t vec_n = vundefined_u64m1();\n    vuint64m1_t vec_power = vundefined_u64m1();\n    \n    vec_x = vslide1down_u64m1(vec_x, x);\n    vec_n = vslide1down_u64m1(vec_n, n);\n    \n    for (int i = 0; i < 64; i++) {\n        vec_power = vwmul_u64m1(vec_power, vec_n);\n        if (vfirst_m_b64m1(vmsltu_vv_u64m1(vec_power, vec_x)) == 0) {\n            return false;\n        }\n        if (vfirst_m_b64m1(vmsltu_vv_u64m1(vec_power, vec_x)) == 1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x < n) return false;\n\n    vuint64m1_t vec_x = vundefined_u64m1();\n    vuint64m1_t vec_n = vundefined_u64m1();\n    vuint64m1_t vec_pow = vundefined_u64m1();\n    vuint64m1_t vec_one = vmv_v_x_u64m1(1, 1);\n    vuint64m1_t vec_result = vundefined_u64m1();\n    \n    vec_x = vmv_v_x_u64m1(x, 1);\n    vec_n = vmv_v_x_u64m1(n, 1);\n    \n    for (int i = 0; i < 64; i++) {\n        vec_pow = vwmul_vv_u64m1(vec_pow, vec_n, 1);\n        vec_result = vwmul_vv_u64m1(vec_pow, vec_one, 1);\n        \n        if (vfirst_m_b(vle64_v_u64m1(vec_result, 1) == x)) {\n            return true;\n        }\n        \n        if (vfirst_m_b(vec_pow > vec_x)) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    vuint64m1_t vec_x = vundefined_u64m1();\n    vuint64m1_t vec_n = vundefined_u64m1();\n    vuint64m1_t vec_pow = vundefined_u64m1();\n    vuint64m1_t vec_one = vdup_u64m1(1);\n    vuint64m1_t vec_result = vundefined_u64m1();\n\n    vec_x = vslide1down_u64m1(vec_x, x);\n    vec_n = vslide1down_u64m1(vec_n, n);\n    \n    for (uint64_t i = 0; i < 64; i++) {\n        vec_pow = vwmul_u64m1(vec_pow, vec_n);\n        vec_result = vwmul_u64m1(vec_pow, vec_one);\n        \n        if (vfirst_u64m1(vec_result) == x) {\n            return true;\n        }\n        \n        if (vec_pow > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    uint64_t result = 1;\n    vuint64m1_t v_result = vmv_v_x_u64m1(1, 1);\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, 1);\n    vuint64m1_t v_x = vmv_v_x_u64m1(x, 1);\n    \n    while (result < x) {\n        v_result = vmul_vv_u64m1(v_result, v_n);\n        result = vget_v_u64m1(v_result, 0);\n        if (result == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    vuint64m1_t vec_x = vundefined_u64m1();\n    vuint64m1_t vec_n = vundefined_u64m1();\n    vuint64m1_t vec_pow = vundefined_u64m1();\n    vuint64m1_t vec_result = vundefined_u64m1();\n    \n    vec_x = vslide1down_u64m1(vec_x, 0, vundefined_u64m1());\n    vec_n = vslide1down_u64m1(vec_n, 0, vundefined_u64m1());\n    \n    for (uint64_t i = 0; i < 64; i++) {\n        vec_pow = vwmul_u64m1(vec_pow, vec_n);\n        vec_result = vwmul_u64m1(vec_result, vec_pow);\n        \n        if (vfirst_m_b64m1(vmsltu_vv_u64m1(vec_result, vec_x)) == 0) {\n            return false;\n        }\n        if (vfirst_m_b64m1(vmsltu_vv_u64m1(vec_result, vec_x)) == 1) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const int len = num.length();\n    const int vector_length = 64; // Assuming a vector length of 64 bits\n    int count = 0;\n\n    // Create a vector of prime hexadecimal digits\n    uint8_t prime_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0}; // 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\n\n    // Process the string in chunks of vector_length\n    for (int i = 0; i < len; i += vector_length) {\n        int chunk_size = std::min(vector_length, len - i);\n        vuint8m1_t vec_digits = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Convert ASCII hex characters to their numeric values\n        vuint8m1_t vec_values = vsub_vu8m1(vand_vu8m1(vec_digits, 0x0F), 0x30);\n        vuint8m1_t vec_primes = vle8_v_u8m1(prime_digits);\n\n        // Count the prime digits\n        vuint8m1_t vec_result = vgt_vv_u8m1(vec_values, vec_primes);\n        count += vpopc_u8m1(vec_result);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const int len = num.length();\n    const int vector_length = 64; // Assuming a vector length of 64 bits\n    int count = 0;\n\n    // Create a vector to hold the prime hex digits\n    uint8_t prime_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0}; // 0-9, A-F\n\n    // Initialize vector registers\n    vuint8m1_t v_prime_digits = vle8_v_u8m1(prime_digits);\n    vuint8m1_t v_count = vdup_v_u8m1(0);\n\n    for (int i = 0; i < len; i += vector_length) {\n        int remaining = len - i;\n        int current_length = remaining < vector_length ? remaining : vector_length;\n\n        // Load the current segment of hex digits\n        vuint8m1_t v_hex_digits = vle8_v_u8m1((const uint8_t*)num.c_str() + i);\n\n        // Convert hex characters to their decimal values\n        vuint8m1_t v_decimal_values = vsub_vu8m1(v_hex_digits, vdup_v_u8m1('0'));\n        vuint8m1_t v_mask = vmsltu_vu8m1(v_hex_digits, vdup_v_u8m1('A'));\n        v_decimal_values = vadd_vu8m1(v_decimal_values, vsel_vu8m1(v_mask, vdup_v_u8m1(10), vsub_vu8m1(v_hex_digits, vdup_v_u8m1('A'))));\n\n        // Count prime digits\n        vuint8m1_t v_is_prime = vgt_vu8m1(v_prime_digits, vzero_v_u8m1());\n        v_count = vadd_vu8m1(v_count, vand_vu8m1(v_is_prime, vgt_vu8m1(v_decimal_values, vzero_v_u8m1())));\n\n        // Sum up the counts\n        count += vreduce_add_u8m1(v_count);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const int length = num.length();\n    const int vector_length = 64; // Assuming a vector length of 64 bits\n    int count = 0;\n\n    // Create a vector to hold the prime hex digits\n    const char prime_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    vuint8m1_t prime_mask = vundefined_u8m1();\n    for (int i = 0; i < 6; i++) {\n        prime_mask = vset_v_u8m1(prime_mask, prime_digits[i], i);\n    }\n\n    // Process the string in chunks\n    for (int i = 0; i < length; i += vector_length) {\n        int chunk_size = std::min(vector_length, length - i);\n        vuint8m1_t hex_vector = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n\n        // Compare with prime digits\n        vbool8_t is_prime = vmseq_vv_u8m1(hex_vector, prime_mask);\n        count += vpopc_m(is_prime);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const char* hex_digits = num.c_str();\n    size_t length = num.length();\n    int count = 0;\n\n    vuint8m1_t prime_mask = vundefined_u8m1();\n    prime_mask = vsetvl_e8m1(16);\n    prime_mask = vadd_vx_u8m1(prime_mask, 0); // Initialize mask\n\n    // Set prime positions: 2, 3, 5, 7, B(11), D(13)\n    vuint8m1_t primes = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0}; // 0-9, A-F\n    vuint8m1_t hex_values = vundefined_u8m1();\n\n    for (size_t i = 0; i < length; i += 16) {\n        size_t vl = length - i < 16 ? length - i : 16;\n        hex_values = vle8_v_u8m1(&hex_digits[i]);\n\n        vuint8m1_t is_prime = vmsltu_vv_u8m1(hex_values, primes);\n        count += vpopc_u8m1(is_prime);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    vuint8m1_t prime_mask = vundefined_u8m1();\n    prime_mask = vsetvl_e8m1(16);\n    \n    // Set prime mask for hex digits: 2, 3, 5, 7, B, D\n    uint8_t primes[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0}; // 0-9, A-F\n    vuint8m1_t prime_vector = vle8_v_u8m1(primes);\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t vl = std::min(len - i, (size_t)16);\n        vuint8m1_t hex_vector = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(num.data() + i));\n        \n        // Convert hex characters to their numeric values\n        vuint8m1_t hex_values = vadd_vx_u8m1(vsrl_vx_u8m1(hex_vector, 4), \n                                              vadd_vx_u8m1(vand_vx_u8m1(hex_vector, 0x0F), 0x0F));\n        \n        // Compare with prime mask\n        vuint8m1_t is_prime = vmsltu_vv_u8m1(hex_values, prime_vector);\n        \n        // Count primes\n        count += vpopc_u8m1(is_prime);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    vuint8m1_t mask = vundefined_u8m1();\n    vuint8m1_t prev1, prev2;\n    size_t i = 0;\n\n    for (; i <= len - 3; i += 8) {\n        size_t vl = std::min(8UL, len - i);\n        vuint8m1_t vec = vle8_v_u8m1(s.data() + i);\n        \n        prev1 = vslide1down_u8m1(vec, 1);\n        prev2 = vslide1down_u8m1(vec, 2);\n\n        mask = vmand_u8m1(mask, vmandnot_u8m1(vec, prev1));\n        mask = vmand_u8m1(mask, vmandnot_u8m1(vec, prev2));\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] == s[i - 1] || s[i] == s[i - 2] || s[i - 1] == s[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vector_length = vsetvl_e8m1(0); // Set vector length based on the type\n    size_t happy = 1; // Assume happy initially\n\n    for (size_t i = 0; i <= len - 3; i += vector_length) {\n        size_t vl = std::min(vector_length, len - i);\n        vuint8m1_t v1 = vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t v2 = vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t v3 = vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        // Check for distinct characters\n        vbool8_t mask1 = vmne_vv_u8m1(v1, v2, vl);\n        vbool8_t mask2 = vmne_vv_u8m1(v1, v3, vl);\n        vbool8_t mask3 = vmne_vv_u8m1(v2, v3, vl);\n\n        // Combine masks\n        vbool8_t happy_mask = vand_vv_mask8(mask1, mask2, vl);\n        happy_mask = vand_vv_mask8(happy_mask, mask3, vl);\n\n        // If any of the vectors are not happy, set happy to false\n        if (vfirst_m(mask8, happy_mask, vl) != -1) {\n            happy = 0;\n            break;\n        }\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    vbool8_t result = vmslt_vx_u8(vle8_v_u8((const uint8_t *)s.data(), 0), 0);\n    for (size_t i = 0; i <= len - 3; i += 8) {\n        vuint8m1_t v1 = vle8_v_u8((const uint8_t *)(s.data() + i));\n        vuint8m1_t v2 = vle8_v_u8((const uint8_t *)(s.data() + i + 1));\n        vuint8m1_t v3 = vle8_v_u8((const uint8_t *)(s.data() + i + 2));\n\n        vbool8_t cmp1 = vmfne_vv_u8(v1, v2);\n        vbool8_t cmp2 = vmfne_vv_u8(v1, v3);\n        vbool8_t cmp3 = vmfne_vv_u8(v2, v3);\n\n        result = vand_vv_b8(result, vand_vv_b8(cmp1, vand_vv_b8(cmp2, cmp3)));\n    }\n\n    return vmsne_vx_u8(result, 0);\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    vuint8m1_t mask = vundefined_u8m1();\n    vuint8m1_t prev1, prev2;\n    size_t i = 0;\n\n    for (; i <= len - 3; i += vsetvl_e8m1(1)) {\n        vuint8m1_t current = vle8_v_u8m1((const uint8_t*)s.c_str() + i);\n        prev1 = vle8_v_u8m1((const uint8_t*)s.c_str() + i + 1);\n        prev2 = vle8_v_u8m1((const uint8_t*)s.c_str() + i + 2);\n\n        mask = vmandnot_u8m1(mask, vmand_u8m1(vmsne_u8m1(current, prev1), vmsne_u8m1(current, prev2)));\n        if (vmsne_u8m1(mask, vundefined_u8m1())) {\n            return false;\n        }\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] == s[i - 1] || s[i] == s[i - 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    vuint8m1_t mask = vundefined_u8m1();\n    size_t i = 0;\n\n    for (; i <= len - 3; i += vsetvl_e8m1(1)) {\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)s.c_str() + i);\n        mask = vset_v_u8m1(0);\n        mask = vorr_vv_u8m1(mask, vshl_vx_u8m1(vec, 8));\n        mask = vorr_vv_u8m1(mask, vshl_vx_u8m1(vec, 16));\n        mask = vorr_vv_u8m1(mask, vshl_vx_u8m1(vec, 24));\n\n        if (vfirst_m(mask) != -1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    vbool8_t result = vmslt_vx_i32(vle32_v_i32((int*)&length, 0), 2);\n    if (vany_v_b8(result)) return false;\n\n    vbool8_t prime_check = {true, true, true, true, true, true, true, true};\n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) {\n            prime_check = vmand_vb8(prime_check, vmsne_vx_i32(vle32_v_i32((int*)&length, 0), i));\n        }\n    }\n\n    return vfirst_m_b8(prime_check);\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    vbool8_t result = vmslt_vx_i32_b8(vle32_v_i32(&length, 0), 2);\n    if (vfirst_m_b8(result)) return false;\n\n    int prime_check = is_prime(length);\n    return prime_check;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    vbool8_t mask = vmv_v_x_b8(false);\n    for (int i = 0; i < length; i += 8) {\n        vuint8m1_t indices = vadd_vx_u8m1(vse_v_u8m1(vle_v_u8m1((const uint8_t*)str.data() + i, 8), 8), 1);\n        mask = vorr_vv_b8(mask, vmv_v_x_b8(is_prime(vle_v_u8m1((const uint8_t*)str.data() + i, 8))));\n    }\n\n    return vfirst_m(mask) >= 0;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    vbool8_t result = vmslt_vx_i32(vle32_v_i32(&length), 2); // Check if length < 2\n    if (vfirst_m(result) != -1) return false;\n\n    result = vmseq_vx_i32(vle32_v_i32(&length), 2); // Check if length == 2\n    if (vfirst_m(result) != -1) return true;\n\n    result = vmor_vv(result, vmseq_vx_i32(vle32_v_i32(&length), 3)); // Check if length == 3\n    if (vfirst_m(result) != -1) return true;\n\n    int n = length;\n    for (int i = 5; i * i <= n; i += 6) {\n        vbool8_t div_by_i = vmseq_vx_i32(vle32_v_i32(&n), i);\n        vbool8_t div_by_i_plus_2 = vmseq_vx_i32(vle32_v_i32(&n), i + 2);\n        result = vorr_vv(result, div_by_i);\n        result = vorr_vv(result, div_by_i_plus_2);\n    }\n\n    return vfirst_m(result) == -1;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    vbool8_t result = vmslt_vx_i32(vle32_v_i32((int*)&length, 1), 2);\n    if (vfirst_m_b(result) != -1) return false;\n\n    int primes[4] = {2, 3, 5, 7};\n    vint32m1_t lengths = vmv_v_x_i32m1(length);\n    vint32m1_t primes_vec = vle32_v_i32(primes, 4);\n\n    vbool8_t is_prime_vec = vmslt_vx_i32(lengths, 2);\n    if (vfirst_m_b(is_prime_vec) != -1) return false;\n\n    for (int i = 0; i < 4; i++) {\n        vbool8_t divisible = vmul_vv_i32(lengths, primes_vec);\n        if (vfirst_m_b(divisible) != -1) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n\n    // Vector length\n    const int vl = vsetvl_e64m1(1); // Set vector length for 64-bit integers\n    vint64m1_t v_sum = vundefined_i64m1(); // Initialize vector for sum\n\n    for (int i = 0; i < 64; i += 1) {\n        if (N & mask) {\n            sum += 1;\n        }\n        mask <<= 1;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    if (pos != std::string::npos) {\n        return binary.substr(pos);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n    \n    // Process each bit of N in parallel\n    for (int i = 0; i < 64; i += 8) {\n        vuint64m1_t vec = vundefined_u64m1();\n        for (int j = 0; j < 8; j++) {\n            if (i + j < 64) {\n                vec = vinsert_u64m1(vec, (N >> (i + j)) & mask, j);\n            }\n        }\n        sum += vpopc_u64m1(vec);\n    }\n    \n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    return binary.substr(binary.find('1')); // Remove leading zeros\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n    \n    while (N > 0) {\n        sum += (N & mask) ? 1 : 0;\n        N >>= 1;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    \n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    return pos == std::string::npos ? \"0\" : binary.substr(pos);\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n    \n    // Process each bit of N in parallel\n    for (int i = 0; i < 64; i += 8) {\n        vuint64m1_t vec = vundefined_u64m1();\n        for (int j = 0; j < 8; j++) {\n            if (i + j < 64) {\n                vec = vinsert_u64m1(vec, (N >> (i + j)) & mask, j);\n            }\n        }\n        sum += vpopc_u64m1(vec);\n    }\n    \n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    return binary.substr(binary.find('1')); // Remove leading zeros\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n\n    // Process each bit of N in parallel\n    for (int i = 0; i < 64; i += 8) {\n        vuint64m1_t vec = vle64_v_u64m1(&N);\n        vuint64m1_t bits = vand_vu64m1(vec, vslide1down_vu64m1(vec, 1));\n        sum += vpopc_u64m1(bits);\n        N >>= 8;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    return binary.substr(binary.find('1'));\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    vtype<int> v_sum = vundefined<int>();\n    \n    for (int i = 1; i < n; i += VLEN) {\n        vtype<int> v_data = vle32_v_i32(&lst[i]);\n        vtype<int> v_mask = vmv_v_x_i32(0, VLEN);\n        v_mask = vmslt_vx_i32(v_data, 0, VLEN);\n        v_data = vand_vv_i32(v_data, v_mask);\n        v_sum = vadd_vv_i32(v_sum, v_data);\n    }\n    \n    int result[VECTOR_LENGTH];\n    vse32_v_i32(result, v_sum);\n    \n    for (int i = 0; i < VECTOR_LENGTH; i++) {\n        sum += result[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n\n    vint32m1_t vec = vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t mask = vmseq_vx_i32m1(vec, 0, vl);\n    vint32m1_t even_elements = vand_vx_i32m1(vec, mask, vl);\n    \n    int result = 0;\n    for (size_t i = 1; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int *data = lst.data();\n\n    // Create a vector of integers\n    vtype<int> vec_data = vle32_v_i32(data, n);\n    \n    // Initialize a vector to hold the result\n    vtype<int> vec_sum = vmv_v_x_i32(0, n);\n\n    // Process elements at odd indices\n    for (int i = 1; i < n; i += 2) {\n        vtype<int> vec_elem = vslide1down_v_i32(vec_data, i);\n        vtype<int> vec_mask = vmseq_v_i32(vec_elem, vmv_v_x_i32(0, n)); // Mask for even elements\n        vec_sum = vadd_vv_i32(vec_sum, vmask_v_i32(vec_elem, vec_mask));\n    }\n\n    // Horizontal reduction to get the final sum\n    sum = vreduce_add_v_i32(vec_sum);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int vl = vsetvl_e32(n);\n\n    vuint32m1_t vec = vle32_v_u32m1(lst.data(), vl);\n    vuint32m1_t mask = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t result = vmv_v_x_u32m1(0, vl);\n\n    for (int i = 1; i < n; i += 2) {\n        if ((lst[i] % 2) == 0) {\n            mask = vsetvl_e32(i);\n            result = vadd_vv_u32m1(result, vle32_v_u32m1(lst.data() + i, mask), mask);\n        }\n    }\n\n    sum += vredsum_vs_u32m1(result, sum, vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n\n    // Create a vector of integers\n    vtype<int> vec;\n    vtype<int> result_vec;\n\n    // Load the elements into the vector\n    for (int i = 1; i < n; i += 2) {\n        vec = vload(&lst[i], 1);\n        // Check if the element is even\n        result_vec = vselect(vec % 2 == 0, vec, 0);\n        sum += vreduce_add(result_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Vector length\n    size_t vl = vsetvl_e8(len);\n\n    // Load characters into vector\n    vuint8m1_t vec_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n\n    // Encrypt by rotating the alphabet\n    vuint8m1_t vec_encrypted = vadd_vv_u8m1(vec_chars, vsetvl_e8(2), vl);\n    vec_encrypted = vadd_vv_u8m1(vec_encrypted, vsetvl_e8(2), vl);\n\n    // Store the result back to the string\n    vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), vec_encrypted, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8m1(len);\n\n    // Load input string into vector\n    vuint8m1_t vec_input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n\n    // Encrypt by rotating the alphabet\n    vuint8m1_t vec_output = vadd_vx_u8m1(vec_input, 4, vl); // Shift by 4 (2 * 2)\n\n    // Store the result back to string\n    vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), vec_output, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Vector length\n    size_t vl = vsetvl_e8(len);\n\n    // Load characters into vector\n    vuint8m1_t vec_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n\n    // Encrypt: Rotate each character by 4 (2 * 2)\n    vuint8m1_t vec_encrypted = vadd_vv_u8m1(vec_chars, vdup_u8(4), vl);\n\n    // Store the result back to the string\n    vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), vec_encrypted, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Vector length\n    size_t vl = vsetvl_e8(len);\n\n    // Load input string into vector\n    vuint8m1_t v_input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n\n    // Encrypt by rotating letters\n    vuint8m1_t v_offset = vadd_vx_u8m1(v_input, 2 * 2, vl);\n    vuint8m1_t v_encrypted = vminu_vx_u8m1(v_offset, 122, vl); // 'z' is 122\n    vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), v_encrypted, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Vector length\n    size_t vl = vsetvl_e8(len);\n\n    // Load characters into vector\n    vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)s.c_str(), vl);\n\n    // Encrypt by rotating the alphabet\n    vuint8m1_t vec_encrypted = vadd_vv_u8m1(vec_chars, vsetvl_e8(2), vl);\n    vec_encrypted = vadd_vv_u8m1(vec_encrypted, vsetvl_e8(2), vl);\n\n    // Store the result back\n    vse8_v_u8m1((uint8_t*)result.data(), vec_encrypted, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    size_t vector_length = vsetvl_e8m1(len);\n    vuint8m1_t vec_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(message.data()), vector_length);\n    \n    for (size_t i = 0; i < len; i += vector_length) {\n        size_t vl = std::min(vector_length, len - i);\n        vuint8m1_t vec_vowels = vmseq_v_u8m1(vec_chars, vlev_v_u8m1('a', vl));\n        vec_vowels = vorr_v_u8m1(vec_vowels, vmseq_v_u8m1(vec_chars, vlev_v_u8m1('e', vl)));\n        vec_vowels = vorr_v_u8m1(vec_vowels, vmseq_v_u8m1(vec_chars, vlev_v_u8m1('i', vl)));\n        vec_vowels = vorr_v_u8m1(vec_vowels, vmseq_v_u8m1(vec_chars, vlev_v_u8m1('o', vl)));\n        vec_vowels = vorr_v_u8m1(vec_vowels, vmseq_v_u8m1(vec_chars, vlev_v_u8m1('u', vl)));\n        \n        vuint8m1_t vec_replaced = vadd_v_u8m1(vec_chars, vlev_v_u8m1(2, vl));\n        vec_chars = vblend_vx_u8m1(vec_vowels, vec_replaced, vec_chars);\n        \n        vuint8m1_t vec_upper = vadd_v_u8m1(vec_chars, vlev_v_u8m1('A' - 'a', vl));\n        vec_chars = vblend_vx_u8m1(vmsltu_v_u8m1(vec_chars, vlev_v_u8m1('Z' + 1, vl)), vec_upper, vec_chars);\n        \n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(const_cast<char*>(message.data() + i)), vec_chars, vl);\n    }\n    \n    return message;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result(len, ' ');\n\n    // Create vectors for processing\n    vuint8m1_t v_char;\n    vuint8m1_t v_result;\n    vuint8m1_t v_vowels = vle8_v_u8m1((const uint8_t *)\"aeiouAEIOU\", 10);\n    vuint8m1_t v_offset = vmv_v_x_u8m1(2);\n    \n    for (size_t i = 0; i < len; i += 16) {\n        size_t vl = std::min(len - i, (size_t)16);\n        v_char = vle8_v_u8m1((const uint8_t *)(message.data() + i), vl);\n\n        // Swap case\n        v_char = vadd_vv_u8m1(v_char, vmv_v_x_u8m1(32)); // Toggle case for lower to upper and vice versa\n        \n        // Replace vowels\n        vuint8m1_t v_is_vowel = vmseq_vv_u8m1(v_char, v_vowels);\n        vuint8m1_t v_replaced = vadd_vv_u8m1(v_char, v_offset);\n        v_char = vsel_u8m1(v_is_vowel, v_replaced, v_char);\n\n        vse8_v_u8m1((uint8_t *)(result.data() + i), v_char, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result(len, ' ');\n\n    // Vector length\n    const int vl = vsetvl_e8(len);\n\n    // Load message into vector\n    vuint8m1_t v_msg = vle8_v_u8m1((const uint8_t*)message.c_str(), vl);\n\n    // Prepare output vector\n    vuint8m1_t v_result = v_msg;\n\n    // Process each character\n    for (size_t i = 0; i < len; i += vl) {\n        size_t current_vl = std::min(vl, len - i);\n        \n        // Swap case\n        v_result = vadd_vv_u8m1(v_result, vslidedown_v_u8m1(v_result, 32, current_vl));\n        \n        // Replace vowels\n        vuint8m1_t v_vowels = vmsltu_v_u8m1(v_msg, 91); // Check for vowels\n        v_result = vadd_vv_u8m1(v_result, v_vowels);\n        \n        // Store result\n        vse8_v_u8m1((uint8_t*)&result[i], v_result, current_vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result(len, ' ');\n\n    vuint8m1_t vec_indices = vseq_u8m1(0, 1);\n    vuint8m1_t vec_vowels = vundefined_u8m1();\n    vuint8m1_t vec_replacements = vundefined_u8m1();\n    \n    for (size_t i = 0; i < len; i += vsetvl_e8m1(len - i)) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(message.data() + i), vl);\n        \n        // Swap case\n        vuint8m1_t vec_upper = vadd_vx_u8m1(vec_chars, 32);\n        vuint8m1_t vec_lower = vsub_vx_u8m1(vec_chars, 32);\n        vuint8m1_t vec_case_swapped = vmerge_vx_u8m1(vec_upper, vec_lower, vmsltu_vx_u8m1(vec_chars, 91)); // 'Z' = 90, 'A' = 65\n        \n        // Replace vowels\n        vec_vowels = vundefined_u8m1();\n        vec_replacements = vundefined_u8m1();\n        \n        for (int j = 0; j < vl; j++) {\n            uint8_t char_val = vextract_u8m1(vec_case_swapped, j);\n            if (char_val == 'A' || char_val == 'E' || char_val == 'I' || char_val == 'O' || char_val == 'U' ||\n                char_val == 'a' || char_val == 'e' || char_val == 'i' || char_val == 'o' || char_val == 'u') {\n                vec_vowels = vinsert_u8m1(vec_vowels, j, char_val);\n                vec_replacements = vinsert_u8m1(vec_replacements, j, char_val + 2);\n            }\n        }\n        \n        vec_case_swapped = vmerge_vx_u8m1(vec_case_swapped, vec_replacements, vec_vowels);\n        \n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), vec_case_swapped, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    vuint8m1_t vowels = vundefined_u8m1();\n    vuint8m1_t two_ahead = vundefined_u8m1();\n    \n    // Initialize vowels and their replacements\n    for (int i = 0; i < 26; i++) {\n        char ch = 'a' + i;\n        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {\n            vowels = vinsert_u8m1(vowels, ch, i);\n            two_ahead = vinsert_u8m1(two_ahead, ch + 2, i);\n        }\n    }\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t vl = std::min(len - i, size_t(16));\n        vuint8m1_t input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(message.data() + i), vl);\n        \n        // Swap case\n        vuint8m1_t swapped = vadd_vu8m1(input, vslide1down_u8m1(vadd_vu8m1(input, 32), 32));\n        \n        // Replace vowels\n        for (int j = 0; j < vl; j++) {\n            uint8_t ch = vextract_u8m1(swapped, j);\n            if (ch == 'a' || ch == 'A') {\n                ch = 'C';\n            } else if (ch == 'e' || ch == 'E') {\n                ch = 'G';\n            } else if (ch == 'i' || ch == 'I') {\n                ch = 'K';\n            } else if (ch == 'o' || ch == 'O') {\n                ch = 'Q';\n            } else if (ch == 'u' || ch == 'U') {\n                ch = 'W';\n            }\n            vinsert_u8m1(swapped, ch, j);\n        }\n        \n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), swapped, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    std::vector<char> keys(size);\n    size_t index = 0;\n\n    for (const auto& pair : dict) {\n        keys[index++] = pair.first[0];\n    }\n\n    vuint8m1_t lower_mask = vmsltu_vx_u8m1(vle8_v_u8m1(keys.data()), 'a');\n    vuint8m1_t upper_mask = vmsltu_vx_u8m1(vle8_v_u8m1(keys.data()), 'A');\n\n    bool all_lower = vfirst_m_b8m1(vand_vv_u8m1(lower_mask, vmsltu_vx_u8m1(vle8_v_u8m1(keys.data()), 'z'))) == -1;\n    bool all_upper = vfirst_m_b8m1(vand_vv_u8m1(upper_mask, vmsltu_vx_u8m1(vle8_v_u8m1(keys.data()), 'Z'))) == -1;\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    std::string keys[size];\n    size_t i = 0;\n    for (const auto& pair : dict) {\n        keys[i++] = pair.first;\n    }\n\n    vuint8m1_t lower_mask = vmv_v_x_u8m1(0);\n    vuint8m1_t upper_mask = vmv_v_x_u8m1(0);\n    vuint8m1_t ascii_mask = vmv_v_x_u8m1(0);\n\n    for (size_t j = 0; j < size; j += VLEN) {\n        size_t vl = std::min(VLEN, size - j);\n        vuint8m1_t keys_vec = vle8_v_u8m1((const uint8_t*)keys + j, vl);\n\n        lower_mask = vmsltu_vx_u8m1(keys_vec, 97); // 'a' = 97\n        upper_mask = vmsltu_vx_u8m1(keys_vec, 65); // 'A' = 65\n        ascii_mask = vmsltu_vx_u8m1(keys_vec, 123); // 'z' = 122\n\n        if (vfirst_m_b(lower_mask, vl) != -1 && vfirst_m_b(ascii_mask, vl) != -1) {\n            return false;\n        }\n        if (vfirst_m_b(upper_mask, vl) != -1 && vfirst_m_b(ascii_mask, vl) != -1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    std::string keys[size];\n    size_t index = 0;\n\n    for (const auto& pair : dict) {\n        keys[index++] = pair.first;\n    }\n\n    vbool8_t lower_case_mask = vmslt_vx_u8(vle8_v_u8((const uint8_t*)keys), 97); // 'a'\n    vbool8_t upper_case_mask = vmsgt_vx_u8(vle8_v_u8((const uint8_t*)keys), 90); // 'Z'\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (size_t i = 0; i < size; i += 8) {\n        vuint8m1_t key_vector = vle8_v_u8((const uint8_t*)&keys[i]);\n        vbool8_t lower_case_check = vmule8_v_u8(key_vector, 0x20); // Check if lower case\n        vbool8_t upper_case_check = vmule8_v_u8(key_vector, 0x40); // Check if upper case\n\n        all_lower &= vmsall_v_b8(lower_case_check);\n        all_upper &= vmsall_v_b8(upper_case_check);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    std::vector<char> keys(size);\n    size_t index = 0;\n\n    for (const auto& pair : dict) {\n        keys[index++] = pair.first[0];\n    }\n\n    vuint8m1_t vec_keys = vle8_v_u8m1(keys.data(), size);\n    vbool8_t lower_mask = vmseq_vv_u8m1(vec_keys, vmv_v_x_u8m1('a'));\n    vbool8_t upper_mask = vmseq_vv_u8m1(vec_keys, vmv_v_x_u8m1('A'));\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (size_t i = 0; i < size; i += 8) {\n        vuint8m1_t keys_chunk = vle8_v_u8m1(keys.data() + i, std::min(size - i, size_t(8)));\n        vbool8_t lower_chunk = vmseq_vv_u8m1(keys_chunk, vmv_v_x_u8m1('a'));\n        vbool8_t upper_chunk = vmseq_vv_u8m1(keys_chunk, vmv_v_x_u8m1('A'));\n\n        all_lower = all_lower && vfirst_m_b(lower_chunk);\n        all_upper = all_upper && vfirst_m_b(upper_chunk);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    std::vector<char> keys(size);\n    size_t index = 0;\n\n    for (const auto& pair : dict) {\n        keys[index++] = pair.first[0]; // Assuming single character keys for simplicity\n    }\n\n    vuint8m1_t lower_mask = vmsltu_vx_u8m1(vle8_v_u8m1(keys.data(), size), 'a');\n    vuint8m1_t upper_mask = vmsltu_vx_u8m1(vle8_v_u8m1(keys.data(), size), 'A');\n\n    bool all_lower = vfirst_m_b(vmand_vx_u8m1(lower_mask, vmsltu_vx_u8m1(vle8_v_u8m1(keys.data(), size), 'z'), size), size) == -1;\n    bool all_upper = vfirst_m_b(vmand_vx_u8m1(upper_mask, vmsltu_vx_u8m1(vle8_v_u8m1(keys.data(), size), 'Z'), size), size) == -1;\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    vuint8m1_t is_prime = vmsltu_vx_u8m1(vundefined_u8m1(), 2); // Initialize vector for prime checking\n\n    for (int i = 2; i < n; i += 8) {\n        vuint8m1_t idx = vmv_v_x_u8m1(i, 8);\n        vuint8m1_t prime_check = vmsltu_vx_u8m1(idx, n);\n        is_prime = vand_vv_u8m1(is_prime, prime_check);\n\n        for (int j = 2; j * j < n; j++) {\n            if (j * j >= i && j * j < i + 8) {\n                vuint8m1_t j_vec = vmv_v_x_u8m1(j, 8);\n                vuint8m1_t div_check = vmsltu_vx_u8m1(idx, j_vec);\n                is_prime = vand_vv_u8m1(is_prime, div_check);\n            }\n        }\n\n        for (int k = 0; k < 8; k++) {\n            if (vget_u8m1(is_prime, k) && (i + k) < n) {\n                primes.push_back(i + k);\n            }\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    vbool64_t mask;\n    vuint64m1_t idx = vseq_u64m1(0, 1);\n    vuint64m1_t limit = vsetvl_e64m1(n);\n    \n    for (int i = 2; i < n; i++) {\n        mask = vmslt_u64m1(idx, limit);\n        if (vfirst(mask) == -1) break;\n\n        vbool64_t is_prime = vmv_v_x_b64m1(true, vsetvl_e64m1(1));\n        for (int j = 2; j * j < n; j++) {\n            vuint64m1_t j_vec = vsetvl_e64m1(j);\n            vuint64m1_t div = vdiv_u64m1(vle64_v_u64m1(&i, limit), j_vec);\n            is_prime = vand(is_prime, vmsne_u64m1(div, 0));\n        }\n\n        if (vfirst(is_prime) != -1) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n\n    std::vector<int> primes;\n    vbool64_t mask;\n    vuint64m1_t idx = vseq_u64m1(0, 1);\n    \n    for (int i = 2; i < n; i += 64) {\n        vuint64m1_t v_i = vadd_vx_u64m1(vle64_v_u64m1(&idx, 64), i);\n        mask = vmul_vx_u64m1(v_i, v_i);\n        \n        for (int j = 2; j * j < n; j++) {\n            vbool64_t is_prime = vmsltu_vx_u64m1(v_i, j * j);\n            mask = vand(mask, is_prime);\n        }\n\n        for (int k = 0; k < 64; k++) {\n            if (mask[k] && v_i[k] < n) {\n                primes.push_back(v_i[k]);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n\n    std::vector<int> primes;\n    vbool64_t mask;\n    vuint64m1_t idx = vseq_u64m1(0, 1);\n    vuint64m1_t limit = vsetvl_u64m1(n);\n    \n    for (int i = 2; i < n; i++) {\n        mask = vmslt_u64m1(idx, limit);\n        if (vfirst(mask) == -1) break;\n\n        vbool64_t is_prime = vmv_v_x_u64m1(true, vsetvl_u64m1(n));\n        for (int j = 2; j * j < n; j++) {\n            vuint64m1_t j_vec = vsetvl_u64m1(j);\n            vuint64m1_t multiples = vdiv_u64m1(vdiv_u64m1(idx, j_vec), j_vec);\n            is_prime = vand(is_prime, vmseq_u64m1(multiples, 0));\n        }\n\n        for (int k = 2; k < n; k++) {\n            if (vfirst(is_prime) != -1) {\n                primes.push_back(k);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n\n    std::vector<int> primes;\n    vbool64_t mask;\n    vint32m8_t indices = vseq_v_i32m8(0, 1, n);\n    vbool64_t is_prime = vmv_v_x_i1(1, 1);\n\n    for (int i = 2; i < n; i++) {\n        mask = vmslt_vx_i1(is_prime, 1, i);\n        if (vfirst_m(mask) != -1) {\n            is_prime = vand_vx_i1(is_prime, 1, i);\n            for (int j = i * 2; j < n; j += i) {\n                is_prime = vandi_vx_i1(is_prime, 0, j);\n            }\n        }\n    }\n\n    for (int i = 2; i < n; i++) {\n        if (vfirst_m(is_prime) != -1) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8m1(0); // Set vector length based on the architecture\n\n    for (size_t i = 0; i < len; i += vec_len * 2) {\n        vint8m1_t vec = vle8_v_i8m1(s.data() + i);\n        for (size_t j = 0; j < vec_len && (i + j * 2) < len; j++) {\n            if ((i + j * 2) % 2 == 0) {\n                // Check if the character is an uppercase vowel\n                count += (vec[j] == 'A' || vec[j] == 'E' || vec[j] == 'I' || vec[j] == 'O' || vec[j] == 'U');\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8m1(0); // Set vector length based on the architecture\n\n    for (size_t i = 0; i < len; i += vec_len * 2) {\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)&s[i], vec_len);\n        vuint8m1_t mask = vmseq_vx_u8m1(vec, 'A', vec_len);\n        vuint8m1_t maskE = vmseq_vx_u8m1(vec, 'E', vec_len);\n        vuint8m1_t maskI = vmseq_vx_u8m1(vec, 'I', vec_len);\n        vuint8m1_t maskO = vmseq_vx_u8m1(vec, 'O', vec_len);\n        vuint8m1_t maskU = vmseq_vx_u8m1(vec, 'U', vec_len);\n\n        vuint8m1_t combined_mask = vorr_vv_u8m1(mask, maskE, vec_len);\n        combined_mask = vorr_vv_u8m1(combined_mask, maskI, vec_len);\n        combined_mask = vorr_vv_u8m1(combined_mask, maskO, vec_len);\n        combined_mask = vorr_vv_u8m1(combined_mask, maskU, vec_len);\n\n        count += vpopc_u8m1(combined_mask, vec_len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t vec_length = vsetvl_e8m1(0); // Set vector length based on the element type\n\n    for (size_t i = 0; i < length; i += vec_length * 2) {\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t *)(s.data() + i));\n        vuint8m1_t mask = vmseq_vx_u8m1(vec, 'A');\n        vuint8m1_t maskE = vmseq_vx_u8m1(vec, 'E');\n        vuint8m1_t maskI = vmseq_vx_u8m1(vec, 'I');\n        vuint8m1_t maskO = vmseq_vx_u8m1(vec, 'O');\n        vuint8m1_t maskU = vmseq_vx_u8m1(vec, 'U');\n\n        vuint8m1_t combined_mask = vorr_vv_u8m1(vorr_vv_u8m1(mask, maskE), vorr_vv_u8m1(vorr_vv_u8m1(maskI, maskO), maskU));\n\n        count += vpopc_m(mask, combined_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8m1(0); // Set vector length based on the type\n\n    for (size_t i = 0; i < len; i += vec_len * 2) {\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t *)(s.data() + i));\n        vuint8m1_t vec_upper = vmsltu_v_u8m1(vec_chars, 91); // Check if char < 'Z' + 1\n        vuint8m1_t vec_lower = vmsltu_v_u8m1(vec_chars, 65); // Check if char < 'A'\n        vuint8m1_t vec_vowel = vmand_v_u8m1(vec_upper, vmand_v_u8m1(vec_chars, vslide1down_v_u8m1(vec_chars, 0, 0x00), 0x00)); // Check if char is A, E, I, O, U\n\n        count += vpopc_u8m1(vec_vowel);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t vec_len = vsetvl_e8m1(0); // Set vector length based on element type\n\n    for (size_t i = 0; i < len; i += vec_len * 2) {\n        vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i));\n        vuint8m1_t mask = vmseq_vx_u8m1(vec, 'A');\n        vuint8m1_t mask_e = vmseq_vx_u8m1(vec, 'E');\n        vuint8m1_t mask_I = vmseq_vx_u8m1(vec, 'I');\n        vuint8m1_t mask_O = vmseq_vx_u8m1(vec, 'O');\n        vuint8m1_t mask_U = vmseq_vx_u8m1(vec, 'U');\n\n        vuint8m1_t combined_mask = vorr_vv_u8m1(mask, mask_e);\n        combined_mask = vorr_vv_u8m1(combined_mask, mask_I);\n        combined_mask = vorr_vv_u8m1(combined_mask, mask_O);\n        combined_mask = vorr_vv_u8m1(combined_mask, mask_U);\n\n        count += vpopc_m(mask, combined_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    vtype<int> v_n = vsetvl_e32(levels);\n    vtype<int> v_stones = vle32_v_i32(stones.data(), v_n);\n    \n    for (int i = 0; i < levels; i++) {\n        v_stones[i] = n + 2 * i + (n % 2 == 0 ? i : 0);\n    }\n    \n    vse32_v_i32(stones.data(), v_stones, v_n);\n    return stones;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32_t *result_ptr = result.data();\n    \n    vtype<int32_t> v_n = vsetvl_e32(n);\n    vtype<int32_t> v_start = v_n % 2 == 0 ? v_n : v_n + 1; // Start with n or next odd/even\n    vtype<int32_t> v_increment = v_n % 2 == 0 ? 2 : 2; // Increment by 2\n\n    for (int i = 0; i < n; i += v_n) {\n        vtype<int32_t> v_index = vadd_vx(vsetvl_e32(i), v_start);\n        vse32(result_ptr + i, v_index);\n        v_start = vadd_vx(v_start, v_increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32_t *data = result.data();\n    \n    vtype<int32_t> v_n = vsetvl_e32(n);\n    vtype<int32_t> v_odd = (n % 2 == 1) ? n : n + 1;\n    vtype<int32_t> v_even = (n % 2 == 0) ? n : n + 1;\n\n    for (int i = 0; i < n; i += v_n) {\n        vtype<int32_t> v_index = vadd_vx(vsetvl_e32(v_n), i);\n        vtype<int32_t> v_stones = (n % 2 == 1) ? vadd_vx(v_odd, v_index) : vadd_vx(v_even, v_index);\n        vse32(data + i, v_stones);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> stones(n);\n    int32_t *ptr = stones.data();\n    \n    vtype<int32_t> v_n = vsetvl_e32(n);\n    vtype<int32_t> v_stones = vadd_vx(v_n, 0, v_n);\n    \n    for (int i = 0; i < n; i += v_n) {\n        vtype<int32_t> v_idx = vmul_vx(vsetvl_e32(i), 2);\n        if (n % 2 == 0) {\n            v_stones = vadd_vx(v_stones, 2, v_n);\n        } else {\n            v_stones = vadd_vx(v_stones, 2, v_n);\n        }\n        vse32(ptr + i, v_stones);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    vtype<int> v_n = vsetvl_e32(levels);\n    vint32m1_t v_stones = vmv_v_x_i32m1(n, v_n);\n    \n    for (int i = 0; i < levels; i++) {\n        if (i > 0) {\n            if (n % 2 == 0) {\n                v_stones = vadd_vx_i32m1(v_stones, 2, v_n);\n            } else {\n                v_stones = vadd_vx_i32m1(v_stones, 2, v_n);\n            }\n        }\n        stones[i] = v_stones[i];\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    // Vector length\n    const int vl = vsetvl_e64m1(count);\n\n    // Load values into vector\n    vuint64m1_t vec_n = vle64_v_u64m1(&n, vl);\n    vuint64m1_t vec_m = vadd_u64m1(vec_n, vslide1down_u64m1(vec_n, 1, vl), vl);\n\n    // Compute sum\n    for (int64_t i = 0; i < count; i += vl) {\n        vuint64m1_t vec_sum = vadd_u64m1(vec_n, vec_m, vl);\n        sum += vreduce_add_u64m1(vec_sum, vl);\n        vec_n = vadd_u64m1(vec_n, vsetvl_e64m1(1), vl);\n    }\n\n    // Calculate average\n    int64_t avg = sum / count;\n\n    // Round down\n    int64_t rounded_avg = std::floor(avg);\n\n    // Convert to binary\n    std::string binary;\n    while (rounded_avg > 0) {\n        binary = char((rounded_avg % 2) + '0') + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    // Vectorization\n    const int64_t vector_length = 8; // Adjust based on the architecture\n    vtype<int64_t> v_n = vsetvl_e64(vector_length);\n    vtype<int64_t> v_sum = vdup(v_n, 0);\n\n    for (int64_t i = n; i <= m; i += vector_length) {\n        vtype<int64_t> v_i = vsetvl_e64(vector_length);\n        for (int j = 0; j < vector_length && (i + j) <= m; j++) {\n            v_i[j] = i + j;\n        }\n        v_sum = vadd(v_sum, v_i);\n    }\n\n    // Sum reduction\n    int64_t total_sum = 0;\n    for (int j = 0; j < vector_length; j++) {\n        total_sum += v_sum[j];\n    }\n\n    int64_t avg = total_sum / count;\n    return std::to_string(avg);\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    vtype<int64_t> v_n = vsetvl_e64m1(count);\n    vtype<int64_t> v_sum = vsetvl_e64m1(0);\n    \n    for (int64_t i = n; i <= m; i += v_n) {\n        vtype<int64_t> v_data = vle64_v_i64m1(&i, v_n);\n        v_sum = vadd_vv_i64m1(v_sum, v_data, v_n);\n    }\n\n    int64_t total_sum = sum + v_sum;\n    int64_t avg = total_sum / count;\n\n    return std::to_string(avg);\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    // Vector setup\n    const int64_t vector_length = 8; // Example vector length\n    vtype<int64_t> v_sum = vundefined<int64_t>();\n    vtype<int64_t> v_n = vundefined<int64_t>();\n\n    for (int64_t i = n; i <= m; i += vector_length) {\n        int64_t end = std::min(i + vector_length, m + 1);\n        for (int64_t j = i; j < end; ++j) {\n            v_n = vsetvl_e64(j);\n            v_sum = vadd(v_sum, v_n);\n        }\n    }\n\n    sum += v_sum[0]; // Assuming reduction to get the final sum\n    int64_t avg = sum / count;\n    if (sum % count != 0) avg = (sum / count) + (sum > 0 ? 1 : 0); // Round down\n\n    std::string binary = std::bitset<64>(avg).to_string();\n    return binary.substr(binary.find('1')); // Remove leading zeros\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    // Vector length\n    size_t vl = vsetvl_e64(count);\n\n    // Load values into vector\n    vint64m1_t vec_n = vle64_v_i64m1(&n, vl);\n    vint64m1_t vec_m = vle64_v_i64m1(&m, vl);\n    vint64m1_t vec_sum = vadd_vv_i64m1(vec_n, vec_m);\n\n    // Calculate the sum of the range\n    for (int64_t i = n + 1; i <= m; i++) {\n        vec_sum = vadd_vv_i64m1(vec_sum, vle64_v_i64m1(&i, vl));\n    }\n\n    // Calculate average\n    int64_t avg = sum / count;\n\n    // Round down\n    int64_t rounded_avg = std::floor(avg);\n\n    // Convert to binary\n    std::string binary;\n    while (rounded_avg > 0) {\n        binary = std::to_string(rounded_avg % 2) + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    vtype<int> v_n = vsetvl_n_u32(n);\n    \n    for (int i = 0; i < n; i += v_n) {\n        vuint32m1_t idx = vadd_vx_u32m1(vle32_v_u32m1(&i, v_n), 1, v_n);\n        vuint32m1_t factorial = vmv_v_x_u32m1(1, v_n);\n        vuint32m1_t sum = vmv_v_x_u32m1(0, v_n);\n        \n        for (int j = 1; j <= v_n; ++j) {\n            if (j % 2 == 0) {\n                factorial = vmul_vv_u32m1(factorial, idx, v_n);\n            } else {\n                sum = vadd_vv_u32m1(sum, idx, v_n);\n            }\n        }\n        \n        for (int k = 0; k < v_n; ++k) {\n            if ((i + k) % 2 == 0) {\n                result[i + k] = vextract_u32m1(factorial, k);\n            } else {\n                result[i + k] = vextract_u32m1(sum, k);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    vtype<int> v_n = vsetvl_n_u32(n);\n    \n    for (int i = 0; i < n; i += v_n) {\n        vuint32m1_t idx = vadd_vx_u32m1(vseqlen(v_n), i);\n        vuint32m1_t is_even = vand_vx_u32m1(vrem_vx_u32m1(idx, 2), 1);\n        \n        vuint32m1_t factorial = vmv_v_x_u32m1(1);\n        vuint32m1_t sum = vmv_v_x_u32m1(0);\n        \n        for (int j = 1; j <= v_n; j++) {\n            factorial = vmul_vv_u32m1(factorial, idx);\n            sum = vadd_vv_u32m1(sum, idx);\n            idx = vadd_vx_u32m1(idx, 1);\n        }\n        \n        vuint32m1_t result_even = vrem_vx_u32m1(factorial, 10000);\n        vuint32m1_t result_odd = vrem_vx_u32m1(sum, 10000);\n        \n        result[i] = vmerge_vv_u32m1(result_even, result_odd, is_even);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    vtype<int> v_n = vsetvl_n_u32(n);\n    \n    for (int i = 0; i < n; i += v_n) {\n        vuint32m1_t idx = vadd_vx_u32m1(vle32_v_u32m1(&i), 1, v_n);\n        vuint32m1_t even_mask = vand_vx_u32m1(vrem_vx_u32m1(idx, 2), 1, v_n);\n        \n        vuint32m1_t factorial = vmv_v_x_u32m1(1, v_n);\n        vuint32m1_t sum = vmv_v_x_u32m1(0, v_n);\n        \n        for (int j = 1; j <= n; j++) {\n            vuint32m1_t j_vec = vmv_v_x_u32m1(j, v_n);\n            factorial = vmul_vv_u32m1(factorial, j_vec, v_n);\n            sum = vadd_vv_u32m1(sum, j_vec, v_n);\n        }\n        \n        for (int j = 0; j < v_n; j++) {\n            if (even_mask[j]) {\n                result[i + j] = factorial[j] % 10000;\n            } else {\n                result[i + j] = sum[j];\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    vtype<int> v_n = vsetvl_e32(n);\n    vtype<int> v_i = vsetvl_e32(1);\n    \n    for (int i = 1; i <= n; i += v_n) {\n        vtype<int> idx = vadd_vx(v_i, i);\n        vtype<int> factorial = vsetvl_e32(1);\n        vtype<int> sum = vsetvl_e32(0);\n        \n        for (int j = 0; j < v_n; j++) {\n            if (idx[j] % 2 == 0) {\n                factorial[j] = 1;\n                for (int k = 1; k <= idx[j]; k++) {\n                    factorial[j] = (factorial[j] * k) % 10000;\n                }\n                result[i + j - 1] = factorial[j];\n            } else {\n                sum[j] = (idx[j] * (idx[j] + 1)) / 2;\n                result[i + j - 1] = sum[j];\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    vtype<int> v_n = vsetvl_n_u32(n);\n    \n    for (int i = 0; i < n; i += v_n) {\n        vuint32m1_t idx = vadd_vx_u32m1(vle32_v_u32m1(&i), 1, v_n);\n        vuint32m1_t factorial = vmv_v_x_u32m1(1, v_n);\n        vuint32m1_t sum = vmv_v_x_u32m1(0, v_n);\n        \n        for (int j = 1; j <= v_n; ++j) {\n            if (j % 2 == 0) {\n                factorial = vmul_vv_u32m1(factorial, idx, v_n);\n            } else {\n                sum = vadd_vv_u32m1(sum, idx, v_n);\n            }\n            idx = vadd_vx_u32m1(idx, 1, v_n);\n        }\n        \n        vuint32m1_t result_vec = vblend_vv_u32m1(factorial, sum, v_and_vv_u32m1(vrem_vx_u32m1(idx, 2, v_n), 1, v_n), v_n);\n        vse32_v_u32m1(&result[i], result_vec, v_n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    vuint32m1_t idx = vseq_u32m1(1, 1); // Vector of indices from 1 to n\n    vuint32m1_t limit = vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < limit; i += vsetvl_e32m1(1)) {\n        vuint32m1_t current = vadd_vx_u32m1(idx, i);\n        vbool32_t mask = vmslt_u32m1(current, n + 1);\n        \n        // Check for palindromes\n        vbool32_t is_palindrome = vfalse_b32();\n        for (size_t j = 0; j < vsetvl_e32m1(1); j++) {\n            if (mask[j]) {\n                int num = current[j];\n                int reversed = 0, original = num;\n                while (num > 0) {\n                    reversed = reversed * 10 + num % 10;\n                    num /= 10;\n                }\n                if (original == reversed) {\n                    is_palindrome[j] = true;\n                }\n            }\n        }\n\n        // Count even and odd palindromes\n        for (size_t j = 0; j < vsetvl_e32m1(1); j++) {\n            if (is_palindrome[j]) {\n                if (current[j] % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector of integers from 1 to n\n    vuint32m1_t v_indices = vseq_u32m1(1, 1);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, 1);\n    \n    for (int i = 1; i <= n; i += vsetvl_e32m1(1)) {\n        vuint32m1_t v_numbers = vadd_vx_u32m1(v_indices, i - 1);\n        vbool32_t mask = vmsltu_vx_u32m1(v_numbers, v_n);\n        \n        // Check for palindromes\n        vuint32m1_t v_palindromes = v_numbers;\n        vbool32_t palindrome_mask = vmsgtu_vx_u32m1(v_palindromes, 0);\n        \n        // Count even and odd palindromes\n        for (int j = 0; j < vsetvl_e32m1(1); j++) {\n            if (mask[j] && palindrome_mask[j]) {\n                if (v_palindromes[j] % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector of integers from 1 to n\n    vuint32m1_t v_indices = vseq_u32m1(1, 1);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, 1);\n    \n    for (int i = 1; i <= n; i += vsetvl_e32m1(1)) {\n        vuint32m1_t v_numbers = vadd_vx_u32m1(v_indices, i);\n        vbool32_t mask = vmsltu_vx_u32m1(v_numbers, v_n);\n        \n        // Check for palindromes\n        for (int j = 0; j < vsetvl_e32m1(1); j++) {\n            if (mask[j]) {\n                int num = v_numbers[j];\n                int reversed = 0, original = num;\n\n                while (num > 0) {\n                    reversed = reversed * 10 + num % 10;\n                    num /= 10;\n                }\n\n                if (original == reversed) {\n                    if (original % 2 == 0) {\n                        even_count++;\n                    } else {\n                        odd_count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector of integers from 1 to n\n    vuint32m1_t indices = vundefined_u32m1();\n    for (int i = 0; i < n; i += 8) {\n        indices = vseq_u32m1(i + 1, 8);\n        vuint32m1_t palindromes = vundefined_u32m1();\n        \n        // Check for palindromes\n        for (int j = 0; j < 8 && (i + j + 1) <= n; j++) {\n            int num = i + j + 1;\n            int rev = 0, original = num;\n            while (num > 0) {\n                rev = rev * 10 + num % 10;\n                num /= 10;\n            }\n            if (original == rev) {\n                palindromes = vset_u32m1(palindromes, j, original);\n            }\n        }\n\n        // Count even and odd palindromes\n        for (int j = 0; j < 8 && (i + j + 1) <= n; j++) {\n            if (vget_u32m1(palindromes, j) % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a vector of integers from 1 to n\n    vuint32m1_t v_indices = vseq_u32m1(1, 1);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, 1);\n    \n    for (int i = 1; i <= n; i += vsetvl_e32m1(1)) {\n        vuint32m1_t v_numbers = vadd_vx_u32m1(v_indices, i - 1);\n        vbool32_t mask = vmsltu_vx_u32m1(v_numbers, v_n);\n        \n        // Check for palindromes\n        vuint32m1_t v_palindrome = v_numbers;\n        vbool32_t palindrome_mask = vmfne_vv_u32m1(v_palindrome, v_palindrome);\n        \n        // Count even and odd palindromes\n        vbool32_t even_mask = vand_vv(mask, vmsltu_vx_u32m1(v_palindrome, v_n));\n        vbool32_t odd_mask = vandnot_vv(mask, even_mask);\n        \n        even_count += vpopc(even_mask);\n        odd_count += vpopc(odd_mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t length = n.size();\n    size_t vl = vsetvl_e32(length);\n\n    vuint32m1_t sum_digits = vdup_vx_u32m1(0);\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32(length - i);\n        vint32m1_t vec = vle32_v_i32m1(&n[i], vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int num = vextract_i32m1(vec, j);\n            int abs_num = num < 0 ? -num : num;\n            int digit_sum = 0;\n\n            while (abs_num > 0) {\n                digit_sum += abs_num % 10;\n                abs_num /= 10;\n            }\n\n            if (digit_sum > 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t len = n.size();\n    size_t vl = vsetvl_e32(len);\n    vuint32m1_t count = vundefined_u32m1();\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32(len - i);\n        vint32m1_t vec = vle32_v_i32m1(&n[i], vl);\n        vuint32m1_t sum_digits = vundefined_u32m1();\n\n        for (size_t j = 0; j < vl; ++j) {\n            int32_t num = vextract_i32m1(vec, j);\n            int32_t abs_num = (num < 0) ? -num : num;\n            uint32_t sum = 0;\n\n            while (abs_num > 0) {\n                sum += abs_num % 10;\n                abs_num /= 10;\n            }\n\n            sum_digits = vinsert_u32m1(sum_digits, sum, j);\n        }\n\n        vuint32m1_t mask = vmsltu_u32m1(sum_digits, vundefined_u32m1());\n        count = vadd_u32m1(count, vpopc_u32m1(mask));\n    }\n\n    return vreduce_add_u32m1(count);\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t len = n.size();\n    int count = 0;\n\n    // Create a vector of integers\n    vtype<int> vec_n = vle32_v_i32(n.data(), len);\n    \n    // Initialize a vector to hold the sum of digits\n    vtype<int> sum_digits = vmv_v_x_i32(0, len);\n\n    // Process each integer to calculate the sum of digits\n    for (size_t i = 0; i < len; i += VLEN) {\n        vtype<int> vec_chunk = vle32_v_i32(n.data() + i, VLEN);\n        vtype<int> abs_chunk = vabs_v_i32(vec_chunk);\n        \n        // Calculate the sum of digits\n        for (size_t j = 0; j < VLEN; ++j) {\n            int num = abs_chunk[j];\n            while (num > 0) {\n                sum_digits[j] += num % 10;\n                num /= 10;\n            }\n        }\n    }\n\n    // Count how many elements have a sum of digits > 0\n    for (size_t i = 0; i < VLEN; ++i) {\n        if (sum_digits[i] > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t size = n.size();\n    int count = 0;\n\n    // Create a vector of integers\n    vtype<int> vec_n = vle32_v_i32(n.data(), size);\n\n    // Initialize a vector to hold the sum of digits\n    vtype<int> sum_digits = vmv_v_x_i32(0, size);\n\n    // Process each element to calculate the sum of digits\n    for (size_t i = 0; i < size; i += VLEN / sizeof(int)) {\n        vtype<int> vec_chunk = vle32_v_i32(n.data() + i, VLEN / sizeof(int));\n        vtype<int> abs_chunk = vabs_v_i32(vec_chunk);\n        \n        // Calculate the sum of digits for each number\n        for (int j = 0; j < VLEN / sizeof(int); ++j) {\n            int num = vget_i32(abs_chunk, j);\n            while (num > 0) {\n                sum_digits = vadd_vx_i32(sum_digits, num % 10);\n                num /= 10;\n            }\n        }\n    }\n\n    // Count how many elements have a sum of digits > 0\n    for (size_t i = 0; i < size; i += VLEN / sizeof(int)) {\n        vtype<int> vec_chunk = vle32_v_i32(n.data() + i, VLEN / sizeof(int));\n        vtype<int> is_positive = vsgt_vv_i32(sum_digits, vmv_v_x_i32(0, VLEN / sizeof(int)));\n        count += vpopc(is_positive);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t vl = vsetvl_e32(size);\n\n    vint32m1_t vec_nums = vle32_v_i32m1(n.data(), vl);\n    vint32m1_t vec_sum_digits = vdup32m1(0);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32(size - i);\n        vec_nums = vle32_v_i32m1(n.data() + i, vl);\n\n        for (size_t j = 0; j < vl; j++) {\n            int num = vextract_i32m1(vec_nums, j);\n            int sum = 0;\n            while (num != 0) {\n                sum += abs(num % 10);\n                num /= 10;\n            }\n            vec_sum_digits = vadd_i32m1(vec_sum_digits, vdup32m1(sum));\n        }\n    }\n\n    count = vpopc_m_b32(vmsgtu_v_i32m1(vec_sum_digits, vdup32m1(0), vl));\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    vtype<int> v_arr = vle32_v_i32(arr.data(), N);\n    vtype<int> v_sorted = v_arr;\n\n    // Sort the array using std::sort for comparison\n    std::sort(arr.begin(), arr.end());\n    vtype<int> v_sorted_ref = vle32_v_i32(arr.data(), N);\n\n    // Check if the sorted array can be obtained by right shifts\n    for (int shift = 0; shift < N; ++shift) {\n        vtype<int> v_temp = vslide1down_v_i32(v_sorted, v_sorted, shift);\n        if (vmand(v_temp, v_sorted_ref) == v_sorted_ref) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    vtype<int> v_arr = vle32_v_i32(arr.data(), N);\n    vtype<int> v_sorted = vle32_v_i32(arr.data(), N);\n    \n    // Sort the array using std::sort\n    std::sort(arr.begin(), arr.end());\n    vtype<int> v_sorted_ref = vle32_v_i32(arr.data(), N);\n\n    for (int shift = 0; shift < N; ++shift) {\n        // Perform right shift\n        vtype<int> v_temp = v_arr;\n        v_arr = vslide1down_v_i32(v_temp, v_temp, 0);\n        v_arr = vslide1up_v_i32(v_temp, v_temp, N - 1);\n        \n        // Check if the shifted array is sorted\n        if (vmslt_vv_i32(v_arr, v_sorted_ref, N)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector of integers\n    vtype<int> vec_arr = vle32_v_i32(arr.data(), N);\n    \n    // Create a sorted version of the original array\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    vtype<int> vec_sorted_arr = vle32_v_i32(sorted_arr.data(), N);\n\n    // Check if any rotation of arr matches sorted_arr\n    for (int shift = 0; shift < N; ++shift) {\n        vtype<int> rotated_vec = vslideup_v_i32(vec_arr, shift);\n        if (vmand_v_i32(rotated_vec, vec_sorted_arr) == vec_sorted_arr) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector of integers\n    vtype<int> vec_arr = vle32_v_i32(arr.data(), N);\n    \n    // Find the minimum element\n    int min_elem = vmin_v_i32(vec_arr, N);\n    \n    // Rotate the array to find the sorted order\n    for (int i = 0; i < N; i++) {\n        // Perform right shift\n        vtype<int> shifted_vec = vslide1down_v_i32(vec_arr, i);\n        \n        // Check if the shifted vector is sorted\n        if (std::is_sorted(shifted_vec, shifted_vec + N)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector of integers\n    vtype<int> vec_arr = vle32_v_i32(arr.data(), N);\n    \n    // Sort the array using RVV intrinsic\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if any right shift of arr can match sorted_arr\n    for (int shift = 0; shift < N; ++shift) {\n        vtype<int> shifted_vec = vslide1down_v_i32(vec_arr, shift);\n        if (vmand(vle32_v_i32(shifted_vec.data(), N), vle32_v_i32(sorted_arr.data(), N)) == N) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    vtype<int> vlen = vsetvl_e32(n);\n    \n    vint32m1_t vec1 = vle32_v_i32m1(lst1.data(), vlen);\n    vint32m1_t vec2 = vle32_v_i32m1(lst2.data(), vlen);\n    \n    // Create a mask for even numbers in lst1\n    vbool32_t mask_even = vmseq_vx_i32m1(vec1, 0);\n    vbool32_t mask_odd = vmseq_vx_i32m1(vec1, 1);\n    \n    // Count the number of odd numbers in lst1\n    size_t odd_count = vpopc_m(mask_odd);\n    \n    // Count the number of even numbers in lst2\n    vbool32_t mask_even_lst2 = vmseq_vx_i32m1(vec2, 0);\n    size_t even_count_lst2 = vpopc_m(mask_even_lst2);\n    \n    // If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2\n    if (odd_count <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    vtype<int> vlen = vsetvl_e32(n);\n    \n    vint32m1_t vec1 = vle32_v_i32m1(lst1.data(), vlen);\n    vint32m1_t vec2 = vle32_v_i32m1(lst2.data(), vlen);\n    \n    // Create masks for even and odd numbers\n    vint32m1_t mask_even = vande_vv_i32m1(vec1, vslide1down_v_i32m1(vec1, 1));\n    vint32m1_t mask_odd = vsub_vv_i32m1(vec1, mask_even);\n    \n    // Count odd numbers in lst1\n    size_t odd_count = vpopc_m(mask_odd);\n    \n    // Count even numbers in lst2\n    vint32m1_t even_in_lst2 = vand_vv_i32m1(vec2, vslide1down_v_i32m1(vec2, 1));\n    size_t even_count_in_lst2 = vpopc_m(even_in_lst2);\n    \n    if (odd_count <= even_count_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    vtype<int> vtype = vsetvl_e32(n);\n    \n    vint32m1_t vec1 = vle32_v_i32m1(lst1.data(), vtype);\n    vint32m1_t vec2 = vle32_v_i32m1(lst2.data(), vtype);\n    \n    // Create masks for even and odd numbers\n    vbool32_t mask1 = vmsltu_v_i32m1(vec1, 0);\n    vbool32_t mask2 = vmsltu_v_i32m1(vec2, 0);\n    \n    // Count odd numbers in lst1\n    size_t odd_count1 = vpopc(mask1);\n    // Count even numbers in lst2\n    size_t even_count2 = n - vpopc(mask2);\n    \n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    vtype<int> v1 = vle32_v_i32(lst1.data(), n);\n    vtype<int> v2 = vle32_v_i32(lst2.data(), n);\n    \n    // Create a mask for even numbers in lst1\n    vbool32_t mask_even = vmsltu_v_i32(v1, 0);\n    vbool32_t mask_odd = vmseq_v_i32(v1, v1); // All elements are odd initially\n\n    // Count odd numbers in lst1\n    int odd_count = vpopc(mask_odd);\n\n    // Count even numbers in lst2\n    vbool32_t mask_even_lst2 = vmseq_v_i32(v2, v2);\n    int even_count_lst2 = vpopc(mask_even_lst2);\n\n    // Check if we can exchange enough elements\n    if (odd_count <= even_count_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    vtype<int> vec_type = vsetvl_e32(n);\n    \n    vint32m1_t v_lst1 = vle32_v_i32m1(lst1.data(), vec_type);\n    vint32m1_t v_lst2 = vle32_v_i32m1(lst2.data(), vec_type);\n    \n    // Create masks for even and odd numbers\n    vbool32_t mask_even_lst1 = vredmask_v_i32m1(v_lst1, v_lst1, vsetvl_e32(n));\n    vbool32_t mask_even_lst2 = vredmask_v_i32m1(v_lst2, v_lst2, vsetvl_e32(n));\n    \n    // Count even numbers in lst1\n    int count_even_lst1 = vmv_x_s_i32(mask_even_lst1);\n    // Count odd numbers in lst1\n    int count_odd_lst1 = n - count_even_lst1;\n\n    // Count even numbers in lst2\n    int count_even_lst2 = vmv_x_s_i32(mask_even_lst2);\n    \n    // Check if we have enough even numbers in lst2 to replace odd numbers in lst1\n    if (count_even_lst2 >= count_odd_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &s = lst[i];\n        size_t len = s.length();\n        size_t num_odds = 0;\n\n        // Vectorized processing\n        size_t vector_length = 8; // Assuming we process 8 characters at a time\n        size_t j = 0;\n\n        // Process full vectors\n        for (; j + vector_length <= len; j += vector_length) {\n            vuint8m1_t vec = vle8_v_u8m1((const uint8_t *)(s.data() + j));\n            vuint8m1_t odd_mask = vmsltu_vx_u8m1(vec, 10); // Check if digit is odd\n            num_odds += vpopc_m(odd_mask); // Count odd digits\n        }\n\n        // Process remaining characters\n        for (; j < len; ++j) {\n            if ((s[j] - '0') % 2 != 0) {\n                num_odds++;\n            }\n        }\n\n        result[i] = \"the number of odd elements \" + std::to_string(num_odds) + \n                     \"n the str\" + std::to_string(i) + \n                     \"ng \" + std::to_string(i) + \n                     \" of the \" + std::to_string(i) + \"nput.\";\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &s = lst[i];\n        size_t len = s.length();\n        size_t num_odds = 0;\n\n        vuint8m1_t vec_digits = vle8_v_u8m1((const uint8_t*)s.c_str(), len);\n        vuint8m1_t vec_odd_mask = vmseq_vv_u8m1(vec_digits, vlev_v_u8m1('1', len));\n        vec_odd_mask = vorr_vv_u8m1(vec_odd_mask, vmseq_vv_u8m1(vec_digits, vlev_v_u8m1('3', len)));\n        vec_odd_mask = vorr_vv_u8m1(vec_odd_mask, vmseq_vv_u8m1(vec_digits, vlev_v_u8m1('5', len)));\n        vec_odd_mask = vorr_vv_u8m1(vec_odd_mask, vmseq_vv_u8m1(vec_digits, vlev_v_u8m1('7', len)));\n        vec_odd_mask = vorr_vv_u8m1(vec_odd_mask, vmseq_vv_u8m1(vec_digits, vlev_v_u8m1('9', len)));\n\n        num_odds = vpopc_u8m1(vec_odd_mask);\n\n        result[i] = \"the number of odd elements \" + std::to_string(num_odds) + \"n the str\" + std::to_string(i) + \"ng \" + std::to_string(i) + \" of the \" + std::to_string(i) + \"nput.\";\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &s = lst[i];\n        size_t len = s.length();\n        vuint8m1_t odd_count_vec = vdup_u8(0);\n        size_t j = 0;\n\n        for (; j + 16 <= len; j += 16) {\n            vuint8m1_t digits = vle8_v_u8m1((const uint8_t*)(s.data() + j));\n            vuint8m1_t is_odd = vand_vu8m1(vle8_v_u8m1((const uint8_t*)(s.data() + j)), vdup_u8(1));\n            odd_count_vec = vadd_vv_u8m1(odd_count_vec, is_odd);\n        }\n\n        uint8_t odd_count = 0;\n        for (; j < len; ++j) {\n            if ((s[j] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        odd_count += vget_u8m1(odd_count_vec, 0);\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(i) + \"ng \" + std::to_string(i) + \" of the \" + std::to_string(i) + \"nput.\";\n        result[i] = output;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t len = str.size();\n        size_t vector_length = vsetvl_e8m1(len);\n        vuint8m1_t vec_digits = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(str.c_str()), vector_length);\n        \n        vuint8m1_t vec_odd_mask = vmseq_vx_u8m1(vec_digits, 1);\n        vuint8m1_t vec_odd_mask2 = vmseq_vx_u8m1(vec_digits, 3);\n        vuint8m1_t vec_odd_mask3 = vmseq_vx_u8m1(vec_digits, 5);\n        vuint8m1_t vec_odd_mask4 = vmseq_vx_u8m1(vec_digits, 7);\n        vuint8m1_t vec_odd_mask5 = vmseq_vx_u8m1(vec_digits, 9);\n        vuint8m1_t vec_odd_mask6 = vmseq_vx_u8m1(vec_digits, 11);\n        vuint8m1_t vec_odd_mask7 = vmseq_vx_u8m1(vec_digits, 13);\n        vuint8m1_t vec_odd_mask8 = vmseq_vx_u8m1(vec_digits, 15);\n        \n        vuint8m1_t vec_odd_count = vadd_vv_u8m1(vec_odd_mask, vec_odd_mask2);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask3);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask4);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask5);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask6);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask7);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask8);\n        \n        uint8_t odd_count = vfirst_m_u8m1(vec_odd_count);\n        \n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << static_cast<int>(odd_count) \n            << \"n the str\" << static_cast<int>(odd_count) \n            << \"ng \" << static_cast<int>(odd_count) \n            << \" of the \" << static_cast<int>(odd_count) << \"nput.\";\n        \n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &s = lst[i];\n        size_t len = s.length();\n        vuint8m1_t vec_digits = vle8_v_u8m1(s.data(), len);\n        vuint8m1_t vec_odd_mask = vmseq_vx_u8m1(vec_digits, 1);\n        vuint8m1_t vec_odd_mask2 = vmseq_vx_u8m1(vec_digits, 3);\n        vuint8m1_t vec_odd_mask3 = vmseq_vx_u8m1(vec_digits, 5);\n        vuint8m1_t vec_odd_mask4 = vmseq_vx_u8m1(vec_digits, 7);\n        vuint8m1_t vec_odd_mask5 = vmseq_vx_u8m1(vec_digits, 9);\n        vuint8m1_t vec_odd_mask6 = vmseq_vx_u8m1(vec_digits, 11);\n        vuint8m1_t vec_odd_mask7 = vmseq_vx_u8m1(vec_digits, 13);\n        vuint8m1_t vec_odd_mask8 = vmseq_vx_u8m1(vec_digits, 15);\n        \n        vuint8m1_t vec_odd_count = vadd_vv_u8m1(vec_odd_mask, vec_odd_mask2);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask3);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask4);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask5);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask6);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask7);\n        vec_odd_count = vadd_vv_u8m1(vec_odd_count, vec_odd_mask8);\n        \n        uint8_t odd_count = vget_v_u8m1(vec_odd_count, 0);\n        \n        result[i] = \"the number of odd elements \" + std::to_string(odd_count) +\n                     \"n the str\" + std::to_string(i) + \"ng \" + std::to_string(i) +\n                     \" of the \" + std::to_string(i) + \"nput.\";\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    size_t n = nums.size();\n    size_t vl = vsetvl_e64(n);\n\n    vbool64_t mask = vmslt_vx_i64(vle64_v_i64(&nums[0], vl), 0);\n    vint64m1_t vec_sum = vle64_v_i64(&nums[0], vl);\n    vint64m1_t current_sum = vmv_v_x_i64(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64(n - i);\n        vec_sum = vle64_v_i64(&nums[i], vl);\n        current_sum = vadd_vv_i64(current_sum, vec_sum);\n        min_sum = vmin_vx_i64(min_sum, current_sum, vl);\n        current_sum = vmin_vx_i64(current_sum, 0, vl);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    \n    vtype<int64_t> v_current_sum = vsetvl_n_i64(0);\n    vtype<int64_t> v_min_sum = vsetvl_n_i64(min_sum);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = vsetvl_n_i64(n - i);\n        vtype<int64_t> v_nums = vle64_v_i64(&nums[i], vl);\n        \n        v_current_sum = vadd_vv_i64(v_current_sum, v_nums);\n        v_min_sum = vmin_vv_i64(v_min_sum, v_current_sum);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (current_sum > 0) {\n                current_sum = v_current_sum[j];\n            } else {\n                current_sum += v_current_sum[j];\n            }\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    \n    vtype<int64_t> v_current_sum = vsetvl_e64(n);\n    vtype<int64_t> v_min_sum = vsetvl_e64(n);\n    \n    for (size_t i = 0; i < n; i += v_current_sum) {\n        vtype<int64_t> v_nums = vle64_v_i64m1(&nums[i], v_current_sum);\n        v_current_sum = vadd_vv_i64m1(v_current_sum, v_nums, v_current_sum);\n        \n        for (size_t j = 0; j < v_current_sum; j++) {\n            current_sum += nums[i + j];\n            if (current_sum < min_sum) {\n                min_sum = current_sum;\n            }\n            if (current_sum > 0) {\n                current_sum = 0;\n            }\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    size_t n = nums.size();\n    size_t vl = vsetvl_e64(n);\n\n    vbool64_t mask = vmslt_vx_i64(vle64_v_i64(&nums[0], vl), 0);\n    vint64m1_t vec_sum = vle64_v_i64(&nums[0], vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64(n - i);\n        vint64m1_t current = vle64_v_i64(&nums[i], vl);\n        vec_sum = vadd_vv_i64(vec_sum, current);\n        min_sum = std::min(min_sum, vmin_v_i64m1(vec_sum, mask));\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    \n    vtype<int64_t> v_current_sum = vsetvl_n_i64(1);\n    vtype<int64_t> v_min_sum = vsetvl_n_i64(1);\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_n_i64(n - i);\n        vint64m1_t v_nums = vle64_v_i64m1(&nums[i], vl);\n        \n        v_current_sum = vadd_vv_i64m1(v_current_sum, v_nums, vl);\n        v_min_sum = vmin_vv_i64m1(v_min_sum, v_current_sum, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            if (current_sum > 0) {\n                current_sum = nums[i + j];\n            } else {\n                current_sum += nums[i + j];\n            }\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n    \n    return std::min(min_sum, vget_v_i64m1(v_min_sum, 0));\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        vuint8m1_t v_water = vundefined_u8m1();\n        for (int j = 0; j < cols; j += 16) {\n            vuint8m1_t v_well = vle8_v_u8m1(&grid[i][j]);\n            v_water = vadd_vv_u8m1(v_water, v_well);\n        }\n        uint8_t water_count[16];\n        vse8_v_u8m1(water_count, v_water);\n        for (int k = 0; k < 16; k++) {\n            total_buckets += (water_count[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_wells = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        vuint8m1_t v_count = vundefined_u8m1();\n        for (int j = 0; j < cols; j += 16) {\n            vuint8m1_t v_data = vle8_v_u8m1(&grid[i][j]);\n            v_count = vadd_vv_u8m1(v_count, v_data);\n        }\n        total_wells += vget_sum_u8m1(v_count);\n    }\n\n    return (total_wells + capacity - 1) / capacity; // Ceiling division\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_wells = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        vuint8m1_t v_water = vundefined_u8m1();\n        for (int j = 0; j < cols; j += 8) {\n            vuint8m1_t v_data = vle8_v_u8m1(&grid[i][j]);\n            v_water = vadd_vv_u8m1(v_water, v_data);\n        }\n        total_wells += vget_sum_u8m1(v_water);\n    }\n    \n    return (total_wells + capacity - 1) / capacity; // Ceiling division\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_wells = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        vuint8m1_t v_count = vundefined_u8m1();\n        for (int j = 0; j < cols; j += 8) {\n            vuint8m1_t v_data = vle8_v_u8m1(&grid[i][j]);\n            v_count = vadd_vv_u8m1(v_count, v_data);\n        }\n        uint8_t count_array[8];\n        vse8_v_u8m1(count_array, v_count);\n        for (int k = 0; k < 8; ++k) {\n            total_wells += count_array[k];\n        }\n    }\n    \n    return (total_wells + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_wells = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        vuint8m1_t v_sum = vdup_v_u8m1(0);\n        for (int j = 0; j < cols; j += 16) {\n            vuint8m1_t v_data = vle8_v_u8m1(&grid[i][j]);\n            v_sum = vadd_vv_u8m1(v_sum, v_data);\n        }\n        uint8_t sum_array[16];\n        vse8_v_u8m1(sum_array, v_sum);\n        for (int k = 0; k < 16; ++k) {\n            total_wells += sum_array[k];\n        }\n    }\n\n    return (total_wells + capacity - 1) / capacity; // Ceiling division\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n\n    // Create a vector of 16-bit integers\n    vtype<int16_t> vec;\n    vtype<int16_t> odd_mask = vmv_v_x_i16(1); // Mask for odd numbers\n    vtype<int16_t> even_mask = vmv_v_x_i16(0); // Mask for even positions\n\n    for (size_t i = 0; i < n; i += VLEN / sizeof(int16_t)) {\n        size_t vl = std::min(VLEN / sizeof(int16_t), n - i);\n        vec = vle16_v_i16(&lst[i], vl);\n\n        // Create a mask for odd numbers\n        vbool16_t odd_elements = vmseq_vv_i16(vec, odd_mask);\n        // Create a mask for even positions\n        vbool16_t even_positions = vmseq_vv_i16(vsrl_vx_i16(vle16_v_i16(&lst[i], vl), 1), even_mask);\n\n        // Combine masks\n        vbool16_t combined_mask = vand_vv_b16(odd_elements, even_positions);\n\n        // Sum the selected elements\n        sum += vreduce_add_v_i16(vec, combined_mask);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n\n    // Create a vector of 16-bit integers\n    vtype<int16_t> vec;\n    vtype<int16_t> odd_mask = vsetvl_e16m1(1); // Mask for odd numbers\n    vtype<int16_t> even_pos_mask = vsetvl_e16m1(1); // Mask for even positions\n\n    for (size_t i = 0; i < n; i += 2) {\n        vec = vle16_v_i16m1(&lst[i], vsetvl_e16m1(1));\n        vtype<int16_t> odd_elements = vand_vv_i16m1(vec, odd_mask);\n        sum += vreduce_add_i16m1(odd_elements);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n\n    // Create a vector of 16-bit integers\n    vtype<int16_t> vec = vundefined<int16_t>();\n    size_t vec_len = vsetvl_e16(n);\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        size_t vl = std::min(vec_len, n - i);\n        vec = vle16_v_i16m1(&lst[i], vl);\n\n        // Create a mask for odd elements at even positions\n        vbool1_t mask = vmseq_vx_i16m1(vec, 1); // mask for odd elements\n        vbool1_t even_pos_mask = vmseq_vx_i16m1(vsetvl_e16(i), 0); // mask for even positions\n\n        // Combine masks\n        vbool1_t combined_mask = vand_vv_i16m1(mask, even_pos_mask);\n\n        // Sum the selected elements\n        sum += vredsum_vs_i16m1(vec, combined_mask, 0);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    \n    vtype<int16_t> *vec = new vtype<int16_t>[n];\n    for (size_t i = 0; i < n; i++) {\n        vec[i] = lst[i];\n    }\n\n    size_t vl = vsetvl_e16(n);\n    vint16m1_t v_sum = vmv_v_x_i16m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += 2) {\n        vint16m1_t v_elem = vle16_v_i16m1(&vec[i], vl);\n        vbool16_t mask = vmslt_vx_i16m1(v_elem, 0);\n        v_elem = vand_vx_i16m1(v_elem, mask);\n        v_sum = vadd_vv_i16m1(v_sum, v_elem);\n    }\n\n    sum = vredsum_vs_i16m1(v_sum, sum, vl);\n    delete[] vec;\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    size_t vl = vsetvl_e16(n);\n\n    vuint16m1_t vec = vle16_v_u16m1(lst.data(), vl);\n    vuint16m1_t odd_mask = vmseq_vx_u16m1(vec, 1); // Mask for odd numbers\n    vuint16m1_t even_pos_mask = vmslt_vx_u16m1(vsrl_vx_u16m1(vec, 1), n); // Mask for even positions\n\n    vuint16m1_t filtered = vand_vv_u16m1(vec, odd_mask);\n    vuint16m1_t result = vand_vv_u16m1(filtered, even_pos_mask);\n\n    for (size_t i = 0; i < vl; i++) {\n        sum += result[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    vtype<int> v_sum = vundefined<int>();\n\n    for (int i = 0; i < len; i += VLEN) {\n        vint32m4_t v_arr = vle32_v_i32m4(&arr[i]);\n        vbool32_t mask = vmle32_v_i32m4(v_arr, 99); // Elements <= 99\n        v_arr = vselect_v_i32m4(mask, v_arr, vundefined<int>());\n\n        v_sum = vadd_vv_i32m4(v_sum, v_arr);\n    }\n\n    // Horizontal sum of the vector\n    int32_t temp[VLEN];\n    vse32_v_i32m4(temp, v_sum);\n    for (int i = 0; i < VLEN; i++) {\n        if (temp[i] <= 99) {\n            sum += temp[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    vtype<int> v_sum = vundefined<int>();\n    for (int i = 0; i < len; i += VLEN) {\n        int vl = std::min(VLEN, len - i);\n        vint32m1_t v_arr = vle32_v_i32m1(&arr[i], vl);\n        vbool32_t mask = vmle32_v_i32m1_b32(v_arr, 10);\n        v_arr = vselect_v_i32m1_b32(mask, v_arr, vundefined<int>());\n        v_sum = vadd_vv_i32m1(v_sum, v_arr);\n    }\n    \n    sum += vget_i32m1(v_sum, 0);\n    for (int i = 1; i < VLEN; i++) {\n        sum += vget_i32m1(v_sum, i);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    vtype<int> v_arr = vle32_v_i32(arr.data(), len);\n    vtype<int> v_mask = vmv_v_x_i32(0, len);\n    \n    for (int i = 0; i < len; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            v_mask = vset_v_i32(v_mask, i);\n        }\n    }\n    \n    vtype<int> v_result = vadd_vv_i32(v_arr, v_mask);\n    sum = vreduce_add_i32(v_result);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    vtype<int> v_arr = vle32_v_i32(arr.data(), len);\n    vtype<int> v_mask = vmv_v_x_i32(0, len);\n    \n    for (int i = 0; i < len; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            v_mask = vset_v_i32(v_mask, i);\n        }\n    }\n    \n    vtype<int> v_filtered = vmask(v_arr, v_mask);\n    sum = sum_v_i32(v_filtered);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    vtype<int> vec_len = vsetvl_e32(len);\n    vint32m1_t vec_arr = vle32_v_i32m1(arr.data(), vec_len);\n    \n    // Create a mask for elements with at most two digits\n    vint32m1_t mask = vmslt_vx_i32m1(vec_arr, 100);\n    \n    // Apply the mask to filter elements\n    vint32m1_t filtered = vand_vv_i32m1(vec_arr, mask);\n    \n    // Sum the filtered elements\n    sum = vadd_vx_i32m1(vsum_v_i32m1(filtered, vec_len), 0);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    vtype<int> v_n = vsetvl_e32(n);\n    vint32m8_t v_prev = vle32_v_i32m8(lst.data());\n    vint32m8_t v_curr;\n    bool sorted = true;\n    bool has_duplicates = false;\n\n    for (size_t i = 1; i < n; i += v_n) {\n        v_curr = vle32_v_i32m8(lst.data() + i);\n        vbool8_t cmp = vmslt_vv_i32m8(v_curr, v_prev);\n        if (vfirst_m_b8(cmp)) {\n            sorted = false;\n            break;\n        }\n        vbool8_t dup_cmp = veq_vv_i32m8(v_curr, v_prev);\n        if (vfirst_m_b8(dup_cmp)) {\n            has_duplicates = true;\n            break;\n        }\n        v_prev = v_curr;\n    }\n\n    return sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    vtype<int> v_n = vsetvl_e32(n);\n    vtype<int> v_prev = vld(v_n, lst.data());\n    \n    for (size_t i = 1; i < n; i += v_n) {\n        vtype<int> v_curr = vld(v_n, lst.data() + i);\n        \n        // Check if current is less than previous\n        vtype<bool> v_less = vlt(v_curr, v_prev);\n        if (vfirst(v_less) != -1) return false;\n\n        // Check for duplicates\n        vtype<bool> v_equal = veq(v_curr, v_prev);\n        if (vfirst(v_equal) != -1) return false;\n\n        v_prev = v_curr;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    vtype<int> v_n = vsetvl_e32(n);\n    vint32m1_t vec = vle32_v_i32m1(lst.data(), v_n);\n    \n    // Check for ascending order and duplicates\n    for (size_t i = 0; i < n - 1; i += v_n) {\n        vint32m1_t next_vec = vle32_v_i32m1(lst.data() + i + 1, v_n);\n        vint32m1_t cmp = vmslt_vv_i32m1(vec, next_vec, v_n);\n        vint32m1_t dup = veq_vv_i32m1(vec, next_vec, v_n);\n        \n        if (vfirst_m_b(vmslt_vv_i32m1(vec, next_vec, v_n)) == -1 || \n            vfirst_m_b(dup) != -1) {\n            return false;\n        }\n        \n        vec = next_vec;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    vtype<int> v_n = vsetvl_n_u32(n);\n    vint32m1_t v_prev = vle32_v_i32m1(lst.data());\n    vint32m1_t v_curr;\n    bool sorted = true;\n    bool has_duplicates = false;\n\n    for (size_t i = 1; i < n; i += v_n) {\n        v_curr = vle32_v_i32m1(lst.data() + i);\n        \n        // Check for sorted order and duplicates\n        if (vfirst_m(vle32_v_i32m1(lst.data() + i - 1)) > vfirst_m(v_curr)) {\n            sorted = false;\n            break;\n        }\n\n        // Check for duplicates\n        if (vfirst_m(v_prev) == vfirst_m(v_curr)) {\n            has_duplicates = true;\n            break;\n        }\n\n        v_prev = v_curr;\n    }\n\n    return sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    vtype<int> v;\n    vbool32_t mask;\n    for (size_t i = 0; i < n; i += 32) {\n        size_t len = std::min(32UL, n - i);\n        v = vle32_v_i32(&lst[i], len);\n\n        if (i > 0) {\n            vtype<int> prev_v = vle32_v_i32(&lst[i - 1], len);\n            mask = vmslt_vv_i32_b32(prev_v, v);\n            if (vmsne_vv_i32_b32(mask, prev_v, v)) {\n                return false;\n            }\n        }\n\n        if (i > 0) {\n            vtype<int> prev_v = vle32_v_i32(&lst[i - 1], len);\n            mask = vmsne_vv_i32_b32(v, prev_v);\n            if (vmsall_v_b32(mask)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    vtype<int> vlen = vsetvl_e32(n);\n    vint32m1_t vec = vle32_v_i32m1(arr.data(), vlen);\n    \n    vint32m1_t abs_vec = vabs_v_i32m1(vec, vlen);\n    vint32m1_t sign_vec = vsgn_v_i32m1(vec, vlen);\n    \n    int32_t sum_abs = vreduce_add_i32m1(abs_vec, vlen);\n    int32_t prod_sign = vreduce_mul_i32m1(sign_vec, vlen);\n    \n    return sum_abs * prod_sign;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    vtype<int> v_n = vsetvl_e32(n);\n    \n    vint32m1_t v_sum_magnitudes = vdup_v_i32m1(0);\n    vint32m1_t v_product_signs = vdup_v_i32m1(1);\n    \n    for (size_t i = 0; i < n; i += v_n) {\n        size_t vl = vsetvl_e32(n - i);\n        vint32m1_t v_data = vle32_v_i32m1(&arr[i], vl);\n        \n        vint32m1_t v_signs = vmsgtu_v_i32m1(v_data, vdup_v_i32m1(0));\n        v_signs = vadd_vx_i32m1(v_signs, vmsgtu_v_i32m1(v_data, vdup_v_i32m1(0)));\n        v_signs = vsub_vx_i32m1(v_signs, vmsgtu_v_i32m1(v_data, vdup_v_i32m1(-1)));\n        \n        v_product_signs = vmul_vv_i32m1(v_product_signs, v_signs);\n        \n        v_sum_magnitudes = vadd_vv_i32m1(v_sum_magnitudes, vabs_v_i32m1(v_data));\n    }\n    \n    int sum_magnitudes = vredsum_vs_i32m1(v_sum_magnitudes, 0, vl);\n    int product_signs = vredmin_vs_i32m1(v_product_signs, 1, vl);\n    \n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int n = arr.size();\n    vtype<int> v_n = vsetvl_n_i32(n);\n    vint32m1_t vec = vle32_v_i32m1(arr.data(), v_n);\n    \n    vint32m1_t abs_vec = vabs_v_i32m1(vec, v_n);\n    vint32m1_t sign_vec = vsign_v_i32m1(vec, v_n);\n    \n    int sum_magnitudes = vredsum_vs_i32m1_i32m1(abs_vec, 0, v_n);\n    \n    int product_signs = 1;\n    for (int i = 0; i < n; i++) {\n        int sign = arr[i] > 0 ? 1 : (arr[i] < 0 ? -1 : 0);\n        if (sign == 0) {\n            product_signs = 0;\n            break;\n        }\n        product_signs *= sign;\n    }\n    \n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    vtype<int> vsum = vundefined<int>();\n    vtype<int> vprod_signs = vundefined<int>();\n    vtype<int> vzero = vundefined<int>();\n    \n    vprod_signs = vsetvl(n);\n    vsum = vsetvl(n);\n    \n    int sign_product = 1;\n    int sum_magnitude = 0;\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = vsetvl(n - i);\n        vtype<int> vdata = vle32_v_i32(arr.data() + i, vl);\n        vtype<int> vmagnitudes = vabs(vdata);\n        \n        vtype<int> vsigns = vdata;\n        vtype<int> vmask = vsigns != vzero;\n        \n        sign_product *= vmask ? (vsign > 0 ? 1 : -1) : 0;\n        sum_magnitude += vadd(vmagnitudes);\n    }\n\n    return sum_magnitude * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int n = arr.size();\n    vtype<int> v_n = vsetvl_n_i32(n);\n    \n    vint32m1_t vec = vle32_v_i32m1(arr.data(), v_n);\n    vint32m1_t abs_vec = vabs_v_i32m1(vec, v_n);\n    \n    vint32m1_t sign_vec = vsgn_v_i32m1(vec, v_n);\n    vint32m1_t prod_signs = vreduce_mul_v_i32m1(sign_vec, v_n);\n    \n    int sum_magnitudes = vredsum_vs_i32m1(abs_vec, 0, v_n);\n    \n    return sum_magnitudes * prod_signs;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    vuint32m1_t min_path = vundefined_u32m1();\n    vuint32m1_t current_path = vundefined_u32m1();\n    \n    for (int step = 0; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int idx = i * N + j;\n                current_path = vle32_v_u32m1(&path[idx], 1);\n                \n                if (step == 0 || vfirst_m_b32(min_path, current_path) == -1) {\n                    min_path = current_path;\n                } else {\n                    min_path = vmin_u32m1(min_path, current_path);\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < k; ++i) {\n        result[i] = vfirst_u32m1(min_path);\n        min_path = vslide1down_u32m1(min_path, min_path);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path_values(N * N);\n    \n    // Flatten the grid into a single vector\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path_values[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize vector registers\n    vuint32m1_t min_path = vundefined_u32m1();\n    vuint32m1_t current_path = vundefined_u32m1();\n\n    // Iterate through all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        int x = start / N;\n        int y = start % N;\n\n        // Initialize the current path\n        for (int step = 0; step < k; ++step) {\n            if (step == 0) {\n                current_path = vmv_v_x_u32m1(path_values[start], 1);\n            } else {\n                // Move to neighbors and collect values\n                std::vector<int> neighbors;\n                if (x > 0) neighbors.push_back(grid[x - 1][y]); // Up\n                if (x < N - 1) neighbors.push_back(grid[x + 1][y]); // Down\n                if (y > 0) neighbors.push_back(grid[x][y - 1]); // Left\n                if (y < N - 1) neighbors.push_back(grid[x][y + 1]); // Right\n\n                // Load neighbor values into vector\n                vuint32m1_t neighbor_vec = vundefined_u32m1();\n                for (size_t i = 0; i < neighbors.size(); ++i) {\n                    neighbor_vec = vslide1down_u32m1(neighbor_vec, vmv_v_x_u32m1(neighbors[i], 1), i);\n                }\n\n                // Update current path\n                current_path = vmerge_u32m1(current_path, neighbor_vec, 1);\n            }\n        }\n\n        // Compare paths lexicographically\n        if (vfirst_u32m1(current_path) < vfirst_u32m1(min_path) || vfirst_u32m1(min_path) == 0) {\n            min_path = current_path;\n        }\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = vfirst_u32m1(min_path);\n        min_path = vslide1down_u32m1(min_path, min_path, 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            path.clear();\n            int x = i, y = j;\n            for (int step = 0; step < k; step++) {\n                path.push_back(grid[x][y]);\n                if (step < k - 1) {\n                    // Move to the minimum neighbor\n                    int min_value = INT_MAX;\n                    int next_x = x, next_y = y;\n                    for (int dx = -1; dx <= 1; dx++) {\n                        for (int dy = -1; dy <= 1; dy++) {\n                            if (abs(dx) + abs(dy) == 1) { // Only orthogonal moves\n                                int nx = x + dx, ny = y + dy;\n                                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                                    if (grid[nx][ny] < min_value) {\n                                        min_value = grid[nx][ny];\n                                        next_x = nx;\n                                        next_y = ny;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    x = next_x;\n                    y = next_y;\n                }\n            }\n            if (path.size() == k) {\n                if (result.empty() || std::lexicographical_compare(path.begin(), path.end(), result.begin(), result.end())) {\n                    result = path;\n                }\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    // Flatten the grid into a single vector\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize vector registers\n    vuint32m1_t v_indices = vundefined_u32m1();\n    vuint32m1_t v_min_path = vundefined_u32m1();\n    vuint32m1_t v_temp_path = vundefined_u32m1();\n    \n    // Iterate to find the minimum path\n    for (int step = 0; step < k; step++) {\n        for (int i = 0; i < N * N; i += vsetvl_e32m1(N * N)) {\n            v_indices = vadd_vx_u32m1(v_indices, i);\n            v_temp_path = vle32_v_u32m1(&path[i], vsetvl_e32m1(N * N));\n            v_min_path = vmin_vv_u32m1(v_min_path, v_temp_path, vsetvl_e32m1(N * N));\n        }\n        \n        // Store the minimum path value\n        vse32_v_u32m1(&result[step], v_min_path, vsetvl_e32m1(N * N));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    // Flatten the grid into a single vector\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the vector for the minimum path\n    vuint32m1_t min_path = vundefined_u32m1();\n    vuint32m1_t current_path = vundefined_u32m1();\n    \n    // Iterate over all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        // Initialize the current path\n        for (int step = 0; step < k; ++step) {\n            int idx = start + step; // This is a simplified version, actual movement logic needed\n            if (idx < N * N) {\n                current_path = vle32_v_u32m1(&path[idx]);\n            }\n        }\n        \n        // Compare lexicographically\n        if (vfirst_m_b32(min_path) == 0 || vfirst_m_b32(current_path) < vfirst_m_b32(min_path)) {\n            min_path = current_path;\n        }\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = vget_v_u32m1(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    // Convert the number to a string to process each digit\n    char str[20];\n    snprintf(str, sizeof(str), \"%llu\", n);\n    size_t len = strlen(str);\n\n    // Create a vector of characters\n    vuint8m1_t vec_digits = vundefined_u8m1();\n    for (size_t i = 0; i < len; i++) {\n        vec_digits = vslide1down_u8m1(vec_digits, str[i] - '0', i);\n    }\n\n    // Process the digits in parallel\n    for (size_t i = 0; i < len; i += vsetvl_e8m1(len - i)) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vuint8m1_t digits = vlox_u8m1(vec_digits, i, vl);\n        vbool8_t mask = vmslt_u8m1(digits, 10);\n        \n        // Check for odd digits\n        vbool8_t odd_mask = vand_vb_u8m1(mask, vmsne_u8m1(digits, 0));\n        if (vfirst_m(odd_mask)) {\n            has_odd = 1;\n            vuint8m1_t odd_digits = vmand_vb_u8m1(odd_mask, digits);\n            product *= vreduce_mul_u8m1(odd_digits);\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    int count = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    // Vector length\n    size_t len = strlen(str);\n    vuint8m1_t vec_digits = vundefined_u8m1();\n    \n    // Load digits into vector\n    for (size_t i = 0; i < len; i += 8) {\n        size_t vl = (len - i) < 8 ? (len - i) : 8;\n        for (size_t j = 0; j < vl; j++) {\n            vec_digits = vslideup_v_u8m1(vec_digits, str[i + j] - '0', j);\n        }\n\n        // Process odd digits\n        vbool8_t mask = vmul_vx_u8m1(vec_digits, 1);\n        for (size_t j = 0; j < vl; j++) {\n            if (vget_u8m1(vec_digits, j) % 2 != 0) {\n                product *= vget_u8m1(vec_digits, j);\n                count++;\n            }\n        }\n    }\n\n    return count > 0 ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n    \n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    size_t len = strlen(str);\n    vuint8m1_t vec_digits = vundefined_u8m1();\n    \n    for (size_t i = 0; i < len; i += vsetvl_e8m1(len - i)) {\n        size_t vl = vsetvl_e8m1(len - i);\n        for (size_t j = 0; j < vl; j++) {\n            if (i + j < len) {\n                vec_digits = vslide1down_u8m1(vec_digits, str[i + j] - '0', j);\n            }\n        }\n        \n        vuint8m1_t odd_mask = vand_u8m1(vec_digits, vundefined_u8m1());\n        vuint8m1_t odd_digits = vmand_u8m1(vec_digits, vsetvl_e8m1(1), odd_mask);\n        \n        for (size_t j = 0; j < vl; j++) {\n            uint8_t digit = vextract_u8m1(odd_digits, j);\n            if (digit % 2 != 0) {\n                product *= digit;\n                has_odd = 1;\n            }\n        }\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    int count = 0;\n\n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    // Vector length\n    size_t len = strlen(str);\n    vuint8m1_t vec_digits = vundefined_u8m1();\n    \n    // Load digits into vector\n    for (size_t i = 0; i < len; i++) {\n        vec_digits = vslide1down_u8m1(vec_digits, vundefined_u8m1(), i);\n        vec_digits = vinsert_u8m1(vec_digits, str[i] - '0', i);\n    }\n\n    // Process odd digits\n    vuint8m1_t odd_mask = vmv_v_x_u8m1(0);\n    vuint8m1_t odd_digits = vundefined_u8m1();\n    \n    for (size_t i = 0; i < len; i++) {\n        vuint8m1_t digit = vslide1down_u8m1(vec_digits, vundefined_u8m1(), i);\n        vuint8m1_t is_odd = vand_vx_u8m1(digit, 1);\n        odd_mask = vor_vv_u8m1(odd_mask, is_odd);\n        odd_digits = vselect_u8m1(is_odd, digit, odd_digits);\n    }\n\n    // Calculate the product of odd digits\n    for (size_t i = 0; i < len; i++) {\n        vuint8m1_t digit = vslide1down_u8m1(odd_digits, vundefined_u8m1(), i);\n        if (vfirst_m(odd_mask)) {\n            product *= vget_u8m1(digit, 0);\n            count++;\n        }\n    }\n\n    return count > 0 ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n    \n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    size_t len = strlen(str);\n    vuint8m1_t vec_digits = vle8_v_u8m1((const uint8_t*)str, len);\n    \n    for (size_t i = 0; i < len; i += vsetvl_e8m1(len - i)) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vuint8m1_t digits = vle8_v_u8m1((const uint8_t*)str + i, vl);\n        \n        // Convert ASCII digits to integer values\n        vuint8m1_t odd_mask = vmsltu_v_u8m1(digits, vundefined_u8m1());\n        vuint8m1_t is_odd = vand_vu8m1(odd_mask, vmsgtu_v_u8m1(digits, vset_u8(0)));\n        \n        // Calculate product of odd digits\n        vuint8m1_t odd_digits = vadd_vu8m1(digits, vset_u8(0));\n        odd_digits = vand_vu8m1(odd_digits, is_odd);\n        \n        // Update product and check if we have odd digits\n        for (size_t j = 0; j < vl; j++) {\n            if (odd_digits[j] != 0) {\n                product *= odd_digits[j];\n                has_odd = 1;\n            }\n        }\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(lst.data(), vl);\n    vuint32m1_t rounded = vfcvt_rtz_u_f32m1(vec);\n    vuint32m1_t squared = vmul_vv_u32m1(rounded, rounded, vl);\n    uint64_t sum = vreduce_add_u32m1(squared, vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(lst.data(), vl);\n    vfloat32m1_t ceil_vec = vfcvt_f32_v_i32m1(vfceil_v_f32m1(vec), vl);\n    vint32m1_t squared_vec = vmul_vv_i32m1(vfcvt_rtz_v_f32m1(ceil_vec), vfcvt_rtz_v_f32m1(ceil_vec), vl);\n    \n    uint64_t sum = 0;\n    for (size_t i = 0; i < vl; i++) {\n        sum += vget_v_i32m1(squared_vec, i);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(lst.data(), vl);\n    vfloat32m1_t rounded_vec = vfcvt_rtz_f32_v_f32m1(vec);\n    vfloat32m1_t ceil_vec = vfcvt_rtz_f32_v_f32m1(vfadd_vf_f32m1(vec, 0.999999f)); // Ceiling operation\n    vuint32m1_t squared_vec = vmul_vv_u32m1(vfcvt_u32_f32m1(ceil_vec), vfcvt_u32_f32m1(ceil_vec), vl);\n    \n    uint64_t sum = 0;\n    for (size_t i = 0; i < vl; i++) {\n        sum += vget_v_u32m1(squared_vec, i);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(lst.data(), vl);\n    vfloat32m1_t rounded_vec = vfcvt_f32_v_i32m1(vfceil_v_f32m1(vec, vl), vl);\n    vfloat32m1_t squared_vec = vfmul_vv_f32m1(rounded_vec, rounded_vec, vl);\n    \n    uint64_t sum = 0;\n    for (size_t i = 0; i < n; i += vl) {\n        size_t current_vl = vsetvl_e32(n - i);\n        vfloat32m1_t temp = vle32_v_f32m1(squared_vec.data() + i, current_vl);\n        sum += vfredsum_vs_f32m1(temp, sum, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t vl = vsetvl_e32(n);\n    vfloat32m1_t vec = vle32_v_f32m1(lst.data(), vl);\n    vint32m1_t rounded = vfcvt_rtz_x_f32m1(vec);\n    vint32m1_t ceil_vec = vfcvt_rtz_x_f32m1(vfadd_vf_f32m1(vec, 0.999999f));\n    vint32m1_t squared = vmul_vv_i32m1(ceil_vec, ceil_vec, vl);\n    \n    uint64_t sum = 0;\n    for (size_t i = 0; i < vl; i++) {\n        sum += vget_i32m1(squared, i);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    vtype<int> vec_size = vsetvl_n_u32(n);\n    vtype<int> indices = vundefined<int>(vec_size);\n    vtype<int> prev_elements = vundefined<int>(vec_size);\n    vtype<int> curr_elements = vundefined<int>(vec_size);\n    \n    for (int i = 0; i < n - 1; i += vl) {\n        int vl = vsetvl_n_u32(n - i);\n        curr_elements = vle32_v_i32(&arr[i + 1], vl);\n        prev_elements = vle32_v_i32(&arr[i], vl);\n        \n        vbool_t cmp = vmslt_vv_i32(prev_elements, curr_elements, vl);\n        indices = vcompress_i32(cmp, vadd_vx_i32(vse32_v_i32(indices, vl), 1, vl), vl);\n    }\n\n    int max_index = -1;\n    for (int i = 0; i < vl; i++) {\n        if (indices[i] != -1) {\n            max_index = std::max(max_index, indices[i]);\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    vtype<int> vec_size = vsetvl_e32(n);\n    vtype<int> max_index = -1;\n\n    for (int i = 1; i < n; i += vec_size) {\n        vtype<int> v_curr = vle32_v_i32(&arr[i], vec_size);\n        vtype<int> v_prev = vle32_v_i32(&arr[i - 1], vec_size);\n        vtype<bool> v_mask = vmslt_vv_i32(v_prev, v_curr, vec_size);\n\n        for (int j = 0; j < vec_size; j++) {\n            if (v_mask[j]) {\n                max_index = i + j - 1;\n            }\n        }\n    }\n\n    return max_index == -1 ? -1 : max_index;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n == 0) return -1;\n\n    vtype<int> *vec = (vtype<int> *)arr.data();\n    vtype<int> prev = vec[0];\n    int index = -1;\n\n    for (int i = 1; i < n; i += VLEN) {\n        vtype<int> curr = vload(vtype<int>(), &vec[i]);\n        vtype<int> cmp = vmslt(prev, curr);\n        if (vany(cmp)) {\n            index = i + vfirst(cmp);\n            break;\n        }\n        prev = curr;\n    }\n\n    return index == -1 ? -1 : index - 1;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    vtype<int> *vec_arr = (vtype<int> *)arr.data();\n    vtype<int> prev = vsetvl(n);\n    int result = -1;\n\n    for (int i = 1; i < n; i += vlen) {\n        vtype<int> curr = vle32_v_i32(vec_arr + i);\n        vtype<int> prev_elem = vle32_v_i32(vec_arr + i - 1);\n        \n        vtype<bool> cmp = vmslt_vv_i32(prev_elem, curr);\n        int mask = vmfirst_m(cmp);\n        \n        if (mask != -1) {\n            result = i + mask - 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    vtype<int> *vec_arr = (vtype<int> *)arr.data();\n    vtype<int> prev_val = vec_arr[0];\n    int result_index = -1;\n\n    for (int i = 1; i < n; i += VLEN) {\n        vtype<int> curr_vals = vle32_v_i32(vec_arr + i);\n        vtype<int> cmp_result = vmslt_vv_i32(prev_val, curr_vals);\n        vtype<int> mask = vmseq_vv_i32(prev_val, curr_vals);\n        \n        for (int j = 0; j < VLEN && (i + j) < n; j++) {\n            if (mask[j] && !cmp_result[j]) {\n                result_index = i + j;\n            }\n        }\n        \n        prev_val = curr_vals;\n    }\n\n    return result_index;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return {0, 0};\n\n    vtype<int> max_neg = vundefined<int>();\n    vtype<int> min_pos = vundefined<int>();\n    vtype<int> zero = vsetvl_e32(0);\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = vsetvl_e32(n - i);\n        vtype<int> vec = vle32_v_i32(&lst[i], vl);\n\n        vtype<int> neg_mask = vmslt_vx_i32(vec, 0);\n        vtype<int> pos_mask = vmsgt_vx_i32(vec, 0);\n\n        max_neg = vmax_vv_i32(max_neg, vmask_if(neg_mask, vec, zero), vl);\n        min_pos = vmin_vv_i32(min_pos, vmask_if(pos_mask, vec, zero), vl);\n    }\n\n    int largest_neg = (vmax(max_neg) == 0) ? 0 : vmax(max_neg);\n    int smallest_pos = (vmin(min_pos) == 0) ? 0 : vmin(min_pos);\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    int32_t largest_negative = std::numeric_limits<int32_t>::min();\n    int32_t smallest_positive = std::numeric_limits<int32_t>::max();\n\n    vtype<int32_t> vec_size = vsetvl_e32(n);\n    vtype<int32_t> vec_input = vle32_v_i32(lst.data(), vec_size);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vtype<int32_t> vec_chunk = vle32_v_i32(lst.data() + i, vec_size);\n        vtype<bool> is_negative = vmslt_vx_i32_b32(vec_chunk, 0);\n        vtype<bool> is_positive = vmsgt_vx_i32_b32(vec_chunk, 0);\n\n        if (vfirst_m_b32(is_negative)) {\n            largest_negative = vmax_vv_i32(largest_negative, vec_chunk);\n        }\n        if (vfirst_m_b32(is_positive)) {\n            smallest_positive = vmin_vv_i32(smallest_positive, vec_chunk);\n        }\n    }\n\n    if (largest_negative == std::numeric_limits<int32_t>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int32_t>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    vtype<int> v_neg_max = vundefined<int>();\n    vtype<int> v_pos_min = vundefined<int>();\n    \n    vtype<int> v_neg_inf = vsetvl_e32m1(1);\n    vtype<int> v_pos_inf = vsetvl_e32m1(1);\n    \n    v_neg_max = vsetvl_e32m1(std::numeric_limits<int>::min());\n    v_pos_min = vsetvl_e32m1(std::numeric_limits<int>::max());\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vtype<int> v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        vtype<bool> v_neg_mask = vmslt_vx_i32m1(v_data, 0);\n        vtype<bool> v_pos_mask = vmsgt_vx_i32m1(v_data, 0);\n        \n        v_neg_max = vmax_vv_i32m1(v_neg_max, v_data, v_neg_mask);\n        v_pos_min = vmin_vv_i32m1(v_pos_min, v_data, v_pos_mask);\n    }\n\n    int largest_neg = vget_v_i32m1(v_neg_max);\n    int smallest_pos = vget_v_i32m1(v_pos_min);\n\n    if (largest_neg == std::numeric_limits<int>::min()) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == std::numeric_limits<int>::max()) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return {0, 0};\n\n    vtype<int> v_neg_max = vsetvl_e32m1(1);\n    vtype<int> v_pos_min = vsetvl_e32m1(1);\n    int neg_max = std::numeric_limits<int>::min();\n    int pos_min = std::numeric_limits<int>::max();\n\n    for (size_t i = 0; i < n; i += v_neg_max) {\n        vtype<int> vec = vle32_v_i32m1(&lst[i]);\n        vtype<bool> is_neg = vmslt_vx_i32m1(vec, 0);\n        vtype<bool> is_pos = vmsgt_vx_i32m1(vec, 0);\n\n        if (vfirst_m_b(is_neg)) {\n            neg_max = std::max(neg_max, vredmax_vs_i32m1(vec, neg_max, is_neg));\n        }\n        if (vfirst_m_b(is_pos)) {\n            pos_min = std::min(pos_min, vredmin_vs_i32m1(vec, pos_min, is_pos));\n        }\n    }\n\n    if (neg_max == std::numeric_limits<int>::min()) neg_max = 0;\n    if (pos_min == std::numeric_limits<int>::max()) pos_min = 0;\n\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    int32_t largest_negative = std::numeric_limits<int32_t>::min();\n    int32_t smallest_positive = std::numeric_limits<int32_t>::max();\n\n    vtype<int32_t> vec_size = vsetvl_e32(n);\n    vtype<int32_t> vec_data = vle32_v_i32m1(lst.data(), vec_size);\n\n    for (size_t i = 0; i < n; i += vlen) {\n        vtype<int32_t> v = vle32_v_i32m1(lst.data() + i, vec_size);\n        vtype<bool> is_negative = vmslt_vx_i32m1(v, 0);\n        vtype<bool> is_positive = vmsgt_vx_i32m1(v, 0);\n\n        if (i + vlen <= n) {\n            largest_negative = vmax_vx_i32m1(largest_negative, v, is_negative);\n            smallest_positive = vmin_vx_i32m1(smallest_positive, v, is_positive);\n        } else {\n            for (size_t j = i; j < n; ++j) {\n                if (lst[j] < 0) {\n                    largest_negative = std::max(largest_negative, lst[j]);\n                } else if (lst[j] > 0) {\n                    smallest_positive = std::min(smallest_positive, lst[j]);\n                }\n            }\n        }\n    }\n\n    if (largest_negative == std::numeric_limits<int32_t>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int32_t>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    vuint64m1_t v_result = vmv_v_x_u64m1(1, 1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m1_t v_i = vmv_v_x_u64m1(i, 1);\n        v_result = vmul_vv_u64m1(v_result, v_i, 1);\n        \n        for (uint64_t j = 1; j <= i; j++) {\n            vuint64m1_t v_j = vmv_v_x_u64m1(j, 1);\n            v_result = vmul_vv_u64m1(v_result, v_j, 1);\n        }\n    }\n\n    result = vredsum_vs_u64m1(v_result, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    vuint64m1_t v_result = vundefined_u64m1();\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, 1);\n    \n    for (uint64_t i = n; i > 0; i -= 1) {\n        vuint64m1_t v_i = vmv_v_x_u64m1(i, 1);\n        v_result = v_mul_u64m1(v_result, v_i);\n    }\n\n    result = vreduce_mul_u64m1(v_result);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    vuint64m1_t v_result = vundefined_u64m1();\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, 1);\n    \n    for (uint64_t i = n; i > 0; i -= 8) {\n        vuint64m1_t v_i = vmv_v_x_u64m1(i, 1);\n        vuint64m1_t v_fact = v_i;\n\n        for (uint64_t j = i - 1; j > 0; j--) {\n            v_fact = vmul_vv_u64m1(v_fact, vmv_v_x_u64m1(j, 1));\n        }\n\n        v_result = vmul_vv_u64m1(v_result, v_fact);\n    }\n\n    result = vget_u64m1(v_result, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    vuint64m1_t v_result = vundefined_u64m1();\n    vuint64m1_t v_factorial = vundefined_u64m1();\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        v_factorial = vsetvl_u64m1(i);\n        v_result = vfmul_vv_u64m1(v_result, v_factorial);\n    }\n\n    result = vget_u64m1(v_result, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    vuint64m1_t v_result = vundefined_u64m1();\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m1_t v_i = vsetvl_e64m1(i);\n        v_result = vmul_u64m1(v_result, v_i);\n    }\n    \n    result = vget_u64m1(v_result, 0);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        result *= special_factorial_simd(i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    int sum = 0;\n    \n    // Create a vector of integers\n    vtype<int> vec = vle32_v_i32(lst.data(), n);\n    \n    // Create a vector to hold the results\n    vtype<int> result = vmv_v_x_i32(0, n);\n    \n    // Process the vector\n    for (int i = 0; i < n; i += VLEN) {\n        vtype<int> v = vle32_v_i32(lst.data() + i, VLEN);\n        vtype<int> mask3 = vmseq_vx_i32(v, 0);\n        vtype<int> mask4 = vmseq_vx_i32(v, 0);\n        \n        // Create masks for multiples of 3 and 4\n        for (int j = 0; j < VLEN; j++) {\n            if ((i + j) % 3 == 0) {\n                result = vwmul_vv_i32(result, v, v);\n            } else if ((i + j) % 4 == 0) {\n                result = vwmul_vv_i32(result, v, vwmul_vv_i32(v, v));\n            }\n        }\n    }\n\n    // Sum the results\n    sum = vaddv_i32(result);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    int sum = 0;\n    vtype<int> v_sum = vundefined<int>();\n\n    for (int i = 0; i < n; i += VLEN) {\n        vint32m4_t v_data = vle32_v_i32m4(&lst[i]);\n        vbool32_t mask3 = vmul_vx_i32m4(vsetvl_e32m4(1), 3);\n        vbool32_t mask4 = vmul_vx_i32m4(vsetvl_e32m4(1), 4);\n        \n        v_data = vslide1down_v_i32m4(v_data, 0);\n        v_data = vadd_vv_i32m4(v_data, v_data);\n        \n        // Square for multiples of 3\n        v_data = vadd_vv_i32m4(v_data, vsqrt_v_i32m4(v_data));\n        \n        // Cube for multiples of 4 not multiples of 3\n        v_data = vadd_vv_i32m4(v_data, vadd_vv_i32m4(vmul_vv_i32m4(v_data, v_data), v_data));\n        \n        v_sum = vadd_vv_i32m4(v_sum, v_data);\n    }\n\n    sum += vreduce_add_i32m4(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    int sum = 0;\n    int vl = vsetvl_e32(n);\n\n    vuint32m1_t v_sum = vundefined_u32m1();\n    vuint32m1_t v_data = vle32_v_u32m1(lst.data(), vl);\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32(n - i);\n        v_data = vle32_v_u32m1(lst.data() + i, vl);\n\n        vuint32m1_t v_result = vundefined_u32m1();\n        vbool32_t mask_square = vmseq_vx_u32m1(vsetvl_e32(i), 0);\n        vbool32_t mask_cube = vmand(vmsne_vx_u32m1(vsetvl_e32(i), 0), vmul(vmsle_vx_u32m1(vsetvl_e32(i), 0), vsetvl_e32(3)));\n\n        v_result = vadd_vv_u32m1(v_result, vselect(mask_square, vmul(v_data, v_data), v_data));\n        v_result = vadd_vv_u32m1(v_result, vselect(mask_cube, vmul(vmul(v_data, v_data), v_data), v_data));\n\n        v_sum = vadd_vv_u32m1(v_sum, v_result);\n    }\n\n    sum = vredsum_vs_u32m1(v_sum, sum, vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    int sum = 0;\n\n    // Create a vector of integers to hold the results\n    vtype<int> vec_result = vundefined<int>();\n\n    // Process the vector in chunks\n    for (int i = 0; i < n; i += VLEN) {\n        // Load the vector from the input list\n        vtype<int> vec_input = vle32_v_i32(&lst[i]);\n\n        // Create a mask for indices that are multiples of 3\n        vtype<int> mask3 = vmv_v_x_i32(vsetvl_e32m1(0), 0);\n        vtype<int> mask4 = vmv_v_x_i32(vsetvl_e32m1(0), 0);\n        for (int j = 0; j < VLEN && (i + j) < n; j++) {\n            if ((i + j) % 3 == 0) {\n                mask3 = vsetvl_e32m1(1);\n            }\n            if ((i + j) % 4 == 0 && (i + j) % 3 != 0) {\n                mask4 = vsetvl_e32m1(1);\n            }\n        }\n\n        // Square the elements where the index is a multiple of 3\n        vec_result = vselect(mask3, vmul_vv_i32(vec_input, vec_input), vec_result);\n\n        // Cube the elements where the index is a multiple of 4 and not a multiple of 3\n        vtype<int> vec_cubed = vmul_vv_i32(vec_input, vmul_vv_i32(vec_input, vec_input));\n        vec_result = vselect(mask4, vec_cubed, vec_result);\n    }\n\n    // Sum the results\n    for (int i = 0; i < VLEN; i++) {\n        sum += vget_v_i32(vec_result, i);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Create a vector of integers\n    vtype<int> vec = vundefined<int>();\n\n    // Process the vector in chunks\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vec = vle32_v_i32(&lst[i], vl);\n\n        // Create a mask for indices that are multiples of 3\n        vbool32_t mask3 = vmul_vx_i32(vsetvl_e32(vl), 3);\n        vbool32_t mask4 = vmul_vx_i32(vsetvl_e32(vl), 4);\n\n        // Square the elements at multiples of 3\n        vec = vselect(mask3, vmul_vv_i32(vec, vec, vl), vec);\n\n        // Cube the elements at multiples of 4 and not multiples of 3\n        vtype<int> cubed = vmul_vv_i32(vec, vec, vl);\n        cubed = vmul_vv_i32(cubed, vec, vl);\n        vec = vselect(mask4, cubed, vec);\n\n        // Sum the results\n        sum += vreduce_add_i32(vec, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    // Create a vector of integers\n    vtype<int> vec_nums = vle32_v_i32(nums.data(), n);\n    vtype<int> vec_count = vmv_v_x_i32(0, n);\n\n    // Process elements in parallel\n    for (size_t i = 0; i < n; i += VLEN) {\n        vtype<int> v = vle32_v_i32(&nums[i], VLEN);\n        vbool32_t mask_gt_10 = vmslt_vx_i32_b32(v, 10);\n        \n        // Extract first and last digits\n        vtype<int> first_digit = (v / 10) % 10;\n        vtype<int> last_digit = v % 10;\n\n        vbool32_t mask_first_odd = vmand_b32(mask_gt_10, vmsne_vx_i32_b32(first_digit, 0));\n        vbool32_t mask_last_odd = vmand_b32(mask_first_odd, vmsne_vx_i32_b32(last_digit, 0));\n        \n        // Count the valid elements\n        vec_count = vadd_vx_i32(vec_count, vmv_n_x_i32(mask_last_odd, 1));\n    }\n\n    // Sum up the counts\n    count = vget_v_i32(vec_count);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    vtype<int> v_count = vundefined<int>();\n\n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vuint32m1_t v_nums = vle32_v_u32m1(&nums[i], vl);\n        vbool32_t mask_gt_10 = vmsltu_vx_u32m1(v_nums, 10);\n        \n        vuint32m1_t v_first_digit = vdivu_vx_u32m1(v_nums, 10);\n        vuint32m1_t v_last_digit = vremu_vx_u32m1(v_nums, 10);\n        \n        vbool32_t mask_first_odd = vmand_vx_u32m1(v_first_digit, 0x1, vl);\n        vbool32_t mask_last_odd = vmand_vx_u32m1(v_last_digit, 0x1, vl);\n        \n        vbool32_t mask_special = vmand_vv(mask_gt_10, mask_first_odd, vl);\n        mask_special = vmand_vv(mask_special, mask_last_odd, vl);\n        \n        v_count = vadd_vx(v_count, vpopc(mask_special, vl), vl);\n    }\n\n    count += vget_vx(v_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t n = nums.size();\n    int count = 0;\n\n    // Create a vector of integers to hold the results\n    vuint8m1_t result = vundefined_u8m1();\n    \n    // Process the vector in chunks\n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t chunk_size = std::min(VEC_SIZE, n - i);\n        vint32m1_t vec_nums = vle32_v_i32m1(&nums[i], chunk_size);\n        \n        // Check if numbers are greater than 10\n        vbool32_t greater_than_10 = vmsltu_vx_i32m1(vec_nums, 10);\n        \n        // Extract first and last digits\n        vint32m1_t first_digit = vdivu_vx_i32m1(vec_nums, 10);\n        vint32m1_t last_digit = vremu_vx_i32m1(vec_nums, 10);\n        \n        // Check if first and last digits are odd\n        vbool32_t first_odd = vand_vx_i32m1(vremu_vx_i32m1(first_digit, 2), vmsltu_vx_i32m1(first_digit, 10));\n        vbool32_t last_odd = vand_vx_i32m1(vremu_vx_i32m1(last_digit, 2), vmsltu_vx_i32m1(last_digit, 10));\n        \n        // Combine conditions\n        vbool32_t valid_condition = vand_vv_i32m1(greater_than_10, vand_vv_i32m1(first_odd, last_odd));\n        \n        // Count valid elements\n        count += vpopc_v_u8m1(result, valid_condition);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    vtype<int> v_nums = vle32_v_i32(nums.data(), n);\n    \n    // Create masks for conditions\n    vbool32_t mask_gt_10 = vmslt_v_i32(v_nums, vsetvl_e32(10));\n    \n    // Extract first and last digits\n    vtype<int> first_digits = vdiv_v_i32(v_nums, vsetvl_e32(10));\n    vtype<int> last_digits = vmod_v_i32(v_nums, vsetvl_e32(10));\n    \n    // Create masks for odd first and last digits\n    vbool32_t mask_first_odd = vand_vb_i32(vmsne_v_i32(first_digits, vsetvl_e32(0)), \n                                            vmand_vb_i32(vmslt_v_i32(first_digits, vsetvl_e32(10)), \n                                            vmslt_v_i32(vsetvl_e32(0), first_digits)));\n    vbool32_t mask_last_odd = vand_vb_i32(vmsne_v_i32(last_digits, vsetvl_e32(0)), \n                                           vmand_vb_i32(vmslt_v_i32(last_digits, vsetvl_e32(10)), \n                                           vmslt_v_i32(vsetvl_e32(0), last_digits)));\n    \n    // Combine masks\n    vbool32_t final_mask = vand_vb_i32(mask_gt_10, vand_vb_i32(mask_first_odd, mask_last_odd));\n    \n    // Count the number of true values in final_mask\n    count = vpopcount(final_mask);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    vtype<int> v_count = vsetvl_e32(n);\n    \n    for (size_t i = 0; i < n; i += v_count) {\n        vint32m1_t v_nums = vle32_v_i32m1(&nums[i], v_count);\n        vbool32_t v_mask_gt10 = vmsltu_vx_i32m1(v_nums, 10);\n        \n        vint32m1_t v_first_digit = vdivu_vx_i32m1(v_nums, 10);\n        vint32m1_t v_last_digit = vremu_vx_i32m1(v_nums, 10);\n        \n        vbool32_t v_mask_first_odd = vmand_vv_i32m1(vfirst_digit, vfirst_digit, vfirst_digit);\n        vbool32_t v_mask_last_odd = vmand_vv_i32m1(vlast_digit, vlast_digit, vlast_digit);\n        \n        vbool32_t v_mask_special = vand_vv_i32m1(v_mask_gt10, v_mask_first_odd);\n        v_mask_special = vand_vv_i32m1(v_mask_special, v_mask_last_odd);\n        \n        count += vpopc(v_mask_special);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Fill the vector a with the formula\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count triples (i, j, k) such that a[i] + a[j] + a[k] is a multiple of 3\n    for (uint64_t i = 0; i < n; i++) {\n        for (uint64_t j = i + 1; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = new uint64_t[n];\n    \n    // Fill the vector a with the formula a{i} = i * i - i + 1\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Create a vector to hold the counts of residues modulo 3\n    uint64_t residue_count[3] = {0, 0, 0};\n\n    // Count the residues of a[i] % 3\n    for (uint64_t i = 0; i < n; i++) {\n        residue_count[a[i] % 3]++;\n    }\n\n    // Calculate the number of valid triples\n    count += (residue_count[0] * (residue_count[0] - 1) * (residue_count[0] - 2)) / 6; // All residues 0\n    count += (residue_count[1] * (residue_count[1] - 1) * (residue_count[1] - 2)) / 6; // All residues 1\n    count += (residue_count[2] * (residue_count[2] - 1) * (residue_count[2] - 2)) / 6; // All residues 2\n    count += residue_count[0] * residue_count[1] * residue_count[2]; // One of each residue\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Fill the vector a with the formula a[i] = i * i - i + 1\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    // Count the number of valid triples\n    for (uint64_t i = 0; i < n; i += VLEN) {\n        vuint64m1_t va = vle64_v_u64m1(&a[i]);\n        for (uint64_t j = i + 1; j < n; j += VLEN) {\n            vuint64m1_t vb = vle64_v_u64m1(&a[j]);\n            for (uint64_t k = j + 1; k < n; k += VLEN) {\n                vuint64m1_t vc = vle64_v_u64m1(&a[k]);\n                \n                vuint64m1_t sum = vadd_vv_u64m1(va, vb);\n                sum = vadd_vv_u64m1(sum, vc);\n                \n                // Check if the sum is a multiple of 3\n                vuint64m1_t mod = vremu_v_u64m1(sum, 3);\n                count += vpopc_m_u64m1(vmv_v_x_u64m1(mod, 0) == 0);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Fill the vector a with the formula a{i} = i * i - i + 1\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count the number of valid triples\n    for (uint64_t i = 0; i < n; i += VEC_SIZE) {\n        vuint64m1_t v_a = vle64_v_u64m1(&a[i]);\n        vuint64m1_t v_sum = vadd_vv_u64m1(v_a, v_a); // Placeholder for sum calculation\n        // Further processing to find valid triples\n        // This part needs to be implemented to check for triples\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t vec_size = vsetvl_e64m1(n);\n    vuint64m1_t a = vundefined_u64m1();\n\n    for (uint64_t i = 1; i <= n; i += vec_size) {\n        vuint64m1_t idx = vadd_vx_u64m1(vsevl_e64m1(i), 0);\n        vuint64m1_t values = vadd_vx_u64m1(vmul_vx_u64m1(idx, idx), -i + 1);\n        a = vslide1down_u64m1(a, values);\n    }\n\n    // Count valid triples\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                uint64_t sum = vextract_u64m1(a, i) + vextract_u64m1(a, j) + vextract_u64m1(a, k);\n                if (sum % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool32_t mask;\n    vint32m8_t n_vec = vmv_v_x_i32m8(n, 32);\n    vint32m8_t x_vec = vmv_v_x_i32m8(x, 32);\n    vint32m8_t y_vec = vmv_v_x_i32m8(y, 32);\n    \n    for (int i = 0; i < 32; i++) {\n        mask = vmslt_vx_i32m8(n_vec, 2);\n        if (vfirst_m(mask) != -1) {\n            return y; // n < 2, return y\n        }\n    }\n\n    mask = vmslt_vx_i32m8(n_vec, 2);\n    if (vfirst_m(mask) != -1) {\n        return y; // n < 2, return y\n    }\n\n    vint32m8_t result = vmerge_vxm(mask, x_vec, y_vec);\n    return vfirst_i32m8(result);\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool32_t mask = vmslt_vx_i32(vsetvl_e32(32), n, 2);\n    int prime = 0;\n\n    if (!vmslt_vx_i32(mask, n, 2)) {\n        vuint32m1_t vec_n = vmv_v_x_u32m1(n);\n        vuint32m1_t vec_prime = vundefined_u32m1();\n        \n        for (int i = 2; i * i <= n; i++) {\n            vuint32m1_t vec_i = vmv_v_x_u32m1(i);\n            vec_prime = vmerge_vx_u32m1(vec_prime, vmslt_vx_u32m1(vec_n, vec_i), vdiv_u32m1(vec_n, vec_i));\n        }\n        \n        prime = vfirst_m_b32(mask, vec_prime);\n    }\n\n    return prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool32_t mask;\n    vint32m1_t n_vec = vsetvl_e32m1(1);\n    vint32m1_t x_vec = vsetvl_e32m1(1);\n    vint32m1_t y_vec = vsetvl_e32m1(1);\n    \n    mask = vmslt_vx_i32m1(n_vec, 1);\n    if (vfirst_m(mask) != -1) return y;\n\n    mask = vmslt_vx_i32m1(n_vec, 2);\n    if (vfirst_m(mask) != -1) return y;\n\n    vint32m1_t i_vec = vsetvl_e32m1(2);\n    vint32m1_t limit_vec = vsetvl_e32m1((int)sqrt(n) + 1);\n    \n    for (int i = 2; i * i <= n; i++) {\n        mask = vmul_vx_i32m1(i_vec, i_vec);\n        mask = vmslt_vx_i32m1(mask, n_vec);\n        if (vfirst_m(mask) != -1) {\n            if (n % i == 0) return y;\n        }\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool32_t mask = vmslt_vx_i32(vsetvl_e32(32), n, 2);\n    int prime_result = is_prime(n);\n    return vmerge_vx_i32(mask, y, x);\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool32_t mask = vmslt_vx_i32(vsetvl_e32(32), n, 2);\n    int prime_result = is_prime(n);\n    return vmerge_vx_i32(mask, y, x);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    vfloat32m1_t vec;\n    vuint32m1_t mask;\n    uint64_t sum = 0;\n\n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t vl = std::min(VEC_SIZE, n - i);\n        vec = vle32_v_f32m1(&lst[i], vl);\n        mask = vmsltu_v_f32m1(vec, 0); // mask for negative numbers\n        vec = vadd_vx_f32m1(vec, 0, vl); // ignore negatives\n\n        vuint32m1_t odd_mask = vand_vx_u32m1(vmsgtu_v_f32m1(vec, 0), vmsltu_v_f32m1(vec, 2)); // mask for odd numbers\n        vec = vmul_vv_f32m1(vec, vec, vl); // square the numbers\n        vec = vand_vx_f32m1(vec, odd_mask, vl); // apply odd mask\n\n        sum += vfredsum_vs_f32m1(vec, sum, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    vfloat32m1_t vec;\n    vuint64m1_t sum = vundefined_u64m1();\n    size_t i = 0;\n\n    for (; i <= n - 8; i += 8) {\n        vec = vle32_v_f32m1(&lst[i]);\n        vbool8_t mask = vmslt_vf_f32m1(vec, 0.0f);\n        vec = vmandnot_vb_f32m1(mask, vec, vec);\n        mask = vmand_vb_f32m1(vec, vmsne_vf_f32m1(vec, 0.0f));\n        vec = vmsne_vf_f32m1(vec, 0.0f);\n        vfloat32m1_t odd_mask = vmand_vb_f32m1(vec, vmsne_vf_f32m1(vec, 0.0f));\n        vfloat32m1_t squares = vmul_vv_f32m1(odd_mask, odd_mask);\n        sum = vadd_vv_u64m1(sum, vreinterpret_u64m1_f32m1(squares));\n    }\n\n    uint64_t result = 0;\n    for (; i < n; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            result += static_cast<uint64_t>(lst[i]) * static_cast<uint64_t>(lst[i]);\n        }\n    }\n\n    return result + vget_u64m1(sum, 0);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    vfloat32m1_t vec;\n    vuint32m1_t mask;\n    uint64_t sum = 0;\n\n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t vl = std::min(VEC_SIZE, n - i);\n        vec = vle32_v_f32m1(&lst[i], vl);\n        \n        mask = vmslt_v_f32m1(vec, 0.0f); // mask for negative numbers\n        vec = vmerge_vx_f32m1(vec, vfmv_v_f_f32m1(0.0f), mask); // set negative numbers to 0\n\n        mask = vmsne_v_f32m1(vec, 0.0f); // mask for non-zero numbers\n        vec = vmerge_vx_f32m1(vec, vfmv_v_f_f32m1(0.0f), mask); // set non-integers to 0\n\n        vuint32m1_t odd_mask = vmsne_v_f32m1(vec, 0.0f); // mask for odd integers\n        vec = vand_vx_f32m1(vec, odd_mask); // keep only odd integers\n\n        vfloat32m1_t squares = vfmul_vv_f32m1(vec, vec); // square the numbers\n        sum += vfredusum_vs_f32m1(squares, vfmv_v_f_f32m1(0.0f), sum, vl); // sum the squares\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    vuint64m1_t sum = vundefined_u64m1();\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += VSET) {\n        vl = vsetvl_e64m1(n - i);\n        vfloat32m1_t vec = vle32_v_f32m1(&lst[i]);\n        vbool32_t mask = vmslt_v_f32m1(vec, 0.0f);\n        vec = vmv_v_x_f32m1(vec, 0.0f, mask);\n        mask = vmand_vx_f32m1(vec, 1.0f);\n        vec = vfmul_vv_f32m1(vec, vec);\n        sum = vadd_vv_u64m1(sum, vredsum_vs_f32m1(vec, 0.0f, mask));\n    }\n\n    return vmv_x_s_u64m1(sum);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    vfloat32m1_t vec;\n    vuint32m1_t mask;\n\n    for (size_t i = 0; i < n; i += VEC_SIZE) {\n        size_t vl = std::min(VEC_SIZE, n - i);\n        vec = vle32_v_f32m1(&lst[i], vl);\n        mask = vmslt_v_f32m1(vec, 0.0f);\n        vec = vmandnot_v_u32m1(mask, vec, mask);\n        \n        vuint32m1_t odd_mask = vmsne_v_u32m1(vfsgnj_v_f32m1(vec, vec), 0);\n        vec = vfmul_vv_f32m1(vec, vec, vl);\n        vec = vmand_v_u32m1(odd_mask, vec, odd_mask);\n        \n        sum += vfredsum_vs_f32m1(vec, sum, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vint32m1_t game_vec = vle32_v_i32m1(&game[i], vl);\n        vint32m1_t guess_vec = vle32_v_i32m1(&guess[i], vl);\n        vint32m1_t diff_vec = vsub_vv_i32m1(game_vec, guess_vec, vl);\n        result[i] = vse32_v_i32m1(&result[i], vabs_v_i32m1(diff_vec, vl), vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        vtype<int> v_game = vle32_v_i32(&game[i]);\n        vtype<int> v_guess = vle32_v_i32(&guess[i]);\n        \n        vtype<int> v_diff = vsub_vv_i32(v_game, v_guess);\n        vtype<int> v_abs_diff = vabs_v_i32(v_diff);\n        \n        vse32_v_i32(&result[i], v_abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        vtype<int> v_game = vle32_v_i32(&game[i]);\n        vtype<int> v_guess = vle32_v_i32(&guess[i]);\n        vtype<int> v_diff = vsub_vv_i32(v_game, v_guess);\n        vtype<int> v_abs_diff = vabs_v_i32(v_diff);\n        vse32_v_i32(&result[i], v_abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        size_t vl = std::min(VLEN, n - i);\n        vint32m1_t game_vec = vle32_v_i32m1(&game[i], vl);\n        vint32m1_t guess_vec = vle32_v_i32m1(&guess[i], vl);\n        vint32m1_t diff_vec = vsub_vv_i32m1(game_vec, guess_vec, vl);\n        vint32m1_t abs_diff_vec = vabs_v_i32m1(diff_vec, vl);\n        vse32_v_i32m1(&result[i], abs_diff_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <vector>\n#include <riscv_vector.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += VLEN) {\n        vtype<int> v_game = vle32_v_i32(&game[i]);\n        vtype<int> v_guess = vle32_v_i32(&guess[i]);\n        vtype<int> v_diff = vsub_vv_i32(v_game, v_guess);\n        vtype<int> v_abs_diff = vabs_v_i32(v_diff);\n        vse32_v_i32(&result[i], v_abs_diff);\n    }\n    \n    return result;\n}\n```"}

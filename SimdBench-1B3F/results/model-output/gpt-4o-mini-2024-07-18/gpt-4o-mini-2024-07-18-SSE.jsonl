{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    __m128i zero = _mm_setzero_si128();\n\n    for (; i + 2 <= length; i += 2) {\n        __m128i src_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask_vals = _mm_loadu_si128((__m128i*)&mask[i]);\n\n        __m128i mask_masked = _mm_cmpeq_epi8(mask_vals, zero);\n        src_vals = _mm_andnot_si128(mask_masked, src_vals);\n\n        _mm_storeu_si128((__m128i*)&dst[i], src_vals);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    __m128i zero = _mm_setzero_si128();\n    \n    for (; i + 2 <= length; i += 2) {\n        __m128i src_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask_vals = _mm_loadu_si128((__m128i*)&mask[i]);\n        \n        __m128i mask_masked = _mm_cmpeq_epi8(mask_vals, zero);\n        __m128i result = _mm_andnot_si128(mask_masked, src_vals);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i + 1 < length; i += 2) {\n        __m128i src_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask_vals = _mm_loadu_si128((__m128i*)&mask[i]);\n\n        // Convert mask to 0s and 1s\n        __m128i mask_int = _mm_and_si128(mask_vals, _mm_set1_epi64x(1));\n        mask_int = _mm_cmpeq_epi64(mask_int, _mm_set1_epi64x(1));\n\n        // Conditional move\n        __m128i dst_vals = _mm_blendv_epi8(_mm_setzero_si128(), src_vals, mask_int);\n        _mm_storeu_si128((__m128i*)&dst[i], dst_vals);\n    }\n\n    // Handle remaining element if length is odd\n    if (i < length) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    __m128i zero = _mm_setzero_si128();\n\n    for (; i <= length - 2; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask_vec = _mm_loadu_si128((__m128i*)&mask[i]);\n\n        // Convert mask from bool to int (0 or 1)\n        __m128i mask_int = _mm_and_si128(mask_vec, _mm_set1_epi64x(1));\n\n        // Create a mask for the elements to be copied\n        __m128i mask_copy = _mm_cmpeq_epi64(mask_int, zero);\n\n        // Conditional move\n        src_vec = _mm_blendv_epi8(src_vec, zero, mask_copy);\n        _mm_storeu_si128((__m128i*)&dst[i], src_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i + 1 < length; i += 2) {\n        __m128i src_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask_vals = _mm_loadu_si128((__m128i*)&mask[i]);\n\n        // Convert mask from bool to int (0 or 1)\n        __m128i mask_int = _mm_and_si128(mask_vals, _mm_set1_epi64x(1));\n        \n        // Create a mask for the conditional move\n        __m128i mask_cond = _mm_cmpeq_epi64(mask_int, _mm_set1_epi64x(1));\n\n        // Perform the conditional move\n        __m128i result = _mm_blendv_epi8(_mm_set1_epi64x(0), src_vals, mask_cond);\n\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        __m128i tmp1 = _mm_srai_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        __m128i tmp2 = _mm_slli_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        \n        __m128i result = _mm_add_epi32(_mm_mullo_epi32(src_vec, scale_vec), _mm_mullo_epi32(tmp1, tmp2));\n        result = _mm_srai_epi32(result, 3); // Divide by 7 can be approximated by right shift by 3\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3);\n        \n        __m128i result = _mm_add_epi32(scaled_vec, _mm_mullo_epi32(tmp1, tmp2));\n        result = _mm_srai_epi32(result, 3); // Divide by 7 using right shift\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Calculate tmp1 and tmp2\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        __m128i tmp1 = _mm_srai_epi32(scaled_vec, 3); // right shift by 3\n        __m128i tmp2 = _mm_slli_epi32(scaled_vec, 3); // left shift by 3\n        \n        // Calculate final result\n        __m128i result = _mm_add_epi32(scaled_vec, _mm_mullo_epi32(tmp1, tmp2));\n        result = _mm_srai_epi32(result, 3); // divide by 7 (approximation using right shift)\n        \n        // Store the result\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        __m128i tmp1 = _mm_srai_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        __m128i tmp2 = _mm_slli_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        \n        __m128i result = _mm_add_epi32(_mm_mullo_epi32(src_vec, scale_vec), _mm_mullo_epi32(tmp1, tmp2));\n        result = _mm_div_epi32(result, _mm_set1_epi32(7));\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        __m128i tmp1 = _mm_srai_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        __m128i tmp2 = _mm_slli_epi32(_mm_mullo_epi32(src_vec, scale_vec), 3);\n        \n        __m128i result = _mm_add_epi32(_mm_mullo_epi32(src_vec, scale_vec), _mm_mullo_epi32(tmp1, tmp2));\n        result = _mm_div_epi32(result, _mm_set1_epi32(7));\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] * scale + ((src[i] * scale) >> 3) * ((src[i] * scale) << 3)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    __m128d* dst_vec = (__m128d*)dst;\n\n    for (; i + 1 < rows; i += 2) {\n        __m128d data = _mm_loadu_pd(&src[i * cols + stride]);\n        _mm_storeu_pd(&dst_vec[i], data);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    __m128d* dst_ptr = (__m128d*)dst;\n\n    for (; i <= rows - 2; i += 2) {\n        __m128d data = _mm_loadu_pd(&src[i * cols + stride]);\n        _mm_storeu_pd(&dst_ptr[i], data);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    __m128d* dst_vec = (__m128d*)dst;\n\n    for (; i + 1 < rows; i += 2) {\n        __m128d data = _mm_loadu_pd(&src[i * cols + stride]);\n        _mm_storeu_pd(&dst_vec[i], data);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    __m128d* dst_ptr = (__m128d*)dst;\n    for (size_t r = 0; r < rows; r += 2) {\n        __m128d data1 = _mm_load_pd(&src[r * cols + stride]);\n        __m128d data2 = _mm_load_pd(&src[(r + 1) * cols + stride]);\n        _mm_store_pd(&dst_ptr[r], data1);\n        _mm_store_pd(&dst_ptr[r + 1], data2);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    __m128d* dst_ptr = (__m128d*)dst;\n    const double* src_ptr = src + stride;\n\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        __m128d data = _mm_loadu_pd(src_ptr + i * cols);\n        _mm_storeu_pd(dst_ptr + i, data);\n    }\n    \n    if (i < rows) {\n        dst[i] = src_ptr[i * cols];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_set_ps(src[idx.m128i_i32[3]], src[idx.m128i_i32[2]], src[idx.m128i_i32[1]], src[idx.m128i_i32[0]]);\n        _mm_storeu_ps(&dst[i], src_vals);\n    }\n\n    for (i = 0; i < length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_loadu_ps(&src[i]);\n        _mm_storeu_ps(&dst[idx.m128i_i32[0]], src_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation\n    for (; i + 4 <= length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_set_ps(\n            src[_mm_extract_epi32(idx, 3)],\n            src[_mm_extract_epi32(idx, 2)],\n            src[_mm_extract_epi32(idx, 1)],\n            src[_mm_extract_epi32(idx, 0)]\n        );\n        _mm_storeu_ps(&dst[i], src_vals);\n    }\n\n    // Scatter operation\n    for (size_t j = 0; j < length; j++) {\n        int index = indices[j];\n        dst[index] = src[j];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_set_ps(src[idx.m128i_i32[3]], src[idx.m128i_i32[2]], src[idx.m128i_i32[1]], src[idx.m128i_i32[0]]);\n        _mm_storeu_ps(&dst[i], src_vals);\n    }\n    \n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation\n    for (; i + 4 <= length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_set_ps(\n            src[_mm_extract_epi32(idx, 3)],\n            src[_mm_extract_epi32(idx, 2)],\n            src[_mm_extract_epi32(idx, 1)],\n            src[_mm_extract_epi32(idx, 0)]\n        );\n        _mm_storeu_ps(&dst[i], src_vals);\n    }\n\n    // Scatter operation\n    for (size_t j = 0; j < length; j++) {\n        dst[indices[j]] = src[j];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Gather operation\n    for (i = 0; i < length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_set_ps(\n            src[idx.m128i_i32[3]],\n            src[idx.m128i_i32[2]],\n            src[idx.m128i_i32[1]],\n            src[idx.m128i_i32[0]]\n        );\n        _mm_storeu_ps(&dst[i], src_vals);\n    }\n\n    // Scatter operation\n    for (i = 0; i < length; i += 4) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_vals = _mm_loadu_ps(&src[i]);\n        _mm_storeu_ps(&dst[idx.m128i_i32[0]], src_vals);\n        _mm_storeu_ps(&dst[idx.m128i_i32[1]], src_vals);\n        _mm_storeu_ps(&dst[idx.m128i_i32[2]], src_vals);\n        _mm_storeu_ps(&dst[idx.m128i_i32[3]], src_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - 1]);\n\n        // Swap the elements\n        _mm_storeu_si128((__m128i*)&arr[start], right);\n        _mm_storeu_si128((__m128i*)&arr[end - 1], left);\n\n        start += 8; // Move 8 elements forward\n        end -= 8;   // Move 8 elements backward\n    }\n\n    // Handle any remaining elements if the range is not a multiple of 8\n    for (; start < end; ++start, --end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - 1 - (start - (uint64_t)&arr[start])]);\n        \n        _mm_storeu_si128((__m128i*)&arr[start], right);\n        _mm_storeu_si128((__m128i*)&arr[end - 1 - (start - (uint64_t)&arr[start])], left);\n        \n        start += 8; // Process 8 elements at a time\n        end -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    __m128i temp;\n    for (uint64_t i = 0; i < (end - start + 1) / 8; i++) {\n        // Load 8 elements from the start index\n        temp = _mm_loadu_si128((__m128i*)&arr[start + i * 8]);\n        // Reverse the order of the elements\n        temp = _mm_shuffle_epi32(temp, _MM_SHUFFLE(0, 1, 2, 3));\n        // Store the reversed elements back\n        _mm_storeu_si128((__m128i*)&arr[start + i * 8], temp);\n    }\n\n    // Handle the remaining elements if the range is not a multiple of 8\n    for (uint64_t i = (end - start + 1) / 8 * 8; i <= end; i++) {\n        std::swap(arr[start + i], arr[end - (i - start)]);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t half_length = length / 2;\n\n    for (uint64_t i = 0; i < half_length; i += 8) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - i]);\n\n        // Swap the elements\n        _mm_storeu_si128((__m128i*)&arr[start + i], right);\n        _mm_storeu_si128((__m128i*)&arr[end - i], left);\n    }\n\n    // Handle the case where length is odd and there's a middle element\n    if (length % 2 != 0) {\n        arr[start + half_length] = arr[end - half_length];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t half_length = length / 2;\n\n    for (uint64_t i = 0; i < half_length; i += 8) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - i]);\n\n        _mm_storeu_si128((__m128i*)&arr[start + i], right);\n        _mm_storeu_si128((__m128i*)&arr[end - i], left);\n    }\n\n    if (length % 2 != 0) {\n        arr[start + half_length] = arr[end - half_length];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&tensor[slice_offset + i]);\n        _mm_storeu_si128((__m128i*)&slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; ++bj) {\n                    __m128i row = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj) * block_size]);\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj) * rows + (i + bi) * block_size], row);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; ++bj) {\n                    __m128i row = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j)]);\n                    __m128i transposed = _mm_unpacklo_epi16(row, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj) * rows + (i + bi)], transposed);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = block_row; i < block_row + block_size && i < rows; ++i) {\n                for (size_t j = block_col; j < block_col + block_size && j < cols; j += 8) {\n                    __m128i row_data = _mm_loadu_si128((__m128i*)&src[i * cols + j]);\n                    __m128i transposed_data = _mm_unpacklo_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[j * rows + i], transposed_data);\n                    transposed_data = _mm_unpackhi_epi16(row_data, _mm_setzero_si128());\n                    _mm_storeu_si128((__m128i*)&dst[(j + 4) * rows + i], transposed_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; bj += 8) {\n                    __m128i row = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj)]);\n                    __m128i row2 = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj + 4)]);\n                    \n                    _MM_TRANSPOSE8_SI128(row, row2);\n                    \n                    _mm_storeu_si128((__m128i*)&dst[(j + bj) * rows + (i + bi)], row);\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj + 4) * rows + (i + bi)], row2);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && (i + bi) < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && (j + bj) < cols; bj += 8) {\n                    __m128i row = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj)]);\n                    __m128i row2 = _mm_loadu_si128((__m128i*)&src[(i + bi) * cols + (j + bj + 4)]);\n                    \n                    _mm_storeu_si128((__m128i*)&dst[(j + bj) * rows + (i + bi)], row);\n                    _mm_storeu_si128((__m128i*)&dst[(j + bj + 4) * rows + (i + bi)], row2);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        __m128 values = _mm_loadu_ps(&array[i * dim * dim + i * dim + i]);\n        sum_vec = _mm_add_ps(sum_vec, values);\n    }\n\n    // Horizontal sum of the 4 elements in sum_vec\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n    \n    float result[4];\n    _mm_storeu_ps(result, sum_vec);\n    \n    return result[0];\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        __m128 vec = _mm_loadu_ps(&array[i * dim * dim + i * dim + i]);\n        sum_vec = _mm_add_ps(sum_vec, vec);\n    }\n\n    float sum[4];\n    _mm_storeu_ps(sum, sum_vec);\n\n    float total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Handle remaining elements if dim is not a multiple of 4\n    for (; i < dim; ++i) {\n        total_sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        __m128 vec = _mm_loadu_ps(&array[i * dim * dim + i * dim + i]);\n        sum_vec = _mm_add_ps(sum_vec, vec);\n    }\n\n    // Horizontal sum of the vector\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n\n    float result[4];\n    _mm_storeu_ps(result, sum_vec);\n    return result[0];\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        if (i + 3 < dim) {\n            __m128 vec = _mm_loadu_ps(&array[i * dim * dim + i * dim + i]);\n            sum_vec = _mm_add_ps(sum_vec, vec);\n        }\n    }\n\n    float sum[4];\n    _mm_storeu_ps(sum, sum_vec);\n    float total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Handle remaining elements if dim is not a multiple of 4\n    for (; i < dim; ++i) {\n        total_sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        __m128 vec = _mm_loadu_ps(&array[i * dim * dim + i * dim + i]);\n        sum_vec = _mm_add_ps(sum_vec, vec);\n    }\n\n    // Horizontal sum of the 4 elements in sum_vec\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_ps(sum_vec, sum_vec);\n    \n    float result;\n    _mm_store_ss(&result, sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d cmp_mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, cmp_mask);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d cmp_mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, cmp_mask);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d cmp_mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, cmp_mask);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d cmp_mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, cmp_mask);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d cmp_mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, cmp_mask);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    __m128d row_data1, row_data2;\n\n    for (i = 0; i < rows; i += 2) {\n        size_t idx1 = indices[i];\n        size_t idx2 = (i + 1 < rows) ? indices[i + 1] : idx1;\n\n        for (j = 0; j < cols; j += 2) {\n            row_data1 = _mm_loadu_pd(&src[idx1 * cols + j]);\n            row_data2 = _mm_loadu_pd(&src[idx2 * cols + j]);\n            _mm_storeu_pd(&dst[i * cols + j], row_data1);\n            if (i + 1 < rows) {\n                _mm_storeu_pd(&dst[(i + 1) * cols + j], row_data2);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d data = _mm_load_pd(&src[index * cols + j]);\n            _mm_store_pd(&dst[i * cols + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    __m128d src1, src2, src3, src4;\n\n    for (i = 0; i < rows; i += 2) {\n        size_t row1 = indices[i];\n        size_t row2 = (i + 1 < rows) ? indices[i + 1] : row1;\n\n        for (j = 0; j < cols; j += 2) {\n            src1 = _mm_loadu_pd(&src[row1 * cols + j]);\n            src2 = _mm_loadu_pd(&src[row2 * cols + j]);\n            _mm_storeu_pd(&dst[i * cols + j], src1);\n            if (i + 1 < rows) {\n                _mm_storeu_pd(&dst[(i + 1) * cols + j], src2);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t src_row = indices[r] * cols;\n        size_t dst_row = r * cols;\n\n        for (size_t c = 0; c < cols; c += 2) {\n            __m128d data = _mm_loadu_pd(&src[src_row + c]);\n            _mm_storeu_pd(&dst[dst_row + c], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t row_index = indices[i];\n        const double *src_row = src + row_index * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j + 3 < cols; j += 4) {\n            __m128d v0 = _mm_load_pd(src_row + j);\n            __m128d v1 = _mm_load_pd(src_row + j + 2);\n            _mm_store_pd(dst_row + j, v0);\n            _mm_store_pd(dst_row + j + 2, v1);\n        }\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        __m128i result = _mm_add_epi64(sum, scalar_vec);\n        result = _mm_srai_epi64(result, 1);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        sum = _mm_srli_epi64(sum, 1);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i * 2]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i * 2]);\n        \n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        sum = _mm_srai_epi64(sum, 1);\n        \n        _mm_storeu_si128((__m128i*)&dst[i * 2], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i * 2]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i * 2]);\n        \n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        sum = _mm_srai_epi64(sum, 1);\n        \n        _mm_storeu_si128((__m128i*)&dst[i * 2], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        __m128i result = _mm_add_epi64(sum, scalar_vec);\n        result = _mm_srai_epi64(result, 1);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        even_mask = _mm_and_si128(even_mask, _mm_set_epi32(0, 0, 0, 0xFFFFFFFF));\n        data = _mm_and_si128(data, even_mask);\n        min_vec = _mm_min_epi32(min_vec, data);\n    }\n\n    int min_values[4];\n    _mm_storeu_si128((__m128i*)min_values, min_vec);\n    \n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_values[j] < min_result) {\n            min_result = min_values[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            if (src[i] < min_result) {\n                min_result = src[i];\n            }\n        }\n    }\n\n    return min_result == INT_MAX ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n    \n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_result) {\n            min_result = min_array[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_result = std::min(min_result, src[i]);\n        }\n    }\n\n    return (min_result == INT_MAX) ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n    \n    int min_result = INT_MAX;\n    for (int j = 0; j < 4; j++) {\n        if (min_array[j] < min_result) {\n            min_result = min_array[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && src[i] < min_result) {\n            min_result = src[i];\n        }\n    }\n\n    return (min_result == INT_MAX) ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_val = _mm_min_epi32(min_val, _mm_set1_epi32(src[i]));\n        }\n    }\n\n    int result[4];\n    _mm_storeu_si128((__m128i*)result, min_val);\n    int min_result = result[0];\n    for (int j = 1; j < 4; j++) {\n        min_result = std::min(min_result, result[j]);\n    }\n\n    return min_result == INT_MAX ? -1 : min_result;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i even_mask = _mm_set_epi32(0, 0, 0, 0xFFFFFFFF);\n        __m128i even_elements = _mm_and_si128(data, even_mask);\n\n        min_val = _mm_min_epi32(min_val, even_elements);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            min_val = _mm_min_epi32(min_val, _mm_set1_epi32(src[i]));\n        }\n    }\n\n    // Extract the minimum value from the SIMD register\n    int result[4];\n    _mm_storeu_si128((__m128i*)result, min_val);\n    int final_min = result[0];\n    for (int j = 1; j < 4; j++) {\n        final_min = std::min(final_min, result[j]);\n    }\n\n    return final_min == INT_MAX ? -1 : final_min;\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    __m128i shift_mask = _mm_set1_epi32(shift);\n    size_t i;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i * 4]);\n\n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_srai_epi32(data, shift);\n\n        // Logical right shift\n        __m128i unsigned_data = _mm_cvtepu32_epi32(_mm_cvtepi32_epi32(data));\n        __m128i logical_shift = _mm_srli_epi32(unsigned_data, shift);\n\n        // Add results\n        __m128i result = _mm_add_epi32(arithmetic_shift, logical_shift);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    __m128i shift_mask = _mm_set1_epi32(shift);\n    size_t i;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i * 4]);\n\n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_srai_epi32(data, shift);\n\n        // Logical right shift\n        __m128i unsigned_data = _mm_cvtepi32_epi64(data);\n        __m128i logical_shift = _mm_srli_epi32(unsigned_data, shift);\n\n        // Add the results\n        __m128i result = _mm_add_epi32(arithmetic_shift, logical_shift);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    __m128i shift_mask = _mm_set1_epi32(shift);\n    size_t i;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i * 4]);\n\n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_srai_epi32(data, shift);\n\n        // Logical right shift\n        __m128i unsigned_data = _mm_cvtepu32_epi32(data);\n        __m128i logical_shift = _mm_srli_epi32(unsigned_data, shift);\n\n        // Add results\n        __m128i result = _mm_add_epi32(arithmetic_shift, logical_shift);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    __m128i shift_mask = _mm_set1_epi32(shift);\n    size_t i;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i * 4]);\n\n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_srai_epi32(data, shift);\n\n        // Logical right shift\n        __m128i unsigned_data = _mm_cvtepi32_epi64(data);\n        __m128i logical_shift = _mm_srli_epi32(unsigned_data, shift);\n\n        // Add results\n        __m128i result = _mm_add_epi32(arithmetic_shift, logical_shift);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    __m128i shift_mask = _mm_set1_epi32(shift);\n    size_t i;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i * 4]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_srai_epi32(data, shift);\n        \n        // Logical right shift\n        __m128i unsigned_data = _mm_cvtepi32_epi64(data);\n        __m128i logical_shift = _mm_srli_epi32(unsigned_data, shift);\n        \n        // Combine results\n        __m128i result = _mm_add_epi32(arithmetic_shift, logical_shift);\n        \n        _mm_storeu_si128((__m128i*)&dst[i * 4], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n    \n    // Horizontal sum of the 4 integers in sum_vec\n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    \n    int64_t total_sum = (int64_t)temp[0] + (int64_t)temp[1] + (int64_t)temp[2] + (int64_t)temp[3];\n    \n    // Handle remaining elements if total_elements is not a multiple of 4\n    for (size_t i = total_elements - (total_elements % 4); i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n    \n    // Horizontal sum of the 4 integers in sum_vec\n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    \n    return (int64_t)temp[0] + (int64_t)temp[1] + (int64_t)temp[2] + (int64_t)temp[3];\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < total_elements; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Horizontal sum of the 4 integers in sum_vec\n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    \n    return (int64_t)temp[0] + (int64_t)temp[1] + (int64_t)temp[2] + (int64_t)temp[3];\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    int32_t sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n\n    int64_t total_sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    __m128i sum_vec = _mm_setzero_si128();\n    size_t total_elements = rows * cols;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Horizontal sum of the 4 integers in sum_vec\n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    return (int64_t)temp[0] + temp[1] + temp[2] + temp[3];\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(src[0]);\n    size_t max_index = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        __m128i current = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i cmp = _mm_cmpgt_epi8(current, max_val);\n        max_val = _mm_max_epi8(max_val, current);\n        \n        // Update max_index based on comparison\n        for (int j = 0; j < 16; j++) {\n            if (_mm_extract_epi8(cmp, j)) {\n                max_index = i + j;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > _mm_extract_epi8(max_val, 0)) {\n            max_val = _mm_set1_epi8(src[i]);\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(src[0]);\n    size_t max_index = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i current = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i cmp = _mm_cmpgt_epi8(current, max_val);\n        max_val = _mm_max_epi8(max_val, current);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            max_index = i + _mm_extract_epi8(cmp, _mm_cvtsi128_si32(cmp));\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > _mm_extract_epi8(max_val, 0)) {\n            max_val = _mm_set1_epi8(src[i]);\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(src[0]);\n    __m128i max_idx = _mm_set1_epi8(0);\n    size_t index = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i cmp = _mm_cmpgt_epi8(data, max_val);\n        max_val = _mm_max_epi8(max_val, data);\n        max_idx = _mm_blendv_epi8(max_idx, _mm_set1_epi8(i), cmp);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > _mm_extract_epi8(max_val, 0)) {\n            max_val = _mm_set1_epi8(src[i]);\n            index = i;\n        }\n    }\n\n    // Find the index of the maximum value\n    int8_t max_values[16];\n    _mm_storeu_si128((__m128i*)max_values, max_val);\n    for (size_t j = 0; j < 16; ++j) {\n        if (max_values[j] == _mm_extract_epi8(max_val, 0)) {\n            index = (i - 16) + j;\n            break;\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(src[0]);\n    __m128i max_idx = _mm_set1_epi8(0);\n    size_t idx = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        __m128i current_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i cmp_mask = _mm_cmpgt_epi8(current_vals, max_val);\n        max_val = _mm_max_epi8(max_val, current_vals);\n        max_idx = _mm_blendv_epi8(max_idx, _mm_set1_epi8(i), cmp_mask);\n    }\n\n    int8_t max_array[16];\n    _mm_storeu_si128((__m128i*)max_array, max_val);\n\n    int8_t max_value = max_array[0];\n    size_t max_index = idx;\n\n    for (size_t j = 1; j < 16; j++) {\n        if (max_array[j] > max_value) {\n            max_value = max_array[j];\n            max_index = i + j;\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(src[0]);\n    size_t max_index = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        __m128i current_vals = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i cmp = _mm_cmpgt_epi8(current_vals, max_val);\n        max_val = _mm_max_epi8(max_val, current_vals);\n        \n        // Update max_index if necessary\n        for (int j = 0; j < 16; j++) {\n            if (_mm_extract_epi8(cmp, j) != 0) {\n                max_index = i + j;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > _mm_extract_epi8(max_val, 0)) {\n            max_val = _mm_set1_epi8(src[i]);\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    __m128i mask_vec = _mm_set1_epi32(mask);\n    \n    for (i = 0; i < length; i += 8) {\n        __m128i indices = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i blend_mask = _mm_cmpgt_epi32(and_result, _mm_setzero_si128());\n\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i result = _mm_blendv_epi8(src2_vec, src1_vec, blend_mask);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask_vec = _mm_set1_epi32(mask);\n    \n    for (; i <= length - 8; i += 8) {\n        __m128i indices = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i blend_mask = _mm_cmpgt_epi32(and_result, _mm_setzero_si128());\n\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i result = _mm_blendv_epi8(src2_vec, src1_vec, blend_mask);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    __m128i mask_vec = _mm_set1_epi32(mask);\n    \n    for (i = 0; i < length / 8 * 8; i += 8) {\n        __m128i indices = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i blend_mask = _mm_cmpgt_epi32(and_result, _mm_setzero_si128());\n\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i result = _mm_blendv_epi8(src2_vec, src1_vec, blend_mask);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    __m128i mask_vec = _mm_set1_epi32(mask);\n    \n    for (i = 0; i < length / 8 * 8; i += 8) {\n        __m128i indices = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i blend_mask = _mm_cmpgt_epi32(and_result, _mm_setzero_si128());\n\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i blended = _mm_blendv_epi8(src2_vec, src1_vec, blend_mask);\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    __m128i mask_vec = _mm_set1_epi32(mask);\n    \n    for (i = 0; i < length / 8 * 8; i += 8) {\n        __m128i indices = _mm_set_epi32(i + 7, i + 6, i + 5, i + 4);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i blend_mask = _mm_cmpgt_epi32(and_result, _mm_setzero_si128());\n\n        __m128i src1_vec = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i blended = _mm_blendv_epi8(src2_vec, src1_vec, blend_mask);\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for (i = 0; i < length / 4 * 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            count = _mm_add_epi32(count, _mm_and_si128(data, ones));\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for (i = 0; i < length / 4 * 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            count = _mm_add_epi32(count, _mm_and_si128(data, ones));\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n\n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        uint32_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        // Count bits in each byte\n        for (int j = 0; j < 4; ++j) {\n            __m128i byte = _mm_and_si128(data, _mm_set1_epi32(0xFF));\n            count = _mm_add_epi32(count, _mm_popcnt_epi32(byte));\n            data = _mm_srli_epi32(data, 8);\n        }\n\n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for (i = 0; i < length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i count = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            count = _mm_add_epi32(count, _mm_and_si128(data, ones));\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (; i + 4 <= length; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Count bits using the population count method\n        __m128i count = _mm_popcnt_epi32(data);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], count);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i max_val = _mm_set1_epi16(UINT16_MAX);\n\n    for (; i <= length - 8; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi16(a, b);\n        __m128i result = _mm_min_epi16(sum, max_val);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    __m128i max_val = _mm_set1_epi16(UINT16_MAX);\n\n    for (i = 0; i < length / 8 * 8; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi16(a, b);\n        __m128i result = _mm_min_epi16(sum, max_val);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i max_val = _mm_set1_epi16(UINT16_MAX);\n\n    for (; i <= length - 8; i += 8) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi16(vec1, vec2);\n        __m128i result = _mm_min_epi16(sum, max_val);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i max_val = _mm_set1_epi16(UINT16_MAX);\n\n    for (; i <= length - 8; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi16(a, b);\n        __m128i result = _mm_min_epi16(sum, max_val);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i max_val = _mm_set1_epi16(UINT16_MAX);\n\n    for (; i <= length - 8; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&src2[i]);\n        __m128i sum = _mm_add_epi16(a, b);\n        __m128i result = _mm_min_epi16(sum, max_val);\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d zero = _mm_setzero_pd();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vals = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vals = _mm_loadu_pd(&B[k * p + j]);\n\n                __m128d mask_a = _mm_and_pd(_mm_cmpge_pd(a_vals, _mm_set1_pd(-100.0)), _mm_cmple_pd(a_vals, _mm_set1_pd(100.0)));\n                __m128d mask_b = _mm_and_pd(_mm_cmpge_pd(b_vals, _mm_set1_pd(-100.0)), _mm_cmple_pd(b_vals, _mm_set1_pd(100.0)));\n\n                __m128d mask = _mm_and_pd(mask_a, mask_b);\n                a_vals = _mm_and_pd(a_vals, mask);\n                b_vals = _mm_and_pd(b_vals, mask);\n\n                sum = _mm_add_pd(sum, _mm_mul_pd(a_vals, b_vals));\n            }\n            sum = _mm_hadd_pd(sum, sum);\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            C[i * p + j] += result[0] + result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b = _mm_loadu_pd(&B[k * p + j]);\n\n                __m128d mask_a = _mm_and_pd(_mm_cmpge_pd(a, _mm_set1_pd(-100.0)), _mm_cmple_pd(a, _mm_set1_pd(100.0)));\n                __m128d mask_b = _mm_and_pd(_mm_cmpge_pd(b, _mm_set1_pd(-100.0)), _mm_cmple_pd(b, _mm_set1_pd(100.0)));\n\n                __m128d mask = _mm_and_pd(mask_a, mask_b);\n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n\n                sum = _mm_add_pd(sum, prod);\n            }\n            sum = _mm_hadd_pd(sum, sum);\n            _mm_storeu_pd(&C[i * p + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d v_min = _mm_set1_pd(-100.0);\n    __m128d v_max = _mm_set1_pd(100.0);\n    \n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vals = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vals = _mm_loadu_pd(&B[k * p + j]);\n\n                __m128d a_mask = _mm_and_pd(_mm_cmpge_pd(a_vals, v_min), _mm_cmple_pd(a_vals, v_max));\n                __m128d b_mask = _mm_and_pd(_mm_cmpge_pd(b_vals, v_min), _mm_cmple_pd(b_vals, v_max));\n\n                __m128d mask = _mm_and_pd(a_mask, b_mask);\n\n                a_vals = _mm_and_pd(mask, a_vals);\n                b_vals = _mm_and_pd(mask, b_vals);\n\n                sum = _mm_add_pd(sum, _mm_mul_pd(a_vals, b_vals));\n            }\n            sum = _mm_hadd_pd(sum, sum);\n            _mm_storeu_pd(&C[i * p + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d zero = _mm_setzero_pd();\n    __m128d min_val = _mm_set1_pd(-100.0);\n    __m128d max_val = _mm_set1_pd(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vals = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vals = _mm_loadu_pd(&B[k * p + j]);\n\n                __m128d a_mask = _mm_and_pd(_mm_cmpge_pd(a_vals, min_val), _mm_cmple_pd(a_vals, max_val));\n                __m128d b_mask = _mm_and_pd(_mm_cmpge_pd(b_vals, min_val), _mm_cmple_pd(b_vals, max_val));\n\n                __m128d mask = _mm_and_pd(a_mask, b_mask);\n                a_vals = _mm_and_pd(a_vals, mask);\n                b_vals = _mm_and_pd(b_vals, mask);\n\n                sum = _mm_add_pd(sum, _mm_mul_pd(a_vals, b_vals));\n            }\n            sum = _mm_hadd_pd(sum, sum);\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            C[i * p + j] += result[0];\n            C[i * p + j + 1] += result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d v_min = _mm_set1_pd(-100.0);\n    __m128d v_max = _mm_set1_pd(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vals = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vals = _mm_loadu_pd(&B[k * p + j]);\n\n                __m128d a_mask = _mm_and_pd(_mm_cmpge_pd(a_vals, v_min), _mm_cmple_pd(a_vals, v_max));\n                __m128d b_mask = _mm_and_pd(_mm_cmpge_pd(b_vals, v_min), _mm_cmple_pd(b_vals, v_max));\n                __m128d mask = _mm_and_pd(a_mask, b_mask);\n\n                a_vals = _mm_and_pd(a_vals, mask);\n                b_vals = _mm_and_pd(b_vals, mask);\n\n                sum = _mm_add_pd(sum, _mm_mul_pd(a_vals, b_vals));\n            }\n            sum = _mm_hadd_pd(sum, sum);\n            _mm_storeu_pd(&C[i * p + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    __m128i* a_ptr = (__m128i*)A;\n    __m128i* b_ptr = (__m128i*)B;\n    __m128i* c_ptr = (__m128i*)C;\n\n    for (i = 0; i < total_elements / 2; ++i) {\n        __m128i a_val = _mm_load_si128(&a_ptr[i]);\n        __m128i b_val = _mm_load_si128(&b_ptr[i]);\n        __m128i c_val = _mm_add_epi64(a_val, b_val);\n        _mm_store_si128(&c_ptr[i], c_val);\n    }\n\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < total_elements / 2; i++) {\n        __m128i a = _mm_load_si128(&pA[i]);\n        __m128i b = _mm_load_si128(&pB[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_store_si128(&pC[i], c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    // Process 8 elements at a time using SSE2\n    for (i = 0; i + 7 < total_elements; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    // Process 8 elements at a time\n    for (i = 0; i + 7 < total_elements; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    // Process 8 elements at a time\n    for (i = 0; i + 7 < total_elements; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 v1, v2, v_sum;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        v1 = _mm_loadu_ps(&src1[i]);\n        v2 = _mm_loadu_ps(&src2[i]);\n        v_sum = _mm_add_ps(v1, v2);\n        v_sum = _mm_round_ps(v_sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], v_sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 vec1, vec2, result;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        vec1 = _mm_loadu_ps(&src1[i]);\n        vec2 = _mm_loadu_ps(&src2[i]);\n        result = _mm_add_ps(vec1, vec2);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 vec1, vec2, vec_sum, vec_rounded;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        vec1 = _mm_loadu_ps(&src1[i]);\n        vec2 = _mm_loadu_ps(&src2[i]);\n        vec_sum = _mm_add_ps(vec1, vec2);\n        vec_rounded = _mm_round_ps(vec_sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], vec_rounded);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 v1, v2, v_sum;\n\n    for (i = 0; i < length / 4 * 4; i += 4) {\n        v1 = _mm_loadu_ps(&src1[i]);\n        v2 = _mm_loadu_ps(&src2[i]);\n        v_sum = _mm_add_ps(v1, v2);\n        v_sum = _mm_round_ps(v_sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], v_sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 v1, v2, v_sum;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        v1 = _mm_loadu_ps(&src1[i]);\n        v2 = _mm_loadu_ps(&src2[i]);\n        v_sum = _mm_add_ps(v1, v2);\n        v_sum = _mm_round_ps(v_sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_ps(&dst[i], v_sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 threshold = _mm_set1_ps(50.0f);\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        if (i % 2 != 0) {\n            for (size_t j = 0; j < 4 && (i + j) < length; ++j) {\n                dst[i + j] = -1.0f;\n            }\n            continue;\n        }\n\n        __m128 a = _mm_loadu_ps(&src1[i]);\n        __m128 b = _mm_loadu_ps(&src2[i]);\n        __m128 diff = _mm_sub_ps(a, b);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        abs_diff = _mm_max_ps(abs_diff, _mm_neg_ps(diff));\n\n        __m128 mask = _mm_cmple_ps(abs_diff, threshold);\n        __m128 result = _mm_mul_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_UP);\n\n        result = _mm_blendv_ps(minus_one, result, mask);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (size_t j = 0; j < length % 4; ++j) {\n        if ((length - (length % 4) + j) % 2 == 0) {\n            float a = src1[length - (length % 4) + j];\n            float b = src2[length - (length % 4) + j];\n            float diff = fabsf(a - b);\n            if (diff <= 50.0f) {\n                dst[length - (length % 4) + j] = ceilf(a * b);\n            } else {\n                dst[length - (length % 4) + j] = -1.0f;\n            }\n        } else {\n            dst[length - (length % 4) + j] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 v50 = _mm_set1_ps(50.0f);\n    __m128 vNegOne = _mm_set1_ps(-1.0f);\n    \n    for (i = 0; i < length; i += 4) {\n        __m128 vSrc1 = _mm_loadu_ps(&src1[i]);\n        __m128 vSrc2 = _mm_loadu_ps(&src2[i]);\n        \n        __m128 vDiff = _mm_sub_ps(vSrc1, vSrc2);\n        __m128 vAbsDiff = _mm_and_ps(vDiff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n        \n        __m128 vCondition = _mm_cmple_ps(vAbsDiff, v50);\n        \n        __m128 vResult = _mm_mul_ps(vSrc1, vSrc2);\n        vResult = _mm_round_ps(vResult, _MM_FROUND_UP);\n        \n        __m128 vFinalResult = _mm_blendv_ps(vNegOne, vResult, vCondition);\n        \n        if (i + 4 <= length) {\n            _mm_storeu_ps(&dst[i], vFinalResult);\n        } else {\n            for (size_t j = 0; j < length - i; j++) {\n                dst[i + j] = _mm_cvtss_f32(vFinalResult);\n            }\n        }\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if (diff <= 50.0f) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF);\n    __m128 threshold = _mm_set1_ps(50.0f);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        if (i % 2 == 0) {\n            __m128 a = _mm_loadu_ps(&src1[i]);\n            __m128 b = _mm_loadu_ps(&src2[i]);\n            __m128 diff = _mm_sub_ps(a, b);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(mask));\n            abs_diff = _mm_max_ps(abs_diff, _mm_sub_ps(_mm_setzero_ps(), diff));\n            \n            __m128 cmp = _mm_cmple_ps(abs_diff, threshold);\n            __m128 mul = _mm_mul_ps(a, b);\n            mul = _mm_round_ps(mul, _MM_FROUND_UP);\n            \n            __m128 result = _mm_blendv_ps(_mm_set1_ps(-1.0f), mul, cmp);\n            _mm_storeu_ps(&dst[i], result);\n        } else {\n            if (i + 4 <= length) {\n                _mm_storeu_ps(&dst[i], _mm_set1_ps(-1.0f));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128i mask = _mm_set1_epi32(0x7FFFFFFF);\n    __m128 threshold = _mm_set1_ps(50.0f);\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        if (i % 2 == 0) {\n            __m128 a = _mm_loadu_ps(&src1[i]);\n            __m128 b = _mm_loadu_ps(&src2[i]);\n            __m128 diff = _mm_sub_ps(a, b);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(mask));\n            \n            __m128 cmp_mask = _mm_cmple_ps(abs_diff, threshold);\n            __m128 result = _mm_mul_ps(a, b);\n            result = _mm_round_ps(result, _MM_FROUND_UP);\n            result = _mm_blendv_ps(minus_one, result, cmp_mask);\n            \n            _mm_storeu_ps(&dst[i], result);\n        } else {\n            for (size_t j = 0; j < 4 && (i + j) < length; ++j) {\n                dst[i + j] = -1.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    __m128 threshold = _mm_set1_ps(50.0f);\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    \n    for (i = 0; i < length; i += 4) {\n        __m128 v_src1 = _mm_loadu_ps(&src1[i]);\n        __m128 v_src2 = _mm_loadu_ps(&src2[i]);\n        \n        __m128 v_diff = _mm_sub_ps(v_src1, v_src2);\n        __m128 v_abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), v_diff);\n        v_abs_diff = _mm_max_ps(v_abs_diff, _mm_neg_ps(v_diff));\n        \n        __m128 mask = _mm_cmple_ps(v_abs_diff, threshold);\n        __m128 index_mask = _mm_set1_ps((float)(i % 2 == 0 ? 1 : 0));\n        mask = _mm_and_ps(mask, index_mask);\n        \n        __m128 v_result = _mm_mul_ps(v_src1, v_src2);\n        v_result = _mm_round_ps(v_result, _MM_FROUND_UP);\n        v_result = _mm_blendv_ps(minus_one, v_result, mask);\n        \n        _mm_storeu_ps(&dst[i], v_result);\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i + 1 < total_elements; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            __m128 vec = _mm_loadu_ps(&mat[i * n + j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(vec, vec));\n        }\n\n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float norm = sqrt(temp[0] + temp[1] + temp[2] + temp[3]);\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 vec = _mm_loadu_ps(&mat[i * n + j]);\n            vec = _mm_div_ps(vec, _mm_set1_ps(norm));\n            _mm_storeu_ps(&mat[i * n + j], vec);\n        }\n        \n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_squares = _mm_setzero_ps();\n        size_t j = 0;\n\n        // Compute the sum of squares for the current row\n        for (; j + 4 <= n; j += 4) {\n            __m128 vec = _mm_loadu_ps(&mat[i * n + j]);\n            sum_squares = _mm_add_ps(sum_squares, _mm_mul_ps(vec, vec));\n        }\n\n        // Horizontal sum of the squares\n        sum_squares = _mm_hadd_ps(sum_squares, sum_squares);\n        sum_squares = _mm_hadd_ps(sum_squares, sum_squares);\n        float norm;\n        _mm_store_ss(&norm, sum_squares);\n        norm = sqrtf(norm);\n\n        // Normalize the current row\n        for (size_t k = 0; k < j; k += 4) {\n            __m128 vec = _mm_loadu_ps(&mat[i * n + k]);\n            __m128 normalized_vec = _mm_div_ps(vec, _mm_set1_ps(norm));\n            _mm_storeu_ps(&mat[i * n + k], normalized_vec);\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_squares = _mm_setzero_ps();\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(&mat[i * n + j]);\n            sum_squares = _mm_add_ps(sum_squares, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float temp[4];\n        _mm_storeu_ps(temp, sum_squares);\n        float norm = sqrt(temp[0] + temp[1] + temp[2] + temp[3]);\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 normalized_vec = _mm_div_ps(row_vec, _mm_set1_ps(norm));\n            _mm_storeu_ps(&mat[i * n + j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_squares = _mm_setzero_ps();\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(&mat[i * n + j]);\n            sum_squares = _mm_add_ps(sum_squares, _mm_mul_ps(row_vec, row_vec));\n        }\n\n        float temp[4];\n        _mm_storeu_ps(temp, sum_squares);\n        float norm = sqrt(temp[0] + temp[1] + temp[2] + temp[3]);\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 normalized_vec = _mm_div_ps(row_vec, _mm_set1_ps(norm));\n            _mm_storeu_ps(&mat[i * n + j], normalized_vec);\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum_squares = _mm_setzero_ps();\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            __m128 row_elements = _mm_loadu_ps(&mat[i * n + j]);\n            sum_squares = _mm_add_ps(sum_squares, _mm_mul_ps(row_elements, row_elements));\n        }\n\n        float sum_squares_array[4];\n        _mm_storeu_ps(sum_squares_array, sum_squares);\n        float norm = sum_squares_array[0] + sum_squares_array[1] + sum_squares_array[2] + sum_squares_array[3];\n        norm = sqrt(norm);\n\n        for (size_t k = 0; k < j; ++k) {\n            mat[i * n + k] /= norm;\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            dst[i * p + j] = round(result[0] + result[1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row1 = _mm_loadu_ps(&src[i * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row4 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            __m128 tmp1 = _mm_unpacklo_ps(row1, row2);\n            __m128 tmp2 = _mm_unpackhi_ps(row1, row2);\n            __m128 tmp3 = _mm_unpacklo_ps(row3, row4);\n            __m128 tmp4 = _mm_unpackhi_ps(row3, row4);\n\n            __m128 t1 = _mm_unpacklo_ps(tmp1, tmp3);\n            __m128 t2 = _mm_unpackhi_ps(tmp1, tmp3);\n            __m128 t3 = _mm_unpacklo_ps(tmp2, tmp4);\n            __m128 t4 = _mm_unpackhi_ps(tmp2, tmp4);\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            t1 = _mm_round_ps(_mm_add_ps(t1, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t2 = _mm_round_ps(_mm_add_ps(t2, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t3 = _mm_round_ps(_mm_add_ps(t3, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t4 = _mm_round_ps(_mm_add_ps(t4, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n\n            // Store transposed and rounded values\n            _mm_storeu_ps(&dst[j * rows + i], t1);\n            _mm_storeu_ps(&dst[j * rows + i + 1], t2);\n            _mm_storeu_ps(&dst[j * rows + i + 2], t3);\n            _mm_storeu_ps(&dst[j * rows + i + 3], t4);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(&src[i * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            __m128 t0 = _mm_unpacklo_ps(tmp0, tmp2);\n            __m128 t1 = _mm_unpackhi_ps(tmp0, tmp2);\n            __m128 t2 = _mm_unpacklo_ps(tmp1, tmp3);\n            __m128 t3 = _mm_unpackhi_ps(tmp1, tmp3);\n\n            // Round to nearest quarter (0.25)\n            __m128 quarter = _mm_set1_ps(0.25f);\n            t0 = _mm_round_ps(_mm_add_ps(t0, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t1 = _mm_round_ps(_mm_add_ps(t1, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t2 = _mm_round_ps(_mm_add_ps(t2, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t3 = _mm_round_ps(_mm_add_ps(t3, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n\n            // Store transposed and rounded values\n            _mm_storeu_ps(&dst[j * rows + i], t0);\n            _mm_storeu_ps(&dst[j * rows + i + 1], t1);\n            _mm_storeu_ps(&dst[j * rows + i + 2], t2);\n            _mm_storeu_ps(&dst[j * rows + i + 3], t3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(&src[i * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp2 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            row0 = _mm_unpacklo_ps(tmp0, tmp1);\n            row1 = _mm_unpackhi_ps(tmp0, tmp1);\n            row2 = _mm_unpacklo_ps(tmp2, tmp3);\n            row3 = _mm_unpackhi_ps(tmp2, tmp3);\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_round_ps(_mm_add_ps(row0, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            row1 = _mm_round_ps(_mm_add_ps(row1, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            row2 = _mm_round_ps(_mm_add_ps(row2, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            row3 = _mm_round_ps(_mm_add_ps(row3, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n\n            // Store transposed and rounded values\n            _mm_storeu_ps(&dst[j * rows + i], row0);\n            _mm_storeu_ps(&dst[j * rows + i + 1], row1);\n            _mm_storeu_ps(&dst[j * rows + i + 2], row2);\n            _mm_storeu_ps(&dst[j * rows + i + 3], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(&src[i * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            __m128 t0 = _mm_unpacklo_ps(tmp0, tmp2);\n            __m128 t1 = _mm_unpackhi_ps(tmp0, tmp2);\n            __m128 t2 = _mm_unpacklo_ps(tmp1, tmp3);\n            __m128 t3 = _mm_unpackhi_ps(tmp1, tmp3);\n\n            // Round to nearest quarter (0.25)\n            __m128 quarter = _mm_set1_ps(0.25f);\n            t0 = _mm_round_ps(_mm_add_ps(t0, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t1 = _mm_round_ps(_mm_add_ps(t1, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t2 = _mm_round_ps(_mm_add_ps(t2, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n            t3 = _mm_round_ps(_mm_add_ps(t3, _mm_set1_ps(0.125f)), _MM_FROUND_TO_NEAREST_INT);\n\n            // Store transposed and rounded values\n            _mm_storeu_ps(&dst[j * rows + i], t0);\n            _mm_storeu_ps(&dst[j * rows + i + 1], t1);\n            _mm_storeu_ps(&dst[j * rows + i + 2], t2);\n            _mm_storeu_ps(&dst[j * rows + i + 3], t3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row = _mm_loadu_ps(&src[i * cols + j]);\n            row = _mm_add_ps(row, _mm_set1_ps(0.125f)); // Add 0.125 for rounding\n            row = _mm_floor_ps(row); // Floor the values\n            row = _mm_div_ps(row, _mm_set1_ps(0.25f)); // Divide by 0.25\n            row = _mm_round_ps(row, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC); // Round to nearest\n            row = _mm_mul_ps(row, _mm_set1_ps(0.25f)); // Multiply back by 0.25\n            _mm_storeu_ps(&dst[j * rows + i], row); // Store transposed value\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 3 < total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&tensor1[i]);\n        __m128 b = _mm_loadu_ps(&tensor2[i]);\n        __m128 result = _mm_sub_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_ZERO);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&tensor1[i]);\n        __m128 b = _mm_loadu_ps(&tensor2[i]);\n        __m128 result = _mm_sub_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_ZERO);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (float)((int)(tensor1[i] - tensor2[i])) : (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&tensor1[i]);\n        __m128 b = _mm_loadu_ps(&tensor2[i]);\n        __m128 result = _mm_sub_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_ZERO);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (float)((int)(tensor1[i] - tensor2[i])) : (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&tensor1[i]);\n        __m128 b = _mm_loadu_ps(&tensor2[i]);\n        __m128 result = _mm_sub_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_ZERO);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (int)(tensor1[i] - tensor2[i]) : (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128 a = _mm_loadu_ps(&tensor1[i]);\n        __m128 b = _mm_loadu_ps(&tensor2[i]);\n        __m128 result = _mm_sub_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_ZERO);\n        _mm_storeu_ps(&dst[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (tensor1[i] - tensor2[i] > 0) ? (float)((int)(tensor1[i] - tensor2[i])) : (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d a = _mm_load_pd(&mat1[i]);\n        __m128d b = _mm_load_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(a, b);\n        _mm_store_pd(&dst[i], result);\n    }\n\n    for (; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        __m128 sum = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 mat_row = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vals = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_row, vec_vals));\n        }\n        sum = _mm_hadd_ps(sum, sum);\n        sum = _mm_hadd_ps(sum, sum);\n        _mm_store_ss(&dst[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum = _mm_setzero_pd();\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d vec = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double result[2];\n    _mm_storeu_pd(result, sum);\n\n    double total_sum = result[0] + result[1];\n    \n    // Handle remaining elements if total_elements is odd\n    if (total_elements % 2 != 0) {\n        total_sum += mat[total_elements - 1];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t num_vectors = total_elements / 4;\n    size_t remaining_elements = total_elements % 4;\n\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < num_vectors; ++i) {\n        __m128d vec = _mm_loadu_pd(&mat[i * 4]);\n        sum_vec = _mm_add_pd(sum_vec, vec);\n    }\n\n    double sum_array[2];\n    _mm_storeu_pd(sum_array, sum_vec);\n    double total_sum = sum_array[0] + sum_array[1];\n\n    for (size_t j = 0; j < remaining_elements; ++j) {\n        total_sum += mat[num_vectors * 4 + j];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum = _mm_setzero_pd();\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d vec = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double temp[2];\n    _mm_storeu_pd(temp, sum);\n    double total_sum = temp[0] + temp[1];\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum = _mm_setzero_pd();\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i <= total_elements - 2; i += 2) {\n        __m128d vec = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double result[2];\n    _mm_storeu_pd(result, sum);\n\n    double total_sum = result[0] + result[1];\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        total_sum += mat[i];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, data_vec);\n    }\n\n    double sum[2];\n    _mm_storeu_pd(sum, sum_vec);\n\n    double total_sum = sum[0] + sum[1];\n\n    // Handle any remaining elements if total_elements is odd\n    if (total_elements % 2 != 0) {\n        total_sum += mat[total_elements - 1];\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    __m128i prev, curr;\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        bool sorted = true;\n\n        for (size_t j = 0; j < cols; j += 4) {\n            if (j + 4 > cols) break;\n\n            curr = _mm_loadu_si128((__m128i*)&matrix[i * cols + j]);\n\n            if (j == 0) {\n                prev = curr;\n                continue;\n            }\n\n            if (ascending) {\n                __m128i cmp = _mm_cmpgt_epi32(curr, prev);\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    sorted = false;\n                    break;\n                }\n            } else {\n                __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    sorted = false;\n                    break;\n                }\n            }\n            prev = curr;\n        }\n\n        if (!sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    __m128i prev, curr;\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        bool sorted = true;\n\n        for (size_t j = 0; j < cols; j += 4) {\n            prev = _mm_loadu_si128((__m128i*)&matrix[i * cols + j]);\n            if (j + 4 < cols) {\n                curr = _mm_loadu_si128((__m128i*)&matrix[i * cols + j + 4]);\n                if (ascending) {\n                    __m128i cmp = _mm_cmpgt_epi32(curr, prev);\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        sorted = false;\n                        break;\n                    }\n                } else {\n                    __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        sorted = false;\n                        break;\n                    }\n                }\n            }\n            prev = curr;\n        }\n        if (!sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n        size_t c = 0;\n        __m128i prev = _mm_loadu_si128((__m128i*)(row + c));\n\n        for (c = 1; c < cols; c += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + c));\n            __m128i cmp = ascending ? _mm_cmpgt_epi32(curr, prev) : _mm_cmpgt_epi32(prev, curr);\n            int mask = _mm_movemask_epi8(cmp);\n            if (mask != 0) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    __m128i prev, curr;\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        bool sorted = true;\n\n        for (size_t j = 0; j < cols; j += 4) {\n            if (j + 4 > cols) break;\n\n            curr = _mm_loadu_si128((__m128i*)&matrix[i * cols + j]);\n            if (j == 0) {\n                prev = curr;\n                continue;\n            }\n\n            if (ascending) {\n                __m128i cmp = _mm_cmpgt_epi32(curr, prev);\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    sorted = false;\n                    break;\n                }\n            } else {\n                __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    sorted = false;\n                    break;\n                }\n            }\n            prev = curr;\n        }\n\n        if (!sorted) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool direction = directions[i];\n        __m128i prev = _mm_loadu_si128((__m128i*)row);\n        bool sorted = true;\n\n        for (size_t j = 1; j < cols; j += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i cmp = direction ? _mm_cmpgt_epi32(curr, prev) : _mm_cmpgt_epi32(prev, curr);\n            int mask = _mm_movemask_epi8(cmp);\n            if (mask != 0) {\n                sorted = false;\n                break;\n            }\n            prev = curr;\n        }\n\n        if (!sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i base_vec = _mm_set1_epi16(base);\n    __m128i base_minus_one = _mm_set1_epi16(base - 1);\n    \n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        __m128i src_vec1 = _mm_loadu_si128((__m128i*)&src[i * 8]);\n        __m128i src_vec2 = _mm_loadu_si128((__m128i*)&src[i * 8 + 4]);\n\n        __m128i div_vec1 = _mm_div_epi16(src_vec1, base_vec);\n        __m128i div_vec2 = _mm_div_epi16(src_vec2, base_vec);\n\n        __m128i mul_vec1 = _mm_mullo_epi16(div_vec1, base_vec);\n        __m128i mul_vec2 = _mm_mullo_epi16(div_vec2, base_vec);\n\n        __m128i nearest_vec1 = _mm_min_epi16(mul_vec1, src_vec1);\n        __m128i nearest_vec2 = _mm_min_epi16(mul_vec2, src_vec2);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 8], nearest_vec1);\n        _mm_storeu_si128((__m128i*)&dst[i * 8 + 4], nearest_vec2);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i base_vec = _mm_set1_epi16(base);\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        __m128i src_vec1 = _mm_loadu_si128((__m128i*)&src[i * 8]);\n        __m128i src_vec2 = _mm_loadu_si128((__m128i*)&src[i * 8 + 4]);\n\n        __m128i mod_vec1 = _mm_rem_epi16(src_vec1, base_vec);\n        __m128i mod_vec2 = _mm_rem_epi16(src_vec2, base_vec);\n\n        __m128i nearest_vec1 = _mm_sub_epi16(src_vec1, mod_vec1);\n        __m128i nearest_vec2 = _mm_sub_epi16(src_vec2, mod_vec2);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 8], nearest_vec1);\n        _mm_storeu_si128((__m128i*)&dst[i * 8 + 4], nearest_vec2);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[i] - (src[i] % base);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i base_vec = _mm_set1_epi16(base);\n    __m128i base_minus_one = _mm_set1_epi16(base - 1);\n    \n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        __m128i src_vec1 = _mm_loadu_si128((__m128i*)&src[i * 8]);\n        __m128i src_vec2 = _mm_loadu_si128((__m128i*)&src[i * 8 + 4]);\n\n        __m128i mod1 = _mm_and_si128(src_vec1, base_minus_one);\n        __m128i mod2 = _mm_and_si128(src_vec2, base_minus_one);\n\n        __m128i nearest1 = _mm_sub_epi16(src_vec1, mod1);\n        __m128i nearest2 = _mm_sub_epi16(src_vec2, mod2);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 8], nearest1);\n        _mm_storeu_si128((__m128i*)&dst[i * 8 + 4], nearest2);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[i] - (src[i] % base);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i base_vec = _mm_set1_epi16(base);\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    size_t i;\n    for (i = 0; i < length / 8; i++) {\n        __m128i src_vec1 = _mm_loadu_si128((__m128i*)&src[i * 8]);\n        __m128i src_vec2 = _mm_loadu_si128((__m128i*)&src[i * 8 + 4]);\n\n        __m128i mod1 = _mm_rem_epi16(src_vec1, base_vec);\n        __m128i mod2 = _mm_rem_epi16(src_vec2, base_vec);\n\n        __m128i nearest1 = _mm_sub_epi16(src_vec1, mod1);\n        __m128i nearest2 = _mm_sub_epi16(src_vec2, mod2);\n\n        _mm_storeu_si128((__m128i*)&dst[i * 8], nearest1);\n        _mm_storeu_si128((__m128i*)&dst[i * 8 + 4], nearest2);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i base_vec = _mm_set1_epi16(base);\n    __m128i base_minus_one = _mm_sub_epi16(base_vec, _mm_set1_epi16(1));\n    \n    for (size_t i = 0; i < length; i += 8) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        __m128i mult_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        __m128i mult_plus_base = _mm_add_epi16(mult_vec, base_vec);\n        __m128i nearest_vec = _mm_min_epi16(mult_vec, mult_plus_base);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], nearest_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec0 = _mm_load_pd(&vector[0]);\n    __m128d vec1 = _mm_load_pd(&vector[2]);\n\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d mat0 = _mm_load_pd(&matrix[i * cols]);\n        __m128d mat1 = _mm_load_pd(&matrix[i * cols + 2]);\n\n        __m128d cmp0 = _mm_cmpeq_pd(mat0, vec0);\n        __m128d cmp1 = _mm_cmpeq_pd(mat1, vec1);\n\n        if (_mm_movemask_pd(cmp0) == 0x03 || _mm_movemask_pd(cmp1) == 0x03) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec0 = _mm_load_pd(&vector[0]);\n    __m128d vec1 = _mm_load_pd(&vector[2]);\n\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d mat0 = _mm_load_pd(&matrix[i * cols]);\n        __m128d mat1 = _mm_load_pd(&matrix[i * cols + 2]);\n\n        __m128d cmp0 = _mm_cmpeq_pd(mat0, vec0);\n        __m128d cmp1 = _mm_cmpeq_pd(mat1, vec1);\n\n        if (_mm_movemask_pd(cmp0) == 0x3 || _mm_movemask_pd(cmp1) == 0x3) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec0 = _mm_loadu_pd(&vector[0]);\n    __m128d vec1 = _mm_loadu_pd(&vector[2]);\n\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d mat0 = _mm_loadu_pd(&matrix[i * cols]);\n        __m128d mat1 = _mm_loadu_pd(&matrix[i * cols + 2]);\n\n        __m128d cmp0 = _mm_cmpeq_pd(mat0, vec0);\n        __m128d cmp1 = _mm_cmpeq_pd(mat1, vec1);\n\n        if (_mm_movemask_pd(cmp0) == 0x3 || _mm_movemask_pd(cmp1) == 0x3) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec0 = _mm_load_pd(&vector[0]);\n    __m128d vec1 = _mm_load_pd(&vector[2]);\n\n    for (size_t i = 0; i < rows; ++i) {\n        __m128d mat0 = _mm_load_pd(&matrix[i * cols]);\n        __m128d mat1 = _mm_load_pd(&matrix[i * cols + 2]);\n\n        __m128d cmp0 = _mm_cmpeq_pd(mat0, vec0);\n        __m128d cmp1 = _mm_cmpeq_pd(mat1, vec1);\n\n        if (_mm_movemask_pd(cmp0) == 0x3 || _mm_movemask_pd(cmp1) == 0x3) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    __m128d vec0 = _mm_loadu_pd(vector);\n    __m128d vec1 = _mm_loadu_pd(vector + 2);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        __m128d row0 = _mm_loadu_pd(row);\n        __m128d row1 = _mm_loadu_pd(row + 2);\n\n        __m128d cmp0 = _mm_cmpeq_pd(row0, vec0);\n        __m128d cmp1 = _mm_cmpeq_pd(row1, vec1);\n\n        if (_mm_movemask_pd(cmp0) == 0x3 || _mm_movemask_pd(cmp1) == 0x3) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    \n    __m128i equal_mask = _mm_set1_epi8(0xFF);\n    \n    for (size_t i = 0; i < total_elements; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i cmp_result = _mm_cmpeq_epi8(a_vec, b_vec);\n        equal_mask = _mm_and_si128(equal_mask, cmp_result);\n        \n        count += _mm_popcnt_u32(_mm_movemask_epi8(equal_mask));\n        equal_mask = _mm_set1_epi8(0xFF); // Reset mask for next iteration\n    }\n    \n    // Handle remaining elements\n    for (size_t i = total_elements - (total_elements % 16); i < total_elements; ++i) {\n        count += (A[i] == B[i]) ? 1 : 0;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    size_t simd_iterations = total_elements / 16;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i a = _mm_loadu_si128(&ptrA[i]);\n        __m128i b = _mm_loadu_si128(&ptrB[i]);\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * 16; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i scalar = _mm_set1_epi64x(a);\n    size_t i;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i * 2]);\n        __m128i mul_result = _mm_mullo_epi64(scalar, vec_x);\n        __m128i abs_result = _mm_abs_epi64(mul_result);\n        _mm_storeu_si128((__m128i*)&y[i * 2], abs_result);\n    }\n\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i scalar = _mm_set1_epi64x(a);\n    size_t i;\n\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i mul_result = _mm_mullo_epi64(scalar, vec_x);\n        __m128i abs_result = _mm_abs_epi64(mul_result);\n        _mm_storeu_si128((__m128i*)&y[i], abs_result);\n    }\n\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i scalar = _mm_set1_epi64x(a);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i product = _mm_mullo_epi64(scalar, vec_x);\n        __m128i abs_y = _mm_abs_epi64(product);\n        _mm_storeu_si128((__m128i*)&y[i], abs_y);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i scalar = _mm_set1_epi64x(a);\n    size_t i;\n\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i product = _mm_mullo_epi64(scalar, vec_x);\n        __m128i abs_y = _mm_abs_epi64(product);\n        _mm_storeu_si128((__m128i*)&y[i], abs_y);\n    }\n\n    for (; i < length; i++) {\n        y[i] = abs(x[i] * a);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i scalar = _mm_set1_epi64x(a);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vec_x = _mm_loadu_si128((__m128i*)&x[i]);\n        __m128i mul_result = _mm_mullo_epi64(scalar, vec_x);\n        \n        __m128i abs_result = _mm_sign_epi64(mul_result, mul_result);\n        _mm_storeu_si128((__m128i*)&y[i], abs_result);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    __m128i min_val = _mm_set1_epi16(INT16_MAX);\n    __m128i max_val = _mm_set1_epi16(INT16_MIN);\n\n    size_t i;\n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i data = _mm_loadu_si128((__m128i*)&vec[i]);\n        min_val = _mm_min_epi16(min_val, data);\n        max_val = _mm_max_epi16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        min_val = _mm_min_epi16(min_val, _mm_set1_epi16(value));\n        max_val = _mm_max_epi16(max_val, _mm_set1_epi16(value));\n    }\n\n    // Reduce min_val\n    min_val = _mm_min_epi16(min_val, _mm_shuffle_epi32(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    min_val = _mm_min_epi16(min_val, _mm_shufflelo_epi16(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    min_val = _mm_min_epi16(min_val, _mm_shufflehi_epi16(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n\n    // Reduce max_val\n    max_val = _mm_max_epi16(max_val, _mm_shuffle_epi32(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    max_val = _mm_max_epi16(max_val, _mm_shufflelo_epi16(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    max_val = _mm_max_epi16(max_val, _mm_shufflehi_epi16(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n\n    // Store results\n    result.min_num = _mm_extract_epi16(min_val, 0);\n    result.max_num = _mm_extract_epi16(max_val, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    __m128i min_val = _mm_set1_epi16(INT16_MAX);\n    __m128i max_val = _mm_set1_epi16(INT16_MIN);\n\n    size_t i;\n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i data = _mm_loadu_si128((__m128i*)&vec[i]);\n        min_val = _mm_min_epi16(min_val, data);\n        max_val = _mm_max_epi16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        min_val = _mm_min_epi16(min_val, _mm_set1_epi16(value));\n        max_val = _mm_max_epi16(max_val, _mm_set1_epi16(value));\n    }\n\n    // Reduce min and max values\n    min_val = _mm_min_epi16(min_val, _mm_shuffle_epi32(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    min_val = _mm_min_epi16(min_val, _mm_shufflelo_epi16(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    min_val = _mm_min_epi16(min_val, _mm_shufflehi_epi16(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n\n    max_val = _mm_max_epi16(max_val, _mm_shuffle_epi32(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    max_val = _mm_max_epi16(max_val, _mm_shufflelo_epi16(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    max_val = _mm_max_epi16(max_val, _mm_shufflehi_epi16(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n\n    result.min_num = _mm_extract_epi16(min_val, 0);\n    result.max_num = _mm_extract_epi16(max_val, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    __m128i min_val = _mm_set1_epi16(INT16_MAX);\n    __m128i max_val = _mm_set1_epi16(INT16_MIN);\n\n    size_t i;\n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i data = _mm_loadu_si128((__m128i*)&vec[i]);\n        min_val = _mm_min_epi16(min_val, data);\n        max_val = _mm_max_epi16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        min_val = _mm_min_epi16(min_val, _mm_set1_epi16(value));\n        max_val = _mm_max_epi16(max_val, _mm_set1_epi16(value));\n    }\n\n    // Horizontal reduction to find min and max\n    min_val = _mm_min_epi16(min_val, _mm_shuffle_epi32(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    min_val = _mm_min_epi16(min_val, _mm_shufflelo_epi16(min_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    \n    max_val = _mm_max_epi16(max_val, _mm_shuffle_epi32(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n    max_val = _mm_max_epi16(max_val, _mm_shufflelo_epi16(max_val, _MM_SHUFFLE(2, 3, 0, 1)));\n\n    // Store results\n    int16_t min_array[8], max_array[8];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n    _mm_storeu_si128((__m128i*)max_array, max_val);\n\n    result.min_num = min_array[0];\n    result.max_num = max_array[0];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t i;\n\n    __m128i min_vec = _mm_set1_epi16(INT16_MAX);\n    __m128i max_vec = _mm_set1_epi16(INT16_MIN);\n\n    for (i = 0; i < length; i += 8) {\n        __m128i data = _mm_loadu_si128((__m128i*)&vec[i]);\n        min_vec = _mm_min_epi16(min_vec, data);\n        max_vec = _mm_max_epi16(max_vec, data);\n    }\n\n    // Horizontal reduction for min\n    result.min_num = _mm_extract_epi16(min_vec, 0);\n    for (i = 1; i < 8; i++) {\n        result.min_num = (result.min_num < _mm_extract_epi16(min_vec, i)) ? result.min_num : _mm_extract_epi16(min_vec, i);\n    }\n\n    // Horizontal reduction for max\n    result.max_num = _mm_extract_epi16(max_vec, 0);\n    for (i = 1; i < 8; i++) {\n        result.max_num = (result.max_num > _mm_extract_epi16(max_vec, i)) ? result.max_num : _mm_extract_epi16(max_vec, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    __m128i min_val = _mm_set1_epi16(INT16_MAX);\n    __m128i max_val = _mm_set1_epi16(INT16_MIN);\n    \n    size_t i;\n    for (i = 0; i < length / 8 * 8; i += 8) {\n        __m128i data1 = _mm_loadu_si128((__m128i*)&vec[i]);\n        __m128i data2 = _mm_loadu_si128((__m128i*)&vec[i + 4]);\n        \n        min_val = _mm_min_epi16(min_val, data1);\n        min_val = _mm_min_epi16(min_val, data2);\n        \n        max_val = _mm_max_epi16(max_val, data1);\n        max_val = _mm_max_epi16(max_val, data2);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        min_val = _mm_min_epi16(min_val, _mm_set1_epi16(vec[i]));\n        max_val = _mm_max_epi16(max_val, _mm_set1_epi16(vec[i]));\n    }\n    \n    // Reduce min and max values\n    result.min_num = _mm_extract_epi16(min_val, 0);\n    result.max_num = _mm_extract_epi16(max_val, 0);\n    \n    for (i = 1; i < 8; i++) {\n        result.min_num = (result.min_num < _mm_extract_epi16(min_val, i)) ? result.min_num : _mm_extract_epi16(min_val, i);\n        result.max_num = (result.max_num > _mm_extract_epi16(max_val, i)) ? result.max_num : _mm_extract_epi16(max_val, i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)(row + c));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + c + 1));\n\n            __m128i cmp = _mm_cmpgt_epi32(next, current);\n            if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 1]);\n\n            // Compare current with next\n            __m128i cmp = _mm_cmpgt_epi32(next, current);\n\n            // Check if all comparisons are true\n            if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (size_t c = cols - 4; c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 1]);\n\n            // Compare current with next\n            __m128i cmp = _mm_cmpgt_epi32(next, current);\n            int mask = _mm_movemask_epi8(cmp);\n\n            // Check if all comparisons are true (mask should be 0xFFFF)\n            if (mask != 0xFFFF) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] <= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 1]);\n\n            __m128i cmp = _mm_cmpgt_epi32(next, current);\n            if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                return false;\n            }\n        }\n        for (size_t c = cols - 4; c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        for (size_t c = 0; c < cols - 4; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 1]);\n\n            __m128i cmp = _mm_cmpgt_epi32(next, current);\n            if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                return false;\n            }\n        }\n        for (size_t c = cols - (cols % 4); c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            __m128i first_block_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(first_block));\n            for (size_t i = 0; i < block_size; ++i) {\n                __m128i current_block_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(current_block + i * cols));\n                if (_mm_movemask_epi8(_mm_cmpeq_epi32(first_block_vec, current_block_vec)) != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    __m128i first = _mm_loadu_si128((__m128i*)(first_block + i * cols + j));\n                    __m128i current = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n                    __m128i cmp = _mm_cmpeq_epi32(first, current);\n                    int mask = _mm_movemask_epi8(cmp);\n\n                    if (mask != 0xFFFF) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                __m128i first_row = _mm_loadu_si128((__m128i*)(first_block + i * cols));\n                __m128i current_row = _mm_loadu_si128((__m128i*)(current_block + i * cols));\n\n                __m128i cmp = _mm_cmpeq_epi32(first_row, current_row);\n                int mask = _mm_movemask_epi8(cmp);\n\n                if (mask != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                __m128i first_row = _mm_loadu_si128((__m128i*)(first_block + i * cols));\n                __m128i current_row = _mm_loadu_si128((__m128i*)(current_block + i * cols));\n\n                __m128i cmp = _mm_cmpeq_epi32(first_row, current_row);\n                int mask = _mm_movemask_epi8(cmp);\n\n                if (mask != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            for (size_t i = 0; i < block_size; ++i) {\n                __m128i first_row = _mm_loadu_si128((__m128i*)(first_block + i * cols));\n                __m128i current_row = _mm_loadu_si128((__m128i*)(current_block + i * cols));\n                __m128i cmp = _mm_cmpeq_epi32(first_row, current_row);\n                int mask = _mm_movemask_epi8(cmp);\n                if (mask != 0xFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    __m128d tol = _mm_set1_pd(tolerance);\n    \n    for (size_t i = 0; i < num_blocks; ++i) {\n        const double* block_start = vec + i * block_size;\n        __m128d first_elem = _mm_load_pd(block_start);\n        \n        for (size_t j = 1; j < block_size / 2; ++j) {\n            __m128d current_elem = _mm_load_pd(block_start + j * 2);\n            __m128d diff = _mm_sub_pd(first_elem, current_elem);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            if (_mm_movemask_pd(_mm_cmpgt_pd(abs_diff, tol)) != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        __m128d first_block_0 = _mm_loadu_pd(&vec[0 + 0]);\n        __m128d first_block_1 = _mm_loadu_pd(&vec[0 + 2]);\n\n        __m128d current_block_0 = _mm_loadu_pd(&vec[i + 0]);\n        __m128d current_block_1 = _mm_loadu_pd(&vec[i + 2]);\n\n        __m128d diff_0 = _mm_sub_pd(first_block_0, current_block_0);\n        __m128d diff_1 = _mm_sub_pd(first_block_1, current_block_1);\n\n        __m128d abs_diff_0 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_0);\n        __m128d abs_diff_1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_1);\n\n        __m128d within_tolerance_0 = _mm_cmple_pd(abs_diff_0, tolerance_vec);\n        __m128d within_tolerance_1 = _mm_cmple_pd(abs_diff_1, tolerance_vec);\n\n        if (_mm_movemask_pd(within_tolerance_0) != 0x3 || _mm_movemask_pd(within_tolerance_1) != 0x3) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    __m128d first_block[block_size / 2];\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        first_block[i / 2] = _mm_loadu_pd(&vec[i]);\n    }\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        bool equal = true;\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            __m128d current_block = _mm_loadu_pd(&vec[i + j]);\n            for (size_t k = 0; k < block_size / 2; ++k) {\n                __m128d diff = _mm_sub_pd(current_block, first_block[k]);\n                __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n                __m128d cmp = _mm_cmp_pd(abs_diff, tolerance_vec, _CMP_LT_OQ);\n                if (_mm_movemask_pd(cmp) != 0) {\n                    equal = false;\n                    break;\n                }\n            }\n            if (!equal) break;\n        }\n\n        if (!equal) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        __m128d first_block = _mm_loadu_pd(&vec[i]);\n        for (size_t j = 1; j < num_blocks; j++) {\n            __m128d current_block = _mm_loadu_pd(&vec[j * block_size + i]);\n            __m128d diff = _mm_sub_pd(first_block, current_block);\n            __m128d abs_diff = _mm_max_pd(diff, _mm_sub_pd(_mm_setzero_pd(), diff));\n            __m128d cmp = _mm_cmple_pd(abs_diff, tolerance_vec);\n            if (_mm_movemask_pd(cmp) != 0x3) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    __m128d tolerance_vec = _mm_set1_pd(tolerance);\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        __m128d first_block = _mm_loadu_pd(&vec[i]);\n        for (size_t j = 1; j < num_blocks; j++) {\n            __m128d current_block = _mm_loadu_pd(&vec[j * block_size + i]);\n            __m128d diff = _mm_sub_pd(first_block, current_block);\n            __m128d abs_diff = _mm_and_pd(diff, _mm_set1_pd(-0.0)); // Get absolute difference\n            abs_diff = _mm_max_pd(abs_diff, _mm_sub_pd(current_block, first_block)); // Ensure absolute value\n            if (_mm_movemask_pd(_mm_cmpgt_pd(abs_diff, tolerance_vec)) != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n\n        __m128d cmp_result = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(cmp_result) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d cmp = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(cmp) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d cmp_result = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_cvtsi128_si32(_mm_castpd_si128(cmp_result)) || _mm_cvtsi128_si32(_mm_castpd_si128(_mm_unpackhi_pd(cmp_result, cmp_result)));\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, sum_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        sum_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d mat_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(mat_vec, mat_vec));\n        }\n        norm_vec = _mm_sqrt_pd(sum_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d cmp_result = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(cmp_result) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    __m128d threshold_vec, norm_vec;\n    for (size_t i = 0; i < rows; ++i) {\n        norm_vec = _mm_setzero_pd();\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            norm_vec = _mm_add_pd(norm_vec, _mm_mul_pd(row_vec, row_vec));\n        }\n        norm_vec = _mm_sqrt_pd(norm_vec);\n        threshold_vec = _mm_loadu_pd(&thresholds[i]);\n        __m128d cmp_result = _mm_cmp_pd(norm_vec, threshold_vec, _CMP_GT_OQ);\n        result[i] = _mm_movemask_pd(cmp_result) != 0;\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128(&pC[i], c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128(&pC[i], c);\n    }\n\n    for (i *= 4; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    __m128i* ptrA = (__m128i*)A;\n    __m128i* ptrB = (__m128i*)B;\n    __m128i* ptrC = (__m128i*)C;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i a = _mm_loadu_si128(&ptrA[i / 4]);\n        __m128i b = _mm_loadu_si128(&ptrB[i / 4]);\n        __m128i result = _mm_or_si128(a, b);\n        _mm_storeu_si128(&ptrC[i / 4], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128(&pC[i], c);\n    }\n\n    for (i *= 4; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128(&pC[i], c);\n    }\n\n    for (i *= 4; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        sum_squares = _mm_add_epi64(sum_squares, _mm_slli_epi32(_mm_maddubs_epi16(a, a), 16));\n        sum_products = _mm_add_epi64(sum_products, _mm_slli_epi32(_mm_maddubs_epi16(a, b), 16));\n    }\n\n    int64_t squares[2], products[2];\n    _mm_storeu_si128((__m128i*)squares, sum_squares);\n    _mm_storeu_si128((__m128i*)products, sum_products);\n\n    int64_t total_squares = squares[0] + squares[1];\n    int64_t total_products = products[0] + products[1];\n\n    for (; i < length; ++i) {\n        total_squares += A[i] * A[i];\n        total_products += A[i] * B[i];\n    }\n\n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        sum_squares = _mm_add_epi64(sum_squares, _mm_slli_epi32(a, 1)); // a^2\n        sum_squares = _mm_add_epi64(sum_squares, _mm_slli_epi32(b, 1)); // b^2\n        sum_products = _mm_add_epi64(sum_products, _mm_mullo_epi16(a, b)); // a*b\n    }\n\n    // Horizontal sum for sum_squares\n    sum_squares = _mm_hadd_epi64(sum_squares, sum_squares);\n    sum_squares = _mm_hadd_epi64(sum_squares, sum_squares);\n    \n    // Horizontal sum for sum_products\n    sum_products = _mm_hadd_epi64(sum_products, sum_products);\n    sum_products = _mm_hadd_epi64(sum_products, sum_products);\n\n    int64_t result_squares = _mm_cvtsi128_si64(sum_squares);\n    int64_t result_products = _mm_cvtsi128_si64(sum_products);\n\n    for (; i < length; i++) {\n        result_squares += A[i] * A[i] + B[i] * B[i];\n        result_products += A[i] * B[i];\n    }\n\n    return result_squares - result_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n\n    size_t i;\n    for (i = 0; i < length / 16; i++) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i * 16]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i * 16]);\n\n        sum_squares = _mm_add_epi64(sum_squares, _mm_slli_epi32(_mm_maddubs_epi16(a, a), 1));\n        sum_products = _mm_add_epi64(sum_products, _mm_slli_epi32(_mm_maddubs_epi16(a, b), 1));\n    }\n\n    int64_t squares[2], products[2];\n    _mm_storeu_si128((__m128i*)squares, sum_squares);\n    _mm_storeu_si128((__m128i*)products, sum_products);\n\n    int64_t total_squares = squares[0] + squares[1];\n    int64_t total_products = products[0] + products[1];\n\n    for (; i < length; i++) {\n        total_squares += A[i] * A[i];\n        total_products += A[i] * B[i];\n    }\n\n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_squared = _mm_mullo_epi16(a, a);\n        __m128i b_squared = _mm_mullo_epi16(b, b);\n        __m128i product = _mm_mullo_epi16(a, b);\n\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(a_squared, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(a_squared, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(b_squared, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(b_squared, _mm_setzero_si128()));\n\n        sum_products = _mm_add_epi32(sum_products, _mm_unpacklo_epi16(product, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpackhi_epi16(product, _mm_setzero_si128()));\n    }\n\n    int32_t squares[4], products[4];\n    _mm_storeu_si128((__m128i*)squares, sum_squares);\n    _mm_storeu_si128((__m128i*)products, sum_products);\n\n    int64_t total_squares = squares[0] + squares[1] + squares[2] + squares[3];\n    int64_t total_products = products[0] + products[1] + products[2] + products[3];\n\n    for (; i < length; i++) {\n        total_squares += A[i] * A[i] + B[i] * B[i];\n        total_products += A[i] * B[i];\n    }\n\n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i;\n    for (i = 0; i < length / 16; i++) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i * 16]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i * 16]);\n\n        __m128i a_squared = _mm_mullo_epi16(a, a);\n        __m128i b_squared = _mm_mullo_epi16(b, b);\n        __m128i product = _mm_mullo_epi16(a, b);\n\n        sum_squares = _mm_add_epi64(sum_squares, _mm_hadd_epi32(a_squared, b_squared));\n        sum_products = _mm_add_epi64(sum_products, _mm_hadd_epi32(product, product));\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        sum_squares = _mm_add_epi64(sum_squares, _mm_set1_epi64x(A[i] * A[i]));\n        sum_products = _mm_add_epi64(sum_products, _mm_set1_epi64x(A[i] * B[i]));\n    }\n\n    int64_t result_squares[2], result_products[2];\n    _mm_storeu_si128((__m128i*)result_squares, sum_squares);\n    _mm_storeu_si128((__m128i*)result_products, sum_products);\n\n    return (result_squares[0] + result_squares[1]) - (result_products[0] + result_products[1]);\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i neg_b = _mm_andnot_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, neg_b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i not_b = _mm_andnot_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i neg_b = _mm_andnot_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, neg_b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i neg_b = _mm_andnot_si128(b, _mm_set1_epi64x(-1)); // Bitwise negation\n        __m128i result = _mm_and_si128(a, neg_b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (i = 0; i < length / 2; i++) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i not_b = _mm_andnot_si128(b, _mm_set1_epi64x(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    __m128i zero = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi8(1);\n    __m128i minus_one = _mm_set1_epi8(-1);\n\n    for (; i <= length - 16; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_positive = _mm_cmpgt_epi8(a, zero);\n        __m128i b_positive = _mm_cmpgt_epi8(b, zero);\n        __m128i a_negative = _mm_cmpgt_epi8(zero, a);\n        __m128i b_negative = _mm_cmpgt_epi8(zero, b);\n\n        __m128i both_positive = _mm_and_si128(a_positive, b_positive);\n        __m128i both_negative = _mm_and_si128(a_negative, b_negative);\n\n        __m128i result = _mm_blendv_epi8(zero, one, both_positive);\n        result = _mm_blendv_epi8(result, minus_one, both_negative);\n\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    __m128i zero = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi8(1);\n    __m128i minus_one = _mm_set1_epi8(-1);\n\n    for (; i <= length - 16; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_positive = _mm_cmpgt_epi8(a, zero);\n        __m128i b_positive = _mm_cmpgt_epi8(b, zero);\n        __m128i a_negative = _mm_cmpgt_epi8(zero, a);\n        __m128i b_negative = _mm_cmpgt_epi8(zero, b);\n\n        __m128i both_positive = _mm_and_si128(a_positive, b_positive);\n        __m128i both_negative = _mm_and_si128(a_negative, b_negative);\n\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(both_positive, one),\n            _mm_and_si128(both_negative, minus_one)\n        );\n\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    __m128i pos_mask = _mm_set1_epi8(1);\n    __m128i neg_mask = _mm_set1_epi8(-1);\n    __m128i zero_mask = _mm_setzero_si128();\n\n    for (; i <= length - 16; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_pos = _mm_cmpgt_epi8(a_vec, zero_mask);\n        __m128i b_pos = _mm_cmpgt_epi8(b_vec, zero_mask);\n        __m128i a_neg = _mm_cmpgt_epi8(neg_mask, a_vec);\n        __m128i b_neg = _mm_cmpgt_epi8(neg_mask, b_vec);\n\n        __m128i pos_result = _mm_and_si128(a_pos, b_pos);\n        __m128i neg_result = _mm_and_si128(a_neg, b_neg);\n\n        __m128i result = _mm_or_si128(_mm_and_si128(pos_result, pos_mask), \n                                      _mm_and_si128(neg_result, neg_mask));\n\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    __m128i pos_mask = _mm_set1_epi8(1);\n    __m128i neg_mask = _mm_set1_epi8(-1);\n    __m128i zero_mask = _mm_setzero_si128();\n\n    for (; i <= length - 16; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_pos = _mm_cmpgt_epi8(a_vec, zero_mask);\n        __m128i b_pos = _mm_cmpgt_epi8(b_vec, zero_mask);\n        __m128i a_neg = _mm_cmpgt_epi8(neg_mask, a_vec);\n        __m128i b_neg = _mm_cmpgt_epi8(neg_mask, b_vec);\n\n        __m128i both_pos = _mm_and_si128(a_pos, b_pos);\n        __m128i both_neg = _mm_and_si128(a_neg, b_neg);\n\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(both_pos, pos_mask),\n            _mm_and_si128(both_neg, neg_mask)\n        );\n\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = (A[i] > 0 && B[i] > 0) ? 1 : (A[i] < 0 && B[i] < 0) ? -1 : 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    __m128i pos_mask = _mm_set1_epi8(1);\n    __m128i neg_mask = _mm_set1_epi8(-1);\n    __m128i zero_mask = _mm_setzero_si128();\n\n    for (; i <= length - 16; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n\n        __m128i a_pos = _mm_cmpgt_epi8(a, zero_mask);\n        __m128i b_pos = _mm_cmpgt_epi8(b, zero_mask);\n        __m128i a_neg = _mm_cmpgt_epi8(neg_mask, a);\n        __m128i b_neg = _mm_cmpgt_epi8(neg_mask, b);\n\n        __m128i pos_result = _mm_and_si128(a_pos, b_pos);\n        __m128i neg_result = _mm_and_si128(a_neg, b_neg);\n\n        __m128i result = _mm_or_si128(_mm_and_si128(pos_result, pos_mask), \n                                      _mm_and_si128(neg_result, neg_mask));\n\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (size_t i = 0; i < midpoint / 8; ++i) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    if (midpoint % 8 != 0) {\n        for (size_t i = midpoint / 8 * 8; i < midpoint; ++i) {\n            C[i] = A[i] ^ B[i];\n        }\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (size_t i = midpoint + 1; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0 && midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = midpoint + 1; i < length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (size_t i = 0; i < midpoint / 8; ++i) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    if (midpoint % 8 != 0) {\n        for (size_t i = midpoint / 8 * 8; i < midpoint; ++i) {\n            C[i] = A[i] ^ B[i];\n        }\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (size_t i = midpoint + 1; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    __m128i* pA = (__m128i*)A;\n    __m128i* pB = (__m128i*)B;\n    __m128i* pC = (__m128i*)C;\n\n    for (size_t i = 0; i < midpoint / 8; ++i) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n\n    for (size_t i = midpoint / 8; i < midpoint / 8 + 1; ++i) {\n        _mm_storeu_si128(&pC[i], _mm_loadu_si128(&pA[i]));\n    }\n\n    for (size_t i = midpoint / 8 + 1; i < length / 8; ++i) {\n        __m128i a = _mm_loadu_si128(&pA[i]);\n        __m128i b = _mm_loadu_si128(&pB[i]);\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128(&pC[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i cond1_vec = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_vec = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i cond1_true = _mm_cmpeq_epi32(cond1_vec, _mm_set1_epi32(1));\n        __m128i cond2_true = _mm_cmpeq_epi32(cond2_vec, _mm_set1_epi32(1));\n\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        __m128 B_vec = _mm_loadu_ps(&B[i]);\n        __m128 C_vec = _mm_loadu_ps(&C[i]);\n        __m128 D_vec = _mm_loadu_ps(&D[i]);\n\n        __m128 out_vec = _mm_blendv_ps(D_vec, C_vec, _mm_castsi128_ps(cond2_true)); // if cond2 is true, take C\n        out_vec = _mm_blendv_ps(out_vec, B_vec, _mm_castsi128_ps(cond1_true)); // if cond1 is true, take B\n        out_vec = _mm_blendv_ps(out_vec, A_vec, _mm_and_si128(cond1_true, cond2_true)); // if both are true, take A\n\n        _mm_storeu_ps(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i cond1_mask = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_mask = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i cond1_true = _mm_cmpeq_epi32(cond1_mask, _mm_set1_epi32(1));\n        __m128i cond2_true = _mm_cmpeq_epi32(cond2_mask, _mm_set1_epi32(1));\n\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        __m128 B_vec = _mm_loadu_ps(&B[i]);\n        __m128 C_vec = _mm_loadu_ps(&C[i]);\n        __m128 D_vec = _mm_loadu_ps(&D[i]);\n\n        __m128 out_vec = _mm_blendv_ps(D_vec, C_vec, _mm_castsi128_ps(cond2_true)); // D if cond2 is false\n        out_vec = _mm_blendv_ps(out_vec, B_vec, _mm_castsi128_ps(cond1_true)); // B if cond1 is true\n        out_vec = _mm_blendv_ps(out_vec, A_vec, _mm_and_si128(cond1_true, cond2_true)); // A if both are true\n\n        _mm_storeu_ps(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = cond1[i] ? (cond2[i] ? A[i] : B[i]) : (cond2[i] ? C[i] : D[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n\n        __m128i cond1_mask = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_mask = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i cond1_true = _mm_cmpeq_epi32(cond1_mask, _mm_set1_epi32(1));\n        __m128i cond2_true = _mm_cmpeq_epi32(cond2_mask, _mm_set1_epi32(1));\n\n        __m128i select_a = _mm_and_si128(cond1_true, cond2_true);\n        __m128i select_b = _mm_and_si128(cond1_true, _mm_xor_si128(cond2_true, _mm_set1_epi32(-1)));\n        __m128i select_c = _mm_and_si128(_mm_xor_si128(cond1_true, _mm_set1_epi32(-1)), cond2_true);\n        __m128i select_d = _mm_xor_si128(select_a, _mm_xor_si128(select_b, _mm_xor_si128(select_c, _mm_set1_epi32(-1))));\n\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(_mm_castsi128_ps(select_a), a),\n            _mm_or_ps(\n                _mm_and_ps(_mm_castsi128_ps(select_b), b),\n                _mm_or_ps(\n                    _mm_and_ps(_mm_castsi128_ps(select_c), c),\n                    _mm_and_ps(_mm_castsi128_ps(select_d), d)\n                )\n            )\n        );\n\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i cond1_mask = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_mask = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i cond1_true = _mm_cmpeq_epi32(cond1_mask, _mm_set1_epi32(1));\n        __m128i cond2_true = _mm_cmpeq_epi32(cond2_mask, _mm_set1_epi32(1));\n\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        __m128 B_vec = _mm_loadu_ps(&B[i]);\n        __m128 C_vec = _mm_loadu_ps(&C[i]);\n        __m128 D_vec = _mm_loadu_ps(&D[i]);\n\n        __m128 out_vec = _mm_blendv_ps(D_vec, C_vec, _mm_castsi128_ps(cond2_true));\n        out_vec = _mm_blendv_ps(out_vec, B_vec, _mm_castsi128_ps(cond1_true));\n        out_vec = _mm_blendv_ps(out_vec, A_vec, _mm_and_si128(cond1_true, cond2_true));\n\n        _mm_storeu_ps(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i cond1_mask = _mm_loadu_si128((__m128i*)&cond1[i]);\n        __m128i cond2_mask = _mm_loadu_si128((__m128i*)&cond2[i]);\n\n        __m128i cond1_true = _mm_cmpeq_epi32(cond1_mask, _mm_set1_epi32(1));\n        __m128i cond2_true = _mm_cmpeq_epi32(cond2_mask, _mm_set1_epi32(1));\n\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        __m128 B_vec = _mm_loadu_ps(&B[i]);\n        __m128 C_vec = _mm_loadu_ps(&C[i]);\n        __m128 D_vec = _mm_loadu_ps(&D[i]);\n\n        __m128 out_vec = _mm_blendv_ps(D_vec, C_vec, _mm_castsi128_ps(cond2_true));\n        out_vec = _mm_blendv_ps(out_vec, B_vec, _mm_castsi128_ps(cond1_true));\n        out_vec = _mm_blendv_ps(out_vec, A_vec, _mm_and_si128(cond1_true, cond2_true));\n\n        _mm_storeu_ps(&out[i], out_vec);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    __m128i mask = _mm_set1_epi32(0x1);\n    \n    for (i = 0; i < total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i count = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            __m128i bit = _mm_and_si128(data, mask);\n            count = _mm_add_epi32(count, bit);\n            data = _mm_srli_epi32(data, 1);\n        }\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_packus_epi32(count, count);\n        count = _mm_packus_epi16(count, count);\n\n        out[i] = _mm_extract_epi8(count, 0);\n        if (i + 1 < total_elements) out[i + 1] = _mm_extract_epi8(count, 1);\n        if (i + 2 < total_elements) out[i + 2] = _mm_extract_epi8(count, 2);\n        if (i + 3 < total_elements) out[i + 3] = _mm_extract_epi8(count, 3);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i count = _mm_setzero_si128();\n\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        uint32_t result = _mm_cvtsi128_si32(count);\n\n        out[i] = result;\n    }\n\n    for (; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    __m128i mask = _mm_set1_epi32(0x1);\n    __m128i count_mask = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (; i <= total_elements - 4; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i bits = _mm_setzero_si128();\n\n        for (int j = 0; j < 32; j++) {\n            __m128i shifted = _mm_srli_epi32(data, j);\n            __m128i bit_count = _mm_and_si128(shifted, mask);\n            bits = _mm_add_epi32(bits, bit_count);\n        }\n\n        bits = _mm_hadd_epi32(bits, bits);\n        bits = _mm_hadd_epi32(bits, bits);\n        uint32_t count[4];\n        _mm_storeu_si128((__m128i*)count, bits);\n        out[i] = count[0];\n        out[i + 1] = count[1];\n        out[i + 2] = count[2];\n        out[i + 3] = count[3];\n    }\n\n    for (; i < total_elements; i++) {\n        uint32_t val = A[i];\n        uint8_t bit_count = 0;\n        while (val) {\n            bit_count += val & 1;\n            val >>= 1;\n        }\n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i count = _mm_setzero_si128();\n\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        uint32_t result = _mm_cvtsi128_si32(count);\n\n        out[i] = result & 0xFF;\n        out[i + 1] = (result >> 8) & 0xFF;\n        out[i + 2] = (result >> 16) & 0xFF;\n        out[i + 3] = (result >> 24) & 0xFF;\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i count = _mm_setzero_si128();\n\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        data = _mm_srli_epi32(data, 1);\n        count = _mm_add_epi32(count, _mm_and_si128(data, _mm_set1_epi32(1)));\n        \n        // Horizontal sum of the counts\n        count = _mm_hadd_epi32(count, count);\n        count = _mm_hadd_epi32(count, count);\n        \n        uint32_t result = _mm_cvtsi128_si32(count);\n        out[i] = result;\n    }\n\n    for (; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        out[i] = (value & 1) + ((value >> 1) & 1) + ((value >> 2) & 1) + ((value >> 3) & 1) +\n                               ((value >> 4) & 1) + ((value >> 5) & 1) + ((value >> 6) & 1) +\n                               ((value >> 7) & 1) + ((value >> 8) & 1) + ((value >> 9) & 1) +\n                               ((value >> 10) & 1) + ((value >> 11) & 1) + ((value >> 12) & 1) +\n                               ((value >> 13) & 1) + ((value >> 14) & 1) + ((value >> 15) & 1) +\n                               ((value >> 16) & 1) + ((value >> 17) & 1) + ((value >> 18) & 1) +\n                               ((value >> 19) & 1) + ((value >> 20) & 1) + ((value >> 21) & 1) +\n                               ((value >> 22) & 1) + ((value >> 23) & 1) + ((value >> 24) & 1) +\n                               ((value >> 25) & 1) + ((value >> 26) & 1) + ((value >> 27) & 1) +\n                               ((value >> 28) & 1) + ((value >> 29) & 1) + ((value >> 30) & 1) +\n                               ((value >> 31) & 1);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i mod = _mm_rem_epi32(a, _mm_set1_epi32(3));\n        __m128i mask = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n        __m128i abs_a = _mm_abs_epi32(a);\n        __m128i result = _mm_blendv_epi8(a, abs_a, mask);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i mod = _mm_rem_epi32(a, _mm_set1_epi32(3));\n        __m128i mask = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n        __m128i abs_a = _mm_abs_epi32(a);\n        __m128i result = _mm_blendv_epi8(a, abs_a, mask);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i mod = _mm_rem_epi32(a, _mm_set1_epi32(3));\n        __m128i mask = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n        __m128i abs_a = _mm_abs_epi32(a);\n        __m128i result = _mm_blendv_epi8(a, abs_a, mask);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i mod = _mm_rem_epi32(a, _mm_set1_epi32(3));\n        __m128i mask = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n        __m128i abs_a = _mm_abs_epi32(a);\n        __m128i result = _mm_blendv_epi8(a, abs_a, mask);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n\n    for (; i <= total_elements - 4; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i mod = _mm_rem_epi32(a, three);\n        __m128i mask = _mm_cmpeq_epi32(mod, zero);\n        __m128i abs_a = _mm_abs_epi32(a);\n\n        __m128i result = _mm_blendv_epi8(a, abs_a, mask);\n        _mm_storeu_si128((__m128i*)&B[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    __m128i rotate_mask = _mm_set1_epi32((1 << 4) - 1);\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        __m128i all_ones = _mm_cmpeq_epi32(low_bits, rotate_mask);\n        \n        __m128i rotated = _mm_or_si128(\n            _mm_srli_epi32(src_vec, rotate_amount),\n            _mm_slli_epi32(src_vec, 32 - rotate_bits)\n        );\n        \n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(all_ones, rotated),\n            _mm_andnot_si128(all_ones, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    __m128i rotate_mask = _mm_set1_epi32((1 << 4) - 1); // Mask for low 4 bits\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    __m128i rotate_mask_low = _mm_set1_epi32((1 << rotate_bits) - 1);\n    __m128i rotate_mask_high = _mm_set1_epi32(~((1 << rotate_bits) - 1));\n\n    for (size_t i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i low4_bits = _mm_and_si128(src_vec, rotate_mask);\n        \n        __m128i condition = _mm_cmpeq_epi32(low4_bits, rotate_mask);\n        \n        // Rotate src_vec\n        __m128i rotated = _mm_or_si128(\n            _mm_srl_epi32(src_vec, rotate_amount),\n            _mm_and_si128(_mm_sll_epi32(src_vec, _mm_sub_epi32(_mm_set1_epi32(32), rotate_amount)), rotate_mask_low)\n        );\n\n        // Negate src_vec\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n\n        // Select between rotated and negated based on condition\n        __m128i result = _mm_or_si128(_mm_and_si128(condition, rotated), _mm_andnot_si128(condition, negated));\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    __m128i rotate_mask = _mm_set1_epi32((1 << 4) - 1);\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    __m128i all_ones = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i low4_bits = _mm_and_si128(src_vec, rotate_mask);\n        \n        __m128i condition = _mm_cmpeq_epi32(low4_bits, rotate_mask);\n        \n        __m128i rotated = _mm_or_si128(\n            _mm_srl_epi32(src_vec, rotate_amount),\n            _mm_sll_epi32(src_vec, _mm_sub_epi32(_mm_set1_epi32(32), rotate_amount))\n        );\n        \n        __m128i negated = _mm_xor_si128(src_vec, all_ones);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(condition, rotated),\n            _mm_andnot_si128(condition, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    __m128i rotate_mask = _mm_set1_epi32((1 << 4) - 1); // Mask for low 4 bits\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    __m128i all_ones = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i low_bits = _mm_and_si128(src_vec, rotate_mask);\n        \n        // Check if low 4 bits are all 1\n        __m128i condition = _mm_cmpeq_epi32(low_bits, rotate_mask);\n        \n        // Perform rotation\n        __m128i rotated = _mm_or_si128(\n            _mm_srl_epi32(src_vec, rotate_amount), \n            _mm_sll_epi32(src_vec, _mm_sub_epi32(_mm_set1_epi32(32), rotate_amount))\n        );\n        \n        // Negate src_vec\n        __m128i negated = _mm_xor_si128(src_vec, all_ones);\n        \n        // Select based on condition\n        __m128i result = _mm_blendv_epi8(negated, rotated, condition);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    __m128i rotate_mask = _mm_set1_epi32((1 << 4) - 1);\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    __m128i all_ones = _mm_set1_epi32(0xFFFFFFFF);\n    \n    for (size_t i = 0; i < length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i low4_bits = _mm_and_si128(src_vec, rotate_mask);\n        \n        __m128i condition = _mm_cmpeq_epi32(low4_bits, rotate_mask);\n        \n        __m128i rotated = _mm_or_si128(\n            _mm_srli_epi32(src_vec, rotate_amount),\n            _mm_slli_epi32(src_vec, 32 - rotate_amount)\n        );\n        \n        __m128i negated = _mm_xor_si128(src_vec, all_ones);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(condition, rotated),\n            _mm_andnot_si128(condition, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec); // abs(diff)\n        \n        __m128 greater_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128i result_vec = _mm_setzero_si128();\n        \n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(greater_vec), _mm_set1_epi8(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(less_vec), _mm_set1_epi8(-1)));\n        \n        __m128i zero_vec = _mm_set1_epi8(0);\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_cmple_ps(abs_diff_vec, epsilon_vec), zero_vec));\n        \n        _mm_storeu_si128((__m128i*)&out[i], result_vec);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n        __m128 greater_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n\n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_blendv_epi8(result_vec, _mm_set1_epi8(1), _mm_castps_si128(greater_vec));\n        result_vec = _mm_blendv_epi8(result_vec, _mm_set1_epi8(-1), _mm_castps_si128(less_vec));\n        result_vec = _mm_blendv_epi8(result_vec, _mm_set1_epi8(0), _mm_castps_si128(_mm_cmple_ps(abs_diff_vec, epsilon_vec)));\n\n        _mm_storeu_si128((__m128i*)&out[i], result_vec);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i;\n\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec); // abs(diff)\n        \n        __m128 greater_than_epsilon = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_than_neg_epsilon = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128i result = _mm_setzero_si128();\n        result = _mm_blendv_epi8(result, _mm_set1_epi8(1), _mm_castps_si128(greater_than_epsilon));\n        result = _mm_blendv_epi8(result, _mm_set1_epi8(-1), _mm_castps_si128(less_than_neg_epsilon));\n        \n        __m128i zero_mask = _mm_and_si128(_mm_cmple_ps(abs_diff_vec, epsilon_vec), _mm_set1_epi32(1));\n        result = _mm_blendv_epi8(result, _mm_set1_epi8(0), zero_mask);\n        \n        _mm_storeu_si128((__m128i*)&out[i], result);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec); // abs(diff)\n        \n        __m128 greater_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128 result_vec = _mm_setzero_ps();\n        result_vec = _mm_blendv_ps(result_vec, _mm_set1_ps(1.0f), greater_vec);\n        result_vec = _mm_blendv_ps(result_vec, _mm_set1_ps(-1.0f), less_vec);\n        \n        __m128 zero_vec = _mm_set1_ps(0.0f);\n        __m128 mask_zero = _mm_andnot_ps(_mm_or_ps(greater_vec, less_vec), _mm_cmple_ps(abs_diff_vec, epsilon_vec));\n        result_vec = _mm_blendv_ps(result_vec, zero_vec, mask_zero);\n        \n        _mm_storeu_si128((__m128i*)&out[i], _mm_cvtps_epi32(result_vec));\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(fabsf(epsilon));\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n        __m128 greater_vec = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 less_vec = _mm_cmplt_ps(diff_vec, _mm_neg_ps(epsilon_vec));\n        \n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(greater_vec), _mm_set1_epi8(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(less_vec), _mm_set1_epi8(-1)));\n        \n        __m128i zero_vec = _mm_set1_epi8(0);\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_cmple_ps(abs_diff_vec, epsilon_vec), zero_vec));\n        \n        _mm_storeu_si128((__m128i*)&out[i], result_vec);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    __m128i max_val = _mm_set1_epi32(INT32_MAX);\n    __m128i min_val = _mm_set1_epi32(INT32_MIN);\n    \n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 float_vals = _mm_loadu_ps(&A[i]);\n        __m128i int_vals = _mm_cvtps_epi32(float_vals);\n        \n        // Compare with max_val\n        __m128i mask_max = _mm_cmpgt_epi32(int_vals, max_val);\n        int_vals = _mm_blendv_epi8(int_vals, max_val, mask_max);\n        \n        // Compare with min_val\n        __m128i mask_min = _mm_cmpgt_epi32(min_val, int_vals);\n        int_vals = _mm_blendv_epi8(int_vals, min_val, mask_min);\n        \n        _mm_storeu_si128((__m128i*)&B[i], int_vals);\n    }\n    \n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    __m128i max_val = _mm_set1_epi32(INT32_MAX);\n    __m128i min_val = _mm_set1_epi32(INT32_MIN);\n    \n    size_t i;\n    for (i = 0; i < size / 4; i++) {\n        __m128 float_vals = _mm_loadu_ps(&A[i * 4]);\n        __m128i int_vals = _mm_cvtps_epi32(float_vals);\n        \n        // Compare against max and min values\n        __m128i mask_max = _mm_cmpgt_epi32(int_vals, max_val);\n        __m128i mask_min = _mm_cmpgt_epi32(min_val, int_vals);\n        \n        // Set saturated values\n        int_vals = _mm_blendv_epi8(int_vals, max_val, mask_max);\n        int_vals = _mm_blendv_epi8(int_vals, min_val, mask_min);\n        \n        _mm_storeu_si128((__m128i*)&B[i * 4], int_vals);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    __m128i max_val = _mm_set1_epi32(INT32_MAX);\n    __m128i min_val = _mm_set1_epi32(INT32_MIN);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 float_vals = _mm_loadu_ps(&A[i]);\n        __m128i int_vals = _mm_cvtps_epi32(float_vals);\n        \n        // Compare against max and min\n        __m128i mask_max = _mm_cmpgt_epi32(int_vals, max_val);\n        __m128i mask_min = _mm_cmpgt_epi32(min_val, int_vals);\n        \n        // Set values to INT32_MAX or INT32_MIN where needed\n        int_vals = _mm_blendv_epi8(int_vals, max_val, mask_max);\n        int_vals = _mm_blendv_epi8(int_vals, min_val, mask_min);\n        \n        _mm_storeu_si128((__m128i*)&B[i], int_vals);\n    }\n    \n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    __m128i max_val = _mm_set1_epi32(INT32_MAX);\n    __m128i min_val = _mm_set1_epi32(INT32_MIN);\n    \n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 float_vals = _mm_loadu_ps(&A[i]);\n        __m128i int_vals = _mm_cvtps_epi32(float_vals);\n        \n        // Compare against max and min\n        __m128i mask_max = _mm_cmpgt_epi32(int_vals, max_val);\n        __m128i mask_min = _mm_cmpgt_epi32(min_val, int_vals);\n        \n        // Set values to INT32_MAX or INT32_MIN where necessary\n        int_vals = _mm_blendv_epi8(int_vals, max_val, _mm_cvtepi32_epi64(mask_max));\n        int_vals = _mm_blendv_epi8(int_vals, min_val, _mm_cvtepi32_epi64(mask_min));\n        \n        _mm_storeu_si128((__m128i*)&B[i], int_vals);\n    }\n    \n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    __m128i max_val = _mm_set1_epi32(INT32_MAX);\n    __m128i min_val = _mm_set1_epi32(INT32_MIN);\n    \n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 float_vals = _mm_loadu_ps(&A[i]);\n        __m128i int_vals = _mm_cvtps_epi32(float_vals);\n\n        // Compare with max and min\n        __m128i mask_max = _mm_cmpgt_epi32(int_vals, max_val);\n        __m128i mask_min = _mm_cmpgt_epi32(min_val, int_vals);\n\n        // Set saturated values\n        int_vals = _mm_blendv_epi8(int_vals, max_val, mask_max);\n        int_vals = _mm_blendv_epi8(int_vals, min_val, mask_min);\n\n        _mm_storeu_si128((__m128i*)&B[i], int_vals);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(a_vec, scale_vec);\n        __m128 f_vec = _mm_cvtepi32_ps(scaled_vec);\n        _mm_storeu_ps(&B[i], f_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = static_cast<float>(A[i]) * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(a_vec, scale_vec);\n        __m128 f_vec = _mm_cvtepi32_ps(scaled_vec);\n        _mm_storeu_ps(&B[i], f_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i]) * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(a_vec, scale_vec);\n        __m128 f_vec = _mm_cvtepi32_ps(scaled_vec);\n        _mm_storeu_ps(&B[i], f_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(a_vec, scale_vec);\n        __m128 f_vec = _mm_cvtepi32_ps(scaled_vec);\n        _mm_storeu_ps(&B[i], f_vec);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = static_cast<float>(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n\n    for (i = 0; i < size / 4 * 4; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i scaled_vec = _mm_mullo_epi32(a_vec, scale_vec);\n        __m128 f_vec = _mm_cvtepi32_ps(scaled_vec);\n        _mm_storeu_ps(&B[i], f_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = static_cast<float>(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    __m128 a, b, result;\n\n    for (i = 0; i < size; i += 4) {\n        a = _mm_loadu_ps(&A[i]);\n        b = _mm_loadu_ps(&B[i]);\n        result = _mm_div_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_si128((__m128i*)&C[i], _mm_cvtps_epi32(result));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    __m128 a, b, result;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        a = _mm_loadu_ps(&A[i]);\n        b = _mm_loadu_ps(&B[i]);\n        result = _mm_div_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_si128((__m128i*)&C[i], _mm_cvtps_epi32(result));\n    }\n\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(roundf(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    __m128 a, b, result;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        a = _mm_loadu_ps(&A[i]);\n        b = _mm_loadu_ps(&B[i]);\n        result = _mm_div_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_si128((__m128i*)&C[i], _mm_cvtps_epi32(result));\n    }\n\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(roundf(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    __m128 a, b, result;\n\n    for (; i + 4 <= size; i += 4) {\n        a = _mm_loadu_ps(&A[i]);\n        b = _mm_loadu_ps(&B[i]);\n        result = _mm_div_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_si128((__m128i*)&C[i], _mm_cvtps_epi32(result));\n    }\n\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(roundf(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    __m128 a, b, result;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        a = _mm_loadu_ps(&A[i]);\n        b = _mm_loadu_ps(&B[i]);\n        result = _mm_div_ps(a, b);\n        result = _mm_round_ps(result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_storeu_si128((__m128i*)&C[i], _mm_cvtps_epi32(result));\n    }\n\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(round(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val = _mm_set1_pd(FLT_MAX);\n    __m128d min_val = _mm_set1_pd(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128d a1 = _mm_loadu_pd(&A[i]);\n        __m128d a2 = _mm_loadu_pd(&A[i + 2]);\n\n        __m128d saturated_a1 = _mm_min_pd(_mm_max_pd(a1, min_val), max_val);\n        __m128d saturated_a2 = _mm_min_pd(_mm_max_pd(a2, min_val), max_val);\n\n        _mm_storeu_ps(&B[i], _mm_cvtpd_ps(saturated_a1));\n        _mm_storeu_ps(&B[i + 2], _mm_cvtpd_ps(saturated_a2));\n    }\n    \n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val = _mm_set1_pd(FLT_MAX);\n    __m128d min_val = _mm_set1_pd(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        __m128d a1 = _mm_loadu_pd(&A[i]);\n        __m128d a2 = _mm_loadu_pd(&A[i + 2]);\n\n        __m128d saturated_a1 = _mm_min_pd(_mm_max_pd(a1, min_val), max_val);\n        __m128d saturated_a2 = _mm_min_pd(_mm_max_pd(a2, min_val), max_val);\n\n        _mm_storeu_ps(&B[i], _mm_cvtpd_ps(saturated_a1));\n        _mm_storeu_ps(&B[i + 2], _mm_cvtpd_ps(saturated_a2));\n    }\n    \n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(value);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val = _mm_set1_pd((double)FLT_MAX);\n    __m128d min_val = _mm_set1_pd((double)-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        __m128d data = _mm_loadu_pd(&A[i]);\n        __m128d saturated = _mm_min_pd(_mm_max_pd(data, min_val), max_val);\n        __m128  result = _mm_cvtpd_ps(saturated);\n        _mm_storeu_ps(&B[i], result);\n    }\n    \n    for (; i < size; i++) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val = _mm_set1_pd((double)FLT_MAX);\n    __m128d min_val = _mm_set1_pd((double)-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        __m128d a_vals = _mm_loadu_pd(&A[i]);\n        __m128d a_clamped = _mm_max_pd(a_vals, min_val);\n        a_clamped = _mm_min_pd(a_clamped, max_val);\n        __m128 a_floats = _mm_cvtpd_ps(a_clamped);\n        _mm_storeu_ps(&B[i], a_floats);\n    }\n    \n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    __m128d max_val = _mm_set1_pd(FLT_MAX);\n    __m128d min_val = _mm_set1_pd(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128d a1 = _mm_loadu_pd(&A[i]);         // Load 4 double values\n        __m128d a2 = _mm_loadu_pd(&A[i + 2]);\n\n        // Compare and saturate\n        __m128d saturated1 = _mm_min_pd(_mm_max_pd(a1, min_val), max_val);\n        __m128d saturated2 = _mm_min_pd(_mm_max_pd(a2, min_val), max_val);\n\n        // Convert to float\n        __m128 a1_f = _mm_cvtpd_ps(saturated1);\n        __m128 a2_f = _mm_cvtpd_ps(saturated2);\n\n        // Store the results\n        _mm_storeu_ps(&B[i], a1_f);\n        _mm_storeu_ps(&B[i + 4], a2_f);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(value);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i]);\n        __m128i data2 = _mm_loadu_si128(&src[i + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 2], result1);\n        _mm_storeu_si128(&dst[i * 2 + 1], result2);\n        _mm_storeu_si128(&dst[i * 2 + 2], result3);\n        _mm_storeu_si128(&dst[i * 2 + 3], result4);\n    }\n\n    for (; i < size / 2; i++) {\n        B[i] = (int32_t)A[i * 2];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i * 2]);\n        __m128i data2 = _mm_loadu_si128(&src[i * 2 + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 4], result1);\n        _mm_storeu_si128(&dst[i * 4 + 1], result2);\n        _mm_storeu_si128(&dst[i * 4 + 2], result3);\n        _mm_storeu_si128(&dst[i * 4 + 3], result4);\n    }\n\n    for (; i * 8 < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n    size_t simd_size = size / 8; // Each __m128i processes 8 int16_t\n\n    for (i = 0; i < simd_size; ++i) {\n        __m128i data = _mm_loadu_si128(&src[i]);\n        __m128i low = _mm_unpacklo_epi16(data, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi16(data, _mm_setzero_si128());\n        _mm_storeu_si128(&dst[i * 2], low);\n        _mm_storeu_si128(&dst[i * 2 + 1], high);\n    }\n\n    // Handle remaining elements\n    for (i *= 8; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i * 2]);\n        __m128i data2 = _mm_loadu_si128(&src[i * 2 + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 4], result1);\n        _mm_storeu_si128(&dst[i * 4 + 1], result2);\n        _mm_storeu_si128(&dst[i * 4 + 2], result3);\n        _mm_storeu_si128(&dst[i * 4 + 3], result4);\n    }\n\n    for (; i < size / 2; i++) {\n        B[i] = (int32_t)A[i * 2];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128i* dst = (__m128i*)B;\n\n    for (i = 0; i < size / 8; i++) {\n        __m128i data1 = _mm_loadu_si128(&src[i * 2]);\n        __m128i data2 = _mm_loadu_si128(&src[i * 2 + 1]);\n\n        __m128i result1 = _mm_unpacklo_epi16(data1, _mm_setzero_si128());\n        __m128i result2 = _mm_unpacklo_epi16(data2, _mm_setzero_si128());\n        __m128i result3 = _mm_unpackhi_epi16(data1, _mm_setzero_si128());\n        __m128i result4 = _mm_unpackhi_epi16(data2, _mm_setzero_si128());\n\n        _mm_storeu_si128(&dst[i * 4], result1);\n        _mm_storeu_si128(&dst[i * 4 + 1], result2);\n        _mm_storeu_si128(&dst[i * 4 + 2], result3);\n        _mm_storeu_si128(&dst[i * 4 + 3], result4);\n    }\n\n    for (; i * 8 < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_val_vec = _mm_set1_ps(min_val);\n    __m128 max_val_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128i control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        \n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        \n        __m128 normalized = _mm_sub_ps(A_vec, min_val_vec);\n        normalized = _mm_div_ps(normalized, range_vec);\n        normalized = _mm_max_ps(normalized, _mm_setzero_ps());\n        normalized = _mm_min_ps(normalized, _mm_set1_ps(1.0f));\n        \n        __m128 result = _mm_or_ps(_mm_and_ps(_mm_castsi128_ps(mask), normalized), _mm_andnot_ps(mask, A_vec));\n        \n        _mm_storeu_ps(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_val_vec = _mm_set1_ps(min_val);\n    __m128 max_val_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n\n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n\n        __m128 normalized = _mm_div_ps(_mm_sub_ps(a_vec, min_val_vec), range_vec);\n        normalized = _mm_max_ps(normalized, _mm_setzero_ps());\n        normalized = _mm_min_ps(normalized, _mm_set1_ps(1.0f));\n\n        __m128 result = _mm_or_ps(_mm_and_ps(_mm_castsi128_ps(mask), normalized), _mm_andnot_ps(mask, a_vec));\n        _mm_storeu_ps(&B[i], result);\n    }\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized_val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized_val < 0.0f ? 0.0f : (normalized_val > 1.0f ? 1.0f : normalized_val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_val_vec = _mm_set1_ps(min_val);\n    __m128 max_val_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n        \n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        \n        __m128 normalized = _mm_sub_ps(a_vec, min_val_vec);\n        normalized = _mm_div_ps(normalized, range_vec);\n        normalized = _mm_max_ps(normalized, _mm_setzero_ps());\n        normalized = _mm_min_ps(normalized, _mm_set1_ps(1.0f));\n        \n        __m128 result = _mm_blendv_ps(a_vec, normalized, _mm_castsi128_ps(mask));\n        \n        _mm_storeu_ps(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_val_vec = _mm_set1_ps(min_val);\n    __m128 max_val_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n\n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        \n        __m128 normalized = _mm_div_ps(_mm_sub_ps(a_vec, min_val_vec), range_vec);\n        normalized = _mm_max_ps(normalized, _mm_setzero_ps());\n        normalized = _mm_min_ps(normalized, _mm_set1_ps(1.0f));\n\n        __m128 result = _mm_or_ps(_mm_and_ps(_mm_castsi128_ps(mask), normalized), _mm_andnot_ps(mask, a_vec));\n        \n        _mm_storeu_ps(&B[i], result);\n    }\n    \n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized_val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized_val < 0.0f ? 0.0f : (normalized_val > 1.0f ? 1.0f : normalized_val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_val_vec = _mm_set1_ps(min_val);\n    __m128 max_val_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_val_vec, min_val_vec);\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128i control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 A_vec = _mm_loadu_ps(&A[i]);\n        \n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        __m128 normalized_val = _mm_setzero_ps();\n        \n        if (i + 4 <= size) {\n            // Normalization\n            __m128 subtracted = _mm_sub_ps(A_vec, min_val_vec);\n            normalized_val = _mm_div_ps(subtracted, range_vec);\n            normalized_val = _mm_max_ps(normalized_val, _mm_setzero_ps());\n            normalized_val = _mm_min_ps(normalized_val, _mm_set1_ps(1.0f));\n        } else {\n            // Copying for remaining elements\n            normalized_val = A_vec;\n        }\n        \n        // Blend based on control\n        __m128 result = _mm_blendv_ps(normalized_val, A_vec, _mm_castsi128_ps(mask));\n        _mm_storeu_ps(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i high_bits = _mm_srli_epi32(a, 16);\n        __m128  float_values = _mm_cvtepi32_ps(high_bits);\n        __m128 sqrt_values = _mm_sqrt_ps(float_values);\n        _mm_storeu_ps(&B[i], sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i high_bits = _mm_srli_epi32(data, 16);\n        __m128  float_values = _mm_cvtepi32_ps(high_bits);\n        __m128 sqrt_values = _mm_sqrt_ps(float_values);\n        _mm_storeu_ps(&B[i], sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i high_bits = _mm_srli_epi32(a, 16);\n        __m128  float_values = _mm_cvtepi32_ps(high_bits);\n        __m128 sqrt_values = _mm_sqrt_ps(float_values);\n        _mm_storeu_ps(&B[i], sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128* dst = (__m128*)B;\n\n    for (i = 0; i < size / 4; i++) {\n        __m128i data = _mm_load_si128(&src[i]);\n        __m128i high_bits = _mm_srli_epi32(data, 16);\n        __m128 float_data = _mm_cvtepi32_ps(high_bits);\n        __m128 sqrt_data = _mm_sqrt_ps(float_data);\n        _mm_store_ps((float*)&dst[i], sqrt_data);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128* dst = (__m128*)B;\n\n    for (i = 0; i < size / 4; i++) {\n        __m128i data = _mm_load_si128(&src[i]);\n        __m128i high_bits = _mm_srli_epi32(data, 16);\n        __m128 float_values = _mm_cvtepi32_ps(high_bits);\n        __m128 sqrt_values = _mm_sqrt_ps(float_values);\n        _mm_store_ps((float*)&dst[i], sqrt_values);\n    }\n\n    for (; i < size; i++) {\n        B[i] = sqrtf((A[i] >> 16) & 0xFFFF);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    __m128i* src = (__m128i*)A;\n    __m128* dst = (__m128*)B;\n\n    for (i = 0; i < size / 4; i++) {\n        __m128i data = _mm_loadu_si128(&src[i]);\n        _mm_storeu_ps((float*)&dst[i], _mm_castsi128_ps(data));\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    __m128i* pA = (__m128i*)A;\n    __m128* pB = (__m128*)B;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i data = _mm_loadu_si128(&pA[i / 4]);\n        _mm_storeu_ps((float*)&data, _mm_castsi128_ps(data));\n        _mm_storeu_ps(&pB[i / 4], _mm_castsi128_ps(data));\n    }\n\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    __m128i* src = (__m128i*)A;\n    __m128* dest = (__m128*)B;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i data = _mm_loadu_si128(&src[i / 4]);\n        _mm_storeu_ps(&dest[i / 4], _mm_castsi128_ps(data));\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    __m128i* src = (__m128i*)A;\n    __m128* dst = (__m128*)B;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i data = _mm_loadu_si128(&src[i / 4]);\n        _mm_storeu_ps((float*)&dst[i / 4], _mm_castsi128_ps(data));\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    __m128i* src = (__m128i*)A;\n    __m128* dst = (__m128*)B;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i data = _mm_loadu_si128(&src[i / 4]);\n        _mm_storeu_ps(&dst[i / 4], _mm_castsi128_ps(data));\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    __m128i zero = _mm_setzero_si128();\n    __m128 zero_f = _mm_setzero_ps();\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i - 1]);\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n        \n        __m128i cond_mask = _mm_loadu_si128((__m128i*)&cond[i]);\n        __m128i mask = _mm_cmpgt_epi32(cond_mask, zero);\n        \n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n        __m128 result = _mm_and_ps(zero_f, _mm_cvtepi32_ps(mask));\n        result = _mm_or_ps(result, _mm_and_ps(diff_float, _mm_castsi128_ps(mask)));\n\n        _mm_storeu_ps(&diff[i], result);\n    }\n\n    for (size_t i = 1; i < size; i++) {\n        if (!cond[i]) {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    __m128i zero = _mm_setzero_si128();\n    __m128 zero_f = _mm_setzero_ps();\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i - 1]);\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n\n        __m128i cond_mask = _mm_loadu_si128((__m128i*)&cond[i]);\n        __m128i mask = _mm_cmpeq_epi32(cond_mask, zero);\n\n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n        diff_float = _mm_andnot_ps(_mm_castsi128_ps(mask), zero_f);\n        diff_float = _mm_or_ps(diff_float, _mm_and_ps(_mm_castsi128_ps(cond_mask), diff_float));\n\n        _mm_storeu_ps(&diff[i], diff_float);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    __m128i zero = _mm_setzero_si128();\n    __m128 zero_f = _mm_setzero_ps();\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i - 1]);\n        __m128i condition = _mm_loadu_si128((__m128i*)&cond[i]);\n\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n        __m128 mask = _mm_castsi128_ps(_mm_cmpeq_epi32(condition, zero));\n\n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n        __m128 result = _mm_and_ps(diff_float, mask);\n        result = _mm_or_ps(result, _mm_andnot_ps(mask, zero_f));\n\n        _mm_storeu_ps(&diff[i], result);\n    }\n\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        diff[i] = cond[i] ? static_cast<float>(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    __m128i zero = _mm_setzero_si128();\n    __m128 zero_f = _mm_setzero_ps();\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i - 1]);\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n        \n        __m128i cond_mask = _mm_loadu_si128((__m128i*)&cond[i]);\n        __m128i mask = _mm_cmpgt_epi32(cond_mask, zero);\n        \n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n        diff_float = _mm_and_ps(diff_float, _mm_castsi128_ps(mask));\n        __m128 zero_mask = _mm_andnot_ps(_mm_castsi128_ps(mask), zero_f);\n        diff_float = _mm_add_ps(diff_float, zero_mask);\n        \n        _mm_storeu_ps(&diff[i], diff_float);\n    }\n\n    for (size_t i = 1; i < size; i++) {\n        if (!cond[i]) {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    __m128i zero = _mm_setzero_si128();\n    __m128 zero_f = _mm_setzero_ps();\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i - 1]);\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n\n        __m128i cond_mask = _mm_loadu_si128((__m128i*)&cond[i]);\n        __m128i mask = _mm_cmpgt_epi32(cond_mask, zero);\n\n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n        __m128 result = _mm_and_ps(zero_f, _mm_cvtepi32_ps(mask));\n        result = _mm_or_ps(result, _mm_and_ps(diff_float, _mm_castsi128_ps(mask)));\n\n        _mm_storeu_ps(&diff[i], result);\n    }\n\n    for (size_t i = 1; i < size; i += 4) {\n        if (i + 3 >= size) {\n            for (size_t j = i; j < size; ++j) {\n                diff[j] = (cond[j]) ? (A[j] - A[j - 1]) : 0.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i src_data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi32(0xFFFFFFFF);\n        __m128i low_bits = _mm_unpacklo_epi32(src_data, _mm_setzero_si128());\n        __m128i high_low_bits = _mm_unpacklo_epi64(low_bits, high_bits);\n        _mm_storeu_si128(&dst_ptr[i], high_low_bits);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] & 0xFFFFFFFF) | ((uint64_t)0xFFFFFFFF << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi32(0xFFFFFFFF);\n        __m128i result = _mm_unpacklo_epi32(data, high_bits);\n        _mm_storeu_si128(&dst_ptr[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | ((uint64_t)0xFFFFFFFF << 32));\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi32(0xFFFFFFFF); // Set high 32 bits to 1\n\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vals = _mm_loadu_si128((__m128i*)&src[i]); // Load 4 uint32_t values\n        __m128i high_bits = _mm_or_si128(_mm_slli_epi64(src_vals, 32), mask); // Shift left and set high bits\n        _mm_storeu_si128((__m128i*)&dst[i], high_bits); // Store the result\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] << 32) | 0xFFFFFFFF; // Set high bits to 1\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi32(0xFFFFFFFF);\n        __m128i result = _mm_unpacklo_epi32(data, high_bits);\n        _mm_storeu_si128(&dst_ptr[i], _mm_unpacklo_epi64(result, result));\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | ((uint64_t)0xFFFFFFFF << 32));\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i* src_ptr = (__m128i*)src;\n    __m128i* dst_ptr = (__m128i*)dst;\n\n    for (i = 0; i < length / 4; i++) {\n        __m128i data = _mm_loadu_si128(&src_ptr[i]);\n        __m128i high_bits = _mm_set1_epi64x(0xFFFFFFFF00000000);\n        __m128i low_bits = _mm_unpacklo_epi32(data, _mm_setzero_si128());\n        __m128i high_low_bits = _mm_unpackhi_epi32(data, _mm_setzero_si128());\n        \n        __m128i result_low = _mm_or_si128(low_bits, high_bits);\n        __m128i result_high = _mm_or_si128(high_low_bits, high_bits);\n        \n        _mm_storeu_si128(&dst_ptr[i * 2], result_low);\n        _mm_storeu_si128(&dst_ptr[i * 2 + 1], result_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d v0 = _mm_cvtepi32_pd(_mm_unpacklo_epi16(idx, _mm_setzero_si128()));\n        __m128d v1 = _mm_cvtepi32_pd(_mm_unpackhi_epi16(idx, _mm_setzero_si128()));\n        \n        __m128d val0 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v0)]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v1)]);\n        \n        sum = _mm_add_pd(sum, val0);\n        sum = _mm_add_pd(sum, val1);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d v0 = _mm_cvtepi32_pd(_mm_unpacklo_epi16(idx, _mm_setzero_si128()));\n        __m128d v1 = _mm_cvtepi32_pd(_mm_unpackhi_epi16(idx, _mm_setzero_si128()));\n        \n        __m128d val0 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v0)]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v1)]);\n        \n        sum = _mm_add_pd(sum, val0);\n        sum = _mm_add_pd(sum, val1);\n    }\n\n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_extract_epi16(idx, 0)]);\n        __m128d val2 = _mm_loadu_pd(&vec[_mm_extract_epi16(idx, 1)]);\n        sum = _mm_add_pd(sum, val1);\n        sum = _mm_add_pd(sum, val2);\n    }\n\n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(idx)]);\n        __m128d val2 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(_mm_srli_si128(idx, 2))]);\n        sum = _mm_add_pd(sum, val1);\n        sum = _mm_add_pd(sum, val2);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    \n    for (size_t i = 0; i < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)&index[i]);\n        __m128d v0 = _mm_cvtepi32_pd(_mm_unpacklo_epi16(idx, _mm_setzero_si128()));\n        __m128d v1 = _mm_cvtepi32_pd(_mm_unpackhi_epi16(idx, _mm_setzero_si128()));\n        \n        __m128d val0 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v0)]);\n        __m128d val1 = _mm_loadu_pd(&vec[_mm_cvtsi128_si32(v1)]);\n        \n        sum = _mm_add_pd(sum, val0);\n        sum = _mm_add_pd(sum, val1);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    return result[0] + result[1];\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d k[4];\n\n    for (size_t i = 0; i < kernel_size; ++i) {\n        for (size_t j = 0; j < kernel_size; ++j) {\n            k[i * kernel_size + j] = _mm_set1_pd(kernel[i * kernel_size + j]);\n        }\n    }\n\n    for (size_t y = 0; y < output_size; ++y) {\n        for (size_t x = 0; x < output_size; ++x) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t i = 0; i < kernel_size; ++i) {\n                for (size_t j = 0; j < kernel_size; j += 2) {\n                    __m128d input_vals = _mm_loadu_pd(&input[(y + i) * input_size + (x + j)]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(input_vals, k[i * kernel_size + j]));\n                }\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            output[y * output_size + x] = fmax(result[0], 0.0) + fmax(result[1], 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d k[4];\n\n    for (size_t i = 0; i < kernel_size; ++i) {\n        for (size_t j = 0; j < kernel_size; ++j) {\n            k[i * kernel_size + j] = _mm_load1_pd(&kernel[i * kernel_size + j]);\n        }\n    }\n\n    for (size_t y = 0; y < output_size; ++y) {\n        for (size_t x = 0; x < output_size; x += 2) {\n            __m128d sum = _mm_setzero_pd();\n\n            for (size_t i = 0; i < kernel_size; ++i) {\n                for (size_t j = 0; j < kernel_size; ++j) {\n                    __m128d input_val = _mm_loadu_pd(&input[(y + i) * input_size + (x + j)]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(input_val, k[i * kernel_size + j]));\n                }\n            }\n\n            sum = _mm_max_pd(sum, _mm_setzero_pd());\n            _mm_storeu_pd(&output[y * output_size + x], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d k[4];\n\n    for (size_t i = 0; i < kernel_size; ++i) {\n        for (size_t j = 0; j < kernel_size; ++j) {\n            k[i * kernel_size + j] = _mm_load1_pd(&kernel[i * kernel_size + j]);\n        }\n    }\n\n    for (size_t y = 0; y < output_size; ++y) {\n        for (size_t x = 0; x < output_size; ++x) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t i = 0; i < kernel_size; ++i) {\n                for (size_t j = 0; j < kernel_size; j += 2) {\n                    __m128d input_vec = _mm_loadu_pd(&input[(y + i) * input_size + (x + j)]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(input_vec, k[i * kernel_size + j]));\n                }\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            output[y * output_size + x] = fmax(result[0], 0.0) + fmax(result[1], 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d k[4];\n\n    for (size_t i = 0; i < kernel_size; ++i) {\n        for (size_t j = 0; j < kernel_size; ++j) {\n            k[i * kernel_size + j] = _mm_load1_pd(&kernel[i * kernel_size + j]);\n        }\n    }\n\n    for (size_t y = 0; y < output_size; ++y) {\n        for (size_t x = 0; x < output_size; ++x) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t i = 0; i < kernel_size; ++i) {\n                for (size_t j = 0; j < kernel_size; j += 2) {\n                    __m128d input_vals = _mm_loadu_pd(&input[(y + i) * input_size + (x + j)]);\n                    __m128d kernel_vals = k[i * kernel_size + j];\n                    sum = _mm_add_pd(sum, _mm_mul_pd(input_vals, kernel_vals));\n                }\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            double conv_result = result[0] + result[1];\n            output[y * output_size + x] = conv_result > 0 ? conv_result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d k[4];\n\n    for (size_t i = 0; i < kernel_size; ++i) {\n        for (size_t j = 0; j < kernel_size; ++j) {\n            k[i * kernel_size + j] = _mm_load1_pd(&kernel[i * kernel_size + j]);\n        }\n    }\n\n    for (size_t y = 0; y < output_size; ++y) {\n        for (size_t x = 0; x < output_size; ++x) {\n            __m128d sum = _mm_setzero_pd();\n            for (size_t i = 0; i < kernel_size; ++i) {\n                for (size_t j = 0; j < kernel_size; j += 2) {\n                    __m128d input_vals = _mm_loadu_pd(&input[(y + i) * input_size + (x + j)]);\n                    __m128d kernel_vals = _mm_load_pd(&kernel[i * kernel_size + j]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(input_vals, kernel_vals));\n                }\n            }\n            double result[2];\n            _mm_storeu_pd(result, sum);\n            double final_result = result[0] + result[1];\n            output[y * output_size + x] = final_result > 0 ? final_result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    \n    for (size_t i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            __m128d vec1 = _mm_loadu_pd(&numbers[i]);\n            for (size_t j = i + 1; j < n; j++) {\n                __m128d vec2 = _mm_loadu_pd(&numbers[j]);\n                __m128d diff = _mm_sub_pd(vec1, vec2);\n                __m128d abs_diff = _mm_and_pd(diff, _mm_set1_pd(-0.0)); // Absolute value\n                abs_diff = _mm_max_pd(abs_diff, _mm_sub_pd(vec2, vec1));\n                \n                if (_mm_movemask_pd(_mm_cmplt_pd(abs_diff, threshold_vec)) != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 >= n) break;\n\n        __m128d vec1 = _mm_loadu_pd(&numbers[i]);\n        for (int j = i + 2; j < n; j += 2) {\n            __m128d vec2 = _mm_loadu_pd(&numbers[j]);\n\n            __m128d abs_diff = _mm_sub_pd(vec1, vec2);\n            abs_diff = _mm_max_pd(abs_diff, _mm_sub_pd(vec2, vec1));\n\n            __m128d cmp = _mm_cmplt_pd(abs_diff, threshold_vec);\n            if (_mm_movemask_pd(cmp) != 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            __m128d vec = _mm_loadu_pd(&numbers[i]);\n            __m128d diff1 = _mm_sub_pd(vec, _mm_shuffle_pd(vec, vec, 1));\n            __m128d abs_diff1 = _mm_and_pd(diff1, _mm_castsi128_pd(_mm_set1_epi64x(0x7FFFFFFFFFFFFFFF)));\n            __m128d cmp1 = _mm_cmplt_pd(abs_diff1, threshold_vec);\n            if (_mm_movemask_pd(cmp1) != 0) return true;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (i != j) {\n                double diff = std::abs(numbers[i] - numbers[j]);\n                if (diff < threshold) return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            __m128d vec = _mm_loadu_pd(&numbers[i]);\n            __m128d diff1 = _mm_sub_pd(vec, _mm_shuffle_pd(vec, vec, _MM_SHUFFLE(0, 1, 0, 1)));\n            __m128d diff2 = _mm_sub_pd(vec, _mm_shuffle_pd(vec, vec, _MM_SHUFFLE(1, 0, 1, 0)));\n            \n            __m128d abs_diff1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff1);\n            __m128d abs_diff2 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff2);\n            \n            __m128d cmp1 = _mm_cmplt_pd(abs_diff1, threshold_vec);\n            __m128d cmp2 = _mm_cmplt_pd(abs_diff2, threshold_vec);\n            \n            if (_mm_movemask_pd(cmp1) || _mm_movemask_pd(cmp2)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) return false;\n\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    \n    for (int i = 0; i < n; i += 2) {\n        if (i + 1 < n) {\n            __m128d vec1 = _mm_loadu_pd(&numbers[i]);\n            for (int j = 0; j < n; j++) {\n                if (j != i && j != i + 1) {\n                    __m128d vec2 = _mm_loadu_pd(&numbers[j]);\n                    __m128d diff = _mm_sub_pd(vec1, vec2);\n                    diff = _mm_and_pd(diff, _mm_cmpgt_pd(diff, _mm_setzero_pd()));\n                    __m128d abs_diff = _mm_max_pd(diff, _mm_sub_pd(vec2, vec1));\n                    if (_mm_movemask_pd(_mm_cmplt_pd(abs_diff, threshold_vec)) != 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    __m128i zero = _mm_setzero_si128();\n    __m128i balance = _mm_setzero_si128();\n    \n    size_t size = operations.size();\n    size_t i;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i op = _mm_loadu_si128((__m128i*)&operations[i]);\n        balance = _mm_add_epi32(balance, op);\n        \n        // Check if balance is below zero\n        __m128i cmp = _mm_cmpgt_epi32(zero, balance);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        balance = _mm_add_epi32(balance, _mm_set1_epi32(operations[i]));\n        if (_mm_movemask_epi8(_mm_cmpgt_epi32(zero, balance)) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    __m128i zero = _mm_setzero_si128();\n    __m128i balance = _mm_setzero_si128();\n    \n    size_t size = operations.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i op = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&operations[i]));\n        balance = _mm_add_epi32(balance, op);\n        \n        // Check if any element in balance is below zero\n        __m128i cmp = _mm_cmpgt_epi32(zero, balance);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        balance = _mm_add_epi32(balance, _mm_set1_epi32(operations[i]));\n        if (_mm_cvtsi128_si32(balance) < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    __m128i zero = _mm_setzero_si128();\n    __m128i balance = _mm_setzero_si128();\n    \n    size_t size = operations.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i op = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&operations[i]));\n        balance = _mm_add_epi32(balance, op);\n        \n        // Check if any element in balance is below zero\n        __m128i cmp = _mm_cmpgt_epi32(zero, balance);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        balance = _mm_add_epi32(balance, _mm_set1_epi32(operations[i]));\n        if (_mm_extract_epi32(balance, 0) < 0 || _mm_extract_epi32(balance, 1) < 0 ||\n            _mm_extract_epi32(balance, 2) < 0 || _mm_extract_epi32(balance, 3) < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    __m128i zero = _mm_setzero_si128();\n    __m128i balance = _mm_setzero_si128();\n    \n    size_t size = operations.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i op = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&operations[i]));\n        balance = _mm_add_epi32(balance, op);\n        \n        // Check if any of the balances are below zero\n        __m128i cmp = _mm_cmpgt_epi32(zero, balance);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        balance = _mm_add_epi32(balance, _mm_set1_epi32(operations[i]));\n        if (_mm_extract_epi32(balance, 0) < 0 || \n            _mm_extract_epi32(balance, 1) < 0 || \n            _mm_extract_epi32(balance, 2) < 0 || \n            _mm_extract_epi32(balance, 3) < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    __m128i zero = _mm_setzero_si128();\n    __m128i balance = _mm_setzero_si128();\n    \n    size_t size = operations.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i op = _mm_loadu_si128((__m128i*)&operations[i]);\n        balance = _mm_add_epi32(balance, op);\n        __m128i cmp = _mm_cmpgt_epi32(zero, balance);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n    }\n\n    for (; i < size; ++i) {\n        balance = _mm_add_epi32(balance, _mm_set1_epi32(operations[i]));\n        if (_mm_extract_epi32(balance, 0) < 0 || \n            _mm_extract_epi32(balance, 1) < 0 || \n            _mm_extract_epi32(balance, 2) < 0 || \n            _mm_extract_epi32(balance, 3) < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    __m128d sum = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    // Calculate mean\n    for (int i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double total_sum[2];\n    _mm_storeu_pd(total_sum, sum);\n    double mean = (total_sum[0] + total_sum[1]) / n;\n\n    // Calculate mean absolute deviation\n    for (int i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d abs_dev = _mm_sub_pd(vec, mean_vec);\n        abs_dev = _mm_and_pd(abs_dev, _mm_cmpgt_pd(abs_dev, _mm_setzero_pd())); // abs\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_dev);\n    }\n\n    double total_abs_dev[2];\n    _mm_storeu_pd(total_abs_dev, sum_abs_dev);\n    double mad = (total_abs_dev[0] + total_abs_dev[1]) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    __m128d sum = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    // Calculate mean\n    for (int i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double total_sum[2];\n    _mm_storeu_pd(total_sum, sum);\n    double mean = (total_sum[0] + total_sum[1]) / n;\n\n    // Calculate Mean Absolute Deviation\n    for (int i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d abs_dev = _mm_sub_pd(vec, mean_vec);\n        abs_dev = _mm_and_pd(abs_dev, _mm_cmpgt_pd(abs_dev, _mm_setzero_pd())); // absolute value\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_dev);\n    }\n\n    double total_abs_dev[2];\n    _mm_storeu_pd(total_abs_dev, sum_abs_dev);\n    double mad = (total_abs_dev[0] + total_abs_dev[1]) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    __m128d sum_vec = _mm_setzero_pd();\n    __m128d sum_abs_vec = _mm_setzero_pd();\n\n    // Calculate mean\n    for (int i = 0; i < n; i += 2) {\n        __m128d num_vec = _mm_loadu_pd(&numbers[i]);\n        sum_vec = _mm_add_pd(sum_vec, num_vec);\n    }\n\n    double sum[2];\n    _mm_storeu_pd(sum, sum_vec);\n    double mean = (sum[0] + sum[1]) / n;\n\n    // Calculate Mean Absolute Deviation\n    for (int i = 0; i < n; i += 2) {\n        __m128d num_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d abs_diff_vec = _mm_sub_pd(num_vec, mean_vec);\n        abs_diff_vec = _mm_and_pd(abs_diff_vec, _mm_cmpgt_pd(abs_diff_vec, _mm_setzero_pd())); // abs\n        sum_abs_vec = _mm_add_pd(sum_abs_vec, abs_diff_vec);\n    }\n\n    double sum_abs[2];\n    _mm_storeu_pd(sum_abs, sum_abs_vec);\n    double mad = (sum_abs[0] + sum_abs[1]) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    __m128d sum_vec = _mm_setzero_pd();\n    __m128d sum_abs_vec = _mm_setzero_pd();\n\n    // Calculate mean\n    for (int i = 0; i < n; i += 2) {\n        __m128d num_vec = _mm_loadu_pd(&numbers[i]);\n        sum_vec = _mm_add_pd(sum_vec, num_vec);\n    }\n\n    double sum[2];\n    _mm_storeu_pd(sum, sum_vec);\n    double mean = (sum[0] + sum[1]) / n;\n\n    // Calculate Mean Absolute Deviation\n    for (int i = 0; i < n; i += 2) {\n        __m128d num_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d abs_diff_vec = _mm_sub_pd(num_vec, mean_vec);\n        abs_diff_vec = _mm_and_pd(abs_diff_vec, _mm_cmpgt_pd(abs_diff_vec, _mm_setzero_pd()));\n        sum_abs_vec = _mm_add_pd(sum_abs_vec, abs_diff_vec);\n    }\n\n    double sum_abs[2];\n    _mm_storeu_pd(sum_abs, sum_abs_vec);\n    double mad = (sum_abs[0] + sum_abs[1]) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    __m128d sum = _mm_setzero_pd();\n    __m128d sum_abs_diff = _mm_setzero_pd();\n\n    // Calculate mean\n    for (size_t i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n\n    double total_sum[2];\n    _mm_storeu_pd(total_sum, sum);\n    double mean = (total_sum[0] + total_sum[1]) / n;\n\n    // Calculate Mean Absolute Deviation\n    for (size_t i = 0; i < n; i += 2) {\n        __m128d vec = _mm_loadu_pd(&numbers[i]);\n        __m128d mean_vec = _mm_set1_pd(mean);\n        __m128d diff = _mm_sub_pd(vec, mean_vec);\n        __m128d abs_diff = _mm_and_pd(diff, _mm_cmpgt_pd(diff, _mm_setzero_pd()));\n        abs_diff = _mm_add_pd(abs_diff, _mm_andnot_pd(_mm_cmpgt_pd(diff, _mm_setzero_pd()), diff));\n        sum_abs_diff = _mm_add_pd(sum_abs_diff, abs_diff);\n    }\n\n    double total_abs_diff[2];\n    _mm_storeu_pd(total_abs_diff, sum_abs_diff);\n    double mad = (total_abs_diff[0] + total_abs_diff[1]) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    int n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(2 * n - 1);\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n\n    for (int i = 0; i < n; i += 4) {\n        __m128i numbers_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i]));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i * 2]), numbers_vec);\n        \n        if (i + 4 < n) {\n            _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i * 2 + 4]), delimiter_vec);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    result.reserve(n + (n - 1)); // space for delimiters\n\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    \n    for (size_t i = 0; i < n; i += 4) {\n        __m128i numbers_vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        _mm_storeu_si128((__m128i*)&result[result.size()], numbers_vec);\n        result.resize(result.size() + 4);\n        \n        if (i + 4 < n) {\n            _mm_storeu_si128((__m128i*)&result[result.size() - 4], delimiter_vec);\n            result.resize(result.size() + 4);\n        }\n    }\n\n    // Handle the case where the last delimiter is not needed\n    if (result.size() > 0 && result.back() == delimeter) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        __m128i numbers_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i]));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i * 2]), numbers_vec);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i * 2 + 4]), delimiter_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    if (n > 0) {\n        result[new_size - 1] = numbers[n - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    result.reserve(n + (n - 1)); // space for original numbers + delimiters\n\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    \n    for (size_t i = 0; i < n; i += 4) {\n        __m128i numbers_vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        _mm_storeu_si128((__m128i*)&result[result.size()], numbers_vec);\n        result.resize(result.size() + 4);\n        \n        if (i + 4 < n) {\n            _mm_storeu_si128((__m128i*)&result[result.size()], delimiter_vec);\n            result.resize(result.size() + 4);\n        }\n    }\n\n    // Handle remaining elements if n is not a multiple of 4\n    for (size_t i = (n / 4) * 4; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result;\n    result.reserve(n + (n - 1)); // space for delimiters\n\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    \n    for (size_t i = 0; i < n; i += 4) {\n        __m128i nums_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i]));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[result.size()]), nums_vec);\n        result.resize(result.size() + 4);\n        \n        if (i + 4 < n) {\n            _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[result.size()]), delimiter_vec);\n            result.resize(result.size() + 4);\n        }\n    }\n\n    // Handle remaining elements if n is not a multiple of 4\n    for (size_t i = (n / 4) * 4; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    size_t i = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i prod_vec = _mm_set1_epi16(1);\n\n    for (; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        sum_vec = _mm_add_epi16(sum_vec, vec);\n        prod_vec = _mm_mullo_epi16(prod_vec, vec);\n    }\n\n    // Horizontal sum\n    sum_vec = _mm_hadd_epi16(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi16(sum_vec, sum_vec);\n    sum += _mm_extract_epi16(sum_vec, 0);\n\n    // Horizontal product\n    for (int j = 0; j < 8 && i < size; ++j, ++i) {\n        product *= numbers[i];\n    }\n    \n    // Final product calculation\n    for (int j = 0; j < 8; ++j) {\n        product *= _mm_extract_epi16(prod_vec, j);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i prod_vec = _mm_set1_epi32(1);\n    \n    size_t size = numbers.size();\n    size_t i = 0;\n\n    for (; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        sum_vec = _mm_add_epi32(sum_vec, _mm_unpacklo_epi16(vec, _mm_setzero_si128()));\n        sum_vec = _mm_add_epi32(sum_vec, _mm_unpackhi_epi16(vec, _mm_setzero_si128()));\n        prod_vec = _mm_mullo_epi32(prod_vec, _mm_unpacklo_epi16(vec, _mm_setzero_si128()));\n        prod_vec = _mm_mullo_epi32(prod_vec, _mm_unpackhi_epi16(vec, _mm_setzero_si128()));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum_vec = _mm_add_epi32(sum_vec, _mm_set1_epi32(numbers[i]));\n        prod_vec = _mm_mullo_epi32(prod_vec, _mm_set1_epi32(numbers[i]));\n    }\n\n    // Horizontal sum\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    int32_t sum_result = _mm_cvtsi128_si32(sum_vec);\n\n    // Horizontal product\n    int32_t prod_result = _mm_cvtsi128_si32(prod_vec);\n\n    return {static_cast<int64_t>(sum_result), static_cast<int64_t>(prod_result)};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    size_t i = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i prod_vec = _mm_set1_epi16(1);\n\n    for (; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i]));\n        sum_vec = _mm_add_epi16(sum_vec, vec);\n        prod_vec = _mm_mullo_epi16(prod_vec, vec);\n    }\n\n    // Horizontal sum\n    sum_vec = _mm_hadd_epi16(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi16(sum_vec, sum_vec);\n    sum += _mm_cvtsi128_si32(sum_vec);\n\n    // Calculate product\n    for (int j = 0; j < 8; ++j) {\n        product *= _mm_extract_epi16(prod_vec, j);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int size = numbers.size();\n    if (size == 0) {\n        return {0, 1};\n    }\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i prod_vec = _mm_set1_epi32(1);\n    \n    int i;\n    for (i = 0; i <= size - 8; i += 8) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum_vec = _mm_add_epi32(sum_vec, vec1);\n        sum_vec = _mm_add_epi32(sum_vec, vec2);\n        \n        prod_vec = _mm_mullo_epi32(prod_vec, vec1);\n        prod_vec = _mm_mullo_epi32(prod_vec, vec2);\n    }\n\n    int32_t sum[4], prod[4];\n    _mm_storeu_si128((__m128i*)sum, sum_vec);\n    _mm_storeu_si128((__m128i*)prod, prod_vec);\n\n    int64_t total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n    int64_t total_prod = prod[0] * prod[1] * prod[2] * prod[3];\n\n    for (; i < size; ++i) {\n        total_sum += numbers[i];\n        total_prod *= numbers[i];\n    }\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i prod_vec = _mm_set1_epi32(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= size; i += 8) {\n        __m128i vec1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i]));\n        __m128i vec2 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&numbers[i + 4]));\n        \n        sum_vec = _mm_add_epi32(sum_vec, _mm_unpacklo_epi16(vec1, _mm_setzero_si128()));\n        sum_vec = _mm_add_epi32(sum_vec, _mm_unpacklo_epi16(vec2, _mm_setzero_si128()));\n        \n        prod_vec = _mm_mullo_epi32(prod_vec, _mm_unpacklo_epi16(vec1, _mm_setzero_si128()));\n        prod_vec = _mm_mullo_epi32(prod_vec, _mm_unpacklo_epi16(vec2, _mm_setzero_si128()));\n    }\n\n    int32_t sum[4], prod[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(sum), sum_vec);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(prod), prod_vec);\n\n    int64_t total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n    int64_t total_prod = prod[0] * prod[1] * prod[2] * prod[3];\n\n    for (; i < size; ++i) {\n        total_sum += numbers[i];\n        total_prod *= numbers[i];\n    }\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    __m128i max_vec = _mm_set1_epi32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        max_vec = _mm_max_epi32(max_vec, current_vec);\n        \n        if (i + 3 < n) {\n            _mm_storeu_si128((__m128i*)&result[i], max_vec);\n        } else {\n            for (size_t j = i; j < n; ++j) {\n                result[j] = _mm_extract_epi32(max_vec, j - i);\n            }\n        }\n        \n        result[i] = _mm_extract_epi32(max_vec, 0);\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    __m128i current_max = _mm_set1_epi32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        current_max = _mm_max_epi32(current_max, vec);\n        \n        if (i + 3 < n) {\n            _mm_storeu_si128((__m128i*)&result[i], current_max);\n        } else {\n            for (int j = i; j < n; j++) {\n                result[j] = _mm_extract_epi32(current_max, j - i);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    __m128i current_max = _mm_set1_epi32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i++) {\n        current_max = _mm_max_epi32(current_max, _mm_set1_epi32(numbers[i]));\n        result[i] = _mm_cvtsi128_si32(current_max);\n    }\n\n    for (size_t i = 1; i < n; i++) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    __m128i current_max = _mm_set1_epi32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        current_max = _mm_max_epi32(current_max, vec);\n        \n        if (i + 3 < n) {\n            _mm_storeu_si128((__m128i*)&result[i], current_max);\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = _mm_extract_epi32(current_max, j - i);\n            }\n        }\n        \n        current_max = _mm_max_epi32(current_max, _mm_set1_epi32(numbers[i + 3]));\n    }\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    __m128i current_max = _mm_set1_epi32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        current_max = _mm_max_epi32(current_max, vec);\n        \n        if (i + 3 < n) {\n            _mm_storeu_si128((__m128i*)&result[i], current_max);\n        } else {\n            for (int j = i; j < n; ++j) {\n                result[j] = _mm_extract_epi32(current_max, 0);\n                current_max = _mm_max_epi32(current_max, _mm_set1_epi32(numbers[j]));\n            }\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        result[i] = std::max(result[i - 1], result[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.size();\n    std::string result(length, '0');\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i vec_a = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&a[i]));\n        __m128i vec_b = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&b[i]));\n        \n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), vec_result);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    size_t i = 0;\n    for (; i + 4 <= len; i += 4) {\n        __m128i vec_a = _mm_loadu_si128((__m128i*)&a[i]);\n        __m128i vec_b = _mm_loadu_si128((__m128i*)&b[i]);\n        \n        // Convert '0' and '1' characters to 0 and 1 integers\n        vec_a = _mm_sub_epi8(vec_a, _mm_set1_epi8('0'));\n        vec_b = _mm_sub_epi8(vec_b, _mm_set1_epi8('0'));\n        \n        // Perform XOR\n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        // Convert back to '0' and '1' characters\n        vec_result = _mm_add_epi8(vec_result, _mm_set1_epi8('0'));\n        \n        _mm_storeu_si128((__m128i*)&result[i], vec_result);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, '0');\n\n    size_t i = 0;\n    __m128i mask = _mm_set1_epi8(1);\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i vec_a = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&a[i]));\n        __m128i vec_b = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&b[i]));\n\n        __m128i vec_xor = _mm_xor_si128(vec_a, vec_b);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), vec_xor);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.size();\n    std::string result(length, '0');\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i vec_a = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&a[i]));\n        __m128i vec_b = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&b[i]));\n        \n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), vec_result);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    size_t i = 0;\n    for (; i + 4 <= len; i += 4) {\n        __m128i vec_a = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&a[i]));\n        __m128i vec_b = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&b[i]));\n        \n        __m128i vec_result = _mm_xor_si128(vec_a, vec_b);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), vec_result);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    __m128i max_length = _mm_setzero_si128();\n    __m128i max_index = _mm_setzero_si128();\n    int max_len = 0;\n    int index = -1;\n\n    for (size_t i = 0; i < strings.size(); i += 4) {\n        __m128i lengths = _mm_setr_epi32(\n            i < strings.size() ? strings[i].size() : 0,\n            i + 1 < strings.size() ? strings[i + 1].size() : 0,\n            i + 2 < strings.size() ? strings[i + 2].size() : 0,\n            i + 3 < strings.size() ? strings[i + 3].size() : 0\n        );\n\n        __m128i cmp = _mm_cmpgt_epi32(lengths, max_length);\n        max_length = _mm_max_epi32(max_length, lengths);\n        max_index = _mm_blendv_epi8(max_index, _mm_setr_epi32(i, i + 1, i + 2, i + 3), cmp);\n    }\n\n    _mm_store_si128((__m128i*)&max_len, max_length);\n    _mm_store_si128((__m128i*)&index, max_index);\n\n    for (size_t i = 0; i < strings.size(); ++i) {\n        if (strings[i].size() == max_len) {\n            return strings[i];\n        }\n    }\n\n    return \"\";\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    __m128i max_length = _mm_setzero_si128();\n    int max_index = 0;\n\n    for (size_t i = 0; i < strings.size(); i += 4) {\n        __m128i lengths = _mm_setzero_si128();\n        for (int j = 0; j < 4 && (i + j) < strings.size(); ++j) {\n            lengths = _mm_insert_epi32(lengths, strings[i + j].size(), j);\n        }\n\n        // Compare lengths\n        __m128i cmp = _mm_cmpgt_epi32(lengths, max_length);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            max_length = lengths;\n            for (int j = 0; j < 4; ++j) {\n                if ((i + j) < strings.size() && _mm_extract_epi32(cmp, j)) {\n                    max_index = i + j;\n                }\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    std::string longest_str;\n\n    __m128i max_length_vec = _mm_setzero_si128();\n    __m128i current_length_vec;\n\n    size_t size = strings.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        current_length_vec = _mm_setr_epi32(strings[i].size(), strings[i + 1].size(), strings[i + 2].size(), strings[i + 3].size());\n        max_length_vec = _mm_max_epi32(max_length_vec, current_length_vec);\n    }\n\n    int lengths[4];\n    _mm_storeu_si128((__m128i*)lengths, max_length_vec);\n    for (int j = 0; j < 4; ++j) {\n        if (lengths[j] > max_length) {\n            max_length = lengths[j];\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (strings[i].size() > max_length) {\n            max_length = strings[i].size();\n        }\n    }\n\n    for (const auto& str : strings) {\n        if (str.size() == max_length) {\n            longest_str = str;\n            break;\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    std::string longest_string;\n\n    size_t n = strings.size();\n    size_t i = 0;\n\n    __m128i max_lengths = _mm_setzero_si128();\n    __m128i indices = _mm_setzero_si128();\n\n    for (; i + 4 <= n; i += 4) {\n        __m128i lengths = _mm_setr_epi32(strings[i].size(), strings[i + 1].size(), strings[i + 2].size(), strings[i + 3].size());\n        max_lengths = _mm_max_epi32(max_lengths, lengths);\n        indices = _mm_setr_epi32(i, i + 1, i + 2, i + 3);\n    }\n\n    int max_lengths_array[4];\n    _mm_storeu_si128((__m128i*)max_lengths_array, max_lengths);\n\n    int max_index = 0;\n    for (int j = 1; j < 4; ++j) {\n        if (max_lengths_array[j] > max_lengths_array[max_index]) {\n            max_index = j;\n        }\n    }\n\n    max_length = max_lengths_array[max_index];\n    longest_string = strings[i - 4 + max_index];\n\n    for (; i < n; ++i) {\n        if (strings[i].size() > max_length) {\n            max_length = strings[i].size();\n            longest_string = strings[i];\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\n#include <string>\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    std::string longest_str;\n\n    __m128i max_lengths = _mm_setzero_si128();\n    __m128i current_lengths;\n\n    size_t count = strings.size();\n    size_t i = 0;\n\n    for (; i + 4 <= count; i += 4) {\n        current_lengths = _mm_set_epi32(strings[i + 3].length(), strings[i + 2].length(), strings[i + 1].length(), strings[i].length());\n        max_lengths = _mm_max_epi32(max_lengths, current_lengths);\n    }\n\n    int lengths[4];\n    _mm_storeu_si128((__m128i*)lengths, max_lengths);\n\n    for (int j = 0; j < 4; ++j) {\n        if (lengths[j] > max_length) {\n            max_length = lengths[j];\n            longest_str = strings[i - 4 + j];\n        }\n    }\n\n    for (; i < count; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest_str = strings[i];\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = vb;\n        vb = _mm_and_si128(va, vb);\n        va = _mm_sub_epi64(va, vb);\n        vb = _mm_and_si128(temp, _mm_cmpeq_epi64(va, vb));\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = vb;\n        vb = _mm_and_si128(va, vb);\n        va = _mm_sub_epi64(va, vb);\n        vb = _mm_sub_epi64(temp, vb);\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_movemask_epi8(_mm_cmpeq_epi64(va, vb)) == 0) {\n        __m128i vmask = _mm_cmpgt_epi64(va, vb);\n        __m128i vtemp = _mm_and_si128(vmask, va);\n        va = _mm_andnot_si128(vmask, va);\n        va = _mm_add_epi64(va, vtemp);\n        \n        vmask = _mm_cmpgt_epi64(vb, va);\n        vtemp = _mm_and_si128(vmask, vb);\n        vb = _mm_andnot_si128(vmask, vb);\n        vb = _mm_add_epi64(vb, vtemp);\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    __m128i zero = _mm_setzero_si128();\n\n    while (_mm_movemask_epi8(_mm_cmpeq_epi64(va, zero)) == 0) {\n        __m128i v_mod = _mm_rem_epi64(va, vb);\n        va = vb;\n        vb = v_mod;\n    }\n\n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i vtemp = vb;\n        vb = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vtemp;\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    __m128 min_diff = _mm_set1_ps(std::numeric_limits<float>::max());\n    __m128 closest_pair[2];\n\n    for (size_t i = 0; i < n - 1; i += 4) {\n        __m128 a = _mm_loadu_ps(&numbers[i]);\n        __m128 b = _mm_loadu_ps(&numbers[i + 1]);\n\n        __m128 diff = _mm_sub_ps(a, b);\n        diff = _mm_and_ps(diff, _mm_cmpgt_ps(diff, _mm_setzero_ps())); // absolute value\n        diff = _mm_min_ps(diff, _mm_shuffle_ps(diff, diff, _MM_SHUFFLE(2, 3, 0, 1))); // min of pairs\n\n        min_diff = _mm_min_ps(min_diff, diff);\n\n        // Store the closest pairs\n        for (int j = 0; j < 4; j++) {\n            if (_mm_cvtss_f32(diff) == _mm_cvtss_f32(min_diff)) {\n                closest_pair[0] = a;\n                closest_pair[1] = b;\n            }\n            diff = _mm_shuffle_ps(diff, diff, _MM_SHUFFLE(3, 0, 1, 2)); // rotate\n        }\n    }\n\n    float closest[4];\n    _mm_storeu_ps(closest, closest_pair[0]);\n    _mm_storeu_ps(closest + 4, closest_pair[1]);\n\n    float min_value = _mm_cvtss_f32(min_diff);\n    float first = std::numeric_limits<float>::max();\n    float second = std::numeric_limits<float>::max();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_value) {\n                min_value = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    __m128 min_diff = _mm_set1_ps(std::numeric_limits<float>::max());\n    __m128 closest_pair[2];\n\n    for (size_t i = 0; i < n; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        for (size_t j = i + 1; j < n; j++) {\n            __m128 next = _mm_loadu_ps(&numbers[j]);\n            __m128 diff = _mm_sub_ps(current, next);\n            diff = _mm_and_ps(diff, _mm_cmpgt_ps(diff, _mm_setzero_ps())); // absolute value\n            diff = _mm_min_ps(diff, min_diff);\n\n            __m128 mask = _mm_cmpeq_ps(diff, min_diff);\n            closest_pair[0] = _mm_blendv_ps(closest_pair[0], current, mask);\n            closest_pair[1] = _mm_blendv_ps(closest_pair[1], next, mask);\n        }\n    }\n\n    float closest[4];\n    _mm_storeu_ps(closest, closest_pair[0]);\n    float min_value = closest[0];\n    float second_value = closest[1];\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_value) {\n                min_value = diff;\n                second_value = numbers[j];\n            }\n        }\n    }\n\n    return {std::min(min_value, second_value), std::max(min_value, second_value)};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    __m128 min_diff = _mm_set1_ps(std::numeric_limits<float>::max());\n    __m128 closest_pair_low = _mm_set1_ps(0);\n    __m128 closest_pair_high = _mm_set1_ps(0);\n\n    for (size_t i = 0; i < n - 1; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&numbers[i]);\n        __m128 vec2 = _mm_loadu_ps(&numbers[i + 1]);\n\n        __m128 diff = _mm_sub_ps(vec2, vec1);\n        diff = _mm_and_ps(diff, _mm_cmpgt_ps(diff, _mm_setzero_ps())); // only keep positive differences\n\n        __m128 mask = _mm_cmplt_ps(diff, min_diff);\n        min_diff = _mm_blendv_ps(min_diff, diff, mask);\n        \n        closest_pair_low = _mm_blendv_ps(closest_pair_low, vec1, mask);\n        closest_pair_high = _mm_blendv_ps(closest_pair_high, vec2, mask);\n    }\n\n    float min_diff_arr[4], low_arr[4], high_arr[4];\n    _mm_storeu_ps(min_diff_arr, min_diff);\n    _mm_storeu_ps(low_arr, closest_pair_low);\n    _mm_storeu_ps(high_arr, closest_pair_high);\n\n    float min_diff_value = std::numeric_limits<float>::max();\n    float closest_low = 0, closest_high = 0;\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_diff_arr[i] < min_diff_value) {\n            min_diff_value = min_diff_arr[i];\n            closest_low = low_arr[i];\n            closest_high = high_arr[i];\n        }\n    }\n\n    return {closest_low, closest_high};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    __m128 min_diff = _mm_set1_ps(std::numeric_limits<float>::max());\n    __m128 closest_pair[2];\n\n    for (size_t i = 0; i < n - 1; i += 4) {\n        __m128 a = _mm_loadu_ps(&numbers[i]);\n        __m128 b = _mm_loadu_ps(&numbers[i + 1]);\n\n        __m128 diff = _mm_sub_ps(a, b);\n        diff = _mm_and_ps(diff, _mm_cmpgt_ps(diff, _mm_setzero_ps())); // abs(diff)\n\n        min_diff = _mm_min_ps(min_diff, diff);\n        \n        __m128 mask = _mm_cmpeq_ps(diff, min_diff);\n        closest_pair[0] = _mm_blendv_ps(closest_pair[0], a, mask);\n        closest_pair[1] = _mm_blendv_ps(closest_pair[1], b, mask);\n    }\n\n    float closest[4];\n    _mm_storeu_ps(closest, closest_pair[0]);\n    float min_val = closest[0];\n    float max_val = closest[1];\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_val) {\n                min_val = std::min(numbers[i], numbers[j]);\n                max_val = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_pair[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n - 1; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&numbers[i]);\n        __m128 vec2 = _mm_loadu_ps(&numbers[i + 1]);\n\n        __m128 diff = _mm_sub_ps(vec2, vec1);\n        diff = _mm_and_ps(diff, _mm_cmpgt_ps(diff, _mm_setzero_ps())); // Keep only positive differences\n\n        float min_diff_temp[4];\n        _mm_storeu_ps(min_diff_temp, diff);\n        \n        for (int j = 0; j < 4; j++) {\n            if (i + j + 1 < n && min_diff_temp[j] < min_diff) {\n                min_diff = min_diff_temp[j];\n                closest_pair[0] = std::min(numbers[i + j], numbers[i + j + 1]);\n                closest_pair[1] = std::max(numbers[i + j], numbers[i + j + 1]);\n            }\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    __m128 min_val = _mm_set1_ps(numbers[0]);\n    __m128 max_val = _mm_set1_ps(numbers[0]);\n\n    // Find min and max\n    for (size_t i = 0; i < n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        min_val = _mm_min_ps(min_val, vec);\n        max_val = _mm_max_ps(max_val, vec);\n    }\n\n    float min_array[4], max_array[4];\n    _mm_storeu_ps(min_array, min_val);\n    _mm_storeu_ps(max_array, max_val);\n    \n    float min_value = std::min({min_array[0], min_array[1], min_array[2], min_array[3]});\n    float max_value = std::max({max_array[0], max_array[1], max_array[2], max_array[3]});\n    \n    float range = max_value - min_value;\n    __m128 range_vec = _mm_set1_ps(range);\n\n    std::vector<float> result(n);\n    for (size_t i = 0; i < n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled = _mm_sub_ps(vec, _mm_set1_ps(min_value));\n        scaled = _mm_div_ps(scaled, range_vec);\n        _mm_storeu_ps(&result[i], scaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min and max\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        __m128 num_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_sub_ps(num_vec, min_vec);\n        scaled_vec = _mm_div_ps(scaled_vec, range_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    if (size < 2) return numbers;\n\n    // Find min and max\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    std::vector<float> result(size);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 num_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_sub_ps(num_vec, min_vec);\n        scaled_vec = _mm_div_ps(scaled_vec, range_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min and max\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        __m128 num_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_sub_ps(num_vec, min_vec);\n        scaled_vec = _mm_div_ps(scaled_vec, range_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min and max\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        __m128 num_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_sub_ps(num_vec, min_vec);\n        scaled_vec = _mm_div_ps(scaled_vec, range_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / (max_val - min_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i one = _mm_set1_epi64x(1);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i result = _mm_set1_epi64x(0);\n\n    for (int i = 2; i <= n / 2; i += 2) {\n        __m128i divisor = _mm_set_epi64x(i + 1, i);\n        __m128i mod = _mm_rem_epi64(num, divisor);\n\n        __m128i is_divisor = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n        result = _mm_blendv_epi8(result, divisor, is_divisor);\n    }\n\n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1;\n\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i one = _mm_set1_epi64x(1);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i result = _mm_set1_epi64x(1);\n\n    for (uint64_t i = 2; i <= n / 2; i += 2) {\n        __m128i divisor = _mm_set_epi64x(i + 1, i);\n        __m128i mod = _mm_rem_epi64(num, divisor);\n        __m128i is_divisor = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n\n        result = _mm_blendv_epi8(result, divisor, is_divisor);\n    }\n\n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i one = _mm_set1_epi64x(1);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i result = _mm_set1_epi64x(1);\n\n    for (int i = 2; i < n; i += 2) {\n        __m128i divisor = _mm_set_epi64x(i + 1, i);\n        __m128i mod = _mm_rem_epi64(num, divisor);\n        __m128i is_divisor = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n\n        result = _mm_blendv_epi8(result, divisor, is_divisor);\n    }\n\n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1;\n\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i one = _mm_set1_epi64x(1);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i max_divisor = _mm_set1_epi64x(0);\n\n    for (uint64_t i = n - 1; i > 1; i -= 2) {\n        __m128i divisor = _mm_set_epi64x(i, i - 1);\n        __m128i mod = _mm_rem_epi64(num, divisor);\n\n        __m128i is_divisor = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n        max_divisor = _mm_blendv_epi8(max_divisor, divisor, is_divisor);\n    }\n\n    return _mm_cvtsi128_si64(max_divisor);\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1;\n\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i one = _mm_set1_epi64x(1);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i max_divisor = _mm_set1_epi64x(1);\n\n    for (uint64_t i = 2; i <= n / 2; i += 2) {\n        __m128i divisor = _mm_set_epi64x(i + 1, i);\n        __m128i mod = _mm_rem_epi64(num, divisor);\n        __m128i is_divisor = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n\n        max_divisor = _mm_blendv_epi8(max_divisor, divisor, is_divisor);\n    }\n\n    return _mm_cvtsi128_si64(max_divisor);\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    // Handle factor of 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Handle odd factors using SIMD\n    __m128i vec_n = _mm_set1_epi32(n);\n    for (int i = 3; i * i <= n; i += 2) {\n        __m128i vec_i = _mm_set1_epi32(i);\n        while (_mm_cvtsi128_si32(vec_n) % i == 0) {\n            factors.push_back(i);\n            vec_n = _mm_div_epi32(vec_n, vec_i);\n        }\n        n = _mm_cvtsi128_si32(vec_n);\n    }\n\n    // If n is still greater than 2, then it is prime\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    __m128i num = _mm_set1_epi32(n);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i five = _mm_set1_epi32(5);\n    __m128i seven = _mm_set1_epi32(7);\n    \n    for (int i = 2; i <= n; i++) {\n        __m128i divisor = _mm_set1_epi32(i);\n        __m128i result = _mm_div_epi32(num, divisor);\n        __m128i remainder = _mm_rem_epi32(num, divisor);\n        \n        while (_mm_movemask_epi8(_mm_cmpeq_epi32(remainder, _mm_setzero_si128())) != 0) {\n            factors.push_back(i);\n            num = result;\n            remainder = _mm_rem_epi32(num, divisor);\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    __m128i num = _mm_set1_epi32(n);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i five = _mm_set1_epi32(5);\n    __m128i seven = _mm_set1_epi32(7);\n    \n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n        if (i > 7) break; // No need to check beyond 7 for small factors\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    __m128i num = _mm_set1_epi32(n);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i five = _mm_set1_epi32(5);\n    __m128i seven = _mm_set1_epi32(7);\n    \n    for (int i = 2; i <= n; ++i) {\n        __m128i divisor = _mm_set1_epi32(i);\n        __m128i result = _mm_div_epi32(num, divisor);\n        __m128i remainder = _mm_rem_epi32(num, divisor);\n        \n        while (_mm_extract_epi32(remainder, 0) == 0) {\n            factors.push_back(i);\n            num = result;\n            remainder = _mm_rem_epi32(num, divisor);\n        }\n        \n        if (num[0] == 1) break;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    __m128i num = _mm_set1_epi32(n);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i five = _mm_set1_epi32(5);\n    __m128i seven = _mm_set1_epi32(7);\n    \n    for (int i = 2; i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    __m128 zero = _mm_setzero_ps();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        __m128 positive = _mm_and_ps(vec, mask);\n        _mm_storeu_ps(&result[result.size()], positive);\n        result.resize(result.size() + _mm_popcnt_u32(_mm_movemask_ps(mask)));\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(vec, _mm_setzero_ps());\n        __m128 positive_vec = _mm_and_ps(vec, mask);\n        _mm_storeu_ps(&result[result.size()], positive_vec);\n        result.resize(result.size() + 4);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    // Resize result to actual number of positive elements\n    result.resize(std::count_if(l.begin(), l.end(), [](float x) { return x > 0; }));\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(vec, _mm_setzero_ps());\n        __m128 positive_vec = _mm_and_ps(vec, mask);\n        _mm_storeu_ps(&result[result.size()], positive_vec);\n        result.resize(result.size() + 4);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    // Remove trailing zeros if any\n    result.erase(std::remove(result.begin(), result.end(), 0.0f), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]); // Load 4 floats\n        __m128 mask = _mm_cmpgt_ps(vec, _mm_setzero_ps()); // Compare with 0\n        __m128 positive_vec = _mm_and_ps(vec, mask); // Zero out negatives\n        _mm_storeu_ps(&result[result.size()], positive_vec); // Store results\n        result.resize(result.size() + 4); // Resize result vector\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    // Resize result to remove unused space\n    result.resize(std::count_if(result.begin(), result.end(), [](float x) { return x > 0; }));\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <algorithm>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 floats at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        __m128 positive_vec = _mm_and_ps(vec, mask);\n        _mm_storeu_ps(&result[result.size()], positive_vec);\n        result.resize(result.size() + 4);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    // Remove trailing zeros if any\n    result.erase(std::remove(result.begin(), result.end(), 0.0f), result.end());\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = static_cast<int64_t>(sqrt(n));\n    __m128i vec_limit = _mm_set1_epi64x(limit);\n    __m128i vec_n = _mm_set1_epi64x(n);\n    \n    for (int64_t i = 3; i <= limit; i += 2) {\n        __m128i vec_i = _mm_set1_epi64x(i);\n        __m128i vec_div = _mm_div_epi64(vec_n, vec_i);\n        __m128i vec_mod = _mm_sub_epi64(vec_n, _mm_mul_epi64(vec_div, vec_i));\n        \n        if (_mm_cvtsi128_si64(vec_mod) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    __m128i vec_n = _mm_set1_epi64x(n);\n    __m128i vec_i = _mm_set_epi64x(3, 3);\n    __m128i vec_limit = _mm_set1_epi64x(static_cast<int64_t>(sqrt(n)));\n\n    for (; _mm_cvtsi128_si64(vec_i) <= _mm_cvtsi128_si64(vec_limit); vec_i = _mm_add_epi64(vec_i, _mm_set1_epi64x(2))) {\n        __m128i vec_div = _mm_div_epi64(vec_n, vec_i);\n        __m128i vec_mod = _mm_rem_epi64(vec_n, vec_i);\n        if (_mm_cvtsi128_si64(vec_mod) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    __m128i vec_n = _mm_set1_epi64x(n);\n    __m128i vec_i = _mm_set_epi64x(3, 3);\n    __m128i vec_limit = _mm_set1_epi64x((int64_t)sqrt(n));\n\n    while (true) {\n        __m128i vec_mod = _mm_rem_epi64(vec_n, vec_i);\n        __m128i vec_zero = _mm_setzero_si128();\n        if (_mm_movemask_epi8(_mm_cmpeq_epi64(vec_mod, vec_zero)) != 0) {\n            return false;\n        }\n\n        vec_i = _mm_add_epi64(vec_i, _mm_set1_epi64x(2));\n        if (_mm_cmpgt_epi64(vec_i, vec_limit)) {\n            break;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cstdint>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    __m128i vec_n = _mm_set1_epi64x(n);\n    __m128i vec_i = _mm_set_epi64x(3, 3);\n    __m128i vec_limit = _mm_set1_epi64x(static_cast<int64_t>(sqrt(n)) + 1);\n    \n    for (; _mm_cvtsi128_si64(vec_i) < _mm_cvtsi128_si64(vec_limit); vec_i = _mm_add_epi64(vec_i, _mm_set1_epi64x(2))) {\n        __m128i vec_div = _mm_div_epi64(vec_n, vec_i);\n        __m128i vec_mod = _mm_rem_epi64(vec_n, vec_i);\n        \n        if (_mm_cvtsi128_si64(vec_mod) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cstdint>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    __m128i vec_n = _mm_set1_epi64x(n);\n    __m128i vec_i = _mm_set_epi64x(3, 3);\n    __m128i vec_limit = _mm_set1_epi64x(static_cast<int64_t>(sqrt(n)) + 1);\n    \n    while (true) {\n        __m128i vec_mod = _mm_rem_epi64(vec_n, vec_i);\n        __m128i vec_zero = _mm_setzero_si128();\n        \n        if (_mm_movemask_epi8(_mm_cmpeq_epi64(vec_mod, vec_zero)) != 0) {\n            return false;\n        }\n        \n        vec_i = _mm_add_epi64(vec_i, _mm_set1_epi64x(2));\n        \n        if (_mm_movemask_epi8(_mm_cmpgt_epi64(vec_i, vec_limit)) != 0) {\n            break;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    __m128i lower_mask = _mm_set1_epi8(0x20);\n    __m128i upper_mask = _mm_set1_epi8(0xDF);\n    __m128i digits_mask = _mm_set1_epi8(0x30);\n    __m128i letters_mask = _mm_set1_epi8(0x40);\n\n    for (size_t i = 0; i < n; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(input, _mm_set1_epi8('a' - 1)), _mm_cmplt_epi8(input, _mm_set1_epi8('z' + 1)));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(input, _mm_set1_epi8('A' - 1)), _mm_cmplt_epi8(input, _mm_set1_epi8('Z' + 1)));\n        \n        __m128i reversed_case = _mm_or_si128(\n            _mm_and_si128(is_lower, _mm_sub_epi8(input, lower_mask)),\n            _mm_and_si128(is_upper, _mm_add_epi8(input, lower_mask))\n        );\n\n        __m128i is_letter = _mm_or_si128(is_lower, is_upper);\n        __m128i output = _mm_blendv_epi8(input, reversed_case, is_letter);\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), output);\n    }\n\n    if (n % 16 != 0) {\n        for (size_t i = n - (n % 16); i < n; ++i) {\n            if (std::isalpha(s[i])) {\n                result[i] = std::isupper(s[i]) ? std::tolower(s[i]) : std::toupper(s[i]);\n            } else {\n                result[i] = s[i];\n            }\n        }\n    }\n\n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    __m128i lower_mask = _mm_set1_epi8(0x20);\n    __m128i upper_mask = _mm_set1_epi8(0xDF);\n    __m128i ascii_a = _mm_set1_epi8('a');\n    __m128i ascii_z = _mm_set1_epi8('z');\n    __m128i ascii_A = _mm_set1_epi8('A');\n    __m128i ascii_Z = _mm_set1_epi8('Z');\n\n    for (size_t i = 0; i < n; i += 16) {\n        __m128i chunk = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chunk, ascii_a), _mm_cmplt_epi8(chunk, ascii_z));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chunk, ascii_A), _mm_cmplt_epi8(chunk, ascii_Z));\n        \n        __m128i lower_case = _mm_and_si128(is_lower, _mm_xor_si128(chunk, lower_mask));\n        __m128i upper_case = _mm_and_si128(is_upper, _mm_xor_si128(chunk, upper_mask));\n        __m128i result_chunk = _mm_or_si128(lower_case, upper_case);\n        \n        _mm_storeu_si128((__m128i*)&result[i], result_chunk);\n    }\n\n    if (n % 16 != 0) {\n        for (size_t i = (n / 16) * 16; i < n; ++i) {\n            if (std::isalpha(s[i])) {\n                result[i] = std::isupper(s[i]) ? std::tolower(s[i]) : std::toupper(s[i]);\n            } else {\n                result[n - 1 - (i - (n / 16) * 16)] = s[i];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    __m128i lower_mask = _mm_set1_epi8(0x20); // Mask to toggle case\n    __m128i zero_mask = _mm_set1_epi8('0'); // ASCII value of '0'\n    __m128i nine_mask = _mm_set1_epi8('9'); // ASCII value of '9'\n    __m128i a_mask = _mm_set1_epi8('a'); // ASCII value of 'a'\n    __m128i z_mask = _mm_set1_epi8('z'); // ASCII value of 'z'\n    __m128i A_mask = _mm_set1_epi8('A'); // ASCII value of 'A'\n    __m128i Z_mask = _mm_set1_epi8('Z'); // ASCII value of 'Z'\n\n    size_t i = 0;\n    for (; i + 16 <= n; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(input, a_mask), _mm_cmplt_epi8(input, z_mask));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(input, A_mask), _mm_cmplt_epi8(input, Z_mask));\n        __m128i is_digit = _mm_and_si128(_mm_cmpgt_epi8(input, zero_mask), _mm_cmplt_epi8(input, nine_mask));\n\n        __m128i toggled_case = _mm_xor_si128(input, lower_mask);\n        __m128i result_case = _mm_or_si128(_mm_and_si128(is_lower, toggled_case), _mm_andnot_si128(is_lower, input));\n        result_case = _mm_or_si128(_mm.and_si128(is_upper, toggled_case), _mm.andnot_si128(is_upper, result_case));\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), result_case);\n    }\n\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 0x20;\n        } else {\n            result[i] = c;\n        }\n    }\n\n    if (n == 0 || (result.find_first_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") == std::string::npos)) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    __m128i lower_mask = _mm_set1_epi8(0x20); // Mask for toggling case\n    __m128i zero_mask = _mm_set1_epi8('0'); // ASCII '0'\n    __m128i nine_mask = _mm_set1_epi8('9'); // ASCII '9'\n    __m128i a_mask = _mm_set1_epi8('a'); // ASCII 'a'\n    __m128i z_mask = _mm_set1_epi8('z'); // ASCII 'z'\n    __m128i A_mask = _mm_set1_epi8('A'); // ASCII 'A'\n    __m128i Z_mask = _mm_set1_epi8('Z'); // ASCII 'Z'\n\n    size_t i = 0;\n    for (; i + 16 <= n; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        __m128i cmp_lower = _mm_and_si128(_mm_cmpgt_epi8(chunk, a_mask), _mm_cmplt_epi8(chunk, z_mask));\n        __m128i cmp_upper = _mm_and_si128(_mm_cmpgt_epi8(chunk, A_mask), _mm_cmplt_epi8(chunk, Z_mask));\n        \n        __m128i toggled_case = _mm_xor_si128(chunk, lower_mask);\n        __m128i result_chunk = _mm_or_si128(_mm_and_si128(cmp_lower, toggled_case), \n                                             _mm_andnot_si128(cmp_lower, chunk));\n        result_chunk = _mm_or_si128(_mm.and_si128(cmp_upper, toggled_case), \n                                     _mm.andnot_si128(cmp_upper, result_chunk));\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), result_chunk);\n    }\n\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 0x20;\n        } else {\n            result[i] = c;\n        }\n    }\n\n    if (n == 0 || (result.find_first_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") == std::string::npos)) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    std::string result(n, ' ');\n\n    __m128i lower_mask = _mm_set1_epi8(0x20);\n    __m128i upper_mask = _mm_set1_epi8(0xDF);\n    __m128i zero_mask = _mm_set1_epi8('0');\n    __m128i nine_mask = _mm_set1_epi8('9');\n    __m128i a_mask = _mm_set1_epi8('a');\n    __m128i z_mask = _mm_set1_epi8('z');\n    __m128i A_mask = _mm_set1_epi8('A');\n    __m128i Z_mask = _mm_set1_epi8('Z');\n\n    size_t i = 0;\n    for (; i + 16 <= n; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        __m128i lower_case = _mm_and_si128(_mm_cmpgt_epi8(input, A_mask), _mm_cmplt_epi8(input, Z_mask));\n        __m128i upper_case = _mm_and_si128(_mm_cmpgt_epi8(input, a_mask), _mm_cmplt_epi8(input, z_mask));\n        \n        __m128i reversed_case = _mm_xor_si128(input, _mm_or_si128(lower_case, upper_case));\n        __m128i is_digit = _mm_and_si128(_mm_cmpgt_epi8(input, zero_mask), _mm_cmplt_epi8(input, nine_mask));\n        __m128i is_letter = _mm_or_si128(lower_case, upper_case);\n        \n        __m128i result_case = _mm_blendv_epi8(reversed_case, input, is_digit);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), result_case);\n    }\n\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[n - 1 - i] = c - 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[n - 1 - i] = c + 0x20;\n        } else {\n            result[n - 1 - i] = c;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> third_indices;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    std::sort(third_indices.begin(), third_indices.end());\n\n    // Place sorted values back into the result vector\n    size_t j = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = third_indices[j++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> to_sort;\n    for (int i = 0; i < n; i += 3) {\n        if (i < n) to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected values\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Place sorted values back into the result vector\n    for (int i = 0, j = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (j < to_sort.size()) {\n                result[i] = to_sort[j++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> third_indices_values;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_indices_values.push_back(l[i]);\n    }\n\n    // Sort the collected values\n    std::sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Place sorted values back into the result vector\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (sorted_index < third_indices_values.size()) {\n                result[i] = third_indices_values[sorted_index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> third_indices_values;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_indices_values.push_back(l[i]);\n    }\n\n    // Sort the collected values\n    std::sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Place sorted values back into the result vector\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (sorted_index < third_indices_values.size()) {\n                result[i] = third_indices_values[sorted_index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Collect values at indices divisible by 3\n    std::vector<int> third_indices_values;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) third_indices_values.push_back(l[i]);\n    }\n\n    // Sort the collected values\n    std::sort(third_indices_values.begin(), third_indices_values.end());\n\n    // Place sorted values back into the result vector\n    size_t sort_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (sort_index < third_indices_values.size()) {\n                result[i] = third_indices_values[sort_index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    if (size == 0) return std::numeric_limits<float>::quiet_NaN();\n\n    __m128 max_val = _mm_set1_ps(l[0]);\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128 current = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, current);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, max_val);\n    \n    float max_result = result[0];\n    for (int i = 1; i < 4; i++) {\n        max_result = std::max(max_result, result[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    __m128 max_val = _mm_set1_ps(l[0]);\n\n    for (int i = 0; i < size; i += 4) {\n        __m128 current = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, current);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, max_val);\n    float max_result = result[0];\n    for (int i = 1; i < 4; i++) {\n        max_result = std::max(max_result, result[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    __m128 max_val = _mm_set1_ps(-FLT_MAX);\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, vec);\n    }\n\n    float max_array[4];\n    _mm_storeu_ps(max_array, max_val);\n    \n    float max_result = max_array[0];\n    for (int i = 1; i < 4; i++) {\n        max_result = std::max(max_result, max_array[i]);\n    }\n\n    for (int i = (size / 4) * 4; i < size; i++) {\n        max_result = std::max(max_result, l[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    __m128 max_val = _mm_set1_ps(l[0]);\n\n    for (int i = 0; i < size; i += 4) {\n        __m128 current = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, current);\n    }\n\n    float max_array[4];\n    _mm_storeu_ps(max_array, max_val);\n    \n    float max_result = max_array[0];\n    for (int i = 1; i < 4; i++) {\n        max_result = std::max(max_result, max_array[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    __m128 max_val = _mm_set1_ps(l[0]);\n\n    for (int i = 0; i < size; i += 4) {\n        __m128 current_vals = _mm_loadu_ps(&l[i]);\n        max_val = _mm_max_ps(max_val, current_vals);\n    }\n\n    float max_array[4];\n    _mm_storeu_ps(max_array, max_val);\n    \n    float max_result = max_array[0];\n    for (int i = 1; i < 4; ++i) {\n        max_result = std::max(max_result, max_array[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i eleven = _mm_set1_epi32(11);\n    __m128i thirteen = _mm_set1_epi32(13);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(_mm_rem_epi32(indices, eleven), zero), \n                                          _mm_cmpeq_epi32(_mm_rem_epi32(indices, thirteen), zero));\n        \n        __m128i digits = _mm_and_si128(divisible, _mm_cmpeq_epi32(_mm_rem_epi32(indices, _mm_set1_epi32(10)), seven));\n        \n        count += _mm_popcnt_u32(_mm_movemask_epi8(digits));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i eleven = _mm_set1_epi32(11);\n    __m128i thirteen = _mm_set1_epi32(13);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(_mm_rem_epi32(indices, eleven), zero), \n                                          _mm_cmpeq_epi32(_mm_rem_epi32(indices, thirteen), zero));\n        \n        __m128i digit_count = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; ++j) {\n            int current = i + j;\n            if (current >= n) break;\n            int temp = current;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    digit_count = _mm_add_epi32(digit_count, _mm_set1_epi32(1));\n                }\n                temp /= 10;\n            }\n        }\n        \n        count += _mm_extract_epi32(digit_count, 0) + _mm_extract_epi32(digit_count, 1) +\n                 _mm_extract_epi32(digit_count, 2) + _mm_extract_epi32(digit_count, 3);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i eleven = _mm_set1_epi32(11);\n    __m128i thirteen = _mm_set1_epi32(13);\n    __m128i zero = _mm_setzero_si128();\n\n    for (int i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(_mm_rem_epi32(indices, eleven), zero),\n                                          _mm_cmpeq_epi32(_mm_rem_epi32(indices, thirteen), zero));\n        __m128i is_seven = _mm_cmpeq_epi32(indices, seven);\n        \n        __m128i result = _mm_and_si128(divisible, is_seven);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i eleven = _mm_set1_epi32(11);\n    __m128i thirteen = _mm_set1_epi32(13);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(_mm_rem_epi32(indices, eleven), zero), \n                                          _mm_cmpeq_epi32(_mm_rem_epi32(indices, thirteen), zero));\n        \n        __m128i sevens = _mm_and_si128(divisible, _mm_cmpeq_epi32(indices, seven));\n        \n        count += _mm_popcnt_u32(_mm_movemask_epi8(sevens));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i eleven = _mm_set1_epi32(11);\n    __m128i thirteen = _mm_set1_epi32(13);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i values = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(_mm_rem_epi32(values, eleven), zero), \n                                          _mm_cmpeq_epi32(_mm_rem_epi32(values, thirteen), zero));\n        \n        __m128i sevens = _mm_setzero_si128();\n        for (int j = 0; j < 4; j++) {\n            int current = i + j;\n            if (current < n) {\n                while (current > 0) {\n                    if (current % 10 == 7) {\n                        sevens = _mm_add_epi32(sevens, _mm_set1_epi32(1));\n                    }\n                    current /= 10;\n                }\n            }\n        }\n        \n        sevens = _mm_and_si128(sevens, divisible);\n        count += _mm_cvtsi128_si32(sevens) + _mm_cvtsi128_si32(_mm_srli_si128(sevens, 4)) +\n                 _mm_cvtsi128_si32(_mm_srli_si128(sevens, 8)) + _mm_cvtsi128_si32(_mm_srli_si128(sevens, 12));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (i < n) {\n            even_indices.push_back(l[i]);\n        }\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    __m128 odd_mask = _mm_set1_ps(1.0f);\n    for (size_t i = 0; i < n; i += 4) {\n        __m128 even_values = _mm_loadu_ps(&even_indices[i / 2]);\n        __m128 odd_values = _mm_loadu_ps(&l[i]);\n\n        if (i + 1 < n) {\n            odd_values = _mm_and_ps(odd_values, odd_mask);\n            even_values = _mm_andnot_ps(odd_mask, even_values);\n            __m128 result = _mm_or_ps(even_values, odd_values);\n            _mm_storeu_ps(&l[i], result);\n        } else {\n            _mm_storeu_ps(&l[i], odd_values);\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Extract even indices into a temporary vector\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    // Sort the even indices\n    std::sort(even_indices.begin(), even_indices.end());\n\n    // Place sorted even indices back into the result vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            result[i] = even_indices[i / 2];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (i < n) {\n            even_indices.push_back(l[i]);\n        }\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    __m128 odd_mask = _mm_set_ps(0, 1, 0, 1);\n    for (size_t i = 0; i < n; i += 4) {\n        __m128 even_values = _mm_loadu_ps(&even_indices[i / 2]);\n        __m128 odd_values = _mm_loadu_ps(&l[i]);\n        __m128 result = _mm_blendv_ps(odd_values, even_values, odd_mask);\n        _mm_storeu_ps(&l[i], result);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (i < n) {\n            even_indices.push_back(l[i]);\n        }\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    __m128 even_vals, odd_vals;\n    for (size_t i = 0; i < n; i += 4) {\n        even_vals = _mm_loadu_ps(&even_indices[i / 2]);\n        odd_vals = _mm_loadu_ps(&l[i]);\n\n        if (i < n) {\n            _mm_storeu_ps(&l[i], _mm_unpacklo_ps(odd_vals, even_vals));\n        }\n        if (i + 2 < n) {\n            _mm_storeu_ps(&l[i + 2], _mm_unpackhi_ps(odd_vals, even_vals));\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        if (i < n) {\n            even_indices.push_back(l[i]);\n        }\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    for (size_t i = 0, j = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_indices[j++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue; // Skip duplicates\n\n        int a = l[i];\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int b = l[left];\n            int c = l[right];\n            int sum = a + b + c;\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::sort(l.begin(), l.end());\n\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue; // Skip duplicates\n\n        int a = l[i];\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int b = l[left];\n            int c = l[right];\n            int sum = a + b + c;\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (int i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        vec = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        vec = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        vec = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Prepare the result vector\n    std::vector<int> result(size);\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]); // Load 4 integers\n        vec = _mm_add_epi32(vec, _mm_set1_epi32(1));   // Increment each by 1\n        _mm_storeu_si128((__m128i*)&result[i], vec);  // Store the result\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        vec = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        for (int j = 0; j < 4 && (i + j) < size; ++j) {\n            int num = l[i + j];\n            if (seen.count(-num)) {\n                return true;\n            }\n            seen.insert(num);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        for (int j = 0; j < 4; ++j) {\n            if (i + j < size) {\n                int num = l[i + j];\n                if (seen.count(-num)) {\n                    return true;\n                }\n                seen.insert(num);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        for (int j = 0; j < 4; ++j) {\n            if (i + j < size) {\n                int value = l[i + j];\n                if (seen.count(-value)) {\n                    return true;\n                }\n                seen.insert(value);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n    size_t size = l.size();\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        for (int j = 0; j < 4; ++j) {\n            if (i + j < size) {\n                int value = l[i + j];\n                if (seen.count(-value)) {\n                    return true;\n                }\n                seen.insert(value);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        for (int j = 0; j < 4; ++j) {\n            if (i + j < l.size()) {\n                int value = l[i + j];\n                if (seen.count(-value)) {\n                    return true;\n                }\n                seen.insert(value);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::vector<char> result;\n    __m128i num = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi8(base);\n    __m128i zero = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si64(num) > 0) {\n        __m128i remainder = _mm_rem_epi64(num, base_vec);\n        num = _mm_div_epi64(num, base_vec);\n        \n        for (int i = 0; i < 8; ++i) {\n            int64_t rem = _mm_cvtsi128_si64(remainder);\n            if (rem > 0) {\n                result.push_back('0' + rem);\n            }\n            remainder = _mm_srli_epi64(remainder, 8);\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    __m128i num = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi8(base);\n    __m128i zero = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si64(num) > 0) {\n        __m128i remainder = _mm_rem_epi64(num, base_vec);\n        __m128i quotient = _mm_div_epi64(num, base_vec);\n        \n        for (int i = 0; i < 8; ++i) {\n            int64_t rem = _mm_cvtsi128_si64(remainder);\n            if (rem > 0) {\n                result.push_back('0' + rem);\n            }\n            num = quotient;\n            remainder = _mm_rem_epi64(num, base_vec);\n            quotient = _mm_div_epi64(num, base_vec);\n        }\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::vector<char> result;\n    __m128i num = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi8(base);\n    __m128i zero = _mm_set1_epi8('0');\n\n    while (x > 0) {\n        __m128i remainder = _mm_rem_epi64(num, base_vec);\n        num = _mm_div_epi64(num, base_vec);\n        \n        // Convert remainder to character\n        remainder = _mm_add_epi8(remainder, zero);\n        \n        // Store the result\n        for (int i = 0; i < 16; i++) {\n            char r = _mm_extract_epi8(remainder, i);\n            if (r != 0) {\n                result.push_back(r);\n            }\n        }\n    }\n\n    // Reverse the result to get the correct order\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    __m128i num = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi8(base);\n    __m128i zero = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si64(num) > 0) {\n        __m128i remainder = _mm_rem_epi64(num, base_vec);\n        num = _mm_div_epi64(num, base_vec);\n        \n        for (int i = 0; i < 8; ++i) {\n            int64_t rem = _mm_cvtsi128_si64(remainder);\n            if (rem > 0) {\n                result.push_back('0' + rem);\n            }\n            remainder = _mm_srli_epi64(remainder, 8);\n        }\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    __m128i base_vec = _mm_set1_epi8(base);\n    __m128i zero_vec = _mm_set1_epi8('0');\n    \n    while (x > 0) {\n        __m128i x_vec = _mm_set1_epi64x(x);\n        __m128i remainder = _mm_rem_epi64(x_vec, base_vec);\n        x = _mm_cvtsi128_si64(_mm_srli_epi64(x_vec, 1)); // Divide x by base\n        \n        // Convert remainder to character\n        remainder = _mm_add_epi8(remainder, zero_vec);\n        \n        // Store result\n        for (int i = 0; i < 16; ++i) {\n            char r = _mm_extract_epi8(remainder, i);\n            if (r != 0) {\n                result.push_back(r);\n            }\n        }\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n == 0) return true;\n\n    __m128i* data = reinterpret_cast<__m128i*>(text.data());\n    int len = n / 16;\n    int remainder = n % 16;\n\n    for (int i = 0; i < len; ++i) {\n        __m128i left = _mm_loadu_si128(&data[i]);\n        __m128i right = _mm_loadu_si128(&data[len - 1 - i]);\n        left = _mm_shuffle_epi8(left, _mm_setr_epi8(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n        if (_mm_movemask_epi8(_mm_cmpeq_epi8(left, right)) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    for (int i = 0; i < remainder / 2; ++i) {\n        if (text[i] != text[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int start = 0;\n    int end = len - 1;\n\n    while (start < end) {\n        __m128i left_chars = _mm_loadu_si128((__m128i*)&text[start]);\n        __m128i right_chars = _mm_loadu_si128((__m128i*)&text[end - 15]);\n\n        left_chars = _mm_cmpeq_epi8(left_chars, _mm_shuffle_epi32(right_chars, _MM_SHUFFLE(0, 1, 2, 3)));\n        int mask = _mm_movemask_epi8(left_chars);\n\n        if (mask != 0xFFFF) {\n            return false;\n        }\n\n        start += 16;\n        end -= 16;\n    }\n\n    while (start < end) {\n        if (text[start] != text[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n == 0) return true;\n\n    const char* str = text.c_str();\n    int left = 0;\n    int right = n - 1;\n\n    while (left < right) {\n        __m128i left_chars = _mm_loadu_si128((__m128i*)&str[left]);\n        __m128i right_chars = _mm_loadu_si128((__m128i*)&str[right - 15]);\n\n        left_chars = _mm_cmpeq_epi8(left_chars, _mm_shuffle_epi8(right_chars, _mm_set_epi8(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)));\n        int mask = _mm_movemask_epi8(left_chars);\n\n        if (mask != 0xFFFF) return false;\n\n        left += 16;\n        right -= 16;\n    }\n\n    while (left < right) {\n        if (str[left] != str[right]) return false;\n        left++;\n        right--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.length();\n    if (n == 0) return true;\n\n    int left = 0;\n    int right = n - 1;\n\n    while (left < right) {\n        __m128i left_chars = _mm_loadu_si128((__m128i*)&text[left]);\n        __m128i right_chars = _mm_loadu_si128((__m128i*)&text[right - 15]);\n\n        left_chars = _mm_cmpeq_epi8(left_chars, _mm_shuffle_epi32(right_chars, _MM_SHUFFLE(0, 1, 2, 3)));\n        right_chars = _mm_cmpeq_epi8(left_chars, _mm_shuffle_epi32(right_chars, _MM_SHUFFLE(4, 5, 6, 7)));\n\n        int mask = _mm_movemask_epi8(left_chars);\n        if (mask != 0xFFFF) return false;\n\n        left += 16;\n        right -= 16;\n    }\n\n    while (left < right) {\n        if (text[left] != text[right]) return false;\n        left++;\n        right--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n == 0) return true;\n\n    // Use two pointers to compare characters from both ends\n    int left = 0;\n    int right = n - 1;\n\n    while (left < right) {\n        // Load 16 bytes from both ends\n        __m128i left_chars = _mm_loadu_si128((__m128i*)&text[left]);\n        __m128i right_chars = _mm_loadu_si128((__m128i*)&text[right - 15]);\n\n        // Reverse right_chars for comparison\n        right_chars = _mm_shuffle_epi32(right_chars, _MM_SHUFFLE(0, 1, 2, 3));\n        right_chars = _mm_shufflelo_epi16(right_chars, _MM_SHUFFLE(3, 2, 1, 0));\n        right_chars = _mm_shufflehi_epi16(right_chars, _MM_SHUFFLE(3, 2, 1, 0));\n\n        // Compare characters\n        __m128i cmp = _mm_cmpeq_epi8(left_chars, right_chars);\n        int mask = _mm_movemask_epi8(cmp);\n\n        // Check if all characters matched\n        if (mask != 0xFFFF) return false;\n\n        left += 16;\n        right -= 16;\n    }\n\n    // Handle the middle character for odd-length strings\n    if (left == right) {\n        return text[left] == text[right];\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i decoded = _mm_add_epi8(input, shift);\n        __m128i mask = _mm_cmpgt_epi8(decoded, z);\n        decoded = _mm_add_epi8(decoded, _mm_and_si128(mask, _mm_set1_epi8(-26)));\n        _mm_storeu_si128((__m128i*)&out[i], decoded);\n    }\n\n    for (; i < length; ++i) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i range = _mm_set1_epi8(26);\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i decoded = _mm_add_epi8(input, shift);\n        __m128i less_than_a = _mm_cmplt_epi8(decoded, a);\n        __m128i adjusted = _mm_add_epi8(decoded, range);\n        decoded = _mm_blendv_epi8(decoded, adjusted, less_than_a);\n        _mm_storeu_si128((__m128i*)&out[i], decoded);\n    }\n\n    for (; i < length; ++i) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t length = s.length();\n    std::string out(length, ' ');\n\n    __m128i shift = _mm_set1_epi8(5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    \n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i decoded = _mm_sub_epi8(input, shift);\n        __m128i mask = _mm_cmpgt_epi8(decoded, z);\n        decoded = _mm_add_epi8(decoded, _mm_and_si128(mask, _mm_set1_epi8(-26)));\n        _mm_storeu_si128((__m128i*)&out[i], decoded);\n    }\n\n    for (; i < length; ++i) {\n        out[i] = (s[i] - 5 < 'a') ? (s[i] - 5 + 26) : (s[i] - 5);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), ' ');\n    size_t length = s.size();\n    size_t i;\n\n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i range = _mm_set1_epi8(26);\n\n    for (i = 0; i < length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i decoded = _mm_add_epi8(input, shift);\n        __m128i below_a = _mm_cmpgt_epi8(decoded, z);\n        decoded = _mm_sub_epi8(decoded, _mm_and_si128(below_a, range));\n        _mm_storeu_si128((__m128i*)&out[i], decoded);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t length = s.length();\n    std::string out(length, ' ');\n\n    __m128i shift = _mm_set1_epi8(5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i mod = _mm_set1_epi8(26);\n\n    for (size_t i = 0; i < length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i decoded = _mm_sub_epi8(input, shift);\n        __m128i less_than_a = _mm_cmplt_epi8(decoded, a);\n        decoded = _mm_add_epi8(decoded, _mm_and_si128(less_than_a, mod));\n\n        _mm_storeu_si128((__m128i*)&out[i], decoded);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    __m128i threshold = _mm_set1_epi32(t);\n    size_t size = l.size();\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128i values = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i cmp = _mm_cmpgt_epi32(values, threshold);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        if (mask != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    __m128i threshold = _mm_set1_epi32(t);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i cmp = _mm_cmpgt_epi32(vec, threshold);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    __m128i threshold = _mm_set1_epi32(t);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i cmp = _mm_cmpgt_epi32(vec, threshold);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    __m128i threshold = _mm_set1_epi32(t);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i cmp = _mm_cmpgt_epi32(vec, threshold);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    __m128i threshold = _mm_set1_epi32(t);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i cmp = _mm_cmpgt_epi32(vec, threshold);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    __m128i count = _mm_setzero_si128();\n    \n    for (int i = 0; i < length; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&brackets[i]);\n        __m128i less_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('<'));\n        __m128i greater_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('>'));\n        \n        count = _mm_add_epi8(count, _mm_sub_epi8(less_than, greater_than));\n    }\n\n    // Horizontal sum of the count\n    count = _mm_hadd_epi16(count, count);\n    count = _mm_hadd_epi16(count, count);\n    count = _mm_hadd_epi32(count, count);\n    \n    int result = _mm_cvtsi128_si32(count);\n    return result == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    __m128i open_bracket = _mm_set1_epi8('<');\n    __m128i close_bracket = _mm_set1_epi8('>');\n    __m128i count = _mm_setzero_si128();\n    \n    int length = brackets.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&brackets[i]);\n        __m128i mask_open = _mm_cmpeq_epi8(data, open_bracket);\n        __m128i mask_close = _mm_cmpeq_epi8(data, close_bracket);\n        \n        count = _mm_add_epi8(count, _mm_sub_epi8(mask_open, mask_close));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            count = _mm_add_epi8(count, _mm_set1_epi8(1));\n        } else if (brackets[i] == '>') {\n            count = _mm_sub_epi8(count, _mm_set1_epi8(1));\n        }\n    }\n\n    // Horizontal sum of the count\n    int16_t temp[16];\n    _mm_storeu_si128((__m128i*)temp, count);\n    int total = 0;\n    for (int j = 0; j < 16; ++j) {\n        total += temp[j];\n    }\n\n    return total == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    __m128i count = _mm_setzero_si128();\n    int len = brackets.length();\n    int i;\n\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&brackets[i]);\n        __m128i less_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('<'));\n        __m128i greater_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('>'));\n        \n        count = _mm_add_epi8(count, _mm_sub_epi8(less_than, greater_than));\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        if (brackets[i] == '<') {\n            count = _mm_add_epi8(count, _mm_set1_epi8(1));\n        } else if (brackets[i] == '>') {\n            count = _mm_sub_epi8(count, _mm_set1_epi8(1));\n        }\n    }\n\n    // Sum the counts\n    int16_t sums[8];\n    _mm_storeu_si128((__m128i*)sums, count);\n    int total = 0;\n    for (int j = 0; j < 8; ++j) {\n        total += sums[j];\n    }\n\n    return total == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    __m128i count = _mm_setzero_si128();\n    int length = brackets.length();\n    int i;\n\n    for (i = 0; i <= length - 16; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&brackets[i]);\n        __m128i less_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('<'));\n        __m128i greater_than = _mm_cmpeq_epi8(data, _mm_set1_epi8('>'));\n\n        count = _mm_add_epi8(count, _mm_sub_epi8(less_than, greater_than));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            count = _mm_add_epi8(count, _mm_set1_epi8(1));\n        } else if (brackets[i] == '>') {\n            count = _mm_sub_epi8(count, _mm_set1_epi8(1));\n        }\n    }\n\n    // Horizontal sum of the count\n    int16_t sum[8];\n    _mm_storeu_si128((__m128i*)sum, count);\n    int total = sum[0] + sum[1] + sum[2] + sum[3] + sum[4] + sum[5] + sum[6] + sum[7];\n\n    return total == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    __m128i open_mask = _mm_set1_epi8('<');\n    __m128i close_mask = _mm_set1_epi8('>');\n    __m128i count = _mm_setzero_si128();\n    \n    size_t length = brackets.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(brackets.data() + i));\n        __m128i open_count = _mm_sub_epi8(_mm_cmpeq_epi8(data, open_mask), _mm_cmpeq_epi8(data, close_mask));\n        count = _mm_add_epi8(count, open_count);\n    }\n\n    int remaining = length - i;\n    if (remaining > 0) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(brackets.data() + i));\n        __m128i open_count = _mm_sub_epi8(_mm_cmpeq_epi8(data, open_mask), _mm_cmpeq_epi8(data, close_mask));\n        count = _mm_add_epi8(count, open_count);\n    }\n\n    int16_t counts[8];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(counts), count);\n\n    int total_open = 0;\n    for (int j = 0; j < 8; ++j) {\n        total_open += counts[j];\n    }\n\n    return total_open == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false; // Length must be a multiple of 16 for SIMD processing\n    }\n\n    __m128i open = _mm_set1_epi8('(');\n    __m128i close = _mm_set1_epi8(')');\n    __m128i balance = _mm_setzero_si128();\n\n    for (int i = 0; i < length; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&brackets[i]));\n        __m128i is_open = _mm_cmpeq_epi8(chunk, open);\n        __m128i is_close = _mm_cmpeq_epi8(chunk, close);\n\n        __m128i open_count = _mm_and_si128(is_open, _mm_set1_epi8(1));\n        __m128i close_count = _mm_and_si128(is_close, _mm_set1_epi8(1));\n\n        balance = _mm_add_epi8(balance, open_count);\n        balance = _mm_sub_epi8(balance, close_count);\n    }\n\n    // Horizontal sum of the balance vector\n    balance = _mm_hadd_epi16(balance, balance);\n    balance = _mm_hadd_epi16(balance, balance);\n    balance = _mm_hadd_epi16(balance, balance);\n\n    int final_balance = _mm_cvtsi128_si32(balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false; // Length must be a multiple of 16 for SIMD processing\n    }\n\n    __m128i open_mask = _mm_set1_epi8('(');\n    __m128i close_mask = _mm_set1_epi8(')');\n    __m128i balance = _mm_setzero_si128();\n\n    for (int i = 0; i < length; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(brackets.c_str() + i));\n        __m128i open_count = _mm_sub_epi8(_mm_cmpeq_epi8(chunk, open_mask), _mm_set1_epi8(0));\n        __m128i close_count = _mm_sub_epi8(_mm_cmpeq_epi8(chunk, close_mask), _mm_set1_epi8(0));\n        balance = _mm_add_epi8(balance, _mm_sub_epi8(open_count, close_count));\n    }\n\n    int16_t result[8];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(result), balance);\n\n    int total_balance = 0;\n    for (int j = 0; j < 8; ++j) {\n        total_balance += result[j];\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false; // Length must be a multiple of 16 for SIMD processing\n    }\n\n    __m128i open_bracket = _mm_set1_epi8('(');\n    __m128i close_bracket = _mm_set1_epi8(')');\n    __m128i count = _mm_setzero_si128();\n\n    for (int i = 0; i < length; i += 16) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&brackets[i]));\n        __m128i is_open = _mm_cmpeq_epi8(data, open_bracket);\n        __m128i is_close = _mm_cmpeq_epi8(data, close_bracket);\n\n        count = _mm_add_epi8(count, _mm_sub_epi8(is_open, is_close));\n    }\n\n    // Horizontal sum of the count vector\n    count = _mm_hadd_epi16(count, count);\n    count = _mm_hadd_epi16(count, count);\n    count = _mm_hadd_epi16(count, count);\n\n    int total = _mm_extract_epi16(count, 0) + _mm_extract_epi16(count, 1);\n    return total == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false; // Length must be a multiple of 16 for SIMD processing\n    }\n\n    __m128i balance = _mm_setzero_si128();\n    for (int i = 0; i < length; i += 16) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(brackets.c_str() + i));\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8(')'));\n        \n        balance = _mm_add_epi8(balance, _mm_sub_epi8(open_mask, close_mask));\n    }\n\n    int16_t result[8];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(result), balance);\n    \n    int total_balance = 0;\n    for (int j = 0; j < 8; ++j) {\n        total_balance += result[j];\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false; // Length must be a multiple of 16 for SIMD processing\n    }\n\n    __m128i open_bracket = _mm_set1_epi8('(');\n    __m128i close_bracket = _mm_set1_epi8(')');\n    __m128i balance = _mm_setzero_si128();\n\n    for (int i = 0; i < length; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&brackets[i]));\n        __m128i is_open = _mm_cmpeq_epi8(chunk, open_bracket);\n        __m128i is_close = _mm_cmpeq_epi8(chunk, close_bracket);\n\n        balance = _mm_add_epi8(balance, _mm_sub_epi8(is_open, is_close));\n    }\n\n    int total_balance = 0;\n    for (int i = 0; i < 16; ++i) {\n        total_balance += _mm_extract_epi8(balance, i);\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    size_t new_size = n > 1 ? n - 1 : 0;\n    std::vector<float> result(new_size);\n\n    if (n < 2) {\n        return result;\n    }\n\n    __m128 coeffs, indices;\n    for (size_t i = 1; i < n; i += 4) {\n        coeffs = _mm_loadu_ps(&xs[i - 1]);\n        indices = _mm_set_ps(i + 3, i + 2, i + 1, i);\n        indices = _mm_sub_ps(indices, _mm_set1_ps(1.0f));\n        coeffs = _mm_mul_ps(coeffs, indices);\n        _mm_storeu_ps(&result[i - 1], coeffs);\n    }\n\n    for (size_t i = n - 1; i < new_size; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i;\n\n    __m128 coeffs, indices, result_vec;\n\n    for (i = 0; i + 4 <= n; i += 4) {\n        coeffs = _mm_loadu_ps(&xs[i + 1]); // Load coefficients for x^1, x^2, x^3, x^4\n        indices = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f); // Set indices 1, 2, 3, 4\n        result_vec = _mm_mul_ps(coeffs, indices); // Multiply coefficients by their indices\n        _mm_storeu_ps(&result[i], result_vec); // Store the result\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i;\n\n    __m128 coeffs, indices, result_vec;\n\n    for (i = 0; i + 4 <= n; i += 4) {\n        coeffs = _mm_loadu_ps(&xs[i + 1]); // Load coefficients for x^1, x^2, x^3, x^4\n        indices = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f); // Set indices 1, 2, 3, 4\n        result_vec = _mm_mul_ps(coeffs, indices); // Multiply coefficients by their respective indices\n        _mm_storeu_ps(&result[i], result_vec); // Store the result\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n < 2) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i;\n\n    __m128 coeffs, indices, result_vec;\n\n    for (i = 0; i + 4 <= n; i += 4) {\n        coeffs = _mm_loadu_ps(&xs[i + 1]); // Load coefficients for x^1, x^2, x^3, x^4\n        indices = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f); // Set indices for derivative calculation\n        result_vec = _mm_mul_ps(coeffs, indices); // Multiply coefficients by their respective indices\n        _mm_storeu_ps(&result[i], result_vec); // Store the result\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0);\n    \n    if (n <= 1) return result;\n\n    __m128 coeffs;\n    __m128 indices;\n    __m128 multiplier;\n\n    for (size_t i = 1; i < n; i += 4) {\n        coeffs = _mm_loadu_ps(&xs[i - 1]);\n        indices = _mm_set_ps(i + 3, i + 2, i + 1, i);\n        multiplier = _mm_cvtepi32_ps(_mm_cvttps_epi32(indices));\n        multiplier = _mm_mul_ps(coeffs, multiplier);\n        _mm_storeu_ps(&result[i - 1], multiplier);\n    }\n\n    for (size_t i = n - (n % 4); i < n; ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    __m128i vowels = _mm_setr_epi8('u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u');\n    __m128i y_char = _mm_set1_epi8('y');\n    __m128i end_y = _mm_set1_epi8(0);\n    int count = 0;\n\n    for (size_t i = 0; i < s.length(); i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp_vowels = _mm_cmpeq_epi8(input, vowels);\n        __m128i cmp_y = _mm_cmpeq_epi8(input, y_char);\n        \n        // Count vowels\n        int vowel_count = _mm_movemask_epi8(cmp_vowels);\n        count += __builtin_popcount(vowel_count);\n\n        // Check if 'y' is at the end\n        if (i + 15 >= s.length() && s.length() > 0 && s[s.length() - 1] == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    __m128i vowels = _mm_setr_epi8('u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'y');\n    __m128i mask = _mm_set1_epi8(0xFF);\n    int count = 0;\n\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp = _mm_cmpeq_epi8(input, vowels);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(cmp));\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (i == length - 1 && c == 'y')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    __m128i vowels = _mm_setr_epi8('u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u');\n    __m128i count_mask = _mm_set1_epi8(1);\n    int count = 0;\n\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp = _mm_cmpeq_epi8(input, vowels);\n        __m128i sum = _mm_hadd_epi16(cmp, cmp);\n        sum = _mm_hadd_epi16(sum, sum);\n        sum = _mm_hadd_epi16(sum, sum);\n        count += _mm_cvtsi128_si32(sum);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (i == length - 1 && c == 'y')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    __m128i vowels = _mm_setr_epi8('u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u');\n    __m128i count_mask = _mm_set1_epi8(1);\n    int count = 0;\n\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp = _mm_cmpeq_epi8(input, vowels);\n        __m128i sum = _mm_hadd_epi16(cmp, cmp);\n        sum = _mm_hadd_epi16(sum, sum);\n        count += _mm_cvtsi128_si32(sum);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (i == length - 1 && c == 'y')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    __m128i vowels = _mm_setr_epi8('u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u', 'o', 'i', 'e', 'a', 'u');\n    __m128i count_mask = _mm_set1_epi8(1);\n    __m128i total_count = _mm_setzero_si128();\n    \n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp = _mm_cmpeq_epi8(input, vowels);\n        total_count = _mm_add_epi8(total_count, cmp);\n    }\n\n    // Handle remaining characters\n    int remaining = length - i;\n    if (remaining > 0) {\n        __m128i input = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp = _mm_cmpeq_epi8(input, vowels);\n        total_count = _mm_add_epi8(total_count, cmp);\n        \n        // Count remaining characters manually\n        for (int j = 0; j < remaining; j++) {\n            char c = s[i + j];\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (j == remaining - 1 && (c == 'y' || c == 'Y'))) {\n                total_count = _mm_add_epi8(total_count, count_mask);\n            }\n        }\n    }\n\n    // Sum the counts\n    total_count = _mm_hadd_epi16(total_count, total_count);\n    total_count = _mm_hadd_epi16(total_count, total_count);\n    total_count = _mm_hadd_epi16(total_count, total_count);\n    \n    return _mm_cvtsi128_si32(total_count);\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    __m128i sum = _mm_setzero_si128();\n    int total = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        __m128i upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('A' - 1));\n        __m128i lower_mask = _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), chars);\n        __m128i is_upper = _mm_and_si128(upper_mask, lower_mask);\n\n        chars = _mm_and_si128(chars, is_upper);\n        sum = _mm_add_epi8(sum, chars);\n    }\n\n    // Horizontal sum of the 16-byte sum\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    \n    total += _mm_cvtsi128_si32(sum);\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            total += static_cast<int>(s[i]);\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    __m128i sum = _mm_setzero_si128();\n    int total = 0;\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        __m128i chars = _mm_setzero_si128();\n        if (i + 16 <= s.size()) {\n            chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        } else {\n            for (size_t j = 0; j < 16 && i + j < s.size(); ++j) {\n                chars[j] = s[i + j];\n            }\n        }\n\n        __m128i mask = _mm_and_si128(chars, _mm_set1_epi8(0xDF)); // Convert to uppercase\n        __m128i is_upper = _mm_and_si128(mask, _mm_cmpgt_epi8(mask, _mm_set1_epi8('A' - 1)));\n        is_upper = _mm_and_si128(is_upper, _mm_cmplt_epi8(mask, _mm_set1_epi8('Z' + 1)));\n\n        __m128i ascii_sum = _mm_and_si128(is_upper, chars);\n        sum = _mm_add_epi8(sum, ascii_sum);\n    }\n\n    // Horizontal sum of the 16-byte sum\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    \n    total += _mm_extract_epi16(sum, 0);\n    total += _mm_extract_epi16(sum, 1);\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    __m128i sum = _mm_setzero_si128();\n    int length = s.length();\n    int i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('A' - 1));\n        __m128i lower_mask = _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), chars);\n        __m128i is_upper = _mm_and_si128(upper_mask, lower_mask);\n\n        chars = _mm_and_si128(chars, is_upper);\n        sum = _mm_add_epi8(sum, chars);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum = _mm_add_epi8(sum, _mm_set1_epi8(s[i]));\n        }\n    }\n\n    // Horizontal sum of the 16 bytes in sum\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n\n    return _mm_cvtsi128_si32(sum);\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    __m128i sum = _mm_setzero_si128();\n    int total = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i mask_upper = _mm_cmpgt_epi8(chars, _mm_set1_epi8('A' - 1));\n        __m128i mask_lower = _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), chars);\n        __m128i mask = _mm_and_si128(mask_upper, mask_lower);\n        __m128i ascii_values = _mm_and_si128(chars, mask);\n        sum = _mm_add_epi8(sum, ascii_values);\n    }\n\n    // Horizontal sum of the 16-byte sum\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    total += _mm_cvtsi128_si32(sum);\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            total += static_cast<int>(s[i]);\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    __m128i sum = _mm_setzero_si128();\n    int total = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('A' - 1));\n        __m128i mask2 = _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), chars);\n        __m128i upper = _mm_and_si128(mask, mask2);\n        __m128i ascii_values = _mm_and_si128(chars, upper);\n        sum = _mm_add_epi8(sum, ascii_values);\n    }\n\n    // Horizontal sum of the 16-byte sum\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    total += _mm_cvtsi128_si32(sum);\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            total += s[i];\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int size = arr.size();\n    __m128i min_even = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i min_index = _mm_set1_epi32(-1);\n    __m128i zero = _mm_setzero_si128();\n\n    for (int i = 0; i < size; i += 4) {\n        __m128i values = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&arr[i]));\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        __m128i is_even = _mm_and_si128(_mm_cmpeq_epi32(_mm_and_si128(values, _mm_set1_epi32(1)), zero), values);\n        __m128i even_values = _mm_and_si128(is_even, values);\n\n        // Compare even values with current minimum\n        __m128i mask = _mm_cmplt_epi32(even_values, min_even);\n        min_even = _mm_blendv_epi8(min_even, even_values, mask);\n        min_index = _mm_blendv_epi8(min_index, indices, mask);\n\n        // Handle case where we have equal minimums\n        __m128i equal_mask = _mm_cmpeq_epi32(even_values, min_even);\n        min_index = _mm_blendv_epi8(min_index, indices, _mm_and_si128(equal_mask, _mm_cmpgt_epi32(indices, min_index)));\n    }\n\n    int result[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(result), min_even);\n    int smallest_value = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int j = 0; j < 4; ++j) {\n        if (result[j] < smallest_value) {\n            smallest_value = result[j];\n            smallest_index = _mm_extract_epi32(min_index, j);\n        }\n    }\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int size = arr.size();\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    __m128i min_even_vec = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i min_index_vec = _mm_set1_epi32(-1);\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128i values = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&arr[i]));\n        __m128i even_mask = _mm_and_si128(values, _mm_set1_epi32(1)); // Mask for even numbers\n        __m128i is_even = _mm_cmpeq_epi32(even_mask, _mm_setzero_si128());\n\n        // Replace odd values with max int\n        values = _mm_blendv_epi8(values, _mm_set1_epi32(std::numeric_limits<int>::max()), is_even);\n\n        // Compare with current minimum even value\n        min_even_vec = _mm_min_epi32(min_even_vec, values);\n        \n        // Update indices\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i index_mask = _mm_cmpeq_epi32(values, min_even_vec);\n        min_index_vec = _mm_blendv_epi8(min_index_vec, indices, index_mask);\n    }\n\n    // Store results\n    int min_even_arr[4], min_index_arr[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_even_arr), min_even_vec);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_index_arr), min_index_vec);\n\n    // Find the smallest even value and its index\n    for (int j = 0; j < 4; ++j) {\n        if (min_even_arr[j] < min_even) {\n            min_even = min_even_arr[j];\n            min_index = min_index_arr[j];\n        }\n    }\n\n    if (min_even == std::numeric_limits<int>::max()) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    const int size = arr.size();\n    const int simd_size = 4; // SSE can process 4 integers at a time\n    __m128i min_even = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i min_index = _mm_set1_epi32(-1);\n    __m128i zero = _mm_setzero_si128();\n\n    for (int i = 0; i < size; i += simd_size) {\n        __m128i values = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&arr[i]));\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        // Create a mask for even numbers\n        __m128i is_even = _mm_and_si128(values, _mm_set1_epi32(1));\n        is_even = _mm_cmpeq_epi32(is_even, zero);\n\n        // Select even values and their indices\n        __m128i even_values = _mm_and_si128(values, is_even);\n        __m128i even_indices = _mm_and_si128(indices, is_even);\n\n        // Compare with current minimum\n        for (int j = 0; j < simd_size; ++j) {\n            int value = _mm_extract_epi32(even_values, j);\n            if (value != 0) {\n                int index = _mm_extract_epi32(even_indices, j);\n                if (value < _mm_extract_epi32(min_even, 0) || \n                    (value == _mm_extract_epi32(min_even, 0) && index < _mm_extract_epi32(min_index, 0))) {\n                    min_even = _mm_set1_epi32(value);\n                    min_index = _mm_set1_epi32(index);\n                }\n            }\n        }\n    }\n\n    int smallest_value = _mm_extract_epi32(min_even, 0);\n    int smallest_index = _mm_extract_epi32(min_index, 0);\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int size = arr.size();\n    __m128i min_even = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i min_index = _mm_set1_epi32(-1);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        \n        __m128i even_mask = _mm_and_si128(values, _mm_set1_epi32(1));\n        __m128i is_even = _mm_cmpeq_epi32(even_mask, zero);\n        \n        __m128i even_values = _mm_and_si128(values, is_even);\n        \n        // Compare even values with current minimum\n        __m128i mask = _mm_cmplt_epi32(even_values, min_even);\n        min_even = _mm_blendv_epi8(min_even, even_values, mask);\n        min_index = _mm_blendv_epi8(min_index, indices, mask);\n        \n        // Handle case where we have equal minimums\n        __m128i equal_mask = _mm_cmpeq_epi32(even_values, min_even);\n        __m128i current_indices = _mm_blendv_epi8(min_index, indices, equal_mask);\n        min_index = _mm_blendv_epi8(min_index, current_indices, mask);\n    }\n\n    // Extract results\n    int min_even_arr[4], min_index_arr[4];\n    _mm_storeu_si128((__m128i*)min_even_arr, min_even);\n    _mm_storeu_si128((__m128i*)min_index_arr, min_index);\n    \n    int smallest_value = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int j = 0; j < 4; ++j) {\n        if (min_even_arr[j] < smallest_value) {\n            smallest_value = min_even_arr[j];\n            smallest_index = min_index_arr[j];\n        } else if (min_even_arr[j] == smallest_value && min_index_arr[j] < smallest_index) {\n            smallest_index = min_index_arr[j];\n        }\n    }\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n    \n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int size = arr.size();\n    __m128i min_even = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i min_index = _mm_set1_epi32(-1);\n    __m128i zero = _mm_setzero_si128();\n\n    for (int i = 0; i < size; i += 4) {\n        __m128i values = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&arr[i]));\n        __m128i even_mask = _mm_and_si128(values, _mm_set1_epi32(1)); // mask for even numbers\n        __m128i is_even = _mm_cmpeq_epi32(even_mask, zero); // check if even\n\n        // Store indices\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        // Update min_even and min_index\n        for (int j = 0; j < 4; ++j) {\n            int value = arr[i + j];\n            if (value % 2 == 0 && value < _mm_extract_epi32(min_even, 0)) {\n                min_even = _mm_set1_epi32(value);\n                min_index = _mm_set1_epi32(i + j);\n            }\n        }\n    }\n\n    int smallest_value = _mm_extract_epi32(min_even, 0);\n    int smallest_index = _mm_extract_epi32(min_index, 0);\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint search_simd(std::vector<int> lst) {\n    const int max_value = 100; // Assuming the maximum value in the input is 100\n    int frequency[max_value + 1] = {0};\n\n    // Count frequencies using SIMD\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        vec = _mm_min_epi32(vec, _mm_set1_epi32(max_value)); // Clamp to max_value\n        _mm_storeu_si128((__m128i*)&frequency[0], _mm_add_epi32(_mm_loadu_si128((__m128i*)&frequency[0]), vec));\n    }\n\n    // Handle remaining integers\n    for (; i < size; ++i) {\n        if (lst[i] <= max_value) {\n            frequency[lst[i]]++;\n        }\n    }\n\n    // Find the greatest integer with the required frequency\n    for (int j = max_value; j > 0; --j) {\n        if (frequency[j] >= j) {\n            return j;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint search_simd(std::vector<int> lst) {\n    const int max_value = 100; // Assuming a reasonable upper limit for the values in lst\n    int frequency[max_value + 1] = {0};\n\n    // Count frequencies using SIMD\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            int value = _mm_extract_epi32(vec, j);\n            if (value > 0 && value <= max_value) {\n                frequency[value]++;\n            }\n        }\n    }\n\n    // Process remaining integers\n    for (; i < size; i++) {\n        int value = lst[i];\n        if (value > 0 && value <= max_value) {\n            frequency[value]++;\n        }\n    }\n\n    // Find the greatest integer that meets the condition\n    for (int j = max_value; j > 0; j--) {\n        if (frequency[j] >= j) {\n            return j;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint search_simd(std::vector<int> lst) {\n    const int max_value = 100; // Assuming the maximum value in the input vector\n    int frequency[max_value + 1] = {0};\n\n    // Count frequencies using SIMD\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        vec = _mm_min_epi32(vec, _mm_set1_epi32(max_value)); // Clamp values to max_value\n        _mm_storeu_si128((__m128i*)&frequency[0], _mm_add_epi32(_mm_loadu_si128((__m128i*)&frequency[0]), vec));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] <= max_value) {\n            frequency[lst[i]]++;\n        }\n    }\n\n    // Find the greatest integer with the required frequency\n    for (int j = max_value; j > 0; --j) {\n        if (frequency[j] >= j) {\n            return j;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint search_simd(std::vector<int> lst) {\n    const int max_value = 100; // Assuming the maximum integer value in the input\n    int frequency[max_value + 1] = {0};\n\n    // Count frequencies using SIMD\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        for (int j = 0; j < 4; ++j) {\n            int value = _mm_extract_epi32(vec, j);\n            if (value > 0 && value <= max_value) {\n                frequency[value]++;\n            }\n        }\n    }\n\n    // Process remaining integers\n    for (; i < size; ++i) {\n        int value = lst[i];\n        if (value > 0 && value <= max_value) {\n            frequency[value]++;\n        }\n    }\n\n    // Find the greatest integer with the required frequency\n    for (int j = max_value; j > 0; --j) {\n        if (frequency[j] >= j) {\n            return j;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    std::unordered_map<int, int> frequency;\n\n    // Count frequencies using SIMD\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        for (int j = 0; j < 4; ++j) {\n            int value = _mm_extract_epi32(vec, j);\n            if (value > 0) {\n                frequency[value]++;\n            }\n        }\n    }\n\n    int result = -1;\n    for (const auto& pair : frequency) {\n        int value = pair.first;\n        int count = pair.second;\n        if (value <= count && value > result) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i balanced_vec = _mm_set1_epi32(1);\n    \n    for (int i = 0; i < n / 4; i++) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&q[i * 4]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n        \n        // Check for palindromic property\n        __m128i rev_vec = _mm_shuffle_epi32(vec, _MM_SHUFFLE(0, 1, 2, 3));\n        balanced_vec = _mm_and_si128(balanced_vec, _mm_cmpeq_epi32(vec, rev_vec));\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; i++) {\n        sum_vec = _mm_add_epi32(sum_vec, _mm_set1_epi32(q[i]));\n    }\n\n    // Sum the elements in sum_vec\n    int sum[4];\n    _mm_storeu_si128((__m128i*)sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Check if balanced\n    int balanced = _mm_movemask_epi8(balanced_vec);\n    bool is_balanced = (balanced == 0xFFFF) || (n == 1);\n\n    return is_balanced && (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is balanced (palindromic)\n    bool balanced = true;\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            balanced = false;\n            break;\n        }\n    }\n\n    if (!balanced) return false;\n\n    // Calculate the sum using SIMD\n    __m128i sum_vec = _mm_setzero_si128();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&q[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    int sum = _mm_cvtsi128_si32(sum_vec) + _mm_cvtsi128_si32(_mm_srli_si128(sum_vec, 4)) +\n              _mm_cvtsi128_si32(_mm_srli_si128(sum_vec, 8)) + _mm_cvtsi128_si32(_mm_srli_si128(sum_vec, 12));\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i balanced_vec = _mm_set1_epi32(1); // Assume balanced initially\n\n    for (int i = 0; i < n / 4; i++) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&q[i * 4]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n        __m128i reversed_vec = _mm_shuffle_epi32(vec, _MM_SHUFFLE(0, 1, 2, 3));\n        balanced_vec = _mm_and_si128(balanced_vec, _mm_cmpeq_epi32(vec, reversed_vec));\n    }\n\n    // Handle remaining elements\n    for (int i = n / 4 * 4; i < n; i++) {\n        sum_vec = _mm_add_epi32(sum_vec, _mm_set1_epi32(q[i]));\n        if (q[i] != q[n - 1 - (i - n / 4 * 4)]) {\n            balanced_vec = _mm_setzero_si128();\n        }\n    }\n\n    int sum[4];\n    _mm_storeu_si128((__m128i*)sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    int balanced = _mm_movemask_epi8(balanced_vec);\n    bool is_balanced = (balanced != 0);\n\n    return is_balanced && (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check for palindromic property\n    __m128i is_palindrome = _mm_set1_epi32(1);\n    for (int i = 0; i < n / 2; ++i) {\n        __m128i left = _mm_set1_epi32(q[i]);\n        __m128i right = _mm_set1_epi32(q[n - 1 - i]);\n        is_palindrome = _mm_and_si128(is_palindrome, _mm_cmpeq_epi32(left, right));\n    }\n\n    // Sum elements using SIMD\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&q[i]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Horizontal sum\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    int sum = _mm_cvtsi128_si32(sum_vec);\n\n    // Check conditions\n    return (_mm_movemask_epi8(is_palindrome) != 0 && sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i is_palindrome = _mm_set1_epi32(1);\n    \n    for (int i = 0; i < n / 4; i++) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&q[i * 4]);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n        \n        __m128i rev_vec = _mm_loadu_si128((__m128i*)&q[n - 4 - i * 4]);\n        is_palindrome = _mm_and_si128(is_palindrome, _mm_cmpeq_epi32(vec, rev_vec));\n    }\n\n    if (n % 4 != 0) {\n        for (int i = n - (n % 4); i < n; i++) {\n            sum_vec = _mm_add_epi32(sum_vec, _mm_set1_epi32(q[i]));\n            if (q[i] != q[n - 1 - (i - (n - (n % 4)))]) {\n                is_palindrome = _mm_setzero_si128();\n            }\n        }\n    }\n\n    int sum[4];\n    _mm_storeu_si128((__m128i*)sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    int palindrome_flag = _mm_movemask_epi8(is_palindrome);\n    bool balanced = (palindrome_flag != 0);\n\n    return balanced && (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 1 - i]);\n\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        int mask = _mm_movemask_epi8(cmp);\n\n        changes += __builtin_popcount(~mask & 0xFFFF); // Count mismatches\n    }\n\n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]) ? 1 : 0; // Middle element check for odd length\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 1 - i]);\n        \n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        changes += 4 - __builtin_popcount(mask);\n    }\n    \n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 1 - i]);\n\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        int mask = _mm_movemask_epi8(cmp);\n\n        changes += 4 - __builtin_popcount(mask);\n    }\n\n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]) ? 1 : 0;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 1 - i]);\n\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        int mask = _mm_movemask_epi8(cmp);\n\n        changes += 4 - __builtin_popcount(mask);\n    }\n\n    // Handle the case where n is odd\n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 1 - i]);\n\n        // Compare left and right elements\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        // Count the number of equal pairs\n        int mask = _mm_movemask_epi8(cmp);\n        changes += 4 - __builtin_popcount(mask);\n    }\n\n    // Handle the case where n is odd\n    if (n % 2 != 0) {\n        changes += (arr[n / 2] != arr[n / 2]);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total length of strings in lst1\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n\n    // Calculate total length of strings in lst2\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    size_t size1 = lst1.size();\n    size_t size2 = lst2.size();\n\n    // Calculate total characters in lst1\n    for (size_t i = 0; i < size1; ++i) {\n        total1 += lst1[i].size();\n    }\n\n    // Calculate total characters in lst2\n    for (size_t i = 0; i < size2; ++i) {\n        total2 += lst2[i].size();\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n\n    // Calculate total characters in lst1\n    for (const auto& str : lst1) {\n        total1 += str.size();\n    }\n\n    // Calculate total characters in lst2\n    for (const auto& str : lst2) {\n        total2 += str.size();\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n;\n    if (x < 1) return false;\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (int i = 0; i < 64; i++) {\n        result = _mm_mullo_epi64(result, n_vec);\n        __m128i cmp = _mm_cmpgt_epi64(result, x_vec);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            break;\n        }\n        if (_mm_cmpeq_epi64(result, x_vec).m128i_i64[0] != 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n; // n must be greater than 1 for valid power checks\n    if (x < 1) return false; // x must be at least 1\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (int i = 0; i < 64; i++) {\n        if (_mm_cvtsi128_si64(result) == x) return true;\n        result = _mm_mullo_epi64(result, n_vec);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n;\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i power_vec = _mm_set1_epi64x(1);\n    \n    for (int i = 0; i < 64; i++) {\n        if (_mm_cvtsi128_si64(power_vec) == x) {\n            return true;\n        }\n        power_vec = _mm_mullo_epi64(power_vec, n_vec);\n        if (_mm_cvtsi128_si64(power_vec) > x) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cstdint>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x < n) return false;\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (int i = 0; i < 64; ++i) {\n        result = _mm_mullo_epi64(result, n_vec);\n        __m128i cmp = _mm_cmpeq_epi64(result, x_vec);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n        if (_mm_cmpgt_epi64(result, x_vec) != _mm_setzero_si128()) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == n;\n    if (x < 1) return false;\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (int i = 0; i < 64; i++) {\n        result = _mm_mullo_epi64(result, n_vec);\n        __m128i cmp = _mm_cmpeq_epi64(result, x_vec);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return true;\n        }\n        if (_mm_cmpgt_epi64(result, x_vec)[0] != 0) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const __m128i primes_mask = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF);\n    const __m128i hex_digits = _mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F');\n    const __m128i prime_digits = _mm_setr_epi8(0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0); // 2, 3, 5, 7, B, D\n\n    int count = 0;\n    size_t length = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(num.c_str() + i));\n        __m128i cmp = _mm_cmpeq_epi8(input, hex_digits);\n        __m128i mask = _mm_and_si128(cmp, prime_digits);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n    }\n\n    for (; i < length; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const __m128i primes = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const __m128i hex_values = _mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F');\n    const __m128i prime_mask = _mm_setr_epi8(0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0); // 2, 3, 5, 7, B, D\n\n    int count = 0;\n    size_t length = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(num.c_str() + i));\n        __m128i cmp = _mm_cmpeq_epi8(input, hex_values);\n        __m128i prime_count = _mm_and_si128(cmp, prime_mask);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(prime_count));\n    }\n\n    for (; i < length; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const __m128i primes_mask = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF);\n    const __m128i hex_digits = _mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 0);\n    const __m128i prime_digits = _mm_setr_epi8(0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0);\n    \n    int count = 0;\n    size_t length = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(num.data() + i));\n        __m128i cmp = _mm_cmpeq_epi8(input, hex_digits);\n        __m128i prime_check = _mm_and_si128(cmp, prime_digits);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(prime_check));\n    }\n\n    for (; i < length; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const __m128i primes_mask = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF); // Mask for prime hex digits\n    const __m128i hex_values = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15); // Hex values\n    const __m128i prime_digits = _mm_setr_epi8(0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0); // Prime indicator for 0-F\n\n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(num.data() + i));\n        __m128i hex_mask = _mm_and_si128(input, _mm_set1_epi8(0x0F)); // Mask to get lower 4 bits\n        __m128i prime_check = _mm_shuffle_epi8(prime_digits, hex_mask); // Shuffle to get prime indicators\n        count += _mm_popcnt_u32(_mm_movemask_epi8(prime_check)); // Count the number of primes\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = num[i];\n        if ((c == '2') || (c == '3') || (c == '5') || (c == '7') || (c == 'B') || (c == 'D')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const __m128i primes = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const __m128i hex_values = _mm_setr_epi8('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F');\n    const __m128i prime_mask = _mm_setr_epi8(0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0); // 2, 3, 5, 7, B, D\n\n    int count = 0;\n    size_t length = num.length();\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        __m128i cmp = _mm_cmpeq_epi8(input, hex_values);\n        __m128i prime_check = _mm_and_si128(cmp, prime_mask);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(prime_check));\n    }\n\n    for (; i < length; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t length = s.length();\n    __m128i distinct_mask = _mm_set1_epi8(0xFF);\n    \n    for (size_t i = 0; i <= length - 3; i += 3) {\n        __m128i chars = _mm_set_epi8(s[i + 2], s[i + 1], s[i], 0, 0, 0, 0, 0);\n        __m128i cmp1 = _mm_cmpeq_epi8(chars, _mm_shuffle_epi32(chars, _MM_SHUFFLE(0, 0, 1, 2)));\n        __m128i cmp2 = _mm_cmpeq_epi8(chars, _mm_shuffle_epi32(chars, _MM_SHUFFLE(0, 1, 2, 0)));\n        __m128i cmp3 = _mm_cmpeq_epi8(chars, _mm_shuffle_epi32(chars, _MM_SHUFFLE(1, 2, 0, 0)));\n\n        __m128i distinct = _mm_and_si128(cmp1, cmp2);\n        distinct = _mm_and_si128(distinct, cmp3);\n\n        if (_mm_movemask_epi8(distinct) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t length = s.length();\n    __m128i distinct_mask = _mm_set1_epi8(0xFF);\n    \n    for (size_t i = 0; i <= length - 3; i += 3) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i cmp_mask = _mm_cmpeq_epi8(chars, _mm_shuffle_epi32(chars, _MM_SHUFFLE(0, 0, 1, 1)));\n        distinct_mask = _mm_and_si128(distinct_mask, cmp_mask);\n        \n        if (_mm_movemask_epi8(distinct_mask) != 0xFFFF) {\n            return false;\n        }\n        \n        distinct_mask = _mm_set1_epi8(0xFF); // Reset mask for next iteration\n    }\n\n    // Handle remaining characters if length is not a multiple of 3\n    for (size_t i = length - length % 3; i < length; ++i) {\n        if (i + 2 < length) {\n            if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t length = s.length();\n    __m128i prev1 = _mm_setzero_si128();\n    __m128i prev2 = _mm_setzero_si128();\n    \n    for (size_t i = 0; i <= length - 3; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        __m128i mask1 = _mm_cmpeq_epi8(current, prev1);\n        __m128i mask2 = _mm_cmpeq_epi8(current, prev2);\n        \n        if (_mm_movemask_epi8(mask1) || _mm_movemask_epi8(mask2)) {\n            return false;\n        }\n        \n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t length = s.length();\n    __m128i distinct_mask = _mm_set1_epi8(0);\n    \n    for (size_t i = 0; i <= length - 3; i += 3) {\n        __m128i chars = _mm_setr_epi8(s[i], s[i + 1], s[i + 2], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n        __m128i cmp = _mm_cmpeq_epi8(chars, distinct_mask);\n        if (_mm_movemask_epi8(cmp) != 0) {\n            return false;\n        }\n        distinct_mask = _mm_or_si128(distinct_mask, chars);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t length = s.length();\n    __m128i prev1, prev2, curr;\n    \n    for (size_t i = 0; i <= length - 3; i += 3) {\n        curr = _mm_set_epi8(s[i + 2], s[i + 1], s[i], 0, 0, 0, 0, 0);\n        \n        if (i > 0) {\n            prev1 = _mm_set_epi8(s[i - 1], s[i - 2], s[i - 3], 0, 0, 0, 0, 0);\n            prev2 = _mm_set_epi8(s[i - 2], s[i - 3], s[i - 4], 0, 0, 0, 0, 0);\n            __m128i cmp1 = _mm_cmpeq_epi8(curr, prev1);\n            __m128i cmp2 = _mm_cmpeq_epi8(curr, prev2);\n            if (_mm_movemask_epi8(cmp1) || _mm_movemask_epi8(cmp2)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    __m128i vec_length = _mm_set1_epi32(length);\n    __m128i vec_two = _mm_set1_epi32(2);\n    __m128i vec_three = _mm_set1_epi32(3);\n    __m128i vec_one = _mm_set1_epi32(1);\n    \n    __m128i cmp1 = _mm_cmpgt_epi32(vec_length, vec_one);\n    __m128i cmp2 = _mm_cmpeq_epi32(vec_length, vec_two);\n    __m128i cmp3 = _mm_cmpeq_epi32(vec_length, vec_three);\n    \n    if (_mm_movemask_epi8(cmp2) || _mm_movemask_epi8(cmp3)) {\n        return true;\n    }\n    \n    if (!_mm_movemask_epi8(cmp1)) {\n        return false;\n    }\n\n    for (int i = 5; i * i <= length; i += 6) {\n        if (length % i == 0 || length % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    __m128i lengths = _mm_set1_epi32(length);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    \n    __m128i is_prime_mask = _mm_set1_epi32(1);\n    \n    __m128i less_than_two = _mm_cmpgt_epi32(lengths, _mm_set1_epi32(1));\n    __m128i less_than_four = _mm_cmpgt_epi32(lengths, _mm_set1_epi32(3));\n    \n    // Check if length is less than 2\n    if (_mm_cvtsi128_si32(less_than_two) == 0) return false;\n    \n    // Check if length is 2 or 3\n    if (_mm_cvtsi128_si32(lengths) == 2 || _mm_cvtsi128_si32(lengths) == 3) return true;\n\n    // Check divisibility by 2 and 3\n    __m128i divisible_by_two = _mm_and_si128(_mm_eq_epi32(_mm_rem_epi32(lengths, two), _mm_setzero_si128()), less_than_four);\n    __m128i divisible_by_three = _mm_and_si128(_mm_eq_epi32(_mm_rem_epi32(lengths, three), _mm_setzero_si128()), less_than_four);\n    \n    if (_mm_cvtsi128_si32(divisible_by_two) != 0 || _mm_cvtsi128_si32(divisible_by_three) != 0) return false;\n\n    // Check for factors from 5 to sqrt(length)\n    for (int i = 5; i * i <= length; i += 6) {\n        __m128i divisor = _mm_set1_epi32(i);\n        __m128i next_divisor = _mm_set1_epi32(i + 2);\n        \n        __m128i divisible_by_i = _mm_eq_epi32(_mm_rem_epi32(lengths, divisor), _mm_setzero_si128());\n        __m128i divisible_by_next_i = _mm_eq_epi32(_mm_rem_epi32(lengths, next_divisor), _mm_setzero_si128());\n        \n        if (_mm_cvtsi128_si32(divisible_by_i) != 0 || _mm_cvtsi128_si32(divisible_by_next_i) != 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    __m128i vec_length = _mm_set1_epi32(length);\n    __m128i vec_two = _mm_set1_epi32(2);\n    __m128i vec_three = _mm_set1_epi32(3);\n    __m128i vec_length_check = _mm_cmpgt_epi32(vec_length, vec_two);\n    __m128i vec_length_check_3 = _mm_cmpgt_epi32(vec_length, vec_three);\n    \n    int mask = _mm_movemask_epi8(vec_length_check);\n    if (mask == 0) return false;\n\n    mask = _mm_movemask_epi8(vec_length_check_3);\n    if (mask == 0) return true;\n\n    if (length % 2 == 0 || length % 3 == 0) return false;\n\n    for (int i = 5; i * i <= length; i += 6) {\n        if (length % i == 0 || length % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    __m128i lengths = _mm_set1_epi32(length);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i six = _mm_set1_epi32(6);\n    \n    __m128i is_prime_mask = _mm_set1_epi32(1); // Assume true initially\n\n    // Check if length <= 1\n    __m128i less_than_two = _mm_cmplt_epi32(lengths, two);\n    is_prime_mask = _mm_andnot_si128(less_than_two, is_prime_mask);\n\n    // Check if length <= 3\n    __m128i less_than_four = _mm_cmplt_epi32(lengths, three);\n    is_prime_mask = _mm_andnot_si128(less_than_four, is_prime_mask);\n\n    // Check if divisible by 2 or 3\n    __m128i divisible_by_two = _mm_rem_epi32(lengths, two);\n    __m128i divisible_by_three = _mm_rem_epi32(lengths, three);\n    __m128i is_not_prime = _mm_or_si128(divisible_by_two, divisible_by_three);\n    is_prime_mask = _mm_andnot_si128(is_not_prime, is_prime_mask);\n\n    // Check for factors from 5 to sqrt(length)\n    for (int i = 5; i * i <= length; i += 6) {\n        __m128i factor = _mm_set1_epi32(i);\n        __m128i factor_plus_two = _mm_set1_epi32(i + 2);\n        \n        __m128i divisible_by_factor = _mm_rem_epi32(lengths, factor);\n        __m128i divisible_by_factor_plus_two = _mm_rem_epi32(lengths, factor_plus_two);\n        \n        is_not_prime = _mm_or_si128(divisible_by_factor, divisible_by_factor_plus_two);\n        is_prime_mask = _mm_andnot_si128(is_not_prime, is_prime_mask);\n    }\n\n    return _mm_movemask_epi8(is_prime_mask) != 0;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    __m128i len_vec = _mm_set1_epi32(length);\n    __m128i two_vec = _mm_set1_epi32(2);\n    __m128i three_vec = _mm_set1_epi32(3);\n    __m128i one_vec = _mm_set1_epi32(1);\n    \n    __m128i is_prime_vec = _mm_set1_epi32(1); // Assume true initially\n\n    __m128i less_than_two = _mm_cmpgt_epi32(len_vec, one_vec);\n    __m128i less_than_four = _mm_cmpgt_epi32(len_vec, three_vec);\n    \n    // Check if length is less than 2\n    if (_mm_cvtsi128_si32(less_than_two) == 0) return false;\n\n    // Check if length is 2 or 3\n    if (_mm_cvtsi128_si32(less_than_four) == 0) return true;\n\n    // Check divisibility by 2 and 3\n    __m128i divisible_by_two = _mm_rem_epi32(len_vec, two_vec);\n    __m128i divisible_by_three = _mm_rem_epi32(len_vec, three_vec);\n    \n    if (_mm_cvtsi128_si32(divisible_by_two) == 0 || _mm_cvtsi128_si32(divisible_by_three) == 0) return false;\n\n    // Check for factors from 5 to sqrt(length)\n    for (int i = 5; i * i <= length; i += 6) {\n        __m128i i_vec = _mm_set1_epi32(i);\n        __m128i i_plus_two_vec = _mm_set1_epi32(i + 2);\n        \n        __m128i divisible_by_i = _mm_rem_epi32(len_vec, i_vec);\n        __m128i divisible_by_i_plus_two = _mm_rem_epi32(len_vec, i_plus_two_vec);\n        \n        if (_mm_cvtsi128_si32(divisible_by_i) == 0 || _mm_cvtsi128_si32(divisible_by_i_plus_two) == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <string>\n#include <emmintrin.h>\n#include <nmmintrin.h>\n\nstd::string solve_simd(uint64_t N) {\n    // Initialize the sum to zero\n    __m128i sum = _mm_setzero_si128();\n    \n    // Process each byte of the 64-bit integer\n    for (int i = 0; i < 8; ++i) {\n        uint8_t byte = (N >> (i * 8)) & 0xFF;\n        // Count the number of 1s in the byte\n        __m128i count = _mm_set1_epi8(byte);\n        count = _mm_and_si128(count, _mm_set1_epi8(1));\n        sum = _mm_add_epi8(sum, count);\n    }\n\n    // Horizontal sum of the counts\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    sum = _mm_hadd_epi16(sum, sum);\n    \n    // Extract the total sum\n    int total_sum = _mm_cvtsi128_si32(sum);\n\n    // Convert the total sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary.insert(binary.begin(), (total_sum % 2) + '0');\n        total_sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    uint64_t mask = 1;\n\n    for (int i = 0; i < 64; i += 4) {\n        __m128i bits = _mm_set_epi64x((N >> (i + 2)) & 1, (N >> (i + 1)) & 1);\n        bits = _mm_or_si128(bits, _mm_set_epi64x((N >> i) & 1, 0));\n        sum = _mm_add_epi64(sum, bits);\n    }\n\n    int total_sum = _mm_cvtsi128_si64(sum);\n    \n    std::string binary_sum = std::bitset<64>(total_sum).to_string();\n    size_t pos = binary_sum.find('1');\n    return pos == std::string::npos ? \"0\" : binary_sum.substr(pos);\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    for (int i = 0; i < 64; i += 4) {\n        __m128i bits = _mm_set_epi64x((N >> (i + 2)) & 1, (N >> (i + 1)) & 1);\n        bits = _mm_add_epi64(bits, _mm_set_epi64x((N >> i) & 1, 0));\n        sum = _mm_add_epi64(sum, bits);\n    }\n    \n    int total_sum = _mm_cvtsi128_si64(sum);\n    \n    std::string binary = std::bitset<64>(total_sum).to_string();\n    return binary.substr(64 - (total_sum > 0 ? (int)log2(total_sum) + 1 : 1));\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <string>\n#include <emmintrin.h>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    __m128i count = _mm_setzero_si128();\n    uint64_t mask = 1;\n\n    for (int i = 0; i < 64; i += 4) {\n        __m128i bits = _mm_set_epi64x((N >> (i + 2)) & 1, (N >> (i + 1)) & 1);\n        bits = _mm_or_si128(bits, _mm_set_epi64x((N >> i) & 1, 0));\n        count = _mm_add_epi64(count, bits);\n    }\n\n    int total_sum = _mm_cvtsi128_si64(count);\n    \n    std::string binary;\n    while (total_sum > 0) {\n        binary.insert(binary.begin(), (total_sum % 2) + '0');\n        total_sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    __m128i count = _mm_setzero_si128();\n    for (int i = 0; i < 64; i += 4) {\n        __m128i bits = _mm_set1_epi64x(N >> i & 0xF);\n        count = _mm_add_epi32(count, _mm_popcnt_epi32(bits));\n    }\n    \n    int total = _mm_cvtsi128_si32(count);\n    std::string result = std::bitset<64>(total).to_string();\n    return result.substr(result.find('1'));\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (int i = 1; i < size; i += 4) {\n        __m128i indices = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i even_mask = _mm_and_si128(indices, _mm_set1_epi32(1)); // Mask for even numbers\n        __m128i odd_indices = _mm_and_si128(indices, _mm_set1_epi32(0xFFFFFFFE)); // Mask for odd indices\n        __m128i filtered = _mm_and_si128(indices, odd_indices);\n        \n        sum_vec = _mm_add_epi32(sum_vec, filtered);\n    }\n\n    // Horizontal sum of the vector\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    _mm_store_ss((float*)&sum, sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (int i = 1; i < size; i += 4) {\n        __m128i indices = _mm_set_epi32(\n            (i + 3 < size) ? lst[i + 3] : 0,\n            (i + 2 < size) ? lst[i + 2] : 0,\n            (i + 1 < size) ? lst[i + 1] : 0,\n            (i < size) ? lst[i] : 0\n        );\n\n        __m128i even_mask = _mm_and_si128(indices, _mm_set1_epi32(1));\n        __m128i odd_indices = _mm_cmpeq_epi32(even_mask, _mm_setzero_si128());\n        __m128i even_elements = _mm_and_si128(indices, odd_indices);\n        \n        sum_vec = _mm_add_epi32(sum_vec, even_elements);\n    }\n    \n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    \n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (int i = 1; i < size; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i values = _mm_loadu_si128((__m128i*)&lst[i - 1]);\n\n        __m128i even_mask = _mm_and_si128(values, _mm_set1_epi32(1));\n        __m128i odd_indices_mask = _mm_cmpeq_epi32(indices, _mm_set1_epi32(i));\n        __m128i result_mask = _mm_and_si128(even_mask, odd_indices_mask);\n\n        sum_vec = _mm_add_epi32(sum_vec, _mm_and_si128(values, result_mask));\n    }\n\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    _mm_store_ss((float*)&sum, sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    __m128i total = _mm_setzero_si128();\n\n    for (int i = 1; i < size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i mask = _mm_and_si128(vec, _mm_set1_epi32(1)); // mask for even numbers\n        __m128i odd_indices = _mm_set1_epi32(0xFFFFFFFF); // mask for odd indices\n        odd_indices = _mm_srli_epi32(odd_indices, 1); // shift right to align with odd indices\n        odd_indices = _mm_and_si128(odd_indices, mask); // apply mask to get even numbers at odd indices\n        total = _mm_add_epi32(total, odd_indices);\n    }\n\n    int result[4];\n    _mm_storeu_si128((__m128i*)result, total);\n    for (int j = 0; j < 4; j++) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (int i = 1; i < size; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i values = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        __m128i even_mask = _mm_and_si128(values, _mm_set1_epi32(1));\n        __m128i odd_indices_mask = _mm_cmpeq_epi32(indices, _mm_set1_epi32(1));\n        \n        __m128i filtered = _mm_and_si128(values, even_mask);\n        sum_vec = _mm_add_epi32(sum_vec, filtered);\n    }\n    \n    int result[4];\n    _mm_storeu_si128((__m128i*)result, sum_vec);\n    \n    for (int j = 0; j < 4; j++) {\n        sum += result[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(2); // Set the shift value to 2\n    __m128i base = _mm_set1_epi8('a'); // Base for lowercase letters\n    __m128i range = _mm_set1_epi8(26); // Range for alphabet\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        __m128i mask = _mm_cmpgt_epi8(input, _mm_set1_epi8('z')); // Check for characters > 'z'\n        input = _mm_sub_epi8(input, _mm_set1_epi8('a')); // Normalize to 0-25 range\n        input = _mm_add_epi8(input, shift); // Shift by 2\n        input = _mm_and_si128(input, _mm_set1_epi8(0x1F)); // Wrap around using modulo 26\n        input = _mm_add_epi8(input, base); // Convert back to ASCII\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), input);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = (c - 'a' + 2) % 26 + 'a';\n        } else {\n            result[i] = c; // Non-alphabet characters remain unchanged\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    const __m128i shift = _mm_set1_epi8(2);\n    const __m128i base = _mm_set1_epi8('a');\n    const __m128i upper_limit = _mm_set1_epi8('z' + 1);\n    \n    size_t i = 0;\n    for (; i + 16 <= s.size(); i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        __m128i mask = _mm_and_si128(_mm_cmpgt_epi8(input, base), _mm_cmplt_epi8(input, upper_limit));\n        __m128i rotated = _mm_add_epi8(input, shift);\n        rotated = _mm_and_si128(rotated, mask);\n        rotated = _mm_or_si128(rotated, _mm_andnot_si128(mask, input));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), rotated);\n    }\n    \n    for (; i < s.size(); ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = (c - 'a' + 2) % 26 + 'a';\n        } else {\n            result[i] = c;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t len = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(2); // Set the shift value\n    __m128i base = _mm_set1_epi8('a'); // Base for lowercase letters\n    __m128i range = _mm_set1_epi8(26); // Range for alphabet\n\n    for (; i + 16 <= len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        __m128i mask = _mm_cmpgt_epi8(input, _mm_set1_epi8('z')); // Check for overflow\n        input = _mm_sub_epi8(input, _mm_set1_epi8('a')); // Normalize to 0-25\n        input = _mm_add_epi8(input, shift); // Shift by 2\n        input = _mm_and_si128(input, _mm_set1_epi8(0x1F)); // Wrap around using modulo 26\n        input = _mm_add_epi8(input, base); // Normalize back to 'a'-'z'\n        input = _mm_or_si128(input, _mm_and_si128(mask, _mm_set1_epi8(' '))); // Handle overflow\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), input);\n    }\n\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = (c - 'a' + 2) % 26 + 'a';\n        } else {\n            result[i] = c; // Non-alphabet characters remain unchanged\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(2); // Set the shift value to 2\n    __m128i base = _mm_set1_epi8('a'); // Base for lowercase letters\n    __m128i upper_base = _mm_set1_epi8('A'); // Base for uppercase letters\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        __m128i mask_lower = _mm_and_si128(_mm_cmpgt_epi8(input, base), _mm_cmplt_epi8(input, _mm_add_epi8(base, _mm_set1_epi8(26))));\n        __m128i mask_upper = _mm_and_si128(_mm_cmpgt_epi8(input, upper_base), _mm_cmplt_epi8(input, _mm_add_epi8(upper_base, _mm_set1_epi8(26))));\n\n        // Rotate lowercase letters\n        __m128i lower_shifted = _mm_add_epi8(input, shift);\n        lower_shifted = _mm_sub_epi8(lower_shifted, _mm_and_si128(mask_lower, _mm_set1_epi8(26)));\n\n        // Rotate uppercase letters\n        __m128i upper_shifted = _mm_add_epi8(input, shift);\n        upper_shifted = _mm_sub_epi8(upper_shifted, _mm_and_si128(mask_upper, _mm_set1_epi8(26)));\n\n        // Select the shifted values based on the masks\n        __m128i result_chars = _mm_or_si128(_mm_and_si128(mask_lower, lower_shifted), _mm_andnot_si128(mask_lower, input));\n        result_chars = _mm_or_si128(_mm_and_si128(mask_upper, upper_shifted), _mm_andnot_si128(mask_upper, result_chars));\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), result_chars);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = (c - 'a' + 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = (c - 'A' + 2) % 26 + 'A';\n        } else {\n            result[i] = c;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t length = s.size();\n    size_t i = 0;\n\n    __m128i shift = _mm_set1_epi8(2); // Set the shift value to 2\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i A = _mm_set1_epi8('A');\n    __m128i Z = _mm_set1_epi8('Z');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(input, a), _mm_cmplt_epi8(input, z));\n        __m128i upper_mask = _mm_and_si128(_mm_cmpgt_epi8(input, A), _mm_cmplt_epi8(input, Z));\n\n        input = _mm_add_epi8(input, shift);\n\n        // Wrap around for lowercase letters\n        __m128i wrap_lower = _mm_and_si128(lower_mask, _mm_cmpgt_epi8(input, z));\n        input = _mm_sub_epi8(input, _mm_and_si128(wrap_lower, _mm_set1_epi8(26)));\n\n        // Wrap around for uppercase letters\n        __m128i wrap_upper = _mm_and_si128(upper_mask, _mm_cmpgt_epi8(input, Z));\n        input = _mm_sub_epi8(input, _mm_and_si128(wrap_upper, _mm_set1_epi8(26)));\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), input);\n    }\n\n    for (; i < length; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 2) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = (c - 'A' + 2) % 26 + 'A';\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0, 0);\n    __m128i offset = _mm_set1_epi8(2);\n    __m128i lower_a = _mm_set1_epi8('a');\n    __m128i lower_z = _mm_set1_epi8('z');\n    __m128i upper_a = _mm_set1_epi8('A');\n    __m128i upper_z = _mm_set1_epi8('Z');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i chunk = _mm_loadu_si128((__m128i*)&message[i]);\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(chunk, lower_a), _mm_cmplt_epi8(chunk, upper_z));\n        __m128i upper_mask = _mm_and_si128(_mm_cmpgt_epi8(chunk, upper_a), _mm_cmplt_epi8(chunk, upper_z));\n\n        // Swap case\n        chunk = _mm_xor_si128(chunk, _mm_and_si128(lower_mask, _mm_set1_epi8(0x20)));\n\n        // Replace vowels\n        __m128i is_vowel = _mm_cmpeq_epi8(chunk, vowels);\n        __m128i vowel_replacement = _mm_add_epi8(chunk, offset);\n        chunk = _mm_blendv_epi8(chunk, vowel_replacement, is_vowel);\n\n        _mm_storeu_si128((__m128i*)&result[i], chunk);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Swap case\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Swap case\n        }\n\n        if (c == 'a') c = 'c';\n        else if (c == 'e') c = 'g';\n        else if (c == 'i') c = 'k';\n        else if (c == 'o') c = 'q';\n        else if (c == 'u') c = 'w';\n        else if (c == 'A') c = 'C';\n        else if (c == 'E') c = 'G';\n        else if (c == 'I') c = 'K';\n        else if (c == 'O') c = 'Q';\n        else if (c == 'U') c = 'W';\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u', 0, 0, 0, 0, 0, 0);\n    __m128i shift = _mm_set1_epi8(2);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_case_offset = _mm_set1_epi8('A' - 'a');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(message.data() + i));\n        __m128i case_swapped = _mm_xor_si128(input, _mm_set1_epi8(0x20));\n\n        __m128i is_vowel = _mm_cmpeq_epi8(case_swapped, vowels);\n        __m128i two_ahead = _mm_add_epi8(case_swapped, shift);\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(case_swapped, lower_bound), _mm_cmplt_epi8(case_swapped, upper_bound));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(case_swapped, upper_bound), _mm_cmplt_epi8(case_swapped, upper_bound));\n\n        case_swapped = _mm_blendv_epi8(case_swapped, two_ahead, is_vowel);\n        case_swapped = _mm_blendv_epi8(case_swapped, _mm_sub_epi8(case_swapped, upper_case_offset), is_upper);\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), case_swapped);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20;\n            if (c == 'A') c = 'C';\n            else if (c == 'E') c = 'G';\n            else if (c == 'I') c = 'K';\n            else if (c == 'O') c = 'Q';\n            else if (c == 'U') c = 'W';\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('E', 'e', 'I', 'i', 'O', 'o', 'U', 'u', 'A', 'a', 0, 0, 0, 0, 0, 0);\n    __m128i shift = _mm_set1_epi8(2);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_case_offset = _mm_set1_epi8('A' - 'a');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(message.data() + i));\n        __m128i upper = _mm_and_si128(input, _mm_set1_epi8(0xDF)); // Convert to upper case\n        __m128i lower = _mm_and_si128(input, _mm_set1_epi8(0x20)); // Check if lower case\n\n        // Replace vowels\n        for (int j = 0; j < 8; j++) {\n            __m128i cmp = _mm_cmpeq_epi8(input, _mm_set1_epi8(vowels[j]));\n            __m128i next_char = _mm_add_epi8(input, shift);\n            input = _mm_blendv_epi8(input, next_char, cmp);\n        }\n\n        // Swap case\n        __m128i result_vec = _mm_xor_si128(input, lower_bound);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), result_vec);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        if (c == 'a' || c == 'A') c = 'C';\n        else if (c == 'e' || c == 'E') c = 'G';\n        else if (c == 'i' || c == 'I') c = 'K';\n        else if (c == 'o' || c == 'O') c = 'Q';\n        else if (c == 'u' || c == 'U') c = 'W';\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result(message.size(), ' ');\n    size_t length = message.size();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u', 0, 0, 0, 0, 0, 0);\n    __m128i shift = _mm_set1_epi8(2);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_case_offset = _mm_set1_epi8('A' - 'a');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(message.data() + i));\n        __m128i case_swapped = _mm_xor_si128(input, _mm_set1_epi8(0x20));\n\n        __m128i is_vowel = _mm_cmpeq_epi8(case_swapped, vowels);\n        __m128i incremented = _mm_add_epi8(case_swapped, shift);\n        __m128i result_chars = _mm_blendv_epi8(case_swapped, incremented, is_vowel);\n\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(result.data() + i), result_chars);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Swap case\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2; // Replace vowel\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Swap case\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2; // Replace vowel\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t length = message.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u', 0, 0, 0, 0, 0, 0);\n    __m128i shift = _mm_set1_epi8(2);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_case_offset = _mm_set1_epi8('A' - 'a');\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i input = _mm_loadu_si128((__m128i*)&message[i]);\n        __m128i swapped_case = _mm_xor_si128(input, _mm_set1_epi8(0x20));\n\n        __m128i is_vowel = _mm_cmpeq_epi8(swapped_case, vowels);\n        __m128i two_ahead = _mm_add_epi8(swapped_case, shift);\n\n        // Replace vowels with the letter that appears 2 places ahead\n        swapped_case = _mm_blendv_epi8(swapped_case, two_ahead, is_vowel);\n\n        // Clamp to valid alphabet range\n        __m128i clamped = _mm_min_epi8(_mm_max_epi8(swapped_case, lower_bound), upper_bound);\n        _mm_storeu_si128((__m128i*)&result[i], clamped);\n    }\n\n    for (; i < length; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Swap case\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2; // Replace vowel\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Swap case\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        \n        __m128i lower_mask = _mm_set1_epi8('a');\n        __m128i upper_mask = _mm_set1_epi8('A');\n        __m128i digit_mask = _mm_set1_epi8('0');\n        __m128i upper_limit = _mm_set1_epi8('Z');\n        __m128i lower_limit = _mm_set1_epi8('z');\n\n        for (size_t i = 0; i < len; i += 16) {\n            size_t remaining = len - i;\n            __m128i key_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.c_str() + i));\n\n            if (remaining < 16) {\n                key_vec = _mm_maskload_epi8(key.c_str() + i, _mm_set_epi8(remaining < 15, remaining < 14, remaining < 13, remaining < 12, remaining < 11, remaining < 10, remaining < 9, remaining < 8, remaining < 7, remaining < 6, remaining < 5, remaining < 4, remaining < 3, remaining < 2, remaining < 1, 0));\n            }\n\n            __m128i lower_check = _mm_and_si128(_mm_cmpgt_epi8(key_vec, lower_mask), _mm_cmplt_epi8(key_vec, lower_limit));\n            __m128i upper_check = _mm_and_si128(_mm_cmpgt_epi8(key_vec, upper_mask), _mm_cmplt_epi8(key_vec, upper_limit));\n            __m128i digit_check = _mm_and_si128(_mm_cmpgt_epi8(key_vec, digit_mask), _mm_cmplt_epi8(key_vec, upper_mask));\n\n            if (_mm_movemask_epi8(lower_check) != 0xFFFF) {\n                all_lower = false;\n            }\n            if (_mm_movemask_epi8(upper_check) != 0xFFFF) {\n                all_upper = false;\n            }\n            if (_mm_movemask_epi8(digit_check) != 0xFFFF) {\n                all_lower = false;\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        __m128i lower_mask = _mm_set1_epi8(0x20); // ASCII difference between lower and upper case\n        __m128i upper_mask = _mm_set1_epi8(0x20);\n        __m128i lower_bound = _mm_set1_epi8('a');\n        __m128i upper_bound = _mm_set1_epi8('A');\n        __m128i digit_bound = _mm_set1_epi8('9');\n\n        while (i < len) {\n            size_t chunk_size = std::min(size_t(16), len - i);\n            __m128i keys = _mm_loadu_si128((__m128i*)&key[i]);\n\n            __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(keys, lower_bound), _mm_cmplt_epi8(keys, digit_bound));\n            __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(keys, upper_bound), _mm_cmplt_epi8(keys, lower_bound));\n\n            int mask_lower = _mm_movemask_epi8(is_lower);\n            int mask_upper = _mm_movemask_epi8(is_upper);\n\n            if (mask_lower != 0xFFFF) all_upper = false;\n            if (mask_upper != 0xFFFF) all_lower = false;\n\n            if (!all_lower && !all_upper) return false;\n\n            i += chunk_size;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <map>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        __m128i lower_mask = _mm_set1_epi8(0x20); // mask for lower case check\n        __m128i upper_mask = _mm_set1_epi8(0xDF); // mask for upper case check\n\n        for (; i + 16 <= len; i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.c_str() + i));\n            __m128i lower_check = _mm_and_si128(chars, lower_mask);\n            __m128i upper_check = _mm_and_si128(chars, upper_mask);\n\n            all_lower &= _mm_movemask_epi8(_mm_cmpeq_epi8(lower_check, chars)) == 0xFFFF;\n            all_upper &= _mm_movemask_epi8(_mm_cmpeq_epi8(upper_check, chars)) == 0xFFFF;\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                continue;\n            } else if (c >= 'A' && c <= 'Z') {\n                continue;\n            } else {\n                all_lower = false;\n                all_upper = false;\n                break;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        __m128i lower_mask = _mm_set1_epi8(0x20); // Mask for lower case check\n        __m128i upper_mask = _mm_set1_epi8(0x20); // Mask for upper case check\n        __m128i zero_mask = _mm_set1_epi8(0x30);  // Mask for digit check\n\n        while (i < len) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.c_str() + i));\n            __m128i cmp_lower = _mm_and_si128(data, _mm_set1_epi8(0xDF)); // Convert to upper case\n            __m128i cmp_upper = _mm_and_si128(data, _mm_set1_epi8(0x20)); // Convert to lower case\n\n            // Check for lower case letters\n            __m128i lower_check = _mm_cmpgt_epi8(cmp_lower, zero_mask);\n            __m128i upper_check = _mm_cmpgt_epi8(cmp_upper, zero_mask);\n\n            // Check if any character is not lower case\n            if (_mm_movemask_epi8(lower_check) != 0xFFFF) {\n                all_lower = false;\n            }\n\n            // Check if any character is not upper case\n            if (_mm_movemask_epi8(upper_check) != 0xFFFF) {\n                all_upper = false;\n            }\n\n            i += 16; // Move to the next 16 bytes\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\n#include <map>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        \n        if (len % 16 != 0) {\n            // Pad the string to the next multiple of 16 for SIMD processing\n            std::string padded_key = key;\n            padded_key.resize((len / 16 + 1) * 16, '\\0');\n            len = padded_key.length();\n            key = padded_key;\n        }\n\n        __m128i lower_mask = _mm_set1_epi8(0x20); // mask for lower case check\n        __m128i upper_mask = _mm_set1_epi8(0x20); // mask for upper case check\n        __m128i lower_bound = _mm_set1_epi8('a');\n        __m128i upper_bound = _mm_set1_epi8('A');\n        __m128i digit_bound = _mm_set1_epi8('9');\n\n        for (size_t i = 0; i < len; i += 16) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.data() + i));\n\n            __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(data, lower_bound), _mm_cmplt_epi8(data, upper_bound));\n            __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(data, upper_bound), _mm_cmplt_epi8(data, digit_bound));\n\n            all_lower &= _mm_movemask_epi8(is_lower) == 0xFFFF;\n            all_upper &= _mm_movemask_epi8(is_upper) == 0xFFFF;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n / 2); // Rough estimate of prime count\n\n    __m128i sieve = _mm_set1_epi32(1); // Initialize sieve with 1s\n    for (int i = 2; i * i < n; ++i) {\n        if (_mm_extract_epi32(sieve, i) == 1) {\n            for (int j = i * i; j < n; j += i) {\n                if (j % 4 == 0) {\n                    sieve = _mm_andnot_si128(_mm_set1_epi32(1 << (j % 4)), sieve);\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (_mm_extract_epi32(sieve, i) == 1) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    __m128i sieve = _mm_set1_epi32(1); // Initialize sieve with 1s\n    for (int i = 2; i < n; ++i) {\n        if (sieve.m128i_i32[i] == 0) continue; // Skip if already marked\n\n        // Store prime\n        primes.push_back(i);\n\n        // Mark multiples of the prime\n        for (int j = i * 2; j < n; j += i) {\n            sieve.m128i_i32[j] = 0; // Mark as non-prime\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    __m128i indices = _mm_set_epi32(3, 2, 1, 0); // Initialize with 0, 1, 2, 3\n    for (int i = 4; i < n; i += 4) {\n        __m128i current_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i mask = _mm_set1_epi32(1); // Mask for prime checking\n        for (int j = 2; j * j < n; ++j) {\n            if (is_prime(j)) {\n                __m128i divisor = _mm_set1_epi32(j);\n                __m128i remainder = _mm_rem_epi32(current_indices, divisor);\n                mask = _mm_and_si128(mask, _mm_cmpeq_epi32(remainder, _mm_setzero_si128()));\n            }\n        }\n        for (int j = 0; j < 4; ++j) {\n            if (_mm_extract_epi32(mask, j) == 0) {\n                primes.push_back(_mm_extract_epi32(current_indices, j));\n            }\n        }\n        indices = _mm_add_epi32(indices, _mm_set1_epi32(4));\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    primes.reserve(n);\n\n    __m128i sieve = _mm_set1_epi32(1); // Initialize sieve with 1s\n    for (int i = 2; i * i < n; ++i) {\n        if (_mm_extract_epi32(sieve, i) == 1) {\n            for (int j = i * i; j < n; j += i) {\n                sieve = _mm_andnot_si128(_mm_set1_epi32(1), sieve);\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (_mm_extract_epi32(sieve, i) == 1) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    __m128i sieve = _mm_set1_epi32(1); // Initialize sieve with 1 (true)\n    for (int i = 2; i < n; i += 4) {\n        __m128i idx = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_prime_mask = _mm_set1_epi32(1);\n\n        for (int j = 2; j * j < n; j++) {\n            if (is_prime(j)) {\n                __m128i j_vec = _mm_set1_epi32(j);\n                __m128i mod = _mm_rem_epi32(idx, j_vec);\n                __m128i is_divisible = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n                is_prime_mask = _mm_andnot_si128(is_divisible, is_prime_mask);\n            }\n        }\n\n        // Store primes\n        for (int k = 0; k < 4; k++) {\n            if (i + k < n && _mm_extract_epi32(is_prime_mask, k)) {\n                primes.push_back(i + k);\n            }\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 16 <= length; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i mask = _mm_set1_epi8(0x20); // Mask for uppercase check\n        __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A');\n        \n        // Check for uppercase vowels\n        __m128i upper = _mm_and_si128(data, _mm_set1_epi8(~0x20));\n        __m128i is_vowel = _mm_cmpeq_epi8(upper, vowels);\n        \n        // Create a mask for even indices\n        __m128i even_mask = _mm_setr_epi8(0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,\n                                           0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00);\n        is_vowel = _mm_and_si128(is_vowel, even_mask);\n        \n        // Count the number of set bits\n        count += _mm_popcnt_u32(_mm_movemask_epi8(is_vowel));\n    }\n\n    // Handle remaining characters\n    for (; i < length; i += 2) {\n        if (i < length && s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E');\n    __m128i mask = _mm_set1_epi8(0x20); // Mask to check uppercase\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i even_indices = _mm_and_si128(data, _mm_set1_epi8(0x01)); // Get even indices\n        __m128i upper_case = _mm_and_si128(data, mask); // Check for uppercase\n        __m128i is_vowel = _mm_cmpeq_epi8(data, vowels); // Check for vowels\n        __m128i result = _mm_and_si128(even_indices, upper_case);\n        result = _mm_and_si128(result, is_vowel);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    for (; i < length; i += 2) {\n        if (i < length && s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t i;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E');\n    __m128i upper_mask = _mm_set1_epi8(0xDF); // Mask to convert lowercase to uppercase\n\n    for (i = 0; i < length; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i even_indices = _mm_and_si128(data, _mm_set1_epi8(0x01)); // Mask to get even indices\n        __m128i upper_data = _mm_and_si128(data, upper_mask);\n        \n        __m128i cmp = _mm_cmpeq_epi8(upper_data, vowels);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        count += __builtin_popcount(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t i = 0;\n\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A');\n    __m128i upper_mask = _mm_set1_epi8(0xDF); // Mask to convert lowercase to uppercase\n\n    for (; i + 16 <= length; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i even_indices = _mm_and_si128(data, _mm_set1_epi8(0x01)); // Mask for even indices\n        __m128i upper_data = _mm_and_si128(data, upper_mask);\n\n        __m128i cmp = _mm_cmpeq_epi8(upper_data, vowels);\n        __m128i result = _mm_and_si128(cmp, even_indices);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    for (; i < length; i += 2) {\n        if (i < length && s[i] >= 'A' && s[i] <= 'Z' && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    __m128i vowels = _mm_setr_epi8('A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E', 'I', 'O', 'U', 'A', 'E');\n    __m128i mask = _mm_set1_epi8(0x20); // Mask to check uppercase\n    int count = 0;\n\n    for (size_t i = 0; i < s.length(); i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i even_indices = _mm_and_si128(data, _mm_set1_epi8(0x01)); // Mask to get even indices\n        __m128i upper_case = _mm_andnot_si128(mask, data); // Get uppercase characters\n        __m128i is_vowel = _mm_cmpeq_epi8(upper_case, vowels); // Compare with vowels\n        __m128i result = _mm_and_si128(is_vowel, even_indices); // Filter vowels at even indices\n\n        // Count the number of set bits in result\n        int temp[16];\n        _mm_storeu_si128((__m128i*)temp, result);\n        for (int j = 0; j < 16; j++) {\n            count += (temp[j] != 0);\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    __m128i odd_start = _mm_set1_epi32(n | 1); // Start with n if odd, n+1 if even\n    __m128i even_start = _mm_set1_epi32(n & ~1); // Start with n if even, n-1 if odd\n\n    for (int i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i levels = _mm_add_epi32(indices, indices); // 2 * i\n        __m128i stones;\n\n        if (n % 2 == 0) {\n            stones = _mm_add_epi32(even_start, levels); // Even case\n        } else {\n            stones = _mm_add_epi32(odd_start, levels); // Odd case\n        }\n\n        _mm_storeu_si128((__m128i*)&result[i], stones);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    __m128i base = _mm_set1_epi32(n);\n    __m128i odd_increment = _mm_set1_epi32(2);\n    __m128i even_increment = _mm_set1_epi32(2);\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i level = _mm_add_epi32(base, _mm_set1_epi32(i * 2));\n        if (n % 2 == 0) {\n            level = _mm_add_epi32(level, _mm_and_si128(_mm_set1_epi32(i), _mm_set1_epi32(1)));\n        } else {\n            level = _mm_add_epi32(level, _mm_andnot_si128(_mm_set1_epi32(i), _mm_set1_epi32(1)));\n        }\n        _mm_storeu_si128((__m128i*)&result[i], level);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    __m128i level = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(2);\n    \n    for (int i = 0; i < n; i += 4) {\n        if (i % 2 == 0) {\n            // Even index: next even number\n            _mm_storeu_si128((__m128i*)&result[i], level);\n            level = _mm_add_epi32(level, increment);\n        } else {\n            // Odd index: next odd number\n            _mm_storeu_si128((__m128i*)&result[i], level);\n            level = _mm_add_epi32(level, _mm_add_epi32(increment, _mm_set1_epi32(1)));\n        }\n    }\n    \n    // Handle remaining elements if n is not a multiple of 4\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        result[i] = n + 2 * i + (i % 2);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    __m128i level = _mm_set1_epi32(n);\n    __m128i odd_increment = _mm_set1_epi32(2);\n    __m128i even_increment = _mm_set1_epi32(2);\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i current_levels = level;\n        _mm_storeu_si128((__m128i*)&result[i], current_levels);\n        \n        if (n % 2 == 0) {\n            level = _mm_add_epi32(level, even_increment);\n        } else {\n            level = _mm_add_epi32(level, odd_increment);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    __m128i level = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(2);\n    \n    for (int i = 0; i < n; i += 4) {\n        if (i > 0) {\n            __m128i odd_even = _mm_set1_epi32((n % 2 == 0) ? 1 : 0);\n            __m128i next_increment = _mm_add_epi32(level, odd_even);\n            level = _mm_add_epi32(level, increment);\n            level = _mm_add_epi32(level, next_increment);\n        }\n        _mm_storeu_si128((__m128i*)&result[i], level);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    __m128i sum = _mm_setzero_si128();\n    \n    for (int64_t i = n; i <= m; i += 4) {\n        __m128i values = _mm_set_epi64x(i + 3, i);\n        sum = _mm_add_epi64(sum, values);\n    }\n\n    int64_t total_sum[2];\n    _mm_storeu_si128((__m128i*)total_sum, sum);\n    \n    int64_t total = total_sum[0] + total_sum[1];\n    int64_t avg = total / count;\n\n    if (total % count != 0) {\n        avg = (total < 0) ? (avg - 1) : avg; // round down\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    __m128i start = _mm_set1_epi64x(n);\n    __m128i end = _mm_set1_epi64x(m);\n    __m128i count = _mm_sub_epi64(end, start);\n    count = _mm_add_epi64(count, _mm_set1_epi64x(1)); // count = m - n + 1\n\n    __m128i sum = _mm_setzero_si128();\n    for (int64_t i = n; i <= m; i += 2) {\n        __m128i values = _mm_set_epi64x(i + 1, i);\n        sum = _mm_add_epi64(sum, values);\n    }\n\n    sum = _mm_hadd_epi64(sum, sum); // Horizontal add\n    int64_t total_sum;\n    _mm_store_si128((__m128i*)&total_sum, sum);\n\n    int64_t total_count;\n    _mm_store_si128((__m128i*)&total_count, count);\n\n    int64_t avg = total_sum / total_count;\n    if (total_sum % total_count != 0) {\n        avg = (total_sum < 0) ? (avg - 1) : avg; // Round down\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary.insert(binary.begin(), (avg % 2) + '0');\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    __m128i sum = _mm_setzero_si128();\n    __m128i start = _mm_set1_epi64x(n);\n    __m128i end = _mm_set1_epi64x(m);\n    \n    for (int64_t i = n; i <= m; i += 2) {\n        __m128i current = _mm_set_epi64x(i + 1, i);\n        sum = _mm_add_epi64(sum, current);\n    }\n\n    int64_t total_sum[2];\n    _mm_storeu_si128((__m128i*)total_sum, sum);\n    \n    int64_t total = total_sum[0] + total_sum[1];\n    int64_t avg = total / count;\n\n    std::string binary;\n    while (avg > 0) {\n        binary.insert(binary.begin(), (avg % 2) + '0');\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    __m128i start = _mm_set1_epi64x(n);\n    __m128i end = _mm_set1_epi64x(m);\n    __m128i count = _mm_sub_epi64(end, start);\n    count = _mm_add_epi64(count, _mm_set1_epi64x(1)); // count = m - n + 1\n\n    __m128i sum = _mm_setzero_si128();\n    for (int64_t i = n; i <= m; i += 2) {\n        __m128i temp = _mm_set_epi64x(i + 1, i);\n        sum = _mm_add_epi64(sum, temp);\n    }\n\n    // Calculate average\n    __m128i avg = _mm_div_epi64(sum, count);\n    __m128i rounded_avg = _mm_srli_epi64(avg, 1); // Divide by 2 for rounding down\n\n    // Convert to binary string\n    int64_t result;\n    _mm_store_si128((__m128i*)&result, rounded_avg);\n    \n    std::string binary;\n    while (result > 0) {\n        binary.insert(binary.begin(), (result % 2) + '0');\n        result /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <string>\n#include <vector>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i n_vec = _mm_set_epi64x(n, n + 1);\n    \n    for (int64_t i = n; i <= m; i += 2) {\n        sum_vec = _mm_add_epi64(sum_vec, n_vec);\n        n_vec = _mm_add_epi64(n_vec, _mm_set_epi64x(2, 2));\n    }\n\n    // Horizontal sum\n    sum_vec = _mm_hadd_epi64(sum_vec, sum_vec);\n    _mm_store_si128((__m128i*)&sum, sum_vec);\n\n    // Calculate average\n    int64_t avg = sum / count;\n    if (sum % count != 0) {\n        avg = (sum < 0) ? (avg - 1) : avg; // Round down\n    }\n\n    // Convert to binary string\n    std::string binary;\n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary.insert(binary.begin(), (avg % 2) + '0');\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    __m128i factorial = _mm_set_epi32(1, 1, 1, 1); // Initialize factorial for 1, 2, 3, 4\n    __m128i sum = _mm_set_epi32(0, 0, 0, 0); // Initialize sum for odd indices\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_even = _mm_and_si128(_mm_set1_epi32(1), _mm_srli_epi32(indices, 1)); // Check if even\n\n        // Calculate factorial for even indices\n        for (int j = 0; j < 4; ++j) {\n            if ((i + j) % 2 == 0) {\n                int idx = i + j;\n                if (idx > 1) {\n                    factorial = _mm_mullo_epi32(factorial, _mm_set1_epi32(idx));\n                }\n                result[idx - 1] = _mm_extract_epi32(factorial, j) % 10000;\n            } else {\n                // Calculate sum for odd indices\n                sum = _mm_add_epi32(sum, _mm_set1_epi32(i + j));\n                result[idx - 1] = _mm_extract_epi32(sum, j);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    __m128i factorial = _mm_set_epi32(1, 1, 1, 1); // Initialize factorial for 1, 2, 3, 4\n    __m128i sum = _mm_set_epi32(0, 0, 0, 0); // Initialize sum for 1 to i\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_even = _mm_and_si128(_mm_set1_epi32(1), _mm_srli_epi32(indices, 1)); // Check if even\n\n        // Calculate factorial for even indices\n        if (i <= n) {\n            factorial = _mm_set_epi32(1, 1, 1, 1);\n            for (int j = 1; j <= 4 && (i + j - 1) <= n; ++j) {\n                if ((i + j - 1) % 2 == 0) {\n                    factorial = _mm_mullo_epi32(factorial, _mm_set1_epi32(j));\n                }\n            }\n        }\n\n        // Calculate sum for odd indices\n        sum = _mm_add_epi32(sum, indices);\n\n        // Store results\n        for (int j = 0; j < 4 && (i + j - 1) <= n; ++j) {\n            int idx = i + j - 1;\n            if (idx % 2 == 0) {\n                result[idx] = _mm_extract_epi32(factorial, j) % 10000;\n            } else {\n                result[idx] = _mm_extract_epi32(sum, j);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    __m128i factorial = _mm_set1_epi32(1);\n    __m128i sum = _mm_set1_epi32(0);\n    __m128i mod = _mm_set1_epi32(10000);\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_even = _mm_and_si128(_mm_srli_epi32(indices, 1), _mm_set1_epi32(1));\n\n        for (int j = 0; j < 4 && (i + j) <= n; ++j) {\n            if ((i + j) % 2 == 0) {\n                factorial = _mm_set1_epi32(1);\n                for (int k = 1; k <= (i + j); ++k) {\n                    factorial = _mm_mullo_epi32(factorial, _mm_set1_epi32(k));\n                }\n                factorial = _mm_rem_epi32(factorial, mod);\n                result[i + j - 1] = _mm_cvtsi128_si32(factorial);\n            } else {\n                sum = _mm_add_epi32(sum, _mm_set1_epi32(i + j));\n                result[i + j - 1] = _mm_cvtsi128_si32(sum);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    __m128i factorial = _mm_set1_epi32(1);\n    __m128i sum = _mm_set1_epi32(0);\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_even = _mm_and_si128(_mm_srli_epi32(indices, 1), _mm_set1_epi32(1));\n\n        for (int j = 0; j < 4 && (i + j) <= n; ++j) {\n            int idx = i + j;\n            if (idx % 2 == 0) {\n                factorial = _mm_mullo_epi32(factorial, _mm_set1_epi32(idx));\n                result[idx - 1] = _mm_cvtsi128_si32(factorial) % 10000;\n            } else {\n                sum = _mm_add_epi32(sum, _mm_set1_epi32(idx));\n                result[idx - 1] = _mm_cvtsi128_si32(sum);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    __m128i factorial = _mm_set_epi32(1, 1, 1, 1); // Initialize factorials for 1, 2, 3, 4\n    __m128i sum = _mm_set_epi32(0, 0, 0, 0); // Initialize sums\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_even = _mm_and_si128(_mm_set1_epi32(1), _mm_srli_epi32(indices, 1)); // Check if even\n\n        // Calculate factorial for even indices\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            if ((i + j) % 2 == 0) {\n                int idx = i + j;\n                if (idx > 1) {\n                    factorial = _mm_mullo_epi32(factorial, _mm_set1_epi32(idx));\n                }\n                result[idx - 1] = _mm_cvtsi128_si32(factorial);\n            } else {\n                // Calculate sum for odd indices\n                sum = _mm_add_epi32(sum, _mm_set1_epi32(i + j));\n                result[idx - 1] = _mm_cvtsi128_si32(sum);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_palindrome(int num) {\n    int original = num, reversed = 0;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return original == reversed;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i palindromes = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            if (is_palindrome(i + j)) {\n                palindromes = _mm_or_si128(palindromes, _mm_set_epi32(0, 0, 0, 1 << j));\n            }\n        }\n\n        __m128i evens = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 1));\n        __m128i odds = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 2));\n\n        even_count = _mm_add_epi32(even_count, _mm_srli_epi32(evens, 0));\n        odd_count = _mm_add_epi32(odd_count, _mm_srli_epi32(odds, 0));\n    }\n\n    int even_result = _mm_cvtsi128_si32(even_count);\n    int odd_result = _mm_cvtsi128_si32(odd_count);\n\n    return {even_result, odd_result};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_palindrome(int num) {\n    int reversed = 0, original = num;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return original == reversed;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i palindromes = _mm_setzero_si128();\n\n        for (int j = 0; j < 4; ++j) {\n            int num = _mm_extract_epi32(indices, j);\n            if (num > n) break;\n            if (is_palindrome(num)) {\n                palindromes = _mm_insert_epi32(palindromes, num, j);\n            }\n        }\n\n        __m128i is_even = _mm_and_si128(palindromes, _mm_set1_epi32(1));\n        __m128i is_odd = _mm_xor_si128(is_even, _mm_set1_epi32(1));\n\n        even_count = _mm_add_epi32(even_count, _mm_and_si128(is_even, _mm_set1_epi32(1)));\n        odd_count = _mm_add_epi32(odd_count, _mm_and_si128(is_odd, _mm_set1_epi32(1)));\n    }\n\n    int even_result = _mm_cvtsi128_si32(even_count);\n    int odd_result = _mm_cvtsi128_si32(odd_count);\n\n    return {even_result, odd_result};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_palindrome(int num) {\n    int reversed = 0, original = num;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return original == reversed;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i palindromes = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; ++j) {\n            int num = i + j;\n            if (is_palindrome(num)) {\n                palindromes = _mm_or_si128(palindromes, _mm_set_epi32(0, 0, 0, 1 << j));\n            }\n        }\n\n        __m128i evens = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 1));\n        __m128i odds = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 2));\n\n        even_count = _mm_add_epi32(even_count, _mm_srl_epi32(evens, 1));\n        odd_count = _mm_add_epi32(odd_count, _mm_srl_epi32(odds, 1));\n    }\n\n    int even_result[4], odd_result[4];\n    _mm_storeu_si128((__m128i*)even_result, even_count);\n    _mm_storeu_si128((__m128i*)odd_result, odd_count);\n\n    return {even_result[0] + even_result[1] + even_result[2] + even_result[3],\n            odd_result[0] + odd_result[1] + odd_result[2] + odd_result[3]};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n    \n    for (int i = 1; i <= n; i += 4) {\n        __m128i numbers = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i is_palindrome = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; ++j) {\n            int num = i + j;\n            if (num > n) break;\n            int reversed = 0, original = num;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            if (original == reversed) {\n                is_palindrome = _mm_or_si128(is_palindrome, _mm_set_epi32(0, 0, 0, 1 << j));\n            }\n        }\n\n        __m128i even_mask = _mm_and_si128(is_palindrome, _mm_set1_epi32(0x00000002));\n        __m128i odd_mask = _mm_andnot_si128(even_mask, is_palindrome);\n\n        even_count = _mm_add_epi32(even_count, _mm_sad_epu8(even_mask, _mm_setzero_si128()));\n        odd_count = _mm_add_epi32(odd_count, _mm_sad_epu8(odd_mask, _mm_setzero_si128()));\n    }\n\n    int even_result[4], odd_result[4];\n    _mm_storeu_si128((__m128i*)even_result, even_count);\n    _mm_storeu_si128((__m128i*)odd_result, odd_count);\n\n    return {even_result[0], odd_result[0]};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_palindrome(int num) {\n    int reversed = 0, original = num;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return original == reversed;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n\n    for (int i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i palindromes = _mm_setzero_si128();\n\n        for (int j = 0; j < 4 && (i + j) <= n; ++j) {\n            if (is_palindrome(i + j)) {\n                palindromes = _mm_or_si128(palindromes, _mm_set_epi32(0, 0, 0, 1 << j));\n            }\n        }\n\n        __m128i evens = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 1));\n        __m128i odds = _mm_and_si128(palindromes, _mm_set_epi32(0, 0, 0, 2));\n\n        even_count = _mm_add_epi32(even_count, _mm_srli_epi32(evens, 0));\n        odd_count = _mm_add_epi32(odd_count, _mm_srli_epi32(odds, 0));\n    }\n\n    int even_result[4], odd_result[4];\n    _mm_storeu_si128((__m128i*)even_result, even_count);\n    _mm_storeu_si128((__m128i*)odd_result, odd_count);\n\n    int total_even = even_result[0] + even_result[1] + even_result[2] + even_result[3];\n    int total_odd = odd_result[0] + odd_result[1] + odd_result[2] + odd_result[3];\n\n    return {total_even, total_odd};\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_mask = _mm_set1_epi32(0);\n    \n    for (; i + 4 <= size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Calculate sum of digits\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        __m128i sum_digits = _mm_setzero_si128();\n        \n        for (int j = 0; j < 10; ++j) {\n            __m128i digit_mask = _mm_set1_epi32(0xF);\n            __m128i digits = _mm_and_si128(abs_nums, digit_mask);\n            sum_digits = _mm_add_epi32(sum_digits, digits);\n            abs_nums = _mm_srli_epi32(abs_nums, 4);\n        }\n        \n        // Check if sum of digits > 0\n        __m128i greater_than_zero = _mm_cmpgt_epi32(sum_digits, zero);\n        sum_mask = _mm_add_epi32(sum_mask, greater_than_zero);\n    }\n\n    // Horizontal sum of the counts\n    sum_mask = _mm_hadd_epi32(sum_mask, sum_mask);\n    sum_mask = _mm_hadd_epi32(sum_mask, sum_mask);\n    \n    count += _mm_cvtsi128_si32(sum_mask);\n    \n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += abs(num % 10);\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_digits;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        sum_digits = _mm_setzero_si128();\n\n        for (int j = 0; j < 4; ++j) {\n            int num = n[i + j];\n            while (num != 0) {\n                sum_digits = _mm_add_epi32(sum_digits, _mm_set1_epi32(num % 10));\n                num /= 10;\n            }\n        }\n\n        __m128i mask = _mm_cmpgt_epi32(sum_digits, zero);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    __m128i sum_mask = _mm_set1_epi32(0);\n    \n    for (int i = 0; i < size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        __m128i digits_sum = _mm_setzero_si128();\n        \n        for (int j = 0; j < 10; ++j) {\n            __m128i digit_mask = _mm_set1_epi32(0xF);\n            __m128i digits = _mm_and_si128(abs_nums, digit_mask);\n            digits_sum = _mm_add_epi32(digits_sum, digits);\n            abs_nums = _mm_srli_epi32(abs_nums, 4);\n        }\n        \n        __m128i zero_mask = _mm_cmpgt_epi32(digits_sum, _mm_setzero_si128());\n        sum_mask = _mm_add_epi32(sum_mask, zero_mask);\n    }\n    \n    int results[4];\n    _mm_storeu_si128((__m128i*)results, sum_mask);\n    \n    for (int i = 0; i < 4; ++i) {\n        count += results[i];\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_digits;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        sum_digits = _mm_setzero_si128();\n\n        for (int j = 0; j < 4; ++j) {\n            int num = n[i + j];\n            while (num != 0) {\n                sum_digits = _mm_add_epi32(sum_digits, _mm_set1_epi32(num % 10));\n                num /= 10;\n            }\n        }\n\n        __m128i mask = _mm_cmpgt_epi32(sum_digits, zero);\n        count += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    __m128i zero = _mm_setzero_si128();\n    __m128i count_vec = _mm_setzero_si128();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i abs_nums = _mm_abs_epi32(nums);\n\n        __m128i digits_sum = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i mod = _mm_set1_epi32(10);\n            __m128i remainder = _mm_rem_epi32(abs_nums, mod);\n            digits_sum = _mm_add_epi32(digits_sum, remainder);\n            abs_nums = _mm_div_epi32(abs_nums, mod);\n        }\n\n        __m128i greater_than_zero = _mm_cmpgt_epi32(digits_sum, zero);\n        count_vec = _mm_add_epi32(count_vec, greater_than_zero);\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, count_vec);\n    count += temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < size; i++) {\n        if (sum_of_digits(n[i]) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create an array to hold the shifted values\n    std::vector<int> shifted(N);\n    shifted[0] = arr[N - 1];\n    for (int i = 1; i < N; ++i) {\n        shifted[i] = arr[i - 1];\n    }\n\n    // Check if the original array or the shifted array is sorted\n    __m128i prev, curr;\n    bool original_sorted = true, shifted_sorted = true;\n\n    // Check original array\n    for (int i = 0; i < N; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&arr[i]);\n        curr = _mm_loadu_si128((__m128i*)&arr[i + 1]);\n        original_sorted &= _mm_movemask_epi8(_mm_cmpgt_epi32(curr, prev)) == 0;\n    }\n\n    // Check shifted array\n    for (int i = 0; i < N; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&shifted[i]);\n        curr = _mm_loadu_si128((__m128i*)&shifted[i + 1]);\n        shifted_sorted &= _mm_movemask_epi8(_mm_cmpgt_epi32(curr, prev)) == 0;\n    }\n\n    return original_sorted || shifted_sorted;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to hold the sorted version of arr\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if any right shift of arr matches sorted_arr\n    for (int shift = 0; shift < N; ++shift) {\n        bool is_sorted = true;\n        for (int i = 0; i < N; i += 4) {\n            __m128i a = _mm_loadu_si128((__m128i*)&arr[(i + shift) % N]);\n            __m128i b = _mm_loadu_si128((__m128i*)&sorted_arr[i]);\n            if (_mm_movemask_epi8(_mm_cmpgt_epi32(a, b)) != 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to hold the sorted version of arr\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check for each possible right shift\n    for (int shift = 0; shift < N; ++shift) {\n        __m128i original = _mm_loadu_si128((__m128i*)&arr[0]);\n        __m128i sorted = _mm_loadu_si128((__m128i*)&sorted_arr[0]);\n\n        // Perform the right shift\n        if (shift > 0) {\n            int last_element = arr[N - 1];\n            for (int i = N - 1; i > 0; --i) {\n                arr[i] = arr[i - 1];\n            }\n            arr[0] = last_element;\n            original = _mm_loadu_si128((__m128i*)&arr[0]);\n        }\n\n        // Compare original with sorted\n        __m128i cmp = _mm_cmpgt_epi32(original, sorted);\n        int mask = _mm_movemask_epi8(cmp);\n\n        // If all comparisons are less than or equal, we found a valid shift\n        if (mask == 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Load the array into SSE registers\n    __m128i prev = _mm_set1_epi32(arr[N - 1]);\n    __m128i curr;\n\n    for (int i = 0; i < N; i += 4) {\n        curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Compare current with previous\n        __m128i cmp = _mm_cmpgt_epi32(curr, prev);\n        int mask = _mm_movemask_epi8(cmp);\n\n        // If any element is greater than the previous, we check the next set\n        if (mask != 0xFFFF) {\n            prev = curr;\n        } else {\n            // If we find a decreasing pair, we cannot sort it by shifting\n            return false;\n        }\n    }\n\n    // Final check for the wrap-around case\n    if (arr[0] < arr[N - 1]) {\n        return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to hold the sorted version of arr\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if any rotation of arr matches sorted_arr\n    for (int shift = 0; shift < N; ++shift) {\n        __m128i original = _mm_loadu_si128((__m128i*)&arr[0]);\n        __m128i sorted = _mm_loadu_si128((__m128i*)&sorted_arr[0]);\n\n        bool is_sorted = true;\n        for (int i = 0; i < N; ++i) {\n            if (arr[(i + shift) % N] != sorted[i]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size = lst1.size();\n    __m128i even_mask = _mm_set1_epi32(1);\n    __m128i lst1_mask, lst2_mask;\n\n    int lst1_even_count = 0;\n    int lst2_odd_count = 0;\n\n    for (size_t i = 0; i < size; i += 4) {\n        lst1_mask = _mm_loadu_si128((__m128i*)&lst1[i]);\n        lst2_mask = _mm_loadu_si128((__m128i*)&lst2[i]);\n\n        __m128i lst1_even = _mm_and_si128(lst1_mask, even_mask);\n        __m128i lst2_odd = _mm_andnot_si128(lst1_mask, even_mask);\n\n        lst1_even_count += _mm_popcnt_u32(_mm_cvtsi128_si32(lst1_even));\n        lst2_odd_count += _mm_popcnt_u32(_mm_cvtsi128_si32(lst2_odd));\n    }\n\n    if (lst1_even_count + lst2_odd_count >= size) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size = lst1.size();\n    __m128i even_mask = _mm_set1_epi32(1);\n    __m128i lst1_mask, lst2_mask;\n\n    int lst1_even_count = 0;\n    int lst2_odd_count = 0;\n\n    for (size_t i = 0; i < size; i += 4) {\n        lst1_mask = _mm_loadu_si128((__m128i*)&lst1[i]);\n        lst2_mask = _mm_loadu_si128((__m128i*)&lst2[i]);\n\n        __m128i lst1_even = _mm_and_si128(lst1_mask, even_mask);\n        __m128i lst2_odd = _mm_andnot_si128(lst1_mask, even_mask);\n\n        lst1_even_count += _mm_popcnt_u32(_mm_cvtsi128_si32(lst1_even));\n        lst2_odd_count += _mm_popcnt_u32(_mm_cvtsi128_si32(lst2_odd));\n    }\n\n    if (lst1_even_count + lst2_odd_count >= size) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size = lst1.size();\n    __m128i even_mask = _mm_set1_epi32(1);\n    __m128i lst1_vec, lst2_vec, lst1_even, lst2_even;\n\n    int lst1_even_count = 0;\n    int lst2_odd_count = 0;\n\n    for (size_t i = 0; i < size; i += 4) {\n        lst1_vec = _mm_loadu_si128((__m128i*)&lst1[i]);\n        lst2_vec = _mm_loadu_si128((__m128i*)&lst2[i]);\n\n        lst1_even = _mm_and_si128(lst1_vec, even_mask);\n        lst2_even = _mm_and_si128(lst2_vec, even_mask);\n\n        lst1_even_count += _mm_popcnt_u32(_mm_cvtsi128_si32(lst1_even));\n        lst2_odd_count += 4 - _mm_popcnt_u32(_mm_cvtsi128_si32(lst2_even));\n    }\n\n    if (lst1_even_count + lst2_odd_count >= size) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    __m128i even_mask = _mm_set1_epi32(1);\n    __m128i lst1_mask, lst2_mask;\n    int lst1_even = 0, lst2_odd = 0;\n\n    for (size_t i = 0; i < n; i += 4) {\n        lst1_mask = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst1[i]));\n        lst2_mask = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst2[i]));\n\n        __m128i lst1_even_check = _mm_and_si128(lst1_mask, even_mask);\n        __m128i lst2_odd_check = _mm_andnot_si128(lst1_mask, even_mask);\n\n        lst1_even += _mm_popcnt_u32(_mm_movemask_epi8(lst1_even_check));\n        lst2_odd += _mm_popcnt_u32(_mm_movemask_epi8(lst2_odd_check));\n    }\n\n    if (lst1_even + lst2_odd >= n) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size = lst1.size();\n    __m128i even_mask = _mm_set1_epi32(1);\n    __m128i lst1_mask = _mm_setzero_si128();\n    __m128i lst2_mask = _mm_setzero_si128();\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n\n        __m128i even_elements = _mm_and_si128(vec1, even_mask);\n        __m128i odd_elements = _mm_andnot_si128(even_mask, vec1);\n        lst1_mask = _mm_or_si128(lst1_mask, odd_elements);\n\n        __m128i odd_from_lst2 = _mm_andnot_si128(even_mask, vec2);\n        lst2_mask = _mm_or_si128(lst2_mask, odd_from_lst2);\n    }\n\n    int lst1_odd[4], lst2_odd[4];\n    _mm_storeu_si128((__m128i*)lst1_odd, lst1_mask);\n    _mm_storeu_si128((__m128i*)lst2_odd, lst2_mask);\n\n    for (int i = 0; i < 4; ++i) {\n        if (lst1_odd[i] != 0 && lst2_odd[i] == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i + 16 <= len; i += 16) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.c_str() + i));\n            __m128i odd_mask = _mm_set1_epi8(1); // Mask for odd digits\n            __m128i odd_digits = _mm_and_si128(data, _mm_set1_epi8(0x01));\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_digits));\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \n                         \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        __m128i odd_mask = _mm_set1_epi8(0b01010101); // Mask for odd digits (1, 3, 5, 7, 9)\n        __m128i count_mask = _mm_set1_epi8(0b00001111); // Mask to count odd digits\n\n        for (; i + 16 <= len; i += 16) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.c_str() + i));\n            __m128i odd_digits = _mm_and_si128(data, odd_mask);\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_digits));\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(result.size() + 1) + \"ng \" + std::to_string(result.size() + 1) + \" of the \" + std::to_string(result.size() + 1) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t length = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i + 15 < length; i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.c_str() + i));\n            __m128i odd_mask = _mm_set1_epi8(1); // Mask for odd digits\n            __m128i odd_digits = _mm_and_si128(chars, _mm_set1_epi8(0x01)); // Check if the digit is odd\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_digits));\n        }\n\n        // Process remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(result.size() + 1) + \n                         \"ng \" + std::to_string(result.size() + 1) + \n                         \" of the \" + std::to_string(result.size() + 1) + \n                         \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i + 15 < len; i += 16) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.c_str() + i));\n            __m128i mask = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_set1_epi8(0x01); // Mask for odd digits\n\n            // Check for odd digits (1, 3, 5, 7, 9)\n            __m128i is_odd = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('0' - 1)), \n                                            _mm_and_si128(_mm_cmpeq_epi8(_mm_and_si128(data, odd_mask), odd_mask), \n                                                          _mm_cmpeq_epi8(data, _mm_set1_epi8('1'))));\n\n            // Count the number of odd digits\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(is_odd));\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Create the output string\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                             \"n the str\" + std::to_string(result.size() + 1) + \n                             \"ng \" + std::to_string(result.size() + 1) + \n                             \" of the \" + std::to_string(result.size() + 1) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t length = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i + 15 < length; i += 16) {\n            __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.c_str() + i));\n            __m128i mask = _mm_set1_epi8(1); // Mask for odd digits\n            __m128i odd_mask = _mm_set1_epi8(0x01); // Mask for odd digits (1, 3, 5, 7, 9)\n\n            // Check for odd digits\n            __m128i is_odd = _mm_and_si128(_mm_cmpeq_epi8(_mm_and_si128(data, odd_mask), odd_mask), mask);\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(is_odd));\n        }\n\n        // Process remaining characters\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Create the result string\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) + \" of the \" +\n                             std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 4 elements at a time using SSE2\n    for (; i + 3 < size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        __m128i min_vec = _mm_min_epi64(vec, _mm_set1_epi64x(min_sum));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&nums[i]), min_vec);\n        \n        // Calculate the current sum\n        current_sum += _mm_extract_epi64(min_vec, 0);\n        current_sum += _mm_extract_epi64(min_vec, 1);\n        current_sum += _mm_extract_epi64(min_vec, 2);\n        current_sum += _mm_extract_epi64(min_vec, 3);\n        \n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i min_sum_vec = _mm_set1_epi64x(min_sum);\n    __m128i current_sum_vec = _mm_setzero_si128();\n\n    for (; i + 1 < size; i += 2) {\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        current_sum_vec = _mm_add_epi64(current_sum_vec, nums_vec);\n        min_sum_vec = _mm_min_epi64(min_sum_vec, current_sum_vec);\n    }\n\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    int64_t min_sum_array[2];\n    _mm_storeu_si128((__m128i*)min_sum_array, min_sum_vec);\n    min_sum = std::min(min_sum, std::min(min_sum_array[0], min_sum_array[1]));\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time using SSE2\n    for (; i + 1 < size; i += 2) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        __m128i min_vec = _mm_min_epi64(vec, _mm_set1_epi64x(min_sum));\n        min_sum = std::min(min_sum, _mm_cvtsi128_si64(min_vec));\n        current_sum += _mm_cvtsi128_si64(vec);\n    }\n\n    // Handle the last element if the size is odd\n    if (i < size) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, nums[i]);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        __m128i min_vec = _mm_min_epi64(vec, _mm_set1_epi64x(current_sum));\n        current_sum = _mm_extract_epi64(min_vec, 0);\n        current_sum = std::min(current_sum, _mm_extract_epi64(min_vec, 1));\n        current_sum = std::min(current_sum, _mm_extract_epi64(min_vec, 2));\n        current_sum = std::min(current_sum, _mm_extract_epi64(min_vec, 3));\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i min_vec = _mm_set1_epi64x(min_sum);\n    __m128i current_vec = _mm_setzero_si128();\n\n    for (; i + 1 < size; i += 2) {\n        current_vec = _mm_add_epi64(current_vec, _mm_loadu_si128((__m128i*)&nums[i]));\n        min_vec = _mm_min_epi64(min_vec, current_vec);\n        \n        if (current_sum > 0) {\n            current_sum = 0;\n            current_vec = _mm_setzero_si128();\n        }\n    }\n\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    int64_t min_array[2];\n    _mm_storeu_si128((__m128i*)min_array, min_vec);\n    min_sum = std::min(min_sum, std::min(min_array[0], min_array[1]));\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        __m128i sum = _mm_setzero_si128();\n        for (int j = 0; j < cols; j += 4) {\n            __m128i well_data = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, well_data);\n        }\n        int water_units[4];\n        _mm_storeu_si128((__m128i*)water_units, sum);\n        for (int k = 0; k < 4; ++k) {\n            total_buckets += (water_units[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        __m128i sum = _mm_setzero_si128();\n        for (int j = 0; j < cols; j += 4) {\n            __m128i well_data = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, well_data);\n        }\n        \n        int water_units[4];\n        _mm_storeu_si128((__m128i*)water_units, sum);\n        \n        for (int k = 0; k < 4; ++k) {\n            total_buckets += (water_units[k] + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        __m128i sum = _mm_setzero_si128();\n        for (int j = 0; j < cols; j += 4) {\n            __m128i well_data = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, well_data);\n        }\n        int water_units[4];\n        _mm_storeu_si128((__m128i*)water_units, sum);\n        for (int k = 0; k < 4; ++k) {\n            total_buckets += (water_units[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        __m128i sum = _mm_setzero_si128();\n        for (int j = 0; j < cols; j += 4) {\n            __m128i well_data = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, well_data);\n        }\n        int water_units[4];\n        _mm_storeu_si128((__m128i*)water_units, sum);\n        for (int k = 0; k < 4; ++k) {\n            total_buckets += (water_units[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_buckets = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        __m128i sum = _mm_setzero_si128();\n        for (int j = 0; j < cols; j += 4) {\n            __m128i well_data = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, well_data);\n        }\n        int water_units[4];\n        _mm_storeu_si128((__m128i*)water_units, sum);\n        for (int k = 0; k < 4; ++k) {\n            total_buckets += (water_units[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (i = 0; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i even_mask = _mm_set1_epi16(0x0001); // mask for odd numbers\n        __m128i odd_elements = _mm_and_si128(vec, even_mask);\n        __m128i even_positions = _mm_srli_epi16(vec, 1); // shift right to get elements in even positions\n        __m128i result = _mm_and_si128(odd_elements, even_positions);\n        sum_vec = _mm_add_epi64(sum_vec, _mm_sad_epu8(result, _mm_setzero_si128()));\n    }\n\n    for (; i < size; i += 2) {\n        if (i < size && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    sum += _mm_cvtsi128_si64(sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i total_sum = _mm_setzero_si128();\n\n    for (i = 0; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i mask = _mm_set1_epi16(0x0001);\n        __m128i odd_mask = _mm_and_si128(vec, mask);\n        __m128i even_positions = _mm_set_epi16(0, lst[i + 6], 0, lst[i + 4], 0, lst[i + 2], 0, lst[i]);\n        __m128i result = _mm_and_si128(even_positions, odd_mask);\n        total_sum = _mm_add_epi16(total_sum, result);\n    }\n\n    // Horizontal sum\n    total_sum = _mm_hadd_epi16(total_sum, total_sum);\n    total_sum = _mm_hadd_epi16(total_sum, total_sum);\n    \n    sum += _mm_cvtsi128_si32(total_sum);\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (i = 0; i + 8 <= size; i += 8) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i even_positions = _mm_and_si128(data, _mm_set1_epi16(0x0001)); // Mask for odd elements\n        __m128i odd_mask = _mm_set_epi16(0, 0, 0, 0, 0, 0, 0, 0xFFFF); // Mask for even positions\n        __m128i filtered = _mm_and_si128(even_positions, odd_mask);\n        sum_vec = _mm_add_epi64(sum_vec, _mm_sad_epu8(filtered, _mm_setzero_si128()));\n    }\n\n    for (; i < size; i += 2) {\n        if (i < size && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    int64_t result[2];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(result), sum_vec);\n    sum += result[0] + result[1];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    __m128i total_sum = _mm_setzero_si128();\n\n    for (; i + 8 <= size; i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i mask = _mm_set1_epi16(0x0001); // Mask for odd check\n        __m128i even_pos_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for even positions\n\n        // Create a mask for odd elements\n        __m128i odd_elements = _mm_and_si128(vec, mask);\n        __m128i even_pos_elements = _mm_and_si128(vec, even_pos_mask);\n\n        // Select only odd elements in even positions\n        __m128i result = _mm_and_si128(odd_elements, even_pos_elements);\n\n        // Sum the result\n        total_sum = _mm_add_epi32(total_sum, _mm_sad_epu8(result, _mm_setzero_si128()));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    // Horizontal sum of total_sum\n    int32_t temp[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(temp), total_sum);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i total_sum = _mm_setzero_si128();\n\n    for (i = 0; i < size; i += 8) {\n        __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Extract even indexed elements (0, 2, 4, 6)\n        __m128i even_elements = _mm_unpacklo_epi16(data, _mm_setzero_si128());\n        \n        // Mask to get odd elements (1, 3, 5, 7)\n        __m128i odd_mask = _mm_and_si128(even_elements, _mm_set1_epi16(1));\n        \n        // Filter odd elements\n        __m128i odd_elements = _mm_and_si128(even_elements, odd_mask);\n        \n        // Sum the odd elements\n        total_sum = _mm_add_epi32(total_sum, _mm_sad_epu8(odd_elements, _mm_setzero_si128()));\n    }\n\n    // Horizontal sum of total_sum\n    total_sum = _mm_hadd_epi32(total_sum, total_sum);\n    total_sum = _mm_hadd_epi32(total_sum, total_sum);\n    \n    sum += _mm_cvtsi128_si64(total_sum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    __m128i sum = _mm_setzero_si128();\n    int i = 0;\n\n    for (; i <= k - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(99));\n        vec = _mm_andnot_si128(mask, vec);\n        sum = _mm_add_epi32(sum, vec);\n    }\n\n    int result = 0;\n    for (; i < k; ++i) {\n        if (arr[i] <= 99) {\n            result += arr[i];\n        }\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum);\n    result += temp[0] + temp[1] + temp[2] + temp[3];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    __m128i sum_vec = _mm_setzero_si128();\n    int sum = 0;\n\n    for (int i = 0; i < k; i += 4) {\n        __m128i input_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmpgt_epi32(input_vec, _mm_set1_epi32(99));\n        input_vec = _mm_andnot_si128(mask, input_vec);\n        sum_vec = _mm_add_epi32(sum_vec, input_vec);\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    __m128i sum = _mm_setzero_si128();\n    int count = 0;\n\n    for (int i = 0; i < k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(99));\n        vec = _mm_andnot_si128(mask, vec);\n        sum = _mm_add_epi32(sum, vec);\n        count += 4;\n    }\n\n    int result[4];\n    _mm_storeu_si128((__m128i*)result, sum);\n    \n    int total = result[0] + result[1] + result[2] + result[3];\n    \n    for (int i = count; i < k; i++) {\n        if (arr[i] <= 99) {\n            total += arr[i];\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    __m128i sum_vec = _mm_setzero_si128();\n    int count = 0;\n\n    for (int i = 0; i < k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(99));\n        vec = _mm_andnot_si128(mask, vec);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n        count += 4;\n    }\n\n    int sum[4];\n    _mm_storeu_si128((__m128i*)sum, sum_vec);\n    int total_sum = 0;\n    for (int j = 0; j < count; j++) {\n        total_sum += sum[j];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    __m128i sum_vec = _mm_setzero_si128();\n    int i = 0;\n\n    for (; i <= k - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(99));\n        vec = _mm_and_si128(vec, mask);\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    int sum = 0;\n    for (int j = 0; j < 4; ++j) {\n        sum += _mm_extract_epi32(sum_vec, j);\n    }\n\n    for (; i < k; ++i) {\n        if (arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    __m128i prev = _mm_set1_epi32(lst[0]);\n    for (size_t i = 1; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i cmp = _mm_cmpgt_epi32(current, prev);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) return false;\n\n        __m128i dup = _mm_cmpeq_epi32(current, prev);\n        if (_mm_movemask_epi8(dup) != 0) return false;\n\n        prev = current;\n    }\n\n    // Handle remaining elements if n is not a multiple of 4\n    for (size_t i = n - (n % 4); i < n; ++i) {\n        if (lst[i] < lst[i - 1] || lst[i] == lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) return true;\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    __m128i prev, curr;\n    __m128i duplicates = _mm_setzero_si128();\n    \n    for (; i + 4 <= size; i += 4) {\n        curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        if (i > 0) {\n            if (_mm_movemask_epi8(_mm_cmpgt_epi32(curr, prev)) != 0x0F) {\n                return false;\n            }\n            __m128i cmp = _mm_cmpeq_epi32(curr, prev);\n            duplicates = _mm_or_si128(duplicates, cmp);\n        }\n        prev = curr;\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (lst[i] == lst[i - 1]) return false;\n    }\n\n    if (_mm_movemask_epi8(duplicates) != 0) return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    __m128i prev = _mm_set1_epi32(lst[0]);\n    for (size_t i = 1; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i cmp = _mm_cmpgt_epi32(current, prev);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) return false;\n\n        __m128i dup = _mm_cmpeq_epi32(current, prev);\n        if (_mm_movemask_epi8(dup) != 0) return false;\n\n        prev = current;\n    }\n\n    // Handle remaining elements\n    for (size_t i = n - (n % 4); i < n; ++i) {\n        if (lst[i] < lst[i - 1] || lst[i] == lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) return true;\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Check for duplicates and sort order\n    for (; i + 4 <= size; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i + 1]);\n\n        // Check if current is greater than next\n        __m128i cmp_gt = _mm_cmpgt_epi32(current, next);\n        if (_mm_movemask_epi8(cmp_gt) != 0) return false;\n\n        // Check for duplicates\n        __m128i cmp_eq = _mm_cmpeq_epi32(current, next);\n        if (_mm_movemask_epi8(cmp_eq) != 0) return false;\n    }\n\n    // Handle remaining elements\n    for (; i < size - 1; ++i) {\n        if (lst[i] >= lst[i + 1] || (i > 0 && lst[i] == lst[i - 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    __m128i prev = _mm_set1_epi32(lst[0]);\n    __m128i duplicates = _mm_setzero_si128();\n    \n    for (size_t i = 1; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        __m128i cmp = _mm_cmpgt_epi32(current, prev);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n            return false;\n        }\n\n        __m128i eq = _mm_cmpeq_epi32(current, prev);\n        duplicates = _mm_or_si128(duplicates, eq);\n        \n        prev = current;\n    }\n\n    if (n % 4 != 0) {\n        for (size_t i = n - (n % 4); i < n; ++i) {\n            if (lst[i] < lst[i - 1]) return false;\n            if (lst[i] == lst[i - 1]) return false;\n        }\n    }\n\n    return _mm_movemask_epi8(duplicates) == 0;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    __m128i sum_magnitudes = _mm_setzero_si128();\n    __m128i prod_signs = _mm_set1_epi32(1);\n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i signs = _mm_sign_epi32(vec, vec);\n        __m128i magnitudes = _mm_abs_epi32(vec);\n\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, magnitudes);\n        prod_signs = _mm_mullo_epi32(prod_signs, signs);\n    }\n\n    int sum = 0;\n    for (int j = 0; j < 4; j++) {\n        sum += _mm_extract_epi32(sum_magnitudes, j);\n    }\n\n    for (; i < size; i++) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        prod_signs = _mm_mullo_epi32(prod_signs, _mm_set1_epi32(sign));\n        sum += std::abs(arr[i]);\n    }\n\n    int final_sign = _mm_extract_epi32(prod_signs, 0);\n    return final_sign * sum;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    __m128i sum_magnitudes = _mm_setzero_si128();\n    __m128i product_signs = _mm_set1_epi32(1);\n    __m128i zero_mask = _mm_set1_epi32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Calculate magnitudes\n        __m128i magnitudes = _mm_abs_epi32(vec);\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, magnitudes);\n        \n        // Calculate signs\n        __m128i signs = _mm_cmpgt_epi32(vec, zero_mask);\n        __m128i neg_signs = _mm_cmpgt_epi32(zero_mask, vec);\n        \n        // Update product of signs\n        product_signs = _mm_mullo_epi32(product_signs, _mm_blendv_epi8(\n            _mm_set1_epi32(-1), \n            _mm_set1_epi32(1), \n            signs));\n        product_signs = _mm_mullo_epi32(product_signs, _mm_blendv_epi8(\n            _mm_set1_epi32(1), \n            _mm_set1_epi32(-1), \n            neg_signs));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int value = arr[i];\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, _mm_set1_epi32(abs(value)));\n        if (value > 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(1));\n        } else if (value < 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(-1));\n        }\n    }\n\n    // Sum up the magnitudes\n    int magnitudes[4];\n    _mm_storeu_si128((__m128i*)magnitudes, sum_magnitudes);\n    int total_magnitude = magnitudes[0] + magnitudes[1] + magnitudes[2] + magnitudes[3];\n\n    // Get the final product of signs\n    int sign_product;\n    _mm_storeu_si128((__m128i*)&sign_product, product_signs);\n    \n    return total_magnitude * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    __m128i sum_magnitudes = _mm_setzero_si128();\n    __m128i prod_signs = _mm_set1_epi32(1);\n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i abs_vec = _mm_abs_epi32(vec);\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, abs_vec);\n\n        __m128i sign_mask = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n        __m128i neg_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        prod_signs = _mm_mullo_epi32(prod_signs, _mm_blendv_epi8(_mm_set1_epi32(-1), _mm_set1_epi32(1), sign_mask));\n        prod_signs = _mm_mullo_epi32(prod_signs, _mm_blendv_epi8(_mm_set1_epi32(0), _mm_set1_epi32(1), _mm_cmpeq_epi32(vec, _mm_setzero_si128())));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int val = arr[i];\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, _mm_set1_epi32(abs(val)));\n        if (val > 0) {\n            prod_signs = _mm_mullo_epi32(prod_signs, _mm_set1_epi32(1));\n        } else if (val < 0) {\n            prod_signs = _mm_mullo_epi32(prod_signs, _mm_set1_epi32(-1));\n        } else {\n            prod_signs = _mm_setzero_si128();\n        }\n    }\n\n    // Sum up the magnitudes\n    int magnitudes[4];\n    _mm_storeu_si128((__m128i*)magnitudes, sum_magnitudes);\n    int total_magnitude = magnitudes[0] + magnitudes[1] + magnitudes[2] + magnitudes[3];\n\n    // Calculate the final result\n    int sign_product;\n    _mm_storeu_si128((__m128i*)&sign_product, prod_signs);\n    \n    return total_magnitude * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    __m128i sum_magnitudes = _mm_setzero_si128();\n    __m128i product_signs = _mm_set1_epi32(1);\n    __m128i zero = _mm_set1_epi32(0);\n    \n    size_t size = arr.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Calculate magnitudes\n        __m128i magnitudes = _mm_abs_epi32(vec);\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, magnitudes);\n        \n        // Calculate signs\n        __m128i signs = _mm_cmpgt_epi32(vec, zero);\n        __m128i negative_signs = _mm_cmpgt_epi32(zero, vec);\n        \n        // Update product_signs\n        product_signs = _mm_mullo_epi32(product_signs, _mm_blendv_epi8(\n            _mm_set1_epi32(-1), \n            _mm_set1_epi32(1), \n            signs));\n        product_signs = _mm_mullo_epi32(product_signs, _mm_blendv_epi8(\n            _mm_set1_epi32(1), \n            _mm_set1_epi32(-1), \n            negative_signs));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int value = arr[i];\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, _mm_set1_epi32(value < 0 ? -value : value));\n        if (value > 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(1));\n        } else if (value < 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(-1));\n        }\n    }\n\n    // Horizontal sum of magnitudes\n    sum_magnitudes = _mm_hadd_epi32(sum_magnitudes, sum_magnitudes);\n    sum_magnitudes = _mm_hadd_epi32(sum_magnitudes, sum_magnitudes);\n    \n    int total_magnitude = _mm_cvtsi128_si32(sum_magnitudes);\n    int total_sign = _mm_cvtsi128_si32(product_signs);\n\n    return total_magnitude * total_sign;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    __m128i sum_magnitudes = _mm_setzero_si128();\n    __m128i product_signs = _mm_set1_epi32(1);\n    int size = arr.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i magnitudes = _mm_abs_epi32(vec);\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, magnitudes);\n\n        __m128i signs = _mm_sign_epi32(vec, _mm_set1_epi32(1));\n        product_signs = _mm_mullo_epi32(product_signs, signs);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int value = arr[i];\n        sum_magnitudes = _mm_add_epi32(sum_magnitudes, _mm_abs_epi32(_mm_set1_epi32(value)));\n        if (value > 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(1));\n        } else if (value < 0) {\n            product_signs = _mm_mullo_epi32(product_signs, _mm_set1_epi32(-1));\n        }\n    }\n\n    // Sum the magnitudes\n    int magnitudes[4];\n    _mm_storeu_si128((__m128i*)magnitudes, sum_magnitudes);\n    int total_magnitude = magnitudes[0] + magnitudes[1] + magnitudes[2] + magnitudes[3];\n\n    // Calculate the product of signs\n    int signs[4];\n    _mm_storeu_si128((__m128i*)signs, product_signs);\n    int total_sign_product = signs[0] * signs[1] * signs[2] * signs[3];\n\n    return total_magnitude * total_sign_product;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits.h>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> minPath(k, INT_MAX);\n    \n    __m128i minVal = _mm_set1_epi32(INT_MAX);\n    __m128i pathValues[4];\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int idx = 0;\n            for (int step = 0; step < k; ++step) {\n                if (step == 0) {\n                    pathValues[idx] = _mm_set1_epi32(grid[i][j]);\n                } else {\n                    // Load previous path values\n                    pathValues[idx] = _mm_loadu_si128((__m128i*)&minPath[0]);\n                    pathValues[idx] = _mm_min_epi32(pathValues[idx], _mm_set1_epi32(grid[i][j]));\n                }\n                idx++;\n            }\n            // Compare and store the minimum path\n            for (int p = 0; p < k; ++p) {\n                minVal = _mm_min_epi32(minVal, pathValues[p]);\n            }\n        }\n    }\n    \n    // Store the result\n    _mm_storeu_si128((__m128i*)&result[0], minVal);\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> minPath(k, std::numeric_limits<int>::max());\n    \n    __m128i minValue = _mm_set1_epi32(std::numeric_limits<int>::max());\n    \n    for (int startRow = 0; startRow < N; ++startRow) {\n        for (int startCol = 0; startCol < N; ++startCol) {\n            std::vector<int> path;\n            int row = startRow, col = startCol;\n            path.push_back(grid[row][col]);\n            \n            for (int step = 1; step < k; ++step) {\n                __m128i currentMin = _mm_set1_epi32(std::numeric_limits<int>::max());\n                for (int dRow = -1; dRow <= 1; ++dRow) {\n                    for (int dCol = -1; dCol <= 1; ++dCol) {\n                        if (abs(dRow) + abs(dCol) == 1) {\n                            int newRow = row + dRow;\n                            int newCol = col + dCol;\n                            if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                                __m128i value = _mm_set1_epi32(grid[newRow][newCol]);\n                                currentMin = _mm_min_epi32(currentMin, value);\n                            }\n                        }\n                    }\n                }\n                int minVal[4];\n                _mm_storeu_si128((__m128i*)minVal, currentMin);\n                for (int i = 0; i < 4; ++i) {\n                    if (minVal[i] < std::numeric_limits<int>::max()) {\n                        path.push_back(minVal[i]);\n                    }\n                }\n                row = startRow; // Reset row for next iteration\n                col = startCol; // Reset col for next iteration\n            }\n            \n            if (path.size() == k) {\n                for (int i = 0; i < k; ++i) {\n                    minPath[i] = std::min(minPath[i], path[i]);\n                }\n            }\n        }\n    }\n    \n    result = minPath;\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N, std::numeric_limits<int>::max());\n    \n    // Initialize the path with the grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // SIMD processing\n    for (int step = 0; step < k; ++step) {\n        __m128i min_values = _mm_set1_epi32(std::numeric_limits<int>::max());\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; j += 4) {\n                __m128i current_values = _mm_loadu_si128((__m128i*)&path[i * N + j]);\n                min_values = _mm_min_epi32(min_values, current_values);\n            }\n        }\n\n        // Store the minimum values back to the result\n        _mm_storeu_si128((__m128i*)&result[step], min_values);\n        \n        // Update the path for the next step\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                path[i * N + j] = std::min(path[i * N + j], result[step]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    // Flatten the grid into a single array\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path\n    __m128i minPath = _mm_set1_epi32(INT_MAX);\n    __m128i currentPath;\n\n    // Iterate through all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        std::vector<int> tempPath;\n        int x = start / N;\n        int y = start % N;\n\n        // Collect the path of length k\n        for (int step = 0; step < k; ++step) {\n            if (x < 0 || x >= N || y < 0 || y >= N) break;\n            tempPath.push_back(grid[x][y]);\n\n            // Move to the next cell (up, down, left, right)\n            if (step % 2 == 0) {\n                if (y + 1 < N) y++;\n            } else {\n                if (x + 1 < N) x++;\n            }\n        }\n\n        // Compare paths using SIMD\n        for (int i = 0; i < tempPath.size(); i += 4) {\n            currentPath = _mm_loadu_si128((__m128i*)&tempPath[i]);\n            minPath = _mm_min_epi32(minPath, currentPath);\n        }\n    }\n\n    // Store the result\n    _mm_storeu_si128((__m128i*)&result[0], minPath);\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> minPath(k, std::numeric_limits<int>::max());\n\n    for (int startRow = 0; startRow < N; ++startRow) {\n        for (int startCol = 0; startCol < N; ++startCol) {\n            std::vector<int> path(k);\n            int row = startRow, col = startCol;\n\n            for (int step = 0; step < k; ++step) {\n                path[step] = grid[row][col];\n\n                if (step < k - 1) {\n                    __m128i current = _mm_set1_epi32(grid[row][col]);\n                    __m128i minVal = _mm_set1_epi32(std::numeric_limits<int>::max());\n\n                    for (int dr = -1; dr <= 1; ++dr) {\n                        for (int dc = -1; dc <= 1; ++dc) {\n                            if (abs(dr) + abs(dc) == 1) {\n                                int newRow = row + dr;\n                                int newCol = col + dc;\n                                if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                                    __m128i neighbor = _mm_set1_epi32(grid[newRow][newCol]);\n                                    minVal = _mm_min_epi32(minVal, neighbor);\n                                }\n                            }\n                        }\n                    }\n\n                    int minNeighbor;\n                    _mm_store_ss((float*)&minNeighbor, _mm_cvtepi32_ps(minVal));\n                    row = newRow; // Update row to the minimum neighbor\n                    col = newCol; // Update col to the minimum neighbor\n                }\n            }\n\n            for (int i = 0; i < k; ++i) {\n                if (path[i] < minPath[i]) {\n                    minPath = path;\n                    break;\n                }\n            }\n        }\n    }\n\n    return minPath;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    __m128i result = zero;\n\n    while (n > 0) {\n        __m128i digits = _mm_set_epi8(\n            (n % 10) & 0xFF,\n            (n / 10 % 10) & 0xFF,\n            (n / 100 % 10) & 0xFF,\n            (n / 1000 % 10) & 0xFF,\n            (n / 10000 % 10) & 0xFF,\n            (n / 100000 % 10) & 0xFF,\n            (n / 1000000 % 10) & 0xFF,\n            (n / 10000000 % 10) & 0xFF,\n            (n / 100000000 % 10) & 0xFF,\n            (n / 1000000000 % 10) & 0xFF,\n            (n / 10000000000 % 10) & 0xFF,\n            (n / 100000000000 % 10) & 0xFF,\n            (n / 1000000000000 % 10) & 0xFF,\n            (n / 10000000000000 % 10) & 0xFF,\n            (n / 100000000000000 % 10) & 0xFF,\n            (n / 1000000000000000 % 10) & 0xFF\n        );\n\n        __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n        __m128i non_zero_odd_digits = _mm_and_si128(odd_digits, _mm_cmpgt_epi8(odd_digits, zero));\n\n        product = _mm_mullo_epi8(product, non_zero_odd_digits);\n        result = _mm_or_si128(result, non_zero_odd_digits);\n\n        n /= 10000000000; // Move to the next set of digits\n    }\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; i++) {\n        int8_t val = _mm_extract_epi8(product, i);\n        if (val > 0) final_product *= val;\n    }\n\n    return (final_product == 1 && _mm_movemask_epi8(result) == 0) ? 0 : final_product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    \n    uint8_t digits[16] = {0};\n    int i = 0;\n\n    while (n > 0) {\n        digits[i++] = n % 10;\n        n /= 10;\n    }\n\n    __m128i vec = _mm_loadu_si128((__m128i*)digits);\n    vec = _mm_and_si128(vec, _mm_set1_epi8(0x0F)); // Mask to get only the last 4 bits (digits 0-9)\n\n    for (int j = 0; j < 16; j += 16) {\n        __m128i odd_digits = _mm_and_si128(vec, _mm_set1_epi8(0x01)); // Get odd digits\n        __m128i even_digits = _mm_andnot_si128(odd_digits, vec); // Get even digits\n\n        // Multiply odd digits\n        product = _mm_mullo_epi8(product, odd_digits);\n        \n        // Check if all digits are even\n        if (_mm_movemask_epi8(even_digits) == 0xFFFF) {\n            return 0;\n        }\n    }\n\n    // Reduce the product\n    uint8_t result[16];\n    _mm_storeu_si128((__m128i*)result, product);\n    \n    uint64_t final_product = 1;\n    for (int k = 0; k < 16; k++) {\n        if (result[k] != 0) {\n            final_product *= result[k];\n        }\n    }\n\n    return final_product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    __m128i result = zero;\n\n    while (n > 0) {\n        __m128i digits = _mm_set_epi8(\n            (n % 10) & 0xFF, \n            (n / 10 % 10) & 0xFF, \n            (n / 100 % 10) & 0xFF, \n            (n / 1000 % 10) & 0xFF, \n            (n / 10000 % 10) & 0xFF, \n            (n / 100000 % 10) & 0xFF, \n            (n / 1000000 % 10) & 0xFF, \n            (n / 10000000 % 10) & 0xFF\n        );\n\n        __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n        __m128i non_zero_odd_digits = _mm_and_si128(odd_digits, _mm_cmpeq_epi8(odd_digits, zero));\n\n        product = _mm_mullo_epi8(product, non_zero_odd_digits);\n        result = _mm_or_si128(result, product);\n\n        n /= 100000000; // Move to the next 8 digits\n    }\n\n    // Extract the product from the SIMD register\n    uint8_t prod_array[16];\n    _mm_storeu_si128((__m128i*)prod_array, result);\n    \n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; i++) {\n        if (prod_array[i] % 2 != 0) {\n            final_product *= prod_array[i];\n        }\n    }\n\n    return (final_product == 1) ? 0 : final_product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    __m128i result = zero;\n\n    while (n > 0) {\n        __m128i digits = _mm_set_epi8(\n            (n % 10) & 0xFF,\n            (n / 10 % 10) & 0xFF,\n            (n / 100 % 10) & 0xFF,\n            (n / 1000 % 10) & 0xFF,\n            (n / 10000 % 10) & 0xFF,\n            (n / 100000 % 10) & 0xFF,\n            (n / 1000000 % 10) & 0xFF,\n            (n / 10000000 % 10) & 0xFF,\n            (n / 100000000 % 10) & 0xFF,\n            (n / 1000000000 % 10) & 0xFF,\n            (n / 10000000000 % 10) & 0xFF,\n            (n / 100000000000 % 10) & 0xFF,\n            (n / 1000000000000 % 10) & 0xFF,\n            (n / 10000000000000 % 10) & 0xFF,\n            (n / 100000000000000 % 10) & 0xFF,\n            (n / 1000000000000000 % 10) & 0xFF\n        );\n\n        __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n        __m128i is_non_zero = _mm_cmpgt_epi8(odd_digits, zero);\n        __m128i product_mask = _mm_and_si128(is_non_zero, odd_digits);\n        \n        product = _mm_mullo_epi8(product, product_mask);\n        result = _mm_or_si128(result, product);\n\n        n /= 10000000000; // Move to the next 10 digits\n    }\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; i++) {\n        uint8_t val = _mm_extract_epi8(result, i);\n        if (val != 0) {\n            final_product *= val;\n        }\n    }\n\n    return final_product == 1 ? 0 : final_product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t digits_simd(uint64_t n) {\n    __m128i odd_mask = _mm_set1_epi8(0x01);\n    __m128i product = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8(0);\n    __m128i result = zero;\n\n    while (n > 0) {\n        __m128i digits = _mm_set_epi8(\n            (n % 10) & 0xFF,\n            (n / 10 % 10) & 0xFF,\n            (n / 100 % 10) & 0xFF,\n            (n / 1000 % 10) & 0xFF,\n            (n / 10000 % 10) & 0xFF,\n            (n / 100000 % 10) & 0xFF,\n            (n / 1000000 % 10) & 0xFF,\n            (n / 10000000 % 10) & 0xFF,\n            (n / 100000000 % 10) & 0xFF,\n            (n / 1000000000 % 10) & 0xFF,\n            (n / 10000000000 % 10) & 0xFF,\n            (n / 100000000000 % 10) & 0xFF,\n            (n / 1000000000000 % 10) & 0xFF,\n            (n / 10000000000000 % 10) & 0xFF,\n            (n / 100000000000000 % 10) & 0xFF,\n            (n / 1000000000000000 % 10) & 0xFF\n        );\n\n        __m128i odd_digits = _mm_and_si128(digits, odd_mask);\n        __m128i is_odd = _mm_cmpgt_epi8(odd_digits, zero);\n        __m128i odd_product = _mm_and_si128(digits, is_odd);\n\n        product = _mm_mullo_epi8(product, odd_product);\n        result = _mm_or_si128(result, odd_product);\n\n        n /= 10000000000; // Move to the next set of digits\n    }\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; i++) {\n        uint8_t val = ((uint8_t*)&product)[i];\n        if (val != 0) {\n            final_product *= val;\n        }\n    }\n\n    return (final_product == 1 && result[0] == 0) ? 0 : final_product;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    __m128 sum = _mm_setzero_ps();\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        vec = _mm_ceil_ps(vec);\n        sum = _mm_add_ps(sum, _mm_mul_ps(vec, vec));\n    }\n\n    // Horizontal sum of the 4 elements in the sum vector\n    sum = _mm_hadd_ps(sum, sum);\n    sum = _mm_hadd_ps(sum, sum);\n    \n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total = static_cast<uint64_t>(result[0]);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        total += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    __m128 sum = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        vec = _mm_ceil_ps(vec);\n        vec = _mm_mul_ps(vec, vec);\n        sum = _mm_add_ps(sum, vec);\n    }\n\n    // Horizontal sum of the 4 elements in the sum vector\n    sum = _mm_hadd_ps(sum, sum);\n    sum = _mm_hadd_ps(sum, sum);\n    \n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    return static_cast<uint64_t>(result[0]);\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    __m128 sum = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        vec = _mm_ceil_ps(vec);\n        sum = _mm_add_ps(sum, _mm_mul_ps(vec, vec));\n    }\n\n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    \n    uint64_t total = static_cast<uint64_t>(temp[0]) + static_cast<uint64_t>(temp[1]) +\n                     static_cast<uint64_t>(temp[2]) + static_cast<uint64_t>(temp[3]);\n\n    for (size_t i = n - (n % 4); i < n; ++i) {\n        total += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t i = 0;\n    __m128 sum = _mm_setzero_ps();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        vec = _mm_ceil_ps(vec);\n        vec = _mm_mul_ps(vec, vec);\n        sum = _mm_add_ps(sum, vec);\n    }\n\n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    uint64_t total = static_cast<uint64_t>(temp[0] + temp[1] + temp[2] + temp[3]);\n\n    for (; i < size; ++i) {\n        total += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    __m128 sum = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        vec = _mm_ceil_ps(vec);\n        vec = _mm_mul_ps(vec, vec);\n        sum = _mm_add_ps(sum, vec);\n    }\n    \n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    \n    uint64_t total = static_cast<uint64_t>(temp[0]) + static_cast<uint64_t>(temp[1]) + \n                     static_cast<uint64_t>(temp[2]) + static_cast<uint64_t>(temp[3]);\n    \n    for (size_t i = n - (n % 4); i < n; ++i) {\n        float ceil_val = std::ceil(lst[i]);\n        total += static_cast<uint64_t>(ceil_val * ceil_val);\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    __m128i prev, curr;\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&arr[i - 1]);\n        curr = _mm_loadu_si128((__m128i*)&arr[i]);\n\n        __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask) {\n            for (int j = 0; j < 4; ++j) {\n                if (mask & (1 << (j * 2))) {\n                    result = i + j - 1;\n                }\n            }\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            result = i - 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    __m128i prev, curr;\n    int index = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&arr[i - 1]);\n        curr = _mm_loadu_si128((__m128i*)&arr[i]);\n\n        __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask) {\n            index = i - 1 + __builtin_ctz(mask) / 4;\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    __m128i prev, curr;\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&arr[i - 1]);\n        curr = _mm_loadu_si128((__m128i*)&arr[i]);\n\n        __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask) {\n            for (int j = 0; j < 4; ++j) {\n                if (mask & (1 << (j * 2))) {\n                    result = i + j - 1;\n                }\n            }\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            result = i - 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    __m128i prev, curr;\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        prev = _mm_loadu_si128((__m128i*)&arr[i - 1]);\n        curr = _mm_loadu_si128((__m128i*)&arr[i]);\n\n        __m128i cmp = _mm_cmpgt_epi32(prev, curr);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask) {\n            for (int j = 0; j < 4; ++j) {\n                if (mask & (1 << (j * 2))) {\n                    result = i + j;\n                }\n            }\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    __m128i max_index = _mm_set1_epi32(-1);\n    __m128i prev = _mm_set1_epi32(arr[0]);\n\n    for (int i = 1; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i cmp = _mm_cmpgt_epi32(prev, current);\n        int mask = _mm_movemask_epi8(cmp);\n\n        if (mask) {\n            for (int j = 0; j < 4; ++j) {\n                if (mask & (1 << (j * 2))) {\n                    max_index = _mm_max_epi32(max_index, _mm_set1_epi32(i + j));\n                }\n            }\n        }\n\n        prev = current;\n    }\n\n    int indices[4];\n    _mm_storeu_si128((__m128i*)indices, max_index);\n    int result = -1;\n    for (int i = 0; i < 4; ++i) {\n        if (indices[i] != -1) {\n            result = std::max(result, indices[i]);\n        }\n    }\n\n    return result == -1 ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    __m128i max_neg = _mm_set1_epi32(std::numeric_limits<int>::min());\n    __m128i min_pos = _mm_set1_epi32(std::numeric_limits<int>::max());\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        __m128i neg_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        __m128i pos_mask = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n\n        __m128i neg_values = _mm_and_si128(vec, neg_mask);\n        __m128i pos_values = _mm_and_si128(vec, pos_mask);\n\n        max_neg = _mm_max_epi32(max_neg, neg_values);\n        min_pos = _mm_min_epi32(min_pos, pos_values);\n    }\n\n    int max_neg_array[4], min_pos_array[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(max_neg_array), max_neg);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_pos_array), min_pos);\n\n    int max_neg_result = max_neg_array[0];\n    for (int j = 1; j < 4; ++j) {\n        max_neg_result = std::max(max_neg_result, max_neg_array[j]);\n    }\n\n    int min_pos_result = min_pos_array[0];\n    for (int j = 1; j < 4; ++j) {\n        min_pos_result = std::min(min_pos_result, min_pos_array[j]);\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg_result = std::max(max_neg_result, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_result = std::min(min_pos_result, lst[i]);\n        }\n    }\n\n    if (max_neg_result == std::numeric_limits<int>::min()) {\n        max_neg_result = 0;\n    }\n    if (min_pos_result == std::numeric_limits<int>::max()) {\n        min_pos_result = 0;\n    }\n\n    return {max_neg_result, min_pos_result};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    __m128i max_neg = _mm_set1_epi32(INT32_MIN);\n    __m128i min_pos = _mm_set1_epi32(INT32_MAX);\n    int size = lst.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i neg_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        __m128i pos_mask = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n\n        max_neg = _mm_max_epi32(max_neg, _mm_and_si128(vec, neg_mask));\n        min_pos = _mm_min_epi32(min_pos, _mm_and_si128(vec, pos_mask));\n    }\n\n    int max_neg_arr[4], min_pos_arr[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(max_neg_arr), max_neg);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_pos_arr), min_pos);\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg_arr[0] = std::max(max_neg_arr[0], lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_arr[0] = std::min(min_pos_arr[0], lst[i]);\n        }\n    }\n\n    int largest_neg = (max_neg_arr[0] == INT32_MIN) ? 0 : max_neg_arr[0];\n    int smallest_pos = (min_pos_arr[0] == INT32_MAX) ? 0 : min_pos_arr[0];\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    __m128i neg_inf = _mm_set1_epi32(std::numeric_limits<int>::min());\n    __m128i pos_inf = _mm_set1_epi32(std::numeric_limits<int>::max());\n    __m128i largest_neg = neg_inf;\n    __m128i smallest_pos = pos_inf;\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i mask_neg = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        __m128i mask_pos = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n\n        largest_neg = _mm_max_epi32(largest_neg, _mm_and_si128(vec, mask_neg));\n        smallest_pos = _mm_min_epi32(smallest_pos, _mm_and_si128(vec, mask_pos));\n    }\n\n    int largest_neg_array[4], smallest_pos_array[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(largest_neg_array), largest_neg);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(smallest_pos_array), smallest_pos);\n\n    int largest_neg_result = largest_neg_array[0];\n    for (int j = 1; j < 4; ++j) {\n        largest_neg_result = std::max(largest_neg_result, largest_neg_array[j]);\n    }\n\n    int smallest_pos_result = smallest_pos_array[0];\n    for (int j = 1; j < 4; ++j) {\n        smallest_pos_result = std::min(smallest_pos_result, smallest_pos_array[j]);\n    }\n\n    if (largest_neg_result == std::numeric_limits<int>::min()) {\n        largest_neg_result = 0;\n    }\n    if (smallest_pos_result == std::numeric_limits<int>::max()) {\n        smallest_pos_result = 0;\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            largest_neg_result = std::max(largest_neg_result, lst[i]);\n        } else if (lst[i] > 0) {\n            smallest_pos_result = std::min(smallest_pos_result, lst[i]);\n        }\n    }\n\n    return {largest_neg_result, smallest_pos_result};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    __m128i max_neg = _mm_set1_epi32(INT32_MIN);\n    __m128i min_pos = _mm_set1_epi32(INT32_MAX);\n    int size = lst.size();\n    int i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i neg_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        __m128i pos_mask = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n\n        max_neg = _mm_max_epi32(max_neg, _mm_and_si128(vec, neg_mask));\n        min_pos = _mm_min_epi32(min_pos, _mm_and_si128(vec, pos_mask));\n    }\n\n    int max_neg_arr[4], min_pos_arr[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(max_neg_arr), max_neg);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_pos_arr), min_pos);\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            max_neg_arr[0] = std::max(max_neg_arr[0], lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_arr[0] = std::min(min_pos_arr[0], lst[i]);\n        }\n    }\n\n    int largest_neg = (max_neg_arr[0] == INT32_MIN) ? 0 : max_neg_arr[0];\n    int smallest_pos = (min_pos_arr[0] == INT32_MAX) ? 0 : min_pos_arr[0];\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    __m128i max_neg = _mm_set1_epi32(0); // Initialize to 0 for max negative\n    __m128i min_pos = _mm_set1_epi32(0); // Initialize to 0 for min positive\n    bool has_neg = false, has_pos = false;\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        __m128i neg_mask = _mm_cmpgt_epi32(_mm_setzero_si128(), vec);\n        __m128i pos_mask = _mm_cmpgt_epi32(vec, _mm_setzero_si128());\n\n        if (_mm_movemask_epi8(neg_mask)) {\n            has_neg = true;\n            max_neg = _mm_max_epi32(max_neg, vec);\n        }\n        if (_mm_movemask_epi8(pos_mask)) {\n            has_pos = true;\n            min_pos = _mm_min_epi32(min_pos, vec);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0) {\n            has_neg = true;\n            max_neg = _mm_max_epi32(max_neg, _mm_set1_epi32(lst[i]));\n        } else if (lst[i] > 0) {\n            has_pos = true;\n            min_pos = _mm_min_epi32(min_pos, _mm_set1_epi32(lst[i]));\n        }\n    }\n\n    // Extract results\n    int max_neg_arr[4], min_pos_arr[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(max_neg_arr), max_neg);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(min_pos_arr), min_pos);\n\n    int largest_neg = has_neg ? max_neg_arr[0] : 0;\n    int smallest_pos = has_pos ? min_pos_arr[0] : 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    __m128i result = _mm_set1_epi64x(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        __m128i current = _mm_set_epi64x(i, i + 1);\n        result = _mm_mullo_epi64(result, current);\n    }\n\n    uint64_t res[2];\n    _mm_storeu_si128((__m128i*)res, result);\n    return res[0] * res[1];\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    __m128i result = _mm_set1_epi64x(1);\n    for (uint64_t i = 1; i <= n; ++i) {\n        __m128i temp = _mm_set1_epi64x(i);\n        result = _mm_mullo_epi64(result, temp);\n    }\n\n    uint64_t res[2];\n    _mm_storeu_si128((__m128i*)res, result);\n    return res[0] * res[1];\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    __m128i result = _mm_set1_epi64x(1);\n    for (uint64_t i = 1; i <= n; ++i) {\n        __m128i factorial = _mm_set1_epi64x(i);\n        for (uint64_t j = 1; j < i; ++j) {\n            factorial = _mm_mullo_epi64(factorial, _mm_set1_epi64x(j));\n        }\n        result = _mm_mullo_epi64(result, factorial);\n    }\n\n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    __m128i result = _mm_set1_epi64x(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        __m128i current = _mm_set_epi64x(i, i + 1);\n        __m128i factorial = _mm_set_epi64x(1, 1);\n        \n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial = _mm_mullo_epi64(factorial, _mm_set_epi64x(j, j));\n        }\n        \n        result = _mm_mullo_epi64(result, factorial);\n    }\n\n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    __m128i result = _mm_set1_epi64x(1);\n    for (uint64_t i = 1; i <= n; i += 2) {\n        __m128i current = _mm_set_epi64x(i, i + 1);\n        result = _mm_mullo_epi64(result, current);\n    }\n\n    uint64_t res[2];\n    _mm_storeu_si128((__m128i*)res, result);\n    return res[0] * (n % 2 == 0 ? res[1] : 1);\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        \n        __m128i mask_square = _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(3)), _mm_setzero_si128());\n        __m128i mask_cube = _mm_andnot_si128(mask_square, _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(4)), _mm_setzero_si128()));\n        \n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n        \n        vec = _mm_or_si128(_mm_and_si128(mask_square, squared), _mm_and_si128(mask_cube, cubed));\n        \n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Horizontal sum of the vector\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    \n    sum += _mm_cvtsi128_si32(sum_vec);\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        __m128i mask_square = _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(3)), _mm_setzero_si128());\n        __m128i mask_cube = _mm_andnot_si128(mask_square, _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(4)), _mm_setzero_si128()));\n\n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n\n        vec = _mm_or_si128(_mm_and_si128(mask_square, squared), _mm_and_si128(mask_cube, cubed));\n\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n\n    for (size_t j = 0; j < 4; ++j) {\n        sum += temp[j];\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n\n        __m128i index = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i mask3 = _mm_cmpeq_epi32(_mm_and_si128(index, _mm_set1_epi32(3)), _mm_setzero_si128());\n        __m128i mask4 = _mm_cmpeq_epi32(_mm_and_si128(index, _mm_set1_epi32(4)), _mm_setzero_si128());\n\n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n\n        vec = _mm_or_si128(_mm_and_si128(mask3, squared), _mm_andnot_si128(mask3, vec));\n        vec = _mm_or_si128(_mm_and_si128(mask4, cubed), _mm_andnot_si128(mask4, vec));\n\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n\n        __m128i mask_square = _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(3)), _mm_setzero_si128());\n        __m128i mask_cube = _mm_andnot_si128(mask_square, _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(4)), _mm_setzero_si128()));\n\n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n\n        vec = _mm_or_si128(_mm_and_si128(mask_square, squared), _mm_and_si128(mask_cube, cubed));\n\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n\n    for (size_t j = 0; j < 4; ++j) {\n        sum += temp[j];\n    }\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n\n        __m128i index = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i mask3 = _mm_cmpeq_epi32(_mm_and_si128(index, _mm_set1_epi32(3)), _mm_setzero_si128());\n        __m128i mask4 = _mm_cmpeq_epi32(_mm_and_si128(index, _mm_set1_epi32(4)), _mm_setzero_si128());\n        \n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n\n        vec = _mm_or_si128(_mm_and_si128(mask3, squared), _mm_and_si128(mask4, cubed));\n        \n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n\n    // Horizontal sum of the vector\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n    sum += _mm_cvtsi128_si32(sum_vec);\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i odd_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for odd digits\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i greater_than_ten = _mm_cmpgt_epi32(vec, ten);\n\n        // Extract first and last digits\n        __m128i first_digit = _mm_and_si128(vec, _mm_set1_epi32(0xF0000000)); // Get first digit\n        __m128i last_digit = _mm_and_si128(vec, _mm_set1_epi32(0x0000000F)); // Get last digit\n\n        // Check if first and last digits are odd\n        __m128i first_odd = _mm_and_si128(first_digit, odd_mask);\n        __m128i last_odd = _mm_and_si128(last_digit, odd_mask);\n        __m128i both_odd = _mm_and_si128(first_odd, last_odd);\n\n        // Combine conditions\n        __m128i result = _mm_and_si128(greater_than_ten, both_odd);\n\n        // Count the number of true conditions\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = nums[i] % 10;\n            if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i odd_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for odd digits\n    __m128i ten_mask = _mm_set1_epi32(10); // Mask for comparison with 10\n    __m128i first_digit_mask = _mm_set1_epi32(0xF0000000); // Mask for first digit\n    __m128i last_digit_mask = _mm_set1_epi32(0x0000000F); // Mask for last digit\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Check if greater than 10\n        __m128i greater_than_ten = _mm_cmpgt_epi32(vec, ten_mask);\n        \n        // Extract first and last digits\n        __m128i first_digit = _mm_and_si128(_mm_srli_epi32(vec, 28), _mm_set1_epi32(0x0F));\n        __m128i last_digit = _mm_and_si128(vec, last_digit_mask);\n        \n        // Check if first and last digits are odd\n        __m128i first_odd = _mm_and_si128(first_digit, odd_mask);\n        __m128i last_odd = _mm_and_si128(last_digit, odd_mask);\n        \n        // Combine conditions\n        __m128i odd_condition = _mm_and_si128(first_odd, last_odd);\n        __m128i valid_condition = _mm_and_si128(greater_than_ten, odd_condition);\n        \n        // Count valid numbers\n        count += _mm_popcnt_u32(_mm_movemask_epi8(valid_condition));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = nums[i] % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i odd_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for odd digits (1, 3, 5, 7, 9)\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Check if elements are greater than 10\n        __m128i greater_than_ten = _mm_cmpgt_epi32(vec, ten);\n        \n        // Extract first and last digits\n        __m128i first_digit = _mm_srli_epi32(vec, 28); // Get first digit (assuming 32-bit int)\n        __m128i last_digit = _mm_and_si128(vec, _mm_set1_epi32(0xF)); // Get last digit\n        \n        // Check if first and last digits are odd\n        __m128i first_odd = _mm_and_si128(first_digit, odd_mask);\n        __m128i last_odd = _mm_and_si128(last_digit, odd_mask);\n        \n        // Combine conditions\n        __m128i both_odd = _mm_and_si128(first_odd, last_odd);\n        __m128i valid_elements = _mm_and_si128(greater_than_ten, both_odd);\n        \n        // Count valid elements\n        count += _mm_popcnt_u32(_mm_movemask_epi8(valid_elements));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = std::abs(nums[i]) % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i odd_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for odd digits (1, 3, 5, 7, 9)\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i greater_than_ten = _mm_cmpgt_epi32(vec, ten);\n        \n        // Extract first and last digits\n        __m128i first_digit = _mm_and_si128(vec, _mm_set1_epi32(0xF0000000)); // Get first digit\n        __m128i last_digit = _mm_and_si128(vec, _mm_set1_epi32(0x0000000F)); // Get last digit\n        \n        // Check if first and last digits are odd\n        first_digit = _mm_and_si128(first_digit, odd_mask);\n        last_digit = _mm_and_si128(last_digit, odd_mask);\n        \n        __m128i both_odd = _mm_and_si128(first_digit, last_digit);\n        \n        // Combine conditions\n        __m128i result = _mm_and_si128(greater_than_ten, both_odd);\n        \n        // Count the number of true conditions\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::abs(nums[i]);\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = nums[i] % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i odd_mask = _mm_set1_epi32(0xAAAAAAAA); // Mask for odd digits\n\n    for (; i + 4 <= size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i greater_than_ten = _mm_cmpgt_epi32(vec, ten);\n\n        // Extract first and last digits\n        __m128i first_digit = _mm_and_si128(vec, _mm_set1_epi32(0xF0000000)); // Get first digit\n        __m128i last_digit = _mm_and_si128(vec, _mm_set1_epi32(0x0000000F)); // Get last digit\n\n        // Check if first and last digits are odd\n        first_digit = _mm_srli_epi32(first_digit, 28); // Shift to get first digit\n        last_digit = _mm_and_si128(last_digit, _mm_set1_epi32(0x0F)); // Mask last digit\n\n        __m128i first_odd = _mm_and_si128(first_digit, odd_mask);\n        __m128i last_odd = _mm_and_si128(last_digit, odd_mask);\n\n        __m128i both_odd = _mm_and_si128(first_odd, last_odd);\n        __m128i valid_numbers = _mm_and_si128(greater_than_ten, both_odd);\n\n        // Count valid numbers\n        count += _mm_popcnt_u32(_mm_movemask_epi8(valid_numbers));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (nums[i] > 10) {\n            int first_digit = std::to_string(nums[i]).front() - '0';\n            int last_digit = std::to_string(nums[i]).back() - '0';\n            if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    __m128i count = _mm_setzero_si128();\n    __m128i mod_count[3] = {_mm_setzero_si128(), _mm_setzero_si128(), _mm_setzero_si128()};\n\n    for (uint64_t i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i + 3, i);\n        __m128i squares = _mm_mullo_epi32(indices, indices);\n        __m128i results = _mm_sub_epi32(squares, indices);\n        results = _mm_add_epi32(results, _mm_set1_epi32(1));\n\n        for (int j = 0; j < 4 && (i + j) <= n; j++) {\n            int value = _mm_extract_epi32(results, j);\n            int mod = value % 3;\n            mod_count[mod] = _mm_add_epi32(mod_count[mod], _mm_set1_epi32(1));\n        }\n    }\n\n    uint64_t total_triples = 0;\n    uint64_t mod0 = _mm_cvtsi128_si64(mod_count[0]);\n    uint64_t mod1 = _mm_cvtsi128_si64(mod_count[1]);\n    uint64_t mod2 = _mm_cvtsi128_si64(mod_count[2]);\n\n    total_triples += (mod0 * (mod0 - 1) * (mod0 - 2)) / 6; // C(mod0, 3)\n    total_triples += (mod1 * (mod1 - 1) * (mod1 - 2)) / 6; // C(mod1, 3)\n    total_triples += (mod2 * (mod2 - 1) * (mod2 - 2)) / 6; // C(mod2, 3)\n    total_triples += (mod0 * mod1 * mod2); // C(mod0, 1) * C(mod1, 1) * C(mod2, 1)\n\n    return total_triples;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    __m128i count = _mm_setzero_si128();\n    __m128i mod3_count = _mm_setzero_si128();\n    __m128i indices = _mm_set_epi32(0, 1, 2, 3);\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        __m128i idx = _mm_add_epi32(indices, _mm_set1_epi32(i - 1));\n        __m128i a = _mm_sub_epi32(_mm_mullo_epi32(idx, idx), idx);\n        a = _mm_add_epi32(a, _mm_set1_epi32(1));\n        \n        __m128i mod3 = _mm_and_si128(a, _mm_set1_epi32(3));\n        mod3_count = _mm_add_epi32(mod3_count, _mm_set_epi32(0, 0, 0, _mm_extract_epi32(mod3, 0)));\n        mod3_count = _mm_add_epi32(mod3_count, _mm_set_epi32(0, 0, _mm_extract_epi32(mod3, 1), 0));\n        mod3_count = _mm_add_epi32(mod3_count, _mm_set_epi32(0, _mm_extract_epi32(mod3, 2), 0, 0));\n        mod3_count = _mm_add_epi32(mod3_count, _mm_set_epi32(_mm_extract_epi32(mod3, 3), 0, 0, 0));\n        \n        indices = _mm_add_epi32(indices, _mm_set1_epi32(4));\n    }\n\n    uint64_t total_count = 0;\n    for (int i = 0; i < 4; i++) {\n        total_count += _mm_extract_epi32(mod3_count, i);\n    }\n\n    return total_count / 3; // Each triple counted 3 times\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    __m128i count = _mm_setzero_si128();\n    __m128i mod_count = _mm_setzero_si128();\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(i + 3, i + 2, i + 1, i);\n        __m128i values = _mm_sub_epi32(_mm_mullo_epi32(indices, indices), indices);\n        values = _mm_add_epi32(values, _mm_set1_epi32(1));\n        __m128i mod = _mm_and_si128(values, _mm_set1_epi32(3));\n        \n        for (int j = 0; j < 4; j++) {\n            int mod_val = _mm_extract_epi32(mod, j);\n            if (mod_val >= 0 && mod_val < 3) {\n                mod_count = _mm_add_epi32(mod_count, _mm_set1_epi32(1));\n            }\n        }\n        \n        if (i + 3 <= n) {\n            for (int j = 0; j < 4; j++) {\n                int mod_val = _mm_extract_epi32(mod, j);\n                if (mod_val == 0) {\n                    count = _mm_add_epi32(count, _mm_set1_epi32(1));\n                }\n            }\n        }\n    }\n\n    uint64_t total_count = _mm_cvtsi128_si64(count);\n    uint64_t total_mod_count = _mm_cvtsi128_si64(mod_count);\n    \n    return (total_count * (total_mod_count - 1)) / 2;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <cstdint>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    __m128i count = _mm_setzero_si128();\n    __m128i mod_count = _mm_setzero_si128();\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i + 3, i);\n        __m128i values = _mm_add_epi64(_mm_mullo_epi64(indices, indices), _mm_set1_epi64x(-i + 1));\n        __m128i mod_values = _mm_rem_epi64(values, _mm_set1_epi64x(3));\n\n        for (int j = 0; j < 4; ++j) {\n            int mod = _mm_extract_epi64(mod_values, j);\n            if (mod >= 0 && mod < 3) {\n                mod_count = _mm_add_epi64(mod_count, _mm_set1_epi64x(1));\n            }\n        }\n    }\n\n    uint64_t total_count = _mm_cvtsi128_si64(mod_count);\n    return (total_count * (total_count - 1) * (total_count - 2)) / 6;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    __m128i count = _mm_setzero_si128();\n    __m128i mod_count = _mm_setzero_si128();\n    __m128i indices = _mm_set_epi32(0, 1, 2, 3);\n    \n    for (uint64_t i = 1; i <= n; i += 4) {\n        __m128i idx = _mm_add_epi32(indices, _mm_set1_epi32(i - 1));\n        __m128i a = _mm_sub_epi32(_mm_mullo_epi32(idx, idx), idx);\n        a = _mm_add_epi32(a, _mm_set1_epi32(1));\n        \n        __m128i mod = _mm_and_si128(a, _mm_set1_epi32(3));\n        mod_count = _mm_add_epi32(mod_count, _mm_set_epi32(0, 0, 0, _mm_extract_epi32(mod, 0)));\n        mod_count = _mm_add_epi32(mod_count, _mm_set_epi32(0, 0, _mm_extract_epi32(mod, 1), 0));\n        mod_count = _mm_add_epi32(mod_count, _mm_set_epi32(0, _mm_extract_epi32(mod, 2), 0, 0));\n        mod_count = _mm_add_epi32(mod_count, _mm_set_epi32(_mm_extract_epi32(mod, 3), 0, 0, 0));\n        \n        indices = _mm_add_epi32(indices, _mm_set1_epi32(4));\n    }\n\n    uint32_t counts[4];\n    _mm_storeu_si128((__m128i*)counts, mod_count);\n    \n    uint64_t total_triples = 0;\n    for (int i = 0; i < 3; ++i) {\n        total_triples += counts[i] * counts[i + 1] * counts[i + 2];\n    }\n\n    return total_triples / 6; // Divide by 6 for combinations of triples\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    \n    int prime = is_prime(n);\n    __m128i result = _mm_blend_epi16(y_vec, x_vec, prime ? 0 : 0xFFFF);\n    \n    return _mm_cvtsi128_si32(result);\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    \n    int prime = is_prime(n);\n    __m128i result = _mm_blend_epi16(y_vec, x_vec, prime ? 0 : 0xFFFF);\n    \n    return _mm_cvtsi128_si32(result);\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    \n    // Check if n is prime\n    int prime = is_prime(n);\n    __m128i result = _mm_blend_epi16(y_vec, x_vec, prime ? 0 : 0xFFFF);\n    \n    return _mm_cvtsi128_si32(result);\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    \n    int prime = is_prime(n);\n    __m128i result = _mm_blend_epi16(y_vec, x_vec, prime ? 0 : 0xFFFF);\n    \n    return _mm_cvtsi128_si32(result);\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    __m128i n_vec = _mm_set1_epi32(n);\n    __m128i x_vec = _mm_set1_epi32(x);\n    __m128i y_vec = _mm_set1_epi32(y);\n    \n    int prime = is_prime(n);\n    \n    __m128i result = _mm_blend_epi16(y_vec, x_vec, prime ? 0 : 0xFFFF);\n    \n    return _mm_cvtsi128_si32(result);\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    __m128 sum = _mm_setzero_ps();\n    __m128i zero = _mm_setzero_si128();\n    __m128i odd_mask = _mm_set1_epi32(1);\n    __m128i neg_mask = _mm_set1_epi32(0x80000000);\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        __m128i int_values = _mm_cvtps_epi32(values);\n        \n        __m128i odd_values = _mm_and_si128(int_values, odd_mask);\n        __m128i neg_values = _mm_and_si128(int_values, neg_mask);\n        \n        __m128 mask = _mm_castsi128_ps(_mm_cmpeq_epi32(neg_values, zero));\n        odd_values = _mm_and_si128(odd_values, _mm_castps_si128(mask));\n        \n        __m128 squared = _mm_mul_ps(_mm_cvtepi32_ps(odd_values), _mm_cvtepi32_ps(odd_values));\n        sum = _mm_add_ps(sum, squared);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total = 0;\n    for (int j = 0; j < 4; ++j) {\n        total += static_cast<uint64_t>(result[j]);\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] >= 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            total += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    __m128 sum = _mm_setzero_ps();\n    __m128i zero = _mm_setzero_si128();\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 v = _mm_loadu_ps(&lst[i]);\n        __m128i iv = _mm_cvtps_epi32(v);\n        \n        __m128i odd_mask = _mm_and_si128(iv, _mm_set1_epi32(1));\n        __m128i odd_numbers = _mm_and_si128(iv, _mm_cmpeq_epi32(odd_mask, zero));\n        \n        __m128 squared = _mm_mul_ps(_mm_cvtepi32_ps(odd_numbers), _mm_cvtepi32_ps(odd_numbers));\n        sum = _mm_add_ps(sum, squared);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total = 0;\n    for (int j = 0; j < 4; j++) {\n        total += static_cast<uint64_t>(result[j]);\n    }\n\n    for (; i < size; i++) {\n        if (lst[i] >= 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            total += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    __m128 sum = _mm_setzero_ps();\n    __m128i odd_mask = _mm_set1_epi32(1);\n    __m128i zero_mask = _mm_setzero_si128();\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        __m128i int_values = _mm_cvttps_epi32(values);\n        \n        __m128i odd_values = _mm_and_si128(int_values, odd_mask);\n        __m128i is_positive = _mm_cmpgt_epi32(int_values, zero_mask);\n        __m128i mask = _mm_and_si128(odd_values, is_positive);\n        \n        __m128 squared = _mm_mul_ps(values, values);\n        __m128 filtered = _mm_and_ps(squared, _mm_castsi128_ps(mask));\n        \n        sum = _mm_add_ps(sum, filtered);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total_sum = 0;\n    for (int j = 0; j < 4; ++j) {\n        total_sum += static_cast<uint64_t>(result[j]);\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            total_sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    __m128 sum = _mm_setzero_ps();\n    __m128i odd_mask = _mm_set1_epi32(1);\n    __m128i zero_mask = _mm_setzero_si128();\n    \n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        __m128i int_values = _mm_cvttps_epi32(values);\n        \n        __m128i odd_values = _mm_and_si128(int_values, odd_mask);\n        __m128i is_positive = _mm_cmpgt_epi32(int_values, zero_mask);\n        __m128i mask = _mm_and_si128(odd_values, is_positive);\n        \n        __m128 squared = _mm_mul_ps(values, values);\n        __m128 masked_squared = _mm_and_ps(squared, _mm_castsi128_ps(mask));\n        \n        sum = _mm_add_ps(sum, masked_squared);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total_sum = 0;\n    for (size_t j = 0; j < 4; ++j) {\n        total_sum += static_cast<uint64_t>(result[j]);\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            total_sum += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    __m128 sum = _mm_setzero_ps();\n    __m128i zero = _mm_setzero_si128();\n    \n    size_t size = lst.size();\n    size_t i;\n\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        __m128i int_values = _mm_cvtps_epi32(values);\n        \n        __m128i odd_mask = _mm_and_si128(int_values, _mm_set1_epi32(1));\n        __m128i positive_mask = _mm_cmpgt_epi32(int_values, zero);\n        __m128i mask = _mm_and_si128(odd_mask, positive_mask);\n        \n        __m128 squared = _mm_mul_ps(values, values);\n        __m128 filtered = _mm_and_ps(squared, _mm_castsi128_ps(mask));\n        \n        sum = _mm_add_ps(sum, filtered);\n    }\n\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    \n    uint64_t total = 0;\n    for (int j = 0; j < 4; ++j) {\n        total += static_cast<uint64_t>(result[j]);\n    }\n\n    for (; i < size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) % 2 != 0) {\n            total += static_cast<uint64_t>(lst[i] * lst[i]);\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n    \n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff_vec);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff_vec);\n    }\n    \n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\n#include <vector>\n#include <xmmintrin.h>\n#include <emmintrin.h>\n#include <x86intrin.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n    \n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}

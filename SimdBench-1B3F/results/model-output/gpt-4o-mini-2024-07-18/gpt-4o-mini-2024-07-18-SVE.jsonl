{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1(pg, &mask[i]);\n        svint64_t dst_vec = svsel(mask_vec, src_vec, svdup_n_s64(0)); // Use 0 or any default value\n        svst1(pg, &dst[i], dst_vec);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    for (; i <= length - SV_NUM_ELEMS(svint64_t); i += SV_NUM_ELEMS(svint64_t)) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1(pg, &mask[i]);\n        svint64_t result = svsel(mask_vec, src_vec, svdup_n_s64(0));\n        svst1(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    for (; i <= length - SV_NUM_ELEMS(svint64_t); i += SV_NUM_ELEMS(svint64_t)) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t data = svld1(pg, &src[i]);\n        svbool_t mask_pg = svld1(pg, &mask[i]);\n        svint64_t result = svsel(mask_pg, data, svdup_n_s64(0));\n        svst1(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_pg = svld1(pg, &mask[i]);\n        svint64_t result = svsel(mask_pg, src_vec, svdup_n_s64(0));\n        svst1(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    for (; i <= length - SV_NUM_ELEM; i += SV_NUM_ELEM) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_pg = svld1(pg, &mask[i]);\n        svint64_t dst_vec = svsel(mask_pg, src_vec, svdup_n_s64(0));\n        svst1(pg, &dst[i], dst_vec);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svint32_t scale_vec = svdup_n_s32(scale);\n    \n    for (; i < length; i += svcntw()) {\n        svint32_t src_vec = svld1_s32(&src[i]);\n        svint32_t tmp1 = svlsr_n_s32(svmul_s32(src_vec, scale_vec), 3);\n        svint32_t tmp2 = svlsl_n_s32(svmul_s32(src_vec, scale_vec), 3);\n        svint32_t result = svdiv_s32(svadd_s32(svmul_s32(src_vec, scale_vec), svmul_s32(tmp1, tmp2)), svdup_n_s32(7));\n        svst1_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svint32_t scale_vec = svdup_n_s32(scale);\n    \n    for (; i < length; i += svcntw()) {\n        svint32_t src_vec = svld1_s32(&src[i]);\n        svint32_t tmp1 = svlsr_n_s32(svmul_s32(src_vec, scale_vec), 3);\n        svint32_t tmp2 = svlsl_n_s32(svmul_s32(src_vec, scale_vec), 3);\n        svint32_t result = svdiv_s32(svadd_s32(svmul_s32(src_vec, scale_vec), svmul_s32(tmp1, tmp2)), svdup_n_s32(7));\n        svst1_s32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        svint32_t vec_scale = svdup_n_s32(scale);\n        \n        svint32_t tmp1 = svlsr_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        svint32_t tmp2 = svlsl_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        \n        svint32_t result = svadd_s32(svmul_s32(vec_src, vec_scale), svdiv_s32(svadd_s32(svmul_s32(tmp1, tmp2), svdup_n_s32(0)), svdup_n_s32(7)));\n        \n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b32(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length; i += svcntw()) {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        svint32_t vec_scale = svdup_n_s32(scale);\n        \n        svint32_t tmp1 = svlsr_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        svint32_t tmp2 = svlsl_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        \n        svint32_t result = svadd_s32(svmul_s32(vec_src, vec_scale), svdiv_s32(svadd_s32(svmul_s32(tmp1, tmp2), svdup_n_s32(0)), svdup_n_s32(7)));\n        \n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b32(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length; i += svcntb()) {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        svint32_t vec_scale = svdup_n_s32(scale);\n        \n        svint32_t tmp1 = svlsr_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        svint32_t tmp2 = svlsl_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        \n        svint32_t result = svadd_s32(svmul_s32(vec_src, vec_scale), svdiv_s32(svadd_s32(svmul_s32(tmp1, tmp2), svdup_n_s32(0)), svdup_n_s32(7)));\n        \n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b32(i + svcntb(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t indices = svadd_u64(svdup_u64(i), svdup_u64(stride));\n        svuint64_t offsets = svmul_u64(indices, svdup_u64(cols));\n        svuint64_t load_indices = svadd_u64(offsets, svdup_u64(0));\n        \n        svfloat64_t data = svld1(pg, (const double *)(src + svindex_u64(load_indices)));\n        svst1(pg, dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r;\n    svbool_t pg = svptrue_b64();\n    for (r = 0; r < rows; r += svcntd()) {\n        svuint64_t indices = svadd_u64(svdup_u64(r), svdup_u64(stride));\n        svuint64_t base_indices = svmul_u64(svdup_u64(cols), svdup_u64(r));\n        svuint64_t load_indices = svadd_u64(base_indices, indices);\n        \n        svfloat64_t data = svld1(pg, (const float64_t *)(src + svindex(load_indices)));\n        svst1(pg, dst + r, data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    svbool_t pg = svptrue_b64();\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t indices = svadd_u64(svdup_u64(i), svdup_u64(stride));\n        svfloat64_t data = svld1(pg, &src[svindex_u64(indices, 0, cols)]);\n        svst1(pg, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t indices = svadd_u64(svdup_u64(i), svdup_u64(stride));\n        svuint64_t base_indices = svmul_u64(svdup_u64(cols), svdup_u64(i));\n        svuint64_t load_indices = svadd_u64(base_indices, indices);\n        \n        svfloat64_t data = svld1(pg, (const double *)(src + svindex_u64(load_indices)));\n        svst1(pg, dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    svbool_t pg = svptrue_b64();\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t indices = svadd_u64(svdup_u64(i), svdup_u64(stride));\n        svuint64_t base_index = svmul_u64(svdup_u64(cols), svdup_u64(i));\n        svuint64_t load_indices = svadd_u64(base_index, indices);\n        \n        svfloat64_t data = svld1(pg, (const float64_t *)(src + svindex_u64(load_indices)));\n        svst1(pg, (float64_t *)(dst + i), data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t src_vec;\n    svuint32_t idx_vec;\n\n    for (; i <= length - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        idx_vec = svld1_u32(&indices[i]); // Load indices\n        src_vec = svld1_f32(&src[i]); // Load source values\n\n        // Gather operation\n        svfloat32_t gathered = svgather_f32(svundef_f32(), src, idx_vec);\n        svst1_f32(&dst[i], gathered); // Store gathered values to destination\n\n        // Scatter operation\n        svst1_f32(&dst[svindex_u32(idx_vec)], src_vec); // Scatter source values to destination\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    svfloat32_t src_vec;\n    svuint32_t indices_vec;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svcntw();\n        vl = svmin_u(size_t, vl, length - i);\n\n        indices_vec = svld1_u32(svptrue_b32(), &indices[i]);\n        src_vec = svld1_f32(svptrue_b32(), &src[i]);\n\n        svst1_f32(svptrue_b32(), &dst[i], svtbl(src_vec, indices_vec));\n        svst1_f32(svptrue_b32(), &dst[svtbl(indices_vec, svindex_u32(i, vl))], src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec_src;\n    svuint32_t vec_indices;\n\n    // Gather operation\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec_indices = svld1_u32(&indices[i]);\n        vec_src = svgather_f32(svundef_f32(), src, vec_indices);\n        svst1_f32(&dst[i], vec_src);\n    }\n\n    // Scatter operation\n    for (i = 0; i <= length - svcntw(); i += svcntw()) {\n        vec_indices = svld1_u32(&indices[i]);\n        vec_src = svld1_f32(&src[i]);\n        svscatter_f32(dst, vec_indices, vec_src);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    svfloat32_t src_vec;\n    svint32_t indices_vec;\n    \n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svcntw(); // Vector length\n        \n        // Gather operation\n        indices_vec = svld1_s32(&indices[i]);\n        src_vec = svgather_f32(svdup_n_s32(0), src, indices_vec);\n        svst1_f32(&dst[i], src_vec);\n        \n        // Scatter operation\n        src_vec = svld1_f32(&src[i]);\n        svscatter_f32(dst, indices_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t src_vec;\n    svuint32_t idx_vec;\n\n    for (; i <= length - SV_NUM_F32; i += SV_NUM_F32) {\n        idx_vec = svld1_u32(&indices[i]);\n        src_vec = svld1_f32(&src[i]);\n        \n        svfloat32_t gathered = svld1_gather_f32(svindex_u32(idx_vec), src);\n        svst1_f32(&dst[i], gathered);\n        \n        svst1_scatter_f32(svindex_u32(idx_vec), src_vec, dst);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntw(); // Number of 32-bit words in a vector\n    uint64_t num_vectors = (length + vector_length - 1) / vector_length;\n\n    for (uint64_t i = 0; i < num_vectors; i++) {\n        uint64_t offset = start + i * vector_length;\n        if (offset >= end) break;\n\n        svint16_t vec = svld1_s16(&arr[offset]);\n        svint16_t rev_vec = svrev(vec);\n\n        svst1_s16(&arr[offset], rev_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntw(); // Number of 16-bit elements in a vector\n    uint64_t i;\n\n    for (i = 0; i < length / vector_length; i++) {\n        svint16_t vec = svld1_s16(&arr[start + i * vector_length]);\n        svint16_t rev_vec = svrev(vec);\n        svst1_s16(&arr[start + i * vector_length], rev_vec);\n    }\n\n    // Handle any remaining elements\n    for (; i * vector_length < length; i++) {\n        arr[start + i * vector_length] = arr[end - i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntw(); // Number of 32-bit words in a vector\n    uint64_t num_vectors = (length + vector_length - 1) / vector_length;\n\n    for (uint64_t i = 0; i < num_vectors; ++i) {\n        uint64_t current_start = start + i * vector_length;\n        uint64_t current_end = current_start + vector_length - 1;\n        if (current_end > end) {\n            current_end = end;\n        }\n\n        uint64_t current_length = current_end - current_start + 1;\n        if (current_length <= 0) continue;\n\n        svint16_t vec = svld1_s16(&arr[current_start]);\n        svint16_t reversed_vec = svrev_s16(vec);\n        svst1_s16(&arr[current_start], reversed_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntw(); // Number of 32-bit words in a vector\n    uint64_t num_vectors = (length + vector_length - 1) / vector_length;\n\n    for (uint64_t i = 0; i < num_vectors; i++) {\n        uint64_t offset = start + i * vector_length;\n        if (offset >= end) break;\n\n        svint16_t vec = svld1_s16(&arr[offset]);\n        svint16_t reversed_vec = svrev(vec);\n\n        svst1_s16(&arr[offset], reversed_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntw(); // Number of 16-bit elements in a vector\n    uint64_t i;\n\n    for (i = 0; i < length / vector_length; i++) {\n        svint16_t vec = svld1_s16(&arr[start + i * vector_length]);\n        svint16_t rev_vec = svrev(vec);\n        svst1_s16(&arr[start + i * vector_length], rev_vec);\n    }\n\n    // Handle any remaining elements\n    for (; i * vector_length < length; i++) {\n        arr[start + i * vector_length] = arr[end - i * vector_length];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svuint8_t *tensor_ptr = (svuint8_t_t *)(tensor + slice_offset);\n    svuint8_t *slice_ptr = (svuint8_t_t *)slice;\n\n    size_t i = 0;\n    for (; i <= total_elements - svcntb(); i += svcntb()) {\n        svuint8_t data = svld1_u8(svindex_u8(tensor_ptr, i));\n        svst1_u8(slice_ptr + i, data);\n    }\n\n    for (; i < total_elements; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svuint8_t *slice_ptr = (svuint8_t_t *)slice;\n    const svuint8_t *tensor_ptr = (const svuint8_t_t *)(tensor + slice_offset);\n\n    size_t i = 0;\n    for (; i <= total_elements - svcntb(); i += svcntb()) {\n        svuint8_t data = svld1_u8(tensor_ptr + i);\n        svst1_u8(slice_ptr + i, data);\n    }\n\n    for (; i < total_elements; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svuint8_t *slice_ptr = (svuint8_t_t *)slice;\n    const svuint8_t *tensor_ptr = (const svuint8_t_t *)(tensor + slice_offset);\n\n    size_t i = 0;\n    for (; i <= total_elements - svcntb(); i += svcntb()) {\n        svuint8_t data = svld1_u8(svindex_u8(tensor_ptr, i));\n        svst1_u8(slice_ptr + i, data);\n    }\n\n    for (; i < total_elements; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svuint8_t *slice_ptr = (svuint8_t_t *)slice;\n    const svuint8_t *tensor_ptr = (const svuint8_t_t *)(tensor + slice_offset);\n\n    size_t i = 0;\n    for (; i <= total_elements - svcntb(); i += svcntb()) {\n        svuint8_t data = svld1_u8(tensor_ptr + i);\n        svst1_u8(slice_ptr + i, data);\n    }\n\n    for (; i < total_elements; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    svuint8_t *slice_ptr = (svuint8_t_t *)slice;\n    const svuint8_t *tensor_ptr = (const svuint8_t_t *)(tensor + slice_offset);\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t vec = svld1_u8(svindex_u8(tensor_ptr, i));\n        svst1_u8(slice_ptr + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                svint16_t row_data = svld1_s16(&src[(block_row + i) * cols + block_col]);\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    svint16_t col_data = svdup_n_s16(row_data[j]);\n                    svst1_s16(&dst[(block_col + j) * rows + (block_row + i)], col_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                svint16_t src_vec = svld1_s16(&src[(block_row + i) * cols + block_col]);\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    svint16_t dst_vec = svld1_s16(&dst[(block_col + j) * rows + block_row]);\n                    svst1_s16(&dst[(block_col + j) * rows + block_row + i], src_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                svint16_t vec = svld1_s16(&src[(block_row + i) * cols + block_col]);\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    svint16_t temp = svdup_n_s16(vec[j]);\n                    svst1_s16(&dst[(block_col + j) * rows + (block_row + i)], temp);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                svint16_t row_data = svld1_s16(&src[(block_row + i) * cols + block_col]);\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    svint16_t col_data = svdup_n_s16(svindex_s16(row_data, j));\n                    svst1_s16(&dst[(block_col + j) * rows + (block_row + i)], col_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            for (size_t i = 0; i < block_size && (block_row + i) < rows; ++i) {\n                svint16_t row_data = svld1_s16(&src[(block_row + i) * cols + block_col]);\n                for (size_t j = 0; j < block_size && (block_col + j) < cols; ++j) {\n                    svint16_t col_data = svdup_n_s16(row_data[j]);\n                    svst1_s16(&dst[(block_col + j) * rows + (block_row + i)], col_data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i;\n    svfloat32_t vsum = svdup_f32(0.0f);\n    \n    for (i = 0; i < dim; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svfloat32_t vdata = svld1_f32(&array[i * dim * dim + i * dim + i]);\n        vsum = svadd_f32(vsum, vdata);\n    }\n    \n    sum += svaddv_f32(svadd_f32(vsum, svdup_f32(0.0f)));\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i;\n    svfloat32_t vsum = svdup_f32(0.0f);\n    \n    for (i = 0; i < dim; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svfloat32_t vdata = svld1_f32(&array[i * dim * dim + i * dim + indices]);\n        vsum = svadd_f32(vsum, vdata);\n    }\n\n    float result[svcntw()];\n    svst1_f32(result, vsum);\n    \n    for (size_t j = 0; j < svcntw(); j++) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t total_elements = dim * dim * dim;\n    size_t i;\n\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    \n    for (i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svfloat32_t diagonal_elements = svld1_f32(&array[svmul_u32(indices, svdup_u32(dim * dim + 1))]);\n        sum_vec = svadd_f32(sum_vec, diagonal_elements);\n    }\n\n    float result[svcntw()];\n    svst1_f32(result, sum_vec);\n    \n    for (size_t j = 0; j < svcntw(); j++) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i;\n    svfloat32_t vsum = svdup_f32(0.0f);\n    size_t num_diagonal_elements = dim;\n\n    for (i = 0; i < num_diagonal_elements; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svfloat32_t vdata = svld1_f32(&array[i * (dim + 1)]);\n        vsum = svadd_f32(vsum, vdata);\n    }\n\n    sum += svaddv_f32(svadd_f32(vsum, svdup_f32(0.0f)));\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i;\n    svfloat32_t vsum = svdup_f32(0.0f);\n    \n    for (i = 0; i < dim; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svuint32_t idx = svadd_u32(indices, svmul_u32(svdup_u32(dim), indices));\n        svfloat32_t vdata = svld1_f32(&array[idx]);\n        vsum = svadd_f32(vsum, vdata);\n    }\n    \n    float result[svcntw()];\n    svst1_f32(result, vsum);\n    \n    for (size_t j = 0; j < svcntw(); j++) {\n        sum += result[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svfloat64_t vec_src = svld1_u64(svptrue_b64(), (const uint64_t*)&src[i]);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n        svfloat64_t vec_scale = svdup_f64(scale);\n        \n        svbool_t mask = svcmplt_f64(svwhilelt_b64(i, total_elements), vec_src, vec_threshold);\n        svfloat64_t scaled_values = svmul_f64(mask, vec_src, vec_scale);\n        svfloat64_t result = svsel(mask, scaled_values, vec_src);\n        \n        svst1_u64(svptrue_b64(), (uint64_t*)&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svfloat64_t vec_src = svld1_u64(svptrue_b64(), &src[i]);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n        svfloat64_t vec_scale = svdup_f64(scale);\n\n        svbool_t mask = svcmplt_f64(svpr_true_b64(), vec_src, vec_threshold);\n        svfloat64_t scaled_values = svmul_f64(mask, vec_src, vec_scale);\n        svfloat64_t result = svsel(mask, scaled_values, vec_src);\n\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t data = svld1_u64(svptrue_b64(), &src[i]);\n        svbool_t mask = svcmplt_f64(svdup_f64(threshold), data);\n        svfloat64_t scaled_data = svmul_f64(svdup_f64(scale), data);\n        svfloat64_t result = svsel(mask, data, scaled_data);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t data = svld1_u64(svptrue_b64(), &src[i]);\n        svbool_t mask = svcmple_f64(svdup_f64(threshold), data);\n        svfloat64_t scaled_data = svmul_f64(svdup_f64(scale), data);\n        data = svsel(mask, data, scaled_data);\n        svst1_u64(svptrue_b64(), &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec_src = svld1_u64(svptrue_b64(), &src[i]);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n        svfloat64_t vec_scale = svdup_f64(scale);\n\n        svbool_t mask = svcmplt_f64(svtrue(), vec_src, vec_threshold);\n        svfloat64_t scaled = svmul_f64(svtrue(), vec_src, vec_scale);\n        svfloat64_t result = svsel(mask, vec_src, scaled);\n\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t idx = svld1_u64(pg, &indices[i]);\n        svbool_t pg_idx = svwhilelt_b64(i, rows);\n        \n        for (size_t j = 0; j < cols; j++) {\n            svfloat64_t data = svld1_gather_index_f64(pg_idx, &src[j * rows], idx);\n            svst1(pg_idx, &dst[j * rows + i], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svptrue_b64();\n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t idx = svld1_u64(pg, &indices[i]);\n        for (j = 0; j < cols; j++) {\n            svfloat64_t data = svld1_gather_index_f64(pg, src, idx, j * rows);\n            svst1(pg, &dst[i * cols + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    svbool_t pg = svwhilelt_b64(0, rows);\n\n    for (i = 0; i < cols; i += svcntd()) {\n        svfloat64_t vec_src = svld1(pg, &src[indices[i] * cols + i]);\n        svst1(pg, &dst[i], vec_src);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    svbool_t pg = svptrue_b64();\n    \n    for (i = 0; i < rows; i += svcntd()) {\n        svuint64_t idx = svld1_u64(pg, indices + i);\n        svfloat64_t data = svld1_gather_index_f64(pg, src, idx);\n        svst1_f64(pg, dst + i * cols, data);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg;\n    for (i = 0; i < rows; i += svcntd()) {\n        pg = svwhilelt_b64(i, rows);\n        svuint64_t idx = svld1_u64(pg, &indices[i]);\n        for (j = 0; j < cols; j++) {\n            svfloat64_t data = svld1_gather_index_f64(pg, src, idx * cols + j);\n            svst1(pg, &dst[i * cols + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint64_t v_src1 = svld1(pg, &src1[i]);\n        svint64_t v_src2 = svld1(pg, &src2[i]);\n        svint64_t v_sum = svadd_s64(v_src1, v_src2);\n        svint64_t v_scalar = svdup_s64(scalar);\n        svint64_t v_result = svadd_s64(v_sum, v_scalar);\n        svint64_t v_final = svlsr_n_s64(v_result, 1);\n        svst1(pg, &dst[i], v_final);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_s64(vec1, vec2);\n        result = svadd_s64(result, svdup_s64(scalar));\n        result = svshl_n_s64(result, -1); // Divide by 2 (round-toward-zero)\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i <= length - SV_NUM_ELEM; i += SV_NUM_ELEM) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t sum = svadd_s64(vec1, vec2);\n        svint64_t result = svadd_s64(sum, svdup_s64(scalar));\n        result = svshl_n_s64(result, -1); // Divide by 2 (round-toward-zero)\n        svst1(pg, &dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint64_t v_src1 = svld1(pg, &src1[i]);\n        svint64_t v_src2 = svld1(pg, &src2[i]);\n        svint64_t v_result = svadd_s64(v_src1, v_src2);\n        v_result = svadd_s64(v_result, svdup_s64(scalar));\n        v_result = svshl_n_s64(v_result, -1); // Divide by 2 (right shift)\n        svst1(pg, &dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; svptest_any(pg); i += svcntd()) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_s64(vec1, vec2);\n        result = svadd_s64(result, svdup_s64(scalar));\n        result = svshl_n_s64(result, -1); // Divide by 2 (round-toward-zero)\n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svint32_t min_val = svdup_n_s32(INT32_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += svcntw()) {\n        svint32_t data = svld1_s32(&src[i]);\n        svint32_t mask = svindex_s32(i, svcntw());\n        svint32_t even_data = svand_s32(data, svdup_n_s32(0xFFFFFFFE));\n\n        min_val = svmin_s32(min_val, even_data);\n    }\n\n    int32_t result[svcntw()];\n    svst1_s32(result, min_val);\n\n    int32_t final_min = INT32_MAX;\n    for (size_t j = 0; j < svcntw(); j++) {\n        if (result[j] < final_min) {\n            final_min = result[j];\n        }\n    }\n\n    return final_min == INT32_MAX ? -1 : final_min;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svint32_t min_val = svdup_n_s32(INT32_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += svcntb()) {\n        svint32_t data = svld1_s32(&src[i]);\n        svint32_t even_mask = svindex_s32(i, svcntb());\n        svint32_t even_elements = svand_s32(data, even_mask);\n\n        min_val = svmin_s32(min_val, even_elements);\n    }\n\n    int32_t result = svmin_s32(min_val);\n    return result == INT32_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svint32_t min_val = svdup_n_s32(INT32_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += svcntb()) {\n        svint32_t data = svld1_s32(&src[i]);\n        svint32_t mask = svcmpeq_s32(data, svdup_n_s32(0)); // mask for even indices\n        svint32_t even_data = svand_s32(data, mask);\n\n        min_val = svmin_s32(min_val, even_data);\n    }\n\n    int32_t result = svmin_s32(min_val);\n    return result == INT32_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svint32_t min_val = svdup_n_s32(INT32_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t data = svld1(pg, &src[i]);\n\n        svbool_t even_mask = svindex_b32(pg, 0);\n        svint32_t even_data = svuzp1_s32(data, svdup_n_s32(0), even_mask);\n\n        min_val = svmin_s32(min_val, even_data);\n    }\n\n    int result = svmin_s32(min_val, min_val);\n    return result == INT32_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svint32_t min_val = svdup_n_s32(INT32_MAX);\n    size_t i;\n\n    for (i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t data = svld1(pg, &src[i]);\n\n        svint32_t even_elements = svand_s32(data, svdup_n_s32(1)); // Mask to get even indexed elements\n        min_val = svmin_s32(min_val, svreinterpret_s32(even_elements));\n    }\n\n    int32_t result = svmin_s32(min_val, svdup_n_s32(INT32_MAX));\n    return (result == INT32_MAX) ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length; i += svcntw()) {\n        svint32_t data = svld1(pg, &src[i]);\n        svint32_t arith_shift = svashr_n_s32(data, shift);\n        svuint32_t uint_data = svreinterpret_u32(data);\n        svuint32_t logical_shift = svlsr_n_u32(uint_data, shift);\n        svint32_t result = svadd_s32(arith_shift, svreinterpret_s32(logical_shift));\n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b32(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntb()) {\n        svint32_t data = svld1(pg, &src[i]);\n        \n        svint32_t arith_shift = svshrq_n_s32(data, shift);\n        svuint32_t uint_data = svreinterpret_u32(data);\n        svuint32_t logical_shift = svshrq_n_u32(uint_data, shift);\n        \n        svint32_t result = svadd_s32(arith_shift, svreinterpret_s32(logical_shift));\n        svst1(pg, &dst[i], result);\n        \n        pg = svwhilelt_b32(i + svcntb(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    for (; i < length; i += svcntw()) {\n        svint32_t data = svld1(pg, &src[i]);\n        svint32_t arith_shift = svashr_n_s32(data, shift);\n        svuint32_t data_uint = svreinterpret_u32(data);\n        svuint32_t log_shift = svlshr_n_u32(data_uint, shift);\n        svint32_t result = svadd_s32(arith_shift, svreinterpret_s32(log_shift));\n        svst1(pg, &dst[i], result);\n        pg = svwhilelt_b32(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svuint32_t shift_vec = svdup_u32(shift);\n    \n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint32_t src_vec = svld1_s32(&src[i]);\n        \n        svint32_t arith_shifted = svashr_n_s32(src_vec, shift);\n        svuint32_t uint_src_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shifted = svlsr_n_u32(uint_src_vec, shift);\n        \n        svint32_t result = svadd_s32(arith_shifted, svreinterpret_s32_u32(logical_shifted));\n        svst1_s32(&dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntb()) {\n        svint32_t data = svld1(pg, &src[i]);\n        \n        svint32_t arith_shift = svashr_n_s32(data, shift);\n        svuint32_t uint_data = svreinterpret_u32(data);\n        svint32_t logic_shift = svreinterpret_s32(svashr_n_u32(uint_data, shift));\n        \n        svint32_t result = svadd_s32(arith_shift, logic_shift);\n        svst1(pg, &dst[i], result);\n        \n        pg = svwhilelt_b32(i + svcntb(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t vec = svld1_u32(&matrix[i]);\n        svint64_t vec_sum = svreinterpret_s64_u32(vec);\n        acc = svadd_s64(acc, vec_sum);\n    }\n\n    // Horizontal addition of the accumulated vector\n    sum += svaddv_s64(acc);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t vec = svld1_u32(svptrue_b32(), &matrix[i]);\n        svint64_t vec_sum = svaddv_s64(svdup_n_s64(0), svreinterpret_s64_u32(vec));\n        acc = svadd_s64(acc, vec_sum);\n    }\n\n    sum += svaddv_s64(svdup_n_s64(0), acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t data = svld1_u32(&matrix[i]);\n        svint64_t data_s64 = svreinterpret_s64_u32(data);\n        acc = svadd_s64(acc, data_s64);\n    }\n\n    // Horizontal addition of the accumulated vector\n    sum += svaddv_s64(acc);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t vec = svld1_u32(svptrue_b32(), &matrix[i]);\n        svint32_t vec_s32 = svreinterpret_s32_u32(vec);\n        acc = svadd_s64(acc, svreinterpret_s64_s32(vec_s32));\n    }\n\n    // Horizontal addition of the accumulated vector\n    sum += svaddv_s64(svadd_s64(acc, svext_s64(acc, acc, 1)));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svuint32_t vec = svld1_u32(svptrue_b32(), &matrix[i]);\n        svint32_t vec_s32 = svreinterpret_s32_u32(vec);\n        acc = svadd_s64(acc, svreinterpret_s64_s32(vec_s32));\n    }\n\n    // Horizontal add to get the final sum\n    sum += svaddv_s64(svadd_s64(acc, svdup_n_s64(0)));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_n_u64(0);\n    size_t idx = 0;\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin_u(size_t, svcntb(), length - i);\n        svint8_t data = svld1_u8(svindex_u8(i, svdup_n_u8(0)), src + i);\n        \n        svbool_t cmp = svcmpgt_s8(max_val, data);\n        max_val = svmax_s8(max_val, data);\n        max_idx = svsel(cmp, max_idx, svdup_n_u64(i) + svindex_u64(0, svdup_n_u64(0)));\n    }\n\n    uint8_t max_value = svmax_u8(svdup_n_u8(0), max_val);\n    size_t max_index = svindex_u64(0, max_idx);\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_n_u64(0);\n    size_t idx = 0;\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t remaining = length - i;\n        svint8_t data = svld1_u8(svindex_u8(i, svcntb()), src + i);\n        \n        svbool_t cmp = svcmpeq_s8(data, max_val);\n        svbool_t gt = svgreater_s8(data, max_val);\n        \n        if (svptest_any(svnot(cmp), gt)) {\n            max_val = svmax_s8(max_val, data);\n            max_idx = svadd_u64(max_idx, svdup_n_u64(svcntb()));\n        }\n    }\n\n    uint8_t max_value = svmax_u8(max_val);\n    size_t max_index = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] == max_value) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_n_u64(0);\n    svuint64_t current_idx = svdup_n_u64(0);\n    \n    size_t i = 0;\n    for (; i <= length - svcntb(); i += svcntb()) {\n        svint8_t vec = svld1_u8(svptrue_b8(), &src[i]);\n        svbool_t cmp = svcmpgt_s8(svtrue(), vec, max_val);\n        \n        max_val = svsel(cmp, vec, max_val);\n        max_idx = svsel(cmp, svadd_u64(current_idx, svdup_n_u64(i)), max_idx);\n        \n        current_idx = svadd_u64(current_idx, svdup_n_u64(svcntb()));\n    }\n\n    int8_t final_max = svmax_s8(max_val);\n    size_t final_index = svindex_u64(max_idx, svcmpeq_s8(svtrue(), max_val, final_max));\n    \n    for (; i < length; i++) {\n        if (src[i] > final_max) {\n            final_max = src[i];\n            final_index = i;\n        }\n    }\n\n    return final_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_n_u64(0);\n    size_t idx = 0;\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t remaining = length - i;\n        svint8_t data = svld1_u8(svindex_u8(i, remaining), src + i);\n        \n        svbool_t cmp = svcmpgt_s8(data, max_val);\n        max_val = svmax_s8(max_val, data);\n        max_idx = svsel(cmp, svdup_n_u64(i), max_idx);\n    }\n\n    uint8_t max_idx_array[svcntb()];\n    svst1_u8(max_idx_array, max_idx);\n\n    size_t max_index = 0;\n    for (size_t j = 0; j < svcntb(); j++) {\n        if (max_idx_array[j] != 0) {\n            max_index = max_idx_array[j];\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_n_u64(0);\n    size_t idx = 0;\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t remaining = length - i;\n        svint8_t vec = svld1_u8(svptrue_b8(), (const uint8_t *)(src + i));\n        svbool_t pg = svwhilelt_b8(i, length);\n\n        max_val = svmax_s8(max_val, vec);\n        svuint64_t indices = svadd_u64(svdup_n_u64(i), svindex_u64(0, svcntb()));\n        max_idx = svorr_u64(max_idx, svand_u64(pg, indices));\n    }\n\n    uint8_t max_val_array[svcntb()];\n    svst1_u8(svptrue_b8(), (uint8_t *)max_val_array, max_val);\n    \n    for (size_t j = 0; j < svcntb(); j++) {\n        if (max_val_array[j] == svmax_s8(max_val, max_val_array[j])) {\n            idx = max_idx[j];\n            break;\n        }\n    }\n\n    return idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t v_src1, v_src2, v_dst;\n    \n    for (; i <= length - SVE_VECTOR_LENGTH; i += SVE_VECTOR_LENGTH) {\n        pg = svwhilelt_b16(i, length);\n        \n        v_src1 = svld1_u16(pg, &src1[i]);\n        v_src2 = svld1_u16(pg, &src2[i]);\n        \n        svuint32_t v_index = svindex_u32(i, SVE_VECTOR_LENGTH);\n        svuint32_t v_mask = svdup_u32(mask);\n        svuint32_t v_and = svand_u32(v_index, v_mask);\n        \n        pg = svcmpeq_u32(pg, v_and, svdup_u32(0));\n        v_dst = svsel(pg, v_src2, v_src1);\n        \n        svst1_u16(pg, &dst[i], v_dst);\n    }\n    \n    for (; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t mask_vec = svdup_u16(mask);\n    \n    for (; i <= length - svcntw(); i += svcntw()) {\n        svuint16_t indices = svindex_u16(i, svcntw());\n        svuint16_t and_result = svand_u16(indices, mask_vec);\n        svbool_t select_src1 = svcmpeq_u16(and_result, svdup_u16(0));\n\n        svuint16_t src1_vec = svld1_u16(svptrue_b16(), &src1[i]);\n        svuint16_t src2_vec = svld1_u16(svptrue_b16(), &src2[i]);\n        svuint16_t blended = svsel(select_src1, src2_vec, src1_vec);\n\n        svst1_u16(svptrue_b16(), &dst[i], blended);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t mask_vec = svdup_u16(mask);\n    \n    for (; i <= length - SV_NUM_ELEMS; i += SV_NUM_ELEMS) {\n        svuint16_t indices = svindex_u16(i, SV_NUM_ELEMS);\n        svuint16_t and_result = svand_u16(indices, mask_vec);\n        svbool_t select_src1 = svcmpeq_u16(and_result, svdup_u16(0));\n        \n        svuint16_t src1_vec = svld1_u16(svwhilelt_u32(i, length), &src1[i]);\n        svuint16_t src2_vec = svld1_u16(svwhilelt_u32(i, length), &src2[i]);\n        \n        svuint16_t result = svsel(select_src1, src2_vec, src1_vec);\n        svst1_u16(svwhilelt_u32(i, length), &dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t v_mask = svdup_u16(mask);\n    \n    for (; i <= length - svcntw(); i += svcntw()) {\n        svuint16_t indices = svindex_u16(i, svcntw());\n        svuint16_t blend_mask = svand_u16(indices, v_mask);\n        svuint16_t src1_vec = svld1_u16(&src1[i]);\n        svuint16_t src2_vec = svld1_u16(&src2[i]);\n        \n        svuint16_t result = svsel_u16(svcmpeq_u16(blend_mask, svdup_u16(0)), src2_vec, src1_vec);\n        svst1_u16(&dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t mask_vec = svdup_u16(mask);\n    \n    for (; i <= length - SV_NUM_ELEMS(svuint16_t); i += SV_NUM_ELEMS(svuint16_t)) {\n        svuint16_t indices = svindex_u16(i, SV_NUM_ELEMS(svuint16_t));\n        svuint16_t and_result = svand_u16(indices, mask_vec);\n        svbool_t select_src1 = svcmpeq_u16(and_result, svdup_u16(0));\n\n        svuint16_t src1_vec = svld1_u16(&src1[i]);\n        svuint16_t src2_vec = svld1_u16(&src2[i]);\n        svuint16_t result_vec = svsel(select_src1, src2_vec, src1_vec);\n\n        svst1_u16(&dst[i], result_vec);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint32_t vec_popcount;\n    \n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_popcount = svcntb_u32(vec_src);\n        svst1_u32(&dst[i], vec_popcount);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec;\n    svuint32_t pop_count;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&src[i]);\n        pop_count = svcntb_u32(vec);\n        svst1_u32(&dst[i], pop_count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint32_t vec_count;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_count = svcntb_u32(vec_src);\n        svst1_u32(&dst[i], vec_count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec;\n    svuint32_t pop_count;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&src[i]);\n        pop_count = svcntb_u32(vec);\n        svst1_u32(&dst[i], pop_count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec;\n    svuint32_t pop_count;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec = svld1_u32(&src[i]);\n        pop_count = svcntb_u32(vec);\n        svst1_u32(&dst[i], pop_count);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t vec1, vec2, result;\n    svbool_t pg;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svadd_u16(vec1, vec2);\n        result = svmin_u16(result, svdup_u16(UINT16_MAX));\n        svst1_u16(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t vec1, vec2, result;\n    svbool_t pg;\n\n    for (; i <= length - SV_NUM_ELEMS(svuint16_t); i += SV_NUM_ELEMS(svuint16_t)) {\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svadd_u16(vec1, vec2);\n        result = svmin_u16(result, svdup_u16(UINT16_MAX));\n        svst1_u16(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t vsrc1, vsrc2, vresult;\n    svbool_t pg;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vsrc1 = svld1_u16(pg, &src1[i]);\n        vsrc2 = svld1_u16(pg, &src2[i]);\n        vresult = svadd_u16(vsrc1, vsrc2);\n        vresult = svmin_u16(vresult, svdup_u16(UINT16_MAX));\n        svst1_u16(pg, &dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t vec1, vec2, result;\n    svbool_t pg;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svadd_u16(vec1, vec2);\n        result = svmin_u16(result, svdup_u16(UINT16_MAX));\n        svst1_u16(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svuint16_t vec1, vec2, result;\n    svbool_t pg;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svadd_u16(vec1, vec2);\n        result = svmin_u16(result, svdup_u16(UINT16_MAX));\n        svst1_u16(pg, &dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t temp = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (temp > UINT16_MAX) ? UINT16_MAX : (uint16_t)temp;\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                pg = svand_b(pg, svcmple_f64(a_vec, svdup_f64(100.0)), svcmple_f64(a_vec, svdup_f64(-100.0)));\n                pg = svand_b(pg, svcmple_f64(b_vec, svdup_f64(100.0)), svcmple_f64(b_vec, svdup_f64(-100.0)));\n                \n                svfloat64_t prod = svmul_f64(pg, a_vec, b_vec);\n                sum += svaddv_f64(svptrue_b64(), prod);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                pg = svand_b(pg, svcmple_f64(a_vec, svdup_f64(100.0)), svcmple_f64(a_vec, svdup_f64(-100.0)));\n                pg = svand_b(pg, svcmple_f64(b_vec, svdup_f64(100.0)), svcmple_f64(b_vec, svdup_f64(-100.0)));\n                \n                sum = svmla_f64(sum, svsel(pg, a_vec, svdup_f64(0.0)), svsel(pg, b_vec, svdup_f64(0.0)));\n            }\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                pg = svwhilelt_b64(k, n);\n                pg = svand(pg, svcmplt_f64(a_vec, svdup_f64(100.0)));\n                pg = svand(pg, svcmpgt_f64(a_vec, svdup_f64(-100.0)));\n                pg = svand(pg, svcmplt_f64(b_vec, svdup_f64(100.0)));\n                pg = svand(pg, svcmpgt_f64(b_vec, svdup_f64(-100.0)));\n\n                a_vec = svmul_f64_m(pg, a_vec, b_vec);\n                sum += svaddv_f64(svptrue_b64(), a_vec);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                pg = svwhilelt_b64(k, n);\n                pg = svand(pg, svcmple_f64(a_vec, svdup_f64(100.0)));\n                pg = svand(pg, svcmpge_f64(a_vec, svdup_f64(-100.0)));\n                pg = svand(pg, svcmple_f64(b_vec, svdup_f64(100.0)));\n                pg = svand(pg, svcmpge_f64(b_vec, svdup_f64(-100.0)));\n\n                svfloat64_t prod = svmul_f64(pg, a_vec, b_vec);\n                sum += svaddv_f64(pg, prod);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                pg = svand_b(pg, svcmple_f64(a_vec, svdup_f64(100.0)), svcmpge_f64(a_vec, svdup_f64(-100.0)));\n                pg = svand_b(pg, svcmple_f64(b_vec, svdup_f64(100.0)), svcmpge_f64(b_vec, svdup_f64(-100.0)));\n                \n                sum = svmla_f64(sum, svsel(pg, a_vec, svdup_f64(0.0)), svsel(pg, b_vec, svdup_f64(0.0)));\n            }\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, &A[i]);\n        svint64_t b_vec = svld1(pg, &B[i]);\n        svint64_t c_vec = svadd_s64(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, &A[i]);\n        svint64_t b_vec = svld1(pg, &B[i]);\n        svint64_t c_vec = svadd_s64(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, &A[i]);\n        svint64_t b_vec = svld1(pg, &B[i]);\n        svint64_t c_vec = svadd_s64(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, &A[i]);\n        svint64_t b_vec = svld1(pg, &B[i]);\n        svint64_t c_vec = svadd_s64(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint64_t a_vec = svld1_u64(&A[i]);\n        svuint64_t b_vec = svld1_u64(&B[i]);\n        svuint64_t c_vec = svadd_u64(a_vec, b_vec);\n        svst1_u64(&C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        vec1 = svld1_f32(&src1[i]);\n        vec2 = svld1_f32(&src2[i]);\n        result = svadd_f32(vec1, vec2);\n        result = svrndn_f32(result);\n        svst1_f32(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t vec1, vec2, result;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svcntw(); // Vector length\n        vec1 = svld1_f32(&src1[i]); // Load src1\n        vec2 = svld1_f32(&src2[i]); // Load src2\n        result = svadd_f32(vec1, vec2); // Element-wise addition\n        result = svrndn_f32(result); // Round to nearest integer\n        svst1_f32(&dst[i], result); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n        \n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        svbool_t condition = svcmple_f32(pg, v_diff, svdup_f32(50.0f));\n        \n        pg = svand_b(pg, condition, svwhilelt_b32(i, length));\n        \n        v_result = svmul_f32(v_src1, v_src2);\n        v_result = svceil_f32(v_result);\n        \n        svst1(pg, &dst[i], svsel(pg, v_result, svdup_f32(-1.0f)));\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n\n        v_src1 = svld1_f32(pg, &src1[i]);\n        v_src2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        pg = svlt_f32(v_diff, svdup_f32(50.0f));\n\n        svfloat32_t v_mul = svmul_f32(v_src1, v_src2);\n        v_result = svifthen_f32(pg, v_mul, svdup_f32(-1.0f));\n\n        v_result = svceil_f32(v_result);\n\n        svst1_f32(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        svbool_t condition = svcmple_f32(pg, v_diff, svdup_f32(50.0f));\n\n        v_result = svmul_f32(v_src1, v_src2);\n        v_result = svceil_f32(v_result);\n\n        svfloat32_t v_neg_one = svdup_f32(-1.0f);\n        v_result = svsel(condition, v_result, v_neg_one);\n\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n\n        v_src1 = svld1_f32(pg, &src1[i]);\n        v_src2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        pg = svlt_f32(v_diff, svdup_f32(50.0f));\n\n        svfloat32_t v_mul = svmul_f32(v_src1, v_src2);\n        v_result = svdup_f32(-1.0f); // Default to -1\n        v_result = svsel(pg, svceil_f32(v_mul), v_result); // Apply condition\n\n        svst1_f32(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    svfloat32_t v_src1, v_src2, v_result;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n\n        svfloat32_t v_diff = svabs_f32(svsub_f32(v_src1, v_src2));\n        svbool_t cond = svlt_f32(v_diff, svdup_f32(50.0f));\n\n        v_result = svmul_f32(v_src1, v_src2);\n        v_result = svceil_f32(v_result);\n\n        // Set results to -1 where conditions are not met\n        svfloat32_t v_neg1 = svdup_f32(-1.0f);\n        v_result = svsel(cond, v_result, v_neg1);\n\n        // Store results in dst, only for even indices\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_f64(svindex_f64(mat, i));\n        svfloat64_t result_vec = svmul_f64(mat_vec, scalar_vec);\n        svst1_f64(svindex_f64(dst, i), result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_f64(svindex_u64(i, 0), &mat[i]);\n        svfloat64_t result_vec = svmul_f64(mat_vec, scalar_vec);\n        svst1_f64(svindex_u64(i, 0), &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_u64(svindex_u64(i, svcntd()), (const double*)&mat[i]);\n        svfloat64_t result_vec = svmul_f64(scalar_vec, mat_vec);\n        svst1_u64(svindex_u64(i, svcntd()), (double*)&dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_f64(svindex_u64(i, svcntd()), mat);\n        svfloat64_t result_vec = svmul_f64(mat_vec, scalar_vec);\n        svst1_f64(svindex_u64(i, svcntd()), dst, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    \n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_f64(NULL, &mat[i]);\n        svfloat64_t result_vec = svmul_f64(mat_vec, scalar_vec);\n        svst1_f64(NULL, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        float* row = mat + i * n;\n\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            sum_vec = svmla_f32(sum_vec, vec, vec);\n        }\n\n        for (; j < n; j++) {\n            sum_squares += row[j] * row[j];\n        }\n\n        sum_vec = svaddv_f32(sum_vec);\n        sum_squares += svget_f32(sum_vec, 0);\n\n        float norm = sqrtf(sum_squares);\n        if (norm > 0) {\n            j = 0;\n            for (; j <= n - svcntw(); j += svcntw()) {\n                svfloat32_t vec = svld1_f32(&row[j]);\n                svfloat32_t normalized_vec = svdiv_f32(vec, svdup_f32(norm));\n                svst1_f32(&row[j], normalized_vec);\n            }\n\n            for (; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_of_squares = 0.0f;\n        float* row = mat + i * n;\n        \n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            sum_vec = svmla_f32(sum_vec, vec, vec);\n        }\n\n        // Horizontal sum of the vector\n        sum_of_squares += svaddv_f32(sum_vec);\n\n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum_of_squares += row[j] * row[j];\n        }\n\n        float norm = sqrtf(sum_of_squares);\n        if (norm > 0.0f) {\n            for (j = 0; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_of_squares = 0.0f;\n        float* row = mat + i * n;\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            sum_vec = svmla_f32(sum_vec, vec, vec);\n        }\n\n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum_of_squares += row[j] * row[j];\n        }\n\n        // Sum the vectorized results\n        float sum_array[svcntw()];\n        svst1_f32(sum_array, sum_vec);\n        for (size_t k = 0; k < svcntw(); k++) {\n            sum_of_squares += sum_array[k];\n        }\n\n        float norm = sqrtf(sum_of_squares);\n        if (norm > 0) {\n            for (size_t k = 0; k < n; k++) {\n                row[k] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        float* row = mat + i * n;\n\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            sum_vec = svmla_f32(sum_vec, vec, vec);\n        }\n\n        for (; j < n; j++) {\n            sum_squares += row[j] * row[j];\n        }\n\n        sum_squares += svaddv_f32(sum_vec);\n        float norm = sqrtf(sum_squares);\n\n        if (norm > 0.0f) {\n            j = 0;\n            for (; j <= n - svcntw(); j += svcntw()) {\n                svfloat32_t vec = svld1_f32(&row[j]);\n                svfloat32_t normalized_vec = svdiv_f32(vec, svdup_f32(norm));\n                svst1_f32(&row[j], normalized_vec);\n            }\n\n            for (; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_squares = svdup_f32(0.0f);\n        \n        for (size_t j = 0; j < n; j += SVECTOR_LENGTH) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            sum_squares = svmla_f32(sum_squares, vec, vec);\n        }\n\n        float norm = sqrt(svaddv_f32(sum_squares));\n        svfloat32_t norm_vec = svdup_f32(norm);\n\n        for (size_t j = 0; j < n; j += SVECTOR_LENGTH) {\n            svfloat32_t vec = svld1_f32(&row[j]);\n            svfloat32_t normalized_vec = svdiv_f32(vec, norm_vec);\n            svst1_f32(&row[j], normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t a = svld1_f64(&mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(&mat2[k * p + j]);\n                sum = svmla_f64(sum, a, b);\n            }\n            double result = svaddv_f64(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t vec1 = svld1_f64(&mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(&mat2[k * p + j]);\n                sum = svmla_f64(sum, vec1, vec2);\n            }\n            double result = svaddv_f64(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t vec1 = svld1_f64(&mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(&mat2[k * p + j]);\n                sum = svmla_f64(sum, vec1, vec2);\n            }\n            double result[svcntd()];\n            svst1_f64(result, sum);\n            double total = 0.0;\n            for (size_t l = 0; l < svcntd(); l++) {\n                total += result[l];\n            }\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t a = svld1_f64(&mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(&mat2[k * p + j]);\n                sum = svmla_f64(sum, a, b);\n            }\n            double result = svaddv_f64(sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1(pg, &mat2[k * p + j]);\n                sum = svmla_f64(sum, a, b);\n            }\n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i += svcntw()) {\n        for (j = 0; j < cols; j += svcntw()) {\n            svfloat32_t vec = svld1_f32(&src[i * cols + j]);\n            vec = svround_f32(vec);\n            vec = svmul_f32(vec, svdup_f32(4.0f));\n            vec = svfloor_f32(vec);\n            vec = svdiv_f32(vec, svdup_f32(4.0f));\n            svst1_f32(&dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += SVE_NUM_F32) {\n        for (size_t j = 0; j < cols; j += SVE_NUM_F32) {\n            svfloat32_t vec = svld1_f32(&src[i * cols + j]);\n            vec = svadd_f32(vec, svdup_f32(0.125f)); // Add 0.125 for rounding to nearest quarter\n            vec = svtrunc_f32(vec); // Truncate to integer\n            vec = svmul_f32(vec, svdup_f32(0.25f)); // Scale back down to quarter\n            svst1_f32(&dst[j * rows + i], vec); // Store transposed value\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t r, c;\n    for (r = 0; r < rows; r += svcntw()) {\n        for (c = 0; c < cols; c += svcntw()) {\n            svfloat32_t vec[svcntw()];\n            size_t i;\n            for (i = 0; i < svcntw() && (r + i < rows) && (c + i < cols); ++i) {\n                vec[i] = svld1_f32(&src[(r + i) * cols + c]);\n            }\n            svfloat32_t rounded = svadd_f32(svdup_f32(0.125f), svmul_f32(vec, svdup_f32(4.0f)));\n            rounded = svfloor_f32(rounded);\n            rounded = svmul_f32(rounded, svdup_f32(0.25f));\n            for (i = 0; i < svcntw() && (r + i < rows) && (c + i < cols); ++i) {\n                svst1_f32(&dst[c * rows + r + i], rounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i += svcntw()) {\n        for (j = 0; j < cols; j++) {\n            svfloat32_t vec = svld1_f32(&src[i * cols + j]);\n            vec = svadd_f32(vec, svdup_f32(0.125f)); // Add 0.125 for rounding to nearest quarter\n            vec = svmul_f32(vec, svdup_f32(4.0f)); // Scale to whole numbers\n            vec = svround_f32(vec); // Round to nearest integer\n            vec = svdiv_f32(vec, svdup_f32(4.0f)); // Scale back to quarters\n            svst1_f32(&dst[j * rows + i], vec); // Store transposed value\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    for (i = 0; i < rows; i += svcntw()) {\n        for (j = 0; j < cols; j++) {\n            svfloat32_t vec = svld1_f32(&src[i * cols + j]);\n            vec = svadd_f32(vec, svdup_f32(0.125f)); // Add 0.125 for rounding\n            vec = svtrunc_f32(vec); // Truncate to integer\n            vec = svmul_f32(vec, svdup_f32(0.25f)); // Scale back to quarter\n            svst1_f32(&dst[j * rows + i], vec); // Store transposed result\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t vec1 = svld1_f32(&tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(&tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svtruncate_f32(result); // Round towards zero\n        svst1_f32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t v_tensor1 = svld1_f32(svptrue_b32(), &tensor1[i]);\n        svfloat32_t v_tensor2 = svld1_f32(svptrue_b32(), &tensor2[i]);\n        svfloat32_t v_result = svsub_f32(v_tensor1, v_tensor2);\n        svfloat32_t v_rounded = svtrunc_f32(v_result);\n        svst1_f32(svptrue_b32(), &dst[i], v_rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t v1 = svld1_f32(svptrue_b32(), &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(svptrue_b32(), &tensor2[i]);\n        svfloat32_t result = svsub_f32(v1, v2);\n        svfloat32_t rounded_result = svtrunc_f32(result);\n        svst1_f32(svptrue_b32(), &dst[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntf32()) {\n        svfloat32_t vec1 = svld1_f32(svptrue_b32(), &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(svptrue_b32(), &tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svtrunc_f32(result);\n        svst1_f32(svptrue_b32(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_NUM_F32) {\n        svfloat32_t vec1 = svld1_f32(svwhilelt_b32(i, total_elements), &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(svwhilelt_b32(i, total_elements), &tensor2[i]);\n        svfloat32_t result = svsub_f32(vec1, vec2);\n        result = svuzp_f32(result, result); // Round towards zero\n        svst1_f32(svwhilelt_b32(i, total_elements), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64_m(svptrue_b64(), vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_u64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(svptrue_b64(), &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec1 = svld1(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_m(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntd()) {\n        svfloat64_t vec1 = svld1_u64(&mat1[i]);\n        svfloat64_t vec2 = svld1_u64(&mat2[i]);\n        svfloat64_t result = svmul_f64(vec1, vec2);\n        svst1_u64(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t v_vec = svld1_f32(&vec[0]);\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t v_mat = svld1_f32(&mat[i * n + j]);\n            svfloat32_t v_vec_part = svld1_f32(&vec[j]);\n            sum = svmla_f32(sum, v_mat, v_vec_part);\n        }\n        dst[i] = svaddv_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t v_vec = svld1_f32(vec);\n    \n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t v_mat = svld1_f32(&mat[i * n + j]);\n            svfloat32_t v_vec_part = svld1_f32(&vec[j]);\n            sum = svmla_f32(sum, v_mat, v_vec_part);\n        }\n        dst[i] = svaddv_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t v_mat = svld1_f32(&mat[i * n + j]);\n            svfloat32_t v_vec = svld1_f32(&vec[j]);\n            sum = svmla_f32(sum, v_mat, v_vec);\n        }\n        dst[i] = svaddv_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t v_vec = svld1_f32(vec);\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t m_vec = svld1_f32(&mat[i * n + j]);\n            sum = svmla_f32(sum, m_vec, v_vec);\n        }\n        dst[i] = svaddv_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t v_mat = svld1_f32(&mat[i * n + j]);\n            svfloat32_t v_vec = svld1_f32(&vec[j]);\n            sum = svmla_f32(sum, v_mat, v_vec);\n        }\n        dst[i] = svaddv_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += svcntd()) {\n            svfloat64_t data_vec = svld1_f64(svptrue_b64(), &mat[i * n + j]);\n            sum_vec = svadd_f64(sum_vec, data_vec);\n        }\n    }\n\n    sum += svaddv_f64(svadd_f64(sum_vec, svdup_f64(0.0)));\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += svcntd()) {\n            svfloat64_t vec_data = svld1_f64(svptrue_b64(), &mat[i * n + j]);\n            vec_sum = svadd_f64(vec_sum, vec_data);\n        }\n    }\n    \n    double result[svcntd()];\n    svst1_f64(svptrue_b64(), result, vec_sum);\n    \n    for (size_t k = 0; k < svcntd(); k++) {\n        sum += result[k];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += svcntd()) {\n            svfloat64_t data_vec = svld1_f64(&mat[i * n + j]);\n            sum_vec = svadd_f64(sum_vec, data_vec);\n        }\n    }\n\n    sum += svaddv_f64(svadd_f64(sum_vec, svdup_f64(0.0)));\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += svcntd()) {\n            svfloat64_t data_vec = svld1_f64(svptrue_b64(), &mat[i * n + j]);\n            sum_vec = svadd_f64(sum_vec, data_vec);\n        }\n    }\n    \n    sum += svaddv_f64(svadd_f64(sum_vec, svdup_f64(0.0)));\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += svcntd()) {\n            svfloat64_t vec_data = svld1_f64(&mat[i * n + j]);\n            vec_sum = svadd_f64(vec_sum, vec_data);\n        }\n    }\n    \n    sum += svaddv_f64(svadd_f64(vec_sum, svdup_f64(0.0)));\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1(pg, row);\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            svint32_t curr = svld1(pg, row + c);\n            svbool_t cmp;\n\n            if (ascending) {\n                cmp = svcmple(pg, prev, curr);\n            } else {\n                cmp = svcmpge(pg, prev, curr);\n            }\n\n            if (!svptest_any(pg, cmp)) {\n                result = false;\n                break;\n            }\n            prev = curr;\n        }\n        if (!result) break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1(pg, row);\n        svint32_t curr;\n\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            curr = svld1(pg, row + c);\n\n            if (ascending) {\n                svbool_t cmp = svcmplt(pg, prev, curr);\n                if (!svptest_any(pg, cmp)) {\n                    result = false;\n                    break;\n                }\n            } else {\n                svbool_t cmp = svcmpgt(pg, prev, curr);\n                if (!svptest_any(pg, cmp)) {\n                    result = false;\n                    break;\n                }\n            }\n\n            prev = curr;\n        }\n\n        if (!result) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1(pg, row);\n        svint32_t curr;\n\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            pg = svwhilelt_b32(c, cols);\n            curr = svld1(pg, row + c);\n\n            if (ascending) {\n                svbool_t cmp = svcmplt(pg, prev, curr);\n                if (svptest_any(pg, svcmpeq(pg, cmp, svptrue_b32()))) {\n                    result = false;\n                    break;\n                }\n            } else {\n                svbool_t cmp = svcmpgt(pg, prev, curr);\n                if (svptest_any(pg, svcmpeq(pg, cmp, svptrue_b32()))) {\n                    result = false;\n                    break;\n                }\n            }\n\n            prev = curr;\n        }\n\n        if (!result) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1(pg, row);\n        svint32_t curr;\n\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            curr = svld1(pg, row + c);\n            if (ascending) {\n                pg = svwhilelt_b32(c, cols);\n                svbool_t cmp_pg = svcmpeq(pg, svsub_s32(curr, prev), svdup_s32(0));\n                if (svptest_any(pg, cmp_pg) == 0) {\n                    result = false;\n                    break;\n                }\n            } else {\n                pg = svwhilelt_b32(c, cols);\n                svbool_t cmp_pg = svcmpeq(pg, svsub_s32(prev, curr), svdup_s32(0));\n                if (svptest_any(pg, cmp_pg) == 0) {\n                    result = false;\n                    break;\n                }\n            }\n            prev = curr;\n        }\n\n        if (!result) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1(pg, row);\n        svint32_t curr;\n\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            curr = svld1(pg, row + c);\n            if (ascending) {\n                pg = svwhilelt_b32(c, cols);\n                svbool_t cmp = svcmpeq(pg, prev, curr);\n                if (svptest_any(pg, svcmplt(pg, prev, curr)) == 0) {\n                    result = false;\n                    break;\n                }\n            } else {\n                pg = svwhilelt_b32(c, cols);\n                svbool_t cmp = svcmpeq(pg, prev, curr);\n                if (svptest_any(pg, svcmpgt(pg, prev, curr)) == 0) {\n                    result = false;\n                    break;\n                }\n            }\n            prev = curr;\n        }\n\n        if (!result) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint16_t vec_src = svld1(pg, &src[i]);\n        svint16_t vec_base = svdup_n_s16(base);\n        \n        svint16_t vec_multiple = svdiv_s16(vec_src, vec_base);\n        vec_multiple = svmul_s16(vec_multiple, vec_base);\n        \n        svint16_t vec_result = svmin_s16(vec_multiple, vec_src);\n        svst1(pg, &dst[i], vec_result);\n        \n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svuint16_t vbase = svdup_u16(base);\n    svuint16_t vbase_minus_one = svsub_u16(vbase, svdup_u16(1));\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svuint16_t vsrc = svld1_u16(&src[i]);\n        svuint16_t vnearest = svand_u16(vsrc, vbase_minus_one);\n        vnearest = svsub_u16(vsrc, vnearest);\n        vnearest = svmin_u16(vnearest, svsub_u16(vsrc, svdup_u16(1)));\n        svuint16_t vresult = svmul_u16(vnearest, vbase);\n        svst1_u16(&dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svuint16_t base_vec = svdup_u16(base);\n    \n    for (; i <= length - svcntw(); i += svcntw()) {\n        svuint16_t src_vec = svld1_u16(&src[i]);\n        svuint16_t nearest = svdiv_u16(src_vec, base_vec);\n        nearest = svmul_u16(nearest, base_vec);\n        nearest = svmin_u16(nearest, src_vec);\n        svst1_u16(&dst[i], nearest);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n        if (dst[i] > src[i]) {\n            dst[i] -= base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint16_t vec_src = svld1_s16(pg, &src[i]);\n        svint16_t vec_base = svdup_n_s16(base);\n        svint16_t vec_multiple = svdiv_s16(vec_src, vec_base);\n        vec_multiple = svmul_s16(vec_multiple, vec_base);\n        vec_multiple = svmin_s16(vec_multiple, vec_src);\n        svst1_s16(pg, &dst[i], vec_multiple);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint16_t src_vec = svld1_s16(pg, &src[i]);\n        svint16_t base_vec = svdup_n_s16(base);\n        \n        svint16_t nearest_multiple = svdiv_s16(src_vec, base_vec);\n        nearest_multiple = svmul_s16(nearest_multiple, base_vec);\n        \n        svint16_t mask = svlt_s16(src_vec, nearest_multiple);\n        nearest_multiple = svsel(mask, svsub_s16(nearest_multiple, base_vec), nearest_multiple);\n        \n        svst1_s16(pg, &dst[i], nearest_multiple);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_vec = svld1(pg, row);\n        svfloat64_t vec_vec = svld1(pg, vector);\n        svbool_t match = svcmpeq(pg, row_vec, vec_vec);\n        if (svptest_any(pg, match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_vec = svld1(pg, row);\n        svfloat64_t vec_vec = svld1(pg, vector);\n        svfloat64_t cmp = svcmpeq_f64(row_vec, vec_vec);\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_vec = svld1(pg, row);\n        svfloat64_t vec_vec = svld1(pg, vector);\n        svfloat64_t cmp = svcmpeq_f64(row_vec, vec_vec);\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svptrue_b64();\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t row_vec = svld1(pg, row + j);\n            svfloat64_t vec_vec = svld1(pg, vector);\n            pg = svwhilelt_b64(j, cols);\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec);\n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg;\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        pg = svptrue_b64();\n        for (size_t j = 0; j < cols; j += SV_NUM_ELEMS) {\n            svfloat64_t row_vec = svld1(pg, row + j);\n            svfloat64_t vec_vec = svld1(pg, vector);\n            pg = svwhilelt_b64(j, cols);\n            svbool_t match = svcmpeq(pg, row_vec, vec_vec);\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svuint8_t* a_ptr = (svuint8_t*)A;\n    svuint8_t* b_ptr = (svuint8_t*)B;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&a_ptr[i]);\n        svuint8_t b_vec = svld1_u8(&b_ptr[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u8(svreinterpret_u8(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svuint8_t* a_vec = (svuint8_t_t*) A;\n    svuint8_t* b_vec = (svuint8_t_t*) B;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a = svld1_u8(&a_vec[i]);\n        svuint8_t b = svld1_u8(&b_vec[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a, b);\n        count += svaddv_u8(svreinterpret_u8(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svuint8_t* a_ptr = (svuint8_t_t*) A;\n    svuint8_t* b_ptr = (svuint8_t_t*) B;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(svptrue_b8(), a_ptr + i);\n        svuint8_t b_vec = svld1_u8(svptrue_b8(), b_ptr + i);\n        \n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u8(svreinterpret_u8(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svuint8_t* a_ptr = (svuint8_t_t*)A;\n    svuint8_t* b_ptr = (svuint8_t_t*)B;\n\n    size_t vector_length = svcntb(); // Number of bytes in a vector\n    size_t i;\n\n    for (i = 0; i < total_elements; i += vector_length) {\n        svuint8_t a_vec = svld1_u8(&a_ptr[i]);\n        svuint8_t b_vec = svld1_u8(&b_ptr[i]);\n        svuint8_t eq_mask = svcmpeq_u8(a_vec, b_vec);\n        count += svaddv_u8(svreinterpret_u8(eq_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svuint8_t vec_a;\n    svuint8_t vec_b;\n    svuint8_t equal_mask;\n    svuint64_t equal_count;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        size_t remaining = total_elements - i;\n        size_t load_count = remaining < svcntb() ? remaining : svcntb();\n\n        vec_a = svld1_u8(&A[i]);\n        vec_b = svld1_u8(&B[i]);\n        equal_mask = svcmpeq_u8(vec_a, vec_b);\n        equal_count = svcntb(equal_mask);\n\n        count += svaddv_u64(equal_count);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svint64_t va = svdup_n_s64(a);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += SV_NUM_ELEM) {\n        vl = svmin_u(size_t(length - i), SV_NUM_ELEM);\n        svint64_t vx = svld1(svindex_u64(i), x);\n        svint64_t v_abs_y = svabs_s64(vx);\n        svint64_t v_result = svsub_s64(v_abs_y, svmul_s64(va, vx));\n        svst1(svindex_u64(i), y, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svint64_t va = svdup_n_s64(a);\n    size_t i = 0;\n\n    for (; i < length; i += svcntd()) {\n        svint64_t vx = svld1_s64(&x[i]);\n        svint64_t vy = svabs_s64(vx);\n        svint64_t result = svmlal_s64(va, vx, vy);\n        svst1_s64(&y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svint64_t va = svdup_n_s64(a);\n    size_t i = 0;\n\n    for (; i < length; i += svcntd()) {\n        svint64_t vx = svld1_s64(&x[i]);\n        svint64_t vy = svabs_s64(vx);\n        svint64_t result = svsub_s64(svmul_s64(va, vx), vy);\n        svst1_s64(&y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svint64_t va = svdup_n_s64(a);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        vl = svmin_u(size_t(length - i), svcntd());\n        svint64_t vx = svld1(svptrue_b64(), &x[i]);\n        svint64_t v_abs_y = svabs_s64(svmul_s64(va, vx));\n        svst1(svptrue_b64(), &y[i], v_abs_y);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svint64_t va = svdup_n_s64(a);\n    size_t i = 0;\n\n    for (; i < length; i += svcntd()) {\n        svint64_t vx = svld1_s64(&x[i]);\n        svint64_t vy = svabs_s64(vx);\n        svint64_t result = svsub_s64(svmul_s64(va, vx), vy);\n        svst1_s64(&y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_val = svmin_s16(min_val, data);\n        max_val = svmax_s16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        min_val = svmin_s16(min_val, svdup_n_s16(value));\n        max_val = svmax_s16(max_val, svdup_n_s16(value));\n    }\n\n    MinMaxPair result;\n    result.min_num = svmin_s16(min_val, min_val)[0];\n    result.max_num = svmax_s16(max_val, max_val)[0];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    \n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t data = svld1_s16(&vec[i]);\n        max_val = svmax_s16(max_val, data);\n        min_val = svmin_s16(min_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        max_val = svmax_s16(max_val, svdup_n_s16(value));\n        min_val = svmin_s16(min_val, svdup_n_s16(value));\n    }\n\n    MinMaxPair result;\n    result.max_num = svmax_s16(max_val, max_val).val[0];\n    result.min_num = svmin_s16(min_val, min_val).val[0];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(SHRT_MAX);\n    svint16_t max_vec = svdup_n_s16(SHRT_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_vec = svmin_s16(min_vec, data);\n        max_vec = svmax_s16(max_vec, data);\n    }\n\n    int16_t min_result = SHRT_MAX;\n    int16_t max_result = SHRT_MIN;\n\n    for (; i < length; i++) {\n        min_result = (vec[i] < min_result) ? vec[i] : min_result;\n        max_result = (vec[i] > max_result) ? vec[i] : max_result;\n    }\n\n    MinMaxPair result;\n    result.min_num = svmin_s16(min_vec, svdup_n_s16(min_result));\n    result.max_num = svmax_s16(max_vec, svdup_n_s16(max_result));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - SV_NUM_ELEMS; i += SV_NUM_ELEMS) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_val = svmin_s16(min_val, data);\n        max_val = svmax_s16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        int16_t value = vec[i];\n        min_val = svmin_s16(min_val, svdup_n_s16(value));\n        max_val = svmax_s16(max_val, svdup_n_s16(value));\n    }\n\n    MinMaxPair result;\n    result.min_num = svmin_s16(min_val, min_val)[0];\n    result.max_num = svmax_s16(max_val, max_val)[0];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    for (; i <= length - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svint16_t data = svld1_s16(&vec[i]);\n        min_val = svmin_s16(min_val, data);\n        max_val = svmax_s16(max_val, data);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        min_val = svmin_s16(min_val, svdup_n_s16(vec[i]));\n        max_val = svmax_s16(max_val, svdup_n_s16(vec[i]));\n    }\n\n    MinMaxPair result;\n    result.min_num = svmin_s16(min_val, min_val);\n    result.max_num = svmax_s16(max_val, max_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        svint32_t prev = svld1_s32(&row[0]);\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            svint32_t curr = svld1_s32(&row[c]);\n            svbool_t cmp = svcmplt_s32(prev, curr);\n            if (!svptest_any(svcmpne_s32(cmp, svdup_s32(1), svdup_s32(0)))) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t c = 0;\n\n        // Process in chunks of SVE vector length\n        for (; c <= cols - SVE_LENGTH; c += SVE_LENGTH) {\n            svint32_t vec_current = svld1_s32(&row[c]);\n            svint32_t vec_next = svld1_s32(&row[c + 1]);\n\n            // Check if current elements are less than next elements\n            svbool_t cmp = svcmplt_s32(vec_current, vec_next);\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n        }\n\n        // Handle any remaining elements\n        for (; c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        size_t c = 0;\n\n        // Process in chunks of SVE vector length\n        for (; c <= cols - SVE_ACLE_VL; c += SVE_ACLE_VL) {\n            svint32_t vec1 = svld1_s32(&row[c]);\n            svint32_t vec2 = svld1_s32(&row[c + 1]);\n\n            // Check if vec1 < vec2\n            svbool_t cmp = svcmplt_s32(vec1, vec2);\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (; c < cols - 1; ++c) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svptrue_b32();\n        \n        for (size_t c = 0; c < cols - 1; c += svcntw()) {\n            svint32_t v1 = svld1(pg, &row[c]);\n            svint32_t v2 = svld1(pg, &row[c + 1]);\n            svbool_t cmp = svcmpeq(pg, v1, v2);\n            if (svptest_any(pg, cmp)) return false;\n\n            svbool_t inc_pg = svcmpgt(pg, v2, v1);\n            if (!svptest_any(pg, inc_pg)) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        size_t c = 0;\n\n        for (; c <= cols - SVE_LENGTH; c += SVE_LENGTH) {\n            svint32_t vec1 = svld1_s32(&row[c]);\n            svint32_t vec2 = svld1_s32(&row[c + 1]);\n            svbool_t cmp = svcmplt_s32(vec1, vec2);\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n        }\n\n        for (; c < cols - 1; c++) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            svbool_t all_equal = svptrue_b32();\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t first_row = svld1_s32(&first_block[i * cols]);\n                svint32_t current_row = svld1_s32(&current_block[i * cols]);\n                all_equal = svand_b32(all_equal, svcmpeq_s32(first_row, current_row));\n            }\n\n            if (!svptest_any(all_equal)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            svbool_t pg = svptrue_b32();\n\n            for (size_t i = 0; i < block_size; i += svcntw()) {\n                svint32_t first_block_vec = svld1(pg, first_block + i * cols);\n                svint32_t current_block_vec = svld1(pg, current_block + i * cols);\n                pg = svwhilelt_b32(i, block_size);\n\n                if (svptest_any(pg, svcmpeq_s32(first_block_vec, current_block_vec))) {\n                    continue;\n                } else {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            if (current_block == first_block) continue;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svbool_t pg = svwhilelt_b32(i, block_size);\n                for (size_t j = 0; j < block_size; j += svcntw()) {\n                    svint32_t first_block_vec = svld1(pg, first_block + i * cols + j);\n                    svint32_t current_block_vec = svld1(pg, current_block + i * cols + j);\n                    svbool_t cmp = svcmpeq(pg, first_block_vec, current_block_vec);\n                    if (!svptest_any(pg, cmp)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            for (size_t i = 0; i < block_size; i += svcntw()) {\n                svuint32_t first_block_vec = svld1_u32(&first_block[i * cols]);\n                svuint32_t current_block_vec = svld1_u32(&current_block[i * cols]);\n                svuint32_t cmp = svcmpeq_u32(first_block_vec, current_block_vec);\n                if (svptest_any(svcmpneq_u32(cmp, svdup_u32(0)))) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_size_squared = block_size * block_size;\n\n    const int* first_block = matrix;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            if (current_block == first_block) continue;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t first_block_vec = svld1_s32(&first_block[i * cols]);\n                svint32_t current_block_vec = svld1_s32(&current_block[i * cols]);\n                svbool_t cmp = svcmpeq_s32(first_block_vec, current_block_vec);\n                \n                if (svptest_any(svptrue_b32(), cmp) == 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t first_block = svld1(pg, vec);\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svfloat64_t diff = svfabs(svsub_f64(current_block, first_block));\n        svbool_t cmp = svcmplt_f64(diff, svdup_f64(tolerance));\n        \n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svfloat64_t diff = svfabs_f64(svsub_f64(current_block, first_block));\n        svbool_t cmp = svcmple_f64(diff, svdup_f64(tolerance));\n\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svfloat64_t diff = svfabs_f64(svsub_f64(first_block, current_block));\n        svbool_t cmp = svlt_f64(diff, svdup_f64(tolerance));\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length < block_size || block_size == 0 || (length % block_size) != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < num_blocks; i++) {\n        const double* block_start = vec + i * block_size;\n        svfloat64_t first_block = svld1(pg, block_start);\n        \n        bool all_equal = true;\n        \n        for (size_t j = 1; j < block_size; j += svcntd()) {\n            svfloat64_t current_block = svld1(pg, block_start + j);\n            svfloat64_t diff = svsub_f64(first_block, current_block);\n            svfloat64_t abs_diff = svabs_f64(diff);\n            svbool_t cmp = svcmplt_f64(abs_diff, svdup_f64(tolerance));\n            all_equal &= svptest_any(pg, cmp);\n            \n            if (!all_equal) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length < block_size || block_size == 0 || length % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svfloat64_t diff = svfabs_f64(svsub_f64(current_block, first_block));\n        svbool_t cmp = svcmple_f64(diff, svdup_f64(tolerance));\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svmla_f64(sum, vec, vec);\n        }\n        svfloat64_t norm = svsqrt_f64(sum);\n        svbool_t cmp = svcmplt_f64(norm, svld1(pg, &thresholds[i]));\n        result[i] = svptest_any(pg, cmp);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t r = 0; r < rows; r++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t vec = svld1_f64(&matrix[r * cols + c]);\n            sum = svmla_f64(sum, vec, vec);\n        }\n        double norm = sqrt(svaddv_f64(sum));\n        result[r] = norm > thresholds[r];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svmla_f64(sum, vec, vec);\n        }\n        svfloat64_t norm = svsqrt_f64(sum);\n        svbool_t cmp = svcmplt_f64(norm, svld1(pg, &thresholds[i]));\n        result[i] = svptest_any(pg, cmp);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1_f64(&matrix[i * cols + j]);\n            sum = svmla_f64(sum, vec, vec);\n        }\n        svfloat64_t norm = svsqrt_f64(sum);\n        svbool_t cmp = svwhilelt_b64(0, cols);\n        svfloat64_t threshold_vec = svld1_f64(&thresholds[i]);\n        cmp = svcmplt_f64_m(cmp, norm, threshold_vec);\n        result[i] = svptest_any(cmp);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            sum = svmla_f64(sum, vec, vec);\n        }\n        svfloat64_t norm = svsqrt_f64(sum);\n        svbool_t cmp = svcmplt_f64(norm, svld1(pg, &thresholds[i]));\n        result[i] = svptest_any(pg, cmp);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svuint32_t a_vec, b_vec, c_vec;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        a_vec = svld1_u32(&A[i]);\n        b_vec = svld1_u32(&B[i]);\n        c_vec = svorr_u32(a_vec, b_vec);\n        svst1_u32(&C[i], c_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_a, vec_b, vec_c;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_a = svld1_u32(&A[i]);\n        vec_b = svld1_u32(&B[i]);\n        vec_c = svorr_u32(vec_a, vec_b);\n        svst1_u32(&C[i], vec_c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svuint32_t a_vec, b_vec, c_vec;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        a_vec = svld1_u32(&A[i]);\n        b_vec = svld1_u32(&B[i]);\n        c_vec = svorr_u32(a_vec, b_vec);\n        svst1_u32(&C[i], c_vec);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svuint32_t a_vec, b_vec, c_vec;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        a_vec = svld1_u32(&A[i]);\n        b_vec = svld1_u32(&B[i]);\n        c_vec = svorr_u32(a_vec, b_vec);\n        svst1_u32(&C[i], c_vec);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svuint32_t a_vec, b_vec, c_vec;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        a_vec = svld1_u32(&A[i]);\n        b_vec = svld1_u32(&B[i]);\n        c_vec = svorr_u32(a_vec, b_vec);\n        svst1_u32(&C[i], c_vec);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint64_t sum_squares = svdup_n_s64(0);\n    svint64_t sum_products = svdup_n_s64(0);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        \n        svint16_t a_sq = svmul_s16(svuzp1_s16(svuzp1_u8(a_vec)), svuzp1_s16(svuzp1_u8(a_vec)));\n        svint16_t b_sq = svmul_s16(svuzp1_s16(svuzp1_u8(b_vec)), svuzp1_s16(svuzp1_u8(b_vec)));\n        svint16_t prod = svmul_s16(svuzp1_s16(svuzp1_u8(a_vec)), svuzp1_s16(svuzp1_u8(b_vec)));\n        \n        sum_squares = svadd_s64(sum_squares, svadd_s64(svadd_s64(svdup_n_s64(0), svaddv_s64(a_sq)), svaddv_s64(b_sq)));\n        sum_products = svadd_s64(sum_products, svaddv_s64(prod));\n    }\n    \n    int64_t total_squares = svaddv_s64(sum_squares);\n    int64_t total_products = svaddv_s64(sum_products);\n    \n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint64_t sum_squares = svdup_n_s64(0);\n    svint64_t sum_products = svdup_n_s64(0);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svuint8_t a_vec = svld1_u8(&A[i]);\n        svuint8_t b_vec = svld1_u8(&B[i]);\n        \n        svint16_t a_squared = svmul_s16(svuzp_u8(a_vec, a_vec).val[0], svuzp_u8(a_vec, a_vec).val[0]);\n        svint16_t b_squared = svmul_s16(svuzp_u8(b_vec, b_vec).val[0], svuzp_u8(b_vec, b_vec).val[0]);\n        svint16_t product = svmul_s16(a_vec, b_vec);\n        \n        sum_squares = svadd_s64(sum_squares, svreinterpret_s64(svadd_u16(a_squared, b_squared)));\n        sum_products = svadd_s64(sum_products, svreinterpret_s64(product));\n    }\n    \n    int64_t total_squares = svaddv_s64(sum_squares);\n    int64_t total_products = svaddv_s64(sum_products);\n    \n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        svint8_t a_vec = svld1(pg, A + i);\n        svint8_t b_vec = svld1(pg, B + i);\n\n        svint16_t a_sq = svmul_s8(a_vec, a_vec);\n        svint16_t b_sq = svmul_s8(b_vec, b_vec);\n        svint16_t prod = svmul_s8(a_vec, b_vec);\n\n        sum_squares += svaddv_s16(pg, a_sq);\n        sum_squares += svaddv_s16(pg, b_sq);\n        sum_products += svaddv_s16(pg, prod);\n    }\n\n    for (; i < length; i++) {\n        sum_squares += A[i] * A[i];\n        sum_squares += B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vl = svcntb(); // Vector length in bytes for int8_t\n    size_t i;\n\n    for (i = 0; i < length; i += vl) {\n        size_t n = length - i < vl ? length - i : vl;\n\n        svint8_t a_vec = svld1_u8(svwhilelt_b8(i, length), A + i);\n        svint8_t b_vec = svld1_u8(svwhilelt_b8(i, length), B + i);\n\n        svint16_t a_squared = svmul_s8(a_vec, a_vec);\n        svint16_t b_squared = svmul_s8(b_vec, b_vec);\n        svint16_t product = svmul_s8(a_vec, b_vec);\n\n        sum_squares += svaddv_s16(svadd_s16(a_squared, b_squared));\n        sum_products += svaddv_s16(product);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - svcntb(); i += svcntb()) {\n        svint8_t a_vec = svld1_s8(A + i);\n        svint8_t b_vec = svld1_s8(B + i);\n        \n        svint16_t a_squared = svmul_s8(a_vec, a_vec);\n        svint16_t b_squared = svmul_s8(b_vec, b_vec);\n        svint16_t product = svmul_s8(a_vec, b_vec);\n        \n        sum_squares += svaddv_s16(a_squared);\n        sum_squares += svaddv_s16(b_squared);\n        sum_products += svaddv_s16(product);\n    }\n\n    for (; i < length; i++) {\n        sum_squares += (int64_t)A[i] * (int64_t)A[i];\n        sum_squares += (int64_t)B[i] * (int64_t)B[i];\n        sum_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_c;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_a = svld1_u64(&A[i]);\n        vec_b = svld1_u64(&B[i]);\n        vec_not_b = svnot_u64(vec_b);\n        vec_c = svand_u64(vec_a, vec_not_b);\n        svst1_u64(&C[i], vec_c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_c;\n\n    for (i = 0; i < length; i += svcntd()) {\n        size_t vl = svcntd(); // Get the current vector length\n        vec_a = svld1_u64(&A[i]); // Load A\n        vec_b = svld1_u64(&B[i]); // Load B\n        vec_not_b = svnot_u64(vec_b); // Bitwise negation of B\n        vec_c = svand_u64(vec_a, vec_not_b); // Element-wise AND\n        svst1_u64(&C[i], vec_c); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_c;\n\n    for (i = 0; i < length; i += svcntb_u64()) {\n        size_t vl = svcntb_u64(); // Get the vector length\n        vec_a = svld1_u64(&A[i]); // Load A\n        vec_b = svld1_u64(&B[i]); // Load B\n        vec_not_b = svnot_u64(vec_b); // Bitwise negation of B\n        vec_c = svand_u64(vec_a, vec_not_b); // Element-wise AND\n        svst1_u64(&C[i], vec_c); // Store result in C\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_c;\n\n    for (i = 0; i < length; i += svcntd()) {\n        size_t vl = svcntd(); // Get the number of elements that can be processed in parallel\n        vec_a = svld1_u64(&A[i]); // Load A\n        vec_b = svld1_u64(&B[i]); // Load B\n        vec_not_b = svnot_u64(vec_b); // Bitwise negation of B\n        vec_c = svand_u64(vec_a, vec_not_b); // Element-wise AND between A and NOT B\n        svst1_u64(&C[i], vec_c); // Store the result in C\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_c;\n\n    for (i = 0; i < length; i += svcntb64()) {\n        size_t vl = svcntb64() < (length - i) ? svcntb64() : (length - i);\n        \n        vec_a = svld1_u64(&A[i]);\n        vec_b = svld1_u64(&B[i]);\n        vec_not_b = svnot_u64(vec_b);\n        vec_c = svand_u64(vec_a, vec_not_b);\n        \n        svst1_u64(&C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    \n    for (; i <= length - svcntb8(); i += svcntb8()) {\n        svint8_t a = svld1_u8(pg, (const uint8_t*)&A[i]);\n        svint8_t b = svld1_u8(pg, (const uint8_t*)&B[i]);\n        \n        svbool_t pos_a = svcmpgt_b8(pg, a, svdup_n_u8(0));\n        svbool_t pos_b = svcmpgt_b8(pg, b, svdup_n_u8(0));\n        svbool_t neg_a = svcmplt_b8(pg, a, svdup_n_u8(0));\n        svbool_t neg_b = svcmplt_b8(pg, b, svdup_n_u8(0));\n        \n        svint8_t result = svdup_n_u8(0);\n        result = svsel(pos_a & pos_b, svdup_n_u8(1), result);\n        result = svsel(neg_a & neg_b, svdup_n_u8(-1), result);\n        \n        svst1_u8(pg, (uint8_t*)&C[i], result);\n    }\n    \n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += svcntb()) {\n        svuint8_t a = svld1_u8(&A[i]);\n        svuint8_t b = svld1_u8(&B[i]);\n\n        svbool_t pos_a = svcmpeq_u8(a, 1);\n        svbool_t pos_b = svcmpeq_u8(b, 1);\n        svbool_t neg_a = svcmpeq_u8(a, 255); // -1 in 8-bit unsigned\n        svbool_t neg_b = svcmpeq_u8(b, 255); // -1 in 8-bit unsigned\n\n        svbool_t both_pos = svand_b(pos_a, pos_b);\n        svbool_t both_neg = svand_b(neg_a, neg_b);\n\n        svuint8_t result = svdup_u8(0);\n        result = svorr_u8(result, svdup_u8(1), both_pos);\n        result = svorr_u8(result, svdup_u8(255), both_neg); // -1 in 8-bit unsigned\n\n        svst1_u8(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i < length; i += SVE_ACLE_VEC_SIZE(int8_t)) {\n        svint8_t a_vec = svld1_s8(&A[i]);\n        svint8_t b_vec = svld1_s8(&B[i]);\n\n        svbool_t pos_mask = svcmpgt_s8(a_vec, svdup_n_s8(0));\n        svbool_t neg_mask = svcmplt_s8(a_vec, svdup_n_s8(0));\n\n        svbool_t b_pos_mask = svcmpgt_s8(b_vec, svdup_n_s8(0));\n        svbool_t b_neg_mask = svcmplt_s8(b_vec, svdup_n_s8(0));\n\n        svbool_t both_pos_mask = svand_b(pos_mask, b_pos_mask);\n        svbool_t both_neg_mask = svand_b(neg_mask, b_neg_mask);\n\n        svint8_t result = svdup_n_s8(0);\n        result = svorr(result, svand_b(both_pos_mask, svdup_n_s8(1)));\n        result = svorr(result, svand_b(both_neg_mask, svdup_n_s8(-1)));\n\n        svst1_s8(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    for (; i < length; i += svcntb()) {\n        svint8_t a = svld1(pg, &A[i]);\n        svint8_t b = svld1(pg, &B[i]);\n\n        svbool_t pos_a = svcmplt_b8(a, 0);\n        svbool_t pos_b = svcmplt_b8(b, 0);\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel(pos_a & pos_b, svdup_n_s8(-1), result);\n        result = svsel(~pos_a & ~pos_b, svdup_n_s8(1), result);\n\n        svst1(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    for (i = 0; i < length; i += svcntb()) {\n        svint8_t a = svld1_u8(pg, A + i);\n        svint8_t b = svld1_u8(pg, B + i);\n        \n        svbool_t pos_a = svcmple_n_u8(a, 0);\n        svbool_t pos_b = svcmple_n_u8(b, 0);\n        \n        svbool_t both_pos = svand_b(pos_a, pos_b);\n        svbool_t both_neg = svand_b(svcmple_n_u8(a, 0), svcmple_n_u8(b, 0));\n        \n        svint8_t result = svdup_n_u8(0);\n        result = svorr_b(both_pos, svdup_n_u8(1), result);\n        result = svorr_b(both_neg, svdup_n_u8(-1), result);\n        \n        svst1_u8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    svuint16_t vec_a, vec_b, vec_c;\n    \n    for (i = 0; i < midpoint; i += svcntw()) {\n        size_t vl = svcntw();\n        vec_a = svld1_u16(&A[i]);\n        vec_b = svld1_u16(&B[i]);\n        vec_c = svorr_u16(vec_a, vec_b); // Element-wise XOR\n        svst1_u16(&C[i], vec_c);\n    }\n\n    if (length % svcntw() != 0) {\n        size_t remaining = length % svcntw();\n        for (size_t j = midpoint; j < midpoint + remaining; j++) {\n            C[j] = A[j];\n        }\n    }\n\n    for (; i < length; i += svcntw()) {\n        size_t vl = svcntw();\n        vec_a = svld1_u16(&A[i]);\n        vec_b = svld1_u16(&B[i]);\n        vec_c = svand_u16(vec_a, vec_b); // Element-wise AND\n        svst1_u16(&C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    svuint16_t a_vec, b_vec, c_vec;\n    \n    for (i = 0; i < midpoint; i += svcntw()) {\n        size_t vl = svcntw();\n        a_vec = svld1_u16(&A[i]);\n        b_vec = svld1_u16(&B[i]);\n        c_vec = svorr_u16(svxor_u16(a_vec, b_vec), svdup_u16(0)); // XOR operation\n        svst1_u16(&C[i], c_vec);\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i]; // AND operation\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    svuint16_t* a_vec = (svuint16_t_t*)A;\n    svuint16_t* b_vec = (svuint16_t_t*)B;\n    svuint16_t_t c_vec;\n\n    for (i = 0; i < midpoint; i += svcntw()) {\n        svuint16_t_t a = svld1_u16(svptrue_b16(), A + i);\n        svuint16_t_t b = svld1_u16(svptrue_b16(), B + i);\n        svuint16_t_t result = svorr_u16(a, b);\n        svst1_u16(svptrue_b16(), C + i, result);\n    }\n\n    if (length % svcntw() != 0) {\n        size_t remaining = length % svcntw();\n        for (size_t j = midpoint; j < length; j++) {\n            C[j] = A[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    svuint16_t vec_a, vec_b, vec_c;\n    \n    for (i = 0; i < midpoint; i += svcntw()) {\n        size_t vl = svcntw();\n        vec_a = svld1_u16(&A[i]);\n        vec_b = svld1_u16(&B[i]);\n        vec_c = svorr_u16(vec_a, vec_b); // XOR operation\n        svst1_u16(&C[i], vec_c);\n    }\n\n    // Midpoint element\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    for (; i < length; i++) {\n        C[i] = svand_u16(A[i], B[i]); // AND operation\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    svbool_t pg;\n\n    // Process elements before the midpoint\n    for (i = 0; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t result = svorr_u16(va, vb); // XOR operation\n        svst1_u16(pg, &C[i], result);\n    }\n\n    // Process the midpoint element\n    if (length % 2 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t result = svand_u16(va, vb); // AND operation\n        svst1_u16(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svld1(pg, &B[i]);\n        svfloat32_t c_vec = svld1(pg, &C[i]);\n        svfloat32_t d_vec = svld1(pg, &D[i]);\n\n        svuint8_t cond1_vec = svld1_u8(pg, (const uint8_t*)&cond1[i]);\n        svuint8_t cond2_vec = svld1_u8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t cond1_true = svcmpeq_u8(cond1_vec, svdup_u8(1));\n        svbool_t cond2_true = svcmpeq_u8(cond2_vec, svdup_u8(1));\n\n        svfloat32_t out_vec = svdup_f32(0.0f);\n        \n        out_vec = svsel(cond1_true & cond2_true, a_vec, out_vec);\n        out_vec = svsel(cond1_true & !cond2_true, b_vec, out_vec);\n        out_vec = svsel(!cond1_true & cond2_true, c_vec, out_vec);\n        out_vec = svsel(!cond1_true & !cond2_true, d_vec, out_vec);\n\n        svst1(pg, &out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svuint32_t cond1_vec = svld1_u32(pg, (const uint32_t*)&cond1[i]);\n        svuint32_t cond2_vec = svld1_u32(pg, (const uint32_t*)&cond2[i]);\n        \n        svfloat32_t A_vec = svld1(pg, &A[i]);\n        svfloat32_t B_vec = svld1(pg, &B[i]);\n        svfloat32_t C_vec = svld1(pg, &C[i]);\n        svfloat32_t D_vec = svld1(pg, &D[i]);\n\n        svbool_t cond1_true = svreinterpret_b32(svdup_u32(1) & cond1_vec);\n        svbool_t cond2_true = svreinterpret_b32(svdup_u32(1) & cond2_vec);\n\n        svfloat32_t out_vec = svsel(cond1_true & cond2_true, A_vec,\n                        svsel(cond1_true & !cond2_true, B_vec,\n                        svsel(!cond1_true & cond2_true, C_vec, D_vec)));\n\n        svst1(pg, &out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svuint32_t idx = svindex_u32(i, svcntw());\n        \n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svld1(pg, &B[i]);\n        svfloat32_t c_vec = svld1(pg, &C[i]);\n        svfloat32_t d_vec = svld1(pg, &D[i]);\n        \n        svbool_t cond1_vec = svld1(pg, (const uint32_t*)&cond1[i]);\n        svbool_t cond2_vec = svld1(pg, (const uint32_t*)&cond2[i]);\n        \n        svbool_t cond1_true = svand(pg, cond1_vec, svdup_b32(1));\n        svbool_t cond1_false = svand(pg, svnot(pg, cond1_vec), svdup_b32(1));\n        \n        svbool_t cond2_true = svand(pg, cond2_vec, svdup_b32(1));\n        svbool_t cond2_false = svand(pg, svnot(pg, cond2_vec), svdup_b32(1));\n        \n        svfloat32_t out_vec = svdup_f32(0);\n        \n        out_vec = svsel(cond1_true, a_vec, out_vec);\n        out_vec = svsel(cond1_false, svsel(cond2_true, c_vec, out_vec), svsel(cond2_false, d_vec, out_vec));\n        \n        svst1(pg, &out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svuint32_t cond1_vec = svld1_u32(pg, (const uint32_t*)&cond1[i]);\n        svuint32_t cond2_vec = svld1_u32(pg, (const uint32_t*)&cond2[i]);\n        \n        svfloat32_t A_vec = svld1(pg, &A[i]);\n        svfloat32_t B_vec = svld1(pg, &B[i]);\n        svfloat32_t C_vec = svld1(pg, &C[i]);\n        svfloat32_t D_vec = svld1(pg, &D[i]);\n\n        svbool_t cond1_true = svreinterpret_b32(svcmpeq_u32(cond1_vec, svdup_u32(1)));\n        svbool_t cond2_true = svreinterpret_b32(svcmpeq_u32(cond2_vec, svdup_u32(1)));\n\n        svfloat32_t out_vec = svdup_f32(0.0f);\n        out_vec = svsel(cond1_true & cond2_true, A_vec, out_vec);\n        out_vec = svsel(cond1_true & !cond2_true, B_vec, out_vec);\n        out_vec = svsel(!cond1_true & cond2_true, C_vec, out_vec);\n        out_vec = svsel(!cond1_true & !cond2_true, D_vec, out_vec);\n\n        svst1(pg, &out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svld1(pg, &B[i]);\n        svfloat32_t c_vec = svld1(pg, &C[i]);\n        svfloat32_t d_vec = svld1(pg, &D[i]);\n        \n        svbool_t cond1_vec = svld1(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1(pg, &cond2[i]);\n        \n        svbool_t cond1_true = svand(pg, cond1_vec, svdup_b32(1));\n        svbool_t cond1_false = svand(pg, svnot(pg, cond1_vec), svdup_b32(1));\n        \n        svbool_t cond2_true = svand(pg, cond2_vec, svdup_b32(1));\n        svbool_t cond2_false = svand(pg, svnot(pg, cond2_vec), svdup_b32(1));\n        \n        svfloat32_t out_vec = svdup_f32(0);\n        \n        out_vec = svsel(cond1_true, a_vec, out_vec);\n        out_vec = svsel(cond1_false, svsel(cond2_true, c_vec, out_vec), out_vec);\n        out_vec = svsel(cond1_false, svsel(cond2_false, d_vec, out_vec), out_vec);\n        \n        svst1(pg, &out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svuint32_t vec = svld1_u32(&A[i]);\n        svuint32_t count = svcntb_u32(vec);\n        svst1_u8(&out[i], svreinterpret_u8_u32(count));\n    }\n\n    for (; i < total_elements; i++) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VL) {\n        svuint32_t vec = svld1_u32(&A[i]);\n        svuint8_t count = svdup_u8(0);\n\n        for (int j = 0; j < 32; j++) {\n            svuint32_t mask = svdup_u32(1u << j);\n            svuint32_t bits = svand_u32(vec, mask);\n            count = svadd_u8(count, svdup_u8(svcntb_u32(bits)));\n        }\n\n        svst1_u8(&out[i], count);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svuint32_t vec = svld1_u32(&A[i]);\n        svuint32_t count = svcntb_u32(vec);\n        svst1_u8(&out[i], svuzp1_u8(count, count));\n    }\n\n    for (; i < total_elements; i++) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - svcntb(); i += svcntb()) {\n        svuint32_t a_vec = svld1_u32(&A[i]);\n        svuint8_t count_vec = svdup_u8(0);\n\n        for (int j = 0; j < 32; j++) {\n            svuint8_t bit_mask = svdup_u8(1 << j);\n            svuint8_t bits_set = svand_u8(svshr_n_u32(a_vec, j), bit_mask);\n            count_vec = svadd_u8(count_vec, svdup_u8(!!svcntb(bits_set)));\n        }\n\n        svst1_u8(&out[i], count_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += SVE_VECTOR_LENGTH) {\n        svuint32_t a_vec = svld1_u32(&A[i]);\n        svuint32_t mask = svdup_u32(1);\n        svuint32_t count = svdup_u32(0);\n\n        for (int bit = 0; bit < 32; bit++) {\n            svuint32_t bit_set = svand_u32(a_vec, mask);\n            count = svadd_u32(count, svdup_u32(svcnt_u32(bit_set)));\n            mask = svshl_u32(mask, 1);\n        }\n\n        svuint8_t out_vec = svuzp_u8(svuzp_u8(count, count).val[0], count).val[0];\n        svst1_u8(&out[i], out_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - SVE_VL; i += SVE_VL) {\n        svint32_t a_vec = svld1_s32(&A[i]);\n        svbool_t cond = svcmpeq_n_s32(svdup_n_s32(3), 0);\n        svbool_t divisible_by_3 = svcmpeq_s32(a_vec, svdup_n_s32(0));\n\n        svint32_t abs_vec = svabs_s32(a_vec);\n        svint32_t result_vec = svsel(divisible_by_3, abs_vec, a_vec);\n\n        svst1_s32(&B[i], result_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t mask = svdup_u8(0);\n        svint32_t vec_a = svld1_s32(&A[i]);\n        \n        svuint32_t vec_a_u = svreinterpret_u32(vec_a);\n        svuint32_t divisible_by_3 = svand_u32(vec_a_u, svdup_u32(3));\n        mask = svcmpeq_u32(divisible_by_3, svdup_u32(0));\n\n        svint32_t abs_a = svabs_s32(vec_a);\n        svint32_t result = svsel(mask, abs_a, vec_a);\n\n        svst1_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t a_vec = svld1(pg, &A[i]);\n\n        svbool_t condition = svreinterpret_b32(svremu_b32(a_vec, svdup_n_u32(3)) == 0);\n        svint32_t abs_a_vec = svabs(a_vec);\n\n        svint32_t result_vec = svsel(condition, abs_a_vec, a_vec);\n        svst1(pg, &B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t mask = svdup_u8(0);\n        svint32_t vec_a = svld1_s32(&A[i]);\n\n        svuint32_t vec_a_u = svreinterpret_u32(vec_a);\n        svuint8_t is_div3 = svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(0))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(3))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(6))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(9))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(12))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(15))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(18))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(21))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(24))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(27))) | \n                            svreinterpret_u8(svcmpeq_u32(vec_a_u, svdup_u32(30)));\n\n        svint32_t abs_a = svabs_s32(vec_a);\n        svint32_t result = svsel(is_div3, abs_a, vec_a);\n\n        svst1_s32(&B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += svcntb()) {\n        svuint8_t mask = svdup_u8(0);\n        svint32_t a_vec = svld1_s32(&A[i]);\n\n        svuint32_t a_mod = svand_u32(a_vec, svdup_u32(3));\n        mask = svcmpeq_u32(a_mod, svdup_u32(0));\n\n        svint32_t abs_a_vec = svabs_s32(a_vec);\n        svint32_t result_vec = svsel(mask, abs_a_vec, a_vec);\n\n        svst1_s32(&B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb();\n        vec_src = svld1_u32(&src[i]);\n\n        pg = svwhilelt_b32(i, length);\n        svuint32_t low4_bits = svand_u32(vec_src, svdup_u32(0xF));\n        svbool_t condition = svcmpeq_u32(pg, low4_bits, svdup_u32(0xF));\n\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, svdup_u32(rotate_bits)), \n                                        svshl_u32(vec_src, svdup_u32(32 - rotate_bits)));\n\n        vec_dst = svsel(condition, rotated, svnot_u32(vec_src));\n        svst1_u32(&dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svuint32_t mask = svdup_u32(0x0F); // Mask for low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Mask for rotation\n    svuint32_t rotate_amount = svdup_u32(32 - rotate_bits); // Amount to rotate\n\n    for (i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb(); // Vector length\n        vec_src = svld1_u32(svptrue_b32(), &src[i]); // Load source vector\n\n        // Check if low 4 bits are all 1\n        svbool_t condition = svcmpeq_u32(svand_u32(vec_src, mask), mask);\n\n        // Perform rotation or negation based on condition\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, rotate_amount), svshl_u32(vec_src, svdup_u32(rotate_bits)));\n        vec_dst = svsel(condition, rotated, svnot_u32(vec_src));\n\n        // Store the result in destination vector\n        svst1_u32(svptrue_b32(), &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svuint32_t vec_src;\n    svuint32_t vec_dst;\n    svuint32_t mask = svdup_u32(0xF); // Mask for low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Mask for rotation\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb();\n        vec_src = svld1_u32(&src[i]);\n\n        // Check if the low 4 bits are all 1\n        svbool_t cond = svcmpeq_u32(svand_u32(vec_src, mask), mask);\n\n        // Perform rotation or negation based on the condition\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, svdup_n_u32(rotate_bits)), svshl_u32(vec_src, svdup_n_u32(32 - rotate_bits)));\n        vec_dst = svsel_u32(cond, rotated, svneg_u32(vec_src));\n\n        svst1_u32(&dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svuint32_t mask = svdup_u32(0x0F); // Mask for the low 4 bits\n    svuint32_t rotate_mask = svdup_u32((1U << rotate_bits) - 1); // Mask for rotation\n    svuint32_t rotate_amount = svdup_u32(32 - rotate_bits); // Amount to rotate\n\n    for (i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb(); // Vector length\n        vec_src = svld1_u32(svptrue_b32(), &src[i]); // Load source vector\n\n        svuint32_t low_bits = svand_u32(vec_src, mask); // Extract low 4 bits\n        svuint32_t condition = svcmpeq_u32(low_bits, mask); // Check if low 4 bits are all 1\n\n        // Perform rotation\n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, svdup_n_u32(rotate_bits)), \n                                        svshl_u32(vec_src, rotate_amount));\n\n        // Conditional selection\n        vec_dst = svsel(condition, rotated, svnot_u32(vec_src)); // Select based on condition\n\n        svst1_u32(svptrue_b32(), &dst[i], vec_dst); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    svuint32_t vec_src, vec_dst;\n    svbool_t pg;\n\n    for (i = 0; i < length; i += svcntb()) {\n        size_t vl = svcntb();\n        vec_src = svld1_u32(&src[i]);\n        \n        pg = svcmpeq_u32(svand_u32(vec_src, svdup_u32(0x0F)), svdup_u32(0x0F));\n        \n        svuint32_t rotated = svorr_u32(svrshl_u32(vec_src, svdup_u32(rotate_bits)), \n                                        svshl_u32(vec_src, svdup_u32(32 - rotate_bits)));\n        \n        vec_dst = svsel(pg, rotated, svnot_u32(vec_src));\n        \n        svst1_u32(&dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        \n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        svuint8_t result = svdup_u8(0);\n        \n        result = svorr_u8(result, svcmpeq_f32(abs_diff_vec, epsilon_vec));\n        result = svorr_u8(result, svcmpeq_f32(abs_diff_vec, neg_epsilon_vec));\n        \n        svuint8_t greater_than = svcmplt_f32(diff_vec, neg_epsilon_vec);\n        svuint8_t less_than = svcmpgt_f32(diff_vec, epsilon_vec);\n        \n        result = svorr_u8(result, svand_u8(greater_than, svdup_u8(255))); // -1\n        result = svorr_u8(result, svand_u8(less_than, svdup_u8(1))); // 1\n        \n        svst1_u8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svneg_f32(epsilon_vec);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        \n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        svint8_t result = svdup_n_s8(0);\n        \n        svbool_t gt_epsilon = svcmpeq_f32(svabs_f32(diff_vec), epsilon_vec);\n        svbool_t lt_neg_epsilon = svcmpeq_f32(svabs_f32(diff_vec), neg_epsilon_vec);\n        \n        result = svsel(gt_epsilon, svdup_n_s8(1), result);\n        result = svsel(lt_neg_epsilon, svdup_n_s8(-1), result);\n        \n        svst1_s8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t v_epsilon = svdup_f32(epsilon);\n    svfloat32_t v_neg_epsilon = svneg_f32(v_epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svfloat32_t v_a = svld1_f32(&A[i]);\n        svfloat32_t v_b = svld1_f32(&B[i]);\n        svfloat32_t v_diff = svsub_f32(v_a, v_b);\n        \n        svfloat32_t v_abs_diff = svabs_f32(v_diff);\n        \n        svint8_t v_out = svdup_n_s8(0);\n        v_out = svorr_s8(v_out, svcmplt_f32(v_diff, v_neg_epsilon), svdup_n_s8(-1));\n        v_out = svorr_s8(v_out, svcmpgt_f32(v_diff, v_epsilon), svdup_n_s8(1));\n        \n        svst1_s8(&out[i], v_out);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    \n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        \n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svorr_s8(result, svcmpeq_f32(abs_diff_vec, epsilon_vec));\n        result = svorr_s8(result, svcmpeq_f32(abs_diff_vec, neg_epsilon_vec));\n        \n        svint8_t pos_mask = svcmplt_f32(diff_vec, neg_epsilon_vec);\n        svint8_t neg_mask = svcmpgt_f32(diff_vec, epsilon_vec);\n        \n        result = svorr_s8(result, svand_s8(pos_mask, svdup_n_s8(-1)));\n        result = svorr_s8(result, svand_s8(neg_mask, svdup_n_s8(1)));\n        \n        svst1_s8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    svfloat32_t abs_epsilon_vec = svdup_f32(fabsf(epsilon));\n\n    size_t i = 0;\n    for (; i <= length - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svfloat32_t b_vec = svld1_f32(&B[i]);\n        svfloat32_t diff_vec = svsub_f32(a_vec, b_vec);\n        \n        svfloat32_t abs_diff_vec = svabs_f32(diff_vec);\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svorr_s8(result, svcmplt_f32(diff_vec, neg_epsilon_vec));\n        result = svorr_s8(result, svcmpgt_f32(diff_vec, epsilon_vec));\n        \n        svst1_s8(&out[i], result);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n    svbool_t pg;\n\n    const svint32_t max_int32 = svdup_n_s32(INT32_MAX);\n    const svint32_t min_int32 = svdup_n_s32(INT32_MIN);\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_a = svld1(pg, &A[i]);\n        \n        vec_b = svcvta_s32_f32(vec_a);\n        \n        // Apply saturation\n        vec_b = svmin_s32(vec_b, max_int32);\n        vec_b = svmax_s32(vec_b, min_int32);\n        \n        svst1(pg, &B[i], vec_b);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32_t max_float = (float32_t)INT32_MAX;\n    const float32_t min_float = (float32_t)INT32_MIN;\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t vec_a = svld1_f32(A + i);\n        svint32_t vec_b = svuzp_f32(vec_a, vec_a); // Duplicate to use for saturation\n\n        // Apply saturation\n        svint32_t saturated_b = svmin_s32(svmax_s32(svuzp_f32(vec_a, vec_a), svdup_s32(INT32_MIN)), svdup_s32(INT32_MAX));\n\n        svst1_s32(B + i, saturated_b);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > max_float) {\n            B[i] = INT32_MAX;\n        } else if (value < min_float) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const svint32_t max_val = svdup_n_s32(INT32_MAX);\n    const svint32_t min_val = svdup_n_s32(INT32_MIN);\n    \n    size_t i = 0;\n    for (; i <= size - SV_NUM_ELEMS; i += SV_NUM_ELEMS) {\n        svfloat32_t a_vec = svld1_f32(A + i);\n        svint32_t b_vec = svcvt_s32_f32(a_vec);\n        \n        svint32_t b_vec_clamped = svmin_s32(svmax_s32(b_vec, min_val), max_val);\n        svst1_s32(B + i, b_vec_clamped);\n    }\n    \n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const svfloat32_t max_float = svdup_f32((float)INT32_MAX);\n    const svfloat32_t min_float = svdup_f32((float)INT32_MIN);\n    const svint32_t max_int = svdup_s32(INT32_MAX);\n    const svint32_t min_int = svdup_s32(INT32_MIN);\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svint32_t b_vec = svuzp_s32(svmax_s32(svmin_s32(svuzp_s32(a_vec, max_float), max_int), min_int));\n        svst1_s32(&B[i], b_vec);\n    }\n\n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32_t max_float = (float32_t)INT32_MAX;\n    const float32_t min_float = (float32_t)INT32_MIN;\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t vec_a = svld1_f32(A + i);\n        svint32_t vec_b = svreinterpret_s32_f32(vec_a);\n\n        svint32_t vec_max = svdup_n_s32(INT32_MAX);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN);\n\n        svint32_t vec_result = svmin_s32(vec_b, vec_max);\n        vec_result = svmax_s32(vec_result, vec_min);\n\n        svst1_s32(B + i, vec_result);\n    }\n\n    for (; i < size; i++) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svcvt_f32_s32(a_vec);\n        b_vec = svmul_f32_m(pg, b_vec, svdup_f32((float)scale));\n        svst1(pg, &B[i], b_vec);\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_s32(vec_a);\n        svfloat32_t vec_scale = svdup_f32((float)scale);\n        vec_b = svmul_f32(pg, vec_b, vec_scale);\n        svst1(pg, &B[i], vec_b);\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svcvt_f32_s32(a_vec);\n        b_vec = svmul_f32(pg, b_vec, svdup_f32((float)scale));\n        svst1(pg, &B[i], b_vec);\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; svptest_any(pg); i += svcntw()) {\n        svint32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svcvt_f32_s32(a_vec);\n        b_vec = svmul_f32_m(pg, b_vec, svdup_f32((float)scale));\n        svst1(pg, &B[i], b_vec);\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; svptest_any(pg); i += svcntw()) {\n        svint32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svcvt_f32_s32(a_vec);\n        b_vec = svmul_f32(pg, b_vec, svdup_f32((float)scale));\n        svst1(pg, &B[i], b_vec);\n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svfloat32_t a_vec, b_vec, result_vec;\n    svint32_t rounded_vec;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        a_vec = svld1_f32(&A[i]);\n        b_vec = svld1_f32(&B[i]);\n        result_vec = svdiv_f32(a_vec, b_vec);\n        rounded_vec = svrndn_s32(result_vec);\n        svst1_s32(&C[i], rounded_vec);\n    }\n\n    for (; i < size; i++) {\n        C[i] = (int32_t)(roundf(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svfloat32_t va, vb, vresult;\n    svint32_t vrounded;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        va = svld1_f32(&A[i]);\n        vb = svld1_f32(&B[i]);\n        vresult = svdiv_f32(va, vb);\n        vrounded = svcvta_s32_f32(vresult);\n        svst1_s32(&C[i], vrounded);\n    }\n\n    for (; i < size; i++) {\n        C[i] = (int32_t)(A[i] / B[i] + (A[i] / B[i] >= 0 ? 0.5f : -0.5f));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svfloat32_t va, vb, vresult;\n    svint32_t vrounded;\n\n    for (; i < size; i += svcntw()) {\n        size_t vl = svcntw(); // Vector length\n        va = svld1_f32(&A[i]); // Load A\n        vb = svld1_f32(&B[i]); // Load B\n        vresult = svdiv_f32(va, vb); // Element-wise division\n        vrounded = svrndn_s32(vresult); // Round to nearest integer\n        svst1_s32(&C[i], vrounded); // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svfloat32_t va, vb, vresult;\n    svint32_t vrounded;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        va = svld1_f32(&A[i]);\n        vb = svld1_f32(&B[i]);\n        vresult = svdiv_f32(va, vb);\n        vrounded = svrndn_n_s32_f32(vresult);\n        svst1_s32(&C[i], vrounded);\n    }\n\n    for (; i < size; i++) {\n        C[i] = (int32_t)(roundf(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svfloat32_t va, vb, vresult;\n    svint32_t vrounded;\n\n    for (; i < size; i += svcntw()) {\n        size_t vl = svcntw();\n        vl = svmin_u(size - i, vl);\n\n        va = svld1_f32(&A[i]);\n        vb = svld1_f32(&B[i]);\n        vresult = svdiv_f32(va, vb);\n        vrounded = svrndn_s32(vresult);\n        \n        svst1_s32(&C[i], vrounded);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svfloat64_t vec_d;\n    svfloat32_t vec_f;\n    svfloat32_t max_f = svdup_f32(FLT_MAX);\n    svfloat32_t min_f = svdup_f32(-FLT_MAX);\n\n    for (; i <= size - svcntd(); i += svcntd()) {\n        vec_d = svld1_f64(&A[i]);\n        vec_f = svcvtn_f64_f32(vec_d); // Convert double to float\n        \n        // Saturate values\n        vec_f = svmin_f32(vec_f, max_f);\n        vec_f = svmax_f32(vec_f, min_f);\n        \n        svst1_f32(&B[i], vec_f);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float max_float = (float)FLT_MAX;\n    const float min_float = (float)-FLT_MAX;\n\n    for (; i <= size - svcntd(); i += svcntd()) {\n        svfloat64_t va = svld1_u64(A + i);\n        svfloat64_t vclamped = svmin_f64(va, svdup_f64(max_float));\n        vclamped = svmax_f64(vclamped, svdup_f64(min_float));\n        svfloat32_t vb = svcvt_f32_f64(vclamped);\n        svst1_f32(B + i, vb);\n    }\n\n    for (; i < size; i++) {\n        double value = A[i];\n        if (value > max_float) {\n            B[i] = max_float;\n        } else if (value < min_float) {\n            B[i] = min_float;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svfloat64_t vec_d;\n    svfloat32_t vec_f;\n    svfloat32_t max_f = svdup_f32(FLT_MAX);\n    svfloat32_t min_f = svdup_f32(-FLT_MAX);\n    \n    for (; i <= size - svcntd(); i += svcntd()) {\n        vec_d = svld1_f64(&A[i]);\n        vec_f = svcvt_f32_f64(vec_d);\n        vec_f = svmin_f32(vec_f, max_f);\n        vec_f = svmax_f32(vec_f, min_f);\n        svst1_f32(&B[i], vec_f);\n    }\n    \n    for (; i < size; i++) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svfloat64_t vec_d;\n    svfloat32_t vec_f;\n    svfloat32_t max_f = svdup_f32(FLT_MAX);\n    svfloat32_t min_f = svdup_f32(-FLT_MAX);\n\n    for (; i <= size - svcntd(); i += svcntd()) {\n        vec_d = svld1_u64(&A[i]);\n        vec_f = svcvt_f32_f64(vec_d);\n        vec_f = svmin_f32(vec_f, max_f);\n        vec_f = svmax_f32(vec_f, min_f);\n        svst1_u32(&B[i], vec_f);\n    }\n\n    for (; i < size; i++) {\n        double temp = A[i];\n        if (temp > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (temp < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)temp;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svfloat64_t vec_d;\n    svfloat32_t vec_f;\n    svfloat32_t max_f = svdup_f32(FLT_MAX);\n    svfloat32_t min_f = svdup_f32(-FLT_MAX);\n\n    for (; i <= size - svcntd(); i += svcntd()) {\n        vec_d = svld1_u64(A + i);\n        vec_f = svcvt_f32_f64(vec_d);\n        vec_f = svmin_f32(vec_f, max_f);\n        vec_f = svmax_f32(vec_f, min_f);\n        svst1_f32(B + i, vec_f);\n    }\n\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        svint16_t a = svld1(pg, &A[i]);\n        svint32_t b = svcvt_s32_s16(a);\n        svst1(pg, &B[i], b);\n        pg = svwhilelt_b16(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    for (i = 0; i < size; i += svcntw()) {\n        svint16_t a = svld1(pg, &A[i]);\n        svint32_t b = svreinterpret_s32_s16(a);\n        svst1(pg, &B[i], b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    for (; i < size; i += svcntw()) {\n        svint16_t a = svld1(pg, &A[i]);\n        svint32_t b = svreinterpret_s32(a);\n        svst1(pg, &B[i], b);\n        pg = svwhilelt_b16(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    for (; i < size; i += svcntw()) {\n        svint16_t a = svld1(pg, &A[i]);\n        svint32_t b = svreinterpret_s32(a);\n        svst1(pg, &B[i], b);\n        pg = svwhilelt_b16(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    svbool_t pg;\n    for (i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_s16(vec_a);\n        svst1(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n\n    size_t i = 0;\n    for (; i <= size - SVECTOR_LENGTH; i += SVECTOR_LENGTH) {\n        svint32_t control_vec = svld1_s32(control + i);\n        svfloat32_t A_vec = svld1_f32(A + i);\n\n        svbool_t mask = svgt_s32(control_vec, svdup_s32(0));\n\n        svfloat32_t normalized = svsub_f32(A_vec, min_val_vec);\n        normalized = svdiv_f32(normalized, range_vec);\n        normalized = svmax_f32(normalized, svdup_f32(0.0f));\n        normalized = svmin_f32(normalized, svdup_f32(1.0f));\n\n        svfloat32_t result = svsel(mask, normalized, A_vec);\n        svst1_f32(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized_val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized_val < 0.0f ? 0.0f : (normalized_val > 1.0f ? 1.0f : normalized_val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t min_val_vec = svdup_f32(min_val);\n    float32_t max_val_vec = svdup_f32(max_val);\n    float32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n    \n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        float32_t a_vec = svld1_f32(pg, &A[i]);\n        int32_t control_vec = svld1_s32(pg, &control[i]);\n        \n        svbool_t control_pg = svcmplt_s32(control_vec, svdup_s32(1));\n        \n        float32_t normalized_vec = svsub_f32(a_vec, min_val_vec);\n        normalized_vec = svdiv_f32(normalized_vec, range_vec);\n        normalized_vec = svmax_f32(normalized_vec, svdup_f32(0.0f));\n        normalized_vec = svmin_f32(normalized_vec, svdup_f32(1.0f));\n        \n        float32_t result_vec = svsel(control_pg, a_vec, normalized_vec);\n        svst1_f32(pg, &B[i], result_vec);\n    }\n    \n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : (val > 1.0f) ? 1.0f : val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32_t min_val_vec = svdup_f32(min_val);\n    float32_t max_val_vec = svdup_f32(max_val);\n    float32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        float32_t a_vec = svld1_f32(pg, &A[i]);\n        int32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t control_pg = svcmpeq_s32(pg, control_vec, svdup_s32(0));\n        float32_t normalized_vec = svsub_f32(a_vec, min_val_vec);\n        normalized_vec = svdiv_f32(normalized_vec, range_vec);\n        normalized_vec = svmax_f32(normalized_vec, svdup_f32(0.0f));\n        normalized_vec = svmin_f32(normalized_vec, svdup_f32(1.0f));\n\n        svst1_f32(pg, &B[i], svsel(control_pg, a_vec, normalized_vec));\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : (val > 1.0f) ? 1.0f : val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t a_vec = svld1_f32(&A[i]);\n        svint32_t control_vec = svld1_s32(&control[i]);\n\n        svbool_t mask = svgt_s32(control_vec, svdup_s32(0));\n\n        svfloat32_t normalized = svsub_f32(a_vec, min_val_vec);\n        normalized = svdiv_f32(normalized, range_vec);\n        normalized = svmax_f32(normalized, svdup_f32(0.0f));\n        normalized = svmin_f32(normalized, svdup_f32(1.0f));\n\n        svfloat32_t result = svsel(mask, normalized, a_vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (normalized < 0.0f) ? 0.0f : (normalized > 1.0f) ? 1.0f : normalized;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32(max_val_vec, min_val_vec);\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svuint32_t ctrl_vec = svld1_u32(&control[i]);\n        svfloat32_t A_vec = svld1_f32(&A[i]);\n\n        svbool_t mask = svgt_u32(ctrl_vec, svdup_u32(0));\n        svfloat32_t normalized = svsub_f32(A_vec, min_val_vec);\n        normalized = svdiv_f32(normalized, range_vec);\n        normalized = svmax_f32(normalized, svdup_f32(0.0f));\n        normalized = svmin_f32(normalized, svdup_f32(1.0f));\n\n        svfloat32_t result = svsel(mask, normalized, A_vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized < 0.0f ? 0.0f : (normalized > 1.0f ? 1.0f : normalized);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n    \n    for (i = 0; i < size; i += svcntb()) {\n        size_t vl = svcntb(); // Vector length\n        vec_a = svld1_u32(&A[i]); // Load uint32_t values\n        \n        // Extract high 16 bits and convert to float\n        svuint32_t high_bits = svshl_u32(vec_a, 16); // Shift left to get high 16 bits\n        vec_b = svcvt_f32_u32(high_bits); // Convert to float\n        \n        // Compute square root\n        vec_b = svsqrt_f32(vec_b);\n        \n        // Store the result\n        svst1_f32(&B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntb(); i += svcntb()) {\n        vec_a = svld1_u32(A + i);\n        vec_b = svsqrt_f32(svuzp1_f32(svshl_n_u32(vec_a, 16), svdup_f32(0.0f)));\n        svst1_f32(B + i, vec_b);\n    }\n\n    for (; i < size; i++) {\n        B[i] = sqrtf((A[i] >> 16) & 0xFFFF);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec_a = svld1_u32(A + i);\n        vec_b = svsqrt_f32(svuzp1_f32(svshl_n_u32(vec_a, 16))); // Extract high 16 bits and convert to float\n        svst1_f32(B + i, vec_b);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = sqrtf((A[i] >> 16) & 0xFFFF);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i += svcntb()) {\n        svuint32_t a_vec = svld1_u32(&A[i]);\n        svuint32_t high_bits = svshl_n_u32(a_vec, 16);\n        svfloat32_t float_vec = svcvt_f32_u32(high_bits);\n        svfloat32_t sqrt_vec = svsqrt_f32(float_vec);\n        svst1_f32(&B[i], sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntb(); i += svcntb()) {\n        vec_a = svld1_u32(&A[i]);\n        vec_a = svshl_n_u32(vec_a, 16); // Shift left to get the high 16 bits\n        vec_b = svcvt_f32_u32(vec_a);   // Convert to float\n        vec_b = svsqrt_f32(vec_b);      // Compute square root\n        svst1_f32(&B[i], vec_b);        // Store result\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(A + i);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntb(); i += svcntb()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec_a = svld1_u32(&A[i]);\n        vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(&B[i], vec_b);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec;\n    svfloat32_t result;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec = svld1_u32(&A[i]);\n        result = svreinterpret_f32_u32(vec);\n        svst1_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svuint32_t vec_a;\n    svfloat32_t vec_b;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        vec_a = svld1_u32(&A[i]);\n        vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(&B[i], vec_b);\n    }\n\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Initialize the first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of SVE vector length\n    for (size_t i = 1; i < size; i += svcntb()) {\n        // Load condition and source values\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1(pg, &A[i]);\n        svint32_t a_prev = svld1(pg, &A[i - 1]);\n        svbool_t cond_pg = svld1(pg, &cond[i]);\n\n        // Compute differences\n        svint32_t diff_int = svsub_s32(a_curr, a_prev);\n\n        // Convert to float\n        svfloat32_t diff_float = svcvt_f32_s32(diff_int);\n\n        // Set output based on condition\n        svfloat32_t result = svsel(cond_pg, diff_float, svdup_f32(0.0f));\n\n        // Store results\n        svst1(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b32();\n    svint32_t a_prev = svdup_s32(0); // Initialize previous value to 0\n    svfloat32_t zero_f = svdup_f32(0.0f);\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, size);\n        \n        svint32_t a_curr = svld1(pg_loop, &A[i]);\n        svbool_t cond_mask = svld1(pg_loop, &cond[i]);\n\n        svint32_t diff_vec = svsub_s32(a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32(diff_vec);\n\n        // Set diff to zero where cond is false\n        svfloat32_t result = svsel(cond_mask, diff_float, zero_f);\n        \n        svst1(pg_loop, &diff[i], result);\n        \n        a_prev = a_curr; // Update previous value for next iteration\n    }\n    \n    // Set the first element to 0.0f\n    svst1(pg, &diff[0], zero_f);\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b32();\n    svint32_t a_prev = svld1(pg, A); // Load first element\n    svfloat32_t zero = svdup_f32(0.0f);\n    svfloat32_t result;\n\n    // Set the first element of diff to 0.0f\n    svst1(pg, diff, zero);\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1(pg, A + i);\n        svbool_t cond_pg = svld1(pg, cond + i);\n\n        svint32_t diff_vec = svsub_s32(a_curr, a_prev);\n        result = svcvt_f32_s32(diff_vec);\n\n        // Set result to zero where cond is false\n        result = svsel(cond_pg, result, zero);\n\n        svst1(pg, diff + i, result);\n        a_prev = a_curr; // Update previous element\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b32();\n    svint32_t a_prev = svdup_s32(0); // Initialize previous element to 0\n    svfloat32_t zero_f = svdup_f32(0.0f);\n\n    for (size_t i = 1; i < size; i += svcntb()) {\n        size_t vl = svmin_u(size - i, svcntb());\n        svbool_t mask = svld1(pg, cond + i);\n        svint32_t a_curr = svld1(pg, A + i);\n        svint32_t diff_vec = svsub_s32(a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32(diff_vec);\n\n        // Set diff to zero where condition is false\n        diff_float = svsel(mask, diff_float, zero_f);\n        svst1(pg, diff + i, diff_float);\n\n        // Update previous element for next iteration\n        a_prev = a_curr;\n    }\n\n    // Set the first element to 0.0f\n    svst1(pg, diff, zero_f);\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b32();\n    svint32_t a_prev = svdup_s32(0); // Initialize previous value to 0\n    svfloat32_t zero = svdup_f32(0.0f);\n    \n    for (size_t i = 1; i < size; i += svcntb()) {\n        svbool_t valid = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1(pg, &A[i]);\n        svbool_t cond_mask = svld1(pg, &cond[i]);\n\n        svint32_t diff_vec = svsub_s32(a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32(diff_vec);\n\n        // Set diff to 0.0f where cond is false\n        svfloat32_t result = svsel(cond_mask, diff_float, zero);\n        \n        svst1(pg, &diff[i], result);\n        \n        a_prev = a_curr; // Update previous value\n    }\n    \n    // Set the first element to 0.0f\n    svst1(pg, &diff[0], zero);\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_dst = svorr_u64(svuzp_u64(svdup_u64(0xFFFFFFFFFFFFFFFF), svreinterpret_u64(vec_src)), svdup_u64(0));\n        svst1_u64(&dst[i], vec_dst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000ULL);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_dst = svorr_u64(svuzp_u64(svdup_u64(0xFFFFFFFFFFFFFFFF), svreinterpret_u64(vec_src)), svdup_u64(0));\n        svst1_u64(&dst[i], vec_dst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_dst = svorr_u64(svuzp_u64(svdup_u64(0xFFFFFFFFFFFFFFFF), svreinterpret_u64(vec_src)), svdup_u64(0));\n        svst1_u64(&dst[i], vec_dst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] | 0xFFFFFFFF00000000);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_dst = svorr_u64(svshl_n_u64(svuzp_u32(vec_src, vec_src).val[0], 32), svuzp_u32(vec_src, vec_src).val[1]);\n        svst1_u64(&dst[i], vec_dst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] << 32) | 0xFFFFFFFF;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    for (; i <= length - svcntb(); i += svcntb()) {\n        vec_src = svld1_u32(&src[i]);\n        vec_dst = svorr_u64(svshl_n_u64(svuzp_u32(vec_src, vec_src).val[0], 32), svuzp_u32(vec_src, vec_src).val[1]);\n        svst1_u64(&dst[i], vec_dst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i] << 32) | 0xFFFFFFFF;\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint16_t idx = svld1_s16(&index[i]);\n        svfloat64_t vals = svld1_gather_index_f64(vec, idx);\n        sum = svadd_f64(sum, vals);\n    }\n\n    double result = svaddv_f64(svadd_f64(sum, svdup_f64(0.0)));\n\n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint16_t idx = svld1_s16(&index[i]);\n        svfloat64_t vec_vals = svld1_gather_f64(vec, idx);\n        sum = svadd_f64(sum, vec_vals);\n    }\n\n    double result = svaddv_f64(svadd_f64(sum, svdup_f64(0.0)));\n\n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint16_t idx = svld1_s16(&index[i]);\n        svfloat64_t vec_vals = svld1_gather_index_f64(vec, idx);\n        sum = svadd_f64(sum, vec_vals);\n    }\n\n    double result = svaddv_f64(svadd_f64(sum, svdup_f64(0.0)));\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint16_t idx = svld1_s16(&index[i]);\n        svfloat64_t vals = svld1_gather_f64(vec, idx);\n        sum = svadd_f64(sum, vals);\n    }\n\n    double result = svaddv_f64(svadd_f64(sum, svdup_f64(0.0)));\n\n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        svint16_t idx = svld1_s16(&index[i]);\n        svfloat64_t values = svld1_gather_f64(vec, idx);\n        sum = svadd_f64(sum, values);\n    }\n\n    double result = svaddv_f64(svadd_f64(sum, svdup_f64(0.0)));\n\n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t acc = svdup_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    svfloat64_t input_vec = svld1(pg, &input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n                    acc = svmla_f64(acc, kernel_vec, input_vec);\n                }\n            }\n            svfloat64_t relu_result = svmax_f64(acc, svdup_f64(0.0));\n            output[i * output_size + j] = svlastb(relu_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svwhilelt_b64(0, output_size * output_size);\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t acc = svdup_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    svfloat64_t input_vec = svld1(pg, &input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n                    acc = svmla_f64(acc, kernel_vec, input_vec);\n                }\n            }\n            double result = svmax_f64(svdup_f64(0.0), svaddv_f64(acc));\n            output[i * output_size + j] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    svfloat64_t input_vec = svld1_f64(&input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n                    sum = svmla_f64(sum, kernel_vec, input_vec);\n                }\n            }\n            double result = svaddv_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    svfloat64_t input_vec = svld1_f64(&input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n                    sum = svmla_f64(sum, kernel_vec, input_vec);\n                }\n            }\n            double result = svaddv_f64(svadd_f64(sum, sum));\n            output[i * output_size + j] = result > 0 ? result : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    svfloat64_t input_vec = svld1_f64(&input[input_index]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_index]);\n                    sum = svmla_f64(sum, kernel_vec, input_vec);\n                }\n            }\n            double result = svaddv_f64(sum);\n            output[i * output_size + j] = result > 0 ? result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; i += SV_NUM_F64) {\n        size_t remaining = n - i;\n        svfloat64_t vec1 = svld1(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += SV_NUM_F64) {\n            svfloat64_t vec2 = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec1, vec2));\n            svbool_t close = svcmplt_f64(pg, diff, threshold_vec);\n            \n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n    for (size_t i = 0; i < n; i += SV_NUM_F64) {\n        svfloat64_t vec1 = svld1_f64(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += SV_NUM_F64) {\n            svfloat64_t vec2 = svld1_f64(&numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec1, vec2));\n            svbool_t close = svcmplt_f64(diff, threshold_vec);\n            if (svptest_any(svwhilelt_b64(0, n), close)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; i += SV_NUM_F64) {\n        size_t remaining = n - i;\n        svfloat64_t vec_a = svld1(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += SV_NUM_F64) {\n            svfloat64_t vec_b = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec_a, vec_b));\n            svbool_t close = svcmplt_f64(pg, diff, threshold_vec);\n            \n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n; i += SV_NUM_F64) {\n        size_t remaining = n - i;\n        svfloat64_t vec1 = svld1(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += SV_NUM_F64) {\n            svfloat64_t vec2 = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec1, vec2));\n            svbool_t close = svcmple_f64(pg, diff, threshold_vec);\n            if (svptest_any(pg, close)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svfloat64_t threshold_vec = svdup_f64(threshold);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t vec1 = svld1_f64(svptrue_b64(), &numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t vec2 = svld1_f64(svptrue_b64(), &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec1, vec2));\n            svbool_t close = svcmplt_f64(diff, threshold_vec);\n            if (svptest_any(svptrue_b64(), close)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t ops = svld1(pg, &operations[i]);\n        balance = svadd_s32(balance, ops);\n        pg = svwhilelt_b32(i + svcntw(), n);\n        \n        if (svptest_any(pg, svcmplt_s32(balance, svdup_s32(0)))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t op = svld1(pg, &operations[i]);\n        balance = svadd_s32(balance, op);\n        pg = svwhilelt_b32(i + svcntw(), n);\n        \n        if (svptest_any(pg, svcmplt_s32(balance, svdup_s32(0)))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t op = svld1(pg, &operations[i]);\n        balance = svadd_s32(balance, op);\n        pg = svwhilelt_b32(i + svcntw(), n);\n        \n        if (svptest_any(pg, svcmplt_s32(balance, svdup_s32(0)))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svint32_t ops = svld1(pg, &operations[i]);\n        balance = svadd_s32(balance, ops);\n        pg = svcmpeq(pg, balance, svdup_s32(0));\n        \n        if (svptest_any(pg, svcmplt_s32(balance, svdup_s32(0)))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t op = svld1(pg, &operations[i]);\n        balance = svadd_s32(balance, op);\n        pg = svwhilelt_b32(i + svcntw(), n);\n        \n        if (svptest_any(pg, svcmplt_s32(balance, svdup_s32(0)))) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize SVE vectors\n    svfloat64_t vec_mean = svdup_f64(mean);\n    svfloat64_t total_abs_dev = svdup_f64(0.0);\n    \n    size_t i = 0;\n    for (; i <= n - svcntd(); i += svcntd()) {\n        svfloat64_t vec_numbers = svld1_f64(svptrue_b64(), &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64(svsub_f64(vec_numbers, vec_mean));\n        total_abs_dev = svadd_f64(total_abs_dev, abs_dev);\n    }\n\n    // Handle remaining elements\n    double remaining_sum = 0.0;\n    for (; i < n; ++i) {\n        remaining_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Sum up the total absolute deviation\n    double total_sum = svaddv_f64(total_abs_dev) + remaining_sum;\n\n    // Calculate Mean Absolute Deviation\n    return total_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize SVE vectors\n    svfloat64_t vec_mean = svdup_f64(mean);\n    svfloat64_t mad_sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    // Process elements in chunks\n    for (; i <= n - svcntd(); i += svcntd()) {\n        svfloat64_t vec_numbers = svld1_f64(svptrue_b64(), &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64(svsub_f64(vec_numbers, vec_mean));\n        mad_sum = svadd_f64(mad_sum, abs_diff);\n    }\n\n    // Handle remaining elements\n    double remaining_sum = 0.0;\n    for (; i < n; ++i) {\n        remaining_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Sum up the results from SVE and remaining elements\n    double total_mad = svaddv_f64(mad_sum) + remaining_sum;\n\n    // Calculate final Mean Absolute Deviation\n    return total_mad / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svfloat64_t mean_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t data_vec = svld1_f64(svptrue_b64(), &numbers[i]);\n        sum_vec = svadd_f64(sum_vec, data_vec);\n    }\n\n    double sum = svaddv_f64(svadd_f64(sum_vec, svdup_f64(0.0)));\n    double mean = sum / n;\n\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t data_vec = svld1_f64(svptrue_b64(), &numbers[i]);\n        svfloat64_t diff_vec = svsub_f64(data_vec, svdup_f64(mean));\n        mad_vec = svadd_f64(mad_vec, svabs_f64(diff_vec));\n    }\n\n    double mad_sum = svaddv_f64(svadd_f64(mad_vec, svdup_f64(0.0)));\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize SVE vectors\n    svfloat64_t vec_mean = svdup_f64(mean);\n    svfloat64_t mad_sum = svdup_f64(0.0);\n    \n    size_t i = 0;\n    for (; i <= n - svcntd(); i += svcntd()) {\n        svfloat64_t vec_numbers = svld1_f64(&numbers[i]);\n        svfloat64_t abs_diff = svabs_f64(svsub_f64(vec_numbers, vec_mean));\n        mad_sum = svadd_f64(mad_sum, abs_diff);\n    }\n\n    // Handle remaining elements\n    double remaining_sum = 0.0;\n    for (; i < n; ++i) {\n        remaining_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Sum up the SVE results\n    double total_mad = svaddv_f64(mad_sum) + remaining_sum;\n\n    // Calculate final Mean Absolute Deviation\n    return total_mad / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / n;\n\n    // Initialize SVE vectors\n    svfloat64_t vec_mean = svdup_f64(mean);\n    svfloat64_t mad_sum = svdup_f64(0.0);\n    size_t i = 0;\n\n    // Process elements in chunks\n    for (; i <= n - svcntd(); i += svcntd()) {\n        svfloat64_t vec_numbers = svld1_f64(svptrue_b64(), &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64(svsub_f64(vec_numbers, vec_mean));\n        mad_sum = svadd_f64(mad_sum, abs_diff);\n    }\n\n    // Handle remaining elements\n    double remaining_sum = 0.0;\n    for (; i < n; ++i) {\n        remaining_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Sum up the results from SVE and remaining elements\n    double total_mad = svaddv_f64(mad_sum) + remaining_sum;\n\n    // Calculate final Mean Absolute Deviation\n    return total_mad / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    svint32_t vec_delim = svdup_n_s32(delimeter);\n    svint32_t vec_numbers;\n    size_t i = 0;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        vec_numbers = svld1_s32(&numbers[i]);\n        svst1_s32(&result[i * 2], vec_numbers);\n        svst1_s32(&result[i * 2 + 1], vec_delim);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t out_size = n + (n - 1);\n    std::vector<int> result(out_size);\n\n    if (n == 0) return result;\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(numbers.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(&input_ptr[i]);\n        svst1_s32(&output_ptr[i * 2], vec);\n        svint32_t delimiter_vec = svdup_n_s32(delimeter);\n        svst1_s32(&output_ptr[i * 2 + svcntw()], delimiter_vec);\n    }\n\n    for (; i < n; ++i) {\n        output_ptr[i * 2] = numbers[i];\n        if (i < n - 1) {\n            output_ptr[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t out_size = n + (n - 1);\n    std::vector<int> result(out_size);\n\n    if (n == 0) return result;\n\n    svint32_t *input_vec = reinterpret_cast<svint32_t*>(numbers.data());\n    svint32_t *output_vec = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1(svptrue_b32(), input_vec + i);\n        svint32_t delimeter_vec = svdup_n_s32(delimeter);\n        svint32_t interspersed = svuzp1_s32(vec, delimeter_vec);\n        svst1(svptrue_b32(), output_vec + i * 2, interspersed);\n        svst1(svptrue_b32(), output_vec + i * 2 + svcntw(), delimeter_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t new_size = n + (n - 1);\n    std::vector<int> result(new_size);\n\n    if (n == 0) return result;\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(numbers.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        svst1(svptrue_b32(), output_ptr + i * 2, vec);\n        svint32_t delimiter_vec = svdup_n_s32(delimeter);\n        svst1(svptrue_b32(), output_ptr + i * 2 + svcntw(), delimiter_vec);\n    }\n\n    for (; i < n; ++i) {\n        output_ptr[i * 2] = input_ptr[i];\n        if (i < n - 1) {\n            output_ptr[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    size_t out_size = n + (n - 1);\n    std::vector<int> result(out_size);\n\n    if (n == 0) return result;\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(numbers.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), input_ptr + i);\n        svint32_t delimeter_vec = svdup_n_s32(delimeter);\n        svint32_t interspersed = svuzp1_s32(vec, delimeter_vec);\n        svst1_s32(svptrue_b32(), output_ptr + (i * 2), interspersed);\n        svst1_s32(svptrue_b32(), output_ptr + (i * 2 + svcntw()), delimeter_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i < n - 1) {\n            result[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n    \n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        sum_vec = svadd_s16(sum_vec, vec);\n        prod_vec = svmul_s16(prod_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    // Horizontal add for sum\n    sum += svaddv_s16(sum_vec);\n    \n    // Horizontal multiply for product\n    product *= svmulv_s16(prod_vec);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_prod = svdup_n_s16(1);\n    \n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        vec_sum = svadd_s16(vec_sum, vec);\n        vec_prod = svmul_s16(vec_prod, vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    // Horizontal addition for sum\n    sum += svaddv_s16(vec_sum);\n    \n    // Horizontal multiplication for product\n    product *= svaddv_s16(vec_prod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_prod = svdup_n_s16(1);\n    \n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        vec_sum = svadd_s16(vec_sum, vec);\n        vec_prod = svmul_s16(vec_prod, vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    // Horizontal addition for sum\n    sum += svaddv_s16(vec_sum);\n    \n    // Horizontal multiplication for product\n    product *= svaddv_s16(vec_prod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_prod = svdup_n_s16(1);\n    size_t i = 0;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svint16_t vec_nums = svld1_s16(svptrue_b16(), &numbers[i]);\n        vec_sum = svadd_s16(vec_sum, vec_nums);\n        vec_prod = svmul_s16(vec_prod, vec_nums);\n    }\n\n    // Horizontal addition for sum\n    sum += svaddv_s16(svadd_s16(vec_sum, svext_s16(vec_sum, vec_sum, 1)), svext_s16(vec_sum, vec_sum, 2));\n    sum += svaddv_s16(svext_s16(vec_sum, vec_sum, 3));\n\n    // Horizontal multiplication for product\n    product *= svmulv_s16(vec_prod);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    size_t vector_length = svcntw(); // Number of 32-bit integers in a vector\n    size_t i = 0;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (; i <= n - vector_length; i += vector_length) {\n        svint16_t data_vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        sum_vec = svadd_s16(sum_vec, data_vec);\n        prod_vec = svmul_s16(prod_vec, data_vec);\n    }\n\n    // Horizontal add for sum\n    sum += svaddv_s16(svadd_s16(sum_vec, svext_s16(sum_vec, sum_vec, 1)));\n    sum += svaddv_s16(svadd_s16(sum_vec, svext_s16(sum_vec, sum_vec, 2)));\n\n    // Horizontal multiply for product\n    product *= svmulv_s16(prod_vec);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        size_t len = std::min(svcntw(), n - i);\n        svint32_t input_vec = svld1_s32(&numbers[i]);\n        max_vec = svmax_s32(max_vec, input_vec);\n        \n        for (size_t j = 0; j < len; ++j) {\n            result[i + j] = svget4_s32(max_vec, j);\n        }\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        size_t remaining = std::min(svcntw(), n - i);\n        svint32_t input_vec = svld1_s32(svptrue_b32(), &numbers[i]);\n        max_vec = svmax_s32(max_vec, input_vec);\n        \n        for (size_t j = 0; j < remaining; ++j) {\n            result[i + j] = svget4_s32(max_vec, j);\n        }\n        \n        if (i + remaining < n) {\n            result[i + remaining] = result[i + remaining - 1];\n        }\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t vl = svmin_u(remaining, svcntw());\n\n        svint32_t current_vec = svld1_s32(&numbers[i]);\n        max_vec = svmax_s32(max_vec, current_vec);\n\n        svst1_s32(&result[i], max_vec);\n        \n        for (size_t j = 0; j < vl; j++) {\n            result[i + j] = std::max(result[i - 1], result[i + j]);\n        }\n    }\n\n    for (size_t i = n - (n % svcntw()); i < n; i++) {\n        result[i] = std::max(result[i - 1], numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    svint32_t max_val = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += svcntb()) {\n        size_t remaining = n - i;\n        svint32_t vec = svld1_s32(svptrue_b32(), &numbers[i]);\n        max_val = svmax_s32(max_val, vec);\n        \n        for (size_t j = 0; j < svcntb() && j < remaining; ++j) {\n            result[i + j] = svget4_s32(max_val, j);\n        }\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        size_t remaining = std::min(svcntw(), n - i);\n        svint32_t current_vec = svld1_s32(&numbers[i]);\n        max_vec = svmax_s32(max_vec, current_vec);\n        \n        for (size_t j = 0; j < remaining; ++j) {\n            result[i + j] = svget4_s32(max_vec, j);\n        }\n        \n        if (remaining < svcntw()) {\n            for (size_t j = remaining; j < svcntw(); ++j) {\n                result[i + j] = result[i + remaining - 1];\n            }\n        }\n    }\n\n    for (size_t i = 1; i < n; ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n        svuint8_t vxor = svbitxor_u8(va, vb);\n        svst1_u8(pg, (uint8_t*)&result[i], vxor);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n        svuint8_t vxor = svorr_u8(svand_u8(va, svdup_u8(1)), svand_u8(vb, svdup_u8(1)));\n        \n        svst1_u8(pg, (uint8_t*)&result[i], vxor);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n        svuint8_t vxor = svbitxor_u8(va, vb);\n        svst1_u8(pg, (uint8_t*)&result[i], vxor);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)&b[i]);\n        svuint8_t vxor = svbitxor_u8(va, vb);\n        svst1_u8(pg, (uint8_t*)&result[i], vxor);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a.data() + i));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b.data() + i));\n        svuint8_t vxor = svorr_u8(svand_u8(va, svdup_u8(1)), svandnot_u8(va, vb));\n\n        svst1_u8(pg, (uint8_t*)(result.data() + i), vxor);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    size_t index = 0;\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint32_t lengths = svdup_u32(0);\n        svbool_t valid = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i, svcntw());\n\n        for (size_t j = 0; j < svcntw(); j++) {\n            if (svptest_any(valid, pg)) {\n                lengths = svmax_u32(lengths, svdup_u32(strings[indices[j]].size()));\n                valid = svwhilelt_b32(i + j + 1, n);\n            }\n        }\n\n        uint32_t max_length_vec = svmax_u32_s32(svdup_u32(0), lengths);\n        if (max_length_vec > max_length) {\n            max_length = max_length_vec;\n            index = i + svindex_u32(0, svcntw());\n        }\n    }\n\n    for (size_t i = 0; i < n; i++) {\n        if (strings[i].size() == max_length) {\n            return strings[i];\n        }\n    }\n\n    return \"None\";\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    size_t index = 0;\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint32_t lengths = svdup_u32(0);\n        svuint32_t indices = svdup_u32(0);\n        size_t count = std::min(svcntw(), n - i);\n\n        for (size_t j = 0; j < count; ++j) {\n            lengths = svsetq_u32(lengths, j, strings[i + j].length());\n            indices = svsetq_u32(indices, j, i + j);\n        }\n\n        svuint32_t max_lengths = svmax_u32(pg, lengths, svdup_u32(max_length));\n        pg = svwhilelt_b32(0, count);\n        max_length = svmax_u32(pg, max_lengths, max_length);\n        \n        if (max_length > lengths[0]) {\n            index = indices[0];\n        }\n    }\n\n    return strings[index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svuint8_t lengths = svdup_u8(0);\n        size_t count = std::min(svcntb(), n - i);\n        \n        for (size_t j = 0; j < count; ++j) {\n            lengths = svadd_u8(lengths, svdup_u8(strings[i + j].length()));\n        }\n\n        svuint8_t max_lengths = svmax_u8(pg, lengths, svdup_u8(max_length));\n        max_length = svget_u8(max_lengths, 0);\n        \n        for (size_t j = 0; j < count; ++j) {\n            if (strings[i + j].length() == max_length) {\n                max_index = i + j;\n                break;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    size_t index = 0;\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint32_t lengths = svdup_u32(0);\n        svbool_t mask = svwhilelt_b32(i, n);\n        for (size_t j = 0; j < svcntw() && (i + j) < n; ++j) {\n            lengths = svsetq_u32(lengths, j, strings[i + j].length());\n        }\n        svuint32_t max_lengths = svmax_u32(pg, lengths, svdup_u32(max_length));\n        max_length = svmax_u32(svptrue_b32(), max_lengths);\n        if (max_length > lengths[0]) {\n            index = i + svindex_u32(max_lengths, svmax_u32(pg, lengths, svdup_u32(max_length)));\n        }\n    }\n\n    return strings[index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"None\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint32_t lengths = svdup_u32(0);\n        svuint32_t indices = svdup_u32(0);\n        size_t count = std::min(svcntw(), n - i);\n\n        for (size_t j = 0; j < count; ++j) {\n            lengths = svsetq_u32(lengths, j, strings[i + j].length());\n            indices = svsetq_u32(indices, j, i + j);\n        }\n\n        svuint32_t max_lengths = svmax_u32(pg, lengths, svdup_u32(max_length));\n        pg = svptrue_b32();\n        max_length = svmax_u32(pg, max_lengths, svdup_u32(max_length))[0];\n\n        if (max_length > 0) {\n            max_index = svindex_u32(pg, indices, svmax_u32(pg, lengths, svdup_u32(max_length)))[0];\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svuint64_t vzero = svdup_u64(0);\n    \n    while (svptest_any(svptrue_b64(), svwhilelt_u64(vzero, va))) {\n        svuint64_t vmod = svmod_u64(va, vb);\n        va = vb;\n        vb = vmod;\n    }\n    \n    return svlast_u64(svdup_u64(0), vb);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svuint64_t vzero = svdup_u64(0);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(va, vzero)) == 0) {\n        svuint64_t vtemp = svdup_u64(0);\n        svuint64_t vmod = svrem_u64(va, vb);\n        va = vb;\n        vb = vmod;\n    }\n    \n    return svlast_u64(va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svuint64_t vzero = svdup_u64(0);\n    \n    while (svptest_any(svptrue_b64(), svwhilelt_u64(vzero, va))) {\n        svuint64_t vmod = svmod_u64(va, vb);\n        svuint64_t vmask = svcmpeq_u64(vb, vzero);\n        va = svsel_u64(vmask, vb, va);\n        vb = svsel_u64(vmask, vmod, vb);\n    }\n    \n    return svlast_u64(svdup_u64(0), vb);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svuint64_t vzero = svdup_u64(0);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(va, vzero)) == 0) {\n        svuint64_t vtemp = svdup_u64(0);\n        vtemp = svsub_u64(va, vb);\n        va = svsel(svcmplt_u64(va, vb), va, vtemp);\n        vb = svsel(svcmplt_u64(vb, vzero), vb, svdup_u64(0));\n    }\n    \n    return svlast_u64(va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svuint64_t vzero = svdup_u64(0);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(va, vzero)) == 0) {\n        svuint64_t vtemp = svdup_u64(0);\n        svuint64_t vmod = svrem_u64(va, vb);\n        va = vb;\n        vb = vmod;\n    }\n    \n    return svlast_u64(va);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(2);\n    float min_diff = std::numeric_limits<float>::max();\n\n    svfloat32_t vec_numbers = svld1_u32(svindex_u32(0, n), numbers.data());\n    svfloat32_t sorted_numbers = svsort_f32(vec_numbers);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svfloat32_t a = svld1_u32(svindex_u32(i, n), numbers.data());\n        svfloat32_t b = svld1_u32(svindex_u32(i + 1, n), numbers.data());\n        svfloat32_t diff = svsub_f32(b, a);\n        \n        svuint32_t mask = svcmplt_f32(diff, svdup_f32(min_diff));\n        if (svptest_any(mask, mask)) {\n            for (size_t j = 0; j < svcntw(); ++j) {\n                if (mask[j]) {\n                    float current_diff = svget1_f32(diff, j);\n                    if (current_diff < min_diff) {\n                        min_diff = current_diff;\n                        result[0] = std::min(svget1_f32(a, j), svget1_f32(b, j));\n                        result[1] = std::max(svget1_f32(a, j), svget1_f32(b, j));\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> closest(2);\n    float min_diff = std::numeric_limits<float>::max();\n\n    svfloat32_t vec_numbers = svld1_f32(svwhilelt_b32(0, n), numbers.data());\n    svfloat32_t sorted_vec = svsort_f32(vec_numbers);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svfloat32_t a = svld1_f32(svwhilelt_b32(0, n - i), numbers.data() + i);\n        svfloat32_t b = svld1_f32(svwhilelt_b32(0, n - i - 1), numbers.data() + i + 1);\n        svfloat32_t diff = svabs_f32(svsub_f32(a, b));\n        \n        for (int j = 0; j < svcntw(); j++) {\n            float d = svget1_f32(svindex(diff, j));\n            if (d < min_diff) {\n                min_diff = d;\n                closest[0] = svget1_f32(svindex(a, j));\n                closest[1] = svget1_f32(svindex(b, j));\n            }\n        }\n    }\n\n    if (closest[0] > closest[1]) {\n        std::swap(closest[0], closest[1]);\n    }\n    \n    return closest;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(2);\n    \n    if (n < 2) return result; // Handle edge case\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_pair[2] = {0, 0};\n\n    svfloat32_t vec_numbers = svld1_f32(svptrue_b32(), numbers.data());\n    svfloat32_t sorted_vec = svsort_f32(vec_numbers);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svfloat32_t a = svld1_f32(svptrue_b32(), numbers.data() + i);\n        svfloat32_t b = svld1_f32(svptrue_b32(), numbers.data() + i + 1);\n        \n        svfloat32_t diff = svabs_f32(svsub_f32(a, b));\n        svfloat32_t min_diff_vec = svmin_f32(diff, svdup_f32(min_diff));\n        \n        if (svptest_any(svptrue_b32(), svcmpeq_f32(min_diff_vec, diff))) {\n            for (size_t j = 0; j < svcntw(); ++j) {\n                if (diff[j] < min_diff) {\n                    min_diff = diff[j];\n                    closest_pair[0] = std::min(a[j], b[j]);\n                    closest_pair[1] = std::max(a[j], b[j]);\n                }\n            }\n        }\n    }\n\n    result[0] = closest_pair[0];\n    result[1] = closest_pair[1];\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(2);\n    \n    if (n < 2) return result; // Handle edge case\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest1 = 0.0f, closest2 = 0.0f;\n\n    svfloat32_t vec_numbers = svld1_f32(svptrue_b32(), numbers.data());\n    svfloat32_t sorted_vec = svsort_f32(vec_numbers);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svfloat32_t a = svld1_f32(svptrue_b32(), numbers.data() + i);\n        svfloat32_t b = svld1_f32(svptrue_b32(), numbers.data() + i + 1);\n        svfloat32_t diff = svabs_f32(svsub_f32(a, b));\n        \n        for (int j = 0; j < svcntw(); ++j) {\n            float current_diff = svget1_f32(svindex(diff, j));\n            if (current_diff < min_diff) {\n                min_diff = current_diff;\n                closest1 = std::min(svget1_f32(a), svget1_f32(b));\n                closest2 = std::max(svget1_f32(a), svget1_f32(b));\n            }\n        }\n    }\n\n    result[0] = closest1;\n    result[1] = closest2;\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> closest(2);\n    float min_diff = std::numeric_limits<float>::max();\n\n    svfloat32_t vec_numbers = svld1_u32(svindex_u32(0, n), numbers.data());\n    svfloat32_t sorted_numbers = svsort_f32(vec_numbers);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svfloat32_t a = svld1_u32(svindex_u32(i, n), numbers.data());\n        svfloat32_t b = svld1_u32(svindex_u32(i + 1, n), numbers.data());\n        svfloat32_t diff = svsub_f32(b, a);\n        svfloat32_t mask = svcmplt_f32(diff, svdup_f32(min_diff));\n        \n        if (svptest_any(svptrue(), mask)) {\n            for (size_t j = 0; j < svcntw(); ++j) {\n                if (mask[j]) {\n                    float current_diff = svget1_f32(diff, j);\n                    if (current_diff < min_diff) {\n                        min_diff = current_diff;\n                        closest[0] = std::min(svget1_f32(a, j), svget1_f32(b, j));\n                        closest[1] = std::max(svget1_f32(a, j), svget1_f32(b, j));\n                    }\n                }\n            }\n        }\n    }\n\n    return closest;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    std::vector<float> result(n);\n    \n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t input_vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t scaled_vec = svdiv_f32(svsub_f32(input_vec, min_vec), svsub_f32(max_vec, min_vec));\n        svst1_f32(svptrue_b32(), &result[i], scaled_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    std::vector<float> result(n);\n    \n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t scaled = svsub_f32(vec, min_vec);\n        svfloat32_t range = svsub_f32(max_vec, min_vec);\n        svfloat32_t rescaled = svdiv_f32(svtrue(), scaled, range);\n        svst1_f32(svptrue_b32(), &result[i], rescaled);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t scaled = svsub_f32(vec, min_vec);\n        scaled = svdiv_f32(scaled, range_vec);\n        svst1_f32(svptrue_b32(), &result[i], scaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t input_vec = svld1_f32(&numbers[i]);\n        svfloat32_t scaled_vec = svsub_f32(input_vec, min_vec);\n        scaled_vec = svdiv_f32(scaled_vec, range_vec);\n        svst1_f32(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t input_vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t scaled_vec = svsub_f32(input_vec, min_vec);\n        scaled_vec = svdiv_f32(scaled_vec, range_vec);\n        svst1_f32(svptrue_b32(), &result[i], scaled_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t largest_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(2);\n    svuint64_t vec_limit = svdup_u64(n / 2);\n    \n    while (svptest_any(svptrue_b64(), svcmple_u64(vec_i, vec_limit))) {\n        svuint64_t vec_divisor = svdiv_u64(vec_n, vec_i);\n        svuint64_t vec_remainder = svmod_u64(vec_n, vec_i);\n        \n        svbool_t mask = svcmpeq_u64(vec_remainder, svdup_u64(0));\n        largest_divisor = svmax_u64(mask, largest_divisor, vec_i);\n        \n        vec_i = svadd_u64(vec_i, svdup_u64(1));\n    }\n\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t largest_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(2);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(vec_i, vec_n))) {\n        svuint64_t vec_div = svdiv_u64(vec_n, vec_i);\n        svuint64_t vec_rem = svmod_u64(vec_n, vec_i);\n        \n        // Check if remainder is zero\n        if (svptest_any(svptrue_b64(), svcmpeq_u64(vec_rem, svdup_u64(0)))) {\n            largest_divisor = svmax_u64(largest_divisor, svmax_u64(svget_u64(vec_div, 0), svget_u64(vec_div, 1)));\n        }\n        \n        vec_i = svadd_u64(vec_i, svdup_u64(1));\n    }\n    \n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t largest_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(2);\n    svuint64_t vec_limit = svdup_u64(n / 2);\n    \n    while (svptest_any(svptrue_b64(), svcmplt_u64(vec_i, vec_limit))) {\n        svuint64_t vec_remainder = svmod_u64(vec_n, vec_i);\n        svuint64_t mask = svcmpeq_u64(vec_remainder, svdup_u64(0));\n        \n        largest_divisor = svmax_u64(largest_divisor, svmax_u64(vec_i, mask));\n        vec_i = svadd_u64(vec_i, svdup_u64(1));\n    }\n\n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 2) return 1; // Handle edge case\n\n    uint64_t largest_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(2);\n    \n    while (svptest_any(svptrue_b64(), svcmplt_u64(vec_i, vec_n))) {\n        svuint64_t vec_rem = svrem_u64(vec_n, vec_i);\n        svuint64_t mask = svcmpeq_u64(vec_rem, svdup_u64(0));\n        \n        if (svptest_any(svptrue_b64(), mask)) {\n            largest_divisor = svmax_u64(largest_divisor, svmax_u64(vec_i, svdup_u64(1)));\n        }\n        \n        vec_i = svadd_u64(vec_i, svdup_u64(1));\n    }\n    \n    return largest_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t max_divisor = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(1);\n    svuint64_t vec_limit = svdup_u64(n / 2);\n    \n    while (svptest_any(svptrue_b64(vec_i < vec_limit))) {\n        svuint64_t vec_remainder = svrem_u64(vec_n, vec_i);\n        svuint64_t vec_is_divisor = svcmpeq_u64(vec_remainder, svdup_u64(0));\n        \n        max_divisor = svmax_u64(max_divisor, svmax_u64(vec_is_divisor, vec_i));\n        \n        vec_i = svadd_u64(vec_i, svdup_u64(1));\n    }\n\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Use SVE to vectorize the output\n    int num_factors = factors.size();\n    svint32_t vec_factors = svdup_n_s32(0);\n    for (int i = 0; i < num_factors; i += svcntw()) {\n        svint32_t temp = svld1_s32(&factors[i]);\n        vec_factors = svadd_s32(vec_factors, temp);\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < svcntw(); i++) {\n        int factor = svget1_s32(vec_factors, i);\n        for (int j = 0; j < std::count(factors.begin(), factors.end(), factor); j++) {\n            result.push_back(factor);\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n    \n    // Handle factor of 2\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Handle odd factors from 3 to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    // Use SVE to create a vector of factors\n    int num_factors = factors.size();\n    svint32_t factor_vector = svdup_n_s32(0);\n    for (int i = 0; i < num_factors; i += svcntw()) {\n        svint32_t temp_vector = svld1_s32(svindex(i, num_factors), factors.data());\n        factor_vector = svadd_s32(factor_vector, temp_vector);\n    }\n\n    // Convert the SVE vector back to std::vector\n    std::vector<int> result;\n    for (int i = 0; i < svcntw(); ++i) {\n        int factor = svget1_s32(factor_vector, i);\n        if (factor != 0) {\n            result.push_back(factor);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Use SVE to vectorize the output\n    int num_factors = factors.size();\n    svint32_t vec_factors = svdup_n_s32(0);\n    svuint64_t indices = svindex_u64(0, num_factors);\n\n    for (int i = 0; i < num_factors; i += svcntw()) {\n        svint32_t temp = svld1_s32(&factors[i]);\n        vec_factors = svadd_s32(vec_factors, temp);\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < svcntw(); i++) {\n        int factor = svget1_s32(svindex_s32(vec_factors, i));\n        if (factor != 0) {\n            result.push_back(factor);\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // Using SVE to vectorize the output\n    int num_factors = factors.size();\n    svint32_t vec_factors = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, num_factors);\n\n    for (int i = 0; i < num_factors; i += svcntb()) {\n        svint32_t temp = svld1(pg, &factors[i]);\n        vec_factors = svadd_n_s32(vec_factors, temp);\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < svcntb(); i++) {\n        if (i < num_factors) {\n            result.push_back(svindex_s32(vec_factors, i));\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    // SVE vectorization\n    int num_factors = factors.size();\n    svint32_t vec_factors = svdup_n_s32(0);\n    svint32_t vec_count = svdup_n_s32(0);\n    \n    for (int i = 0; i < num_factors; i += svcntw()) {\n        svint32_t input_vec = svld1_s32(svptrue_b32(), &factors[i]);\n        vec_factors = svadd_s32(vec_factors, input_vec);\n        vec_count = svadd_s32(vec_count, svdup_n_s32(1));\n    }\n\n    std::vector<int> result;\n    for (int i = 0; i < svcntw(); i++) {\n        int count = svget4_s32(vec_count, i);\n        int factor = svget4_s32(vec_factors, i);\n        for (int j = 0; j < count; j++) {\n            result.push_back(factor);\n        }\n    }\n\n    std::sort(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    svfloat32_t vec;\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t len = remaining < svcntw() ? remaining : svcntw();\n\n        vec = svld1_f32(&l[i]);\n        pg = svcmpgt_f32(svdup_f32(0.0f), vec);\n        svfloat32_t filtered = svsel(pg, vec, svdup_f32(0.0f));\n\n        for (size_t j = 0; j < len; ++j) {\n            float value = svget1_f32(svindex(filtered, j));\n            if (value > 0) {\n                result.push_back(value);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    svfloat32_t vec;\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t len = remaining < svcntw() ? remaining : svcntw();\n        \n        vec = svld1_f32(&l[i]);\n        pg = svcmpgt_f32(svdup_f32(0.0f), vec);\n        \n        for (size_t j = 0; j < len; ++j) {\n            if (svptest_any(pg, svindex(svdup_n_u32(0), j))) {\n                result.push_back(svget1_f32(svindex(vec, j)));\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    svfloat32_t vec;\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t len = remaining < svcntw() ? remaining : svcntw();\n        \n        vec = svld1_f32(&l[i]);\n        pg = svcmpgt_f32(svdup_f32(0.0f), vec);\n        \n        for (size_t j = 0; j < len; ++j) {\n            if (svptest_any(pg, svindex(svdup_f32(0.0f), j))) {\n                result.push_back(svget_f32(vec, j));\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    svfloat32_t vec;\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t count = remaining < svcntw() ? remaining : svcntw();\n\n        vec = svld1_f32(&l[i]);\n        pg = svcmpgt_f32(svdup_f32(0.0f), vec);\n        svfloat32_t positive_vec = svsel(pg, vec, svdup_f32(0.0f));\n\n        for (size_t j = 0; j < count; ++j) {\n            float value = svget1_f32(svindex(positive_vec, j));\n            if (value > 0.0f) {\n                result.push_back(value);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    svfloat32_t vec;\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t len = remaining < svcntw() ? remaining : svcntw();\n\n        vec = svld1_f32(&l[i]);\n        pg = svcmpgt_f32(svdup_f32(0.0f), vec);\n        svfloat32_t filtered = svsel(pg, vec, svdup_f32(0.0f));\n\n        for (size_t j = 0; j < len; ++j) {\n            if (svget1_f32(filtered, j) > 0.0f) {\n                result.push_back(svget1_f32(filtered, j));\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    svint64_t vec_limit = svdup_n_s64(limit);\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pg = svptrue_b64();\n    \n    for (int64_t i = 3; i <= limit; i += 2) {\n        svint64_t vec_i = svdup_n_s64(i);\n        svint64_t vec_div = svdiv_s64_m(pg, vec_n, vec_i);\n        svint64_t vec_mod = svsub_s64_m(pg, vec_n, svmul_s64_m(pg, vec_div, vec_i));\n\n        if (svptest_any(pg, svcmpeq_s64(pg, vec_mod, svdup_n_s64(0)))) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_limit = svdup_n_s64(limit);\n    svint64_t vec_i = svdup_n_s64(3);\n    svint64_t vec_step = svdup_n_s64(2);\n    \n    while (svptest_any(svptrue_b64(), svcmplt_s64(vec_i, vec_limit))) {\n        svint64_t vec_div = svdiv_s64(vec_n, vec_i);\n        svint64_t vec_rem = svrem_s64(vec_n, vec_i);\n        svbool_t mask = svcmpeq_s64(vec_rem, svdup_n_s64(0));\n\n        if (svptest_any(mask)) {\n            return false;\n        }\n\n        vec_i = svadd_s64(vec_i, vec_step);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    svint64_t vec_limit = svdup_n_s64(limit);\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = 3; i <= limit; i += 2) {\n        svint64_t vec_i = svdup_n_s64(i);\n        svbool_t cmp = svcmpeq_s64(pg, vec_n, svdup_n_s64(0));\n        if (svptest_any(pg, cmp)) return false;\n\n        svint64_t vec_mod = svrem_s64(vec_n, vec_i);\n        pg = svcmpeq_s64(pg, vec_mod, svdup_n_s64(0));\n        if (svptest_any(pg, cmp)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    svint64_t vec_limit = svdup_n_s64(limit);\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pg = svptrue_b64();\n    \n    for (int64_t i = 3; i <= limit; i += 2) {\n        svint64_t vec_i = svdup_n_s64(i);\n        svint64_t vec_div = svdiv_s64_m(pg, vec_n, vec_i);\n        svint64_t vec_rem = svsub_s64_m(pg, vec_n, svmul_s64_m(pg, vec_div, vec_i));\n        \n        if (svptest_any(pg, svcmpeq_s64_m(pg, vec_rem, svdup_n_s64(0)))) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    int64_t limit = (int64_t)sqrt(n);\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_limit = svdup_n_s64(limit);\n    svint64_t vec_i = svdup_n_s64(3);\n    svint64_t vec_step = svdup_n_s64(2);\n    \n    while (svfirst_s64(svcmplt_s64(vec_i, vec_limit))) {\n        svint64_t vec_div = svdiv_s64(vec_n, vec_i);\n        svint64_t vec_rem = svrem_s64(vec_n, vec_i);\n        svbool_t mask = svcmpeq_s64(vec_rem, svdup_n_s64(0));\n\n        if (svptest_any(mask)) {\n            return false;\n        }\n\n        vec_i = svadd_s64(vec_i, vec_step);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n    \n    svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data());\n    \n    svuint8_t lower_mask = svdup_u8('a');\n    svuint8_t upper_mask = svdup_u8('A');\n    svuint8_t diff_mask = svdup_u8('a' - 'A');\n    \n    svuint8_t is_lower = svcmpeq_u8(svsub_u8(chars, lower_mask), svdup_u8(0));\n    svuint8_t is_upper = svcmpeq_u8(svsub_u8(chars, upper_mask), svdup_u8(0));\n    \n    svuint8_t toggled_case = svorr_u8(svand_u8(is_lower, svsub_u8(chars, diff_mask)),\n                                       svand_u8(is_upper, svadd_u8(chars, diff_mask)));\n    \n    svuint8_t result_chars = svorr_u8(svand_u8(pg, chars), svandnot_u8(pg, toggled_case));\n    \n    svst1_u8(pg, (uint8_t*)result.data(), result_chars);\n    \n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n    \n    svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data());\n    svuint8_t lower_mask = svdup_u8(0x20);\n    svuint8_t is_lower = svand_u8(chars, svdup_u8(0x20));\n    svuint8_t is_upper = svand_u8(chars, svdup_u8(0xDF));\n    \n    svuint8_t toggled = svorr_u8(svand_u8(chars, svdup_u8(~0x20)), svand_u8(is_lower, svdup_u8(0xDF)));\n    \n    svbool_t is_alpha = svorr_b8(sveq_u8(chars, svdup_u8('a')), sveq_u8(chars, svdup_u8('z')));\n    is_alpha = svorr_b8(is_alpha, sveq_u8(chars, svdup_u8('A')));\n    is_alpha = svorr_b8(is_alpha, sveq_u8(chars, svdup_u8('Z')));\n    \n    svuint8_t result_chars = svsel_u8(is_alpha, toggled, chars);\n    \n    svst1_u8(pg, (uint8_t*)result.data(), result_chars);\n    \n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n\n    svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data());\n    svuint8_t lower_mask = svdup_u8(0x20);\n    svuint8_t upper_mask = svdup_u8(0xDF);\n    svuint8_t is_alpha = svorr_u8(svand_u8(svcmple_u8(chars, svdup_u8('z')), svcmple_u8(chars, svdup_u8('a'))),\n                                  svorr_u8(svand_u8(svcmple_u8(chars, svdup_u8('Z')), svcmple_u8(chars, svdup_u8('A'))));\n\n    svuint8_t toggled = svorr_u8(svand_u8(chars, svnot_u8(is_alpha)), svand_u8(svnot_u8(is_alpha), chars));\n\n    svst1_u8(pg, (uint8_t*)result.data(), svorr_u8(svand_u8(toggled, lower_mask), svand_u8(svand_u8(toggled, upper_mask), svnot_u8(is_alpha))));\n\n    if (svptest_any(pg, is_alpha) == 0) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n    \n    svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.c_str());\n    svuint8_t lower_mask = svdup_u8(0x20);\n    svuint8_t upper_mask = svdup_u8(0xDF);\n    \n    svuint8_t is_lower = svand_u8(chars, svdup_u8(0x20));\n    svuint8_t is_upper = svand_u8(chars, svdup_u8(0xDF));\n    \n    svuint8_t toggled = svorr_u8(svand_u8(chars, svnot_u8(is_lower)), svand_u8(is_upper, lower_mask));\n    \n    svbool_t is_alpha = svorr_b8(sveq_u8(chars, svdup_u8('a')), sveq_u8(chars, svdup_u8('z')));\n    is_alpha = svorr_b8(is_alpha, sveq_u8(chars, svdup_u8('A')));\n    is_alpha = svorr_b8(is_alpha, sveq_u8(chars, svdup_u8('Z')));\n    \n    svuint8_t result_chars = svsel_u8(is_alpha, toggled, chars);\n    \n    svst1_u8(pg, (uint8_t*)result.data(), result_chars);\n    \n    if (svptest_any(pg, is_alpha)) {\n        return result;\n    } else {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n    \n    svuint8_t chars = svld1_u8(pg, (const uint8_t*)s.data());\n    \n    svuint8_t lower_mask = svdup_u8(0x20);\n    svuint8_t upper_mask = svdup_u8(0xDF);\n    \n    svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n    svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n    \n    svuint8_t toggled_case = svorr_u8(\n        svand_u8(chars, svnot_u8(is_lower)),\n        svand_u8(svorr_u8(is_lower, is_upper), lower_mask)\n    );\n\n    svbool_t is_letter = svorr_b8(is_lower, is_upper);\n    svuint8_t final_chars = svsel(is_letter, toggled_case, chars);\n    \n    svst1_u8(pg, (uint8_t*)result.data(), final_chars);\n    \n    if (std::all_of(s.begin(), s.end(), [](char c) { return !std::isalpha(c); })) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Create a temporary vector to hold the values at indices divisible by 3\n    std::vector<int> temp;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) temp.push_back(l[i]);\n    }\n\n    // Sort the temporary vector\n    std::sort(temp.begin(), temp.end());\n\n    // Load the sorted values back into the result vector\n    size_t temp_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = temp[temp_index++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Create a temporary vector to hold the values at indices divisible by 3\n    std::vector<int> temp;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) temp.push_back(l[i]);\n    }\n\n    // Sort the temporary vector\n    std::sort(temp.begin(), temp.end());\n\n    // Load the sorted values back into the result vector at the appropriate indices\n    svint32_t sorted_values = svld1_s32(temp.data());\n    for (size_t i = 0, j = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = svindex(sorted_values, j);\n            j++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Create a vector to hold the values at indices divisible by 3\n    std::vector<int> temp;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) temp.push_back(l[i]);\n    }\n\n    // Sort the temporary vector\n    std::sort(temp.begin(), temp.end());\n\n    // Load the sorted values back into the result vector at the appropriate indices\n    svint32_t indices = svdup_n_s32(0);\n    size_t temp_index = 0;\n\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (temp_index < temp.size()) {\n                result[i] = temp[temp_index++];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Create a temporary vector for elements at indices divisible by 3\n    std::vector<int> temp;\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) temp.push_back(l[i]);\n    }\n\n    // Sort the temporary vector\n    std::sort(temp.begin(), temp.end());\n\n    // Load sorted values back into the result vector at the correct positions\n    svint32_t sorted_values = svld1_s32(svptrue_b32(), temp.data());\n    for (size_t i = 0, j = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = svget1_s32(sorted_values, j++);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Create a mask for indices that are divisible by 3\n    svbool_t mask = svwhilelt_b32(0, n);\n    svint32_t indices = svindex(0, n);\n    svbool_t div3_mask = svreinterpret_b32(svcmpeq_n_u32(svdup_n_u32(0), svdiv_n_u32(indices, 3)));\n\n    // Collect values at indices divisible by 3\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            to_sort.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected values\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Place sorted values back into the result vector\n    size_t sort_index = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            result[i] = to_sort[sort_index++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n\n    svfloat32_t max_vec = svdup_f32(max_val);\n    size_t i = 0;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svfloat32_t data_vec = svld1_f32(&l[i]);\n        max_vec = svmax_f32(max_vec, data_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    // Reduce the max vector to find the maximum value\n    float result[svcntw()];\n    svst1_f32(result, max_vec);\n    for (size_t j = 0; j < svcntw(); ++j) {\n        max_val = std::max(max_val, result[j]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n\n    svfloat32_t max_vec = svdup_f32(max_val);\n    size_t i = 0;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        max_vec = svmax_f32(svptrue_b32(), max_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    // Reduce the max vector to find the maximum value\n    max_val = std::max(max_val, svmaxv_f32(max_vec, svptrue_b32()));\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = -std::numeric_limits<float>::infinity();\n    \n    svfloat32_t max_vec = svdup_f32(max_val);\n    \n    size_t i = 0;\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        max_vec = svmax_f32(svptrue_b32(), max_vec, vec);\n    }\n    \n    // Horizontal reduction to find the maximum value\n    float max_array[svcntw()];\n    svst1_f32(svptrue_b32(), max_array, max_vec);\n    \n    for (size_t j = 0; j < svcntw(); ++j) {\n        max_val = std::max(max_val, max_array[j]);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n\n    svfloat32_t max_vec = svdup_f32(max_val);\n    size_t i = 0;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(&l[i]);\n        max_vec = svmax_f32(max_vec, vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    // Reduce the max vector to find the maximum value\n    max_val = std::max(max_val, svmaxv_f32(max_vec));\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = -std::numeric_limits<float>::infinity();\n    \n    svfloat32_t max_vec = svdup_f32(max_val);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t len = std::min(svcntw(), n - i);\n        svfloat32_t vec = svld1_f32(svwhilelt_b32(i, n), &l[i]);\n        max_vec = svmax_f32(max_vec, vec);\n    }\n    \n    max_val = svmaxv_f32(max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = svcntb(); // Get the number of bytes in a vector\n    svuint8_t mask = svdup_u8(0); // Initialize mask for counting\n\n    for (int i = 0; i < n; i += vector_size) {\n        svuint8_t indices = svindex_u8(i, vector_size); // Create indices\n        svuint8_t divisible = svorr_u8(svdiv_u8(indices, svdup_u8(11)), svdiv_u8(indices, svdup_u8(13))); // Check divisibility by 11 or 13\n        svuint8_t digit_count = svdup_u8(0);\n\n        // Count occurrences of digit '7'\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        digit_count = svadd_u8(digit_count, svdup_u8(1));\n                    }\n                    num /= 10;\n                }\n            }\n        }\n\n        // Accumulate counts\n        mask = svadd_u8(mask, digit_count);\n    }\n\n    // Sum the counts in the mask\n    for (int j = 0; j < vector_size; j++) {\n        count += svget_u8(mask, j);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = svcntb(); // Get the number of bytes in a vector\n    svuint8_t mask = svdup_u8(0); // Initialize mask for counting occurrences\n\n    for (int i = 0; i < n; i += vector_size) {\n        svuint8_t vec = svld1_u8(svindex_u8(i, vector_size)); // Load integers into vector\n        svbool_t divisible_by_11 = svcmpeq_u8(svrem_u8(vec, svdup_u8(11)), svdup_u8(0));\n        svbool_t divisible_by_13 = svcmpeq_u8(svrem_u8(vec, svdup_u8(13)), svdup_u8(0));\n        svbool_t is_divisible = svorr_b8(divisible_by_11, divisible_by_13);\n\n        svuint8_t digit_count = svdup_u8(0);\n        for (int j = 0; j < vector_size; j++) {\n            if (i + j < n) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        digit_count = svadd_u8(digit_count, svdup_u8(1));\n                    }\n                    num /= 10;\n                }\n            }\n        }\n\n        mask = svorr_b8(mask, svand_b8(is_divisible, svcmpeq_u8(digit_count, svdup_u8(1))));\n    }\n\n    count += svaddv_u8(svadd_u8(mask, svdup_u8(0)));\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = svcntb(); // Get the number of bytes in a vector\n    int num_vectors = (n + vector_size - 1) / vector_size; // Calculate number of vectors needed\n\n    svuint8_t mask_11 = svdup_u8(0);\n    svuint8_t mask_13 = svdup_u8(0);\n    svuint8_t mask_7 = svdup_u8(0);\n    \n    for (int i = 0; i < num_vectors; i++) {\n        svuint8_t indices = svindex_u8(i * vector_size, vector_size);\n        svuint8_t values = svadd_u8(indices, svdup_u8(1)); // Start from 1 to n\n\n        mask_11 = svorr_u8(mask_11, svcmpeq_u8(svrem_u8(values, svdup_u8(11)), svdup_u8(0)));\n        mask_13 = svorr_u8(mask_13, svcmpeq_u8(svrem_u8(values, svdup_u8(13)), svdup_u8(0)));\n        \n        svuint8_t combined_mask = svorr_u8(mask_11, mask_13);\n        \n        svuint8_t digit_count = svdup_u8(0);\n        svuint8_t digit_seven = svdup_u8(7);\n        \n        for (int j = 0; j < vector_size; j++) {\n            if (i * vector_size + j < n) {\n                int current_value = i * vector_size + j + 1;\n                while (current_value > 0) {\n                    if (current_value % 10 == 7) {\n                        digit_count = svadd_u8(digit_count, svdup_u8(1));\n                    }\n                    current_value /= 10;\n                }\n            }\n        }\n        \n        count += svaddv_u8(svand_u8(combined_mask, digit_count));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = svcntb(); // Get the size of the vector in bytes\n    int num_vectors = (n + vector_size - 1) / vector_size; // Number of vectors needed\n    svuint8_t digit_count = svdup_u8(0); // Vector to hold counts of digit '7'\n\n    for (int i = 0; i < num_vectors; i++) {\n        svuint8_t indices = svindex_u8(i * vector_size, vector_size); // Create indices for the current vector\n        svuint8_t values = svadd_u8(indices, svdup_u8(1)); // Generate values from 1 to vector_size\n\n        // Check divisibility by 11 or 13\n        svbool_t mask_11 = svreinterpret_b8(svdup_u8(11));\n        svbool_t mask_13 = svreinterpret_b8(svdup_u8(13));\n        svbool_t divisible = svorr_b8(svcmpeq_u8(svrem_u8(values, svdup_u8(11)), svdup_u8(0)),\n                                       svcmpeq_u8(svrem_u8(values, svdup_u8(13)), svdup_u8(0)));\n\n        // Count occurrences of digit '7'\n        svbool_t mask_seven = svcmpeq_u8(values, svdup_u8(7));\n        digit_count = svadd_u8(digit_count, svand_u8(mask_seven, divisible));\n\n        // Break if we exceed n\n        if (svlastb(mask_11) >= n) break;\n    }\n\n    // Sum the counts in the vector\n    for (int j = 0; j < vector_size; j++) {\n        count += svget_u8(digit_count, j);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int vector_size = svcntb(); // Get the number of bytes in a vector\n    int num_vectors = (n + vector_size - 1) / vector_size; // Calculate number of vectors needed\n\n    svuint8_t mask = svdup_u8(0);\n    svuint8_t digit_seven = svdup_u8(7);\n    svuint8_t divisor_11 = svdup_u8(11);\n    svuint8_t divisor_13 = svdup_u8(13);\n    \n    for (int i = 0; i < num_vectors; i++) {\n        svuint8_t indices = svdup_u8(i * vector_size);\n        svuint8_t values = svadd_u8(indices, svdup_u8(1)); // Start from 1 to n\n\n        svuint8_t divisible_by_11 = svmod_u8(values, divisor_11);\n        svuint8_t divisible_by_13 = svmod_u8(values, divisor_13);\n        \n        svuint8_t is_divisible = svorr_u8(svcmpeq_u8(divisible_by_11, svdup_u8(0)), \n                                           svcmpeq_u8(divisible_by_13, svdup_u8(0)));\n\n        svuint8_t count_sevens = svdup_u8(0);\n        for (int j = 0; j < vector_size; j++) {\n            if (i * vector_size + j < n) {\n                if (values[j] == 7) {\n                    count_sevens = svadd_u8(count_sevens, svdup_u8(1));\n                }\n            }\n        }\n\n        count += svaddv_u8(count_sevens);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Create a mask for even indices\n    svbool_t mask = svwhilelt_b32(0, n);\n    \n    // Extract even indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        if (i < n) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    \n    // Sort the even indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n    \n    // Fill the result vector\n    for (size_t i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = even_elements[i / 2];\n        } else {\n            result[i] = l[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t num_vectors = n / 2;\n    std::vector<float> result(n);\n    \n    // Load the vector\n    svfloat32_t vec = svld1_u32(svptrue_b32(), l.data());\n\n    // Extract even indices\n    svfloat32_t even_indices = svuzp1_f32(vec, svdup_f32(0));\n    \n    // Sort the even indices\n    std::vector<float> even_values(num_vectors);\n    svst1_u32(svptrue_b32(), even_values.data(), even_indices);\n    std::sort(even_values.begin(), even_values.end());\n\n    // Store sorted even values back to result\n    for (size_t i = 0; i < num_vectors; ++i) {\n        result[i * 2] = even_values[i];\n    }\n\n    // Copy odd indices from original vector\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 != 0) {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t vec_len = svcntf32(); // Number of float elements in a vector\n    size_t num_vectors = (n + vec_len - 1) / vec_len;\n\n    std::vector<float> result(n);\n    \n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vec_len;\n        size_t end = std::min(start + vec_len, n);\n\n        svfloat32_t vec = svld1_f32(svwhilelt_b32(0, end - start), &l[start]);\n\n        // Extract even indices\n        svfloat32_t even_indices = svdup_f32(0);\n        for (size_t j = 0; j < end - start; j += 2) {\n            if (j < end - start) {\n                even_indices = svsetq_f32(even_indices, j / 2, svld1_f32(svwhilelt_b32(0, end - start), &l[start + j]));\n            }\n        }\n\n        // Sort even indices\n        std::vector<float> even_values;\n        for (size_t j = 0; j < end - start; j += 2) {\n            if (j < end - start) {\n                even_values.push_back(l[start + j]);\n            }\n        }\n        std::sort(even_values.begin(), even_values.end());\n\n        // Place sorted even values back\n        for (size_t j = 0; j < even_values.size(); ++j) {\n            if (2 * j < end - start) {\n                result[start + 2 * j] = even_values[j];\n            }\n        }\n\n        // Copy odd indices\n        for (size_t j = 1; j < end - start; j += 2) {\n            result[start + j] = l[start + j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t vec_len = svcntf32();\n    std::vector<float> result(n);\n    \n    // Sort even indices\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n\n    // Fill the result vector\n    for (size_t i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = even_values[i / 2];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t vec_len = svcntf32();\n    std::vector<float> result(n);\n    \n    // Process in chunks of vector length\n    for (size_t i = 0; i < n; i += vec_len) {\n        svfloat32_t vec = svld1_f32(&l[i]);\n        svfloat32_t odd_mask = svdup_f32(0.0f);\n        \n        // Create a mask for odd indices\n        for (size_t j = 0; j < vec_len; j++) {\n            if ((i + j) % 2 != 0) {\n                odd_mask = svsetq_f32(odd_mask, j, svget_f32(vec, j));\n            }\n        }\n\n        // Extract even indices\n        svfloat32_t even_vals = svdup_f32(0.0f);\n        for (size_t j = 0; j < vec_len; j += 2) {\n            if (i + j < n) {\n                even_vals = svsetq_f32(even_vals, j / 2, svget_f32(vec, j));\n            }\n        }\n\n        // Sort even values\n        std::vector<float> even_array(vec_len / 2);\n        for (size_t j = 0; j < vec_len; j += 2) {\n            if (i + j < n) {\n                even_array[j / 2] = svget_f32(even_vals, j / 2);\n            }\n        }\n        std::sort(even_array.begin(), even_array.end());\n\n        // Place sorted even values back into the result\n        for (size_t j = 0; j < vec_len; j++) {\n            if ((i + j) % 2 == 0) {\n                if (j / 2 < even_array.size()) {\n                    result[i + j] = even_array[j / 2];\n                }\n            } else {\n                result[i + j] = svget_f32(odd_mask, j);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.count(target) && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.count(target) && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.count(target) && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < n; ++i) {\n        seen.insert(l[i]);\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int target = -(l[i] + l[j]);\n            if (seen.find(target) != seen.end() && target != l[i] && target != l[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n    \n    size_t vector_length = n / svcntw();\n    size_t remainder = n % svcntw();\n    \n    for (size_t i = 0; i < vector_length; ++i) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + i, vec);\n    }\n    \n    if (remainder > 0) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + vector_length);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + vector_length, vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n    \n    size_t vector_length = svcntw(); // Number of 32-bit integers in a vector\n    size_t i = 0;\n\n    for (; i <= n - vector_length; i += vector_length) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + i, vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n    \n    size_t vector_length = n / svcntw();\n    size_t remainder = n % svcntw();\n\n    for (size_t i = 0; i < vector_length; ++i) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + i, vec);\n    }\n\n    if (remainder > 0) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + vector_length);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + vector_length, vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n    \n    size_t vector_length = n / svcntw();\n    size_t remainder = n % svcntw();\n    \n    for (size_t i = 0; i < vector_length; ++i) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + i, vec);\n    }\n    \n    if (remainder > 0) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + vector_length);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + vector_length, vec);\n        \n        for (size_t j = 0; j < remainder; ++j) {\n            result[vector_length * svcntw() + j] = l[vector_length * svcntw() + j] + 1;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n    \n    size_t vector_length = n / svcntw();\n    size_t remainder = n % svcntw();\n    \n    for (size_t i = 0; i < vector_length; ++i) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + i);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + i, vec);\n    }\n    \n    if (remainder > 0) {\n        svint32_t vec = svld1(svptrue_b32(), input_ptr + vector_length);\n        vec = svadd_n_s32(vec, 1);\n        svst1(svptrue_b32(), output_ptr + vector_length, vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec;\n    svbool_t pg;\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec = svld1(pg, &l[i]);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (i + j < n) {\n                int current = l[i + j];\n                if (seen.count(-current)) {\n                    return true;\n                }\n                seen.insert(current);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec;\n    svbool_t pg;\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec = svld1(pg, &l[i]);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (i + j < n) {\n                int val = l[i + j];\n                if (seen.count(-val)) {\n                    return true;\n                }\n                seen.insert(val);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec = svld1_s32(svptrue_b32(), l.data());\n    svbool_t pg = svptrue_b32();\n\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t current = svld1_s32(pg, l.data() + i);\n        for (int j = 0; j < svcntw(); ++j) {\n            if (i + j < n) {\n                int val = svget1_s32(svindex_s32(current, j));\n                if (seen.count(-val)) {\n                    return true;\n                }\n                seen.insert(val);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec;\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t count = remaining < svcntw() ? remaining : svcntw();\n        \n        vec = svld1(svptrue_b32(), &l[i]);\n        \n        for (size_t j = 0; j < count; ++j) {\n            int value = svindex(vec, j);\n            if (seen.count(-value)) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec = svld1_s32(svptrue_b32(), l.data());\n    svbool_t pg = svptrue_b32();\n\n    std::unordered_set<int> seen;\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svint32_t current_vec = svld1_s32(pg, l.data() + i);\n        for (int j = 0; j < svcntb(); ++j) {\n            int value = svget1_s32(current_vec, j);\n            if (seen.count(-value)) {\n                return true;\n            }\n            seen.insert(value);\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t num = x;\n\n    while (num > 0) {\n        svint64_t vec_num = svdup_n_s64(num);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_remainder = svrem_s64(vec_num, vec_base);\n        svint64_t vec_quotient = svdiv_s64(vec_num, vec_base);\n\n        for (int i = 0; i < svcntd(); i++) {\n            int64_t remainder = svget_s64(vec_remainder, i);\n            if (remainder < 0) break;\n            result.push_back(static_cast<char>(remainder + '0'));\n            num = svget_s64(vec_quotient, i);\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t num = x;\n\n    while (num > 0) {\n        // Use SVE to process multiple digits in parallel\n        svint64_t vec_num = svdup_s64(num);\n        svint64_t vec_base = svdup_s64(base);\n        svint64_t vec_rem = svrem_s64(vec_num, vec_base);\n        svint64_t vec_quot = svdiv_s64(vec_num, vec_base);\n\n        // Store the remainders\n        for (int i = 0; i < svcntd(); i++) {\n            int64_t remainder = svget_s64(vec_rem, i);\n            if (remainder < 10) {\n                result.push_back('0' + remainder);\n            }\n            num = svget_s64(vec_quot, i);\n        }\n\n        if (num == 0) break;\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t num = x;\n\n    while (num > 0) {\n        svint64_t vec_num = svdup_n_s64(num);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_remainder = svrem_s64(vec_num, vec_base);\n        svint64_t vec_quotient = svdiv_s64(vec_num, vec_base);\n\n        for (int i = 0; i < svcntd(); i++) {\n            int64_t remainder = svget_s64(vec_remainder, i);\n            if (remainder < 10) {\n                result.push_back('0' + remainder);\n            }\n            num = svget_s64(vec_quotient, i);\n            if (num == 0) break;\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    int64_t num = x;\n    int64_t index = 0;\n\n    while (num > 0) {\n        svint64_t vec_num = svdup_n_s64(num);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_rem = svrem_s64(vec_num, vec_base);\n        svint64_t vec_quot = svdiv_s64(vec_num, vec_base);\n\n        for (int i = 0; i < svcntd(); i++) {\n            if (index < 64 && svget_s64(vec_rem, i) >= 0) {\n                result.push_back('0' + svget_s64(vec_rem, i));\n                num = svget_s64(vec_quot, i);\n                index++;\n            }\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::vector<char> result;\n    if (x == 0) return \"0\";\n\n    while (x > 0) {\n        svint64_t vec_x = svdup_n_s64(x);\n        svint64_t vec_base = svdup_n_s64(base);\n        svint64_t vec_remainder = svrem_s64(vec_x, vec_base);\n        svint64_t vec_quotient = svdiv_s64(vec_x, vec_base);\n\n        // Store the remainders\n        for (int i = 0; i < svcntd(); i++) {\n            int64_t remainder = svget1_s64(svindex(vec_remainder, i));\n            if (remainder < 10) {\n                result.push_back('0' + remainder);\n            }\n        }\n\n        x = svget1_s64(svindex(vec_quotient, 0));\n    }\n\n    std::reverse(result.begin(), result.end());\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    size_t half_len = len / 2;\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svuint8_t left = svld1_u8(pg, (const uint8_t*)(text.c_str() + i));\n        svuint8_t right = svld1_u8(pg, (const uint8_t*)(text.c_str() + len - 1 - i));\n        \n        svuint8_t cmp = svcmpeq_u8(left, right);\n        if (svptest_any(pg, cmp) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    // Handle odd/even length\n    size_t half_len = len / 2;\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svuint8_t left = svld1_u8(pg, (const uint8_t*)text.data() + i);\n        svuint8_t right = svld1_u8(pg, (const uint8_t*)text.data() + (len - 1 - i));\n\n        // Compare left and right\n        svbool_t cmp = svcmpeq_u8(left, right);\n        if (svptest_any(pg, cmp) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t half_len = len / 2;\n\n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svuint8_t left = svld1_u8(pg, (const uint8_t*)text.c_str() + i);\n        svuint8_t right = svld1_u8(pg, (const uint8_t*)text.c_str() + (len - 1 - i));\n\n        svbool_t cmp = svcmpeq_u8(left, right);\n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t half_len = len / 2;\n\n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svuint8_t idx = svadd_u8(svdup_u8(i), svindex_u8(0, svcntb()));\n        svuint8_t rev_idx = svsub_u8(svdup_u8(len - 1 - i), svindex_u8(0, svcntb()));\n\n        svuint8_t text_chars = svld1_u8(pg, (const uint8_t*)text.c_str() + i);\n        svuint8_t text_rev_chars = svld1_u8(pg, (const uint8_t*)text.c_str() + (len - 1 - i));\n\n        svbool_t mismatch = svcmpeq_u8(pg, text_chars, text_rev_chars);\n        if (!svptest_any(pg, mismatch)) {\n            return false;\n        }\n        pg = svwhilelt_b8(i + svcntb(), half_len);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t half_len = len / 2;\n\n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        svuint8_t idx = svadd_u8(svdup_u8(i), svindex_u8(0, svcntb()));\n        svuint8_t rev_idx = svsub_u8(svdup_u8(len - 1 - i), svindex_u8(0, svcntb()));\n\n        svuint8_t text_chars = svld1_u8(pg, (const uint8_t*)text.c_str() + i);\n        svuint8_t text_rev_chars = svld1_u8(pg, (const uint8_t*)text.c_str() + (len - 1 - i));\n\n        svbool_t cmp_pg = svcmpeq_u8(pg, text_chars, text_rev_chars);\n        if (!svptest_any(pg, cmp_pg)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svuint8_t decoded = svsub_u8(input, svdup_u8(5));\n        svuint8_t wrapped = svadd_u8(decoded, svdup_u8(26));\n        svuint8_t result = svand_u8(wrapped, svdup_u8(0x1F)); // Wrap around for lowercase letters\n        svst1_u8(pg, (uint8_t*)&out[i], result);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    svuint8_t shift = svdup_u8(5);\n    svuint8_t a = svdup_u8('a');\n    svuint8_t z = svdup_u8('z');\n    \n    size_t i = 0;\n    for (; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8((const uint8_t*)&s[i]);\n        svuint8_t decoded = svsub_u8(input, shift);\n        svuint8_t wrapped = svadd_u8(decoded, svsub_u8(a, svand_u8(svlt_u8(decoded, a), svdup_u8(26))));\n        svst1_u8((uint8_t*)&out[i], wrapped);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    svuint8_t shift = svdup_u8(21); // 26 - 5 = 21 for decoding\n    size_t i = 0;\n\n    for (; i <= len - svcntb(); i += svcntb()) {\n        svuint8_t chars = svld1_u8((const uint8_t*)&s[i]);\n        svuint8_t decoded = svadd_u8(chars, shift);\n        svst1_u8((uint8_t*)&out[i], decoded);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        out[i] = (s[i] - 'a' + 21) % 26 + 'a';\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    for (; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svuint8_t decoded = svsub_u8(input, svdup_u8(5));\n        svuint8_t wrapped = svadd_u8(decoded, svdup_u8(26));\n        svuint8_t result = svand_u8(wrapped, svdup_u8(0x1F)); // Wrap around for lowercase letters\n        svst1_u8(pg, (uint8_t*)&out[i], result);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    for (; i <= len - svcntb8(); i += svcntb8()) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&s[i]);\n        vec = svsub_u8(vec, svdup_u8(5)); // Shift back by 5\n        vec = svadd_u8(vec, svdup_u8('a')); // Adjust to 'a'\n        svst1_u8(pg, (uint8_t*)&out[i], vec);\n    }\n\n    // Handle remaining characters\n    for (; i < len; i++) {\n        out[i] = (s[i] - 5 + 'a');\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, l.data());\n    svint32_t threshold = svdup_n_s32(t);\n    svbool_t cmp = svcmplt(pg, vec, threshold);\n    return svptest_any(pg, cmp);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, l.data());\n    svint32_t threshold = svdup_n_s32(t);\n    svbool_t result_pg = svcmplt(pg, vec, threshold);\n    \n    return svptest_any(pg, result_pg);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_n_s32(t);\n    svint32_t result = svdup_n_s32(1); // Assume all are below threshold initially\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svmin_u32(n - i, svcntw());\n        svint32_t vec = svld1(pg, &l[i]);\n        svbool_t below = svcmplt(pg, vec, threshold);\n        result = svand_s32(result, below);\n    }\n\n    return svptest_any(pg, result);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, l.data());\n    svint32_t threshold = svdup_n_s32(t);\n    svbool_t cmp = svlt(pg, vec, threshold);\n    return svptest_any(pg, cmp);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, l.data());\n    svint32_t threshold = svdup_n_s32(t);\n    svbool_t cmp = svcmplt(pg, vec, threshold);\n    return svptest_any(pg, cmp);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < length; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(balance, svreinterpret_s32(svcmpeq_u8(chars, svdup_u8('<'))));\n        svint32_t close = svsub_s32(balance, svreinterpret_s32(svcmpeq_u8(chars, svdup_u8('>'))));\n        balance = svadd_s32(open, close);\n        \n        pg = svwhilelt_b8(i + svcntb(), length);\n    }\n\n    return svptest_any(pg, svcmpeq_s32(balance, svdup_s32(0))) && svptest_any(pg, svcmplt_s32(balance, svdup_s32(0))) == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t open_count = svdup_s32(0);\n    svint32_t close_count = svdup_s32(0);\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svbool_t mask_open = svcmpeq_u8(data, svdup_u8('<'));\n        svbool_t mask_close = svcmpeq_u8(data, svdup_u8('>'));\n\n        open_count = svadd_s32(open_count, svreinterpret_s32(svadd_u8(mask_open, svdup_u8(0))));\n        close_count = svadd_s32(close_count, svreinterpret_s32(svadd_u8(mask_close, svdup_u8(0))));\n    }\n\n    int total_open = svaddv_s32(svadd_s32(open_count, close_count));\n    return total_open >= 0 && svaddv_s32(open_count) == svaddv_s32(close_count);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(balance, svcntb());\n        svint32_t close = svsub_s32(balance, svcntb());\n\n        balance = svadd_s32(balance, svadd_s32(svcmpeq_u8(chars, svdup_u8('<')), svdup_s32(1)));\n        balance = svsub_s32(balance, svadd_s32(svcmpeq_u8(chars, svdup_u8('>')), svdup_s32(1)));\n    }\n\n    return svptest_any(pg, svcmpeq_s32(balance, svdup_s32(0))) && svptest_any(pg, svcmplt_s32(balance, svdup_s32(0))) == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t open_count = svdup_s32(0);\n    svint32_t close_count = svdup_s32(0);\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svbool_t mask_open = svcmpeq_u8(pg, chars, svdup_u8('<'));\n        svbool_t mask_close = svcmpeq_u8(pg, chars, svdup_u8('>'));\n\n        open_count = svadd_s32(open_count, svreinterpret_s32(svdup_u8(svcntb() * svptest_any(mask_open))));\n        close_count = svadd_s32(close_count, svreinterpret_s32(svdup_u8(svcntb() * svptest_any(mask_close))));\n    }\n\n    int total_open = svaddv_s32(svadd_s32(open_count, close_count));\n    return total_open >= 0 && svaddv_s32(open_count) == svaddv_s32(close_count);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(balance, svcmpeq_u8(chars, svdup_u8('<')));\n        svint32_t close = svsub_s32(balance, svcmpeq_u8(chars, svdup_u8('>')));\n        balance = svadd_s32(open, close);\n    }\n\n    return svptest_any(pg, svcmpeq_s32(balance, svdup_s32(0))) && (len % 2 == 0);\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(svcmpeq_u8(chars, svdup_u8('(')), balance);\n        svint32_t close = svadd_s32(svcmpeq_u8(chars, svdup_u8(')')), balance);\n        balance = svsub_s32(open, close);\n    }\n\n    return svptest_any(pg, svcmpeq_s32(balance, svdup_s32(0))) && svptest_any(pg, svcmplt_s32(balance, svdup_s32(0))) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < length; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svsub_s32(svdup_s32(0), svcmpeq_u8(chars, svdup_u8('(')));\n        svint32_t close = svsub_s32(svdup_s32(0), svcmpeq_u8(chars, svdup_u8(')')));\n        \n        balance = svadd_s32(balance, open);\n        balance = svsub_s32(balance, close);\n        \n        if (svptest_any(pg, svlt_s32(balance, svdup_s32(0)))) {\n            return false;\n        }\n    }\n    \n    int final_balance = 0;\n    svint32_t final_balance_vec = balance;\n    for (int i = 0; i < svcntw(); i++) {\n        final_balance += svget4_s32(final_balance_vec, i);\n    }\n    \n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(balance, svcmpeq_u8(chars, svdup_u8('(')));\n        svint32_t close = svsub_s32(balance, svcmpeq_u8(chars, svdup_u8(')')));\n        balance = svadd_s32(open, close);\n    }\n\n    int32_t final_balance = svaddv_s32(pg, balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t balance = svdup_s32(0);\n    \n    for (int i = 0; i < length; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(brackets.c_str() + i));\n        svint32_t open = svadd_s32(svcmpeq_u8(chars, svdup_u8('(')), balance);\n        svint32_t close = svsub_s32(svcmpeq_u8(chars, svdup_u8(')')), balance);\n        balance = svadd_s32(open, close);\n        pg = svwhilelt_b32(i + svcntb(), length);\n    }\n    \n    return svptest_any(pg, svcmpeq_s32(balance, svdup_s32(0))) && svptest_any(pg, svcmplt_s32(balance, svdup_s32(0))) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    svbool_t pg = svptrue_b8();\n    svint32_t balance = svdup_n_s32(0);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&brackets[i]);\n        svint32_t open = svadd_s32(svdup_n_s32(0), svcmpeq_u8(chars, svdup_n_u8('(')));\n        svint32_t close = svadd_s32(svdup_n_s32(0), svcmpeq_u8(chars, svdup_n_u8(')')));\n        \n        balance = svadd_s32(balance, svsub_s32(open, close));\n        \n        if (svptest_any(pg, svlt_s32(balance, svdup_n_s32(0)))) {\n            return false;\n        }\n    }\n    \n    return svptest_any(pg, svcmpeq_s32(balance, svdup_n_s32(0)));\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    svfloat32_t coeffs = svld1_f32(&xs[0]);\n    svfloat32_t indices = svdup_f32(1.0f);\n    \n    for (size_t i = 1; i < n; ++i) {\n        svfloat32_t powers = svdup_f32(static_cast<float>(i));\n        svfloat32_t term = svmul_f32(svdup_f32(static_cast<float>(i)), svld1_f32(&xs[i]));\n        svst1_f32(&result[i - 1], term);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    svfloat32_t coeffs = svld1_f32(&xs[0]);\n    svfloat32_t indices = svdup_f32(1.0f);\n    \n    for (size_t i = 1; i < n; ++i) {\n        svfloat32_t coeff = svdup_f32(xs[i]);\n        svfloat32_t term = svmul_f32(coeff, svdup_f32(static_cast<float>(i)));\n        svst1_f32(&result[i - 1], term);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n\n    svfloat32_t coefficients = svld1_f32(&xs[0]);\n    svfloat32_t indices = svindex_f32(1, n - 1);\n    \n    for (size_t i = 1; i < n; i++) {\n        svfloat32_t term = svmul_f32(svdup_f32(static_cast<float>(i)), svld1_f32(&xs[i]));\n        svst1_f32(&result[i - 1], term);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    svfloat32_t coeffs = svld1_f32(&xs[0]);\n    svfloat32_t indices = svdup_f32(1.0f);\n    \n    for (size_t i = 1; i < n; ++i) {\n        svfloat32_t powers = svdup_f32(static_cast<float>(i));\n        svfloat32_t term = svmul_f32(svindex_f32(coeffs, i), powers);\n        svst1_f32(&result[i - 1], term);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n - 1);\n    \n    svfloat32_t coeffs = svld1_f32(&xs[0]);\n    svfloat32_t indices = svdup_f32(1.0f);\n    \n    for (size_t i = 1; i < n; ++i) {\n        svfloat32_t powers = svdup_f32(static_cast<float>(i));\n        svfloat32_t term = svmul_f32(svdup_f32(static_cast<float>(i)), svld1_f32(&xs[i]));\n        svst1_f32(&result[i - 1], term);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t mask_vowels = svcmpeq_u8(data, 'a') | svcmpeq_u8(data, 'e') | svcmpeq_u8(data, 'i') | svcmpeq_u8(data, 'o') | svcmpeq_u8(data, 'u') |\n                               svcmpeq_u8(data, 'A') | svcmpeq_u8(data, 'E') | svcmpeq_u8(data, 'I') | svcmpeq_u8(data, 'O') | svcmpeq_u8(data, 'U');\n\n        count += svcntb(svptrue_b8() & mask_vowels);\n\n        if (i + svcntb() >= len && s[len - 1] == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t mask = svcmpeq_u8(pg, data, 'a') | svcmpeq_u8(pg, data, 'e') |\n                        svcmpeq_u8(pg, data, 'i') | svcmpeq_u8(pg, data, 'o') |\n                        svcmpeq_u8(pg, data, 'u') | svcmpeq_u8(pg, data, 'A') |\n                        svcmpeq_u8(pg, data, 'E') | svcmpeq_u8(pg, data, 'I') |\n                        svcmpeq_u8(pg, data, 'O') | svcmpeq_u8(pg, data, 'U');\n        \n        count += svcntb(svptrue_b8()) - svpopc(mask);\n        \n        if (remaining < svcntb()) {\n            for (size_t j = remaining; j < svcntb(); j++) {\n                if (i + j < len && s[i + j] == 'y' || s[i + j] == 'Y') {\n                    if (i + j == len - 1) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)(s.c_str() + i));\n        \n        svbool_t is_vowel = svorr_b8(pg, \n            svcmpeq_u8(pg, data, svdup_u8('a')), \n            svcmpeq_u8(pg, data, svdup_u8('e')));\n        is_vowel = svorr_b8(pg, is_vowel, svcmpeq_u8(pg, data, svdup_u8('i')));\n        is_vowel = svorr_b8(pg, is_vowel, svcmpeq_u8(pg, data, svdup_u8('o')));\n        is_vowel = svorr_b8(pg, is_vowel, svcmpeq_u8(pg, data, svdup_u8('u')));\n        \n        if (i + svcntb() >= len && s[len - 1] == 'y') {\n            is_vowel = svorr_b8(pg, is_vowel, svcmpeq_u8(pg, data, svdup_u8('y')));\n        }\n\n        count += svcntb(svptrue_b8()) - svcntb(svnot_b8(pg, is_vowel));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)(s.c_str() + i));\n        svbool_t mask_vowels = svcmpeq_u8(pg, data, 'a');\n        mask_vowels = svorr(mask_vowels, mask_vowels, svcmpeq_u8(pg, data, 'e'));\n        mask_vowels = svorr(mask_vowels, mask_vowels, svcmpeq_u8(pg, data, 'i'));\n        mask_vowels = svorr(mask_vowels, mask_vowels, svcmpeq_u8(pg, data, 'o'));\n        mask_vowels = svorr(mask_vowels, mask_vowels, svcmpeq_u8(pg, data, 'u'));\n        \n        if (i + svcntb() >= len && s[len - 1] == 'y') {\n            mask_vowels = svorr(mask_vowels, mask_vowels, svcmpeq_u8(pg, data, 'y'));\n        }\n        \n        count += svcntb(svptrue_b8()) - svcntb(svnot(mask_vowels));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)(s.c_str() + i));\n        svbool_t mask_vowels = svcmpeq_u8(pg, data, 'a') | svcmpeq_u8(pg, data, 'e') |\n                               svcmpeq_u8(pg, data, 'i') | svcmpeq_u8(pg, data, 'o') |\n                               svcmpeq_u8(pg, data, 'u') | svcmpeq_u8(pg, data, 'A') |\n                               svcmpeq_u8(pg, data, 'E') | svcmpeq_u8(pg, data, 'I') |\n                               svcmpeq_u8(pg, data, 'O') | svcmpeq_u8(pg, data, 'U');\n        \n        count += svcntb(svptrue_b8() & mask_vowels);\n        \n        if (i + svcntb() >= len && s[len - 1] == 'y') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A')) | svcmpeq_u8(pg, chars, svdup_u8('B')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('C')) | svcmpeq_u8(pg, chars, svdup_u8('D')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('E')) | svcmpeq_u8(pg, chars, svdup_u8('F')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('G')) | svcmpeq_u8(pg, chars, svdup_u8('H')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('I')) | svcmpeq_u8(pg, chars, svdup_u8('J')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('K')) | svcmpeq_u8(pg, chars, svdup_u8('L')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('M')) | svcmpeq_u8(pg, chars, svdup_u8('N')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('O')) | svcmpeq_u8(pg, chars, svdup_u8('P')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Q')) | svcmpeq_u8(pg, chars, svdup_u8('R')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('S')) | svcmpeq_u8(pg, chars, svdup_u8('T')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('U')) | svcmpeq_u8(pg, chars, svdup_u8('V')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('W')) | svcmpeq_u8(pg, chars, svdup_u8('X')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Y')) | svcmpeq_u8(pg, chars, svdup_u8('Z'));\n        \n        svuint8_t upper_chars = svand_u8(pg, chars, upper_mask);\n        sum += svaddv_u8(svptrue_b8(), upper_chars);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(s.c_str() + i));\n        svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A')) | svcmpeq_u8(pg, chars, svdup_u8('B')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('C')) | svcmpeq_u8(pg, chars, svdup_u8('D')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('E')) | svcmpeq_u8(pg, chars, svdup_u8('F')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('G')) | svcmpeq_u8(pg, chars, svdup_u8('H')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('I')) | svcmpeq_u8(pg, chars, svdup_u8('J')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('K')) | svcmpeq_u8(pg, chars, svdup_u8('L')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('M')) | svcmpeq_u8(pg, chars, svdup_u8('N')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('O')) | svcmpeq_u8(pg, chars, svdup_u8('P')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Q')) | svcmpeq_u8(pg, chars, svdup_u8('R')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('S')) | svcmpeq_u8(pg, chars, svdup_u8('T')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('U')) | svcmpeq_u8(pg, chars, svdup_u8('V')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('W')) | svcmpeq_u8(pg, chars, svdup_u8('X')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Y')) | svcmpeq_u8(pg, chars, svdup_u8('Z'));\n\n        svuint8_t upper_chars = svand_u8(pg, chars, upper_mask);\n        sum += svaddv_u8(svptrue_b8(), upper_chars);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t upper_mask = svcmpeq_u8(chars, svdup_u8('A')) | svcmpeq_u8(chars, svdup_u8('B')) | \n                              svcmpeq_u8(chars, svdup_u8('C')) | svcmpeq_u8(chars, svdup_u8('D')) | \n                              svcmpeq_u8(chars, svdup_u8('E')) | svcmpeq_u8(chars, svdup_u8('F')) | \n                              svcmpeq_u8(chars, svdup_u8('G')) | svcmpeq_u8(chars, svdup_u8('H')) | \n                              svcmpeq_u8(chars, svdup_u8('I')) | svcmpeq_u8(chars, svdup_u8('J')) | \n                              svcmpeq_u8(chars, svdup_u8('K')) | svcmpeq_u8(chars, svdup_u8('L')) | \n                              svcmpeq_u8(chars, svdup_u8('M')) | svcmpeq_u8(chars, svdup_u8('N')) | \n                              svcmpeq_u8(chars, svdup_u8('O')) | svcmpeq_u8(chars, svdup_u8('P')) | \n                              svcmpeq_u8(chars, svdup_u8('Q')) | svcmpeq_u8(chars, svdup_u8('R')) | \n                              svcmpeq_u8(chars, svdup_u8('S')) | svcmpeq_u8(chars, svdup_u8('T')) | \n                              svcmpeq_u8(chars, svdup_u8('U')) | svcmpeq_u8(chars, svdup_u8('V')) | \n                              svcmpeq_u8(chars, svdup_u8('W')) | svcmpeq_u8(chars, svdup_u8('X')) | \n                              svcmpeq_u8(chars, svdup_u8('Y')) | svcmpeq_u8(chars, svdup_u8('Z'));\n\n        svuint8_t upper_chars = svand_u8(chars, upper_mask);\n        sum += svaddv_u8(svdup_u8(0), upper_chars);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A')) | svcmpeq_u8(pg, chars, svdup_u8('B')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('C')) | svcmpeq_u8(pg, chars, svdup_u8('D')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('E')) | svcmpeq_u8(pg, chars, svdup_u8('F')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('G')) | svcmpeq_u8(pg, chars, svdup_u8('H')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('I')) | svcmpeq_u8(pg, chars, svdup_u8('J')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('K')) | svcmpeq_u8(pg, chars, svdup_u8('L')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('M')) | svcmpeq_u8(pg, chars, svdup_u8('N')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('O')) | svcmpeq_u8(pg, chars, svdup_u8('P')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Q')) | svcmpeq_u8(pg, chars, svdup_u8('R')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('S')) | svcmpeq_u8(pg, chars, svdup_u8('T')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('U')) | svcmpeq_u8(pg, chars, svdup_u8('V')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('W')) | svcmpeq_u8(pg, chars, svdup_u8('X')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Y')) | svcmpeq_u8(pg, chars, svdup_u8('Z'));\n\n        svuint8_t upper_chars = svand_u8(pg, chars, upper_mask);\n        sum += svaddv_u8(svptrue_b8(), upper_chars);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A')) | svcmpeq_u8(pg, chars, svdup_u8('B')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('C')) | svcmpeq_u8(pg, chars, svdup_u8('D')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('E')) | svcmpeq_u8(pg, chars, svdup_u8('F')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('G')) | svcmpeq_u8(pg, chars, svdup_u8('H')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('I')) | svcmpeq_u8(pg, chars, svdup_u8('J')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('K')) | svcmpeq_u8(pg, chars, svdup_u8('L')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('M')) | svcmpeq_u8(pg, chars, svdup_u8('N')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('O')) | svcmpeq_u8(pg, chars, svdup_u8('P')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Q')) | svcmpeq_u8(pg, chars, svdup_u8('R')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('S')) | svcmpeq_u8(pg, chars, svdup_u8('T')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('U')) | svcmpeq_u8(pg, chars, svdup_u8('V')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('W')) | svcmpeq_u8(pg, chars, svdup_u8('X')) |\n                              svcmpeq_u8(pg, chars, svdup_u8('Y')) | svcmpeq_u8(pg, chars, svdup_u8('Z'));\n\n        svuint8_t upper_chars = svand_u8(pg, chars, upper_mask);\n        sum += svaddv_u8(svadd_u8(upper_chars, svdup_u8(0)), pg);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    svint32_t min_even_value = svdup_n_s32(std::numeric_limits<int>::max());\n    svint32_t min_even_index = svdup_n_s32(-1);\n    svbool_t mask = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t data = svld1(mask, &arr[i]);\n        svbool_t even_mask = svcmpeq_b32(mask, svand_s32(data, svdup_n_s32(1)), svdup_n_s32(0));\n        \n        svint32_t even_values = svreinterpret_s32(svand_s32(data, svdup_n_s32(0xFFFFFFFE)));\n        min_even_value = svmin_s32(min_even_value, svsel(even_mask, even_values, min_even_value));\n        \n        svint32_t indices = svdup_n_s32(i);\n        min_even_index = svmin_s32(min_even_index, svsel(even_mask, indices, min_even_index));\n    }\n\n    int smallest_value = svmax_s32(min_even_value, min_even_value);\n    int smallest_index = svmax_s32(min_even_index, min_even_index);\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    svint32_t min_even_value = svdup_n_s32(std::numeric_limits<int>::max());\n    svuint32_t min_even_index = svdup_n_u32(std::numeric_limits<unsigned int>::max());\n    svbool_t mask;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(svptrue_b32(), &arr[i]);\n        mask = svcmpeq(svptrue_b32(), svand_n_s32(vec, 1), 0);\n        \n        svint32_t even_values = svreinterpret_as_s32(svand(mask, vec));\n        svuint32_t indices = svdup_n_u32(i) + svindex_u32(0, svcntw());\n\n        mask = svcmplt(svptrue_b32(), even_values, min_even_value);\n        min_even_value = svsel(mask, even_values, min_even_value);\n        min_even_index = svsel(mask, indices, min_even_index);\n    }\n\n    int smallest_value = svmax(svdup_n_s32(0), min_even_value);\n    unsigned int smallest_index = svmax(svdup_n_u32(0), min_even_index);\n\n    if (smallest_value == std::numeric_limits<int>::max()) {\n        return {};\n    }\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, arr.data());\n\n    svint32_t even_mask = svand_s32(pg, vec, svdup_s32(1));\n    svbool_t is_even = svcmpeq(pg, even_mask, svdup_s32(0));\n\n    svint32_t min_even_value = svdup_s32(std::numeric_limits<int>::max());\n    svint32_t min_even_index = svdup_s32(-1);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t current_values = svld1(pg, arr.data() + i);\n        svbool_t current_is_even = svcmpeq(pg, svand_s32(pg, current_values, svdup_s32(1)), svdup_s32(0));\n\n        min_even_value = svmin_s32(pg, min_even_value, svsel(current_is_even, current_values, min_even_value));\n        min_even_index = svsel(current_is_even, svdup_s32(i), min_even_index);\n    }\n\n    svbool_t valid = svcmpeq(pg, min_even_value, std::numeric_limits<int>::max());\n    if (svptest_any(pg, valid)) return {};\n\n    int smallest_value = svlastb_s32(min_even_value);\n    int smallest_index = svlastb_s32(min_even_index);\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, arr.data());\n\n    svbool_t is_even = svcmpeq_n_u32(pg, vec, 0);\n    svint32_t even_values = svand(vec, svdup_n_u32(1)); // Mask to get even values\n    svint32_t min_even = svdup_n_u32(std::numeric_limits<int>::max());\n    svuint32_t min_index = svdup_n_u32(std::numeric_limits<unsigned int>::max());\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t valid_mask = svwhilelt_b32(i, n);\n        svint32_t current_values = svld1(valid_mask, arr.data() + i);\n        svbool_t current_is_even = svcmpeq_n_u32(valid_mask, current_values, 0);\n\n        // Update min_even and min_index\n        svint32_t current_min_even = svmin(valid_mask, current_values, min_even);\n        svuint32_t current_min_index = svdup_n_u32(i);\n\n        min_even = svsel(current_is_even, current_min_even, min_even);\n        min_index = svsel(current_is_even, current_min_index, min_index);\n    }\n\n    // Find the smallest even value and its index\n    int smallest_value = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    for (int i = 0; i < svcntw(); ++i) {\n        if (min_even[i] < smallest_value) {\n            smallest_value = min_even[i];\n            smallest_index = min_index[i];\n        }\n    }\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return {};\n\n    svint32_t min_even_value = svdup_n_s32(std::numeric_limits<int>::max());\n    svuint32_t min_even_index = svdup_n_u32(std::numeric_limits<unsigned int>::max());\n    svbool_t mask = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        svint32_t vec = svld1(mask, &arr[i]);\n        svbool_t even_mask = svcmpeq(mask, svand_n_s32(vec, 1), 0);\n        \n        svint32_t even_values = svreinterpret_s32(svand_n_u32(vec, 0xFFFFFFFE));\n        svint32_t filtered_even_values = svsel(even_mask, even_values, svdup_n_s32(std::numeric_limits<int>::max()));\n        \n        min_even_value = svmin_s32(min_even_value, filtered_even_values);\n        \n        svuint32_t indices = svdup_n_u32(i);\n        svuint32_t filtered_indices = svsel(even_mask, indices, svdup_n_u32(std::numeric_limits<unsigned int>::max()));\n        min_even_index = svmin_u32(min_even_index, filtered_indices);\n    }\n\n    int smallest_value = svmax_s32(min_even_value);\n    unsigned int smallest_index = svmax_u32(min_even_index);\n\n    if (smallest_value == std::numeric_limits<int>::max()) return {};\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svint32_t vec = svld1_s32(&lst[0]);\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    std::unordered_map<int, int> freq_map;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t current_vec = svld1_s32(&lst[i]);\n        svint32_t unique_vals = svdup_n_s32(0);\n        svint32_t counts = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntw(); j++) {\n            if (pg[j]) {\n                int val = svget1_s32(svindex_s32(current_vec, j));\n                freq_map[val]++;\n            }\n        }\n    }\n\n    int result = -1;\n    for (const auto& pair : freq_map) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svint32_t vec = svld1_s32(&lst[0]);\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    std::unordered_map<int, int> freq_map;\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t current = svld1_s32(&lst[i]);\n        svint32_t unique = svdup_s32(0);\n        \n        for (int j = 0; j < svcntw(); j++) {\n            if (pg[j]) {\n                int value = svget1_s32(svindex_s32(current, j));\n                freq_map[value]++;\n            }\n        }\n    }\n    \n    int result = -1;\n    for (const auto& pair : freq_map) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (value > 0 && frequency >= value) {\n            result = std::max(result, value);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svint32_t vec = svld1_s32(&lst[0]);\n    svuint64_t counts = svdup_u64(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t data = svld1_s32(&lst[i]);\n        svuint64_t indices = svsub_u64(svuzp_u32(data), svdup_u64(1));\n        counts = svadd_u64(counts, svdup_u64(1));\n    }\n\n    std::unordered_map<int, int> frequency_map;\n    for (int i = 0; i < n; i++) {\n        frequency_map[lst[i]]++;\n    }\n\n    int result = -1;\n    for (const auto& pair : frequency_map) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svint32_t vec = svld1_s32(&lst[0]);\n    svuint32_t mask = svdup_u32(0);\n    \n    // Count frequencies\n    std::unordered_map<int, int> frequency_map;\n    for (int num : lst) {\n        frequency_map[num]++;\n    }\n\n    int max_value = -1;\n    for (const auto& pair : frequency_map) {\n        int value = pair.first;\n        int frequency = pair.second;\n        if (value > 0 && frequency >= value) {\n            max_value = std::max(max_value, value);\n        }\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    \n    std::unordered_map<int, int> freq_map;\n    for (int num : lst) {\n        freq_map[num]++;\n    }\n\n    svint32_t max_freq = svdup_n_s32(0);\n    svint32_t result = svdup_n_s32(-1);\n    \n    for (int i = 1; i <= max_val; i += svcntw()) {\n        svint32_t indices = svdup_n_s32(i);\n        svint32_t counts = svdup_n_s32(0);\n        \n        for (int j = 0; j < n; j += svcntw()) {\n            svint32_t vec = svld1_s32(&lst[j]);\n            svbool_t mask = svcmpeq_s32(svdup_n_s32(i), vec);\n            counts = svadd_s32(counts, svcntb(mask));\n        }\n        \n        svbool_t valid_mask = svcmplt_s32(counts, indices);\n        if (svptest_any(valid_mask, valid_mask)) {\n            result = svmax_s32(result, indices);\n        }\n    }\n\n    return svlastb(result) == -1 ? -1 : svget1_s32(result);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svint32_t vec = svld1(pg, &q[i]);\n        sum_vec = svaddv_s32(pg, sum_vec, vec);\n        pg = svwhilelt_b32(i + svcntb(), n);\n    }\n\n    int sum = svaddv_s32(pg, sum_vec);\n    \n    // Check for palindrome\n    bool is_palindrome = true;\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Calculate the sum of elements\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t data_vec = svld1(pg, &q[i]);\n        sum_vec = svaddv_s32(pg, sum_vec, data_vec);\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    // Check if the vector is palindromic\n    bool is_balanced = true;\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            is_balanced = false;\n            break;\n        }\n    }\n\n    // Get the total sum\n    int total_sum = svaddv_s32(pg, sum_vec);\n    \n    return is_balanced && (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 0; i < n; i += svcntb()) {\n        svint32_t vec = svld1(pg, (const svint32_t*)&q[i]);\n        sum_vec = svaddv_s32(pg, sum_vec, vec);\n        pg = svwhilelt_b32(i + svcntb(), n);\n    }\n\n    int sum = svaddv_s32(pg, sum_vec);\n    \n    // Check for palindrome\n    bool is_palindrome = true;\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    if (q.empty()) return false;\n\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Check if the vector is palindromic\n    svint32_t vec = svld1(pg, q.data());\n    svint32_t rev_vec = svrev(pg, vec);\n    svbool_t is_palindrome = svcmpeq(pg, vec, rev_vec);\n    \n    // Check if all elements are equal (palindrome check)\n    bool balanced = svptest_any(pg, is_palindrome);\n    \n    // Calculate the sum of elements\n    svint32_t sum_vec = svaddv(pg, vec);\n    int sum = svaddv(svptrue_b32(), sum_vec);\n    \n    return balanced && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    if (q.empty()) return false;\n\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_q = svld1(pg, q.data());\n\n    // Check if balanced (palindromic)\n    svint32_t rev_vec_q = svrev(pg, vec_q);\n    svbool_t is_balanced = svcmpeq(pg, vec_q, rev_vec_q);\n    bool balanced = svptest_any(pg, is_balanced);\n\n    // Calculate sum\n    svint32_t sum_vec = svaddv(pg, vec_q);\n    int sum = svaddv(pg, sum_vec);\n\n    return balanced && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svint32_t left = svld1(svptrue_b32(), &arr[i]);\n        svint32_t right = svld1(svptrue_b32(), &arr[n - 1 - i]);\n\n        svint32_t equal_mask = svcmpeq(svdup_n_s32(0), left, right);\n        changes += svaddv(svadd(svadd(svdup_n_s32(0), svcntb(equal_mask)), svdup_n_s32(1)), svdup_n_s32(0));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int change_count = 0;\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svint32_t left = svld1_s32(&arr[i]);\n        svint32_t right = svld1_s32(&arr[n - 1 - i]);\n\n        svint32_t equal_mask = svcmpeq_s32(left, right);\n        change_count += svcntb(svnot_b32(equal_mask));\n    }\n\n    return change_count;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svuint32_t left = svld1_u32(&arr[i]);\n        svuint32_t right = svld1_u32(&arr[n - 1 - i]);\n\n        svuint32_t equal_mask = svcmpeq_u32(left, right);\n        changes += svcntb(svnot_u32(equal_mask));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n / 2; i += svcntb()) {\n        svint32_t left = svld1(pg, &arr[i]);\n        svint32_t right = svld1(pg, &arr[n - 1 - i]);\n\n        svbool_t cmp = svcmpeq_b32(left, right);\n        changes += svcntb(svnot(pg, cmp));\n        \n        pg = svwhilelt_b32(i + svcntb(), n / 2);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    svint32_t *vec_arr = (svint32_t *)arr.data();\n    svint32_t zero = svdup_n_s32(0);\n    \n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svint32_t left = svld1_s32(&vec_arr[i]);\n        svint32_t right = svld1_s32(&vec_arr[n - 1 - i]);\n\n        svint32_t eq_mask = svcmpeq_s32(left, right);\n        changes += svpopc(eq_mask) / 2; // Count mismatches\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < len1; i += svcntb()) {\n        svuint8_t chars = svdup_u8(0);\n        for (size_t j = 0; j < svcntb() && (i + j) < len1; ++j) {\n            chars = svadd_u8(chars, svdup_u8(lst1[i + j].size()));\n        }\n        total_chars1 += svaddv_u8(pg, chars);\n    }\n\n    for (size_t i = 0; i < len2; i += svcntb()) {\n        svuint8_t chars = svdup_u8(0);\n        for (size_t j = 0; j < svcntb() && (i + j) < len2; ++j) {\n            chars = svadd_u8(chars, svdup_u8(lst2[i + j].size()));\n        }\n        total_chars2 += svaddv_u8(pg, chars);\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < len1; i += SVECTOR_SIZE) {\n        svuint32_t chars_count = svdup_u32(0);\n        for (size_t j = 0; j < SVECTOR_SIZE && (i + j) < len1; ++j) {\n            chars_count = svadd_u32(chars_count, svdup_u32(lst1[i + j].size()));\n        }\n        total_chars1 += svaddv_u32(pg, chars_count);\n    }\n\n    for (size_t i = 0; i < len2; i += SVECTOR_SIZE) {\n        svuint32_t chars_count = svdup_u32(0);\n        for (size_t j = 0; j < SVECTOR_SIZE && (i + j) < len2; ++j) {\n            chars_count = svadd_u32(chars_count, svdup_u32(lst2[i + j].size()));\n        }\n        total_chars2 += svaddv_u32(pg, chars_count);\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < len1; i += svcntb()) {\n        svuint8_t chars_count = svdup_u8(0);\n        for (size_t j = 0; j < svcntb() && (i + j) < len1; ++j) {\n            chars_count = svadd_u8(chars_count, svdup_u8(lst1[i + j].size()));\n        }\n        total_chars1 += svaddv_u8(pg, chars_count);\n    }\n\n    for (size_t i = 0; i < len2; i += svcntb()) {\n        svuint8_t chars_count = svdup_u8(0);\n        for (size_t j = 0; j < svcntb() && (i + j) < len2; ++j) {\n            chars_count = svadd_u8(chars_count, svdup_u8(lst2[i + j].size()));\n        }\n        total_chars2 += svaddv_u8(pg, chars_count);\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0, total2 = 0;\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    svbool_t pg1 = svwhilelt_b64(0, len1);\n    svbool_t pg2 = svwhilelt_b64(0, len2);\n\n    for (size_t i = 0; i < len1; i += svcntb()) {\n        svuint8_t chars = svdup_u8(0);\n        svbool_t pg = svwhilelt_b64(i, len1);\n        for (size_t j = 0; j < svcntb(); ++j) {\n            if (pg1[j]) {\n                chars = svadd_u8(chars, svdup_u8(lst1[i + j].size()));\n            }\n        }\n        total1 += svaddv_u8(svptrue_b8(), chars);\n    }\n\n    for (size_t i = 0; i < len2; i += svcntb()) {\n        svuint8_t chars = svdup_u8(0);\n        svbool_t pg = svwhilelt_b64(i, len2);\n        for (size_t j = 0; j < svcntb(); ++j) {\n            if (pg2[j]) {\n                chars = svadd_u8(chars, svdup_u8(lst2[i + j].size()));\n            }\n        }\n        total2 += svaddv_u8(svptrue_b8(), chars);\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n    \n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < len1; i += SV_NUM_ELEMS) {\n        svuint64_t chars = svdup_u64(0);\n        for (size_t j = 0; j < SV_NUM_ELEMS && (i + j) < len1; ++j) {\n            chars = svadd_u64(chars, svdup_u64(lst1[i + j].size()));\n        }\n        total_chars1 += svaddv_u64(pg, chars);\n    }\n\n    for (size_t i = 0; i < len2; i += SV_NUM_ELEMS) {\n        svuint64_t chars = svdup_u64(0);\n        for (size_t j = 0; j < SV_NUM_ELEMS && (i + j) < len2; ++j) {\n            chars = svadd_u64(chars, svdup_u64(lst2[i + j].size()));\n        }\n        total_chars2 += svaddv_u64(pg, chars);\n    }\n\n    if (total_chars1 < total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(svdup_u64(1), result))) {\n        result = svmul_u64(result, vec_n);\n        if (svptest_any(svptrue_b64(), svcmpeq_u64(vec_x, result))) {\n            return true;\n        }\n        if (svptest_any(svptrue_b64(), svcmpgt_u64(vec_x, result))) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t pg = svptrue_b64();\n\n    while (svptest_any(pg, svcmpeq_u64(vec_n, svdup_u64(1)))){\n        result = svmul_u64(result, vec_n);\n        pg = svptrue_b64();\n    }\n\n    return svptest_any(pg, svcmpeq_u64(result, vec_x));\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t power = svdup_u64(1);\n    svuint64_t result = svdup_u64(0);\n    \n    for (int i = 0; i < 64; i++) {\n        result = svadd_u64(result, power);\n        if (svptest_any(svptrue_b64(), svcmpeq_u64(result, vec_x))) {\n            return true;\n        }\n        power = svmul_u64(power, vec_n);\n        if (svptest_any(svptrue_b64(), svcmpgt_u64(power, vec_x))) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x < n) return false;\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t power = svdup_u64(1);\n    svbool_t pg = svptrue_b64();\n\n    while (svptest_any(pg, power) && svmax_u64(svadd_u64(power, power), svdup_u64(0)) <= vec_x) {\n        power = svmul_u64(power, vec_n);\n        pg = svcmpeq_u64(pg, power, vec_x);\n    }\n\n    return svptest_any(pg, power);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    \n    while (svptest_any(svptrue_b64(), svcmpeq_u64(svdup_u64(1), result))) {\n        result = svmul_u64(result, vec_n);\n        if (svptest_any(svptrue_b64(), svcmpeq_u64(vec_x, result))) {\n            return true;\n        }\n        if (svptest_any(svptrue_b64(), svcmpgt_u64(result, vec_x))) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t length = num.length();\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    uint8_t primes_mask = (1 << 2) | (1 << 3) | (1 << 5) | (1 << 7) | (1 << 11) | (1 << 13);\n    \n    for (size_t i = 0; i < length; i += svcntb()) {\n        svuint8_t indices = svindex_u8(i, svcntb());\n        svuint8_t hex_digits = svld1_u8(pg, (const uint8_t *)(num.data() + i));\n        \n        svuint8_t decimal_values = svsub_u8(hex_digits, svdup_u8('0'));\n        svuint8_t mask = svdup_u8(0);\n        \n        mask = svorr_u8(mask, svand_u8(svdup_u8(0xF), svsub_u8(hex_digits, svdup_u8('0'))));\n        mask = svorr_u8(mask, svand_u8(svdup_u8(0xF), svsub_u8(hex_digits, svdup_u8('A' - 10))));\n        \n        svbool_t is_prime = svreinterpret_b8(svdup_u8(primes_mask));\n        count += svaddv_u8(svand_u8(mask, is_prime));\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    uint8_t primes_mask = 0b00000010 | 0b00000100 | 0b00001000 | 0b00010000 | 0b00100000 | 0b01000000; // 2, 3, 5, 7, B, D\n    uint8_t hex_values[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    \n    svuint8_t hex_digits = svdup_u8(0);\n    svuint8_t prime_count = svdup_u8(0);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        pg = svwhilelt_b8(i, len);\n        \n        svuint8_t indices = svld1_u8(pg, (const uint8_t*)num.data() + i);\n        indices = svand_u8(indices, 0x0F); // Mask to get lower 4 bits\n        \n        // Convert ASCII to hex values\n        svuint8_t hex_vals = svadd_u8(indices, svdup_u8(-'0'));\n        hex_vals = svadd_u8(hex_vals, svand_u8(svsub_u8(indices, svdup_u8(10)), svdup_u8(0x0F)));\n        \n        // Check for primes\n        svuint8_t is_prime = svand_u8(primes_mask, hex_vals);\n        prime_count = svadd_u8(prime_count, svcntb(pg));\n    }\n    \n    count += svaddv_u8(prime_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    svbool_t pg = svptrue_b8();\n    \n    // Prepare a mask for prime hexadecimal digits\n    uint8_t prime_mask = 0b00000000; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n    prime_mask |= (1 << 2); // 2\n    prime_mask |= (1 << 3); // 3\n    prime_mask |= (1 << 5); // 5\n    prime_mask |= (1 << 7); // 7\n    prime_mask |= (1 << 11); // B\n    prime_mask |= (1 << 13); // D\n\n    for (int i = 0; i < length; i += svcntb()) {\n        svuint8_t hex_digits = svld1_u8(pg, (const uint8_t *)(num.c_str() + i));\n        svuint8_t hex_values = svsub_u8(hex_digits, svdup_u8('0')); // Convert '0'-'9' to 0-9\n        svuint8_t hex_values_upper = svsub_u8(hex_digits, svdup_u8('A' - 10)); // Convert 'A'-'F' to 10-15\n        \n        // Create a mask for valid hexadecimal digits\n        svbool_t valid_mask = svorr_b8(pg, svcmplt_u8(hex_values, svdup_u8(16)), svcmplt_u8(hex_values_upper, svdup_u8(16)));\n        \n        // Combine the values\n        svuint8_t combined_values = svorr_u8(valid_mask, hex_values, hex_values_upper);\n        \n        // Count primes\n        count += svcntb(svand_u8(valid_mask, svdup_u8(prime_mask & 0xFF)));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    // Define a mask for prime hex digits: 2, 3, 5, 7, B, D\n    uint8_t prime_mask = 0b00111000; // 2, 3, 5, 7, B, D in hex\n\n    // Process the string in chunks\n    for (int i = 0; i < length; i += svcntb()) {\n        svuint8_t hex_digits = svld1_u8(pg, (const uint8_t *)(num.c_str() + i));\n        \n        // Convert ASCII hex characters to their numeric values\n        svuint8_t numeric_values = svsub_u8(hex_digits, svdup_u8('0'));\n        svbool_t is_upper = svcmpeq_u8(numeric_values, svdup_u8(10)); // Check for 'A'\n        numeric_values = svorr_u8(numeric_values, svand_u8(is_upper, svsub_u8(numeric_values, svdup_u8(7)))); // Convert 'A' to 10, 'B' to 11, etc.\n\n        // Create a mask for prime digits\n        svbool_t prime_mask_pg = svcmpeq_u8(numeric_values, svdup_u8(2));\n        prime_mask_pg = svorr_b8(prime_mask_pg, svcmpeq_u8(numeric_values, svdup_u8(3)));\n        prime_mask_pg = svorr_b8(prime_mask_pg, svcmpeq_u8(numeric_values, svdup_u8(5)));\n        prime_mask_pg = svorr_b8(prime_mask_pg, svcmpeq_u8(numeric_values, svdup_u8(7)));\n        prime_mask_pg = svorr_b8(prime_mask_pg, svcmpeq_u8(numeric_values, svdup_u8(11)));\n        prime_mask_pg = svorr_b8(prime_mask_pg, svcmpeq_u8(numeric_values, svdup_u8(13)));\n\n        // Count the number of primes\n        count += svcntb(svaddv_u8(pg, prime_mask_pg));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    int length = num.length();\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    uint8_t primes_mask = 0b00000000; // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n    primes_mask |= (1 << 2); // 2\n    primes_mask |= (1 << 3); // 3\n    primes_mask |= (1 << 5); // 5\n    primes_mask |= (1 << 7); // 7\n    primes_mask |= (1 << 11); // B\n    primes_mask |= (1 << 13); // D\n\n    svuint8_t hex_digits = svdup_u8(0);\n    svuint8_t prime_count = svdup_u8(0);\n\n    for (int i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svuint8_t indices = svld1_u8(pg, (const uint8_t *)(num.data() + i));\n        \n        // Convert ASCII hex characters to their integer values\n        svuint8_t hex_values = svsub_u8(svand_u8(indices, 0x0F), svdup_u8('0'));\n        hex_values = svorr_u8(hex_values, svand_u8(svsub_u8(indices, svdup_u8('A' - 10)), svdup_u8(0xF)));\n\n        // Check for primes\n        svuint8_t is_prime = svand_u8(hex_values, svdup_u8(primes_mask));\n        prime_count = svadd_u8(prime_count, svcntb(pg));\n    }\n\n    count += svaddv_u8(prime_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t distinct_mask = svdup_u8(0);\n    \n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t next_chars = svld1_u8(pg, (const uint8_t*)(s.data() + i + 1));\n        svuint8_t next_next_chars = svld1_u8(pg, (const uint8_t*)(s.data() + i + 2));\n\n        svuint8_t combined = svorr_u8(svorr_u8(chars, next_chars), next_next_chars);\n        distinct_mask = svorr_u8(distinct_mask, combined);\n        \n        svbool_t distinct_check = svcmpeq_u8(pg, chars, next_chars);\n        distinct_check = svorr_b8(distinct_check, svcmpeq_u8(pg, chars, next_next_chars));\n        distinct_check = svorr_b8(distinct_check, svcmpeq_u8(pg, next_chars, next_next_chars));\n\n        if (svptest_any(pg, distinct_check)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t distinct_mask = svdup_u8(0);\n    svuint8_t prev1 = svdup_u8(0), prev2 = svdup_u8(0);\n    bool happy = true;\n\n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svuint8_t mask = svdup_u8(0);\n\n        mask = svorr_u8(mask, svceq_u8(chars, prev1));\n        mask = svorr_u8(mask, svceq_u8(chars, prev2));\n\n        if (svptest_any(pg, mask)) {\n            happy = false;\n            break;\n        }\n\n        prev2 = prev1;\n        prev1 = chars;\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    size_t happy_count = 0;\n\n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(s.c_str() + i));\n        svuint8_t next_chars = svld1_u8(pg, (const uint8_t*)(s.c_str() + i + 1));\n        svuint8_t next_next_chars = svld1_u8(pg, (const uint8_t*)(s.c_str() + i + 2));\n\n        svbool_t distinct1 = svcmpeq_u8(pg, chars, next_chars);\n        svbool_t distinct2 = svcmpeq_u8(pg, chars, next_next_chars);\n        svbool_t distinct3 = svcmpeq_u8(pg, next_chars, next_next_chars);\n\n        pg = svand_b8(pg, svnot_b8(distinct1));\n        pg = svand_b8(pg, svnot_b8(distinct2));\n        pg = svand_b8(pg, svnot_b8(distinct3));\n\n        happy_count += svcntb() - svpopc_b8(pg);\n        pg = svptrue_b8(); // Reset the predicate for the next iteration\n    }\n\n    return happy_count == 0;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t distinct_mask = svdup_u8(0);\n    svuint8_t prev1 = svdup_u8(0), prev2 = svdup_u8(0);\n    bool happy = true;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n\n        if (remaining < svcntb()) {\n            pg = svwhilelt_b8(i, len);\n            chars = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        }\n\n        svuint8_t mask = svdup_u8(0);\n        mask = svorr_u8(mask, svcmpeq_u8(chars, prev1));\n        mask = svorr_u8(mask, svcmpeq_u8(chars, prev2));\n\n        if (svptest_any(pg, mask)) {\n            happy = false;\n            break;\n        }\n\n        prev2 = prev1;\n        prev1 = chars;\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint8_t chars = svdup_u8(0);\n    svuint8_t prev1 = svdup_u8(0);\n    svuint8_t prev2 = svdup_u8(0);\n    \n    for (size_t i = 0; i < len - 2; i += svcntb()) {\n        svuint8_t current = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        pg = svwhilelt_b32(i + svcntb(), len);\n\n        chars = svuzp1_u8(current, prev1);\n        prev1 = svuzp2_u8(current, prev1);\n        prev2 = svuzp1_u8(prev1, prev2);\n\n        svbool_t distinct = svcmpeq_u8(chars, prev1);\n        distinct = svorr_b8(distinct, svcmpeq_u8(chars, prev2));\n\n        if (svptest_any(pg, distinct)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    \n    // Use SVE to check if the length is prime\n    svbool_t pg = svptrue_b32();\n    svint32_t lengths = svdup_n_s32(length);\n    \n    svint32_t is_prime_vec = svdup_n_s32(1);\n    \n    // Check divisibility by 2 and 3\n    is_prime_vec = svand_s32(is_prime_vec, svcmpeq_s32(lengths, svdup_n_s32(2)));\n    is_prime_vec = svorr_s32(is_prime_vec, svcmpeq_s32(lengths, svdup_n_s32(3)));\n    \n    // Check for other divisors\n    for (int i = 5; i * i <= length; i += 6) {\n        svint32_t divisor1 = svdup_n_s32(i);\n        svint32_t divisor2 = svdup_n_s32(i + 2);\n        \n        svbool_t divisible1 = svcmpeq_s32(svrem_s32(lengths, divisor1), svdup_n_s32(0));\n        svbool_t divisible2 = svcmpeq_s32(svrem_s32(lengths, divisor2), svdup_n_s32(0));\n        \n        is_prime_vec = svand_s32(is_prime_vec, svneg_b32(divisible1));\n        is_prime_vec = svand_s32(is_prime_vec, svneg_b32(divisible2));\n    }\n    \n    return svptest_any(pg, is_prime_vec);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svint32_t indices = svindex(0, 32);\n    svint32_t lengths = svdup_n_s32(length);\n    \n    svbool_t is_prime_vec = svdup_b8(0);\n    \n    for (int i = 2; i <= length; i++) {\n        svint32_t current = svdup_n_s32(i);\n        svbool_t is_prime_check = svcmpeq_s32(pg, current, lengths);\n        is_prime_vec = svorr_b8(is_prime_vec, is_prime_check);\n    }\n\n    return svptest_any(pg, is_prime_vec);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t lengths = svdup_n_s32(length);\n    svint32_t results = svdup_n_s32(1); // Assume prime\n\n    for (int i = 2; i * i <= length; i++) {\n        svint32_t divisor = svdup_n_s32(i);\n        svbool_t mask = svlt_u32(svdup_n_u32(i * i), lengths);\n        svint32_t mod_result = svmod_s32(pg, lengths, divisor);\n        results = svand_s32(pg, results, svceq_s32(pg, mod_result, svdup_n_s32(0)));\n        pg = svand(pg, pg, mask);\n    }\n\n    return svptest_any(pg, svceq_s32(pg, results, svdup_n_s32(1)));\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t lengths = svdup_n_s32(length);\n    svint32_t results = svdup_n_s32(1); // Assume prime\n\n    svint32_t two = svdup_n_s32(2);\n    svint32_t three = svdup_n_s32(3);\n    svint32_t i = svdup_n_s32(5);\n\n    svbool_t is_less_than_two = svcmplt(pg, lengths, two);\n    svbool_t is_less_than_three = svcmplt(pg, lengths, three);\n    results = svsel(is_less_than_two, svdup_n_s32(0), results);\n    results = svsel(is_less_than_three, svdup_n_s32(1), results);\n\n    svbool_t is_even = svcmpeq(pg, svmod_s32(lengths, two), svdup_n_s32(0));\n    results = svsel(is_even, svdup_n_s32(0), results);\n\n    while (svptest_any(pg, results)) {\n        svbool_t pg_i = svptrue_b32();\n        svint32_t mod_i = svmod_s32(lengths, i);\n        svint32_t mod_next = svmod_s32(lengths, svadd_s32(i, two));\n\n        results = svsel(pg_i, svdup_n_s32(0), results);\n        pg_i = svcmpeq(pg_i, mod_i, svdup_n_s32(0));\n        results = svsel(pg_i, svdup_n_s32(0), results);\n        pg_i = svcmpeq(pg_i, mod_next, svdup_n_s32(0));\n        results = svsel(pg_i, svdup_n_s32(0), results);\n\n        i = svadd_s32(i, svdup_n_s32(6));\n    }\n\n    return svptest_any(pg, svcmpeq(results, svdup_n_s32(1)));\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svint32_t lengths = svdup_n_s32(length);\n    svint32_t results = svdup_n_s32(1); // Assume prime\n\n    // Check divisibility by 2\n    svint32_t two = svdup_n_s32(2);\n    svint32_t mod2 = svrem_s32(lengths, two);\n    results = svand_s32(results, svcmpeq_s32(mod2, svdup_n_s32(0)));\n\n    // Check divisibility by odd numbers from 3 to sqrt(length)\n    for (int i = 3; i * i <= length; i += 2) {\n        svint32_t divisor = svdup_n_s32(i);\n        svint32_t mod = svrem_s32(lengths, divisor);\n        results = svand_s32(results, svcmpeq_s32(mod, svdup_n_s32(0)));\n    }\n\n    // If results is still 1, then it's prime\n    return svptest_any(pg, results);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t temp = N;\n\n    while (temp > 0) {\n        sum += temp & 1;\n        temp >>= 1;\n    }\n\n    std::bitset<64> binarySum(sum);\n    return binarySum.to_string().substr(64 - binarySum.count());\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n    \n    while (mask <= N) {\n        sum += (N & mask) ? 1 : 0;\n        mask <<= 1;\n    }\n\n    std::string binary_sum = std::bitset<64>(sum).to_string();\n    return binary_sum.substr(binary_sum.find('1'));\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n    \n    while (mask <= N) {\n        sum += (N & mask) ? 1 : 0;\n        mask <<= 1;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    return (pos == std::string::npos) ? \"0\" : binary.substr(pos);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N & 1;\n        N >>= 1;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    \n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    return pos == std::string::npos ? \"0\" : binary.substr(pos);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    uint64_t mask = 1;\n\n    while (N > 0) {\n        sum += (N & mask) ? 1 : 0;\n        N >>= 1;\n    }\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t pos = binary.find('1');\n    return pos == std::string::npos ? \"0\" : binary.substr(pos);\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    \n    svint32_t vec_sum = svdup_n_s32(0);\n    \n    for (int i = 1; i < n; i += 2) {\n        svint32_t vec = svld1_s32(&lst[i]);\n        svbool_t mask = svcmpeq_n_s32(svindex_s32(i), 0);\n        vec_sum = svadd_s32(vec_sum, svand_s32(vec, mask));\n    }\n    \n    sum += svaddv_s32(vec_sum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    svint32_t total = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t mask = svdup_n_s32(0);\n        \n        // Create a mask for odd indices\n        for (int j = 0; j < svcntw(); j++) {\n            if ((i + j) % 2 == 1) {\n                mask = svorr(mask, mask, svdup_n_s32(1 << j));\n            }\n        }\n\n        // Filter even numbers at odd indices\n        svint32_t even_mask = svand(mask, svceq_s32(vec, svdup_n_s32(0)));\n        total = svaddv_s32(total, svand(even_mask, vec));\n    }\n\n    // Horizontal addition to get the final sum\n    sum = svaddv_s32(total);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    svint32_t total = svdup_n_s32(0);\n    \n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t data = svld1_s32(svld1_u8((uint8_t*)lst.data() + i * sizeof(int)));\n        svbool_t mask_even = svcmpeq_s32(svdup_n_s32(0), svand_s32(data, svdup_n_s32(1)));\n        svbool_t mask_odd_indices = svindex(svdup_n_u32(1), svindex(svdup_n_u32(0), svdup_n_u32(1)));\n        svbool_t combined_mask = svand(mask_even, mask_odd_indices);\n        \n        total = svaddv_s32(total, svsel(combined_mask, data, svdup_n_s32(0)));\n    }\n    \n    sum += svaddv_s32(total);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n    \n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t data = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t mask = svand_s32(svdup_n_s32(1), svdup_n_s32(0xFFFFFFFE));\n        svint32_t even_elements = svand_s32(data, mask);\n        total_sum = svadd_s32(total_sum, even_elements);\n    }\n    \n    sum += svaddv_s32(svadd_s32(total_sum, svdup_n_s32(0)));\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n    \n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t data = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t mask = svand_s32(svdup_n_s32(1), svdup_n_s32(0xFFFFFFFE));\n        svint32_t even_elements = svand_s32(data, mask);\n        total_sum = svadd_s32(total_sum, even_elements);\n    }\n    \n    int32_t result[svcntw()];\n    svst1_s32(svptrue_b32(), result, total_sum);\n    \n    for (int i = 0; i < svcntw(); ++i) {\n        sum += result[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svdup_u8(0);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t shifted = svadd_u8(input, svdup_u8(2 * 2)); // Shift down by 4\n        svuint8_t wrapped = svand_u8(shifted, svdup_u8(0x1F)); // Wrap around for lowercase letters\n        \n        svst1_u8(pg, (uint8_t*)(result.data() + i), wrapped);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svadd_u8(svdup_u8(2), svdup_u8(2)); // Shift by 4\n    svuint8_t base = svdup_u8('a');\n    svuint8_t range = svdup_u8(26);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        svuint8_t shifted = svadd_u8(chars, indices);\n        svuint8_t wrapped = svsub_u8(shifted, svand_u8(svsub_u8(shifted, base), range));\n        svst1_u8(pg, (uint8_t *)(result.data() + i), wrapped);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint8_t shift = svdup_u8(2 * 2); // Shift by 4\n    svuint8_t a = svdup_u8('a');\n    svuint8_t z = svdup_u8('z');\n    svuint8_t A = svdup_u8('A');\n    svuint8_t Z = svdup_u8('Z');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        svuint8_t is_lower = svand_u8(svcmpeq_u8(input, svdup_u8('a')), svdup_u8(1));\n        svuint8_t is_upper = svand_u8(svcmpeq_u8(input, svdup_u8('A')), svdup_u8(1));\n\n        svuint8_t base = svorr_u8(svand_u8(is_lower, a), svand_u8(is_upper, A));\n        svuint8_t offset = svsub_u8(input, base);\n        svuint8_t new_offset = svadd_u8(offset, shift);\n        svuint8_t wrapped = svmin_u8(new_offset, svsub_u8(z, base));\n        svuint8_t result_char = svadd_u8(wrapped, base);\n\n        svst1_u8(pg, (uint8_t *)(result.data() + i), result_char);\n        pg = svwhilelt_b32(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svadd_u8(svindex_u8(0), 2);\n    svuint8_t shift = svdup_u8(2);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        svuint8_t rotated = svadd_u8(input, shift);\n        svuint8_t wrapped = svand_u8(rotated, svdup_u8(0x1F)); // Wrap around for lowercase letters\n\n        svst1_u8(pg, (uint8_t *)(result.data() + i), wrapped);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    svuint8_t shift = svdup_u8(2 * 2); // Shift by 4\n    svuint8_t base = svdup_u8('a'); // Base for lowercase letters\n    svuint8_t range = svdup_u8(26); // Range of alphabet\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t idx = svld1_u8(&s[i]);\n        svuint8_t mask = svcmpeq_u8(idx, svdup_u8(0)); // Mask for null terminator\n        idx = svsub_u8(idx, base); // Normalize to 0-25 range\n        idx = svadd_u8(idx, shift); // Shift by 4\n        idx = svmod_u8(idx, range); // Wrap around using modulo\n        idx = svadd_u8(idx, base); // Denormalize back to ASCII\n\n        svst1_u8(&result[i], svand_u8(idx, mask)); // Store result, apply mask\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Swap case\n        svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n        svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n        chars = svorr_u8(chars, svand_u8(is_lower, svdup_u8('A' - 'a')));\n        chars = svorr_u8(chars, svand_u8(is_upper, svdup_u8('a' - 'A')));\n\n        // Replace vowels\n        svuint8_t vowels = svdup_u8('A');\n        svuint8_t a = svdup_u8('A');\n        svuint8_t e = svdup_u8('E');\n        svuint8_t i = svdup_u8('I');\n        svuint8_t o = svdup_u8('O');\n        svuint8_t u = svdup_u8('U');\n\n        svuint8_t is_vowel = svorr_u8(svorr_u8(svorr_u8(svcmpeq_u8(chars, a), svcmpeq_u8(chars, e)),\n                                                svcmpeq_u8(chars, i)), \n                                      svorr_u8(svcmpeq_u8(chars, o), svcmpeq_u8(chars, u)));\n\n        svuint8_t new_chars = svadd_u8(chars, svdup_u8(2));\n        chars = svsel(pg, new_chars, chars); // Replace vowels with new_chars\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Swap case\n        svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n        svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n        chars = svorr_u8(chars, svand_u8(is_lower, svdup_u8('A' - 'a')));\n        chars = svorr_u8(chars, svand_u8(is_upper, svdup_u8('a' - 'A')));\n\n        // Replace vowels\n        svuint8_t vowels = svdup_u8('A');\n        svuint8_t a = svdup_u8('A'), e = svdup_u8('E'), i = svdup_u8('I'), o = svdup_u8('O'), u = svdup_u8('U');\n        svuint8_t a_offset = svdup_u8(2), e_offset = svdup_u8(2), i_offset = svdup_u8(2), o_offset = svdup_u8(2), u_offset = svdup_u8(2);\n        \n        svuint8_t is_vowel = svorr_u8(svorr_u8(svcmpeq_u8(chars, a), svcmpeq_u8(chars, e)),\n                                      svorr_u8(svcmpeq_u8(chars, i), svorr_u8(svcmpeq_u8(chars, o), svcmpeq_u8(chars, u))));\n        \n        svuint8_t new_chars = svadd_u8(chars, svand_u8(is_vowel, svdup_u8(2)));\n        \n        svst1_u8(pg, (uint8_t*)&result[i], new_chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint8_t indices = svindex_u8(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Swap case\n        svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n        svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n        chars = svorr_u8(chars, svand_u8(is_lower, svsub_u8(chars, svdup_u8('a' - 'A'))));\n        chars = svorr_u8(chars, svand_u8(is_upper, svadd_u8(chars, svdup_u8('a' - 'A'))));\n\n        // Replace vowels\n        svuint8_t vowels = svdup_u8('A');\n        svuint8_t a = svdup_u8('A');\n        svuint8_t e = svdup_u8('E');\n        svuint8_t i = svdup_u8('I');\n        svuint8_t o = svdup_u8('O');\n        svuint8_t u = svdup_u8('U');\n\n        svuint8_t replace = svdup_u8(0);\n        replace = svorr_u8(replace, svand_u8(svcmpeq_u8(chars, a), svdup_u8('C')));\n        replace = svorr_u8(replace, svand_u8(svcmpeq_u8(chars, e), svdup_u8('G')));\n        replace = svorr_u8(replace, svand_u8(svcmpeq_u8(chars, i), svdup_u8('K')));\n        replace = svorr_u8(replace, svand_u8(svcmpeq_u8(chars, o), svdup_u8('Q')));\n        replace = svorr_u8(replace, svand_u8(svcmpeq_u8(chars, u), svdup_u8('W')));\n\n        chars = svorr_u8(chars, replace);\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n        svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n        svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n        \n        // Swap case\n        chars = svorr_u8(svand_u8(chars, svdup_u8(0x5F)), svand_u8(chars, svdup_u8(0x20)));\n\n        // Replace vowels\n        svuint8_t vowels = svorr_u8(svorr_u8(svcmpeq_u8(chars, svdup_u8('a')), \n                                               svcmpeq_u8(chars, svdup_u8('e'))),\n                                    svorr_u8(svcmpeq_u8(chars, svdup_u8('i')),\n                                             svorr_u8(svcmpeq_u8(chars, svdup_u8('o')),\n                                                      svcmpeq_u8(chars, svdup_u8('u')))));\n        \n        svuint8_t offset = svdup_u8(2);\n        svuint8_t new_chars = svadd_u8(chars, offset);\n        chars = svsel_u8(vowels, new_chars, chars);\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result(message.size(), ' ');\n    size_t len = message.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Swap case\n        svuint8_t is_lower = svcmpeq_u8(chars, svdup_u8('a'));\n        svuint8_t is_upper = svcmpeq_u8(chars, svdup_u8('A'));\n        chars = svorr_u8(chars, svand_u8(is_lower, svsub_u8(chars, svdup_u8(32))));\n        chars = svorr_u8(chars, svand_u8(is_upper, svadd_u8(chars, svdup_u8(32))));\n        \n        // Replace vowels\n        svuint8_t vowels = svorr_u8(svcmpeq_u8(chars, svdup_u8('a')), svcmpeq_u8(chars, svdup_u8('A')));\n        vowels = svorr_u8(vowels, svorr_u8(svcmpeq_u8(chars, svdup_u8('e')), svorr_u8(svcmpeq_u8(chars, svdup_u8('E')))));\n        vowels = svorr_u8(vowels, svorr_u8(svcmpeq_u8(chars, svdup_u8('i')), svorr_u8(svcmpeq_u8(chars, svdup_u8('I')))));\n        vowels = svorr_u8(vowels, svorr_u8(svcmpeq_u8(chars, svdup_u8('o')), svorr_u8(svcmpeq_u8(chars, svdup_u8('O')))));\n        vowels = svorr_u8(vowels, svorr_u8(svcmpeq_u8(chars, svdup_u8('u')), svorr_u8(svcmpeq_u8(chars, svdup_u8('U')))));\n        \n        svuint8_t new_chars = svadd_u8(chars, svdup_u8(2));\n        chars = svorr_u8(chars, svand_u8(vowels, new_chars));\n        \n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b32(0, len);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)(key.c_str() + i));\n            svbool_t lower_mask = svcmpeq_u8(pg, chars, svdup_u8('a'));\n            svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A'));\n\n            all_lower &= svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('a'))) || \n                         svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('A')));\n            all_upper &= svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('A'))) || \n                         svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('Z')));\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b32(0, len);\n\n        if (len == 0) continue;\n\n        svuint8_t key_vec = svld1_u8(pg, (const uint8_t*)key.c_str());\n\n        svuint8_t lower_mask = svdup_u8('a');\n        svuint8_t upper_mask = svdup_u8('A');\n        svuint8_t alpha_mask = svdup_u8('z' - 'a' + 1);\n        svuint8_t upper_limit = svdup_u8('Z');\n\n        svbool_t is_lower = svcmpeq_u8(pg, svsub_u8(key_vec, lower_mask), svdup_u8(0));\n        svbool_t is_upper = svcmpeq_u8(pg, svsub_u8(key_vec, upper_mask), svdup_u8(0));\n\n        all_lower = all_lower && svptest_any(pg, is_lower);\n        all_upper = all_upper && svptest_any(pg, is_upper);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b32(0, len);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)(key.c_str() + i));\n            svbool_t lower_mask = svcmpeq_u8(pg, chars, svdup_u8('a'));\n            svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A'));\n\n            all_lower &= svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('a'))) || svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('A')));\n            all_upper &= svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('A'))) || svptest_any(pg, svcmplt_u8(pg, chars, svdup_u8('Z')));\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b32(0, len);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)(key.c_str() + i));\n            svbool_t lower_mask = svcmpeq_u8(pg, chars, svdup_u8('a'));\n            svbool_t upper_mask = svcmpeq_u8(pg, chars, svdup_u8('A'));\n            svbool_t is_lower = svorr(pg, svcmplt_u8(pg, chars, svdup_u8('a')), svcmplt_u8(pg, chars, svdup_u8('A')));\n            svbool_t is_upper = svorr(pg, svcmplt_u8(pg, chars, svdup_u8('A')), svcmplt_u8(pg, chars, svdup_u8('Z')));\n\n            all_lower = all_lower && svptest_any(pg, is_lower);\n            all_upper = all_upper && svptest_any(pg, is_upper);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b32(0, len);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t key_vec = svld1_u8(pg, (const uint8_t*)(key.c_str() + i));\n            svbool_t lower_mask = svcmpeq_u8(pg, key_vec, svdup_u8('a'));\n            svbool_t upper_mask = svcmpeq_u8(pg, key_vec, svdup_u8('A'));\n            svbool_t digit_mask = svcmpeq_u8(pg, key_vec, svdup_u8('0'));\n\n            all_lower &= svptest_any(pg, svorr_u8(pg, lower_mask, svcmplt_u8(pg, key_vec, svdup_u8('a'))));\n            all_upper &= svptest_any(pg, svorr_u8(pg, upper_mask, svcmplt_u8(pg, key_vec, svdup_u8('A'))));\n            all_lower &= !svptest_any(pg, digit_mask);\n            all_upper &= !svptest_any(pg, digit_mask);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t indices = svindex(0, 32);\n    svint32_t results = svdup_n_s32(0);\n    \n    for (int i = 2; i < n; i += 32) {\n        svint32_t candidates = svadd_n_s32(svdup_n_s32(i), indices);\n        svbool_t mask = svlt_u32(candidates, svdup_n_u32(n));\n        \n        for (int j = 0; j < 32; ++j) {\n            if (mask.bits & (1 << j)) {\n                int candidate = svget3_s32(candidates, j);\n                if (is_prime(candidate)) {\n                    primes.push_back(candidate);\n                }\n            }\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    svbool_t pg = svptrue_b32();\n    int count = 0;\n\n    for (int i = 2; i < n; i += svcntw()) {\n        svuint32_t indices = svindex_u32(i, svcntw());\n        svbool_t mask = svlt_u32(pg, indices, n);\n        svuint32_t candidates = svadd_u32(svdup_u32(i), svindex_u32(0, svcntw()));\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (mask[j] && is_prime(candidates[j])) {\n                primes.push_back(candidates[j]);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    svint32_t sieve = svdup_n_s32(1); // Initialize sieve to 1 (true)\n\n    for (int i = 2; i < n; ++i) {\n        svint32_t idx = svdup_n_s32(i);\n        svbool_t mask = svlt_b32(pg, idx, svdup_n_s32(n));\n        svint32_t is_prime = svand_s32(sieve, mask);\n\n        if (svptest_any(mask, is_prime)) {\n            primes.push_back(i);\n            // Mark multiples of i as non-prime\n            for (int j = i * 2; j < n; j += i) {\n                sieve = svand_s32(sieve, svdup_n_s32(0), sveq_b32(svdup_n_s32(j), svdup_n_s32(j)));\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    svint32_t candidates = svdup_n_s32(2);\n    \n    for (int i = 2; i < n; i += svcntb()) {\n        svint32_t vec = svadd_n_s32(candidates, i);\n        svbool_t mask = svlt(pg, vec, svdup_n_s32(n));\n        \n        for (int j = 0; j < svcntb(); j++) {\n            if (mask[j]) {\n                int candidate = vec[j];\n                bool is_prime = true;\n\n                for (int k = 2; k * k <= candidate; k++) {\n                    if (candidate % k == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n\n                if (is_prime) {\n                    primes.push_back(candidate);\n                }\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    svuint32_t sieve = svdup_u32(1); // Initialize sieve with 1 (true)\n\n    for (int i = 2; i < n; i++) {\n        if (svptest_any(pg, svdup_u32(i))) {\n            // Check if i is prime\n            for (int j = 2; j * j < n; j++) {\n                if (i % j == 0) {\n                    sieve = svand_u32(sieve, svdup_u32(0)); // Mark as not prime\n                    break;\n                }\n            }\n        }\n        if (svptest_any(pg, sieve)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b32(0, len / 2); // Create a predicate for even indices\n\n    for (size_t i = 0; i < len; i += SVECTOR_LENGTH) {\n        svuint8_t indices = svadd_u8(svdup_u8(i), svdup_u8(0)); // Even indices\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(s.c_str() + i)); // Load characters\n\n        svbool_t is_upper = svcmpeq_u8(chars, svdup_u8('A')) | svcmpeq_u8(chars, svdup_u8('E')) |\n                            svcmpeq_u8(chars, svdup_u8('I')) | svcmpeq_u8(chars, svdup_u8('O')) |\n                            svcmpeq_u8(chars, svdup_u8('U'));\n\n        count += svcntb(pg, is_upper); // Count the number of true predicates\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t vowels_mask = svdup_u8('A') | svdup_u8('E') | svdup_u8('I') | svdup_u8('O') | svdup_u8('U');\n    \n    for (i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (const uint8_t *)(s.c_str() + i));\n        svbool_t even_indices = svindex_b8(pg, 0, 2);\n        svuint8_t even_data = svand_u8(even_indices, data);\n        \n        svbool_t is_upper = svcmpeq_u8(even_data, svdup_u8('A')) | svcmpeq_u8(even_data, svdup_u8('E')) |\n                            svcmpeq_u8(even_data, svdup_u8('I')) | svcmpeq_u8(even_data, svdup_u8('O')) |\n                            svcmpeq_u8(even_data, svdup_u8('U'));\n        \n        count += svaddv_u8(svptrue_b8(), svreinterpret_u8(is_upper));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i;\n\n    svbool_t pg = svwhilelt_b32(0, len / 2); // Create a predicate for even indices\n    svint32_t indices = svindex(0, 2); // Generate indices 0, 2, 4, ...\n\n    for (i = 0; i < len; i += 2 * SVECTOR_LENGTH) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        svbool_t is_upper = svcmpeq_u8(chars, svdup_u8('A')) | \n                            svcmpeq_u8(chars, svdup_u8('E')) | \n                            svcmpeq_u8(chars, svdup_u8('I')) | \n                            svcmpeq_u8(chars, svdup_u8('O')) | \n                            svcmpeq_u8(chars, svdup_u8('U'));\n\n        count += svcntb(pg & is_upper); // Count the number of true values\n        pg = svwhilelt_b32(i + 2 * SVECTOR_LENGTH, len / 2); // Update predicate for next iteration\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i;\n\n    svbool_t pg = svwhilelt_b32(0, len / 2); // Create a predicate for even indices\n    svuint8_t indices = svindex_u8(0, 2); // Generate indices 0, 2, 4, ...\n\n    for (i = 0; i < len; i += 16) {\n        svuint8_t data = svld1_u8(pg, (const uint8_t *)(s.data() + i));\n        svuint8_t upper_mask = svdup_u8('A'); // Uppercase 'A'\n        svuint8_t upper_vowel_mask = svdup_u8('E'); // Uppercase 'E'\n        svuint8_t upper_I_mask = svdup_u8('I'); // Uppercase 'I'\n        svuint8_t upper_O_mask = svdup_u8('O'); // Uppercase 'O'\n        svuint8_t upper_U_mask = svdup_u8('U'); // Uppercase 'U'\n\n        svbool_t is_upper = svcmpeq_u8(data, upper_mask);\n        is_upper = svorr(is_upper, svcmpeq_u8(data, upper_vowel_mask));\n        is_upper = svorr(is_upper, svcmpeq_u8(data, upper_I_mask));\n        is_upper = svorr(is_upper, svcmpeq_u8(data, upper_O_mask));\n        is_upper = svorr(is_upper, svcmpeq_u8(data, upper_U_mask));\n\n        count += svcntb(is_upper);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t length = s.length();\n    size_t vector_length = svcntb(); // Number of bytes in a vector\n    size_t i;\n\n    for (i = 0; i < length; i += vector_length) {\n        svuint8_t vec = svld1_u8(s.data() + i);\n        svuint8_t mask_even_indices = svdup_u8(0x01); // Mask for even indices\n        svuint8_t indices = svindex_u8(0, vector_length);\n        svuint8_t even_mask = svand_u8(mask_even_indices, indices);\n        \n        svuint8_t upper_mask = svdup_u8(0x20); // Mask to check for uppercase\n        svuint8_t vowels_mask = svdup_u8(0x0); // Mask for vowels A, E, I, O, U\n\n        // Check for uppercase vowels\n        svuint8_t is_upper = svand_u8(vec, upper_mask);\n        svuint8_t is_vowel = svorr_u8(sveq_u8(vec, svdup_u8('A')), \n                                       svorr_u8(sveq_u8(vec, svdup_u8('E')),\n                                       svorr_u8(sveq_u8(vec, svdup_u8('I')),\n                                       svorr_u8(sveq_u8(vec, svdup_u8('O')),\n                                       sveq_u8(vec, svdup_u8('U'))))));\n        \n        // Combine masks\n        svuint8_t final_mask = svand_u8(is_upper, is_vowel);\n        final_mask = svand_u8(final_mask, even_mask);\n\n        // Count the number of set bits in final_mask\n        count += svpopcnt_u8(final_mask);\n    }\n\n    // Handle any remaining characters\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    svint32_t indices = svindex(0, 1);\n    svint32_t base_stones = svdup_n_s32(n);\n    svint32_t odd_increment = svdup_n_s32(2);\n    svint32_t even_increment = svdup_n_s32(2);\n    \n    for (int i = 0; i < levels; i += svcntw()) {\n        svint32_t current_indices = svadd_s32(indices, svdup_n_s32(i));\n        svint32_t current_stones = svadd_s32(base_stones, svmul_s32(current_indices, (n % 2 == 0) ? even_increment : odd_increment));\n        \n        svst1_u32(svindex(0, 1), (uint32_t*)&stones[i], current_stones);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> result(levels);\n    \n    svint32_t indices = svindex(0, 1);\n    svint32_t base = svdup_n_s32(n);\n    \n    svint32_t stones = base;\n    for (int i = 0; i < levels; i += svcntw()) {\n        svint32_t odd_even = svadd_s32(stones, svdup_n_s32(i % 2 == 0 ? 0 : 2));\n        svst1(svptrue_b32(), &result[i], odd_even);\n        stones = svadd_s32(stones, svdup_n_s32(2));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    svint32_t indices = svindex(0, 1);\n    svint32_t base = svdup_n_s32(n);\n    svint32_t increment = svdup_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < levels; i += svcntw()) {\n        svint32_t level_indices = svadd_s32(indices, svdup_n_s32(i));\n        svint32_t current_stones = svadd_s32(base, svmul_s32(level_indices, increment));\n        svst1_u32(svindex(0, 1), (uint32_t*)&stones[i], current_stones);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    svint32_t idx = svindex(0, 1);\n    svint32_t base = svdup_n_s32(n);\n    svint32_t increment = svdup_n_s32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < levels; i += svcntw()) {\n        svint32_t current_idx = svadd_s32(idx, svdup_n_s32(i));\n        svint32_t current_stones = svadd_s32(base, svmul_s32(current_idx, increment));\n        svst1_s32(svptrue_b32(), &stones[i], current_stones);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    int levels = n;\n    std::vector<int> stones(levels);\n    \n    svint32_t idx = svindex(0, 1);\n    svint32_t base = svdup_n_s32(n);\n    svint32_t increment = svdup_n_s32(2);\n    \n    for (int i = 0; i < levels; i += svcntw()) {\n        svint32_t current_idx = svadd_s32(idx, svdup_n_s32(i));\n        svint32_t current_stones = svadd_s32(base, svmul_s32(increment, current_idx));\n        \n        svst1_u32(svindex(i, 1), (uint32_t*)stones.data(), current_stones);\n    }\n    \n    return stones;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_m = svdup_n_s64(m);\n    svint64_t vec_sum = svdup_n_s64(0);\n    svint64_t vec_count = svdup_n_s64(count);\n\n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svld1_s64(&i);\n        vec_sum = svadd_s64(vec_sum, vec_i);\n    }\n\n    sum += svaddv_s64(vec_sum);\n    int64_t avg = sum / count;\n\n    return std::to_string(avg);\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_m = svdup_n_s64(m);\n    svint64_t vec_sum = svdup_n_s64(0);\n    \n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svld1_s64(&i);\n        vec_sum = svadd_s64(vec_sum, vec_i);\n    }\n\n    sum += svaddv_s64(vec_sum);\n    int64_t avg = sum / count;\n    \n    // Rounding down\n    if (sum % count != 0) {\n        avg = (sum < 0) ? (avg - 1) : avg;\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_m = svdup_n_s64(m);\n    svint64_t vec_sum = svdup_n_s64(0);\n    \n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svld1_s64(&i);\n        vec_sum = svadd_s64(vec_sum, vec_i);\n    }\n\n    sum += svaddv_s64(vec_sum);\n    \n    int64_t avg = sum / count;\n    if (sum % count != 0) {\n        avg += (sum > 0) ? 1 : 0;\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary.insert(binary.begin(), (avg % 2) + '0');\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_m = svdup_n_s64(m);\n    svint64_t vec_sum = svdup_n_s64(0);\n    svint64_t vec_count = svdup_n_s64(0);\n    \n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svld1_s64(&i);\n        vec_sum = svadd_s64(vec_sum, vec_i);\n        vec_count = svadd_s64(vec_count, svdup_n_s64(1));\n    }\n\n    sum += svaddv_s64(vec_sum);\n    count += svaddv_s64(vec_count);\n\n    int64_t avg = sum / count;\n    if (sum % count != 0) {\n        avg = (sum < 0) ? (avg - 1) : avg; // round down\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_m = svdup_n_s64(m);\n    svint64_t vec_sum = svdup_n_s64(0);\n    svint64_t vec_count = svdup_n_s64(0);\n    \n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svld1_s64(&i);\n        vec_sum = svadd_s64(vec_sum, vec_i);\n        vec_count = svadd_s64(vec_count, svdup_n_s64(1));\n    }\n\n    sum += svaddv_s64(vec_sum);\n    count += svaddv_s64(vec_count);\n\n    int64_t avg = sum / count;\n    if (sum % count != 0) {\n        avg += (sum > 0) ? 1 : 0;\n    }\n\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int vl = svcntb(); // Vector length in bytes\n    int num_vectors = (n + vl - 1) / vl;\n\n    for (int v = 0; v < num_vectors; v++) {\n        svuint64_t indices = svindex_u64(v * vl + 1, vl); // Indices from 1 to n\n        svuint64_t even_mask = svcmpeq_u64(svdup_u64(0), svand_u64(indices, svdup_u64(1))); // Even indices mask\n\n        svuint64_t factorial = svdup_u64(1);\n        svuint64_t sum = svdup_u64(0);\n        for (int i = 1; i <= vl; i++) {\n            svuint64_t current_index = svadd_u64(indices, svdup_u64(i - 1));\n            svuint64_t current_factorial = svdup_u64(1);\n            for (int j = 1; j <= i; j++) {\n                current_factorial = svmul_u64(current_factorial, current_index);\n                current_index = svsub_u64(current_index, svdup_u64(1));\n            }\n            factorial = svmlt_u64(even_mask, current_factorial, svdup_u64(10000));\n            sum = svadd_u64(sum, svdup_u64(i));\n        }\n\n        svuint64_t result_vector = svsel_u64(even_mask, factorial, sum);\n        svst1_u64(result.data() + v * vl, result_vector);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int vl = svcntw(); // Vector length for 32-bit integers\n    int i = 1;\n\n    for (; i <= n - vl; i += vl) {\n        svuint32_t indices = svindex_u32(i, vl);\n        svuint32_t factorials = svdup_u32(1);\n        svuint32_t sums = svmul_u32(svdup_u32(0), indices);\n\n        for (int j = 1; j <= i + vl - 1; j++) {\n            svuint32_t mask = svcmpeq_u32(svdup_u32(j), indices);\n            factorials = svmla_u32(factorials, mask, svdup_u32(j));\n            sums = svadd_u32(sums, mask);\n        }\n\n        svuint32_t results = svorr_u32(svdup_u32(10000), svdup_u32(0));\n        for (int j = 0; j < vl; j++) {\n            int idx = i + j;\n            if (idx % 2 == 0) {\n                results = svdup_u32(svget_u32(factorials, j) % 10000);\n            } else {\n                results = svdup_u32(svget_u32(sums, j));\n            }\n            result[idx - 1] = svget_u32(results, j);\n        }\n    }\n\n    for (; i <= n; i++) {\n        if (i % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i - 1] = fact;\n        } else {\n            result[i - 1] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int vector_length = svcntb(); // Get the number of bytes in a vector\n    int num_vectors = (n + vector_length - 1) / vector_length; // Calculate number of vectors needed\n\n    for (int v = 0; v < num_vectors; v++) {\n        svuint8_t indices = svindex_u8(v * vector_length + 1, vector_length); // Create indices starting from 1\n        svuint8_t is_even = svand_u8(svdup_u8(1), svshl_u8(indices, 1)); // Check if index is even\n\n        svuint8_t factorial = svdup_u8(1);\n        svuint8_t sum = svdup_u8(0);\n        svuint8_t i = indices;\n\n        for (int j = 1; j <= vector_length; j++) {\n            svuint8_t current = svdup_u8(j);\n            factorial = svmul_u8(factorial, current); // Calculate factorial\n            sum = svadd_u8(sum, current); // Calculate sum\n        }\n\n        factorial = svmod_u8(factorial, svdup_u8(10000)); // Modulo 10000\n\n        // Select between factorial and sum based on even/odd\n        svuint8_t result_vector = svsel_u8(is_even, factorial, sum);\n\n        // Store results\n        svst1_u8(svindex_u8(v * vector_length, vector_length), result_vector);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int vector_length = svcntb(); // Get the number of bytes in a vector\n    int num_vectors = (n + vector_length - 1) / vector_length; // Calculate number of vectors needed\n\n    for (int v = 0; v < num_vectors; ++v) {\n        svuint8_t indices = svindex_u8(v * vector_length + 1, vector_length);\n        svuint8_t is_even = svand_u8(svlsr_u8(indices, 1), svdup_u8(1)); // Check if index is even\n\n        svuint8_t factorial = svdup_u8(1);\n        svuint8_t sum = svdup_u8(0);\n        for (int i = 1; i <= vector_length; ++i) {\n            svuint8_t current_index = svadd_u8(indices, svdup_u8(i - 1));\n            factorial = svmul_u8(factorial, current_index);\n            sum = svadd_u8(sum, current_index);\n        }\n\n        svuint8_t result_vector = svdup_u8(0);\n        result_vector = svifthen_u8(is_even, svmod_u8(factorial, svdup_u8(10000)), sum);\n\n        // Store results\n        svst1_u8(svindex_u8(v * vector_length, vector_length), result_vector);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int vl = svcntb(); // Vector length in bytes\n    int num_vectors = (n + vl - 1) / vl;\n\n    for (int v = 0; v < num_vectors; v++) {\n        svuint8_t indices = svindex_u8(v * vl + 1, vl);\n        svuint8_t even_mask = svreinterpret_u8(svdup_u32(0xAAAAAAAA)); // Mask for even indices\n        svuint8_t odd_mask = svreinterpret_u8(svdup_u32(0x55555555)); // Mask for odd indices\n\n        svuint8_t factorial = svdup_u8(1);\n        svuint8_t sum = svdup_u8(0);\n        svuint8_t i = indices;\n\n        for (int j = 1; j <= vl; j++) {\n            svuint8_t current = svdup_u8(j);\n            factorial = svmul_u8(factorial, current);\n            sum = svadd_u8(sum, current);\n        }\n\n        svuint8_t factorial_mod = svmod_u8(factorial, svdup_u8(10000));\n        svuint8_t result_vector = svorr_u8(svand_u8(even_mask, factorial_mod), svand_u8(odd_mask, sum));\n\n        svst1_u8(svindex_u8(v * vl + 1, vl), result_vector, result.data() + v * vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svwhilelt_b32(1, n + 1);\n    svint32_t count_even = svdup_s32(0);\n    svint32_t count_odd = svdup_s32(0);\n\n    for (int i = 1; i <= n; i += svcntb()) {\n        svint32_t indices = svld1_u32(pg, (const uint32_t*)&i);\n        svbool_t valid = svwhilelt_b32(i, n + 1);\n        \n        for (int j = 0; j < svcntb(); j++) {\n            if (valid[j]) {\n                int num = svget1_s32(indices, j);\n                int reversed = 0, original = num;\n\n                while (num > 0) {\n                    reversed = reversed * 10 + num % 10;\n                    num /= 10;\n                }\n\n                if (original == reversed) {\n                    if (original % 2 == 0) {\n                        count_even = svadd_s32(count_even, svdup_s32(1));\n                    } else {\n                        count_odd = svadd_s32(count_odd, svdup_s32(1));\n                    }\n                }\n            }\n        }\n    }\n\n    int even_count = svaddv_s32(svptrue_b32(), count_even);\n    int odd_count = svaddv_s32(svptrue_b32(), count_odd);\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svwhilelt_b32(1, n + 1);\n    svint32_t counts = svdup_n_s32(0);\n    \n    for (int i = 1; i <= n; i += svcntb()) {\n        svint32_t idx = svadd_n_s32(svdup_n_s32(i), 0);\n        svbool_t mask = svwhilelt_b32(idx, n + 1);\n        \n        svint32_t palindromes = svdup_n_s32(0);\n        svint32_t even_count = svdup_n_s32(0);\n        svint32_t odd_count = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntb(); j++) {\n            if (mask[j]) {\n                int num = i + j;\n                int reversed = 0, original = num;\n                while (num > 0) {\n                    reversed = reversed * 10 + num % 10;\n                    num /= 10;\n                }\n                if (original == reversed) {\n                    palindromes = svadd_n_s32(palindromes, 1);\n                    if (original % 2 == 0) {\n                        even_count = svadd_n_s32(even_count, 1);\n                    } else {\n                        odd_count = svadd_n_s32(odd_count, 1);\n                    }\n                }\n            }\n        }\n        \n        counts = svadd_s32(counts, svadd_s32(even_count, odd_count));\n    }\n    \n    int even = svadd_s32(svget1_s32(counts), 0);\n    int odd = svadd_s32(svget1_s32(counts), 1);\n    \n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t even_count = svdup_s32(0);\n    svint32_t odd_count = svdup_s32(0);\n\n    for (int i = 1; i <= n; i += svcntb()) {\n        svint32_t indices = svld1(pg, (const int32_t*)&i);\n        svbool_t mask = svlt_u32(indices, svdup_u32(n + 1));\n\n        for (int j = 0; j < svcntb(); j++) {\n            if (mask[j]) {\n                int num = i + j;\n                int rev = 0, original = num;\n\n                while (num > 0) {\n                    rev = rev * 10 + num % 10;\n                    num /= 10;\n                }\n\n                if (original == rev) {\n                    if (original % 2 == 0) {\n                        even_count = svadd_s32(even_count, svdup_s32(1));\n                    } else {\n                        odd_count = svadd_s32(odd_count, svdup_s32(1));\n                    }\n                }\n            }\n        }\n    }\n\n    int even_result = svaddv_s32(pg, even_count);\n    int odd_result = svaddv_s32(pg, odd_count);\n\n    return {even_result, odd_result};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_palindrome(int num) {\n    int reversed = 0, original = num;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return original == reversed;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t counts = svdup_n_s32(0);\n    \n    for (int i = 1; i <= n; i += svcntb()) {\n        svint32_t indices = svld1(pg, (const int32_t*)&i);\n        svbool_t mask = svlt(pg, indices, svdup_n_s32(n + 1));\n\n        for (int j = 0; j < svcntb(); j++) {\n            if (mask[j]) {\n                int num = i + j;\n                if (is_palindrome(num)) {\n                    if (num % 2 == 0) {\n                        counts = svadd_s32(counts, svdup_n_s32(1));\n                    } else {\n                        counts = svadd_s32(counts, svdup_n_s32(2));\n                    }\n                }\n            }\n        }\n    }\n\n    int even_count = svget4_s32(counts, 0);\n    int odd_count = svget4_s32(counts, 1);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    svbool_t pg = svwhilelt_b32(1, n + 1);\n    for (int i = 1; i <= n; i += svcntb()) {\n        svuint32_t indices = svld1_u32(pg, (const uint32_t*)&i);\n        svuint32_t palindromes = svdup_u32(0);\n\n        for (int j = 0; j < svcntb(); j++) {\n            if (svindex_u32(indices, j) > n) break;\n            int num = svindex_u32(indices, j);\n            int rev = 0, original = num;\n\n            while (num > 0) {\n                rev = rev * 10 + num % 10;\n                num /= 10;\n            }\n\n            if (original == rev) {\n                palindromes = svadd_u32(palindromes, svdup_u32(1));\n                if (original % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n        pg = svwhilelt_b32(i + svcntb(), n + 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t length = n.size();\n    svint32_t sum_digits = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        svint32_t vec = svld1(pg, &n[i]);\n        svint32_t digits_sum = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntb(); ++j) {\n            if (i + j < length) {\n                int num = n[i + j];\n                while (num != 0) {\n                    digits_sum = svadd_s32(digits_sum, svdup_n_s32(num % 10));\n                    num /= 10;\n                }\n            }\n        }\n\n        pg = svwhilelt_b32(i, length);\n        sum_digits = svadd_s32(sum_digits, digits_sum);\n    }\n\n    for (int j = 0; j < svcntb(); ++j) {\n        if (j < length && svget4_s32(sum_digits, j) > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    svint32_t vec_count = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svint32_t vec_nums = svld1_s32(&n[i]);\n        svint32_t vec_sums = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntb(); ++j) {\n            int num = svget3_s32(vec_nums, j);\n            if (num != 0) {\n                vec_sums = svadd_s32(vec_sums, svdup_n_s32(sum_of_digits(num)));\n            }\n        }\n        \n        svint32_t vec_mask = svgt_s32(vec_sums, svdup_n_s32(0));\n        vec_count = svadd_s32(vec_count, svcntb(vec_mask));\n    }\n    \n    count += svaddv_s32(vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t length = n.size();\n    svint32_t vec_count = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint32_t vec_nums = svld1_s32(&n[i]);\n        svint32_t vec_sums = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntw(); ++j) {\n            int num = svget4_s32(vec_nums, j);\n            if (num != 0) {\n                vec_sums = svadd_s32(vec_sums, svdup_n_s32(sum_of_digits(num)));\n            }\n        }\n        \n        svbool_t pg = svptrue_b32();\n        vec_count = svadd_s32(vec_count, svcmpeq_s32(pg, vec_sums, svdup_n_s32(0)));\n    }\n    \n    count += svaddv_s32(svptrue_b32(), vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    svint32_t vec_count = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svint32_t vec_nums = svld1_s32(&n[i]);\n        svint32_t vec_sums = svdup_n_s32(0);\n        \n        for (int j = 0; j < svcntb(); ++j) {\n            int num = svget3_s32(vec_nums, j);\n            if (num != 0) {\n                vec_sums = svadd_s32(vec_sums, svdup_n_s32(sum_of_digits(num)));\n            }\n        }\n        \n        svint32_t mask = svgt_s32(vec_sums, svdup_n_s32(0));\n        vec_count = svadd_s32(vec_count, svcntb(mask));\n    }\n    \n    count += svaddv_s32(vec_count);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_of_digits(int num) {\n    int sum = 0;\n    num = abs(num);\n    while (num > 0) {\n        sum += num % 10;\n        num /= 10;\n    }\n    return sum;\n}\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t length = n.size();\n    size_t vector_length = svcntw(); // Number of 32-bit integers in a vector\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        svuint32_t vec = svld1_u32(&n[i]);\n        svuint32_t mask = svdup_u32(0);\n        \n        for (size_t j = 0; j < vector_length && (i + j) < length; ++j) {\n            int digit_sum = sum_of_digits(n[i + j]);\n            if (digit_sum > 0) {\n                mask = svorr_u32(mask, svdup_u32(1 << j));\n            }\n        }\n\n        count += svcntb(svdup_u8(mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create a SVE vector from the array\n    svint32_t vec = svld1_s32(svindex(0, N), arr.data());\n\n    // Find the minimum and maximum elements\n    int min_val = *std::min_element(arr.begin(), arr.end());\n    int max_val = *std::max_element(arr.begin(), arr.end());\n\n    // Check if the sorted array can be obtained by right shifts\n    for (size_t shift = 0; shift < N; ++shift) {\n        svint32_t shifted_vec = svext_s32(vec, vec, shift);\n        std::vector<int> shifted_arr(N);\n        svst1_s32(shifted_arr.data(), shifted_vec);\n\n        if (std::is_sorted(shifted_arr.begin(), shifted_arr.end())) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    svint32_t vec = svld1_s32(svptrue_b32(), arr.data());\n    svint32_t sorted_vec = svdup_s32(0);\n    \n    // Sort the array using SVE\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Load sorted array into SVE vector\n    sorted_vec = svld1_s32(svptrue_b32(), sorted_arr.data());\n\n    // Check if any rotation of arr matches sorted_arr\n    for (int shift = 0; shift < N; ++shift) {\n        svint32_t rotated_vec = svext_s32(vec, vec, shift);\n        if (svwhilelt_b32(rotated_vec, sorted_vec)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int64_t min_val = *std::min_element(arr.begin(), arr.end());\n    int64_t max_val = *std::max_element(arr.begin(), arr.end());\n\n    svint32_t vec_min = svdup_n_s32(min_val);\n    svint32_t vec_max = svdup_n_s32(max_val);\n    \n    svint32_t vec_arr = svld1_s32(svptrue_b32(), arr.data());\n    \n    svbool_t mask = svcmpeq_s32(svptrue_b32(), vec_arr, vec_min);\n    svint32_t min_pos = svindex_s32(mask, 0);\n    \n    mask = svcmpeq_s32(svptrue_b32(), vec_arr, vec_max);\n    svint32_t max_pos = svindex_s32(mask, 0);\n\n    if (svptest_any(svptrue_b32(), svlt_s32(min_pos, max_pos))) {\n        return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    svint32_t vec = svld1_s32(svdup_n_u32(0), arr.data());\n    svint32_t sorted_vec = svdup_n_s32(arr[0]);\n    svint32_t min_val = sorted_vec;\n    svint32_t max_val = sorted_vec;\n\n    for (int i = 1; i < N; ++i) {\n        svint32_t current = svdup_n_s32(arr[i]);\n        min_val = svmin_s32(min_val, current);\n        max_val = svmax_s32(max_val, current);\n        sorted_vec = svuzp1_s32(sorted_vec, current);\n    }\n\n    svint32_t sorted_check = svuzp1_s32(min_val, max_val);\n    svbool_t is_sorted = svcmpeq(svuzp1_s32(sorted_check, sorted_vec), svdup_n_s32(0));\n\n    return svptest_any(is_sorted);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector of integers from the array\n    svint32_t vec = svld1_s32(svptrue_b32(), arr.data());\n\n    // Find the minimum and maximum values in the vector\n    svint32_t min_val = svminv_s32(vec, svptrue_b32());\n    svint32_t max_val = svmaxv_s32(vec, svptrue_b32());\n\n    // Check if the sorted array can be achieved by right shifts\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if the sorted array can be obtained by right shifts\n    for (size_t i = 0; i < N; ++i) {\n        svint32_t shifted_vec = svext_s32(vec, vec, 1); // Right shift\n        if (svptest_any(svptrue_b32(), svcmpeq_s32(shifted_vec, svld1_s32(svptrue_b32(), sorted_arr.data())))) {\n            return true;\n        }\n        vec = shifted_vec;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    svint32_t vec1 = svld1_s32(&lst1[0]);\n    svint32_t vec2 = svld1_s32(&lst2[0]);\n\n    svbool_t even_mask1 = sveq(svdup_n_s32(0), svand_n_s32(vec1, 1));\n    svbool_t even_mask2 = sveq(svdup_n_s32(0), svand_n_s32(vec2, 1));\n\n    int count_even1 = svcntb(svaddv(svdup_n_u8(0), even_mask1));\n    int count_odd1 = n - count_even1;\n\n    int count_even2 = svcntb(svaddv(svdup_n_u8(0), even_mask2));\n\n    if (count_odd1 <= count_even2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    svint32_t vec1, vec2;\n    svbool_t pg;\n\n    // Check if lst1 can be made all even\n    bool has_even_in_lst2 = false;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec1 = svld1(pg, &lst1[i]);\n        vec2 = svld1(pg, &lst2[i]);\n\n        // Check if there are any even numbers in lst2\n        has_even_in_lst2 |= svptest_any(pg, svcmpeq_n_s32(vec2, 0) | svcmpeq_n_s32(vec2, 2) | svcmpeq_n_s32(vec2, 4) | svcmpeq_n_s32(vec2, 6) | svcmpeq_n_s32(vec2, 8) | svcmpeq_n_s32(vec2, 10) | svcmpeq_n_s32(vec2, 12) | svcmpeq_n_s32(vec2, 14) | svcmpeq_n_s32(vec2, 16) | svcmpeq_n_s32(vec2, 18) | svcmpeq_n_s32(vec2, 20) | svcmpeq_n_s32(vec2, 22) | svcmpeq_n_s32(vec2, 24) | svcmpeq_n_s32(vec2, 26) | svcmpeq_n_s32(vec2, 28) | svcmpeq_n_s32(vec2, 30));\n    }\n\n    // Check if all elements in lst1 are even\n    bool all_even_in_lst1 = true;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec1 = svld1(pg, &lst1[i]);\n\n        // Check if all elements are even\n        all_even_in_lst1 &= svptest_all(pg, svcmpeq_n_s32(vec1, 0) | svcmpeq_n_s32(vec1, 2) | svcmpeq_n_s32(vec1, 4) | svcmpeq_n_s32(vec1, 6) | svcmpeq_n_s32(vec1, 8) | svcmpeq_n_s32(vec1, 10) | svcmpeq_n_s32(vec1, 12) | svcmpeq_n_s32(vec1, 14) | svcmpeq_n_s32(vec1, 16) | svcmpeq_n_s32(vec1, 18) | svcmpeq_n_s32(vec1, 20) | svcmpeq_n_s32(vec1, 22) | svcmpeq_n_s32(vec1, 24) | svcmpeq_n_s32(vec1, 26) | svcmpeq_n_s32(vec1, 28) | svcmpeq_n_s32(vec1, 30));\n    }\n\n    if (all_even_in_lst1 || has_even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    svint32_t vec1 = svld1_s32(&lst1[0]);\n    svint32_t vec2 = svld1_s32(&lst2[0]);\n\n    svbool_t even_mask1 = sveq(svdup_n_s32(0), svand_n_s32(vec1, 1));\n    svbool_t even_mask2 = sveq(svdup_n_s32(0), svand_n_s32(vec2, 1));\n\n    int count_even1 = svcntb(svaddv(svdup_n_u8(1), even_mask1));\n    int count_odd1 = n - count_even1;\n\n    int count_even2 = svcntb(svaddv(svdup_n_u8(1), even_mask2));\n\n    if (count_odd1 <= count_even2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    svint32_t vec1, vec2;\n    svbool_t pg;\n    \n    int even_count_lst1 = 0;\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec1 = svld1(pg, &lst1[i]);\n        vec2 = svld1(pg, &lst2[i]);\n\n        svbool_t is_even = svcmpeq_n_s32(pg, vec1, 0);\n        even_count_lst1 += svcntb(svaddv_b32(pg, is_even));\n\n        svbool_t is_odd = svcmpeq_n_s32(pg, vec1, 1);\n        odd_count_lst1 += svcntb(svaddv_b32(pg, is_odd));\n\n        even_count_lst2 += svcntb(svaddv_b32(pg, svcmpeq_n_s32(pg, vec2, 0)));\n    }\n\n    if (even_count_lst1 + even_count_lst2 >= n) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    svint32_t vec1 = svld1_s32(&lst1[0]);\n    svint32_t vec2 = svld1_s32(&lst2[0]);\n\n    svbool_t even_mask1 = sveq(svdup_n_s32(0), svand_n_s32(vec1, 1));\n    svbool_t even_mask2 = sveq(svdup_n_s32(0), svand_n_s32(vec2, 1));\n\n    int count_even1 = svcntb(svaddv(svdup_n_u8(0), even_mask1));\n    int count_odd1 = n - count_even1;\n\n    int count_even2 = svcntb(svaddv(svdup_n_u8(0), even_mask2));\n\n    if (count_odd1 <= count_even2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        svbool_t pg = svptrue_b8();\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t digits = svld1_u8(pg, (const uint8_t*)(str.c_str() + i));\n            svbool_t odd_mask = svcmpeq_u8(digits, svdup_u8('1')) | svcmpeq_u8(digits, svdup_u8('3')) |\n                                svcmpeq_u8(digits, svdup_u8('5')) | svcmpeq_u8(digits, svdup_u8('7')) |\n                                svcmpeq_u8(digits, svdup_u8('9'));\n            odd_count += svcntb(svaddv_u8(pg, odd_mask));\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) +\n                          \"n the str\" + std::to_string(odd_count) +\n                          \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &str = lst[i];\n        size_t len = str.length();\n        svuint8_t odd_count = svdup_u8(0);\n        \n        for (size_t j = 0; j < len; j += svcntb()) {\n            size_t remaining = len - j;\n            svuint8_t digits = svld1_u8((const uint8_t *)(str.c_str() + j));\n            svuint8_t is_odd = svand_u8(svdup_u8(1), svshl_n_u8(digits, 1));\n            odd_count = svadd_u8(odd_count, svcntb(svuzp_u8(is_odd, svdup_u8(0)).val[0]));\n        }\n        \n        uint8_t total_odd = svaddv_u8(odd_count);\n        result[i] = \"the number of odd elements \" + std::to_string(total_odd) + \n                     \"n the str\" + std::to_string(i) + \"ng \" + std::to_string(i) + \n                     \" of the \" + std::to_string(i) + \"nput.\";\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.size();\n        svbool_t pg = svptrue_b8();\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t digits = svld1_u8(pg, (const uint8_t*)(str.c_str() + i));\n            svbool_t odd_mask = svcmpeq_u8(digits, svdup_u8('1')) | \n                                svcmpeq_u8(digits, svdup_u8('3')) | \n                                svcmpeq_u8(digits, svdup_u8('5')) | \n                                svcmpeq_u8(digits, svdup_u8('7')) | \n                                svcmpeq_u8(digits, svdup_u8('9'));\n            odd_count += svcntb(svaddv_u8(pg, odd_mask));\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count \n            << \"n the str\" << odd_count << \"ng \" << odd_count \n            << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result(lst.size());\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string &str = lst[i];\n        size_t len = str.length();\n        svuint8_t odd_count = svdup_u8(0);\n        \n        for (size_t j = 0; j < len; j += svcntb()) {\n            size_t remaining = len - j;\n            svuint8_t digits = svld1_u8((const uint8_t *)(str.c_str() + j));\n            svuint8_t is_odd = svand_u8(svdup_u8(1), svshl_u8(digits, 1));\n            odd_count = svadd_u8(odd_count, svcntb(svcmpeq_u8(is_odd, svdup_u8(1))));\n        }\n\n        uint8_t count = svaddv_u8(odd_count);\n        result[i] = \"the number of odd elements \" + std::to_string(count) + \n                     \"n the str\" + std::to_string(i) + \n                     \"ng \" + std::to_string(i) + \n                     \" of the \" + std::to_string(i) + \"nput.\";\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        svbool_t pg = svptrue_b8();\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svuint8_t digits = svld1_u8(pg, (const uint8_t*)(str.c_str() + i));\n            svbool_t odd_mask = svcmpeq_u8(digits, svdup_u8('1')) | svcmpeq_u8(digits, svdup_u8('3')) |\n                                svcmpeq_u8(digits, svdup_u8('5')) | svcmpeq_u8(digits, svdup_u8('7')) |\n                                svcmpeq_u8(digits, svdup_u8('9'));\n            odd_count += svcntb(svaddv_u8(odd_mask));\n        }\n\n        std::ostringstream oss;\n        oss << \"the number of odd elements \" << odd_count << \"n the str\" << odd_count << \"ng \" << odd_count << \" of the \" << odd_count << \"nput.\";\n        result.push_back(oss.str());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    \n    svint64_t min_vec = svdup_n_s64(INT64_MAX);\n    svint64_t current_vec = svdup_n_s64(0);\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        size_t vl = svcntd();\n        svint64_t data_vec = svld1_s64(&nums[i]);\n        \n        current_vec = svadd_s64(current_vec, data_vec);\n        min_vec = svmin_s64(min_vec, current_vec);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n) {\n                current_sum += nums[i + j];\n                min_sum = std::min(min_sum, current_sum);\n                if (current_sum > 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n\n    int64_t min_vec_result = svminv_s64(min_vec);\n    return std::min(min_sum, min_vec_result);\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    \n    svint64_t min_vec = svdup_n_s64(INT64_MAX);\n    svint64_t current_vec = svdup_n_s64(0);\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        size_t vl = svcntd();\n        svint64_t data_vec = svld1_s64(&nums[i]);\n        \n        current_vec = svadd_s64(current_vec, data_vec);\n        min_vec = svmin_s64(min_vec, current_vec);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n) {\n                current_sum += nums[i + j];\n                min_sum = std::min(min_sum, current_sum);\n                if (current_sum > 0) {\n                    current_sum = 0;\n                }\n            }\n        }\n    }\n    \n    int64_t min_vec_result = svminv_s64(min_vec);\n    return std::min(min_sum, min_vec_result);\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    svint64_t min_vector = svdup_n_s64(std::numeric_limits<int64_t>::max());\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        size_t vl = svcntd();\n        svint64_t data = svld1_s64(&nums[i]);\n        \n        current_sum += svaddv_s64(data);\n        min_vector = svmin_s64(min_vector, data);\n        \n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        \n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return std::min(min_sum, svaddv_s64(min_vector));\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t length = nums.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(0, length);\n    svint64_t vec = svld1(pg, &nums[0]);\n\n    while (i < length) {\n        svint64_t current_vec = svld1(pg, &nums[i]);\n        current_sum += svaddv_s64(pg, current_vec);\n        min_sum = std::min(min_sum, current_sum);\n\n        svint64_t min_vec = svminv_s64(pg, current_vec);\n        min_sum = std::min(min_sum, svmax(svdup_n_s64(min_sum), min_vec));\n\n        current_sum = std::min(current_sum + svaddv_s64(pg, current_vec), 0LL);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    size_t n = nums.size();\n    svint64_t v_current_sum = svdup_n_s64(0);\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        size_t vl = svmin_u64(n - i, svcntd());\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_sum = svadd_s64(v_current_sum, v_nums);\n        current_sum = svaddv_s64(svptrue_b64(), v_current_sum);\n        min_sum = std::min(min_sum, current_sum);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            if (current_sum > 0) {\n                current_sum = 0;\n            }\n            current_sum += nums[i + j];\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_lowerings = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        svuint8_t water_units = svdup_u8(0);\n        for (int j = 0; j < cols; j += svcntb()) {\n            svuint8_t well_data = svld1_u8((const uint8_t*)&grid[i][j]);\n            water_units = svadd_u8(water_units, well_data);\n        }\n\n        uint8_t water_count[svcntb()];\n        svst1_u8(water_count, water_units);\n\n        for (int k = 0; k < svcntb(); k++) {\n            total_lowerings += (water_count[k] + capacity - 1) / capacity;\n        }\n    }\n\n    return total_lowerings;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_pulls = 0;\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n\n    for (size_t i = 0; i < rows; ++i) {\n        svuint8_t water_units = svdup_u8(0);\n        for (size_t j = 0; j < cols; j += svcntb()) {\n            svuint8_t well_data = svld1_u8((const uint8_t*)&grid[i][j]);\n            water_units = svadd_u8(water_units, well_data);\n        }\n        uint8_t water_count[svcntb()];\n        svst1_u8(water_count, water_units);\n\n        int total_water = 0;\n        for (size_t k = 0; k < svcntb(); ++k) {\n            total_water += water_count[k];\n        }\n        total_pulls += (total_water + capacity - 1) / capacity; // Ceiling division\n    }\n    return total_pulls;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_wells = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b32();\n        svuint32_t water_units = svdup_u32(0);\n\n        for (int j = 0; j < cols; j += svcntb()) {\n            svuint8_t well_data = svld1_u8(pg, &grid[i][j]);\n            water_units = svadd_u32(water_units, svreinterpret_u32(well_data));\n        }\n\n        uint32_t total_water = svaddv_u32(pg, water_units);\n        total_wells += (total_water + capacity - 1) / capacity; // Ceiling division\n    }\n\n    return total_wells;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_lowers = 0;\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n\n    for (size_t i = 0; i < rows; ++i) {\n        svuint8_t water_count = svdup_u8(0);\n        for (size_t j = 0; j < cols; j += svcntb()) {\n            svuint8_t bucket = svld1_u8((const uint8_t*)&grid[i][j]);\n            water_count = svadd_u8(water_count, bucket);\n        }\n        uint8_t water_sum[svcntb()];\n        svst1_u8(water_sum, water_count);\n        for (size_t k = 0; k < svcntb(); ++k) {\n            total_lowers += (water_sum[k] + capacity - 1) / capacity;\n        }\n    }\n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_operations = 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        svuint8_t water_count = svdup_u8(0);\n        for (int j = 0; j < cols; j += svcntb()) {\n            svuint8_t well_data = svld1_u8((const uint8_t*)&grid[i][j]);\n            water_count = svadd_u8(water_count, well_data);\n        }\n        \n        uint8_t water_array[svcntb()];\n        svst1_u8((uint8_t*)water_array, water_count);\n        \n        for (int k = 0; k < svcntb(); k++) {\n            total_operations += (water_array[k] + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    svint16_t sum_vec = svdup_n_s16(0);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t data = svld1_u16(pg, &lst[i]);\n        \n        svbool_t even_pos = svindex_b16(pg, 0, 2);\n        svint16_t odd_elements = svand_s16(data, svdup_n_s16(1));\n        \n        svint16_t selected_elements = svsel(even_pos, odd_elements, svdup_n_s16(0));\n        sum_vec = svadd_s16(sum_vec, selected_elements);\n    }\n    \n    sum += svaddv_s16(svptrue_b16(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    svint16_t sum_vec = svdup_n_s16(0);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint16_t data_vec = svld1_s16(svld1_u16(&lst[i]));\n        svbool_t mask = svwhilelt_b16(i, n);\n        \n        svint16_t even_pos_vec = svtbl(data_vec, svdup_n_u8(0, 2)); // Extract even positions\n        svbool_t odd_mask = svreinterpret_b16(svcmpeq_s16(even_pos_vec, svdup_n_s16(1))); // Check for odd numbers\n        \n        sum_vec = svadd_s16(sum_vec, svand_s16(even_pos_vec, odd_mask));\n    }\n    \n    sum += svaddv_s16(sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    svint16_t sum_vec = svdup_n_s16(0);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint16_t data_vec = svld1_s16(svptrue_b16(), &lst[i]);\n        svbool_t mask = svwhilelt_b16(i, n);\n        \n        svint16_t even_pos_vec = svuzp1_s16(data_vec, svdup_n_s16(0));\n        svbool_t odd_mask = svreinterpret_b16(svdup_n_u16(1));\n        svint16_t odd_elements = svand_s16(even_pos_vec, odd_mask);\n        \n        sum_vec = svadd_s16(sum_vec, svifelse(odd_mask, odd_elements, svdup_n_s16(0)));\n    }\n    \n    sum += svaddv_s16(svptrue_b16(), sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    svint16_t vec_sum = svdup_n_s16(0);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint16_t vec = svld1_s16(&lst[i]);\n        svbool_t mask = svwhilelt_b16(i, n);\n        \n        svint16_t even_pos_elements = svuzp1_s16(vec, svdup_n_s16(0));\n        svbool_t odd_mask = svreinterpret_b16(svdup_n_u16(1));\n        svint16_t odd_elements = svand_s16(even_pos_elements, odd_mask);\n        \n        svbool_t odd_elements_mask = svcmpeq_b16(odd_elements, svdup_n_s16(1));\n        vec_sum = svadd_s16(vec_sum, svifthenelse(odd_elements_mask, odd_elements, svdup_n_s16(0)));\n    }\n    \n    sum += svaddv_s16(vec_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svint16_t vec;\n    svbool_t pg;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        vec = svld1_s16(svptrue_b16(), &lst[i]);\n        pg = svwhilelt_b16(i, n);\n\n        svint16_t even_pos = svuzp1_s16(vec, svdup_s16(0)); // Get elements at even positions\n        svbool_t odd_mask = svcmpeq_b16(svrem_s16(even_pos, svdup_s16(2)), svdup_s16(1)); // Check for odd elements\n\n        sum += svaddv_s16(svsel(odd_mask, even_pos, svdup_s16(0))); // Sum odd elements at even positions\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    svint32_t total_sum = svdup_n_s32(0);\n    svbool_t pg;\n\n    for (; i <= k - 4; i += 4) {\n        svint32_t vec = svld1_u32(svwhilelt_b32(i, k), &arr[i]);\n        pg = svcmplt_s32(svwhilelt_b32(0, 4), vec, svdup_n_s32(100));\n        total_sum = svaddv_s32_m(pg, total_sum, vec);\n    }\n\n    for (; i < k; i++) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum + svaddv_s32(svptrue_b32(), total_sum);\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int n = std::min(k, static_cast<int>(arr.size()));\n    \n    svint32_t total_sum = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t mask = svlt_u32(vec, svdup_n_u32(100)); // Check for elements with at most two digits\n        svint32_t filtered = svand_s32(mask, vec);\n        total_sum = svadd_s32(total_sum, filtered);\n    }\n\n    // Horizontal addition of the vector\n    sum += svaddv_s32(svptrue_b32(), total_sum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    svint32_t total_sum = svdup_n_s32(0);\n    svbool_t pg;\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svint32_t data = svld1_s32(&arr[i]);\n        pg = svlt_u32(svindex_u32(i), svdup_n_u32(len));\n\n        svint32_t mask = svand_s32(pg, svgt_s32(data, svdup_n_s32(9)));\n        svint32_t filtered = svand_s32(mask, data);\n        \n        total_sum = svadd_s32(total_sum, filtered);\n    }\n\n    int32_t result[svcntb()];\n    svst1_s32(result, total_sum);\n    \n    for (int j = 0; j < svcntb(); j++) {\n        if (result[j] <= 99 && result[j] >= 0) {\n            sum += result[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    svint32_t total_sum = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svint32_t data = svld1(pg, &arr[i]);\n        svbool_t mask = svlt_b32(data, svdup_n_s32(100)); // Check for elements with at most two digits\n        total_sum = svaddv_s32(mask, total_sum, data);\n    }\n    \n    sum = svaddv_s32(pg, total_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, static_cast<int>(arr.size()));\n    \n    svint32_t total_sum = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t mask = svlt_b32(vec, svdup_n_s32(100)) & svgt_b32(vec, svdup_n_s32(-1));\n        total_sum = svaddv_s32(mask, total_sum, vec);\n        pg = svwhilelt_b32(i + svcntb(), len);\n    }\n    \n    sum += svaddv_s32(pg, total_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    svint32_t prev = svld1_s32(&lst[0]);\n    svbool_t sorted = svptrue_b32();\n    svbool_t has_duplicates = svptrue_b32();\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(&lst[i]);\n        svbool_t cmp = svcmplt_s32(curr, prev);\n        sorted = svand_b32(sorted, svnot_b32(cmp));\n\n        svbool_t dup = svcmpeq_s32(curr, prev);\n        has_duplicates = svand_b32(has_duplicates, svnot_b32(dup));\n\n        prev = curr;\n    }\n\n    return svptest_any(svand_b32(sorted, has_duplicates));\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    svint32_t prev = svld1_s32(&lst[0]);\n    svbool_t is_sorted = svptrue_b32();\n    svbool_t has_duplicates = svptrue_b32();\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(&lst[i]);\n        \n        // Check if current elements are less than or equal to previous elements\n        is_sorted = svand_b32(is_sorted, svcmple_s32(prev, curr));\n        \n        // Check for duplicates\n        has_duplicates = svand_b32(has_duplicates, svcmpeq_s32(prev, curr));\n        \n        prev = curr;\n    }\n\n    // Check if any of the comparisons failed\n    bool sorted = svptest_any(is_sorted);\n    bool duplicates = svptest_any(has_duplicates);\n\n    return sorted && !duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    svint32_t prev = svld1_s32(&lst[0]);\n    svbool_t sorted = svptrue_b32();\n    svbool_t has_duplicates = svptrue_b32();\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(&lst[i]);\n        \n        // Check if current elements are less than or equal to previous elements\n        sorted = svand_b32(sorted, svcmple_s32(curr, prev));\n        \n        // Check for duplicates\n        has_duplicates = svand_b32(has_duplicates, svcmpeq_s32(curr, prev));\n        \n        prev = curr;\n    }\n\n    // Check if sorted is true and has_duplicates is false\n    return svptest_any(sorted) && !svptest_any(has_duplicates);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    svint32_t vec_prev = svld1_s32(&lst[0]);\n    svbool_t pred = svptrue_b32();\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svint32_t vec_curr = svld1_s32(&lst[i]);\n        svbool_t cmp_pred = svcmpeq(pred, vec_curr, vec_prev);\n        if (svptest_any(pred, cmp_pred)) return false;\n\n        cmp_pred = svcmplt(pred, vec_curr, vec_prev);\n        if (svptest_any(pred, cmp_pred)) return false;\n\n        vec_prev = vec_curr;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    svint32_t prev = svld1_s32(&lst[0]);\n    svbool_t sorted = svptrue_b32();\n    svbool_t unique = svptrue_b32();\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(&lst[i]);\n        svbool_t cmp = svcmple_s32(curr, prev);\n        sorted = svand_b32(sorted, svnot_b32(cmp));\n\n        svbool_t dup = svcmpeq_s32(curr, prev);\n        unique = svand_b32(unique, svnot_b32(dup));\n\n        prev = curr;\n    }\n\n    return svptest_any(sorted) == 0 && svptest_any(unique) != 0;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int64_t sum_magnitudes = 0;\n    int64_t product_signs = 1;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svint32_t prod_vec = svdup_n_s32(1);\n    svbool_t pg;\n\n    size_t len = arr.size();\n    size_t i = 0;\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t data_vec = svld1(pg, &arr[i]);\n\n        svint32_t abs_vec = svabs_s32(data_vec);\n        sum_vec = svadd_s32(sum_vec, abs_vec);\n\n        svint32_t sign_vec = svdup_n_s32(1);\n        sign_vec = svorr_s32(sign_vec, svcmpeq_s32(data_vec, svdup_n_s32(0)));\n        sign_vec = svorr_s32(sign_vec, svcmplt_s32(data_vec, svdup_n_s32(0)));\n        sign_vec = svsub_s32(sign_vec, svdup_n_s32(1));\n\n        prod_vec = svmul_s32(prod_vec, sign_vec);\n    }\n\n    sum_magnitudes += svaddv_s32(svadd_u32(sum_vec, svdup_n_u32(0)));\n    product_signs *= svaddv_s32(svadd_u32(prod_vec, svdup_n_u32(0)));\n\n    for (; i < len; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        sum_magnitudes += std::abs(arr[i]);\n        product_signs *= sign;\n    }\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svint32_t prod_vec = svdup_n_s32(1);\n    \n    size_t len = arr.size();\n    size_t i = 0;\n\n    for (; i <= len - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(&arr[i]);\n        svint32_t signs = svsign_s32(vec);\n        \n        sum_vec = svadd_s32(sum_vec, svabs_s32(vec));\n        prod_vec = svmul_s32(prod_vec, signs);\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        sum_magnitudes += abs(arr[i]);\n        product_signs *= sign;\n    }\n\n    sum_magnitudes += svaddv_s32(sum_vec);\n    product_signs *= svaddv_s32(prod_vec);\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sum_magnitudes = 0;\n    int product_signs = 1;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svint32_t prod_vec = svdup_n_s32(1);\n    svbool_t pg = svptrue_b32();\n\n    size_t len = arr.size();\n    size_t i = 0;\n\n    for (; i <= len - svcntw(); i += svcntw()) {\n        svint32_t data_vec = svld1(pg, &arr[i]);\n        svint32_t abs_vec = svabs_s32(data_vec);\n        sum_vec = svadd_s32(sum_vec, abs_vec);\n\n        svint32_t sign_vec = svdup_n_s32(1);\n        sign_vec = svorr_s32(sign_vec, svcmpeq_s32(data_vec, svdup_n_s32(0)), svdup_n_s32(0));\n        sign_vec = svorr_s32(sign_vec, svcmplt_s32(data_vec, svdup_n_s32(0)), svdup_n_s32(-1));\n\n        prod_vec = svmul_s32(prod_vec, sign_vec);\n    }\n\n    sum_magnitudes += svaddv_s32(svadd_u32(svuzp1_u32(sum_vec), svuzp2_u32(sum_vec)));\n    product_signs *= svaddv_s32(svadd_u32(svuzp1_u32(prod_vec), svuzp2_u32(prod_vec)));\n\n    for (; i < len; ++i) {\n        int val = arr[i];\n        sum_magnitudes += abs(val);\n        if (val < 0) product_signs *= -1;\n        else if (val == 0) product_signs *= 0;\n    }\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int64_t sum_magnitudes = 0;\n    int64_t product_signs = 1;\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svint32_t prod_vec = svdup_n_s32(1);\n    svbool_t pg;\n\n    size_t len = arr.size();\n    size_t i = 0;\n\n    for (; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t data_vec = svld1(pg, &arr[i]);\n\n        sum_vec = svadd_s32(sum_vec, svabs_s32(data_vec));\n\n        svbool_t is_zero = svcmpeq_s32(pg, data_vec, svdup_n_s32(0));\n        svbool_t is_positive = svcmplt_s32(pg, data_vec, svdup_n_s32(0));\n        svbool_t is_negative = svcmpgt_s32(pg, data_vec, svdup_n_s32(0));\n\n        prod_vec = svmul_s32(prod_vec, svsel(is_zero, svdup_n_s32(0), svsel(is_positive, svdup_n_s32(1), svdup_n_s32(-1))));\n    }\n\n    sum_magnitudes += svaddv_s32(svptrue_b32(), sum_vec);\n    product_signs *= svaddv_s32(svptrue_b32(), prod_vec);\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int64_t sum_magnitude = 0;\n    int64_t product_sign = 1;\n\n    size_t n = arr.size();\n    size_t i = 0;\n\n    svint32_t vec_signs, vec_magnitudes;\n    svbool_t pg;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec_signs = svld1(pg, (const svint32_t*)&arr[i]);\n        vec_magnitudes = svabs_s32(vec_signs);\n\n        // Calculate product of signs\n        svint32_t zero_mask = svcmpeq_n_s32(vec_signs, 0);\n        svint32_t neg_mask = svcmplt_n_s32(vec_signs, 0);\n        product_sign = svaddv_s32(pg, svadd_s32(svdup_n_s32(1), svand_s32(zero_mask, svdup_n_s32(0))));\n        product_sign = svaddv_s32(pg, svand_s32(neg_mask, svdup_n_s32(-1)));\n\n        // Sum magnitudes\n        sum_magnitude += svaddv_s32(pg, vec_magnitudes);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n        product_sign *= (sign == 0) ? 0 : sign;\n        sum_magnitude += std::abs(arr[i]);\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    // Flatten the grid into a single array\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize SVE vectors\n    svuint32_t min_path = svdup_u32(0xFFFFFFFF); // Initialize with max values\n    svuint32_t indices = svdup_u32(0);\n\n    // Iterate over all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        svuint32_t current_path = svdup_u32(path[start]);\n        svuint32_t current_indices = svdup_u32(start);\n\n        // Perform k steps\n        for (int step = 0; step < k; ++step) {\n            svuint32_t neighbors[4];\n            int neighbor_count = 0;\n\n            // Get neighbors\n            if (start % N > 0) neighbors[neighbor_count++] = svdup_u32(path[start - 1]); // left\n            if (start % N < N - 1) neighbors[neighbor_count++] = svdup_u32(path[start + 1]); // right\n            if (start / N > 0) neighbors[neighbor_count++] = svdup_u32(path[start - N]); // up\n            if (start / N < N - 1) neighbors[neighbor_count++] = svdup_u32(path[start + N]); // down\n\n            // Find the minimum neighbor\n            for (int n = 0; n < neighbor_count; ++n) {\n                current_path = svmin_u32(current_path, neighbors[n]);\n            }\n        }\n\n        // Update the minimum path if the current path is better\n        min_path = svmin_u32(min_path, current_path);\n        indices = svmin_u32(indices, current_indices);\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = svget_u32(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> flat_grid(N * N);\n    \n    // Flatten the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path\n    svint32_t min_path = svdup_n_s32(INT32_MAX);\n    svint32_t current_path = svdup_n_s32(0);\n    \n    // Iterate over all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        svint32_t path_values = svdup_n_s32(0);\n        int path_length = 0;\n        int x = start / N;\n        int y = start % N;\n\n        // Perform a breadth-first search (BFS) or depth-first search (DFS) to find paths\n        std::vector<std::pair<int, int>> stack;\n        stack.emplace_back(x, y);\n        \n        while (!stack.empty() && path_length < k) {\n            auto [cur_x, cur_y] = stack.back();\n            stack.pop_back();\n            path_values = svadd_s32(path_values, svdup_n_s32(flat_grid[cur_x * N + cur_y]));\n            path_length++;\n\n            // Check neighbors\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (abs(dx) + abs(dy) == 1) { // Only orthogonal moves\n                        int new_x = cur_x + dx;\n                        int new_y = cur_y + dy;\n                        if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < N) {\n                            stack.emplace_back(new_x, new_y);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Compare paths lexicographically\n        if (svmin_s32(path_values) < svmin_s32(min_path)) {\n            min_path = path_values;\n        }\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = svget_n_s32(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    // Flatten the grid into a single vector\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize SVE vectors\n    svuint32_t min_path = svdup_u32(0xFFFFFFFF); // Initialize with max values\n    svuint32_t indices = svdup_u32(0);\n\n    // Iterate over all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        svuint32_t current_path = svdup_u32(path[start]);\n        svuint32_t current_indices = svdup_u32(start);\n\n        // Perform a breadth-first search (BFS) or depth-first search (DFS) to explore paths\n        for (int step = 1; step < k; ++step) {\n            svuint32_t next_path = svdup_u32(0xFFFFFFFF);\n            svuint32_t next_indices = svdup_u32(0);\n\n            // Explore neighbors\n            for (int d = -1; d <= 1; d += 2) {\n                int neighbor = start + d * N; // Up and Down\n                if (neighbor >= 0 && neighbor < N * N) {\n                    svuint32_t neighbor_value = svdup_u32(path[neighbor]);\n                    svuint32_t cmp = svcmpeq_u32(current_path, neighbor_value);\n                    next_path = svmin_u32(next_path, neighbor_value);\n                    next_indices = svorr_u32(next_indices, svand_u32(cmp, svdup_u32(neighbor)));\n                }\n                neighbor = start + d; // Left and Right\n                if (neighbor >= 0 && neighbor < N * N) {\n                    svuint32_t neighbor_value = svdup_u32(path[neighbor]);\n                    svuint32_t cmp = svcmpeq_u32(current_path, neighbor_value);\n                    next_path = svmin_u32(next_path, neighbor_value);\n                    next_indices = svorr_u32(next_indices, svand_u32(cmp, svdup_u32(neighbor)));\n                }\n            }\n\n            current_path = next_path;\n            current_indices = next_indices;\n        }\n\n        // Compare paths\n        min_path = svmin_u32(min_path, current_path);\n        indices = svorr_u32(indices, current_indices);\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = svget_u32(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> values(N * N);\n    \n    // Flatten the grid into a single vector\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            values[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize the minimum path values\n    svint32_t min_path = svdup_n_s32(INT32_MAX);\n    svint32_t current_path;\n\n    // Iterate through all possible starting points\n    for (int start = 0; start < N * N; ++start) {\n        current_path = svdup_n_s32(0);\n        int x = start / N;\n        int y = start % N;\n\n        // Perform a breadth-first search (BFS) or depth-first search (DFS) to find paths\n        for (int step = 0; step < k; ++step) {\n            svint32_t neighbors = svdup_n_s32(INT32_MAX);\n            int index = 0;\n\n            // Check the four possible directions\n            if (x > 0) neighbors = svmin_s32(neighbors, svdup_n_s32(grid[x - 1][y])); // Up\n            if (x < N - 1) neighbors = svmin_s32(neighbors, svdup_n_s32(grid[x + 1][y])); // Down\n            if (y > 0) neighbors = svmin_s32(neighbors, svdup_n_s32(grid[x][y - 1])); // Left\n            if (y < N - 1) neighbors = svmin_s32(neighbors, svdup_n_s32(grid[x][y + 1])); // Right\n\n            current_path = svadd_s32(current_path, neighbors);\n            min_path = svmin_s32(min_path, current_path);\n        }\n    }\n\n    // Store the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = svget_lane_s32(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> path(N * N);\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            path[i * N + j] = grid[i][j];\n        }\n    }\n\n    svint32_t min_path = svdup_n_s32(INT32_MAX);\n    svint32_t indices = svdup_n_s32(-1);\n    \n    for (int start = 0; start < N * N; ++start) {\n        svint32_t current_path = svdup_n_s32(0);\n        int current_length = 0;\n        int x = start / N, y = start % N;\n\n        for (int step = 0; step < k; ++step) {\n            if (current_length < k) {\n                current_path = svsetq_s32(current_length, path[start]);\n                current_length++;\n            }\n            // Move to neighbors\n            if (x > 0) current_path = svmin_s32(current_path, svsetq_s32(current_length, path[(x - 1) * N + y]));\n            if (x < N - 1) current_path = svmin_s32(current_path, svsetq_s32(current_length, path[(x + 1) * N + y]));\n            if (y > 0) current_path = svmin_s32(current_path, svsetq_s32(current_length, path[x * N + (y - 1)]));\n            if (y < N - 1) current_path = svmin_s32(current_path, svsetq_s32(current_length, path[x * N + (y + 1)]));\n        }\n\n        min_path = svmin_s32(min_path, current_path);\n        indices = svdup_n_s32(start);\n    }\n\n    for (int i = 0; i < k; ++i) {\n        result[i] = svget_s32(min_path, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digits[16];\n        int count = 0;\n\n        while (n > 0 && count < 16) {\n            digits[count++] = n % 10;\n            n /= 10;\n        }\n\n        svuint64_t vec_digits = svld1_u64(svindex(0, count), digits);\n        svuint64_t odd_mask = svcmpeq_u64(vec_digits, svdup_u64(1));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(3)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(5)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(7)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(9)));\n\n        svuint64_t odd_digits = svand_u64(vec_digits, odd_mask);\n        has_odd = svptest_any(svcmpeq_u64(odd_digits, svdup_u64(0)));\n\n        if (has_odd) {\n            product *= svreduce_mul_u64(odd_digits);\n        } else {\n            return 0;\n        }\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digits[16];\n        int count = 0;\n\n        // Extract digits\n        while (n > 0 && count < 16) {\n            digits[count++] = n % 10;\n            n /= 10;\n        }\n\n        svuint64_t vec_digits = svld1_u64(svindex_u64(0, count), digits);\n        svuint64_t odd_mask = svcmpeq_u64(vec_digits, svdup_u64(1));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(3)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(5)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(7)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(9)));\n\n        svuint64_t odd_digits = svand_u64(vec_digits, odd_mask);\n        svuint64_t zero_mask = svcmpeq_u64(odd_digits, svdup_u64(0));\n        has_odd = svptest_any(zero_mask);\n\n        if (has_odd) {\n            product *= svreduce_mul_u64(odd_digits);\n        } else {\n            return 0;\n        }\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digits[16];\n        int count = 0;\n\n        while (n > 0 && count < 16) {\n            digits[count++] = n % 10;\n            n /= 10;\n        }\n\n        svuint8_t vec_digits = svld1_u8(svindex_u8(0, count), (const uint8_t*)digits);\n        svuint8_t odd_mask = svand_u8(vec_digits, svdup_u8(1)); // Mask for odd digits\n        svuint8_t odd_digits = svand_u8(vec_digits, svdup_u8(0x55)); // Mask for odd digits (1, 3, 5, 7, 9)\n\n        svuint8_t product_vec = svdup_u8(1);\n        for (int i = 0; i < 8; i++) {\n            svuint8_t current_digits = svext_u8(odd_digits, odd_digits, i);\n            product_vec = svmul_u8(product_vec, current_digits);\n        }\n\n        uint8_t result[16];\n        svst1_u8(svindex_u8(0, 16), result, product_vec);\n        \n        for (int i = 0; i < 16; i++) {\n            if (result[i] != 0) {\n                product *= result[i];\n                has_odd = 1;\n            }\n        }\n\n        if (!has_odd) {\n            return 0;\n        }\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digits[16];\n        int count = 0;\n\n        while (n > 0 && count < 16) {\n            digits[count++] = n % 10;\n            n /= 10;\n        }\n\n        svuint64_t vec_digits = svld1_u64(&digits[0]);\n        svuint64_t odd_mask = svcmpeq_u64(vec_digits, svdup_u64(1));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(3)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(5)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(7)));\n        odd_mask = svorr_u64(odd_mask, svcmpeq_u64(vec_digits, svdup_u64(9)));\n\n        svuint64_t odd_digits = svand_u64(vec_digits, odd_mask);\n        has_odd = svptest_any(odd_mask);\n\n        if (has_odd) {\n            product *= svreduce_mul_u64(odd_digits);\n        } else {\n            return 0;\n        }\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n    \n    // Convert the number to a string to process each digit\n    char str[21]; // Enough to hold 64-bit integer as string\n    snprintf(str, sizeof(str), \"%llu\", n);\n    \n    // Load digits into SVE vector\n    int len = strlen(str);\n    svuint8_t digits = svdup_u8(0);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(&str[i]);\n        svuint8_t odd_mask = svand_u8(vec, svdup_u8(1)); // Mask to check odd digits\n        svuint8_t even_mask = svand_u8(vec, svdup_u8(2)); // Mask to check even digits\n        \n        // Check if there are any odd digits\n        has_odd = svaddv_u8(has_odd, svcmpeq_u8(odd_mask, svdup_u8(1)));\n        \n        // Multiply odd digits\n        svuint8_t odd_digits = svand_u8(vec, svdup_u8(0x0F)); // Mask to get digits 1, 3, 5, 7, 9\n        product *= svaddv_u8(odd_digits);\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svfloat32_t vec;\n    svuint32_t mask;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        vec = svld1_f32(&lst[i]);\n        vec = svceil_f32(vec);\n        vec = svmul_f32(vec, vec);\n        mask = svcmpeq_f32(vec, vec); // Create a mask for all elements\n        sum += svaddv_u64(mask, svreinterpret_u64(vec));\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t vector_length = svcntw(); // Number of elements in a vector\n\n    for (size_t i = 0; i < n; i += vector_length) {\n        // Load elements into SVE vector\n        svfloat32_t vec = svld1_f32(&lst[i]);\n\n        // Ceiling the elements\n        svfloat32_t ceil_vec = svceil_f32(vec);\n\n        // Square the elements\n        svfloat32_t squared_vec = svmul_f32(ceil_vec, ceil_vec);\n\n        // Sum the squared elements\n        sum += svaddv_u64(svreinterpret_u32(squared_vec));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svfloat32_t vec;\n    svuint32_t vec_ceil;\n    svuint64_t vec_squared;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        vec = svld1_f32(&lst[i]);\n        vec_ceil = svuzp1_u32(svceil_f32(vec));\n        vec_squared = svmul_u32(vec_ceil, vec_ceil);\n        sum += svaddv_u64(vec_squared);\n    }\n\n    for (; i < n; i++) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i])) * static_cast<uint64_t>(std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t vector_length = svcntw(); // Number of elements in a vector\n\n    for (size_t i = 0; i < n; i += vector_length) {\n        // Load the next vector of floats\n        svfloat32_t vec = svld1_f32(&lst[i]);\n\n        // Apply ceiling to each element\n        svfloat32_t ceil_vec = svceil_f32(vec);\n\n        // Square each element\n        svfloat32_t squared_vec = svmul_f32(ceil_vec, ceil_vec);\n\n        // Horizontal add to sum the squared elements\n        sum += svaddv_u32(svuzp_f32(squared_vec, squared_vec).val[0]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svfloat32_t vec;\n    svuint32_t mask;\n\n    for (; i <= n - svcntw(); i += svcntw()) {\n        vec = svld1_f32(&lst[i]);\n        vec = svceil_f32(vec);\n        vec = svmul_f32(vec, vec);\n        sum += svaddv_u64(svreinterpret_u32(svaddv_f32(vec)));\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += static_cast<uint64_t>(std::ceil(lst[i]) * std::ceil(lst[i]));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svint32_t max_index = svdup_n_s32(-1);\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n\n    for (int i = 0; i < n - 1; i += svcntb()) {\n        svint32_t current = svld1_s32(pg, &arr[i]);\n        svint32_t previous = svld1_s32(pg, &arr[i + 1]);\n\n        pg = svwhilelt_b32(i + 1, n - 1);\n        svbool_t cmp_pg = svcmplt_s32(pg, previous, current);\n\n        max_index = svsel(cmp_pg, svdup_n_s32(i + 1), max_index);\n    }\n\n    int result = svmax_s32(max_index);\n    return result == -1 ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svint32_t max_index = svdup_n_s32(-1);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t current = svld1(pg, &arr[i]);\n        svint32_t previous = svld1(pg, &arr[i - 1]);\n\n        pg = svwhilelt_b32(i, n);\n        svbool_t cmp_pg = svcmplt(pg, current, previous);\n\n        max_index = svmax(max_index, svdup_n_s32(i) * svreinterpret_u32(cmp_pg));\n    }\n\n    int result = svmax_s32(max_index);\n    return (result == -1) ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svint32_t max_index = svdup_n_s32(-1);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t current = svld1(pg, &arr[i]);\n        svint32_t previous = svld1(pg, &arr[i - 1]);\n        svbool_t cmp_pg = svcmplt(pg, current, previous);\n        max_index = svmax(max_index, svindex_s32(i, cmp_pg));\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n\n    int result = svmax_s32(max_index);\n    return result == -1 ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svint32_t max_index = svdup_n_s32(-1);\n    svbool_t valid_mask = svdup_b32(1);\n\n    for (int i = 0; i < n - 1; i += svcntw()) {\n        svint32_t current = svld1_s32(valid_mask, &arr[i]);\n        svint32_t next = svld1_s32(valid_mask, &arr[i + 1]);\n\n        svbool_t cmp_mask = svcmplt_s32(valid_mask, next, current);\n        max_index = svmax_s32(max_index, svdup_n_s32(i + 1) * svreinterpret_u32(cmp_mask));\n\n        valid_mask = svand_b32(valid_mask, svnot_b32(cmp_mask));\n    }\n\n    int result = svmax_s32(max_index);\n    return (result == -1) ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svint32_t max_index = svdup_n_s32(-1);\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t current = svld1(pg, &arr[i]);\n        svint32_t previous = svld1(pg, &arr[i - 1]);\n        \n        pg = svwhilelt_b32(i, n);\n        svbool_t cmp_pg = svcmplt(pg, current, previous);\n        \n        if (svptest_any(pg, cmp_pg)) {\n            max_index = svmax(max_index, svindex_s32(i, svcntw()));\n        }\n    }\n\n    int result = svmax_s32(max_index);\n    return result == -1 ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    svint32_t max_neg = svdup_n_s32(std::numeric_limits<int>::min());\n    svint32_t min_pos = svdup_n_s32(std::numeric_limits<int>::max());\n    svbool_t mask;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        mask = svcmplt_s32(vec, svdup_n_s32(0));\n        max_neg = svmax_s32(max_neg, svsel(mask, vec, max_neg));\n\n        mask = svcmpgt_s32(vec, svdup_n_s32(0));\n        min_pos = svmin_s32(min_pos, svsel(mask, vec, min_pos));\n    }\n\n    int largest_neg = svptest_any(svptrue_b32(), svcmpeq_s32(max_neg, svdup_n_s32(std::numeric_limits<int>::min()))) ? svmax_s32(max_neg, svdup_n_s32(0))[0] : 0;\n    int smallest_pos = svptest_any(svptrue_b32(), svcmpeq_s32(min_pos, svdup_n_s32(std::numeric_limits<int>::max()))) ? svmin_s32(min_pos, svdup_n_s32(0))[0] : 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    svint32_t max_neg = svdup_n_s32(std::numeric_limits<int>::min());\n    svint32_t min_pos = svdup_n_s32(std::numeric_limits<int>::max());\n    svbool_t mask;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t data = svld1(svptrue_b32(), &lst[i]);\n        mask = svcmplt_s32(svdup_n_s32(0), data);\n        max_neg = svmax_s32(max_neg, svand_s32(mask, data));\n        \n        mask = svcmpgt_s32(svdup_n_s32(0), data);\n        min_pos = svmin_s32(min_pos, svand_s32(mask, data));\n    }\n\n    int largest_neg = svdup_n_s32(0);\n    int smallest_pos = svdup_n_s32(0);\n    \n    if (svptest_any(svptrue_b32(), svcmpeq_s32(max_neg, svdup_n_s32(std::numeric_limits<int>::min())))) {\n        largest_neg = 0;\n    } else {\n        largest_neg = svmax_s32(max_neg, svdup_n_s32(0));\n    }\n\n    if (svptest_any(svptrue_b32(), svcmpeq_s32(min_pos, svdup_n_s32(std::numeric_limits<int>::max())))) {\n        smallest_pos = 0;\n    } else {\n        smallest_pos = svmin_s32(min_pos, svdup_n_s32(0));\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    svint32_t max_neg = svdup_n_s32(std::numeric_limits<int>::min());\n    svint32_t min_pos = svdup_n_s32(std::numeric_limits<int>::max());\n    svbool_t mask;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(svptrue_b32(), &lst[i]);\n        mask = svcmplt_s32(vec, svdup_n_s32(0));\n        max_neg = svmax_s32(max_neg, svsel(mask, vec, max_neg));\n\n        mask = svcmpgt_s32(vec, svdup_n_s32(0));\n        min_pos = svmin_s32(min_pos, svsel(mask, vec, min_pos));\n    }\n\n    int largest_neg = svdup_n_s32(0);\n    int smallest_pos = svdup_n_s32(0);\n    \n    if (svptest_any(svptrue_b32(), svcmpeq_s32(max_neg, svdup_n_s32(std::numeric_limits<int>::min())))) {\n        largest_neg = 0;\n    } else {\n        largest_neg = svmax_s32(max_neg, svdup_n_s32(0));\n    }\n\n    if (svptest_any(svptrue_b32(), svcmpeq_s32(min_pos, svdup_n_s32(std::numeric_limits<int>::max())))) {\n        smallest_pos = 0;\n    } else {\n        smallest_pos = svmin_s32(min_pos, svdup_n_s32(0));\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    svint32_t max_neg = svdup_n_s32(std::numeric_limits<int>::min());\n    svint32_t min_pos = svdup_n_s32(std::numeric_limits<int>::max());\n    svbool_t pg;\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svint32_t data = svld1(svptrue_b32(), &lst[i]);\n        pg = svcmpgt(svptrue_b32(), data, svdup_n_s32(0));\n        svint32_t neg_mask = svcmplt(svptrue_b32(), data, svdup_n_s32(0));\n        svint32_t pos_mask = svcmpgt(svptrue_b32(), data, svdup_n_s32(0));\n\n        max_neg = svmax(max_neg, svsel(neg_mask, data, svdup_n_s32(std::numeric_limits<int>::min())));\n        min_pos = svmin(min_pos, svsel(pos_mask, data, svdup_n_s32(std::numeric_limits<int>::max())));\n    }\n\n    int largest_neg = svptest_any(pg, max_neg) ? svmax_s32(max_neg) : 0;\n    int smallest_pos = svptest_any(pg, min_pos) ? svmin_s32(min_pos) : 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    svint32_t max_neg = svdup_n_s32(std::numeric_limits<int>::min());\n    svint32_t min_pos = svdup_n_s32(std::numeric_limits<int>::max());\n    svbool_t mask;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        mask = svcmplt_s32(vec, svdup_n_s32(0));\n        max_neg = svmax_s32(max_neg, svsel(mask, vec, max_neg));\n\n        mask = svcmpgt_s32(vec, svdup_n_s32(0));\n        min_pos = svmin_s32(min_pos, svsel(mask, vec, min_pos));\n    }\n\n    int largest_neg = svdup_n_s32(0)[0];\n    int smallest_pos = svdup_n_s32(0)[0];\n\n    if (svptest_any(svptrue_b32(), svcmpeq_s32(max_neg, svdup_n_s32(std::numeric_limits<int>::min())))) {\n        largest_neg = 0;\n    } else {\n        largest_neg = svmax_s32(max_neg, svdup_n_s32(0))[0];\n    }\n\n    if (svptest_any(svptrue_b32(), svcmpeq_s32(min_pos, svdup_n_s32(std::numeric_limits<int>::max())))) {\n        smallest_pos = 0;\n    } else {\n        smallest_pos = svmin_s32(min_pos, svdup_n_s32(0))[0];\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    \n    for (uint64_t i = n; i > 0; i -= svcntd()) {\n        svuint64_t indices = svindex_u64(i, svcntd());\n        svuint64_t factorials = svmul_u64(vec_result, svfactorial_u64(indices));\n        vec_result = svmul_u64(vec_result, factorials);\n    }\n\n    uint64_t *results = (uint64_t *)svdup_u64(0);\n    svst1_u64(svptrue_b64(), results, vec_result);\n    \n    for (int j = 0; j < svcntd(); j++) {\n        result *= results[j];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    \n    for (uint64_t i = n; i > 0; i -= svcntd()) {\n        svuint64_t v_i = svld1_u64(svptrue_b64(), &i);\n        v_result = svmul_u64(v_result, svfactorial_u64(v_i));\n    }\n\n    result = svaddv_u64(svadd_u64(v_result, svdup_u64(0)));\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    svuint64_t factorials[SVE_NUM_ELEMS];\n\n    for (uint64_t i = 1; i <= n; i++) {\n        factorials[i % SVE_NUM_ELEMS] = svdup_u64(1);\n        for (uint64_t j = 1; j <= i; j++) {\n            factorials[i % SVE_NUM_ELEMS] = svmul_u64(factorials[i % SVE_NUM_ELEMS], svdup_u64(j));\n        }\n    }\n\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= svreduce_mul_u64(factorials[i % SVE_NUM_ELEMS]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    uint64_t factorials[64] = {1}; // To store factorials from 0! to n!\n\n    for (uint64_t i = 1; i <= n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    svuint64_t vec_factorials = svdup_u64(1);\n    for (uint64_t i = 1; i <= n; i += svcntd()) {\n        svuint64_t indices = svindex_u64(i, svcntd());\n        svuint64_t vec_values = svld1_u64(svld1_u64(factorials + i));\n        vec_factorials = svmul_u64(vec_factorials, vec_values);\n    }\n\n    result = svaddv_u64(vec_factorials);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n    svuint64_t vec_n = svdup_u64(n);\n    \n    for (uint64_t i = n; i > 0; i -= svcntd()) {\n        svuint64_t vec_i = svld1_u64(&i);\n        vec_result = svmul_u64(vec_result, svfactorial_u64(vec_i));\n    }\n\n    result = svaddv_u64(vec_result);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t squared = svmul_s32(vec, vec);\n        svint32_t cubed = svmul_s32(svmul_s32(vec, vec), vec);\n\n        svint32_t result = svdup_n_s32(0);\n        svbool_t mask3 = svindex_b32(i, svcntb()) % 3 == 0;\n        svbool_t mask4 = (svindex_b32(i, svcntb()) % 4 == 0) & !mask3;\n\n        result = svsel(mask3, squared, result);\n        result = svsel(mask4, cubed, result);\n        total_sum = svadd_s32(total_sum, result);\n    }\n\n    int32_t result_array[svcntb()];\n    svst1_s32(svptrue_b32(), result_array, total_sum);\n    for (size_t j = 0; j < svcntb(); ++j) {\n        sum += result_array[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t mask3 = svindex_s32(i, svcntb()) % 3 == 0;\n        svint32_t mask4 = (svindex_s32(i, svcntb()) % 4 == 0) & !mask3;\n\n        svint32_t squared = svmul_s32(vec, vec);\n        svint32_t cubed = svmul_s32(svmul_s32(vec, vec), vec);\n\n        vec = svsel(mask3, squared, vec);\n        vec = svsel(mask4, cubed, vec);\n\n        total_sum = svadd_s32(total_sum, vec);\n    }\n\n    int32_t result[svcntb()];\n    svst1_s32(svptrue_b32(), result, total_sum);\n    \n    for (size_t j = 0; j < svcntb(); j++) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svmin_u(size_t(n - i), svcntw());\n        svint32_t vec = svld1_s32(svindex(0, i), &lst[i]);\n\n        svint32_t squared = svmul_s32(vec, vec);\n        svint32_t cubed = svmul_s32(svmul_s32(vec, vec), vec);\n\n        svint32_t result = svdup_n_s32(0);\n        result = svorr_s32(result, svand_s32(svdup_n_s32((i % 3 == 0)), squared));\n        result = svorr_s32(result, svand_s32(svdup_n_s32((i % 4 == 0) && (i % 3 != 0)), cubed));\n\n        total_sum = svadd_s32(total_sum, result);\n    }\n\n    int32_t sum_array[svcntw()];\n    svst1_s32(svindex(0, 0), sum_array, total_sum);\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_array[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntb()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n        svint32_t mask3 = svindex_s32(i, svcntb()) % 3 == 0;\n        svint32_t mask4 = (svindex_s32(i, svcntb()) % 4 == 0) & !mask3;\n\n        svint32_t squared = svmul_s32(vec, vec);\n        svint32_t cubed = svmul_s32(svmul_s32(vec, vec), vec);\n\n        vec = svsel(mask3, squared, vec);\n        vec = svsel(mask4, cubed, vec);\n\n        total_sum = svadd_s32(total_sum, vec);\n    }\n\n    int32_t result[svcntb()];\n    svst1_s32(svptrue_b32(), result, total_sum);\n    \n    for (size_t j = 0; j < svcntb(); ++j) {\n        sum += result[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t length = lst.size();\n    svint32_t total_sum = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint32_t vec = svld1_s32(svld1_u32(&lst[i]));\n        svint32_t indices = svdup_n_s32(i);\n        \n        svint32_t squared = svmul_s32(vec, vec);\n        svint32_t cubed = svmul_s32(svmul_s32(vec, vec), vec);\n        \n        svint32_t result = svdup_n_s32(0);\n        \n        // Square if index is multiple of 3\n        svint32_t mask3 = svcmpeq_s32(svrem_s32(indices, svdup_n_s32(3)), svdup_n_s32(0));\n        result = svsel(mask3, squared, result);\n        \n        // Cube if index is multiple of 4 and not multiple of 3\n        svint32_t mask4 = svcmpeq_s32(svrem_s32(indices, svdup_n_s32(4)), svdup_n_s32(0));\n        svint32_t mask_not3 = svcmpeq_s32(svrem_s32(indices, svdup_n_s32(3)), svdup_n_s32(1));\n        mask_not3 = svorr(mask_not3, svcmpeq_s32(svrem_s32(indices, svdup_n_s32(3)), svdup_n_s32(2));\n        result = svsel(svand(mask4, mask_not3), cubed, result);\n        \n        total_sum = svadd_s32(total_sum, result);\n    }\n    \n    int32_t sum_array[svcntw()];\n    svst1_s32(sum_array, total_sum);\n    \n    for (size_t j = 0; j < svcntw(); j++) {\n        sum += sum_array[j];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    svint32_t threshold = svdup_n_s32(10);\n    svint32_t odd_mask = svdup_n_s32(0xAAAAAAAA); // Mask for odd digits\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svint32_t data = svld1_s32(&nums[i]);\n        svbool_t gt_mask = svcmpgt_s32(svundef_s32(), data, threshold);\n        \n        svint32_t first_digit = svand_s32(svlsr_n_s32(data, 28), svdup_n_s32(0xF)); // Get first digit\n        svint32_t last_digit = svand_s32(data, svdup_n_s32(0xF)); // Get last digit\n        \n        svbool_t first_odd_mask = svand_b(svcmpeq_s32(svundef_s32(), first_digit, svdup_n_s32(1)), \n                                           svcmpeq_s32(svundef_s32(), first_digit, svdup_n_s32(3)));\n        first_odd_mask = svorr_b(first_odd_mask, \n                                  svcmpeq_s32(svundef_s32(), first_digit, svdup_n_s32(5)));\n        first_odd_mask = svorr_b(first_odd_mask, \n                                  svcmpeq_s32(svundef_s32(), first_digit, svdup_n_s32(7)));\n        first_odd_mask = svorr_b(first_odd_mask, \n                                  svcmpeq_s32(svundef_s32(), first_digit, svdup_n_s32(9)));\n\n        svbool_t last_odd_mask = svand_b(svcmpeq_s32(svundef_s32(), last_digit, svdup_n_s32(1)), \n                                          svcmpeq_s32(svundef_s32(), last_digit, svdup_n_s32(3)));\n        last_odd_mask = svorr_b(last_odd_mask, \n                                 svcmpeq_s32(svundef_s32(), last_digit, svdup_n_s32(5)));\n        last_odd_mask = svorr_b(last_odd_mask, \n                                 svcmpeq_s32(svundef_s32(), last_digit, svdup_n_s32(7)));\n        last_odd_mask = svorr_b(last_odd_mask, \n                                 svcmpeq_s32(svundef_s32(), last_digit, svdup_n_s32(9)));\n\n        svbool_t valid_mask = svand_b(gt_mask, first_odd_mask);\n        valid_mask = svand_b(valid_mask, last_odd_mask);\n\n        count += svcntb(svaddv_s32(svundef_s32(), valid_mask));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    svint32_t vec_nums;\n    svbool_t pg;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_nums = svld1(pg, &nums[i]);\n\n        svbool_t greater_than_10 = svcmplt(pg, vec_nums, svdup_n_s32(10));\n        svbool_t first_digit_odd = svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(1)) |\n                                    svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(3)) |\n                                    svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(5)) |\n                                    svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(7)) |\n                                    svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(9));\n        svbool_t last_digit_odd = svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(1)) |\n                                   svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(3)) |\n                                   svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(5)) |\n                                   svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(7)) |\n                                   svcmpeq(pg, svand_n_s32(vec_nums, 0xF), svdup_n_s32(9));\n\n        svbool_t valid_condition = svand(pg, greater_than_10, svand(first_digit_odd, last_digit_odd));\n        count += svcntb(svand(pg, valid_condition));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    svint32_t threshold = svdup_n_s32(10);\n    svuint8_t odd_mask = svdup_n_u8(0b101010101); // Mask for odd digits\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(&nums[i]);\n        svbool_t gt_mask = svgreater_s32(vec, threshold);\n        \n        svint32_t first_digit = svdiv_s32(vec, svdup_n_s32(10));\n        svint32_t last_digit = svabs_s32(vec);\n        last_digit = svrem_s32(last_digit, svdup_n_s32(10));\n\n        svuint8_t first_odd = svand_u8(svdup_n_u8(0b11111000), svreinterpret_u8(first_digit));\n        svuint8_t last_odd = svand_u8(svdup_n_u8(0b11111000), svreinterpret_u8(last_digit));\n\n        svbool_t first_odd_mask = svcmpeq_u8(first_odd, odd_mask);\n        svbool_t last_odd_mask = svcmpeq_u8(last_odd, odd_mask);\n\n        svbool_t special_mask = svand_b(gt_mask, svand_b(first_odd_mask, last_odd_mask));\n        count += svcntb(special_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    svint32_t vec_nums;\n    svbool_t pg;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_nums = svld1(pg, &nums[i]);\n\n        svbool_t greater_than_10 = svcmpgt_b32(pg, vec_nums, svdup_n_s32(10));\n        \n        svint32_t first_digit = svdiv_n_s32(svabs_s32(vec_nums), 10);\n        svint32_t last_digit = svabs_s32(vec_nums);\n        last_digit = svmod_n_s32(last_digit, 10);\n        \n        svbool_t first_odd = svand_b32(pg, svcmpne_b32(pg, svand_n_s32(first_digit, 1), 0), svcmpne_b32(pg, svand_n_s32(first_digit, 10), 0));\n        svbool_t last_odd = svand_b32(pg, svcmpne_b32(pg, svand_n_s32(last_digit, 1), 0), svcmpne_b32(pg, svand_n_s32(last_digit, 10), 0));\n        \n        svbool_t special_condition = svand_b32(pg, greater_than_10, svand_b32(pg, first_odd, last_odd));\n        \n        count += svcntb(svaddv_s32(pg, special_condition));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    svint32_t vec_nums;\n    svbool_t pg;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        size_t remaining = size - i;\n        pg = svwhilelt_b32(i, size);\n        vec_nums = svld1(pg, &nums[i]);\n\n        svbool_t greater_than_10 = svcmpgt_b32(pg, vec_nums, svdup_n_s32(10));\n        \n        svint32_t first_digit = svdiv_n_s32(svabs_s32(vec_nums), 10);\n        svint32_t last_digit = svabs_s32(vec_nums);\n        last_digit = svsub_n_s32(last_digit, svmul_n_s32(svdiv_n_s32(last_digit, 10), 10));\n\n        svbool_t first_odd = svcmpeq_b32(pg, svand_n_s32(first_digit, 1), svdup_n_s32(1));\n        svbool_t last_odd = svcmpeq_b32(pg, svand_n_s32(last_digit, 1), svdup_n_s32(1));\n\n        svbool_t special_condition = svand_b(pg, greater_than_10, svand_b(pg, first_odd, last_odd));\n        \n        count += svcntb(svaddv_u32(svreinterpret_u32(svdup_n_u32(1)), svreinterpret_u32(svdup_n_u32(0)), special_condition));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Populate the array a using the formula\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Use SVE to count valid triples\n    svuint64_t v_count = svdup_u64(0);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t v_a = svld1_u64(svptrue_b64(), &a[i]);\n        svuint64_t v_mod = svmod_u64(v_a, svdup_u64(3));\n\n        for (uint64_t j = i; j < n; j += svcntd()) {\n            svuint64_t v_b = svld1_u64(svptrue_b64(), &a[j]);\n            svuint64_t v_mod_b = svmod_u64(v_b, svdup_u64(3));\n\n            for (uint64_t k = j; k < n; k += svcntd()) {\n                svuint64_t v_c = svld1_u64(svptrue_b64(), &a[k]);\n                svuint64_t v_mod_c = svmod_u64(v_c, svdup_u64(3));\n\n                svuint64_t v_sum = svadd_u64(v_mod, svadd_u64(v_mod_b, v_mod_c));\n                v_count = svadd_u64(v_count, svcnt_u64(svcmpeq_u64(v_sum, svdup_u64(0))));\n            }\n        }\n    }\n\n    // Sum the counts from the vector\n    count = svaddv_u64(v_count);\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t a[n];\n    \n    // Calculate the values of a[i] = i * i - i + 1\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count triples (i, j, k) such that a[i] + a[j] + a[k] is a multiple of 3\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Fill the array a with the formula a{i} = i * i - i + 1\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Count valid triples using SVE\n    svuint64_t v_a;\n    svuint64_t v_sum;\n    svuint64_t v_mask;\n    \n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        v_a = svld1_u64(svptrue_b64(), &a[i]);\n        \n        for (uint64_t j = i + 1; j < n; j += svcntd()) {\n            svuint64_t v_b = svld1_u64(svptrue_b64(), &a[j]);\n            \n            for (uint64_t k = j + 1; k < n; k += svcntd()) {\n                svuint64_t v_c = svld1_u64(svptrue_b64(), &a[k]);\n                \n                v_sum = svadd_u64(svadd_u64(v_a, v_b), v_c);\n                v_mask = svcmpeq_u64(v_sum, svdup_u64(0)); // Check if sum is multiple of 3\n                \n                count += svcntd() - svpopc_u64(v_mask);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    svuint64_t vec_a;\n    svuint64_t vec_sum;\n    svuint64_t vec_count = svdup_u64(0);\n    \n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        vec_a = svld1_u64(svptrue_b64(), &a[i]);\n        vec_sum = svadd_u64(vec_a, svdup_u64(0));\n        \n        for (uint64_t j = i + 1; j < n; j += svcntd()) {\n            svuint64_t vec_b = svld1_u64(svptrue_b64(), &a[j]);\n            svuint64_t sum_ab = svadd_u64(vec_sum, vec_b);\n            \n            for (uint64_t k = j + 1; k < n; k += svcntd()) {\n                svuint64_t vec_c = svld1_u64(svptrue_b64(), &a[k]);\n                svuint64_t sum_abc = svadd_u64(sum_ab, vec_c);\n                \n                svuint64_t mod_result = svmod_u64(sum_abc, svdup_u64(3));\n                vec_count = svadd_u64(vec_count, svcntb(svcmpeq_u64(mod_result, svdup_u64(0))));\n            }\n        }\n    }\n\n    count = svaddv_u64(vec_count);\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Fill the array a with the formula a[i] = i * i - i + 1\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    // Use SVE to count valid triples\n    svuint64_t v_count = svdup_u64(0);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t v_a = svld1_u64(svptrue_b64(), &a[i]);\n        svuint64_t v_mod = svmod_u64(v_a, svdup_u64(3));\n\n        for (uint64_t j = i; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                svuint64_t v_b = svdup_u64(a[j]);\n                svuint64_t v_c = svdup_u64(a[k]);\n                svuint64_t v_sum = svadd_u64(v_a, svadd_u64(v_b, v_c));\n                svuint64_t v_sum_mod = svmod_u64(v_sum, svdup_u64(3));\n                v_count = svadd_u64(v_count, svcnt_u64(svcmpeq_u64(v_sum_mod, svdup_u64(0))));\n            }\n        }\n    }\n\n    count = svaddv_u64(v_count);\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    svint32_t n_vec = svdup_n_s32(n);\n    svint32_t x_vec = svdup_n_s32(x);\n    svint32_t y_vec = svdup_n_s32(y);\n    \n    svbool_t prime_mask = svdup_b32(is_prime(n));\n    \n    svint32_t result_vec = svsel(prime_mask, x_vec, y_vec);\n    \n    return svget1_s32(result_vec);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int result = y; // Default to y\n    svint32_t n_vec = svdup_n_s32(n);\n    svint32_t x_vec = svdup_n_s32(x);\n    svint32_t y_vec = svdup_n_s32(y);\n    \n    svbool_t prime_mask = svdup_b32(is_prime(n)); // Check if n is prime\n\n    result = svfirst_s32(svsel(prime_mask, x_vec, y_vec)); // Select x if prime, else y\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    if (n <= 3) return 1;\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int result = y; // Default to y\n    svbool_t pg = svptrue_b32(); // Predicate for SVE\n\n    // Create a vector with the value of n\n    svint32_t n_vec = svdup_n_s32(n);\n    \n    // Check if n is prime using SVE\n    svint32_t is_prime_vec = svdup_n_s32(0);\n    is_prime_vec = svdup_n_s32(is_prime(n)); // This is not vectorized, but serves as a placeholder\n\n    // Set result based on the prime check\n    result = svptest_any(pg, is_prime_vec) ? x : y;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int result = y;\n    svint32_t n_vec = svdup_n_s32(n);\n    svint32_t x_vec = svdup_n_s32(x);\n    svint32_t y_vec = svdup_n_s32(y);\n    \n    svbool_t mask = svdup_n_b32(1);\n    svint32_t primes = svdup_n_s32(0);\n    \n    for (int i = 0; i < 32; i++) {\n        if (is_prime(n)) {\n            primes = svadd_s32(primes, svdup_n_s32(1));\n        }\n    }\n    \n    mask = svcmpeq_s32(mask, primes, svdup_n_s32(1));\n    result = svifelse_s32(mask, x_vec, y_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint is_prime(int n) {\n    if (n <= 1) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int result = y;\n    if (is_prime(n)) {\n        result = x;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    \n    if (n == 0) return sum;\n\n    svfloat32_t vec = svld1_f32(&lst[0]);\n    svbool_t mask = svcmpeq_f32(svdup_f32(0), vec);\n    \n    svfloat32_t odd_mask = svand_f32(mask, svdup_f32(1));\n    svfloat32_t odd_numbers = svand_f32(vec, odd_mask);\n    \n    svfloat32_t squares = svmul_f32(odd_numbers, odd_numbers);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint64_t sum_squares = svadd_u64(svdup_u64(0), svreinterpret_u64(svaddv_f32(squares)));\n        sum += svaddv_u64(sum_squares);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    \n    if (n == 0) return sum;\n\n    svfloat32_t vec;\n    svuint32_t mask;\n    svuint64_t result = svdup_u64(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t remaining = n - i;\n        size_t length = remaining < svcntw() ? remaining : svcntw();\n        \n        vec = svld1_f32(&lst[i]);\n        mask = svcmpeq_f32(vec, svdup_f32(-1)); // Mask for negative numbers\n        vec = svand_f32(vec, svnot_u32(mask)); // Zero out negative numbers\n\n        mask = svcmpeq_f32(vec, svdup_f32(0)); // Mask for zero\n        vec = svand_f32(vec, svnot_u32(mask)); // Zero out zeros\n\n        mask = svrem_f32(vec, svdup_f32(2)); // Check for odd numbers\n        mask = svcmpeq_f32(mask, svdup_f32(1)); // Mask for odd numbers\n\n        vec = svmul_f32(vec, vec); // Square the numbers\n        result = svadd_u64(result, svreinterpret_u64(svdup_f32(svadd_f32(svdup_f32(0), svand_f32(vec, mask)))));\n    }\n\n    uint64_t sum_result = svaddv_u64(result);\n    return sum_result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    \n    if (n == 0) return sum;\n\n    svfloat32_t vec = svld1_f32(&lst[0]);\n    svbool_t mask = svcmpgt_f32(svdup_f32(0), vec); // mask for non-negative numbers\n    vec = svand_f32(mask, vec); // zero out negatives\n\n    svbool_t odd_mask = svreinterpret_u32(svcmpeq_f32(svdup_f32(1), svand_f32(vec, svdup_f32(1))));\n    svfloat32_t odd_numbers = svand_f32(odd_mask, vec); // filter odd numbers\n\n    svfloat32_t squares = svmul_f32(odd_numbers, odd_numbers); // square the odd numbers\n    sum = svaddv_u64(svadd_u64(svdup_u64(0), svreinterpret_u64(svadd_f32(svdup_f32(0), squares))));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    \n    if (size == 0) return sum;\n\n    svfloat32_t vec;\n    svuint32_t mask;\n    svuint32_t indices = svindex(0, size);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        size_t remaining = size - i;\n        vec = svld1_f32(svptrue_b32(), &lst[i]);\n        mask = svcmpeq_f32(svptrue_b32(), vec, svdup_f32(0.0f));\n        svuint32_t odd_mask = svand_u32(mask, svcmpeq_u32(svreinterpret_u32_f32(vec), svdup_u32(1)));\n        \n        svuint32_t odd_indices = svand_u32(indices, odd_mask);\n        svfloat32_t odd_numbers = svreinterpret_f32_u32(odd_indices);\n        \n        svfloat32_t squares = svmul_f32(odd_numbers, odd_numbers);\n        sum += svaddv_u64(svadd_u64(svdup_u64(0), svreinterpret_u64_f32(squares)));\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    if (n == 0) return sum;\n\n    svfloat32_t vec = svld1_f32(&lst[0]);\n    svbool_t mask = svcmpeq_f32(svdup_f32(0), vec);\n    svbool_t odd_mask = svand_b(mask, svcmpeq_f32(vec, svdup_f32(1)));\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t v = svld1_f32(&lst[i]);\n        svbool_t odd = svand_b(svcmpeq_f32(v, svdup_f32(1)), svcmplt_f32(v, svdup_f32(0)));\n        svfloat32_t squares = svmul_f32(v, v);\n        sum += svaddv_u64(svifthen(odd, squares));\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    svint32_t game_vec, guess_vec, diff_vec;\n    for (size_t i = 0; i < len; i += svcntw()) {\n        size_t vl = std::min(svcntw(), len - i);\n        game_vec = svld1(svptrue_b32(), &game[i]);\n        guess_vec = svld1(svptrue_b32(), &guess[i]);\n        diff_vec = svabs_diff_s32(game_vec, guess_vec);\n        svst1(svptrue_b32(), &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    svint32_t game_vec, guess_vec, diff_vec;\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t len = std::min(svcntw(), n - i);\n        \n        game_vec = svld1(svptrue_b32(), &game[i]);\n        guess_vec = svld1(svptrue_b32(), &guess[i]);\n        \n        diff_vec = svabs(svsub(game_vec, guess_vec));\n        \n        svst1(svptrue_b32(), &result[i], diff_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    svint32_t game_vec, guess_vec, diff_vec;\n    for (size_t i = 0; i < len; i += svcntw()) {\n        size_t vl = std::min(svcntw(), len - i);\n        \n        game_vec = svld1(svptrue_b32(), &game[i]);\n        guess_vec = svld1(svptrue_b32(), &guess[i]);\n        \n        diff_vec = svabs_diff_s32(game_vec, guess_vec);\n        \n        svst1(svptrue_b32(), &result[i], diff_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n    \n    svint32_t game_vec, guess_vec, diff_vec;\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t vl = std::min(svcntw(), length - i);\n        game_vec = svld1(svptrue_b32(), &game[i]);\n        guess_vec = svld1(svptrue_b32(), &guess[i]);\n        diff_vec = svabs(svsub(game_vec, guess_vec));\n        svst1(svptrue_b32(), &result[i], diff_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    svint32_t game_vec, guess_vec, diff_vec;\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = std::min(svcntw(), n - i);\n        \n        game_vec = svld1(svptrue_b32(), &game[i]);\n        guess_vec = svld1(svptrue_b32(), &guess[i]);\n        \n        diff_vec = svabs_diff_s32(game_vec, guess_vec);\n        \n        svint32_t zero_vec = svdup_n_s32(0);\n        svint32_t result_vec = svwhilelt_b32(zero_vec, diff_vec);\n        \n        svst1(svptrue_b32(), &result[i], result_vec);\n    }\n    \n    return result;\n}\n```"}

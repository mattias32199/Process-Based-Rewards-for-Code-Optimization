{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svbool_t mask_vec = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(mask_vec, src_vec, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t mask_vec = svld1_s8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(mask_vec, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(vec_mask, dst + i, vec_src);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(pg_loop, src + i);\n        \n        svint32_t scaled = svmul_n_s32_x(pg_loop, vec, scale);\n        svint32_t tmp1 = svlsr_n_s32_x(pg_loop, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg_loop, scaled, 3);\n        svint32_t prod = svmul_s32_x(pg_loop, tmp1, tmp2);\n        svint32_t sum = svadd_s32_x(pg_loop, scaled, prod);\n        svint32_t result = svdiv_n_s32_x(pg_loop, sum, 7);\n        \n        svst1_s32(pg_loop, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svint32_t scale_vec = svdup_s32(scale);\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    do {\n        // Load input vector\n        svint32_t src_vec = svld1(pg, &src[i]);\n\n        // Step 1: tmp1 = (element * scale) >> 3\n        svint32_t tmp1 = svmul_s32_z(pg, src_vec, scale_vec);\n        tmp1 = svlsr_n_s32_z(pg, tmp1, 3);\n\n        // Step 2: tmp2 = (element * scale) << 3\n        svint32_t tmp2 = svmul_s32_z(pg, src_vec, scale_vec);\n        tmp2 = svlsl_n_s32_z(pg, tmp2, 3);\n\n        // Step 3: result = (element * scale + tmp1 * tmp2) / 7\n        svint32_t mul_result = svmul_s32_z(pg, src_vec, scale_vec);\n        svint32_t tmp_mul = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t sum = svadd_s32_z(pg, mul_result, tmp_mul);\n        svint32_t result = svdiv_n_s32_z(pg, sum, 7);\n\n        // Store result\n        svst1(pg, &dst[i], result);\n\n        // Update predicate for next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t vec_src = svld1_s32(pg, src + i);\n        \n        svint32_t vec_scaled = svmul_n_s32_z(pg, vec_src, scale);\n        svint32_t tmp1 = svlsr_n_s32_z(pg, vec_scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_z(pg, vec_scaled, 3);\n        svint32_t prod = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t sum = svadd_s32_z(pg, vec_scaled, prod);\n        svint32_t result = svdiv_n_s32_z(pg, sum, 7);\n        \n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load a vector of integers from src\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Step 1: Compute tmp1 = (element * scale) >> 3\n        svint32_t vec_scaled = svmul_n_s32_z(pg, vec_src, scale);\n        svint32_t vec_tmp1 = svlsr_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 2: Compute tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svlsl_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 3: Compute final result = (element * scale + tmp1 * tmp2) / 7\n        svint32_t vec_tmp1_tmp2 = svmul_s32_z(pg, vec_tmp1, vec_tmp2);\n        svint32_t vec_sum = svadd_s32_z(pg, vec_scaled, vec_tmp1_tmp2);\n        svint32_t vec_result = svdiv_n_s32_z(pg, vec_sum, 7);\n        \n        // Store the result in dst\n        svst1(pg, &dst[i], vec_result);\n        \n        // Update the loop counter and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    const int32_t scale_vec = scale;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svint32_t src_vec = svld1(pg, src + i);\n        svint32_t scaled = svmul_n_s32_x(pg, src_vec, scale_vec);\n        \n        svint32_t tmp1 = svlsr_n_s32_x(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled, 3);\n        svint32_t mul_tmp = svmul_s32_x(pg, tmp1, tmp2);\n        \n        svint32_t result = svadd_s32_x(pg, scaled, mul_tmp);\n        result = svdiv_n_s32_x(pg, result, 7);\n        \n        svst1(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    \n    for (size_t r = 0; r < rows; r += vec_len) {\n        size_t n = (rows - r) < vec_len ? (rows - r) : vec_len;\n        svbool_t mask = svwhilelt_b64(r, rows);\n        \n        svuint64_t indices = svindex_u64(r * cols + stride, cols);\n        svfloat64_t data = svld1_gather_u64index_f64(mask, src, indices);\n        svst1_f64(mask, dst + r, data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    svfloat64_t vec = svld1(pg, src + stride);\n    svst1(pg, dst, vec);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    svfloat64_t vec = svld1_gather_index(pg, src + stride, svadd_z(pg, svindex_u64(0, cols), 0));\n    svst1(pg, dst, vec);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i;\n\n    for (i = 0; i < rows; i += vec_len) {\n        // Create a predicate for the current vector length, accounting for tail elements\n        svbool_t p = svwhilelt_b64(i, rows);\n        \n        // Compute the source index for the current row batch\n        svuint64_t indices = svadd_n_u64_z(p, svindex_u64(i, 1), 0);\n        svuint64_t src_offset = svmul_n_u64_z(p, indices, cols);\n        src_offset = svadd_n_u64_z(p, src_offset, stride);\n        \n        // Load from source with strided access\n        svfloat64_t vec = svld1_f64(p, src + svmin_n_u64_z(p, src_offset, (rows - 1) * cols + stride));\n        \n        // Store to destination\n        svst1_f64(p, dst + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i <= rows - vec_len; i += vec_len) {\n        svfloat64_t data = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], data);\n    }\n\n    // Handle remaining elements if rows is not a multiple of vector length\n    if (i < rows) {\n        svbool_t rem_pg = svwhilelt_b64(i, rows);\n        svfloat64_t data = svld1(rem_pg, &src[i * cols + stride]);\n        svst1(rem_pg, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i + vec_len <= length; i += vec_len) {\n        // Create predicate for the current vector length\n        pg = svwhilelt_b32(i, length);\n\n        // Load indices for gather and scatter operations\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n\n        // Gather operation: read from src using indices and store to dst\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, &dst[i], gathered);\n\n        // Scatter operation: write to dst using indices as write locations\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec);\n    }\n\n    // Handle remaining elements if length is not a multiple of vector length\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]]; // Gather equivalent for scalar\n        dst[indices[i]] = src[i]; // Scatter equivalent for scalar\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < length; i += vec_len) {\n        // Adjust predicate for the last iteration if length is not a multiple of vector length\n        if (i + vec_len > length) {\n            pg = svwhilelt_b32(i, length);\n        }\n\n        // Load indices for gather and scatter operations\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n\n        // Gather operation: read from src using indices and store to dst\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, &dst[i], gathered);\n\n        // Scatter operation: write to dst using indices as write locations\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    do {\n        // Load indices for gather and scatter operations\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n\n        // Gather operation: read from src using indices and store to dst\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, &dst[i], gathered);\n\n        // Scatter operation: read from src and write to dst using indices\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    do {\n        // Gather operation: read from src using indices\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered = svldff1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, &dst[i], gathered);\n\n        // Scatter operation: write to dst using indices\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        // Gather operation\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t src_vec = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, src_vec);\n        \n        // Scatter operation\n        svfloat32_t src_vec2 = svld1_f32(pg, src + i);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec2);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    uint64_t i;\n\n    svbool_t pg = svptrue_b16();\n    uint64_t vec_len = svcntw();\n\n    for (i = 0; i < half_len; i += vec_len) {\n        uint64_t remaining = half_len - i;\n        uint64_t elements = (remaining < vec_len) ? remaining : vec_len;\n        svbool_t active_pg = svwhilelt_b16(i, i + elements);\n\n        uint64_t left_idx = start + i;\n        uint64_t right_idx = end - i - elements + 1;\n\n        svint16_t left_vec = svld1_s16(active_pg, &arr[left_idx]);\n        svint16_t right_vec = svld1_s16(active_pg, &arr[right_idx]);\n\n        svst1_s16(active_pg, &arr[left_idx], right_vec);\n        svst1_s16(active_pg, &arr[right_idx], left_vec);\n    }\n\n    // Handle any remaining elements scalar-wise\n    for (; i < half_len; i++) {\n        uint64_t left_idx = start + i;\n        uint64_t right_idx = end - i;\n        int16_t temp = arr[left_idx];\n        arr[left_idx] = arr[right_idx];\n        arr[right_idx] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    uint64_t i;\n\n    // Get the vector length for SVE\n    uint64_t vec_len = svcntw();\n    svbool_t pg = svwhilelt_b16(0, vec_len);\n\n    for (i = 0; i < half_len; i += vec_len) {\n        // Calculate remaining elements to process in the current iteration\n        uint64_t remaining = half_len - i;\n        pg = svwhilelt_b16(0, remaining < vec_len ? remaining : vec_len);\n\n        // Load elements from start + i\n        svint16_t vec_left = svld1(pg, &arr[start + i]);\n\n        // Load elements from end - i\n        svint16_t vec_right = svld1(pg, &arr[end - i - (remaining < vec_len ? remaining - 1 : vec_len - 1)]);\n\n        // Store reversed elements\n        svst1(pg, &arr[start + i], vec_right);\n        svst1(pg, &arr[end - i - (remaining < vec_len ? remaining - 1 : vec_len - 1)], vec_left);\n    }\n\n    // Handle remaining elements scalarly if any\n    for (; i < half_len; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = 0;\n\n    // Process vector-sized chunks\n    while (i < len / 2) {\n        svbool_t pg = svwhilelt_b16(i, len / 2);\n        uint64_t count = svcntw();\n\n        // Calculate indices for left and right sides\n        svuint64_t indices_left = svadd_n_u64_x(pg, svindex_u64(start + i, 1), 0);\n        svuint64_t indices_right = svsub_n_u64_x(pg, svindex_u64(end - i, -1), 0);\n\n        // Load elements from both ends\n        svint16_t left = svld1_gather_u64index_s16(pg, arr, indices_left);\n        svint16_t right = svld1_gather_u64index_s16(pg, arr, indices_right);\n\n        // Store elements in reversed positions\n        svst1_scatter_u64index_s16(pg, arr, indices_right, left);\n        svst1_scatter_u64index_s16(pg, arr, indices_left, right);\n\n        i += count;\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len / 2; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    uint64_t i;\n\n    svbool_t pg = svptrue_b16();\n    uint64_t vec_len = svcntw();\n\n    for (i = 0; i < half_len; i += vec_len) {\n        svbool_t pred = svwhilelt_b16(i, half_len);\n        uint64_t remaining = svcntp_b16(pred);\n\n        if (remaining == 0) break;\n\n        uint64_t idx1 = start + i;\n        uint64_t idx2 = end - i - (remaining - 1);\n\n        svint16_t vec1 = svld1_s16(pred, &arr[idx1]);\n        svint16_t vec2 = svld1_s16(pred, &arr[idx2]);\n\n        svst1_s16(pred, &arr[idx1], vec2);\n        svst1_s16(pred, &arr[idx2], vec1);\n    }\n\n    // Handle remaining elements scalarly if any\n    for (; i < half_len; i++) {\n        uint64_t idx1 = start + i;\n        uint64_t idx2 = end - i;\n        int16_t temp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    \n    svbool_t pg = svwhilelt_b16(start, end);\n    uint64_t i = 0;\n    \n    while (i < half_len) {\n        svint16_t vec_left = svld1_s16(pg, &arr[start + i]);\n        svint16_t vec_right = svld1_s16(pg, &arr[end - i]);\n        \n        svst1_s16(pg, &arr[start + i], vec_right);\n        svst1_s16(pg, &arr[end - i], vec_left);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(start + i, end - i);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, slice_size);\n    do {\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, slice_size);\n    } while (svptest_any(svptrue_b8(), pg));\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < slice_size; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n\n    for (size_t i = 0; i < slice_size; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    for (; i <= slice_size - svcntb(); i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg, &tensor[offset + i]);\n        svst1_u8(pg, &slice[i], vec);\n    }\n\n    if (i < slice_size) {\n        svbool_t remaining_pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(remaining_pg, &tensor[offset + i]);\n        svst1_u8(remaining_pg, &slice[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, slice_size);\n    do {\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, slice_size);\n    } while (svptest_any(svptrue_b8(), pg));\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                size_t jj = j;\n                svbool_t pg = svwhilelt_b16(jj, j_end);\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1_s16(pg, &src[ii * cols + jj]);\n                    svst1_s16(pg, &dst[jj * rows + ii], vec);\n                    jj += svcntw();\n                    pg = svwhilelt_b16(jj, j_end);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                for (size_t jj = j; jj < j_end; jj += svcntw()) {\n                    svbool_t pg = svwhilelt_b16(jj, j_end);\n                    svint16_t vec = svld1(pg, &src[ii * cols + jj]);\n                    svst1(pg, &dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                size_t jj = j;\n                for (; jj < j_end; jj += svcntw()) {\n                    svbool_t pg = svwhilelt_b16(jj, j_end);\n                    svint16_t vec = svld1(pg, &src[ii * cols + jj]);\n                    size_t idx = jj * rows + ii;\n                    svst1_scatter_index(pg, &dst[idx], svindex_u64(0, rows * sizeof(int16_t)), vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                for (size_t jj = j; jj < j_end; jj += svcntw()) {\n                    svbool_t pg = svwhilelt_b16(jj, j_end);\n                    svint16_t vec = svld1(pg, &src[ii * cols + jj]);\n                    svst1(pg, &dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, ii, jj;\n    svbool_t pg;\n    svint16_t vec;\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (ii = i; ii < i_end; ++ii) {\n                for (jj = j; jj < j_end; jj += svcntw()) {\n                    pg = svwhilelt_b16(jj, j_end);\n                    vec = svld1(pg, &src[ii * cols + jj]);\n                    svst1(pg, &dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < dim; i++) {\n        size_t idx = i * dim * dim + i * dim + i;\n        svfloat32_t val = svld1_f32(pg, &array[idx]);\n        sum_vec = svadd_f32_z(pg, sum_vec, val);\n    }\n    \n    float sum = svaddv_f32(pg, sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, dim);\n        svfloat32_t diag = svld1_f32(p, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_z(pg, sum_vec, diag);\n    }\n    \n    return svaddv_f32(pg, sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, dim);\n        svfloat32_t data = svld1_f32(p, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_m(p, sum_vec, data);\n    }\n    \n    return svaddv_f32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svfloat32_t vsum = svdup_n_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n\n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, dim);\n        size_t idx = i * (dim * dim + dim + 1);\n        svfloat32_t vdata = svld1_f32(p, &array[idx]);\n        vsum = svadd_f32_m(p, vsum, vdata);\n    }\n\n    sum = svaddv_f32(pg, vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= dim - vec_len; i += vec_len) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        svfloat32_t data = svld1_f32(pg, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_z(pg, sum_vec, data);\n    }\n\n    float sum = svaddv_f32(svptrue_b32(), sum_vec);\n\n    for (; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        const double *src_row = src + i * cols;\n        double *dst_row = dst + i * cols;\n        \n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec_src = svld1(pg, src_row + j);\n            svfloat64_t vec_threshold = svdup_f64(threshold);\n            svfloat64_t vec_scale = svdup_f64(scale);\n            \n            svbool_t mask = svcmpgt(pg, vec_src, vec_threshold);\n            svfloat64_t vec_result = svsel(mask, svmul_f64_z(pg, vec_src, vec_scale), vec_src);\n            \n            svst1(pg, dst_row + j, vec_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t len = rows * cols;\n    size_t vec_len = svcntd();\n    \n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    svfloat64_t scale_vec = svdup_f64(scale);\n    \n    for (size_t i = 0; i < len; i += vec_len) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svfloat64_t src_vec = svld1_f64(pg, &src[i]);\n        svbool_t mask = svcmpgt_f64(pg, src_vec, thresh_vec);\n        svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, scale_vec);\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec);\n        svst1_f64(pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec_src = svld1_f64(pg, &src[i * cols + j]);\n            svbool_t mask = svcmpgt_f64(pg, vec_src, svdup_f64(threshold));\n            svfloat64_t vec_scaled = svmul_f64_z(pg, vec_src, svdup_f64(scale));\n            svfloat64_t vec_result = svsel_f64(mask, vec_scaled, vec_src);\n            svst1_f64(pg, &dst[i * cols + j], vec_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    size_t vec_len = svcntd();\n    svbool_t pg;\n\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += vec_len) {\n            pg = svwhilelt_b64(j, cols);\n            svfloat64_t src_vec = svld1_f64(pg, &src[i * cols + j]);\n            svbool_t mask = svcmpgt_f64(pg, src_vec, svdup_f64(threshold));\n            svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, svdup_f64(scale));\n            svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec);\n            svst1_f64(pg, &dst[i * cols + j], result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t len = rows * cols;\n    size_t vec_len = svcntd();\n    \n    svbool_t pg = svptrue_b64();\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n    \n    for (size_t i = 0; i < len; i += vec_len) {\n        svbool_t active = svwhilelt_b64(i, len);\n        svfloat64_t v_src = svld1_f64(active, &src[i]);\n        \n        svbool_t mask = svcmpgt_f64(active, v_src, v_threshold);\n        svfloat64_t v_scaled = svmul_f64_z(mask, v_src, v_scale);\n        svfloat64_t v_result = svsel_f64(mask, v_scaled, v_src);\n        \n        svst1_f64(active, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, src_row + j);\n            svst1_f64(pg, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        const double *src_ptr = src + src_row * cols;\n        double *dst_ptr = dst + i * cols;\n\n        for (size_t j = 0; j < cols; j += vec_len) {\n            svbool_t mask = svwhilelt_b64(j, cols);\n            svfloat64_t data = svld1_f64(mask, src_ptr + j);\n            svst1_f64(mask, dst_ptr + j, data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, src_row + j);\n            svst1_f64(pg, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        svbool_t pg = svwhilelt_b64(i, rows);\n        size_t j = 0;\n\n        for (; j < cols - svcntd() + 1; j += svcntd()) {\n            svfloat64_t src_vec = svld1_f64(pg, &src[idx * cols + j]);\n            svst1_f64(pg, &dst[i * cols + j], src_vec);\n        }\n\n        if (j < cols) {\n            svbool_t pg_rem = svwhilelt_b64(j, cols);\n            svfloat64_t src_vec = svld1_f64(pg_rem, &src[idx * cols + j]);\n            svst1_f64(pg_rem, &dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        size_t src_offset = src_row * cols;\n        size_t dst_offset = i * cols;\n\n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t scalar_vec = svdup_s64(scalar);\n\n    for (; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1_s64(p, &src1[i]);\n        svint64_t v2 = svld1_s64(p, &src2[i]);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        svint64_t sum_with_scalar = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t result = svdiv_n_s64_z(pg, sum_with_scalar, 2);\n        svst1_s64(p, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        svint64_t sum_scalar = svadd_s64_z(pg, sum, svdup_s64(scalar));\n        svint64_t result = svdiv_s64_z(pg, sum_scalar, svdup_s64(2));\n        svst1_s64(pg, dst + i, result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t scalar_vec = svdup_s64(scalar);\n\n    for (; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1_s64(p, &src1[i]);\n        svint64_t v2 = svld1_s64(p, &src2[i]);\n        svint64_t sum = svadd_s64_z(p, v1, v2);\n        svint64_t sum_with_scalar = svadd_s64_z(p, sum, scalar_vec);\n        svint64_t result = svdiv_s64_z(p, sum_with_scalar, 2);\n        svst1_s64(p, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n\n    for (; i < length; i += svcntd()) {\n        svbool_t mask = svwhilelt_b64(i, length);\n        svint64_t vec1 = svld1_s64(mask, &src1[i]);\n        svint64_t vec2 = svld1_s64(mask, &src2[i]);\n        svint64_t result = svadd_s64_z(pg, vec1, vec2);\n        result = svadd_s64_z(pg, result, svdup_s64(scalar));\n        result = svdiv_n_s64_z(pg, result, 2);\n        svst1_s64(mask, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t scalar_vec = svdup_s64(scalar);\n\n    for (; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1_s64(p, &src1[i]);\n        svint64_t v2 = svld1_s64(p, &src2[i]);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        svint64_t sum_with_scalar = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t result = svdiv_n_s64_z(pg, sum_with_scalar, 2);\n        svst1_s64(p, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svint32_t min_vec = svdup_n_s32(INT32_MAX);\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_mask = svzip1_b32(pg, svnot_b_z(pg, pg));\n        min_vec = svmin_z(even_mask, min_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n\n    int min_val = INT32_MAX;\n    int32_t temp[svcntw()];\n    svst1_s32(pg, temp, min_vec);\n    for (size_t j = 0; j < svcntw(); j++) {\n        if (temp[j] < min_val) {\n            min_val = temp[j];\n        }\n    }\n\n    if (min_val == INT32_MAX) {\n        return -1;\n    }\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    svbool_t even_mask = svzip1_b32(svpfalse_b(), svptrue_b32());\n\n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svbool_t even_pg = svand_b_z(pg, pg, even_mask);\n        min_vec = svmin_s32_m(pg, min_vec, svsel_s32(even_pg, vec, min_vec));\n        pg = svwhilelt_b32(i + svcntw(), length);\n        even_mask = svnot_b_z(pg, even_mask);\n    }\n\n    int min_val = svminv_s32(svptrue_b32(), min_vec);\n\n    for (; i < length; i += 2) {\n        if (i < length && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svint32_t min_vec = svdup_n_s32(INT32_MAX);\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_mask = svzip1_b32(pg, svnot_b_z(pg, pg));\n        min_vec = svmin_s32_m(even_mask, min_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n\n    int min_val = INT32_MAX;\n    int temp[svcntw()];\n    svst1_s32(pg, temp, min_vec);\n    for (size_t j = 0; j < svcntw(); j++) {\n        if (temp[j] < min_val) {\n            min_val = temp[j];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    size_t i = 0;\n\n    // Process even indices using SVE\n    for (; i + 1 < length; i += svcntw() * 2) {\n        svbool_t pg_even = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(pg_even, &src[i]);\n        min_vec = svmin_s32_m(pg_even, min_vec, vec);\n\n        // Skip to next even index\n        i += svcntw();\n        if (i >= length) break;\n\n        svbool_t pg_odd = svwhilelt_b32(i, length);\n        vec = svld1_s32(pg_odd, &src[i]);\n        min_vec = svmin_s32_m(pg_odd, min_vec, vec);\n    }\n\n    // Handle remaining elements scalarly\n    int min_val = INT32_MAX;\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) min_val = src[i];\n    }\n\n    // Reduce vector to scalar\n    int result = svminv_s32(svptrue_b32(), min_vec);\n    return (min_val < result) ? min_val : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svint32_t min_vec = svdup_n_s32(INT32_MAX);\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_mask = svzip1_b32(pg, svnot_b_z(pg, pg));\n        min_vec = svmin_z(even_mask, min_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Arithmetic right shift\n        svint32_t vec_ashr = svasr_n_s32_z(pg, vec_src, shift);\n        \n        // Logical right shift: convert to uint32, shift, convert back to int32\n        svuint32_t vec_uint = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lshr = svlsr_n_u32_z(pg, vec_uint, shift);\n        svint32_t vec_lshr_int = svreinterpret_s32_u32(vec_lshr);\n        \n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32_z(pg, vec_ashr, vec_lshr_int);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Arithmetic right shift\n        svint32_t vec_arith_shift = svshr_n_s32(pg, vec_src, shift);\n        \n        // Logical right shift: convert to unsigned, shift, then back to signed\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logical_shift_u = svshr_n_u32(pg, vec_unsigned, shift);\n        svint32_t vec_logical_shift = svreinterpret_s32_u32(vec_logical_shift_u);\n        \n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32(pg, vec_arith_shift, vec_logical_shift);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svint32_t vec_src = svld1_s32(pg, &src[i]);\n        \n        svint32_t arith_shift = svasr_n_s32_z(pg, vec_src, shift);\n        \n        svuint32_t vec_uint = svreinterpret_u32_s32(vec_src);\n        svuint32_t logic_shift = svlsr_n_u32_z(pg, vec_uint, shift);\n        svint32_t logic_shift_s32 = svreinterpret_s32_u32(logic_shift);\n        \n        svint32_t result = svadd_s32_z(pg, arith_shift, logic_shift_s32);\n        \n        svst1_s32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        // Load input vector\n        svint32_t vec = svld1(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Convert to uint32 for logical shift\n        svuint32_t vec_u32 = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shift = svlsr_n_u32_z(pg, vec_u32, shift);\n        \n        // Convert logical shift result back to int32 and add to arithmetic shift\n        svint32_t result = svadd_s32_z(pg, arith_shift, \n                                      svreinterpret_s32_u32(logical_shift));\n        \n        // Store result\n        svst1(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svint32_t vec_src = svld1(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t vec_arith = svasr_n_s32_z(pg, vec_src, shift);\n        \n        // Logical right shift: convert to uint32, shift, convert back to int32\n        svuint32_t vec_uint = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logic = svlsr_n_u32_z(pg, vec_uint, shift);\n        svint32_t vec_logic_int = svreinterpret_s32_u32(vec_logic);\n        \n        // Add arithmetic and logical shift results\n        svint32_t vec_result = svadd_s32_z(pg, vec_arith, vec_logic_int);\n        \n        // Store result\n        svst1(pg, dst + i, vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svint32_t sum_vec = svdup_n_s32(0);\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        sum_vec = svadd_s32_z(pg, sum_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n\n    int64_t sum = svaddv_s32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t i = 0;\n\n    // Create a vector of 32-bit integers\n    svint32_t vec;\n    // Create a predicate for active lanes\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    for (; i + svcntw() <= total_elements; i += svcntw()) {\n        // Load a chunk of the matrix into the vector\n        vec = svld1_s32(pg, &matrix[i]);\n        // Add the vector elements to the sum (horizontal reduction)\n        sum += svaddv_s32(pg, vec);\n    }\n\n    // Handle remaining elements that don't fit into a full vector\n    if (i < total_elements) {\n        // Adjust predicate to only process remaining elements\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1_s32(pg, &matrix[i]);\n        sum += svaddv_s32(pg, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svint32_t vsum = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    for (; i < total - (total % svcntw()); i += svcntw()) {\n        svint32_t vec = svld1(pg, &matrix[i]);\n        vsum = svadd_z(pg, vsum, vec);\n    }\n\n    int64_t sum = svaddv(pg, vsum);\n\n    for (; i < total; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t i = 0;\n\n    // Create a vector type for 32-bit integers\n    svint32_t vec;\n    // Create a predicate for active lanes\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    for (; i + svcntw() <= total_elements; i += svcntw()) {\n        // Load a chunk of the matrix into a vector\n        vec = svld1(pg, &matrix[i]);\n        // Add elements of the vector to the sum (using horizontal reduction)\n        sum += svaddv(pg, vec);\n    }\n\n    // Handle remaining elements that don't fit into a full vector\n    if (i < total_elements) {\n        // Adjust predicate to only process remaining elements\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1(pg, &matrix[i]);\n        sum += svaddv(pg, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t i = 0;\n\n    // Create a vector predicate for active lanes\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks using SVE vector length\n    for (; i + svcntw() <= total_elements; i += svcntw()) {\n        // Load a vector of int32_t from the matrix\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        // Convert int32_t vector to int64_t vector for accumulation\n        svint64_t vec64 = svcvt_s64_s32_z(pg, vec);\n        // Accumulate the sum using SVE reduction\n        sum += svaddv_s64(pg, vec64);\n    }\n\n    // Handle remaining elements scalar-wise\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svint8_t max_val_vec = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx_vec = svdup_n_u64(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n\n    do {\n        svint8_t data = svld1_s8(pg, &src[i]);\n        svuint64_t idx = svindex_u64(i, 1);\n        svbool_t cmp = svcmpgt_s8(pg, data, max_val_vec);\n        max_val_vec = svsel_s8(cmp, data, max_val_vec);\n        max_idx_vec = svsel_u64(cmp, idx, max_idx_vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    } while (svptest_any(svptrue_b8(), pg));\n\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n    int8_t temp_max_vec[svcntb()];\n    uint64_t temp_idx_vec[svcntb()];\n    svst1_s8(svptrue_b8(), temp_max_vec, max_val_vec);\n    svst1_u64(svptrue_b8(), temp_idx_vec, max_idx_vec);\n\n    for (size_t j = 0; j < svcntb(); j++) {\n        if (temp_max_vec[j] > max_val) {\n            max_val = temp_max_vec[j];\n            max_idx = temp_idx_vec[j];\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_val = svdup_n_s8(src[0]);\n    svuint64_t max_idx = svdup_n_u64(0);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active = svwhilelt_b8(i, length);\n        svint8_t vec = svld1_s8(active, src + i);\n        svuint64_t idx = svindex_u64(i, 1);\n\n        svbool_t mask = svcmpgt_s8(active, vec, max_val);\n        max_val = svsel_s8(mask, vec, max_val);\n        max_idx = svsel_u64(mask, idx, max_idx);\n\n        i += svcntb();\n    }\n\n    int8_t final_max = svmaxv_s8(pg, max_val);\n    svbool_t final_mask = svcmpeq_s8(pg, max_val, final_max);\n    return svminv_u64(final_mask, max_idx);\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svint8_t max_val_vec = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx_vec = svdup_n_u64(0);\n    svbool_t pg = svptrue_b8();\n    size_t max_idx = 0;\n    int8_t max_val = INT8_MIN;\n    size_t i = 0;\n\n    while (i < length) {\n        size_t remaining = length - i;\n        svbool_t active_pg = svwhilelt_b8(i, length);\n        svint8_t data_vec = svld1_s8(active_pg, &src[i]);\n        svuint64_t idx_vec = svindex_u64(i, 1);\n\n        svbool_t cmp_mask = svcmpgt_s8(active_pg, data_vec, max_val_vec);\n        max_val_vec = svsel_s8(cmp_mask, data_vec, max_val_vec);\n        max_idx_vec = svsel_u64(cmp_mask, idx_vec, max_idx_vec);\n\n        i += svcntb();\n    }\n\n    int8_t local_max_vals[svcntb()];\n    size_t local_max_idxs[svcntb()];\n    svst1_s8(pg, local_max_vals, max_val_vec);\n    svst1_u64(pg, local_max_idxs, max_idx_vec);\n\n    for (size_t j = 0; j < svcntb() && i - svcntb() + j < length; j++) {\n        if (local_max_vals[j] > max_val) {\n            max_val = local_max_vals[j];\n            max_idx = local_max_idxs[j];\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svint8_t max_val_vec = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx_vec = svdup_n_u64(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n    size_t i = 0;\n    size_t max_idx = 0;\n    int8_t max_val = INT8_MIN;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t data = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, data, max_val_vec);\n        \n        max_val_vec = svsel_s8(cmp, data, max_val_vec);\n        svuint64_t current_idx = svindex_u64(i, 1);\n        max_idx_vec = svsel_u64(cmp, current_idx, max_idx_vec);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    int8_t local_max_vals[svcntb()];\n    uint64_t local_max_idxs[svcntb()];\n    svst1_s8(svptrue_b8(), local_max_vals, max_val_vec);\n    svst1_u64(svptrue_b8(), local_max_idxs, max_idx_vec);\n\n    for (size_t j = 0; j < svcntb(); j++) {\n        if (local_max_vals[j] > max_val) {\n            max_val = local_max_vals[j];\n            max_idx = local_max_idxs[j];\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svint8_t max_val_vec = svdup_n_s8(INT8_MIN);\n    svuint64_t max_idx_vec = svdup_n_u64(0);\n    svbool_t pg = svptrue_b8();\n    size_t max_idx = 0;\n    int8_t max_val = INT8_MIN;\n    size_t i = 0;\n\n    while (i < length) {\n        size_t remaining = length - i;\n        svbool_t active_pg = svwhilelt_b8(i, length);\n        svint8_t data = svld1_s8(active_pg, &src[i]);\n        svuint64_t idx_vec = svindex_u64(i, 1);\n\n        svbool_t cmp = svcmpgt_s8(active_pg, data, max_val_vec);\n        max_val_vec = svsel_s8(cmp, data, max_val_vec);\n        max_idx_vec = svsel_u64(cmp, idx_vec, max_idx_vec);\n\n        i += svcntb();\n    }\n\n    int8_t local_max_vals[svcntb()];\n    size_t local_max_idxs[svcntb()];\n    svst1_s8(pg, local_max_vals, max_val_vec);\n    svst1_u64(pg, local_max_idxs, max_idx_vec);\n\n    for (size_t j = 0; j < svcntb() && j < length; j++) {\n        if (local_max_vals[j] > max_val) {\n            max_val = local_max_vals[j];\n            max_idx = local_max_idxs[j];\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, mask);\n        svbool_t mask_pred = svcmpne_u16(pg, masked_indices, 0);\n        svuint16_t vec_src1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec_src2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svsel_u16(mask_pred, vec_src1, vec_src2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    do {\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svcvt_u32_u16_x(pg, indices);\n        svuint32_t masked_indices = svand_u32_x(pg, indices_u32, mask);\n        svbool_t cond = svcmpne_u32(pg, masked_indices, 0);\n        svuint16_t result = svsel_u16(cond, vec_src1, vec_src2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, svdup_u16(mask));\n        svbool_t cond = svcmpne_u16(pg, masked_indices, 0);\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svsel_u16(cond, vec1, vec2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    do {\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t vec_idx = svindex_u16(i, 1);\n        svuint32_t vec_idx32 = svcvt_u32_u16_x(pg, vec_idx);\n        svuint32_t masked_idx = svand_u32_x(pg, vec_idx32, mask);\n        svbool_t cond = svcmpne_u32(pg, masked_idx, 0);\n        svuint16_t result = svsel_u16(cond, vec_src1, vec_src2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    do {\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svcvt_u32_u16_z(pg, indices);\n        svuint32_t masked_indices = svand_u32_z(pg, indices_u32, mask);\n        svbool_t cond = svcmpne_u32(pg, masked_indices, 0);\n        svuint16_t result = svsel_u16(cond, vec_src1, vec_src2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svuint32_t vec = svld1_u32(pg, &src[i]);\n        svuint32_t count = svcntw_pat_u32(SV_ALL, vec);\n        svst1_u32(pg, &dst[i], count);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, &src[i]);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, &dst[i], popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svuint32_t vec = svld1_u32(pg, &src[i]);\n        svuint32_t count = svcntw_pat_u32(SV_ALL, vec);\n        svst1_u32(pg, &dst[i], count);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    \n    while (i < length) {\n        // Determine how many elements to process in this iteration\n        svbool_t active = svwhilelt_b16(i, length);\n        pg = svand_b_z(svptrue_b16(), active, active);\n        \n        // Load vectors from src1 and src2\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        \n        // Perform saturating addition\n        svuint16_t result = svqadd_u16(vec1, vec2);\n        \n        // Store the result to dst\n        svst1_u16(pg, &dst[i], result);\n        \n        // Increment the index by the number of elements processed\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svqadd_u16(vec1, vec2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t v1 = svld1_u16(pg, &src1[i]);\n        svuint16_t v2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg, &dst[i], result);\n    }\n    \n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg_tail, &src1[i]);\n        svuint16_t v2 = svld1_u16(pg_tail, &src2[i]);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg_tail, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t v1 = svld1_u16(pg, &src1[i]);\n        svuint16_t v2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg, &dst[i], result);\n    }\n    \n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg_tail, &src1[i]);\n        svuint16_t v2 = svld1_u16(pg_tail, &src2[i]);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg_tail, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    \n    while (i < length) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(active, &src1[i]);\n        svuint16_t v2 = svld1_u16(active, &src2[i]);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(active, &dst[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n                \n                svbool_t a_valid = svand_b_z(pg, \n                    svcmplt_f64(pg, a_vec, upper_bound), \n                    svcmpgt_f64(pg, a_vec, lower_bound));\n                \n                svbool_t b_valid = svand_b_z(pg, \n                    svcmplt_f64(pg, b_vec, upper_bound), \n                    svcmpgt_f64(pg, b_vec, lower_bound));\n                \n                svbool_t valid = svand_b_z(pg, a_valid, b_valid);\n                \n                svfloat64_t prod = svmul_f64_z(valid, a_vec, b_vec);\n                sum = svadd_f64_z(pg, sum, prod);\n                \n                k += svcntd();\n            }\n            \n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t a_valid = svand_b_z(svtrue_b64(),\n                    svcmpge_f64(pg, a_vec, lower_bound),\n                    svcmple_f64(pg, a_vec, upper_bound));\n                svbool_t b_valid = svand_b_z(svtrue_b64(),\n                    svcmpge_f64(pg, b_vec, lower_bound),\n                    svcmple_f64(pg, b_vec, upper_bound));\n                svbool_t valid = svand_b_z(svtrue_b64(), a_valid, b_valid);\n\n                sum = svmla_m(valid, sum, a_vec, b_vec);\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(svtrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n                \n                svbool_t a_mask = svand_b_z(pg, svcmple_f64(pg, a_vec, upper_bound), svcmpge_f64(pg, a_vec, lower_bound));\n                svbool_t b_mask = svand_b_z(pg, svcmple_f64(pg, b_vec, upper_bound), svcmpge_f64(pg, b_vec, lower_bound));\n                svbool_t combined_mask = svand_b_z(pg, a_mask, b_mask);\n                \n                sum = svmla_m(combined_mask, sum, a_vec, b_vec);\n                \n                k += svcntd();\n            }\n            \n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n    svbool_t all_true = svptrue_b64();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t mask_a = svand_b_z(all_true,\n                    svcmplt_f64(pg, a_vec, upper_bound),\n                    svcmpgt_f64(pg, a_vec, lower_bound));\n                svbool_t mask_b = svand_b_z(all_true,\n                    svcmplt_f64(pg, b_vec, upper_bound),\n                    svcmpgt_f64(pg, b_vec, lower_bound));\n                svbool_t mask = svand_b_z(pg, mask_a, mask_b);\n\n                svfloat64_t prod = svmul_f64_m(mask, a_vec, b_vec);\n                sum = svadd_f64_m(mask, sum, prod);\n\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(all_true, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t a_mask = svand_b_z(pg, svcmpge_f64(pg, a_vec, lower_bound), svcmple_f64(pg, a_vec, upper_bound));\n                svbool_t b_mask = svand_b_z(pg, svcmpge_f64(pg, b_vec, lower_bound), svcmple_f64(pg, b_vec, upper_bound));\n                svbool_t mask = svand_b_z(pg, a_mask, b_mask);\n\n                sum = svmla_m(mask, sum, a_vec, b_vec);\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a = svld1_s64(pg, &A[i]);\n        svint64_t b = svld1_s64(pg, &B[i]);\n        svint64_t sum = svadd_s64_z(pg, a, b);\n        svst1_s64(pg, &C[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_size; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_size);\n        svint64_t a = svld1_s64(pg, A + i);\n        svint64_t b = svld1_s64(pg, B + i);\n        svint64_t c = svadd_s64_z(pg, a, b);\n        svst1_s64(pg, C + i, c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, A + i);\n        svint64_t vb = svld1_s64(pg, B + i);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svfloat32_t v1 = svld1(pg, &src1[i]);\n        svfloat32_t v2 = svld1(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1(pg, &dst[i], rounded);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1(pg_rem, &src1[i]);\n        svfloat32_t v2 = svld1(pg_rem, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg_rem, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg_rem, sum);\n        svst1(pg_rem, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svfloat32_t v1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n    \n    // Handle remaining elements if length is not a multiple of vector length\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg_rem, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg_rem, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg_rem, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg_rem, sum);\n        svst1_f32(pg_rem, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        \n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svfloat32_t v1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg_rem, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg_rem, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg_rem, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg_rem, sum);\n        svst1_f32(pg_rem, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n        svbool_t cond1 = svcmplt_f32(pg, abs_diff, 50.0f);\n        \n        svbool_t cond2 = svptrue_b32();\n        if (i % 2 == 0) {\n            svuint32_t indices = svindex_u32(i, 1);\n            cond2 = svcmpeq_u32(pg, svand_u32_x(pg, indices, 1), 0);\n        } else {\n            cond2 = svpfalse_b();\n        }\n        \n        svbool_t final_cond = svand_b_z(pg, cond1, cond2);\n        \n        svfloat32_t result = svmul_f32_m(final_cond, v1, v2);\n        result = svceil_f32_m(final_cond, result);\n        \n        svfloat32_t default_val = svdup_f32(-1.0f);\n        result = svsel_f32(final_cond, result, default_val);\n        \n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t minus_one = svdup_f32(-1.0f);\n    svfloat32_t threshold = svdup_f32(50.0f);\n\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svfloat32_t v1 = svld1(pg, &src1[i]);\n        svfloat32_t v2 = svld1(pg, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, v1, v2));\n\n        // Condition 1: Absolute difference <= 50\n        svbool_t cond1 = svcmple_f32(pg, diff, threshold);\n\n        // Condition 2: Index is multiple of 2\n        svbool_t cond2 = svptrue_b32();\n        for (size_t j = 0; j < svcntw(); j++) {\n            if ((i + j) % 2 != 0) {\n                cond2 = svpfalse_b();\n                break;\n            }\n        }\n\n        // Combine conditions\n        svbool_t final_cond = svand_b_z(pg, cond1, cond2);\n\n        // Element-wise multiplication\n        svfloat32_t mul_result = svmul_f32_m(final_cond, v1, v2);\n\n        // Round up to positive infinity\n        svfloat32_t rounded_result = svrintp_f32_m(minus_one, final_cond, mul_result);\n\n        // Store result: use rounded result where conditions are met, -1 otherwise\n        svst1(pg, &dst[i], svsel_f32(final_cond, rounded_result, minus_one));\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t vneg1 = svdup_f32(-1.0f);\n    svfloat32_t v50 = svdup_f32(50.0f);\n\n    for (; i < length; i += svcntw()) {\n        svbool_t pgt = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pgt, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pgt, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t vdiff = svabs_f32_x(pgt, svsub_f32_x(pgt, v1, v2));\n\n        // Condition 1: absolute difference <= 50\n        svbool_t cond1 = svcmple_f32(pgt, vdiff, v50);\n\n        // Condition 2: index is multiple of 2\n        svbool_t cond2 = svptrue_b32();\n        for (size_t j = 0; j < svcntw(); j++) {\n            if ((i + j) % 2 != 0) {\n                cond2 = svpfalse_b();\n                break;\n            }\n        }\n\n        // Combine conditions\n        svbool_t cond = svand_b_z(pgt, cond1, cond2);\n\n        // Element-wise multiplication\n        svfloat32_t vresult = svmul_f32_m(cond, v1, v2);\n\n        // Round up to positive infinity (ceiling)\n        vresult = svrintp_f32_m(vresult, cond, vresult);\n\n        // Set result to -1 for elements not meeting conditions\n        vresult = svsel_f32(cond, vresult, vneg1);\n\n        // Store result\n        svst1_f32(pgt, &dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_z(pg, diff);\n        \n        svbool_t cond1 = svcmplt_f32(pg, abs_diff, svdup_f32(50.0f));\n        \n        svbool_t cond2 = svptrue_b32();\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t even_mask = svcmpeq_u32(pg, svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n        \n        svbool_t final_mask = svand_b_z(pg, cond1, even_mask);\n        \n        svfloat32_t result = svmul_f32_z(final_mask, v1, v2);\n        result = svceil_f32_z(final_mask, result);\n        \n        svfloat32_t output = svdup_f32(-1.0f);\n        output = svsel_f32(final_mask, result, output);\n        \n        svst1_f32(pg, dst + i, output);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n        svbool_t cond1 = svcmple_f32(pg, abs_diff, 50.0f);\n        \n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(pg, svand_u32_x(pg, indices, 1), 0);\n        \n        svbool_t mask = svand_b_z(pg, cond1, cond2);\n        \n        svfloat32_t result = svmul_f32_m(mask, v1, v2);\n        result = svceil_f32_m(mask, result);\n        \n        svfloat32_t default_val = svdup_f32(-1.0f);\n        result = svsel_f32(mask, result, default_val);\n        \n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n\n    // Create a vector with the scalar value replicated across all lanes\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n\n    // Process elements in chunks based on vector length\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        // Load a chunk of the input matrix\n        svfloat64_t mat_vec = svld1(pg, &mat[i]);\n        // Perform element-wise multiplication with the scalar\n        svfloat64_t result_vec = svmul_f64(pg, mat_vec, scalar_vec);\n        // Store the result in the destination matrix\n        svst1(pg, &dst[i], result_vec);\n    }\n\n    // Handle remaining elements if total_elements is not a multiple of vector length\n    if (i < total_elements) {\n        svbool_t remaining_pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1(remaining_pg, &mat[i]);\n        svfloat64_t result_vec = svmul_f64(remaining_pg, mat_vec, scalar_vec);\n        svst1(remaining_pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    \n    size_t i = 0;\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n\n    // Load scalar value into a vector for multiplication\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n\n    // Process elements in chunks based on vector length\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        svfloat64_t mat_vec = svld1(pg, &mat[i]);\n        svfloat64_t result_vec = svmul_f64(pg, mat_vec, scalar_vec);\n        svst1(pg, &dst[i], result_vec);\n    }\n\n    // Handle remaining elements if total_elements is not a multiple of vector length\n    if (i < total_elements) {\n        svbool_t remaining_pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1(remaining_pg, &mat[i]);\n        svfloat64_t result_vec = svmul_f64(remaining_pg, mat_vec, scalar_vec);\n        svst1(remaining_pg, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t i = 0;\n    \n    for (; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        svfloat64_t result = svmul_f64_z(pg, vec, scalar_vec);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t total_elements = m * n;\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < total_elements; i += vec_len) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sum_sq = 0.0f;\n\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t sq_vec = svmul_f32_x(pg, vec, vec);\n            sum_sq += svadda_f32(pg, 0.0f, sq_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n\n        float norm = sqrtf(sum_sq);\n        if (norm > 0.0f) {\n            float inv_norm = 1.0f / norm;\n            j = 0;\n            pg = svwhilelt_b32(j, n);\n            do {\n                svfloat32_t vec = svld1_f32(pg, row + j);\n                svfloat32_t norm_vec = svmul_n_f32_x(pg, vec, inv_norm);\n                svst1_f32(pg, row + j, norm_vec);\n                j += svcntw();\n                pg = svwhilelt_b32(j, n);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n\n        // Compute sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            sum = svmla_f32_x(pg, sum, vec, vec);\n        }\n\n        // Compute L2 norm (square root of sum of squares)\n        float norm = sqrtf(svaddv_f32(pg, sum));\n\n        // Avoid division by zero\n        if (norm == 0.0f) continue;\n\n        // Normalize the row\n        svfloat32_t norm_vec = svdup_f32(1.0f / norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            svfloat32_t result = svmul_f32_x(mask, vec, norm_vec);\n            svst1_f32(mask, row + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n\n        // Compute sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            sum = svmla_f32_x(pg, sum, vec, vec);\n        }\n\n        // Horizontal sum to get L^2 norm squared\n        float norm_squared = svaddv_f32(pg, sum);\n        float norm = sqrtf(norm_squared);\n        float inv_norm = (norm != 0.0f) ? 1.0f / norm : 0.0f;\n\n        // Normalize the row\n        svfloat32_t inv_norm_vec = svdup_f32(inv_norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            vec = svmul_f32_x(mask, vec, inv_norm_vec);\n            svst1_f32(mask, row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sum_sq = 0.0f;\n\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t sq = svmul_f32_z(pg, vec, vec);\n            sum_sq += svadda_f32(pg, 0.0f, sq);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n\n        float norm = sqrtf(sum_sq);\n        if (norm > 0.0f) {\n            float inv_norm = 1.0f / norm;\n            j = 0;\n            pg = svwhilelt_b32(j, n);\n            do {\n                svfloat32_t vec = svld1_f32(pg, row + j);\n                svfloat32_t scaled = svmul_n_f32_z(pg, vec, inv_norm);\n                svst1_f32(pg, row + j, scaled);\n                j += svcntw();\n                pg = svwhilelt_b32(j, n);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sum_sq = 0.0f;\n\n        // Calculate sum of squares for the row using SVE\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            sum_vec = svmla_f32_x(pg, sum_vec, vec, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n\n        // Horizontal reduction to get total sum of squares\n        sum_sq = svaddv_f32(svptrue_b32(), sum_vec);\n\n        // Calculate L2 norm (sqrt of sum of squares)\n        float norm = sqrtf(sum_sq);\n        if (norm > 0.0f) {\n            float inv_norm = 1.0f / norm;\n            svfloat32_t inv_norm_vec = svdup_n_f32(inv_norm);\n\n            // Normalize the row by dividing each element by the L2 norm\n            j = 0;\n            pg = svwhilelt_b32(j, n);\n            do {\n                svfloat32_t vec = svld1_f32(pg, row + j);\n                svfloat32_t normalized = svmul_f32_x(pg, vec, inv_norm_vec);\n                svst1_f32(pg, row + j, normalized);\n                j += svcntw();\n                pg = svwhilelt_b32(j, n);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svwhilelt_b64(0, n);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t p = svwhilelt_b64(k, n);\n                \n                svfloat64_t a = svld1_f64(p, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(p, &mat2[k * p + j]);\n                \n                sum = svmla_m(p, sum, a, b);\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = (double)round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            \n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmad_f64_m(pg, a, b, sum);\n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            \n            for (; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t a = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1(pg, &mat2[k * p + j]);\n                \n                sum = svmad_f64_m(pg, a, b, sum);\n            }\n            \n            double final_sum = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(final_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            for (; k < n - (n % svcntd()); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmad_f64_m(pg, a, b, sum);\n            }\n            \n            for (; k < n; k++) {\n                double a_val = mat1[i * n + k];\n                double b_val = mat2[k * p + j];\n                sum = svadd_f64_x(svptrue_b64(), sum, svmul_f64_x(svptrue_b64(), svdup_f64(a_val), svdup_f64(b_val)));\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t vec1, vec2, result;\n    size_t vl = svcntd(); // Get vector length for doubles\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            // Process in chunks based on vector length\n            for (; k + vl <= n; k += vl) {\n                pg = svwhilelt_b64(k, n);\n                vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                vec2 = svld1_f64(pg, &mat2[k * p + j]);\n                result = svmad_f64_m(pg, result, vec1, vec2);\n                sum += svadda_f64(pg, 0.0, result);\n            }\n\n            // Handle remaining elements\n            for (; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            // Round to nearest integer and store\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t vec, rounded_vec;\n    svbool_t pg = svwhilelt_b32(0, (uint32_t)cols);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            pg = svwhilelt_b32((uint32_t)j, (uint32_t)cols);\n            vec = svld1_f32(pg, &src[i * cols + j]);\n            rounded_vec = svrinta_f32_x(pg, svmul_n_f32_x(pg, vec, 4.0f));\n            rounded_vec = svdiv_n_f32_x(pg, rounded_vec, 4.0f);\n            svst1_f32(pg, &dst[j * rows + i], rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t vec, rounded_vec;\n    svbool_t pg = svptrue_b32();\n    float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_f32(quarter);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            // Load a vector of floats from the source matrix\n            vec = svld1_f32(pg, &src[i * cols + j]);\n            \n            // Multiply by 4, round to nearest integer, then divide by 4 to get nearest 0.25\n            vec = svmul_f32_z(pg, vec, svdup_f32(4.0f));\n            rounded_vec = svrintn_f32_z(pg, vec);\n            rounded_vec = svmul_f32_z(pg, rounded_vec, quarter_vec);\n            \n            // Store the result in the transposed position\n            svst1_f32(pg, &dst[j * rows + i], rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n        svfloat32_t result = svsub_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded = svrintz_f32_m(pg, result);\n        svst1(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n        svfloat32_t result = svsub_f32_x(pg, vec1, vec2);\n        svfloat32_t rounded = svrintz_f32_x(pg, result);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n        svfloat32_t result = svsub_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded = svrintz_f32_m(pg, result);\n        svst1(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t sub = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrinta_f32_z(pg, sub);\n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n        svfloat32_t result = svsub_f32_x(pg, vec1, vec2);\n        svfloat32_t rounded = svrintz_f32_x(pg, result);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t vec1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t vec2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec1 = svld1(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t v1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t v2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t vec1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t vec2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        const float* row = mat + i * n;\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t vsum = svdup_n_f32(0.0f);\n\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t vmat = svld1_f32(p, row + j);\n            svfloat32_t vvec = svld1_f32(p, vec + j);\n            vsum = svmla_f32_m(p, vsum, vmat, vvec);\n        }\n\n        sum = svaddv_f32(pg, vsum);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_x(pg, sum, mat_vec, vec_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float result = svaddv_f32(svptrue_b32(), sum);\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < m; ++i) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        const float* row = mat + i * n;\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t mat_vec = svld1_f32(p, row + j);\n            svfloat32_t vec_vec = svld1_f32(p, vec + j);\n            sum = svmla_f32_x(pg, sum, mat_vec, vec_vec);\n        }\n        dst[i] = svaddv_f32(pg, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        \n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pm = svwhilelt_b32(j, n);\n            svfloat32_t mat_vec = svld1_f32(pm, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pm, &vec[j]);\n            sum = svmla_m(pm, sum, mat_vec, vec_vec);\n        }\n        \n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        const float* row = mat + i * n;\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, row + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum_vec = svmla_f32_x(pg, sum_vec, mat_vec, vec_vec);\n        }\n\n        sum = svaddv_f32(svptrue_b32(), sum_vec);\n\n        for (; j < n; j++) {\n            sum += row[j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process elements in chunks using SVE vector length\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    for (; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    \n    for (size_t i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg_loop = svwhilelt_b64(i, m * n);\n        svfloat64_t vec = svld1_f64(pg_loop, mat + i);\n        sum_vec = svadd_f64_z(pg_loop, sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / (double)(m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t mask = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(mask, mat + i);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n\n    double sum = svaddv_f64(pg, sum_vec);\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process elements in chunks based on vector length\n    for (; i < total_elements - (total_elements % svcntd()); i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Handle remaining elements\n    if (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Horizontal reduction to get total sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n\n    // Return the average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    for (; i < total_elements; ) {\n        sum_vec = svadd_f64_z(pg, sum_vec, svld1_f64(pg, mat + i));\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        \n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp;\n        if (ascending) {\n            cmp = svcmple_s32(pg, curr, next);\n        } else {\n            cmp = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all_true(pg, cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        \n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp;\n        if (ascending) {\n            cmp = svcmple_s32(pg, curr, next);\n        } else {\n            cmp = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t sorted;\n        if (directions[i]) {\n            // Ascending\n            sorted = svcmple_s32(pg, curr, next);\n        } else {\n            // Descending\n            sorted = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all(pg, sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t is_ascending = directions[i] ? svtrue_b32() : svfalse_b32();\n        \n        svbool_t cmp_asc = svcmplt_s32(pg, curr, next);\n        svbool_t cmp_desc = svcmpgt_s32(pg, curr, next);\n        svbool_t cmp = svsel_b(is_ascending, cmp_asc, cmp_desc);\n        \n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t sorted;\n        if (directions[i]) {\n            // Ascending order check: curr <= next\n            sorted = svcmple_s32(pg, curr, next);\n        } else {\n            // Descending order check: curr >= next\n            sorted = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all_true(pg, sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    int16_t base16 = (int16_t)base;\n    svint16_t vbase = svdup_n_s16(base16);\n\n    do {\n        svint16_t vsrc = svld1_s16(pg, &src[i]);\n        svint16_t vdiv = svdiv_n_s16_x(pg, vsrc, vbase);\n        svint16_t vmul = svmul_n_s16_x(pg, vdiv, vbase);\n        svst1_s16(pg, &dst[i], vmul);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw();\n    int16_t base16 = (int16_t)base;\n\n    for (size_t i = 0; i < length; i += vec_len) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svint16_t vec_src = svld1_s16(active, &src[i]);\n        svint16_t vec_div = svdiv_n_s16_x(active, vec_src, base16);\n        svint16_t vec_mul = svmul_n_s16_x(active, vec_div, base16);\n        svst1_s16(active, &dst[i], vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        svbool_t match = svptrue_b64();\n        while (j < cols) {\n            svfloat64_t mat_vec = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vec_vec = svld1_f64(pg, &vector[j]);\n            svbool_t cmp = svcmpeq_f64(pg, mat_vec, vec_vec);\n            match = svand_b_z(svptrue_b64(), match, cmp);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        svbool_t all_match = svptrue_b64();\n        \n        while (j < cols) {\n            svfloat64_t matrix_vec = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vector_vec = svld1_f64(pg, &vector[j]);\n            svbool_t match = svcmpeq_f64(pg, matrix_vec, vector_vec);\n            all_match = svand_b_z(svptrue_b64(), all_match, match);\n            \n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n        \n        if (svptest_any(svptrue_b64(), all_match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t vec_vec = svld1_f64(pg, vector);\n        svfloat64_t row_vec = svld1_f64(pg, row);\n        svbool_t cmp = svcmpeq_f64(pg, row_vec, vec_vec);\n        \n        if (svptest_all(cmp)) {\n            size_t remaining = cols;\n            while (remaining > 0) {\n                size_t step = svcntd();\n                if (remaining < step) {\n                    pg = svwhilelt_b64(0, remaining);\n                    vec_vec = svld1_f64(pg, vector + (cols - remaining));\n                    row_vec = svld1_f64(pg, row + (cols - remaining));\n                    cmp = svcmpeq_f64(pg, row_vec, vec_vec);\n                    if (!svptest_all(cmp)) {\n                        return false;\n                    }\n                    break;\n                }\n                pg = svwhilelt_b64(0, step);\n                vec_vec = svld1_f64(pg, vector + (cols - remaining));\n                row_vec = svld1_f64(pg, row + (cols - remaining));\n                cmp = svcmpeq_f64(pg, row_vec, vec_vec);\n                if (!svptest_all(cmp)) {\n                    return false;\n                }\n                remaining -= step;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        size_t j = 0;\n        bool row_match = true;\n\n        while (j < cols) {\n            svfloat64_t vec = svld1_f64(pg, &vector[j]);\n            svfloat64_t mat_row = svld1_f64(pg, &matrix[i * cols + j]);\n            svbool_t cmp = svcmpeq_f64(pg, vec, mat_row);\n\n            if (!svptest_all(cmp)) {\n                row_match = false;\n                break;\n            }\n\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svbool_t match = svptrue_b64();\n        size_t j = 0;\n\n        while (j < cols) {\n            svfloat64_t vec_row = svld1_f64(pg, row + j);\n            svfloat64_t vec_vec = svld1_f64(pg, vector + j);\n            svbool_t eq = svcmpeq_f64(pg, vec_row, vec_vec);\n            match = svand_b_z(svptrue_b64(), match, eq);\n\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n\n        if (svptest_any(svptrue_b64(), match)) {\n            bool all_match = true;\n            for (size_t k = 0; k < cols; k++) {\n                if (row[k] != vector[k]) {\n                    all_match = false;\n                    break;\n                }\n            }\n            if (all_match) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        svuint8_t vec_a = svld1_u8(pg, &A[i]);\n        svuint8_t vec_b = svld1_u8(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, eq_mask);\n        i += svcntb();\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    int64_t vec_len = svcntb();\n\n    // Process elements in chunks of vector length\n    while (i + vec_len <= total_elements) {\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n\n        // Load vectors from A and B\n        svuint8_t vec_a = svld1_u8(pg, &A[i]);\n        svuint8_t vec_b = svld1_u8(pg, &B[i]);\n\n        // Compare for equality\n        svbool_t eq_mask = svcmpeq_u8(pg, vec_a, vec_b);\n\n        // Count the number of true values in the predicate\n        equal_count += svcntp_b8(pg, eq_mask);\n\n        i += vec_len;\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svuint8_t a_vec = svld1_u8(pg, &A[i]);\n        svuint8_t b_vec = svld1_u8(pg, &B[i]);\n        \n        svbool_t eq_mask = svcmpeq_u8(pg, a_vec, b_vec);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    int64_t vl = svcntb();\n\n    // Process elements in chunks of vector length\n    for (; i <= total_elements - vl; i += vl) {\n        // Load vectors from A and B\n        svuint8_t vec_a = svld1_u8(svptrue_b8(), &A[i]);\n        svuint8_t vec_b = svld1_u8(svptrue_b8(), &B[i]);\n\n        // Compare vectors for equality\n        svbool_t eq_mask = svcmpeq_u8(svptrue_b8(), vec_a, vec_b);\n\n        // Count the number of true values in the mask\n        equal_count += svcntp_b8(svptrue_b8(), eq_mask);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svuint8_t a_vec = svld1_u8(pg, &A[i]);\n        svuint8_t b_vec = svld1_u8(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_u8(pg, a_vec, b_vec);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vx = svld1_s64(pg, x + i);\n        svint64_t va = svdup_s64(a);\n        svint64_t mul = svmul_s64_z(pg, va, vx);\n        svint64_t abs = svabs_s64_z(pg, y);\n        svint64_t result = svsub_s64_z(pg, mul, abs);\n        svst1_s64(pg, y + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, x + i);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_abs_y = svabs_s64_x(pg, y + i);\n        svint64_t vec_result = svsub_s64_x(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, y + i, vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vx = svld1_s64(pg, x + i);\n        svint64_t va = svdup_s64(a);\n        svint64_t mul = svmul_s64_z(pg, va, vx);\n        svint64_t abs_y = svabs_s64_z(pg, y + i);\n        svint64_t result = svsub_s64_z(pg, mul, abs_y);\n        svst1_s64(pg, y + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_abs_y = svabs_s64_x(pg, &y[i]);\n        svint64_t vec_result = svsub_s64_x(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, &y[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_abs_y = svabs_s64_x(pg, y[i]);\n        svint64_t result = svsub_s64_x(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(INT16_MAX);\n    svint16_t max_vec = svdup_n_s16(INT16_MIN);\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svint16_t data = svld1_s16(pg, &vec[i]);\n        min_vec = svmin_s16_z(pg, min_vec, data);\n        max_vec = svmax_s16_z(pg, max_vec, data);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n\n    int16_t min_val = svminv_s16(pg, min_vec);\n    int16_t max_val = svmaxv_s16(pg, max_vec);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(vec[0]);\n    svint16_t max_vec = svdup_n_s16(vec[0]);\n    svbool_t pg = svptrue_b16();\n    \n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        min_vec = svmin_s16_m(pg, min_vec, data);\n        max_vec = svmax_s16_m(pg, max_vec, data);\n    }\n    \n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, min_vec);\n    result.max_num = svmaxv_s16(pg, max_vec);\n    \n    for (; i < length; i++) {\n        if (vec[i] < result.min_num) result.min_num = vec[i];\n        if (vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t vmin = svdup_n_s16(vec[0]);\n    svint16_t vmax = svdup_n_s16(vec[0]);\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    do {\n        svint16_t v = svld1_s16(pg, &vec[i]);\n        vmin = svmin_s16_z(pg, vmin, v);\n        vmax = svmax_s16_z(pg, vmax, v);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n\n    int16_t min_val = svminv_s16(svptrue_b16(), vmin);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vmax);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(vec[0]);\n    svint16_t max_vec = svdup_n_s16(vec[0]);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svint16_t current_vec = svld1_s16(pg, &vec[i]);\n        min_vec = svmin_s16_z(pg, min_vec, current_vec);\n        max_vec = svmax_s16_z(pg, max_vec, current_vec);\n        i += svcntw();\n    }\n\n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(INT16_MAX);\n    svint16_t max_vec = svdup_n_s16(INT16_MIN);\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svint16_t data = svld1_s16(pg, &vec[i]);\n        min_vec = svmin_s16_z(pg, min_vec, data);\n        max_vec = svmax_s16_z(pg, max_vec, data);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n\n    int16_t min_val = svminv_s16(pg, min_vec);\n    int16_t max_val = svmaxv_s16(pg, max_vec);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t v1 = svld1_s32(pg, row);\n        svint32_t v2 = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, v1, v2);\n        if (!svptest_all(cmp)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t prev_vec = svld1_s32(pg, row);\n        svint32_t next_vec = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmple_s32(pg, next_vec, prev_vec);\n\n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t prev_vec = svld1_s32(pg, row);\n        svint32_t next_vec = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmple_s32(pg, next_vec, prev_vec);\n\n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t prev = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, prev, next);\n        \n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) return false;\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t vec = svld1_s32(pg, row);\n        svint32_t vec_next = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, vec, vec_next);\n        if (!svptest_all(cmp)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svbool_t pg = svwhilelt_b32(0, block_size);\n    svint32_t first_block_row[block_size];\n\n    for (size_t i = 0; i < block_size; i++) {\n        first_block_row[i] = svld1(pg, &matrix[i * cols]);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            size_t block_start = block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; i++) {\n                svint32_t current_row = svld1(pg, &matrix[block_start + i * cols]);\n                svbool_t cmp = svcmpeq(pg, current_row, first_block_row[i]);\n\n                if (!svptest_all(cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n\n    // Process blocks\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) {\n                continue; // Skip first block\n            }\n\n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = block_row * block_size * cols + i * cols;\n                size_t first_row_offset = i * cols;\n                \n                size_t col_offset = block_col * block_size;\n                svbool_t pg = svwhilelt_b32(0, block_size);\n                \n                svint32_t first_block_row = svld1_s32(pg, matrix + first_row_offset);\n                svint32_t curr_block_row = svld1_s32(pg, matrix + row_offset + col_offset);\n                \n                svbool_t cmp = svcmpeq_s32(pg, first_block_row, curr_block_row);\n                \n                if (!svptest_all(cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < blocks_per_col; ++block_row) {\n        for (size_t block_col = 0; block_col < blocks_per_row; ++block_col) {\n            // Skip the first block (no need to compare it with itself)\n            if (block_row == 0 && block_col == 0) continue;\n\n            // Calculate starting indices for the current block and the first block\n            size_t curr_block_start = (block_row * block_size * cols) + (block_col * block_size);\n            size_t first_block_start = 0;\n\n            // Compare each row of the block\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* curr_row = matrix + curr_block_start + (i * cols);\n                const int* first_row = matrix + first_block_start + (i * cols);\n\n                size_t j = 0;\n                for (; j <= block_size - vector_length; j += vector_length) {\n                    svint32_t curr_vec = svld1(svptrue_b32(), curr_row + j);\n                    svint32_t first_vec = svld1(svptrue_b32(), first_row + j);\n                    svbool_t cmp = svcmpeq(svptrue_b32(), curr_vec, first_vec);\n                    if (!svptest_all(cmp)) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements if block_size is not a multiple of vector_length\n                if (j < block_size) {\n                    svbool_t pg = svwhilelt_b32(j, block_size);\n                    svint32_t curr_vec = svld1(pg, curr_row + j);\n                    svint32_t first_vec = svld1(pg, first_row + j);\n                    svbool_t cmp = svcmpeq(pg, curr_vec, first_vec);\n                    if (!svptest_all(cmp)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            // Skip the first block (no need to compare it with itself)\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            // Compare each element in the current block with the corresponding element in the first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset_first = i * cols;\n                size_t row_offset_curr = (block_row * block_size + i) * cols;\n                const int* first_block_row = matrix + row_offset_first;\n                const int* curr_block_row = matrix + row_offset_curr;\n\n                for (size_t j = 0; j < block_size; j += vector_length) {\n                    // Create predicate for active lanes\n                    svbool_t pg = svwhilelt_b32(j, block_size);\n                    // Load vectors from first block and current block\n                    svint32_t vec_first = svld1_s32(pg, first_block_row + j);\n                    svint32_t vec_curr = svld1_s32(pg, curr_block_row + block_col * block_size + j);\n                    // Compare vectors for equality\n                    svbool_t eq_mask = svcmpeq_s32(pg, vec_first, vec_curr);\n                    // Check if all elements in the predicate range are equal\n                    if (!svptest_all(eq_mask)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size * block_size);\n\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            size_t first_block_offset = 0;\n            size_t curr_block_offset = (block_row * cols * block_size) + (block_col * block_size);\n\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = i * cols;\n                svint32_t first_row = svld1_s32(pg, matrix + first_block_offset + row_offset);\n                svint32_t curr_row = svld1_s32(pg, matrix + curr_block_offset + row_offset);\n\n                svbool_t cmp = svcmpeq_s32(pg, first_row, curr_row);\n                if (!svptest_all(cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (vec == nullptr || tolerance < 0 || length == 0 || block_size == 0) {\n        return false;\n    }\n\n    // Check if there are enough elements to form at least one complete block\n    if (length < block_size) {\n        return false;\n    }\n\n    // Number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Vector length in terms of SVE vectors (for double, 64-bit elements)\n    uint64_t vl = svcntd();\n    svbool_t pg = svwhilelt_b64(0, vl);\n\n    // Process block_size elements at a time using SVE\n    for (size_t i = 0; i < block_size; i += vl) {\n        // Load the reference block (first block) for the current set of elements\n        svfloat64_t ref_vec = svld1(pg, &vec[i]);\n\n        // Compare with corresponding elements in other blocks\n        for (size_t b = 1; b < num_blocks; ++b) {\n            svfloat64_t curr_vec = svld1(pg, &vec[b * block_size + i]);\n\n            // Compute absolute difference\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, curr_vec, ref_vec));\n\n            // Check if difference exceeds tolerance\n            svbool_t exceed_tol = svcmpgt_f64(pg, diff, tolerance);\n\n            // If any element exceeds tolerance, return false\n            if (svptest_any(pg, exceed_tol)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t complete_blocks = length / block_size;\n    if (complete_blocks < 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tol_vec = svdup_f64(tolerance);\n    svfloat64_t first_block[block_size / svcntd() + 1];\n\n    // Load the first block into SVE vectors\n    size_t idx = 0;\n    for (size_t i = 0; i < block_size; i += svcntd()) {\n        svbool_t load_pg = svwhilelt_b64(i, block_size);\n        first_block[idx++] = svld1_f64(load_pg, &vec[i]);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < complete_blocks; ++b) {\n        idx = 0;\n        for (size_t i = b * block_size; i < (b + 1) * block_size; i += svcntd()) {\n            svbool_t load_pg = svwhilelt_b64(i, (b + 1) * block_size);\n            svfloat64_t current = svld1_f64(load_pg, &vec[i]);\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, current, first_block[idx++]));\n            svbool_t cmp = svcmple_f64(pg, diff, tol_vec);\n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    svfloat64_t tol = svdup_f64(tolerance);\n    svbool_t pg = svptrue_b64();\n\n    // Load the first block as reference\n    svfloat64_t first_block[block_size];\n    for (size_t i = 0; i < block_size; i++) {\n        first_block[i] = svdup_f64(vec[i]);\n    }\n\n    // Process complete blocks\n    for (size_t i = block_size; i + block_size <= length; i += block_size) {\n        for (size_t j = 0; j < block_size; j++) {\n            svfloat64_t current = svld1_f64(pg, &vec[i + j]);\n            svfloat64_t diff = svsub_f64_x(pg, current, first_block[j]);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t cmp = svcmple_f64(pg, abs_diff, tol);\n            if (!svptest_all_true(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t vec_len = svcntd();\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < block_size; i += vec_len) {\n        svfloat64_t first_block = svld1_f64(pg, vec + i);\n        size_t j = i + block_size;\n\n        while (j + vec_len <= length) {\n            svfloat64_t curr_block = svld1_f64(pg, vec + j);\n            svfloat64_t diff = svsub_f64_x(pg, first_block, curr_block);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t cmp = svcmple_f64(pg, abs_diff, svdup_f64(tolerance));\n\n            if (!svptest_all(cmp)) {\n                return false;\n            }\n            j += block_size;\n        }\n\n        // Handle remaining elements in the block\n        if (j < length) {\n            svbool_t active = svwhilelt_b64(j, length);\n            svfloat64_t curr_block = svld1_f64(active, vec + j);\n            svfloat64_t diff = svsub_f64_x(active, first_block, curr_block);\n            svfloat64_t abs_diff = svabs_f64_x(active, diff);\n            svbool_t cmp = svcmple_f64(active, abs_diff, svdup_f64(tolerance));\n\n            if (!svptest_all(cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (vec == nullptr || tolerance < 0 || length == 0 || block_size == 0) {\n        return false;\n    }\n\n    // Check if there are enough elements to form at least one complete block\n    if (length < block_size) {\n        return false;\n    }\n\n    // Number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    // Get the vector length for SVE (number of 64-bit elements per vector)\n    uint64_t vl = svcntd();\n    svbool_t pg = svptrue_b64();\n\n    // Process block_size elements at a time using SVE vectors\n    for (size_t i = 0; i < block_size; i += vl) {\n        // Load the reference block (first block) for the current set of elements\n        svfloat64_t ref_vec = svld1(pg, &vec[i]);\n        svfloat64_t abs_tolerance = svdup_f64(tolerance);\n\n        // Compare with corresponding elements in other blocks\n        for (size_t b = 1; b < num_blocks; ++b) {\n            svfloat64_t curr_vec = svld1(pg, &vec[b * block_size + i]);\n            // Compute absolute difference\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, curr_vec, ref_vec));\n            // Check if difference exceeds tolerance\n            svbool_t cmp = svcmplt_f64(pg, diff, abs_tolerance);\n            // If any element exceeds tolerance, return false\n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        svbool_t pg = svwhilelt_b64(0, cols);\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t p = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(p, &matrix[i * cols + j]);\n            sum = svmla_f64_x(pg, sum, vec, vec);\n        }\n        \n        double row_norm = sqrt(svaddv_f64(pg, sum));\n        result[i] = row_norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_squares = 0.0;\n        size_t j = 0;\n        const double* row_start = matrix + i * cols;\n        \n        // Process elements in vectorized chunks\n        for (; j <= cols - svcntd(); j += svcntd()) {\n            svfloat64_t vec = svld1(pg, row_start + j);\n            svfloat64_t sq_vec = svmul_f64_z(pg, vec, vec);\n            sum_squares += svadda_f64(pg, 0.0, sq_vec);\n        }\n        \n        // Handle remaining elements\n        if (j < cols) {\n            svbool_t rem_pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(rem_pg, row_start + j);\n            svfloat64_t sq_vec = svmul_f64_z(rem_pg, vec, vec);\n            sum_squares += svadda_f64(rem_pg, 0.0, sq_vec);\n        }\n        \n        // Compute norm and compare with threshold\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        double sum_sq = 0.0;\n        size_t j = 0;\n        const double* row_start = matrix + i * cols;\n\n        // Process elements in chunks using SVE\n        for (; j + vec_len <= cols; j += vec_len) {\n            svfloat64_t vec = svld1_f64(pg, row_start + j);\n            svfloat64_t sq_vec = svmul_f64_z(pg, vec, vec);\n            sum_sq += svadda_f64(pg, 0.0, sq_vec);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = row_start[j];\n            sum_sq += val * val;\n        }\n\n        // Compute Euclidean norm and compare with threshold\n        double norm = sqrt(sum_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_squares = 0.0;\n        size_t j = 0;\n        const double* row_start = matrix + i * cols;\n        \n        // Process elements in vectorized chunks\n        for (; j + svcntd() <= cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, row_start + j);\n            svfloat64_t sq = svmul_f64_z(pg, vec, vec);\n            sum_squares += svadda_f64(pg, 0.0, sq);\n        }\n        \n        // Handle remaining elements\n        if (j < cols) {\n            svbool_t rem_pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(rem_pg, row_start + j);\n            svfloat64_t sq = svmul_f64_z(rem_pg, vec, vec);\n            sum_squares += svadda_f64(rem_pg, 0.0, sq);\n        }\n        \n        // Compute Euclidean norm and compare with threshold\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_squares = 0.0;\n        size_t j = 0;\n        const double* row_start = matrix + i * cols;\n        \n        // Process elements in vectorized chunks\n        for (; j <= cols - svcntd(); j += svcntd()) {\n            svfloat64_t vec = svld1(pg, row_start + j);\n            svfloat64_t squares = svmul_f64_z(pg, vec, vec);\n            sum_squares += svadda_f64(pg, 0.0, squares);\n        }\n        \n        // Handle remaining elements\n        if (j < cols) {\n            svbool_t remaining_pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(remaining_pg, row_start + j);\n            svfloat64_t squares = svmul_f64_z(remaining_pg, vec, vec);\n            sum_squares += svadda_f64(remaining_pg, 0.0, squares);\n        }\n        \n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        svuint32_t vc = svorr_u32_m(pg, va, vb);\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg_rem, &A[i]);\n        svuint32_t vb = svld1_u32(pg_rem, &B[i]);\n        svuint32_t vc = svorr_u32_x(pg_rem, va, vb);\n        svst1_u32(pg_rem, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        svuint32_t vc = svorr_u32_z(pg, va, vb);\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        svint16_t vecA_16 = svsxtb_n_s16(vecA);\n        svint16_t vecB_16 = svsxtb_n_s16(vecB);\n\n        svint16_t sqA = svmul_s16(vecA_16, vecA_16);\n        svint16_t sqB = svmul_s16(vecB_16, vecB_16);\n        svint16_t prod = svmul_s16(vecA_16, vecB_16);\n\n        sum_sq += svaddv_s16(pg, sqA);\n        sum_sq += svaddv_s16(pg, sqB);\n        sum_prod += svaddv_s16(pg, prod);\n\n        i += svcntb();\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        svint16_t vecA_16 = svsxtb_n_s16(vecA);\n        svint16_t vecB_16 = svsxtb_n_s16(vecB);\n\n        svint16_t sqA = svmul_s16(vecA_16, vecA_16);\n        svint16_t sqB = svmul_s16(vecB_16, vecB_16);\n        svint16_t prod = svmul_s16(vecA_16, vecB_16);\n\n        sum_sq += svadda_s16(pg, 0, sqA);\n        sum_sq += svadda_s16(pg, 0, sqB);\n        sum_prod += svadda_s16(pg, 0, prod);\n\n        i += svcntb();\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svint16_t va_16 = svsxtb_n_s16(va);\n        svint16_t vb_16 = svsxtb_n_s16(vb);\n\n        svint16_t sq_a = svmul_n_s16(va_16, va_16);\n        svint16_t sq_b = svmul_n_s16(vb_16, vb_16);\n        svint16_t prod = svmul_n_s16(va_16, vb_16);\n\n        sum_sq += svadda_s16(pg, 0, sq_a);\n        sum_sq += svadda_s16(pg, 0, sq_b);\n        sum_prod += svadda_s16(pg, 0, prod);\n\n        i += svcntb();\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    while (svcntb() <= length) {\n        svint8_t vec_a = svld1_s8(pg, A);\n        svint8_t vec_b = svld1_s8(pg, B);\n        \n        svint16_t vec_a_s16 = svmul_s8(vec_a, vec_a);\n        svint16_t vec_b_s16 = svmul_s8(vec_b, vec_b);\n        svint16_t vec_ab_s16 = svmul_s8(vec_a, vec_b);\n        \n        sum_squares += svaddv_s16(pg, vec_a_s16);\n        sum_squares += svaddv_s16(pg, vec_b_s16);\n        sum_products += svaddv_s16(pg, vec_ab_s16);\n        \n        A += svcntb();\n        B += svcntb();\n        length -= svcntb();\n        pg = svwhilelt_b8(0, length);\n    }\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    for (size_t i = 0; i < length; ) {\n        svint8_t vec_a = svld1_s8(pg, &A[i]);\n        svint8_t vec_b = svld1_s8(pg, &B[i]);\n        \n        svint16_t vec_a_16 = svmul_s8(vec_a, vec_a);\n        svint16_t vec_b_16 = svmul_s8(vec_b, vec_b);\n        svint16_t vec_prod = svmul_s8(vec_a, vec_b);\n        \n        sum_squares += svaddv_s16(pg, vec_a_16);\n        sum_squares += svaddv_s16(pg, vec_b_16);\n        sum_products += svaddv_s16(pg, vec_prod);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svuint64_t a = svld1_u64(pg, &A[i]);\n        svuint64_t b = svld1_u64(pg, &B[i]);\n        svuint64_t result = svand_u64_z(pg, a, svnot_u64_z(pg, b));\n        svst1_u64(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    do {\n        svuint64_t vec_a = svld1_u64(pg, &A[i]);\n        svuint64_t vec_b = svld1_u64(pg, &B[i]);\n        svuint64_t vec_b_not = svnot_u64_z(pg, vec_b);\n        svuint64_t vec_c = svand_u64_z(pg, vec_a, vec_b_not);\n        svst1_u64(pg, &C[i], vec_c);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint64_t vec_a = svld1_u64(pg, &A[i]);\n        svuint64_t vec_b = svld1_u64(pg, &B[i]);\n        svuint64_t vec_b_not = svnot_u64_z(pg, vec_b);\n        svuint64_t vec_result = svand_u64_z(pg, vec_a, vec_b_not);\n        svst1_u64(pg, &C[i], vec_result);\n    }\n    \n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint64_t vec_a = svld1_u64(pg_rem, &A[i]);\n        svuint64_t vec_b = svld1_u64(pg_rem, &B[i]);\n        svuint64_t vec_b_not = svnot_u64_z(pg_rem, vec_b);\n        svuint64_t vec_result = svand_u64_z(pg_rem, vec_a, vec_b_not);\n        svst1_u64(pg_rem, &C[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svuint64_t vec_a = svld1_u64(pg, &A[i]);\n        svuint64_t vec_b = svld1_u64(pg, &B[i]);\n        svuint64_t vec_b_not = svnot_u64_z(pg, vec_b);\n        svuint64_t vec_c = svand_u64_z(pg, vec_a, vec_b_not);\n        svst1_u64(pg, &C[i], vec_c);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vb_not = svnot_u64_z(pg, vb);\n        svuint64_t result = svand_u64_z(pg, va, vb_not);\n        svst1_u64(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n\n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n\n        // Check if both A and B are positive (> 0)\n        svbool_t pos_a = svcmpgt_n_s8(pg, a_vec, 0);\n        svbool_t pos_b = svcmpgt_n_s8(pg, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg, pos_a, pos_b);\n\n        // Check if both A and B are negative (< 0)\n        svbool_t neg_a = svcmplt_n_s8(pg, a_vec, 0);\n        svbool_t neg_b = svcmplt_n_s8(pg, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg, neg_a, neg_b);\n\n        // Initialize result vector to 0\n        svint8_t result = svdup_n_s8(0);\n\n        // Set result to 1 where both are positive\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n\n        // Set result to -1 where both are negative\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n\n        // Store the result\n        svst1_s8(pg, &C[i], result);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg_rem, &A[i]);\n        svint8_t b_vec = svld1_s8(pg_rem, &B[i]);\n\n        svbool_t pos_a = svcmpgt_n_s8(pg_rem, a_vec, 0);\n        svbool_t pos_b = svcmpgt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg_rem, pos_a, pos_b);\n\n        svbool_t neg_a = svcmplt_n_s8(pg_rem, a_vec, 0);\n        svbool_t neg_b = svcmplt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg_rem, neg_a, neg_b);\n\n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n\n        svst1_s8(pg_rem, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    \n    while (i < length) {\n        svint8_t a = svld1_s8(pg, A + i);\n        svint8_t b = svld1_s8(pg, B + i);\n        \n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n        \n        svint8_t result = svsel_s8(pos_mask, svdup_s8(1), svdup_s8(0));\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pg, C + i, result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    \n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n        \n        // Check if both A and B are positive (> 0)\n        svbool_t a_pos = svcmpgt_n_s8(pg, a_vec, 0);\n        svbool_t b_pos = svcmpgt_n_s8(pg, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n        \n        // Check if both A and B are negative (< 0)\n        svbool_t a_neg = svcmplt_n_s8(pg, a_vec, 0);\n        svbool_t b_neg = svcmplt_n_s8(pg, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n        \n        // Initialize result vector to 0\n        svint8_t result = svdup_n_s8(0);\n        \n        // Set result to 1 where both are positive\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n        \n        // Set result to -1 where both are negative\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n        \n        // Store the result\n        svst1_s8(pg, &C[i], result);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg_rem, &A[i]);\n        svint8_t b_vec = svld1_s8(pg_rem, &B[i]);\n        \n        svbool_t a_pos = svcmpgt_n_s8(pg_rem, a_vec, 0);\n        svbool_t b_pos = svcmpgt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg_rem, a_pos, b_pos);\n        \n        svbool_t a_neg = svcmplt_n_s8(pg_rem, a_vec, 0);\n        svbool_t b_neg = svcmplt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg_rem, a_neg, b_neg);\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg_rem, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n\n        // Check if both A and B are positive (> 0)\n        svbool_t a_pos = svcmpgt_s8(pg, a_vec, svdup_s8(0));\n        svbool_t b_pos = svcmpgt_s8(pg, b_vec, svdup_s8(0));\n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n\n        // Check if both A and B are negative (< 0)\n        svbool_t a_neg = svcmplt_s8(pg, a_vec, svdup_s8(0));\n        svbool_t b_neg = svcmplt_s8(pg, b_vec, svdup_s8(0));\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n\n        // Set output: 1 for both positive, -1 for both negative, 0 otherwise\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_pos, svdup_s8(1), result);\n        result = svsel_s8(both_neg, svdup_s8(-1), result);\n\n        // Store the result\n        svst1_s8(pg, &C[i], result);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg_rem, &A[i]);\n        svint8_t b_vec = svld1_s8(pg_rem, &B[i]);\n\n        svbool_t a_pos = svcmpgt_s8(pg_rem, a_vec, svdup_s8(0));\n        svbool_t b_pos = svcmpgt_s8(pg_rem, b_vec, svdup_s8(0));\n        svbool_t both_pos = svand_b_z(pg_rem, a_pos, b_pos);\n\n        svbool_t a_neg = svcmplt_s8(pg_rem, a_vec, svdup_s8(0));\n        svbool_t b_neg = svcmplt_s8(pg_rem, b_vec, svdup_s8(0));\n        svbool_t both_neg = svand_b_z(pg_rem, a_neg, b_neg);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_pos, svdup_s8(1), result);\n        result = svsel_s8(both_neg, svdup_s8(-1), result);\n\n        svst1_s8(pg_rem, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    \n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n        \n        // Check if both A and B are positive (> 0)\n        svbool_t pos_a = svcmpgt_n_s8(pg, a_vec, 0);\n        svbool_t pos_b = svcmpgt_n_s8(pg, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg, pos_a, pos_b);\n        \n        // Check if both A and B are negative (< 0)\n        svbool_t neg_a = svcmplt_n_s8(pg, a_vec, 0);\n        svbool_t neg_b = svcmplt_n_s8(pg, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg, neg_a, neg_b);\n        \n        // Initialize result vector to 0\n        svint8_t result = svdup_n_s8(0);\n        \n        // Set result to 1 where both are positive\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n        \n        // Set result to -1 where both are negative\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n        \n        // Store the result\n        svst1_s8(pg, &C[i], result);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg_rem, &A[i]);\n        svint8_t b_vec = svld1_s8(pg_rem, &B[i]);\n        \n        svbool_t pos_a = svcmpgt_n_s8(pg_rem, a_vec, 0);\n        svbool_t pos_b = svcmpgt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_pos = svand_b_z(pg_rem, pos_a, pos_b);\n        \n        svbool_t neg_a = svcmplt_n_s8(pg_rem, a_vec, 0);\n        svbool_t neg_b = svcmplt_n_s8(pg_rem, b_vec, 0);\n        svbool_t both_neg = svand_b_z(pg_rem, neg_a, neg_b);\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(both_pos, svdup_n_s8(1), result);\n        result = svsel_s8(both_neg, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg_rem, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(active, &A[i]);\n        svuint16_t vb = svld1_u16(active, &B[i]);\n\n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        svbool_t at_mid = svwhilelt_b16(i, mid + 1);\n        at_mid = svand_b_z(pg, at_mid, svwhilege_b16(i, mid));\n\n        svuint16_t result_before = svand_u16_m(before_mid, va, vb);\n        svuint16_t result_after = sveor_u16_m(after_mid, va, vb);\n        svuint16_t result_mid = svsel_u16(at_mid, va, result_before);\n        svuint16_t result = svsel_u16(after_mid, result_after, result_mid);\n\n        svst1_u16(active, &C[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t a_vec = svld1_u16(active, &A[i]);\n        svuint16_t b_vec = svld1_u16(active, &B[i]);\n        svuint16_t result_vec;\n\n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        svbool_t at_mid = svwhilelt_b16(i, mid + 1);\n        at_mid = svand_b_z(pg, at_mid, svwhilege_b16(i, mid));\n\n        svuint16_t xor_vec = svorr_u16(a_vec, b_vec);\n        svuint16_t and_vec = svand_u16(a_vec, b_vec);\n\n        result_vec = svsel_u16(before_mid, xor_vec, a_vec);\n        result_vec = svsel_u16(at_mid, a_vec, result_vec);\n        result_vec = svsel_u16(after_mid, and_vec, result_vec);\n\n        svst1_u16(active, &C[i], result_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(active, &A[i]);\n        svuint16_t vb = svld1_u16(active, &B[i]);\n\n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        svbool_t at_mid = svwhilelt_b16(i, mid + 1);\n        at_mid = svand_b_z(pg, at_mid, svnot_b_z(pg, after_mid));\n\n        svuint16_t result_before = svand_u16_z(before_mid, va, vb);\n        svuint16_t result_after = sveor_u16_z(after_mid, va, vb);\n        svuint16_t result_mid = svsel_u16(at_mid, va, svsel_u16(before_mid, result_before, result_after));\n\n        svst1_u16(active, &C[i], result_mid);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(active, &A[i]);\n        svuint16_t vb = svld1_u16(active, &B[i]);\n        svuint16_t result;\n\n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        svbool_t at_mid = svwhilelt_b16(i, mid + 1);\n\n        // XOR for elements before midpoint\n        svuint16_t xor_result = sveor_u16_m(before_mid, va, vb);\n        // AND for elements after midpoint\n        svuint16_t and_result = svand_u16_m(after_mid, va, vb);\n        // Keep A at midpoint\n        svuint16_t mid_result = svsel_u16(at_mid, va, svdup_u16(0));\n\n        // Combine results\n        result = svsel_u16(before_mid, xor_result, and_result);\n        result = svsel_u16(at_mid, mid_result, result);\n\n        svst1_u16(active, &C[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t active_pg = svwhilelt_b16(i, length);\n        svuint16_t a_vec = svld1_u16(active_pg, &A[i]);\n        svuint16_t b_vec = svld1_u16(active_pg, &B[i]);\n\n        svbool_t before_mid_pg = svwhilelt_b16(i, mid);\n        svbool_t after_mid_pg = svwhilege_b16(i, mid + 1);\n        svbool_t mid_pg = svwhilelt_b16(i, mid + 1);\n        mid_pg = svand_b_z(svptrue_b16(), mid_pg, svwhilege_b16(i, mid));\n\n        svuint16_t result_vec = a_vec;\n        svuint16_t xor_vec = sveor_u16_m(before_mid_pg, a_vec, b_vec);\n        svuint16_t and_vec = svand_u16_m(after_mid_pg, a_vec, b_vec);\n\n        result_vec = svsel_u16(before_mid_pg, xor_vec, result_vec);\n        result_vec = svsel_u16(after_mid_pg, and_vec, result_vec);\n        result_vec = svsel_u16(mid_pg, a_vec, result_vec);\n\n        svst1_u16(active_pg, &C[i], result_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_true_cond2_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t cond1_false_cond2_false = svand_b_z(pg, svnot_b_z(pg, cond1_vec), svnot_b_z(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_true_cond2_true, a_vec, d_vec);\n        result = svsel_f32(cond1_true_cond2_false, b_vec, result);\n        result = svsel_f32(cond1_false_cond2_true, c_vec, result);\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_u8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_u8(pg, &cond2[i]);\n\n        svbool_t cond1_true = svcmpne_u8(pg, cond1_vec, svdup_u8(0));\n        svbool_t cond2_true = svcmpne_u8(pg, cond2_vec, svdup_u8(0));\n\n        svbool_t both_true = svand_b_z(pg, cond1_true, cond2_true);\n        svbool_t cond1_only = svand_b_z(pg, cond1_true, svnot_b_z(pg, cond2_true));\n        svbool_t cond2_only = svand_b_z(pg, svnot_b_z(pg, cond1_true), cond2_true);\n        svbool_t both_false = svnot_b_z(pg, svor_b_z(pg, cond1_true, cond2_true));\n\n        svfloat32_t result = svsel_f32(both_true, a_vec, \n                            svsel_f32(cond1_only, b_vec, \n                            svsel_f32(cond2_only, c_vec, d_vec)));\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_true_cond2_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t cond1_false_cond2_false = svand_b_z(pg, svnot_b_z(pg, cond1_vec), svnot_b_z(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_true_cond2_true, a_vec, d_vec);\n        result = svsel_f32(cond1_true_cond2_false, b_vec, result);\n        result = svsel_f32(cond1_false_cond2_true, c_vec, result);\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_true_cond2_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t cond1_false_cond2_false = svand_b_z(pg, svnot_b_z(pg, cond1_vec), svnot_b_z(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_true_cond2_true, a_vec, d_vec);\n        result = svsel_f32(cond1_true_cond2_false, b_vec, result);\n        result = svsel_f32(cond1_false_cond2_true, c_vec, result);\n        result = svsel_f32(cond1_false_cond2_false, d_vec, result);\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_true_cond2_true = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_vec, svnot_b_z(pg, cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_vec), cond2_vec);\n        svbool_t cond1_false_cond2_false = svand_b_z(pg, svnot_b_z(pg, cond1_vec), svnot_b_z(pg, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_true_cond2_true, a_vec, d_vec);\n        result = svsel_f32(cond1_true_cond2_false, b_vec, result);\n        result = svsel_f32(cond1_false_cond2_true, c_vec, result);\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        \n        // Count bits using SVE intrinsics\n        svuint32_t count = svcnt_u32_z(pg, vec_a);\n        \n        // Extract lower 8 bits of count\n        svuint8_t result = svlsr_n_u8_z(pg, svreinterpret_u8_u32(count), 24);\n        \n        // Store result\n        svst1_u8(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        \n        // Count bits using a series of bitwise operations\n        svuint32_t vec = vec_a;\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 1), svand_u32_z(pg, vec, svdup_u32(0x55555555)));\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 2), svand_u32_z(pg, vec, svdup_u32(0x33333333)));\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 4), svand_u32_z(pg, vec, svdup_u32(0x0F0F0F0F)));\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 8), svand_u32_z(pg, vec, svdup_u32(0x00FF00FF)));\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 16), svand_u32_z(pg, vec, svdup_u32(0x0000FFFF)));\n        \n        // Convert to 8-bit result\n        svuint8_t result = svnarrow_u16_z(pg, svnarrow_u32_z(pg, vec));\n        svst1_u8(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < total_elements; i += vec_len) {\n        // Adjust predicate for the last iteration if necessary\n        if (i + vec_len > total_elements) {\n            pg = svwhilelt_b32(i, total_elements);\n        }\n\n        // Load a vector of uint32_t from A\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n\n        // Count the number of set bits in each 32-bit element\n        svuint32_t vec_count = svcntp_b32(pg, svbrkb_z(pg, vec_a, 0));\n\n        // Convert the 32-bit count to 8-bit for storage\n        svuint8_t vec_count_u8 = svqxtnb_u32(vec_count);\n\n        // Store the result in out\n        svst1_u8(pg, &out[i], vec_count_u8);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        \n        // Count bits using a series of bitwise operations\n        svuint32_t t = vec;\n        t = svadd_u32_z(pg, svand_u32_z(pg, t, svdup_u32(0x55555555)), \n                        svand_u32_z(pg, svlsr_u32_z(pg, t, 1), svdup_u32(0x55555555)));\n        t = svadd_u32_z(pg, svand_u32_z(pg, t, svdup_u32(0x33333333)), \n                        svand_u32_z(pg, svlsr_u32_z(pg, t, 2), svdup_u32(0x33333333)));\n        t = svadd_u32_z(pg, svand_u32_z(pg, t, svdup_u32(0x0F0F0F0F)), \n                        svand_u32_z(pg, svlsr_u32_z(pg, t, 4), svdup_u32(0x0F0F0F0F)));\n        t = svmul_u32_z(pg, svand_u32_z(pg, t, svdup_u32(0x01010101)), svdup_u32(0x01010101));\n        t = svlsr_u32_z(pg, t, 24);\n\n        // Convert to uint8_t and store\n        svuint8_t result = svnarrow_u32(pg, t);\n        svst1_u8(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        \n        // Count bits using a series of bitwise operations\n        svuint32_t vec = vec_a;\n        vec = svadd_u32_z(pg, svlsr_u32_z(pg, vec, 1), svand_u32_z(pg, vec, svdup_u32(0x55555555)));\n        vec = svadd_u32_z(pg, svand_u32_z(pg, vec, svdup_u32(0x33333333)), svand_u32_z(pg, svlsr_u32_z(pg, vec, 2), svdup_u32(0x33333333)));\n        vec = svadd_u32_z(pg, svand_u32_z(pg, vec, svdup_u32(0x0F0F0F0F)), svand_u32_z(pg, svlsr_u32_z(pg, vec, 4), svdup_u32(0x0F0F0F0F)));\n        vec = svmul_u32_z(pg, svand_u32_z(pg, vec, svdup_u32(0x01010101)), svdup_u32(0x01010101));\n        vec = svlsr_u32_z(pg, vec, 24);\n\n        // Convert to uint8_t and store\n        svuint8_t vec_out = svnarrow_u32_z(pg, vec);\n        svst1_u8(pg, &out[i], vec_out);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t len = rows * cols;\n    size_t i = 0;\n\n    for (; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        \n        svint32_t vec_a = svld1(pg, &A[i]);\n        \n        svint32_t mod3 = svmul_z(pg, vec_a, 0x55555555);\n        mod3 = svmul_z(pg, mod3, 3);\n        svbool_t div_by_3 = svcmpeq(pg, mod3, vec_a);\n        \n        svint32_t abs_a = svabs_z(pg, vec_a);\n        \n        svint32_t result = svsel(div_by_3, abs_a, vec_a);\n        \n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        svint32_t div_by_3 = svdiv_n_s32_z(pg, vec_a, 3);\n        svint32_t mul_back = svmul_n_s32_z(pg, div_by_3, 3);\n        svbool_t cond = svcmpeq_s32(pg, vec_a, mul_back);\n        \n        svint32_t abs_a = svabs_s32_z(pg, vec_a);\n        \n        svint32_t result = svsel_s32(cond, abs_a, vec_a);\n        \n        svst1_s32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    for (; i < total; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total);\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_zero = svdup_s32(0);\n        svint32_t vec_three = svdup_s32(3);\n        \n        // Compute A % 3\n        svint32_t vec_mod = svmod_s32_z(pg, vec_a, vec_three);\n        svbool_t cond = svcmpeq(pg, vec_mod, vec_zero);\n        \n        // Compute abs(A) for elements where condition is true\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n        \n        // Select abs(A) where condition is true, A otherwise\n        svint32_t vec_result = svsel_s32(cond, vec_abs, vec_a);\n        \n        svst1(pg, &B[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t i = 0;\n\n    for (; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_zero = svdup_n_s32(0);\n        svint32_t vec_three = svdup_n_s32(3);\n        \n        // Compute remainder: A % 3\n        svint32_t div_result = svdiv_z(pg, vec_a, vec_three);\n        svint32_t mul_result = svmul_z(pg, div_result, vec_three);\n        svint32_t remainder = svsub_z(pg, vec_a, mul_result);\n        \n        // Condition: remainder == 0 (divisible by 3)\n        svbool_t cond = svcmpeq(pg, remainder, vec_zero);\n        \n        // Compute absolute value for elements where condition is true\n        svint32_t abs_val = svabs_z(pg, vec_a);\n        \n        // Select abs_val where cond is true, otherwise keep original value\n        svint32_t result = svsel(cond, abs_val, vec_a);\n        \n        // Store result\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1(pg, &A[i]);\n\n        // Compute if elements are divisible by 3\n        svint32_t vec_three = svdup_n_s32(3);\n        svint32_t remainder = svmod_n_s32_z(pg, vec_a, vec_three);\n        svbool_t cond = svcmpeq_n_s32(pg, remainder, 0);\n\n        // Compute absolute value for elements where condition is true\n        svint32_t vec_abs = svabs_s32_m(vec_a, pg, vec_a);\n\n        // Select between abs value and original value based on condition\n        svint32_t result = svsel_s32(cond, vec_abs, vec_a);\n\n        // Store result to B\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load the source vector\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check condition: low 4 bits are all 1 (i.e., src & 0xF == 0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Compute rotation for elements where condition is true\n        svuint32_t rotated = svror_n_u32_z(pg, vec_src, rotate_bits);\n        \n        // Compute bitwise negation for elements where condition is false\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select result based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store the result to destination\n        svst1_u32(pg, &dst[i], result);\n        \n        // Update the predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load the source vector\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check condition: low 4 bits are all 1 (i.e., src & 0xF == 0xF)\n        svuint32_t mask = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, mask, 0xF);\n        \n        // Compute rotation: rotate right by rotate_bits\n        svuint32_t rotated = svror_n_u32_z(pg, vec_src, rotate_bits);\n        \n        // Compute bitwise negation\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select result based on condition: if cond true, use rotated; else use negated\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store the result to destination\n        svst1_u32(pg, &dst[i], result);\n        \n        // Update the predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        \n        svbool_t mask = svcmpeq_u32(pg, svand_u32_z(pg, vec, 0xF), 0xF);\n        \n        svuint32_t rotated = svror_n_u32_z(pg, vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, vec);\n        \n        svuint32_t result = svsel_u32(mask, rotated, negated);\n        \n        svst1_u32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t vec = svld1_u32(pg, &src[i]);\n        \n        svbool_t cond = svcmpeq_n_u32(pg, svand_n_u32_z(pg, vec, 0xF), 0xF);\n        \n        svuint32_t rotated = svror_n_u32_z(pg, vec, rotate_bits);\n        \n        svuint32_t negated = svnot_u32_z(pg, vec);\n        \n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svbool_t cond = svcmpeq_n_u32(pg, svand_n_u32_z(pg, vec, 0xF), 0xF);\n        \n        // Perform rotation for true condition\n        svuint32_t rotated = svror_n_u32_z(pg, vec, rotate_bits);\n        \n        // Perform bitwise negation for false condition\n        svuint32_t negated = svnot_u32_z(pg, vec);\n        \n        // Select based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store result\n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    float abs_epsilon = fabsf(epsilon);\n    svfloat32_t v_eps = svdup_f32(abs_epsilon);\n    svfloat32_t v_neg_eps = svdup_f32(-abs_epsilon);\n    svint8_t v_one = svdup_s8(1);\n    svint8_t v_neg_one = svdup_s8(-1);\n    svint8_t v_zero = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t v_a = svld1_f32(pg, A + i);\n        svfloat32_t v_b = svld1_f32(pg, B + i);\n        \n        svfloat32_t v_diff = svsub_f32_x(pg, v_a, v_b);\n        \n        svbool_t gt_eps = svcmpgt_f32(pg, v_diff, v_eps);\n        svbool_t lt_neg_eps = svcmplt_f32(pg, v_diff, v_neg_eps);\n        \n        svint8_t result = svsel_s8(gt_eps, v_one, v_zero);\n        result = svsel_s8(lt_neg_eps, v_neg_one, result);\n        \n        svst1_s8(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t diff_vec = svsub_f32_x(pg, a_vec, b_vec);\n        \n        svbool_t gt_epsilon = svcmpgt_f32(pg, diff_vec, epsilon_vec);\n        svbool_t lt_neg_epsilon = svcmplt_f32(pg, diff_vec, neg_epsilon_vec);\n        \n        svint8_t result_vec = svsel_s8(gt_epsilon, one_vec, zero_vec);\n        result_vec = svsel_s8(lt_neg_epsilon, neg_one_vec, result_vec);\n        \n        svst1_s8(pg, &out[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n    size_t i = 0;\n\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t diff_vec = svsub_f32_x(pg, a_vec, b_vec);\n\n        svbool_t gt_epsilon = svcmpgt_f32(pg, diff_vec, epsilon_vec);\n        svbool_t lt_neg_epsilon = svcmplt_f32(pg, diff_vec, neg_epsilon_vec);\n\n        svint8_t result_vec = svsel_s8(gt_epsilon, one_vec, zero_vec);\n        result_vec = svsel_s8(lt_neg_epsilon, neg_one_vec, result_vec);\n\n        svst1_s8(pg, &out[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_out_vec = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, a_vec, b_vec);\n        \n        svbool_t gt_epsilon = svcmpgt_f32(pg, diff, epsilon_vec);\n        svbool_t lt_neg_epsilon = svcmplt_f32(pg, diff, neg_epsilon_vec);\n        \n        svint8_t result = svsel_s8(gt_epsilon, one_vec, zero_out_vec);\n        result = svsel_s8(lt_neg_epsilon, neg_one_vec, result);\n        \n        svst1_s8(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(fabsf(epsilon));\n    svfloat32_t neg_epsilon_vec = svdup_f32(-fabsf(epsilon));\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        svfloat32_t diff = svsub_f32_x(pg, a_vec, b_vec);\n\n        svbool_t gt_mask = svcmpgt_f32(pg, diff, epsilon_vec);\n        svbool_t lt_mask = svcmplt_f32(pg, diff, neg_epsilon_vec);\n\n        svint8_t result = svsel_s8(gt_mask, one_vec, zero_vec);\n        result = svsel_s8(lt_mask, neg_one_vec, result);\n\n        svst1_s8(pg, out + i, result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; ) {\n        svfloat32_t vec_a = svld1_f32(pg, A + i);\n        \n        svint32_t vec_b = svcvt_s32_f32_m(svunpklo_s32(svundef_s64()), pg, vec_a);\n        \n        svint32_t max_mask = svcmpgt_s32(pg, vec_b, svdup_s32(INT32_MAX));\n        vec_b = svsel_s32(max_mask, svdup_s32(INT32_MAX), vec_b);\n        \n        svint32_t min_mask = svcmplt_s32(pg, vec_b, svdup_s32(INT32_MIN));\n        vec_b = svsel_s32(min_mask, svdup_s32(INT32_MIN), vec_b);\n        \n        svst1_s32(pg, B + i, vec_b);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        svfloat32_t vec_f = svld1_f32(pg, &A[i]);\n        svint32_t vec_i = svcvt_s32_f32_x(pg, vec_f);\n        \n        // Clamp to INT32_MAX and INT32_MIN\n        svint32_t max_val = svdup_s32(INT32_MAX);\n        svint32_t min_val = svdup_s32(INT32_MIN);\n        vec_i = svmin_s32_x(pg, vec_i, max_val);\n        vec_i = svmax_s32_x(pg, vec_i, min_val);\n        \n        svst1_s32(pg, &B[i], vec_i);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; ) {\n        svfloat32_t vec = svld1_f32(pg, A + i);\n        \n        svint32_t result = svcvt_s32_f32_m(svunpklo_s32(svundef_s32()), pg, vec);\n        \n        svint32_t max_int = svdup_s32(INT32_MAX);\n        svint32_t min_int = svdup_s32(INT32_MIN);\n        \n        result = svsel_s32(svcmpgt_s32(pg, result, max_int), max_int, result);\n        result = svsel_s32(svcmpgt_s32(pg, min_int, result), min_int, result);\n        \n        svst1_s32(pg, B + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const float max_val = (float)INT32_MAX;\n    const float min_val = (float)INT32_MIN;\n\n    for (; i + svcntw() <= size; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &A[i]);\n        svfloat32_t clamped_max = svmin_f32_z(pg, vec, max_val);\n        svfloat32_t clamped_min = svmax_f32_z(pg, clamped_max, min_val);\n        svint32_t result = svcvt_s32_f32_z(pg, clamped_min);\n        svst1_s32(pg, &B[i], result);\n    }\n\n    // Handle remaining elements\n    if (i < size) {\n        svbool_t pg_rem = svwhilelt_b32(i, size);\n        svfloat32_t vec = svld1_f32(pg_rem, &A[i]);\n        svfloat32_t clamped_max = svmin_f32_z(pg_rem, vec, max_val);\n        svfloat32_t clamped_min = svmax_f32_z(pg_rem, clamped_max, min_val);\n        svint32_t result = svcvt_s32_f32_z(pg_rem, clamped_min);\n        svst1_s32(pg_rem, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= size; i += svcntw()) {\n        svfloat32_t vec_f32 = svld1_f32(pg, &A[i]);\n        svint32_t vec_i32 = svcvt_s32_f32_x(pg, vec_f32);\n        svint32_t max_val = svdup_s32(INT32_MAX);\n        svint32_t min_val = svdup_s32(INT32_MIN);\n        svbool_t gt_max = svcmpgt_s32(pg, vec_i32, max_val);\n        svbool_t lt_min = svcmplt_s32(pg, vec_i32, min_val);\n        vec_i32 = svsel_s32(gt_max, max_val, vec_i32);\n        vec_i32 = svsel_s32(lt_min, min_val, vec_i32);\n        svst1_s32(pg, &B[i], vec_i32);\n    }\n    \n    // Handle remaining elements\n    if (i < size) {\n        svbool_t pg_rem = svwhilelt_b32(i, size);\n        svfloat32_t vec_f32 = svld1_f32(pg_rem, &A[i]);\n        svint32_t vec_i32 = svcvt_s32_f32_x(pg_rem, vec_f32);\n        svint32_t max_val = svdup_s32(INT32_MAX);\n        svint32_t min_val = svdup_s32(INT32_MIN);\n        svbool_t gt_max = svcmpgt_s32(pg_rem, vec_i32, max_val);\n        svbool_t lt_min = svcmplt_s32(pg_rem, vec_i32, min_val);\n        vec_i32 = svsel_s32(gt_max, max_val, vec_i32);\n        vec_i32 = svsel_s32(lt_min, min_val, vec_i32);\n        svst1_s32(pg_rem, &B[i], vec_i32);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    float scale_f = (float)scale;\n\n    for (; i < size; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, size);\n        svint32_t vec_int = svld1_s32(p, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_s32_z(p, vec_int);\n        svfloat32_t scaled_vec = svmul_n_f32_z(p, vec_float, scale_f);\n        svst1_f32(p, &B[i], scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    float scale_f = (float)scale;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svfloat32_t vec_a_float = svcvt_f32_s32_z(pg, vec_a);\n        svfloat32_t vec_scaled = svmul_f32_m(pg, vec_a_float, svdup_f32(scale_f));\n        \n        svst1_f32(pg, &B[i], vec_scaled);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n    size_t i = 0;\n\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t a_float = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t result = svmul_f32_z(pg, a_float, scale_vec);\n        svst1_f32(pg, B + i, result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    float scale_f = (float)scale;\n\n    for (; i < size; i += svcntw()) {\n        svbool_t mask = svwhilelt_b32_u64(i, size);\n        svint32_t vec_int = svld1_s32(mask, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_s32_z(mask, vec_int);\n        svfloat32_t scaled_vec = svmul_n_f32_z(mask, vec_float, scale_f);\n        svst1_f32(mask, &B[i], scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n    size_t i = 0;\n\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t a_float = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t result = svmul_f32_z(pg, a_float, scale_vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i < size) {\n        // Determine how many elements to process in this iteration\n        svbool_t active = svwhilelt_b32(i, size);\n        pg = svand_b_z(svptrue_b32(), active, active);\n\n        // Load vectors from A and B\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n\n        // Round to nearest integer\n        svint32_t vresult = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vdiv));\n\n        // Store the result in C\n        svst1_s32(pg, &C[i], vresult);\n\n        // Increment the index by the number of elements processed\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vresult = svcvt_s32_f32_z(pg, vdiv);\n        \n        svst1_s32(pg, &C[i], vresult);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vrounded = svrinta_z(pg, vdiv);\n        \n        svst1_s32(pg, C + i, vrounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    while (i < size) {\n        // Determine the number of elements to process in this iteration\n        svbool_t active = svwhilelt_b32(i, size);\n        pg = svand_b_z(svptrue_b32(), active, active);\n        \n        // Load vectors from A and B\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        \n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        \n        // Round to nearest integer\n        svfloat32_t vround = svrintn_f32_z(pg, vdiv);\n        \n        // Convert to int32_t\n        svint32_t vresult = svcvt_s32_f32_z(pg, vround);\n        \n        // Store the result in C\n        svst1_s32(pg, &C[i], vresult);\n        \n        // Increment the index by the number of elements processed\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t div = svdiv_f32_z(pg, va, vb);\n        svint32_t rounded = svrinta_z(pg, div);\n        svst1_s32(pg, C + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        \n        svfloat64_t vec = svld1_f64(pg, A + i);\n        \n        svfloat64_t max = svdup_f64(FLT_MAX);\n        svfloat64_t min = svdup_f64(-FLT_MAX);\n        \n        vec = svmin_f64_m(pg, vec, max);\n        vec = svmax_f64_m(pg, vec, min);\n        \n        svfloat32_t vec_f32 = svcvt_f32_f64_m(svptrue_b32(), pg, vec);\n        \n        svst1_f32(pg, B + i, vec_f32);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    const float FLT_MAX_f = FLT_MAX;\n    const float FLT_MIN_f = -FLT_MAX;\n\n    for (; i < size; i += svcntd()) {\n        // Load double values from A\n        svfloat64_t vec_double = svld1_f64(pg, &A[i]);\n\n        // Convert double to float\n        svfloat32_t vec_float = svcvt_f32_f64_x(pg, vec_double);\n\n        // Create vectors for FLT_MAX and -FLT_MAX\n        svfloat32_t vec_max = svdup_f32(FLT_MAX_f);\n        svfloat32_t vec_min = svdup_f32(FLT_MIN_f);\n\n        // Saturate values: if greater than FLT_MAX, set to FLT_MAX\n        svfloat32_t vec_clamped_max = svmin_f32_x(pg, vec_float, vec_max);\n        // if less than -FLT_MAX, set to -FLT_MAX\n        svfloat32_t vec_clamped = svmax_f32_x(pg, vec_clamped_max, vec_min);\n\n        // Store the result in B\n        svst1_f32(pg, &B[i], vec_clamped);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n\n    for (; i < size; i += svcntd()) {\n        // Load double values from A\n        svfloat64_t vec_double = svld1_f64(pg, &A[i]);\n\n        // Convert double to float\n        svfloat32_t vec_float = svcvt_f32_f64_x(pg, vec_double);\n\n        // Define FLT_MAX and -FLT_MAX as constants for float32\n        svfloat32_t flt_max_vec = svdup_f32(FLT_MAX);\n        svfloat32_t flt_min_vec = svdup_f32(-FLT_MAX);\n\n        // Saturate values > FLT_MAX to FLT_MAX\n        vec_float = svmin_f32_x(pg, vec_float, flt_max_vec);\n\n        // Saturate values < -FLT_MAX to -FLT_MAX\n        vec_float = svmax_f32_x(pg, vec_float, flt_min_vec);\n\n        // Store the result in B\n        svst1_f32(pg, &B[i], vec_float);\n    }\n\n    // Handle remaining elements if size is not a multiple of vector length\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        \n        svfloat64_t vec = svld1_f64(pg, A + i);\n        \n        svfloat32_t result = svcvt_f32_f64_x(pg, vec);\n        \n        svbool_t gt_max = svcmpgt_f64(pg, vec, (double)FLT_MAX);\n        svbool_t lt_min = svcmplt_f64(pg, vec, (double)-FLT_MAX);\n        \n        result = svsel_f32(gt_max, svdup_f32(FLT_MAX), result);\n        result = svsel_f32(lt_min, svdup_f32(-FLT_MAX), result);\n        \n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i < size; i += svcntd()) {\n        // Load double values from A\n        svfloat64_t vec_double = svld1_f64(pg, &A[i]);\n        \n        // Define FLT_MAX and -FLT_MAX as double constants\n        svfloat64_t vec_flt_max = svdup_f64(FLT_MAX);\n        svfloat64_t vec_flt_min = svdup_f64(-FLT_MAX);\n        \n        // Clamp values to FLT_MAX and -FLT_MAX\n        svfloat64_t clamped_max = svmin_f64_z(pg, vec_double, vec_flt_max);\n        svfloat64_t clamped_min = svmax_f64_z(pg, clamped_max, vec_flt_min);\n        \n        // Convert double to float\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, clamped_min);\n        \n        // Store float values to B\n        svst1_f32(pg, &B[i], vec_float);\n    }\n    \n    // Handle remaining elements if size is not a multiple of vector length\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec_a = svld1_s16(pg, A + i);\n        svint32_t vec_b = svsxt_s32_z(pg, vec_a);\n        svst1_s32(pg, B + i, vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    \n    do {\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svsxtb_n_s32(vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec_a = svld1_s16(pg, A + i);\n        svint32_t vec_b = svextend_s32(pg, vec_a);\n        svst1_s32(pg, B + i, vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    \n    do {\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svsxtb_n_s32(vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec = svld1_s16(pg, A + i);\n        svint32_t result = svsxt_s32_z(pg, vec);\n        svst1_s32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_vec, min_vec);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    do {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n\n        // Create predicate for control > 0\n        svbool_t ctrl_pred = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n\n        // Perform normalization: (A - min) / (max - min)\n        svfloat32_t norm_vec = svsub_f32_x(pg, a_vec, min_vec);\n        norm_vec = svdiv_f32_x(pg, norm_vec, range_vec);\n\n        // Clamp values to [0, 1]\n        norm_vec = svmax_f32_x(pg, norm_vec, zero_vec);\n        norm_vec = svmin_f32_x(pg, norm_vec, one_vec);\n\n        // Select normalized value if control > 0, otherwise original value\n        svfloat32_t result_vec = svsel_f32(ctrl_pred, norm_vec, a_vec);\n\n        // Store result\n        svst1_f32(pg, &B[i], result_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n        \n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n        \n        svfloat32_t normalized = svsub_f32_z(pg, a_vec, min_vec);\n        normalized = svdiv_f32_z(pg, normalized, range_vec);\n        normalized = svmax_f32_z(pg, normalized, zero_vec);\n        normalized = svmin_f32_z(pg, normalized, one_vec);\n        \n        svfloat32_t result = svsel_f32(mask, normalized, a_vec);\n        \n        svst1_f32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svint32_t ctrl_vec = svld1_s32(pg, control + i);\n        \n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, 0);\n        \n        svfloat32_t norm_vec = svsub_f32_x(pg, a_vec, min_vec);\n        norm_vec = svdiv_f32_x(pg, norm_vec, range_vec);\n        norm_vec = svmax_f32_x(pg, norm_vec, zero_vec);\n        norm_vec = svmin_f32_x(pg, norm_vec, one_vec);\n        \n        svfloat32_t result_vec = svsel_f32(mask, norm_vec, a_vec);\n        \n        svst1_f32(pg, B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svdup_f32(max_val - min_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    do {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n\n        svfloat32_t normalized = svsub_f32_x(pg, a_vec, min_vec);\n        normalized = svdiv_f32_x(pg, normalized, range_vec);\n        normalized = svmax_f32_x(pg, normalized, zero_vec);\n        normalized = svmin_f32_x(pg, normalized, one_vec);\n\n        svfloat32_t result = svsel_f32(mask, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t range_vec = svdup_f32(max_val - min_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    do {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n\n        svfloat32_t normalized = svsub_f32_x(pg, a_vec, min_vec);\n        normalized = svdiv_f32_x(pg, normalized, range_vec);\n        normalized = svmax_f32_x(pg, normalized, zero_vec);\n        normalized = svmin_f32_x(pg, normalized, one_vec);\n\n        svfloat32_t result = svsel_f32(mask, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        // Load uint32_t values from A\n        svuint32_t vec_u32 = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by shifting right by 16\n        svuint32_t high16 = svlsr_n_u32_x(pg, vec_u32, 16);\n        \n        // Convert high 16 bits to float\n        svfloat32_t vec_f32 = svcvt_f32_u32_x(pg, high16);\n        \n        // Compute square root of float values\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, vec_f32);\n        \n        // Store result in B\n        svst1_f32(pg, &B[i], sqrt_vec);\n        \n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        // Load uint32_t values from A\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by shifting right by 16\n        svuint32_t high_bits = svlsr_n_u32_x(pg, vec_a, 16);\n        \n        // Convert high 16 bits to float\n        svfloat32_t vec_float = svcvt_f32_u32_x(pg, high_bits);\n        \n        // Compute square root of the float values\n        svfloat32_t vec_sqrt = svsqrt_f32_x(pg, vec_float);\n        \n        // Store the result in B\n        svst1_f32(pg, &B[i], vec_sqrt);\n        \n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        // Load uint32_t values from A\n        svuint32_t vec_u32 = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by shifting right by 16\n        svuint32_t high16 = svlsr_n_u32_x(pg, vec_u32, 16);\n        \n        // Convert high 16 bits to float\n        svfloat32_t vec_f32 = svcvt_f32_u32_x(pg, high16);\n        \n        // Compute square root of the float values\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, vec_f32);\n        \n        // Store the result in B\n        svst1_f32(pg, &B[i], sqrt_vec);\n        \n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        // Load uint32_t values from A\n        svuint32_t vec_u32 = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by shifting right by 16\n        svuint32_t high16 = svlsr_n_u32_x(pg, vec_u32, 16);\n        \n        // Convert high 16 bits to float\n        svfloat32_t vec_f32 = svcvt_f32_u32_x(pg, high16);\n        \n        // Compute square root of the float values\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, vec_f32);\n        \n        // Store the result in B\n        svst1_f32(pg, &B[i], sqrt_vec);\n        \n        // Update index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svuint32_t vec_a_high = svlsr_n_u32_x(pg, vec_a, 16);\n        svfloat32_t vec_f = svcvt_f32_u32_x(pg, vec_a_high);\n        svfloat32_t vec_sqrt = svsqrt_f32_x(pg, vec_f);\n        svst1_f32(pg, &B[i], vec_sqrt);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, &B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, &B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i < size; i += svcntw()) {\n        // Load uint32_t values from A as a vector\n        svuint32_t vec_uint = svld1_u32(pg, &A[i]);\n        \n        // Reinterpret the uint32_t vector as float vector (bitcast)\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_uint);\n        \n        // Store the float vector to B\n        svst1_f32(pg, &B[i], vec_float);\n    }\n    \n    // Handle any remaining elements\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    do {\n        svuint32_t vec_uint = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_uint);\n        svst1_f32(pg, &B[i], vec_float);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, A + i);\n        svfloat32_t result = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    diff[0] = 0.0f;\n\n    for (size_t i = 0; i < size; svadv_x(pg, &i, svcntw())) {\n        svbool_t p = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1_s32(p, A + i);\n        svint32_t a_prev = svld1_s32(p, A + i - 1);\n        svbool_t c = svld1_u8(p, cond + i);\n        \n        svint32_t diff_int = svsub_s32_x(p, a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_x(p, diff_int);\n        \n        svfloat32_t result = svsel_f32(c, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(p, diff + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    // Set the first element to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n        i = 1;\n    }\n\n    // Process the arrays using SVE intrinsics\n    for (; i < size; i += svcntw()) {\n        // Create a predicate for the current vector length\n        svbool_t pgt = svwhilelt_b32(i, size);\n\n        // Load the condition array\n        svbool_t cond_vec = svld1_u8(pgt, (const uint8_t*)&cond[i]);\n\n        // Load current and previous elements of A\n        svint32_t a_curr = svld1_s32(pgt, &A[i]);\n        svint32_t a_prev = svld1_s32(pgt, &A[i - 1]);\n\n        // Compute difference\n        svint32_t diff_int = svsub_s32_x(pgt, a_curr, a_prev);\n\n        // Convert difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pgt, diff_int);\n\n        // Create a vector of 0.0f for false conditions\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n\n        // Select between computed difference and 0.0f based on condition\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, zero_vec);\n\n        // Store the result in diff array\n        svst1_f32(pgt, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    size_t i = 1;\n    \n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t vec_a_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t vec_cond = svld1_b8(pg, &cond[i]);\n        \n        svint32_t vec_diff = svsub_s32_z(pg, vec_a, vec_a_prev);\n        svfloat32_t vec_diff_float = svcvt_f32_s32_z(pg, vec_diff);\n        \n        svfloat32_t result = svsel_f32(vec_cond, vec_diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    svbool_t pg = svwhilelt_b32(1, size);\n    for (size_t i = 1; i < size; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, size);\n        \n        svint32_t a_curr = svld1_s32(p, &A[i]);\n        svint32_t a_prev = svld1_s32(p, &A[i-1]);\n        svbool_t c = svld1_u8(p, &cond[i]);\n        \n        svint32_t diff_int = svsub_s32_z(p, a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_z(p, diff_int);\n        \n        svfloat32_t result = svsel_f32(c, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(p, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    svbool_t pg = svwhilelt_b32(1, size);\n    for (size_t i = 1; i < size; ) {\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t vec_a_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t vec_cond = svld1_b8(pg, &cond[i]);\n        \n        svint32_t vec_diff = svsub_s32_z(pg, vec_a, vec_a_prev);\n        svfloat32_t vec_diff_f = svcvt_f32_s32_z(pg, vec_diff);\n        \n        svfloat32_t vec_result = svsel_f32(vec_cond, vec_diff_f, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    do {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_dst = svcvt_u64_u32_z(pg, vec_src);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        vec_dst = svorr_u64_z(pg, vec_dst, high_bits);\n        svst1_u64(pg, &dst[i], vec_dst);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    do {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svwid1_u64_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint64_t widened = svcvt_u64_u32_z(pg, vec);\n        svuint64_t ones = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, widened, ones);\n        svst1_u64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svuint32_t vec_src = svld1_u32(pg, src + i);\n        svuint64_t vec_dst = svcvt_u64_z(pg, vec_src);\n        svuint64_t ones = svdup_u64(0xFFFFFFFF00000000ULL);\n        vec_dst = svorr_u64_z(pg, vec_dst, ones);\n        \n        svst1_u64(pg, dst + i, vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint32_t vec32 = svld1_u32(pg_rem, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg_rem, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg_rem, vec64, high_bits);\n        svst1_u64(pg_rem, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    size_t i = 0;\n    while (i < length) {\n        // Load indices for the current vector\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        \n        // Create a predicate for valid indices (0 <= index < length)\n        svbool_t valid_idx = svand_b_z(pg, svcmpge_n_s16(pg, idx_vec, 0), svcmplt_n_s16(pg, idx_vec, length));\n        \n        // Gather elements from vec using the indices\n        svfloat64_t data_vec = svld1_gather_s16index_f64(valid_idx, vec, idx_vec);\n        \n        // Accumulate the sum for valid indices\n        sum_vec = svadd_f64_m(valid_idx, sum_vec, data_vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n    \n    // Reduce the vector to a single scalar value\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid_idx = svcmpult(pg, idx_vec, svdup_u16(length));\n        svfloat64_t data = svld1_gather_u16index_f64(valid_idx, vec, idx_vec);\n        sum_vec = svadd_m(pg, sum_vec, data);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid = svcmplt_n_u16(pg, idx_vec, length);\n        svfloat64_t values = svld1_gather_u16index_f64(valid, vec, idx_vec);\n        sum_vec = svadd_f64_z(valid, sum_vec, values);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid = svcmplt_n_u16(pg, idx_vec, length);\n        svfloat64_t data = svld1_gather_u16index_f64(valid, vec, idx_vec);\n        sum_vec = svadd_f64_z(valid, sum_vec, data);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    size_t i = 0;\n    while (i < length) {\n        // Load indices for the current vector\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        \n        // Create a predicate for valid indices (0 <= index < length)\n        svbool_t valid_pg = svand_b_z(pg, svcmpge_n_s16(pg, idx_vec, 0), svcmplt_n_s16(pg, idx_vec, length));\n        \n        // Gather elements from vec using the indices\n        svfloat64_t data_vec = svld1_gather_s16index_f64(valid_pg, vec, idx_vec);\n        \n        // Accumulate the sum\n        sum_vec = svadd_f64_m(valid_pg, sum_vec, data_vec);\n        \n        i += svcntb();\n        pg = svwhilelt_b16(i, length);\n    }\n    \n    // Reduce the vector to a scalar sum\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n    double zero = 0.0;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                size_t input_row = i + ki;\n                const double* input_ptr = &input[input_row * input_size + j];\n                const double* kernel_ptr = &kernel[ki * kernel_size];\n                size_t remaining = kernel_size;\n                size_t offset = 0;\n\n                while (remaining >= svcntd()) {\n                    svfloat64_t input_vec = svld1(pg, input_ptr + offset);\n                    svfloat64_t kernel_vec = svld1(pg, kernel_ptr + offset);\n                    svfloat64_t mul_vec = svmul_f64(pg, input_vec, kernel_vec);\n                    sum += svadda_f64(pg, 0.0, mul_vec);\n                    remaining -= svcntd();\n                    offset += svcntd();\n                }\n\n                for (size_t k = offset; k < kernel_size; ++k) {\n                    sum += input_ptr[k] * kernel_ptr[k];\n                }\n            }\n            output[i * output_size + j] = (sum > zero) ? sum : zero;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t in_vec = svdup_f64(input[input_idx]);\n                    svfloat64_t ker_vec = svdup_f64(kernel[kernel_idx]);\n                    sum = svmla_f64(pg, sum, in_vec, ker_vec);\n                }\n            }\n            \n            // Apply ReLU\n            double result = svaddv_f64(pg, sum);\n            output[i * output_size + j] = result > 0.0 ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t zero_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n\n            size_t output_idx = i * output_size + j;\n            svfloat64_t result_vec = svdup_f64(sum);\n            // Apply ReLU activation (max(0, sum))\n            result_vec = svmax_f64_z(pg, result_vec, zero_vec);\n            output[output_idx] = svclastb_f64(pg, 0.0, result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t input_vec = svdup_f64(input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n                    sum = svmad_f64_x(svptrue_b64(), kernel_vec, input_vec, sum);\n                }\n            }\n            \n            // Apply ReLU\n            svfloat64_t zero = svdup_f64(0.0);\n            sum = svmax_f64_x(svptrue_b64(), sum, zero);\n            \n            // Store result\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svwhilelt_b64(0, kernel_size * kernel_size);\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_idx]);\n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                }\n            }\n            \n            double result = svaddv_f64(pg, sum);\n            result = (result > 0.0) ? result : 0.0; // ReLU\n            output[i * output_size + j] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    size_t vec_len = svcntd();\n    size_t i, j;\n\n    for (i = 0; i < n - 1; i++) {\n        svfloat64_t num_i = svdup_f64(numbers[i]);\n        size_t remaining = n - i - 1;\n        size_t j_end = i + 1 + (remaining / vec_len) * vec_len;\n\n        for (j = i + 1; j < j_end; j += vec_len) {\n            svbool_t pg = svwhilelt_b64(j, n);\n            svfloat64_t num_j = svld1_f64(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, num_i, num_j));\n            svbool_t close = svcmplt_f64(pg, diff, thresh_vec);\n            if (svptest_any(svptrue_b64(), close)) {\n                return true;\n            }\n        }\n\n        for (; j < n; j++) {\n            double diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    size_t n = numbers.size();\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        size_t elements = std::min(svcntd(), n - i);\n        svbool_t pg_loop = svwhilelt_b64(i, n);\n        \n        svfloat64_t v1 = svld1_f64(pg_loop, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            size_t elements_j = std::min(svcntd(), n - j);\n            svbool_t pg_loop_j = svwhilelt_b64(j, n);\n            \n            svfloat64_t v2 = svld1_f64(pg_loop_j, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, v1, v2));\n            svbool_t cmp = svcmplt_f64(pg, diff, v_threshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n    \n    for (size_t i = 0; i < n; i++) {\n        svfloat64_t vi = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n        \n        while (j < n) {\n            size_t len = svcntd();\n            if (j + len > n) len = n - j;\n            \n            svbool_t pm = svwhilelt_b64(j, n);\n            svfloat64_t vj = svld1_f64(pm, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vi, vj));\n            svfloat64_t vthreshold = svdup_f64(threshold);\n            svbool_t cmp = svcmplt_f64(pg, diff, vthreshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n            \n            j += len;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat64_t a = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n\n        while (j < n) {\n            // Calculate how many elements can be processed in this vector\n            size_t vec_len = svcntd();\n            size_t remaining = n - j;\n            size_t process_len = remaining < vec_len ? remaining : vec_len;\n\n            // Create predicate for active lanes\n            svbool_t pg_active = svwhilelt_b64(j, n);\n\n            // Load numbers[j:j+process_len]\n            svfloat64_t b = svld1_f64(pg_active, &numbers[j]);\n\n            // Compute absolute difference\n            svfloat64_t diff = svabs_f64_x(pg_active, svsub_f64_x(pg_active, a, b));\n\n            // Compare differences with threshold\n            svbool_t cmp = svcmplt_f64(pg_active, diff, thresh_vec);\n\n            // If any comparison is true, return true\n            if (svptest_any(pg_active, cmp)) {\n                return true;\n            }\n\n            j += process_len;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    size_t vec_len = svcntd();\n\n    for (size_t i = 0; i < n; i++) {\n        double val_i = numbers[i];\n        svfloat64_t vec_i = svdup_f64(val_i);\n        size_t j = i + 1;\n\n        while (j < n) {\n            svbool_t pg_j = svwhilelt_b64(j, n);\n            svfloat64_t vec_j = svld1_f64(pg_j, &numbers[j]);\n            svfloat64_t diff = svabs_f64_x(pg_j, svsub_f64_x(pg_j, vec_i, vec_j));\n            svbool_t close = svcmplt_f64(pg_j, diff, threshold);\n\n            if (svptest_any(pg_j, close)) {\n                return true;\n            }\n\n            j += vec_len;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t len = operations.size();\n    if (len == 0) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n    \n    // Initialize balance to 0\n    int balance = 0;\n    size_t i = 0;\n\n    // Process vectorized chunks\n    while (i + vl <= len) {\n        // Load a vector of operations\n        svint32_t vec_ops = svld1_s32(pg, &operations[i]);\n        \n        // Compute running sum for this vector\n        svint32_t vec_balance = svdup_n_s32(balance);\n        svint32_t vec_sum = svadd_s32_z(pg, vec_balance, vec_ops);\n        \n        // Check if any balance in the vector is below zero\n        svbool_t below_zero = svcmplt_s32(pg, vec_sum, svdup_n_s32(0));\n        if (svptest_any(pg, below_zero)) {\n            return true;\n        }\n        \n        // Update scalar balance with the last element of the vector sum\n        balance = svlasta_s32(svpfalse(), vec_sum);\n        i += vl;\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t len = operations.size();\n    if (len == 0) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n    \n    // Initialize running sum to 0\n    svint32_t sum_vec = svdup_n_s32(0);\n    int running_sum = 0;\n    size_t i = 0;\n\n    // Process in chunks based on vector length\n    for (; i + vl <= len; i += vl) {\n        // Load a chunk of operations\n        svint32_t ops_vec = svld1_s32(pg, &operations[i]);\n        // Add to running sum vector\n        sum_vec = svadd_s32_z(pg, sum_vec, ops_vec);\n        // Check if any element in sum_vec is negative\n        svbool_t neg_mask = svcmplt_s32(pg, sum_vec, 0);\n        if (svptest_any(pg, neg_mask)) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements scalar-wise\n    for (; i < len; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t len = operations.size();\n    if (len == 0) return false;\n\n    int64_t balance = 0;\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load a vector of operations\n        svint32_t ops_vec = svld1_s32(pg, &operations[i]);\n        \n        // Compute running sum using prefix sum within vector\n        svint64_t balance_vec = svdup_s64(balance);\n        svint64_t ops_vec64 = svcvt_s64_s32_z(pg, ops_vec);\n        balance_vec = svadd_s64_z(pg, balance_vec, ops_vec64);\n        \n        // Check if any balance in vector is negative\n        svbool_t neg_mask = svcmplt_s64(pg, balance_vec, 0);\n        if (svptest_any(pg, neg_mask)) {\n            return true;\n        }\n        \n        // Update scalar balance with the last element of the vector\n        balance = svlasta_s64(pg, balance_vec);\n    }\n\n    // Handle remaining elements scalar-wise\n    for (; i < len; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (size_t i = 0; i < operations.size(); i += svcntw()) {\n        svbool_t mask = svwhilelt_b32(i, operations.size());\n        svint32_t ops = svld1_s32(mask, &operations[i]);\n        balance = svadd_z(pg, balance, ops);\n        \n        if (svminv_s32(pg, balance) < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (size_t i = 0; i < operations.size(); i += svcntw()) {\n        size_t count = std::min(svcntw(), (int)(operations.size() - i));\n        svbool_t pg_loop = svwhilelt_b32(i, operations.size());\n        \n        svint32_t ops = svld1_s32(pg_loop, &operations[i]);\n        balance = svadd_m(pg_loop, balance, ops);\n        \n        svbool_t neg = svcmplt_s32(pg_loop, balance, svdup_s32(0));\n        if (svptest_any(pg_loop, neg)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    size_t len = numbers.size();\n    double mean = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Calculate sum\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        sum_vec = svadd_f64_z(p, sum_vec, vec);\n    }\n\n    // Horizontal sum for mean\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    mean = sum / len;\n\n    // Calculate sum of absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    sum_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        svfloat64_t diff = svabs_f64_z(p, svsub_f64_z(p, vec, mean_vec));\n        sum_vec = svadd_f64_z(p, sum_vec, diff);\n    }\n\n    // Final MAD calculation\n    double mad_sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    size_t n = numbers.size();\n    size_t vec_len = svcntd();\n    double mean = 0.0;\n    double sum = 0.0;\n    svfloat64_t vsum = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    // Calculate sum for mean\n    size_t i = 0;\n    for (; i <= n - vec_len; i += vec_len) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        vsum = svadd_f64_z(pg, vsum, vec);\n        pg = svwhilelt_b64(i + vec_len, n);\n    }\n    sum = svaddv_f64(pg, vsum);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate mean absolute deviation\n    double mad_sum = 0.0;\n    svfloat64_t vmad_sum = svdup_f64(0.0);\n    svfloat64_t vmean = svdup_f64(mean);\n    pg = svwhilelt_b64(0, n);\n\n    i = 0;\n    for (; i <= n - vec_len; i += vec_len) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vec, vmean));\n        vmad_sum = svadd_f64_z(pg, vmad_sum, diff);\n        pg = svwhilelt_b64(i + vec_len, n);\n    }\n    mad_sum = svaddv_f64(pg, vmad_sum);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    uint64_t len = numbers.size();\n    uint64_t vlen = svcntd();\n    svbool_t pg = svptrue_b64();\n    double sum = 0.0;\n    svfloat64_t vsum = svdup_f64(0.0);\n\n    // Calculate sum using SVE\n    for (uint64_t i = 0; i < len; i += vlen) {\n        svbool_t pm = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pm, &numbers[i]);\n        vsum = svadd_f64_m(pm, vsum, vec);\n    }\n\n    // Horizontal sum for mean\n    sum = svaddv_f64(pg, vsum);\n    double mean = sum / len;\n\n    // Calculate sum of absolute deviations\n    vsum = svdup_f64(0.0);\n    for (uint64_t i = 0; i < len; i += vlen) {\n        svbool_t pm = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pm, &numbers[i]);\n        svfloat64_t diff = svabs_f64_m(pm, svsub_f64_m(pm, vec, svdup_f64(mean)));\n        vsum = svadd_f64_m(pm, vsum, diff);\n    }\n\n    // Final MAD calculation\n    return svaddv_f64(pg, vsum) / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    uint64_t len = numbers.size();\n    if (len == 0) return 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    uint64_t i = 0;\n    while (i < len) {\n        svbool_t pg_loop = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg_loop, &numbers[i]);\n        sum_vec = svadd_f64_z(pg_loop, sum_vec, vec);\n        i += svcntd();\n    }\n\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n    \n    i = 0;\n    while (i < len) {\n        svbool_t pg_loop = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg_loop, &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64_z(pg_loop, svsub_f64_z(pg_loop, vec, mean_vec));\n        abs_sum_vec = svadd_f64_z(pg_loop, abs_sum_vec, abs_diff);\n        i += svcntd();\n    }\n\n    double abs_sum = svaddv_f64(svptrue_b64(), abs_sum_vec);\n    return abs_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    uint64_t len = numbers.size();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Calculate sum\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Compute mean\n    double sum = svaddv_f64(pg, sum_vec);\n    double mean = sum / len;\n\n    // Calculate sum of absolute deviations\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        svfloat64_t diff = svsub_f64_z(p, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(p, diff);\n        abs_sum_vec = svadd_f64_z(pg, abs_sum_vec, abs_diff);\n    }\n\n    // Compute MAD\n    double abs_sum = svaddv_f64(pg, abs_sum_vec);\n    return abs_sum / len;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = n * 2 - 1;\n    std::vector<int> result(result_size);\n\n    // Determine vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load input vector\n        svint32_t vec_numbers = svld1(pg, &numbers[i]);\n\n        // Create delimiter vector\n        svint32_t vec_delimiter = svdup_n_s32(delimiter);\n\n        // Create even and odd masks for interleaving\n        svbool_t even_mask = svzip1_b32(pg, svptrue_b32(), svpfalse_b32());\n        svbool_t odd_mask = svzip2_b32(pg, svptrue_b32(), svpfalse_b32());\n\n        // Store numbers at even positions\n        svst1(pg & even_mask, &result[2 * i], vec_numbers);\n\n        // Store delimiter at odd positions\n        svst1(pg & odd_mask, &result[2 * i + 1], vec_delimiter);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < n; i++) {\n        result[2 * i] = numbers[i];\n        if (i < n - 1) {\n            result[2 * i + 1] = delimiter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n    \n    if (n == 0) return result;\n    \n    // Result size will be 2*n - 1 (n numbers + n-1 delimiters)\n    result.resize(2 * n - 1);\n    \n    // Process vector length\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t del_vec = svdup_s32(delimeter);\n    \n    // Process input elements in chunks\n    size_t i = 0;\n    while (i < n) {\n        // Load input chunk\n        svint32_t num_vec = svld1_s32(pg, &numbers[i]);\n        \n        // Store numbers to even indices (0, 2, 4, ...)\n        svst1_s32(pg, &result[2 * i], num_vec);\n        \n        // Store delimiters to odd indices (1, 3, 5, ...)\n        if (i < n - 1) {\n            svbool_t pg_del = svwhilelt_b32(0, n - 1 - i);\n            svst1_s32(pg_del, &result[2 * i + 1], del_vec);\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    // Handle last delimiter if needed\n    if (n > 1 && 2 * (n - 1) < result.size()) {\n        result[2 * (n - 1)] = delimeter;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {};\n\n    size_t in_len = numbers.size();\n    size_t out_len = in_len * 2 - 1;\n    std::vector<int> result(out_len);\n\n    svbool_t pg = svwhilelt_b32(0, in_len);\n    svint32_t delim_vec = svdup_s32(delimeter);\n    \n    for (size_t i = 0; i < in_len; i += svcntw()) {\n        pg = svwhilelt_b32(i, in_len);\n        \n        // Load input vector\n        svint32_t in_vec = svld1(pg, &numbers[i]);\n        \n        // Store input elements at even indices\n        svst1(pg, &result[i * 2], in_vec);\n        \n        // Store delimiter at odd indices if not at the end\n        if (i * 2 + 1 < out_len) {\n            svbool_t store_pg = svwhilelt_b32(i * 2 + 1, out_len);\n            svst1(store_pg, &result[i * 2 + 1], delim_vec);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    size_t n = numbers.size();\n    result.resize(2 * n - 1);\n    \n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t elements = std::min(vl, n - i);\n        svbool_t mask = svwhilelt_b32(i, n);\n        \n        svint32_t vec = svld1(mask, &numbers[i]);\n        \n        size_t out_idx = 2 * i;\n        svst1(mask, &result[out_idx], vec);\n        \n        if (out_idx + elements < result.size()) {\n            svint32_t delim_vec = svdup_n_s32(delimeter);\n            svst1(mask, &result[out_idx + elements], delim_vec);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    // Determine vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process input in chunks based on vector length\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load input vector\n        svint32_t vec_in = svld1(pg, &numbers[i]);\n\n        // Create delimiter vector\n        svint32_t vec_del = svdup_n_s32(delimeter);\n\n        // Prepare output vectors for even and odd positions\n        size_t out_idx = 2 * i;\n        svst1(pg, &result[out_idx], vec_in); // Store original numbers at even positions\n\n        // Store delimiter at odd positions if not the last element\n        if (out_idx + 1 < result_size) {\n            svbool_t pg_del = svwhilelt_b32(0, vl - 1);\n            svst1(pg_del, &result[out_idx + 1], vec_del);\n        }\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < n; i++) {\n        size_t out_idx = 2 * i;\n        result[out_idx] = numbers[i];\n        if (out_idx + 1 < result_size) {\n            result[out_idx + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t len = numbers.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw(); // Number of 32-bit elements per vector (assuming int16_t widening to int32_t)\n\n    // Create predicate for active lanes\n    svbool_t pg = svptrue_b32();\n\n    // Process the vector in chunks using SVE\n    for (; i + vl <= len; i += vl) {\n        // Load a chunk of int16_t data into a vector, widening to int32_t\n        svint16_t vec16 = svld1_s16(pg, &numbers[i]);\n        svint32_t vec32 = svsxtb_n_s32(vec16); // Sign-extend int16_t to int32_t\n\n        // Compute sum for this chunk\n        sum += svaddv_s32(pg, vec32);\n\n        // Compute product for this chunk (need to handle int64_t for product to avoid overflow)\n        svint64_t vec64 = svsxtb_n_s64(vec16); // Sign-extend int16_t to int64_t\n        svint64_t prod_vec = svmul_s64_z(pg, svdup_n_s64(product), vec64);\n        product = svmulv_s64(pg, prod_vec);\n    }\n\n    // Handle remaining elements (tail) scalar-wise\n    for (; i < len; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint64_t sum_vec = svdup_n_s64(0);\n    svint64_t prod_vec = svdup_n_s64(1);\n    size_t len = numbers.size();\n    size_t vlen = svcntw();\n\n    for (size_t i = 0; i < len; i += vlen) {\n        size_t elements = std::min(vlen, len - i);\n        svbool_t mask = svwhilelt_b16(i, len);\n        svint16_t vec = svld1_s16(mask, &numbers[i]);\n        svint64_t vec64 = svunpklo_s64(svunpklo_s32(vec));\n\n        sum_vec = svadd_m(pg, sum_vec, vec64);\n        prod_vec = svmul_m(pg, prod_vec, vec64);\n    }\n\n    sum = svaddv_s64(pg, sum_vec);\n    product = svmulv_s64(pg, prod_vec);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t len = numbers.size();\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    svint64_t sum_vec = svdup_n_s64(0);\n    svint64_t prod_vec = svdup_n_s64(1);\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        svint64_t vec64 = svsext_s16_s64(vec);\n        sum_vec = svadd_s64_z(pg, sum_vec, vec64);\n        prod_vec = svmul_s64_z(pg, prod_vec, vec64);\n    }\n\n    sum = svaddv_s64(pg, sum_vec);\n    product = svmulv_s64(pg, prod_vec);\n\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vec_size = svcntw(); // Get the number of 32-bit elements in a vector\n    size_t i = 0;\n    svint16_t vec;\n    svint64_t sum_vec = svdup_n_s64(0);\n    svint64_t prod_vec = svdup_n_s64(1);\n    svbool_t pg = svptrue_b16();\n\n    for (; i + vec_size <= numbers.size(); i += vec_size) {\n        vec = svld1_s16(pg, &numbers[i]);\n        svint64_t vec64 = svsxt_s64(vec); // Sign-extend int16 to int64\n        sum_vec = svadd_s64_z(pg, sum_vec, vec64);\n        prod_vec = svmul_s64_z(pg, prod_vec, vec64);\n    }\n\n    // Horizontal reduction for sum and product\n    sum += svaddv_s64(pg, sum_vec);\n    product *= svmulv_s64(pg, prod_vec);\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t prod = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    size_t i = 0;\n    \n    while (i < numbers.size()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        \n        // Sum reduction\n        sum += svaddv_s16(pg, vec);\n        \n        // Product reduction using svmul\n        svint64_t prod_vec = svmul_s64(svcvt_s64_s16(pg, vec), svdup_s64(prod));\n        prod = svmulv_s64(pg, prod_vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, numbers.size());\n    }\n    \n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t current_max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load the current chunk of input data\n        svint32_t input_vec = svld1_s32(pg, &numbers[i]);\n        // Compute rolling maximum using SVE max operation\n        current_max_vec = svmax_s32_m(pg, current_max_vec, input_vec);\n        // Store the result\n        svst1_s32(pg, &result[i], current_max_vec);\n    }\n\n    // Handle the tail elements if any\n    if (i < n) {\n        svbool_t tail_pg = svwhilelt_b32(i, n);\n        svint32_t input_vec = svld1_s32(tail_pg, &numbers[i]);\n        current_max_vec = svmax_s32_m(tail_pg, current_max_vec, input_vec);\n        svst1_s32(tail_pg, &result[i], current_max_vec);\n    }\n\n    // Sequential fix for rolling maximum property\n    int current_max = result[0];\n    for (size_t j = 1; j < n; ++j) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t current_max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load the input vector\n        svint32_t input_vec = svld1_s32(pg, &numbers[i]);\n        // Compute rolling maximum using SVE max operation\n        current_max_vec = svmax_s32_m(pg, current_max_vec, input_vec);\n        // Store the result\n        svst1_s32(pg, &result[i], current_max_vec);\n    }\n\n    // Handle remaining elements scalar-wise\n    int current_max = result[i - 1];\n    for (; i < n; ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t len = numbers.size();\n    std::vector<int> result(len);\n    \n    if (len == 0) return result;\n    \n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    \n    // Initialize first element\n    result[0] = numbers[0];\n    int current_max = numbers[0];\n    \n    // Process in vector-sized chunks\n    size_t i = 0;\n    for (; i + vlen <= len; i += vlen) {\n        // Load vector\n        svint32_t vec = svld1(svptrue_b32(), &numbers[i]);\n        \n        // Compute maximum with previous maximum\n        svint32_t max_vec = svdup_n_s32(current_max);\n        max_vec = svmax_s32_z(svptrue_b32(), vec, max_vec);\n        \n        // Store result\n        svst1(svptrue_b32(), &result[i], max_vec);\n        \n        // Update scalar max for next iteration\n        // Get maximum element from vector\n        current_max = svlasta(svptrue_b32(), max_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load current chunk of numbers\n        svint32_t current_vec = svld1_s32(pg, &numbers[i]);\n        // Compute rolling maximum using SVE max operation\n        max_vec = svmax_s32_m(pg, max_vec, current_vec);\n        // Store the result\n        svst1_s32(pg, &result[i], max_vec);\n    }\n\n    // Handle remaining elements scalar way if any\n    int current_max = numbers[0];\n    for (size_t j = 0; j < i; j++) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svwhilelt_b32(0, numbers.size());\n\n    for (size_t i = 0; i < numbers.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, numbers.size());\n        svint32_t data_vec = svld1_s32(pg, &numbers[i]);\n        max_vec = svmax_s32_m(pg, max_vec, data_vec);\n        svst1_s32(pg, &result[i], max_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Process in vector-sized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n    \n    for (size_t i = 0; i < len; i += vlen) {\n        // Load strings a and b into vectors\n        svuint8_t va = svld1_u8(pg, (uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pg, (uint8_t*)&b[i]);\n        \n        // Convert '0'/'1' to 0/1 by subtracting ASCII '0' (48)\n        va = svsub_u8_x(pg, va, 48);\n        vb = svsub_u8_x(pg, vb, 48);\n        \n        // Perform XOR\n        svuint8_t vxor = sveor_u8_x(pg, va, vb);\n        \n        // Convert back to '0'/'1' by adding ASCII '0' (48)\n        vxor = svadd_u8_x(pg, vxor, 48);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], vxor);\n        \n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i + vlen, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine the vector length for SVE\n    uint64_t vec_len = svcntb();\n    size_t i = 0;\n\n    // Process the strings in chunks based on vector length\n    while (i + vec_len <= len) {\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store the result back to the output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vec_len;\n    }\n\n    // Handle remaining elements scalarly if any\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine the vector length for SVE\n    uint64_t vec_len = svcntb();\n    size_t i = 0;\n\n    // Process the strings in chunks based on vector length\n    while (i + vec_len <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store the result back into the result string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vec_len;\n    }\n\n    // Handle remaining elements if length is not a multiple of vector length\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine vector length using SVE\n    uint64_t vlen = svcntb();\n    size_t i = 0;\n    \n    // Process input strings in chunks based on vector length\n    while (i + vlen <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vlen;\n    }\n    \n    // Handle remaining elements if length is not multiple of vector length\n    while (i < len) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n        i++;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    size_t vl = svcntb();\n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < len; i += vl) {\n        // Calculate remaining elements\n        size_t remaining = len - i;\n        svbool_t pm = svwhilelt_b8(i, len);\n        \n        // Load strings into vectors\n        svuint8_t va = svld1_u8(pm, (uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pm, (uint8_t*)&b[i]);\n        \n        // Perform XOR operation\n        svuint8_t vxor = svxor_u8_m(pm, va, vb);\n        \n        // Convert to '0' or '1' (ASCII '0' = 48, '1' = 49)\n        svuint8_t vresult = svadd_u8_m(pm, vxor, svdup_u8('0'));\n        \n        // Store result\n        svst1_u8(pm, (uint8_t*)&result[i], vresult);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    uint64_t vlen = svcntb();\n    svuint64_t max_len = svdup_u64(0);\n    svuint64_t max_idx = svdup_u64(0);\n\n    for (size_t i = 0; i < strings.size(); i += vlen) {\n        svbool_t active = svwhilelt_b8(i, strings.size());\n        svuint64_t indices = svindex_u64(i, 1);\n        svuint64_t lengths = svdup_u64(0);\n\n        for (uint64_t j = 0; j < vlen && i + j < strings.size(); ++j) {\n            lengths = svsel_u64(svcmpeq_u64(active, indices, i + j), \n                              svdup_u64(strings[i + j].length()), \n                              lengths);\n        }\n\n        svbool_t cmp = svcmpgt_u64(active, lengths, max_len);\n        max_len = svsel_u64(cmp, lengths, max_len);\n        max_idx = svsel_u64(cmp, indices, max_idx);\n    }\n\n    uint64_t final_max_len = svmaxv_u64(pg, max_len);\n    uint64_t final_max_idx = svmaxv_u64(pg, max_idx);\n\n    return strings[final_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svwhilelt_b8(0, strings.size());\n    svuint64_t max_len_vec = svdup_u64(0);\n    svuint64_t max_idx_vec = svdup_u64(0);\n    uint64_t max_len = 0;\n    uint64_t max_idx = 0;\n\n    for (size_t i = 0; i < strings.size(); i += svcntb()) {\n        svbool_t p = svwhilelt_b8(i, strings.size());\n        svuint64_t idx_vec = svindex_u64(i, 1);\n        svuint64_t len_vec = svdup_u64(0);\n\n        for (size_t j = 0; j < svcntb() && i + j < strings.size(); ++j) {\n            len_vec = svinsr_n_u64(len_vec, strings[i + j].length(), j);\n        }\n\n        svbool_t cmp = svcmpgt_u64(p, len_vec, max_len_vec);\n        max_len_vec = svsel_u64(cmp, len_vec, max_len_vec);\n        max_idx_vec = svsel_u64(cmp, idx_vec, max_idx_vec);\n\n        uint64_t local_max_len = svlasta(svptrue_b64(), max_len_vec);\n        if (local_max_len > max_len) {\n            max_len = local_max_len;\n            max_idx = svlasta(svptrue_b64(), max_idx_vec);\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t vector_length = svcntd(); // Get the number of 64-bit elements in a vector\n    svuint64_t max_lengths = svdup_u64(0);\n    svuint64_t indices = svdup_u64(0);\n    svbool_t pg = svptrue_b64();\n\n    size_t i = 0;\n    for (; i + vector_length <= n; i += vector_length) {\n        svuint64_t current_lengths = svdup_u64(0);\n        svuint64_t current_indices = svindex_u64(i, 1);\n\n        for (size_t j = 0; j < vector_length; ++j) {\n            if (i + j < n) {\n                size_t len = strings[i + j].length();\n                current_lengths = svsel_u64(svptrue_pat_b64(SV_VL1 + j), svdup_u64(len), current_lengths);\n            }\n        }\n\n        svbool_t mask = svcmpgt_u64(pg, current_lengths, max_lengths);\n        max_lengths = svsel_u64(mask, current_lengths, max_lengths);\n        indices = svsel_u64(mask, current_indices, indices);\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    uint64_t temp_lengths[vector_length];\n    uint64_t temp_indices[vector_length];\n    svst1_u64(pg, temp_lengths, max_lengths);\n    svst1_u64(pg, temp_indices, indices);\n\n    for (size_t j = 0; j < vector_length; ++j) {\n        if (temp_lengths[j] > max_len) {\n            max_len = temp_lengths[j];\n            max_idx = temp_indices[j];\n        }\n    }\n\n    for (; i < n; ++i) {\n        size_t len = strings[i].length();\n        if (len > max_len) {\n            max_len = len;\n            max_idx = i;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    if (n == 1) {\n        return strings[0];\n    }\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntb();\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    // Process strings in chunks based on vector length\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint64_t lengths = svdup_u64(0);\n\n        // Load lengths of strings in the current chunk\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n) {\n                size_t len = strings[i + j].length();\n                lengths = svinsr_n_u64(lengths, j, len);\n            }\n        }\n\n        // Find maximum length in the current chunk\n        uint64_t local_max_len = svmaxv_u64(pg, lengths);\n        if (local_max_len > max_len) {\n            max_len = local_max_len;\n            // Find the index of the maximum length\n            svbool_t eq_max = sveq_u64(pg, lengths, local_max_len);\n            max_idx = i + svclzb_u64(eq_max);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        size_t len = strings[i].length();\n        if (len > max_len) {\n            max_len = len;\n            max_idx = i;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    if (n == 1) {\n        return strings[0];\n    }\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Store lengths of strings\n    std::vector<uint32_t> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = static_cast<uint32_t>(strings[i].size());\n    }\n\n    size_t max_len_idx = 0;\n    uint32_t max_len = lengths[0];\n\n    // Process in chunks based on vector length\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = std::min(vl, n - i);\n        svbool_t active_pg = svwhilelt_b32(i, i + remaining);\n\n        // Load lengths into a vector\n        svuint32_t len_vec = svld1_u32(active_pg, &lengths[i]);\n\n        // Compare with current max_len using vector operations\n        svbool_t gt_mask = svcmpgt_u32(active_pg, len_vec, max_len);\n\n        // If any element is greater than max_len, update max_len and max_len_idx\n        if (svptest_any(active_pg, gt_mask)) {\n            // Find the first index where length > max_len\n            for (size_t j = 0; j < remaining; ++j) {\n                if (svptest_nth(active_pg, gt_mask, j)) {\n                    max_len = lengths[i + j];\n                    max_len_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_len_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n    svuint64_t vec_zero = svdup_u64(0);\n\n    while (svptest_any(pg, svcmpne(pg, vec_b, vec_zero))) {\n        svuint64_t vec_temp = svdup_u64(0);\n        vec_temp = vec_b;\n        vec_b = svmod_u64_x(pg, vec_a, vec_b);\n        vec_a = vec_temp;\n    }\n\n    return svlasta_u64(pg, vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n    svuint64_t vec_zero = svdup_u64(0);\n\n    while (svptest_any(pg, svcmpne(pg, vec_b, vec_zero))) {\n        svuint64_t vec_temp = svdup_u64(0);\n        vec_temp = vec_b;\n        vec_b = svmod_u64(pg, vec_a, vec_b);\n        vec_a = vec_temp;\n    }\n\n    return svlasta(pg, vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n    svuint64_t vec_zero = svdup_u64(0);\n\n    while (svptest_any(pg, svcmpne(pg, vec_b, vec_zero))) {\n        svuint64_t vec_temp = vec_b;\n        vec_b = svmod_u64_z(pg, vec_a, vec_b);\n        vec_a = vec_temp;\n    }\n\n    return svlasta(pg, vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n    svuint64_t vec_zero = svdup_u64(0);\n\n    while (svptest_any(pg, svcmpne(pg, vec_b, vec_zero))) {\n        svuint64_t vec_temp = vec_b;\n        vec_b = svmod_u64_x(pg, vec_a, vec_b);\n        vec_a = vec_temp;\n    }\n\n    return svlasta_u64(pg, vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n    svuint64_t vec_zero = svdup_u64(0);\n\n    while (svptest_any(pg, svcmpne(pg, vec_b, vec_zero))) {\n        svuint64_t vec_temp = vec_b;\n        vec_b = svmod_u64_x(pg, vec_a, vec_b);\n        vec_a = vec_temp;\n    }\n\n    return svlasta_u64(pg, vec_a);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t first_vec = svdup_f32(first);\n    svfloat32_t second_vec = svdup_f32(second);\n\n    size_t vec_len = svcntw();\n    for (size_t i = 0; i < n; i++) {\n        svfloat32_t val_i = svdup_f32(numbers[i]);\n        svbool_t pg = svwhilelt_b32(i, n);\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            svbool_t pg_inner = svwhilelt_b32(j, n);\n            svfloat32_t val_j = svld1_f32(pg_inner, &numbers[j]);\n            svfloat32_t diff = svabs_f32_x(pg_inner, svsub_f32_x(pg_inner, val_j, val_i));\n            svbool_t cond = svcmplt_f32(pg_inner, diff, min_diff_vec);\n\n            if (svptest_any(pg_inner, cond)) {\n                float local_min_diff = svminv_f32_x(pg_inner, diff);\n                if (local_min_diff < min_diff) {\n                    min_diff = local_min_diff;\n                    min_diff_vec = svdup_f32(min_diff);\n\n                    uint64_t mask = svmov_n_u64_z(cond, 1);\n                    for (size_t k = 0; k < vec_len; k++) {\n                        if (mask & (1ULL << k)) {\n                            float candidate_j = numbers[j + k];\n                            float smaller = std::min(numbers[i], candidate_j);\n                            float larger = std::max(numbers[i], candidate_j);\n                            first = smaller;\n                            second = larger;\n                            first_vec = svdup_f32(first);\n                            second_vec = svdup_f32(second);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return {};\n    }\n\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    for (size_t i = 0; i < n - 1; i++) {\n        float current = numbers[i];\n        svfloat32_t vec_current = svdup_f32(current);\n        size_t j = i + 1;\n\n        // Process elements in chunks using SVE\n        for (; j <= n - vl; j += vl) {\n            svfloat32_t vec_next = svld1_f32(pg, &numbers[j]);\n            svfloat32_t vec_diff = svabs_f32_x(pg, svsub_f32_x(pg, vec_next, vec_current));\n            float local_min_diff = svminv_f32_x(pg, vec_diff);\n\n            if (local_min_diff < min_diff) {\n                // Extract the minimum difference and corresponding index\n                svbool_t min_mask = svcmpeq_f32(pg, vec_diff, svdup_f32(local_min_diff));\n                uint64_t mask = svcntp_b32(pg, min_mask);\n                size_t min_idx = j + __builtin_ctzll(mask);\n\n                min_diff = local_min_diff;\n                num1 = current;\n                num2 = numbers[min_idx];\n            }\n        }\n\n        // Handle remaining elements scalar-wise\n        for (; j < n; j++) {\n            float diff = std::abs(numbers[j] - current);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = current;\n                num2 = numbers[j];\n            }\n        }\n    }\n\n    // Ensure smaller number is first\n    if (num1 > num2) {\n        std::swap(num1, num2);\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val = 0.0f, max_val = 0.0f;\n\n    // Ensure at least two elements\n    if (n < 2) return {};\n\n    svfloat32_t min_diff_vec = svdup_f32(std::numeric_limits<float>::max());\n    svfloat32_t min_val_vec = svdup_f32(0.0f);\n    svfloat32_t max_val_vec = svdup_f32(0.0f);\n\n    // Process pairs in vectorized manner\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat32_t a = svdup_f32(numbers[i]);\n        svbool_t pg = svwhilelt_b32(i + 1, (uint32_t)n);\n        \n        // Load remaining elements\n        svfloat32_t b = svld1_f32(pg, &numbers[i + 1]);\n        \n        // Compute absolute differences\n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, a, b));\n        \n        // Find minimum difference\n        svbool_t cmp = svcmplt_f32(pg, diff, min_diff_vec);\n        min_diff_vec = svsel_f32(cmp, diff, min_diff_vec);\n        \n        // Update min and max values based on comparison\n        svfloat32_t min_temp = svsel_f32(cmp, svmin_f32_z(pg, a, b), min_val_vec);\n        svfloat32_t max_temp = svsel_f32(cmp, svmax_f32_z(pg, a, b), max_val_vec);\n        \n        min_val_vec = svsel_f32(cmp, min_temp, min_val_vec);\n        max_val_vec = svsel_f32(cmp, max_temp, max_val_vec);\n    }\n\n    // Reduce to find final minimum difference and corresponding values\n    min_diff = svminv_f32(svptrue_b32(), min_diff_vec);\n    svbool_t pg = svptrue_b32();\n    \n    // Find indices where difference equals min_diff\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat32_t a = svdup_f32(numbers[i]);\n        svbool_t pg_loop = svwhilelt_b32(i + 1, (uint32_t)n);\n        svfloat32_t b = svld1_f32(pg_loop, &numbers[i + 1]);\n        svfloat32_t diff = svabs_f32_z(pg_loop, svsub_f32_z(pg_loop, a, b));\n        \n        svbool_t eq = svcmpeq_f32(pg_loop, diff, min_diff);\n        if (svptest_any(pg_loop, eq)) {\n            min_val = numbers[i];\n            // Get first element where difference equals min_diff\n            for (size_t j = i + 1; j < n; j++) {\n                if (std::abs(numbers[i] - numbers[j]) == min_diff) {\n                    max_val = numbers[j];\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    return {std::min(min_val, max_val), std::max(min_val, max_val)};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val = numbers[0], max_val = numbers[0];\n    \n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t min_val_vec = svdup_f32(min_val);\n    svfloat32_t max_val_vec = svdup_f32(max_val);\n    \n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n        svfloat32_t a = svld1_f32(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            svbool_t pg2 = svwhilelt_b32(j, n);\n            svfloat32_t b = svld1_f32(pg2, &numbers[j]);\n            \n            svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, a, b));\n            \n            svbool_t cmp = svcmplt_f32(pg, diff, min_diff_vec);\n            min_diff_vec = svsel_f32(cmp, diff, min_diff_vec);\n            \n            svfloat32_t curr_min = svmin_f32_z(pg, a, b);\n            svfloat32_t curr_max = svmax_f32_z(pg, a, b);\n            \n            min_val_vec = svsel_f32(cmp, curr_min, min_val_vec);\n            max_val_vec = svsel_f32(cmp, curr_max, max_val_vec);\n        }\n    }\n    \n    float final_min_diff = svminv_f32(svptrue_b32(), min_diff_vec);\n    float final_min_val = svminv_f32(svptrue_b32(), min_val_vec);\n    float final_max_val = svmaxv_f32(svptrue_b32(), max_val_vec);\n    \n    return {final_min_val, final_max_val};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return {};\n\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val = 0.0f, max_val = 0.0f;\n\n    // Sort the input array to simplify finding closest pairs\n    std::sort(numbers.begin(), numbers.end());\n\n    // Get vector length for SVE\n    uint64_t vlen = svcntw();\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n\n    // Load first n-1 elements\n    svfloat32_t vec1 = svld1_f32(pg, numbers.data());\n    // Load elements offset by 1\n    svfloat32_t vec2 = svld1_f32(pg, numbers.data() + 1);\n\n    // Compute differences\n    svfloat32_t diff = svsub_f32_x(pg, vec2, vec1);\n    // Compute absolute differences\n    svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n\n    // Find minimum difference\n    float local_min_diff = svminv_f32(abs_diff, pg);\n\n    // Find index of minimum difference\n    svbool_t min_mask = svcmpeq_f32(pg, abs_diff, local_min_diff);\n    uint64_t idx = svcntp_b32(min_mask);\n\n    // Get the two closest numbers\n    if (idx < n - 1) {\n        min_val = numbers[idx];\n        max_val = numbers[idx + 1];\n    }\n\n    return {min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_z(pg, min_vec, vec);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    // Reduce to get single min and max values\n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    \n    // Compute range\n    float range = max_val - min_val;\n    float inv_range = (range != 0.0f) ? 1.0f / range : 0.0f;\n    \n    // Rescale the vector\n    svfloat32_t min_broadcast = svdup_f32(min_val);\n    svfloat32_t inv_range_broadcast = svdup_f32(inv_range);\n    \n    i = 0;\n    pg = svwhilelt_b32(i, n);\n    do {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t rescaled = svmul_f32_z(pg, svsub_f32_z(pg, vec, min_broadcast), inv_range_broadcast);\n        svst1_f32(pg, &result[i], rescaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(svptrue_b32(), min_vec, vec);\n        max_vec = svmax_f32_x(svptrue_b32(), max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    float scale = (max_val != min_val) ? 1.0f / (max_val - min_val) : 0.0f;\n    \n    // Apply linear transform\n    svfloat32_t min_broadcast = svdup_f32(min_val);\n    svfloat32_t scale_broadcast = svdup_f32(scale);\n    \n    i = 0;\n    pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t res = svsub_f32_x(pg, vec, min_broadcast);\n        res = svmul_f32_x(pg, res, scale_broadcast);\n        svst1_f32(pg, &result[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(pg, min_vec, vec);\n        max_vec = svmax_f32_x(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    // Reduce to get scalar min and max\n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    \n    // Calculate scale factor\n    float scale = (max_val == min_val) ? 0.0f : 1.0f / (max_val - min_val);\n    \n    // Apply linear transform\n    svfloat32_t min = svdup_f32(min_val);\n    svfloat32_t scale_vec = svdup_f32(scale);\n    \n    i = 0;\n    pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t res = svmul_f32_x(pg, svsub_f32_x(pg, vec, min), scale_vec);\n        svst1_f32(pg, &result[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    std::vector<float> result(n);\n\n    // Initialize min and max with first element\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max using SVE\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        min_val = svminv_f32_x(svptrue_b32(), vec, min_val);\n        max_val = svmaxv_f32_x(svptrue_b32(), vec, max_val);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    // Compute range\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    // Rescale the vector using SVE\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    i = 0;\n    for (; i + vl <= n; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_x(svptrue_b32(), svsub_f32_x(svptrue_b32(), vec, min_vec), range_vec);\n        svst1_f32(svptrue_b32(), &result[i], rescaled);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    std::vector<float> result(n);\n\n    // Initialize min and max with first element\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max using SVE\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        min_val = svminv_f32_x(svptrue_b32(), vec, min_val);\n        max_val = svmaxv_f32_x(svptrue_b32(), vec, max_val);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    // Compute range\n    float range = max_val - min_val;\n    if (range == 0) {\n        std::fill(result.begin(), result.end(), 0.0f);\n        return result;\n    }\n\n    // Rescale the vector using SVE\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    i = 0;\n    for (; i <= n - vl; i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t scaled = svdiv_f32_x(svptrue_b32(), svsub_f32_x(svptrue_b32(), vec, min_vec), range_vec);\n        svst1_f32(svptrue_b32(), &result[i], scaled);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Get the vector length for SVE\n    uint64_t vlen = svcntd();\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_divisors = svindex_u64(1, 1);\n    svbool_t pg = svwhilelt_b64(1, vlen);\n    uint64_t max_divisor = 1;\n\n    // Iterate over possible divisors in chunks using SVE\n    for (uint64_t i = 1; i < n; i += vlen) {\n        // Update predicate for the current chunk\n        pg = svwhilelt_b64(i, n);\n\n        // Compute remainders for the current chunk of divisors\n        svuint64_t remainder = svmod_u64_z(pg, vec_n, vec_divisors);\n\n        // Check for zero remainders (perfect divisors)\n        svbool_t is_divisor = svcmpeq_u64(pg, remainder, 0);\n\n        // Update max_divisor if a larger divisor is found\n        if (svptest_any(svptrue_b64(), is_divisor)) {\n            svuint64_t candidates = svsel_u64(is_divisor, vec_divisors, svdup_u64(max_divisor));\n            max_divisor = svmaxv_u64(svptrue_b64(), candidates);\n        }\n\n        // Increment the divisors vector for the next iteration\n        vec_divisors = svadd_u64_z(pg, vec_divisors, svdup_u64(vlen));\n    }\n\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t max_div = 1;\n    uint64_t i = 2;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svdup_u64(i);\n    svuint64_t vec_max = svdup_u64(max_div);\n\n    while (svcmplt_n_u64(pg, vec_i, n)) {\n        svbool_t div_mask = svcmpeq_n_u64(pg, svmod_n_u64(pg, vec_n, vec_i), 0);\n        vec_max = svsel_u64(div_mask, vec_i, vec_max);\n        vec_i = svadd_n_u64_x(pg, vec_i, 1);\n    }\n\n    return svmaxv_u64(pg, vec_max);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t largest = 1;\n    uint64_t vector_size = svcntd(); // Get the number of 64-bit elements in the vector\n    svuint64_t divisors = svindex_u64(2, 1); // Start from 2, increment by 1\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    // Calculate the upper limit for checking divisors (sqrt(n))\n    uint64_t limit = (uint64_t)sqrt(n);\n    while (1) {\n        // Create a vector of n for comparison\n        svuint64_t n_vec = svdup_u64(n);\n        // Compute remainders: n % divisors\n        svuint64_t remainders = svmod_u64_z(pg, n_vec, divisors);\n        // Check where remainder is 0\n        svbool_t eq_zero = svcmpeq_u64(pg, remainders, 0);\n        // Extract the largest divisor where remainder is 0\n        if (svptest_any(pg, eq_zero)) {\n            uint64_t candidate = svmaxv_u64(pg, divisors);\n            if (candidate <= limit) {\n                largest = (n / candidate > largest) ? n / candidate : candidate;\n            }\n        }\n\n        // Update divisors for the next iteration\n        divisors = svadd_u64_z(pg, divisors, vector_size);\n        // Check if we've exceeded the limit\n        svbool_t exceed_limit = svcmpgt_u64(pg, divisors, limit);\n        if (svptest_all(pg, exceed_limit)) {\n            break;\n        }\n    }\n\n    // Check remaining divisors sequentially if necessary\n    for (uint64_t i = limit + 1; i < n; ++i) {\n        if (n % i == 0) {\n            largest = i;\n            break;\n        }\n    }\n\n    return largest;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    uint64_t largest = 1;\n    uint64_t vector_size = svcntd(); // Get the number of 64-bit elements in a vector\n    svuint64_t divisors = svindex_u64(2, 1); // Start from 2, increment by 1\n    svbool_t ptrue = svptrue_b64(); // Predicate for all true\n\n    uint64_t limit = n / 2 + 1; // Only need to check up to n/2\n    while (1) {\n        svbool_t active = svptrue_b64();\n        svuint64_t n_vec = svdup_u64(n);\n        svuint64_t remainder = svmod_u64_x(ptrue, n_vec, divisors);\n        svbool_t is_divisor = svcmpeq_u64(ptrue, remainder, 0);\n\n        // Find the largest divisor in the current vector\n        uint64_t local_max = 0;\n        for (int i = 0; i < vector_size; i++) {\n            if (svptest_nth(is_divisor, i)) {\n                uint64_t candidate = 2 + i;\n                if (candidate > local_max && candidate < n) {\n                    local_max = candidate;\n                }\n            }\n        }\n        if (local_max > largest) {\n            largest = local_max;\n        }\n\n        // Check if we've exceeded the limit\n        svbool_t exceeds_limit = svcmpgt_u64(ptrue, divisors, limit);\n        if (svptest_any(ptrue, exceeds_limit)) {\n            break;\n        }\n\n        // Increment the divisors vector by vector_size\n        divisors = svadd_u64_x(ptrue, divisors, vector_size);\n    }\n\n    // Check remaining divisors sequentially if needed\n    for (uint64_t i = limit - (limit % vector_size) + 1; i < limit; i++) {\n        if (n % i == 0 && i > largest && i < n) {\n            largest = i;\n        }\n    }\n\n    return largest;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t max_div = 1;\n    svuint64_t divisors = svindex_u64(1, 1);\n    svuint64_t n_vec = svdup_u64(n);\n    svuint64_t max_div_vec = svdup_u64(1);\n    \n    for (uint64_t i = 1; i <= n / 2; i += svcntd()) {\n        pg = svwhilelt_b64(i, n / 2 + 1);\n        divisors = svindex_u64(i, 1);\n        \n        svuint64_t quot = svdiv_u64_z(pg, n_vec, divisors);\n        svuint64_t prod = svmul_u64_z(pg, quot, divisors);\n        svbool_t is_div = svcmpeq_u64(pg, prod, n_vec);\n        \n        svuint64_t curr_max = svsel_u64(is_div, divisors, max_div_vec);\n        max_div_vec = svmax_u64_z(pg, max_div_vec, curr_max);\n    }\n    \n    max_div = svlasta_u64(svptrue_b64(), max_div_vec);\n    return max_div;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Handle division by 2 separately to optimize for odd numbers later\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Use SVE to check multiple potential factors in parallel\n    int start = 3;\n    int step = 2; // Check only odd numbers\n    svbool_t pg = svptrue_b32();\n    uint64_t vector_length = svcntw();\n\n    while (start * start <= n) {\n        // Create a vector of potential factors: start, start+2, start+4, ...\n        svint32_t factors_vec = svindex_s32(start, step);\n        svint32_t n_vec = svdup_s32(n);\n        svint32_t remainder_vec = svmod_s32_z(pg, n_vec, factors_vec);\n        svbool_t is_factor = svcmpeq_s32(pg, remainder_vec, 0);\n\n        // Check each element in the vector for factors\n        while (svptest_any(pg, is_factor)) {\n            int factor = svlastb_s32(pg, factors_vec);\n            if (n % factor == 0) {\n                factors.push_back(factor);\n                n /= factor;\n            } else {\n                // Move to the next potential factor in the vector\n                factors_vec = svadd_s32_z(pg, factors_vec, svdup_s32(step * vector_length));\n            }\n            remainder_vec = svmod_s32_z(pg, n_vec, factors_vec);\n            is_factor = svcmpeq_s32(pg, remainder_vec, 0);\n        }\n\n        // Update start for the next batch of potential factors\n        start += step * vector_length;\n    }\n\n    // Handle the remaining factor if n is still greater than 1\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int is log2(n) + 1\n    const int max_factors = 32;\n    int32_t factor_array[max_factors];\n    int factor_count = 0;\n\n    // Initialize SVE vectors\n    svbool_t pg = svwhilelt_b32(0, max_factors);\n    svint32_t factor_vec = svdup_n_s32(0);\n\n    // Handle factor 2 separately to optimize for odd numbers\n    while (n % 2 == 0) {\n        factor_array[factor_count++] = 2;\n        n = n / 2;\n    }\n\n    // Create vector for trial division (3, 5, 7, ...)\n    svint32_t divisors = svindex_s32(3, 2);\n    svint32_t n_vec = svdup_n_s32(n);\n\n    // Main factorization loop using SVE\n    while (svptest_any(pg, svcmpgt_n_s32(pg, n_vec, 1))) {\n        // Check if divisors divide n\n        svbool_t div_mask = svcmpeq_n_s32(pg, svmod_n_s32(pg, n_vec, divisors), 0);\n        \n        // Process divisors that divide n\n        while (svptest_any(pg, div_mask)) {\n            // Get first active divisor\n            int32_t divisor = svlasta_s32(svptrue_b32(), svsel_s32(div_mask, divisors, svdup_n_s32(0)));\n            \n            // Add factor and divide n\n            factor_array[factor_count++] = divisor;\n            n = n / divisor;\n            n_vec = svdup_n_s32(n);\n            \n            // Update division mask\n            div_mask = svcmpeq_n_s32(pg, svmod_n_s32(pg, n_vec, divisors), 0);\n        }\n\n        // Increment divisors by 2 (next odd numbers)\n        divisors = svadd_n_s32_x(pg, divisors, 2);\n    }\n\n    // Copy factors to output vector\n    for (int i = 0; i < factor_count; i++) {\n        factors.push_back(factor_array[i]);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int is log2(n) + 1\n    int max_factors = 32;\n    int temp_factors[32];\n    int factor_count = 0;\n\n    // Initialize SVE vectors\n    svbool_t pg = svwhilelt_b32(0, max_factors);\n    svint32_t factor_vec = svdup_s32(0);\n    svint32_t candidate_vec = svindex_s32(2, 1); // Start from 2\n    int current_factor = 2;\n\n    while (n > 1 && current_factor * current_factor <= n) {\n        svbool_t div_mask = svptrue_b32();\n        svint32_t n_vec = svdup_s32(n);\n        svint32_t div_result = svdiv_s32_z(pg, n_vec, candidate_vec);\n        svint32_t remainder = svmul_s32_z(pg, div_result, candidate_vec);\n        remainder = svsub_s32_z(pg, n_vec, remainder);\n        svbool_t is_divisible = svcmpeq_s32(pg, remainder, svdup_s32(0));\n\n        // Check if current_factor divides n\n        if (svptest_any(pg, is_divisible)) {\n            if (n % current_factor == 0) {\n                temp_factors[factor_count++] = current_factor;\n                n /= current_factor;\n                continue;\n            }\n        }\n        current_factor++;\n        candidate_vec = svadd_s32_z(pg, candidate_vec, svdup_s32(1));\n    }\n\n    // Handle remaining factor\n    if (n > 1) {\n        temp_factors[factor_count++] = n;\n    }\n\n    // Copy to output vector\n    factors.reserve(factor_count);\n    for (int i = 0; i < factor_count; i++) {\n        factors.push_back(temp_factors[i]);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for reasonable input sizes\n    const int max_factors = 64;\n    int32_t temp_factors[max_factors];\n    int factor_count = 0;\n\n    // SVE vector for trial divisors\n    svbool_t pg = svptrue_b32();\n    svint32_t divisors = svindex_s32(2, 1);\n    svint32_t n_vec = svdup_s32(n);\n\n    // Trial division up to sqrt(n)\n    int limit = (int)std::sqrt(n) + 1;\n    while (svcmpgt(pg, divisors, svdup_s32(1)) && factor_count < max_factors) {\n        // Check if divisors divide n evenly\n        svbool_t div_mask = svcmpeq(pg, svmod_s32(n_vec, divisors), svdup_s32(0));\n        \n        // Process each active lane\n        while (svptest_any(pg, div_mask)) {\n            int32_t divisor;\n            // Get first active divisor\n            svbool_t first = svfirst(pg, div_mask);\n            divisor = svlastb(first, divisors);\n            \n            // Store factor\n            temp_factors[factor_count++] = divisor;\n            n /= divisor;\n            \n            // Update n_vec\n            n_vec = svdup_s32(n);\n            \n            // Recheck the same divisor\n            div_mask = svcmpeq(pg, svmod_s32(n_vec, divisors), svdup_s32(0));\n        }\n\n        // Increment divisors\n        divisors = svadd_s32_x(pg, divisors, svdup_s32(1));\n        \n        // Break if n is reduced to 1 or divisors exceed sqrt(n)\n        if (n == 1 || svmaxv_s32(pg, divisors) > limit) break;\n    }\n\n    // Handle remaining prime factor if n > 1\n    if (n > 1 && factor_count < max_factors) {\n        temp_factors[factor_count++] = n;\n    }\n\n    // Copy to output vector\n    factors.assign(temp_factors, temp_factors + factor_count);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Handle factor 2 separately to optimize for odd numbers\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Use SVE to check multiple potential factors in parallel\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b32(3, sqrt_n + 1);\n    uint32_t vector_size = svcntw();\n\n    // Allocate vectors for potential factors\n    svuint32_t factors_vec = svindex_u32(3, 2); // Start from 3, step by 2 (odd numbers)\n    svuint32_t n_vec = svdup_u32(n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Compute remainders for n % factors_vec\n        svuint32_t remainder = svmod_u32_z(pg, n_vec, factors_vec);\n        svbool_t is_factor = svcmpeq_u32(pg, remainder, 0);\n\n        // Process each element in the vector\n        for (uint32_t i = 0; i < vector_size; ++i) {\n            if (svptest_nth(pg, i, is_factor)) {\n                uint32_t factor = svlasta_u32(svpfalse_b(), svsel_u32(svcmpeq_u32(pg, svindex_u32(0, 1), i), factors_vec, svdup_u32(0)));\n                while (n % factor == 0) {\n                    factors.push_back(factor);\n                    n /= factor;\n                }\n            }\n        }\n\n        // Update factors_vec to next set of potential factors\n        factors_vec = svadd_u32_z(pg, factors_vec, svdup_u32(vector_size * 2));\n        pg = svwhilelt_b32(svlastb_u32(svpfalse_b(), factors_vec), sqrt_n + 1);\n    }\n\n    // If n is still greater than 1, it is a prime factor itself\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t vec_size = svcntw();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svbool_t mask = svcmpgt(pg, vec, svdup_f32(0.0f));\n        float temp[vec_size];\n        svst1(mask, temp, vec);\n        size_t active_count = svcntp_b32(pg, mask);\n        for (size_t j = 0; j < active_count; ++j) {\n            result.push_back(temp[j]);\n        }\n        i += vec_size;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i + svcntw() <= l.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        float temp[svcntw()];\n        svst1_f32(mask, temp, vec);\n        for (int j = 0; j < svcntw(); j++) {\n            if (svptest_any(pg, mask)) {\n                if (temp[j] > 0.0f) {\n                    result.push_back(temp[j]);\n                }\n            }\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t len = l.size();\n    result.reserve(len); // Reserve space for potential maximum output size\n\n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    svbool_t pg = svwhilelt_b32(0, len);\n\n    size_t i = 0;\n    for (; i + vlen <= len; i += vlen) {\n        // Load vector\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers (x > 0)\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Store results where mask is true\n        float temp[vlen];\n        svst1_f32(positive_mask, temp, vec);\n        \n        // Count true predicates\n        uint64_t true_count = svcntp_b32(pg, positive_mask);\n        \n        // Append positive values to result\n        for (uint64_t j = 0; j < true_count; j++) {\n            result.push_back(temp[j]);\n        }\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + vlen, len);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t len = l.size();\n    size_t vl = svcntw(); // Get vector length in elements (for float32)\n\n    // Process input vector in chunks of vector length\n    for (size_t i = 0; i < len; i += vl) {\n        // Ensure we don't go beyond input size\n        size_t remaining = std::min(vl, len - i);\n        \n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32(i, len);\n        \n        // Load input data\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create mask for positive values (x > 0)\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Count number of positive values in this vector\n        uint64_t count = svcntp_b32(pos_mask);\n        \n        // Store positive values to temporary array\n        float temp[vl];\n        svst1_f32(pos_mask, temp, vec);\n        \n        // Copy positive values to result\n        for (size_t j = 0; j < count; j++) {\n            result.push_back(temp[j]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    const float* input = l.data();\n    size_t len = l.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n\n    for (size_t i = 0; i < len; ) {\n        svfloat32_t vec = svld1_f32(pg, input + i);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n\n        float temp[svcntw()];\n        svst1_f32(pg, temp, vec);\n        uint64_t active_lanes = svcntp_b32(pg, mask);\n\n        for (size_t j = 0; j < active_lanes; j++) {\n            if (svptest_any(pg, mask)) {\n                if (temp[j] > 0.0f) {\n                    result.push_back(temp[j]);\n                }\n                mask = svbic_b_z(svptrue_b32(), mask, svptrue_b32());\n            }\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svint64_t vec_i = svindex_s64(3, 2);\n    svbool_t is_not_divisible = svnot_b_z(pg, svcmpeq_s64(pg, svmod_s64(vec_n, vec_i), 0));\n\n    while (svptest_any(svptrue_b64(), is_not_divisible)) {\n        if (!svptest_any(svptrue_b64(), pg)) {\n            return true;\n        }\n        vec_i = svadd_s64_z(pg, vec_i, svdup_s64(svlen_s64(vec_i) * 2));\n        pg = svwhilelt_b64(svminv_s64(pg, vec_i), sqrt_n + 1);\n        is_not_divisible = svnot_b_z(pg, svcmpeq_s64(pg, svmod_s64(vec_n, vec_i), 0));\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t divisors = svindex_s64(3, 2); // Start from 3, increment by 2\n    svint64_t n_vec = svdup_s64(n);\n    svbool_t result = svnot_b_z(pg, svcmpeq_s64(pg, svmod_s64(pg, n_vec, divisors), 0));\n\n    return svptest_last(pg, result);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    svint64_t vec_i, vec_n, vec_result;\n    svbool_t pg = svwhilelt_b64(5, sqrt_n + 1);\n    uint64_t vector_length = svcntd();\n\n    for (int64_t i = 5; i <= sqrt_n; i += vector_length * 2) {\n        vec_i = svld1(pg, &i);\n        vec_i = svadd_x(pg, vec_i, svdup_s64(0));\n        vec_n = svdup_s64(n);\n        vec_result = svmod_s64_x(pg, vec_n, vec_i);\n        svbool_t zero_mask = svcmpeq(pg, vec_result, 0);\n        if (svptest_any(pg, zero_mask)) {\n            return false;\n        }\n\n        vec_i = svadd_x(pg, vec_i, svdup_s64(2));\n        vec_result = svmod_s64_x(pg, vec_n, vec_i);\n        zero_mask = svcmpeq(pg, vec_result, 0);\n        if (svptest_any(pg, zero_mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svint64_t vec_i = svindex_s64(3, 2);\n    svbool_t result = svptrue_b64();\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t div = svdiv_s64_z(pg, vec_n, vec_i);\n        svint64_t mul = svmul_s64_z(pg, div, vec_i);\n        svbool_t is_divisible = svcmpeq_s64(pg, mul, vec_n);\n        result = svand_b_z(svptrue_b64(), result, svnot_b_z(pg, is_divisible));\n        vec_i = svadd_s64_z(pg, vec_i, svdup_s64(svcntd() * 2));\n        pg = svwhilelt_b64(svlastb_s64(svptrue_b64(), vec_i), sqrt_n + 1);\n    }\n\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    uint64_t vl = svcntd(); // Get vector length for 64-bit elements\n    svbool_t pg = svwhilelt_b64(0, vl); // Predicate for active lanes\n\n    int64_t step = 6;\n    svint64_t vec_i = svindex_s64(5, step); // Start from 5, increment by 6\n    svint64_t vec_i_plus_2 = svadd_n_s64_x(pg, vec_i, 2); // i+2 for checking i and i+2\n    svint64_t vec_n = svdup_s64(n); // Broadcast n to all lanes\n\n    while (1) {\n        // Check if any i exceeds sqrt(n)\n        svbool_t cmp_i = svcmple_s64(pg, vec_i, sqrt_n);\n        if (!svptest_any(pg, cmp_i)) break;\n\n        // Check divisibility for i\n        svint64_t remainder_i = svmod_n_s64_x(pg, vec_n, vec_i);\n        svbool_t div_i = svcmpeq_s64(pg, remainder_i, 0);\n\n        // Check divisibility for i+2\n        svint64_t remainder_i2 = svmod_n_s64_x(pg, vec_n, vec_i_plus_2);\n        svbool_t div_i2 = svcmpeq_s64(pg, remainder_i2, 0);\n\n        // If any lane shows divisibility, return false\n        svbool_t div_any = svorr_b_z(pg, div_i, div_i2);\n        if (svptest_any(pg, div_any)) return false;\n\n        // Increment i by step * vector_length for next iteration\n        vec_i = svadd_n_s64_x(pg, vec_i, step * vl);\n        vec_i_plus_2 = svadd_n_s64_x(pg, vec_i, 2);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string solve_simd(const std::string &s) {\n    size_t len = s.length();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if there are any letters in the string\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    do {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('A' - 1));\n        svbool_t is_lower_bound = svcmpgt_u8(pg, vec, svdup_u8('a' - 1));\n        svbool_t is_upper_bound = svcmplt_u8(pg, vec, svdup_u8('Z' + 1));\n        svbool_t is_letter = svand_b_z(pg, svand_b_z(pg, is_lower, is_lower_bound), svand_b_z(pg, is_upper, is_upper_bound));\n        if (svptest_any(pg, is_letter)) {\n            has_letter = true;\n            break;\n        }\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    } while (svptest_any(svptrue_b8(), pg));\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        size_t left = 0;\n        size_t right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    } else {\n        // Process the string to reverse case of letters\n        i = 0;\n        pg = svwhilelt_b8(i, len);\n        do {\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n            svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n            svbool_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('A' - 1));\n            svbool_t is_lower_bound = svcmpgt_u8(pg, vec, svdup_u8('a' - 1));\n            svbool_t is_upper_bound = svcmplt_u8(pg, vec, svdup_u8('Z' + 1));\n            svbool_t is_lower_letter = svand_b_z(pg, is_lower, is_lower_bound);\n            svbool_t is_upper_letter = svand_b_z(pg, is_upper, is_upper_bound);\n            svuint8_t to_upper = svsub_u8_z(pg, vec, svdup_u8(32));\n            svuint8_t to_lower = svadd_u8_z(pg, vec, svdup_u8(32));\n            svuint8_t result_vec = svsel_u8(is_lower_letter, to_upper, vec);\n            result_vec = svsel_u8(is_upper_letter, to_lower, result_vec);\n            svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), result_vec);\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        } while (svptest_any(svptrue_b8(), pg));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    bool has_letter = false;\n    \n    // Check for letters\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('A'-1));\n        svbool_t is_letter = svand_b_z(pg, is_lower, is_upper);\n        has_letter |= svptest_any(svptrue_b8(), is_letter);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    if (!has_letter) {\n        // Reverse string if no letters\n        for (size_t j = 0; j < len/2; j++) {\n            std::swap(result[j], result[len-1-j]);\n        }\n        return result;\n    }\n    \n    // Process case conversion using SVE\n    i = 0;\n    pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        // Identify letters\n        svbool_t is_lower = svcmple_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpge_u8(pg, vec, svdup_u8('A'));\n        svbool_t is_letter = svand_b_z(pg, is_lower, is_upper);\n        \n        // Convert lower to upper (subtract 32)\n        svbool_t is_lower_letter = svand_b_z(pg, is_letter, \n            svcmple_u8(pg, vec, svdup_u8('z')));\n        svuint8_t lower_to_upper = svsub_u8_m(is_lower_letter, vec, svdup_u8(32));\n        \n        // Convert upper to lower (add 32)\n        svbool_t is_upper_letter = svand_b_z(pg, is_letter, \n            svcmpge_u8(pg, vec, svdup_u8('Z')));\n        svuint8_t upper_to_lower = svadd_u8_m(is_upper_letter, vec, svdup_u8(32));\n        \n        // Combine results, keeping non-letters unchanged\n        svuint8_t result_vec = svsel_u8(is_lower_letter, lower_to_upper, vec);\n        result_vec = svsel_u8(is_upper_letter, upper_to_lower, result_vec);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], result_vec);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letter = false;\n    \n    // Check for letters using SVE\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t input = svld1_u8(pg, (uint8_t*)s.data());\n    \n    svbool_t is_lower = svcmplt_u8(pg, input, svdup_u8('z'));\n    is_lower = svand_b_z(pg, is_lower, svcmpge_u8(pg, input, svdup_u8('a')));\n    \n    svbool_t is_upper = svcmplt_u8(pg, input, svdup_u8('Z'));\n    is_upper = svand_b_z(pg, is_upper, svcmpge_u8(pg, input, svdup_u8('A')));\n    \n    svbool_t is_letter = svorr_b_z(pg, is_lower, is_upper);\n    \n    // Count letters\n    uint64_t letter_count = svcntp_b8(pg, is_letter);\n    \n    if (letter_count > 0) {\n        // Process case conversion using SVE\n        svuint8_t to_upper = svsub_u8_z(pg, input, svdup_u8(32));\n        svuint8_t to_lower = svadd_u8_z(pg, input, svdup_u8(32));\n        \n        svuint8_t output = svsel_u8(is_lower, to_upper, \n                                  svsel_u8(is_upper, to_lower, input));\n        \n        svst1_u8(pg, (uint8_t*)result.data(), output);\n    } else {\n        // Reverse string if no letters\n        int i = 0, j = len - 1;\n        while (i < j) {\n            std::swap(result[i++], result[j--]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    bool has_letter = false;\n\n    // Check if string contains any letters\n    for (size_t i = 0; i < len; i++) {\n        if (std::isalpha(s[i])) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse string if no letters\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n        svuint8_t rev_indices = svrev_u8(svindex_u8(0, 1));\n        svuint8_t reversed = svtbl_u8(vec, rev_indices);\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data()), reversed);\n        return result;\n    }\n\n    // Process string with case reversal for letters\n    size_t i = 0;\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svand_b_z(pg, svcmplt_u8(pg, vec, 'z'), svcmpge_u8(pg, vec, 'a'));\n        svbool_t is_upper = svand_b_z(pg, svcmplt_u8(pg, vec, 'Z'), svcmpge_u8(pg, vec, 'A'));\n\n        // Convert lowercase to uppercase (subtract 32) and uppercase to lowercase (add 32)\n        svuint8_t vec_upper = svsub_u8_z(is_lower, vec, 32);\n        svuint8_t vec_lower = svadd_u8_z(is_upper, vec, 32);\n\n        // Combine results, keeping non-letters unchanged\n        svuint8_t result_vec = svsel_u8(is_lower, vec_upper, svsel_u8(is_upper, vec_lower, vec));\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), result_vec);\n\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string solve_simd(const std::string &s) {\n    size_t len = s.length();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if there is any letter in the string using SVE\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    do {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('A' - 1));\n        svbool_t is_lower_bound = svcmpgt_u8(pg, vec, svdup_u8('a' - 1));\n        svbool_t is_upper_bound = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        svbool_t is_letter = svand_b_z(pg, svand_b_z(pg, is_lower, is_lower_bound), svand_b_z(pg, is_upper, is_upper_bound));\n        if (svptest_any(pg, is_letter)) {\n            has_letter = true;\n            break;\n        }\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    } while (svptest_any(svptrue_b8(), pg));\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        size_t left = 0;\n        size_t right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    } else {\n        // Process the string to reverse case of letters using SVE\n        i = 0;\n        pg = svwhilelt_b8(i, len);\n        do {\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n            svbool_t is_lower = svand_b_z(pg, svcmpgt_u8(pg, vec, svdup_u8('a' - 1)), svcmplt_u8(pg, vec, svdup_u8('z')));\n            svbool_t is_upper = svand_b_z(pg, svcmpgt_u8(pg, vec, svdup_u8('A' - 1)), svcmplt_u8(pg, vec, svdup_u8('Z')));\n            svuint8_t to_upper = svsub_u8_z(is_lower, vec, svdup_u8(32));\n            svuint8_t to_lower = svadd_u8_z(is_upper, vec, svdup_u8(32));\n            svuint8_t modified = svsel_u8(is_lower, to_upper, svsel_u8(is_upper, to_lower, vec));\n            svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), modified);\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        } while (svptest_any(svptrue_b8(), pg));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> third_elements;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n    \n    // Put sorted elements back at indices divisible by 3\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len && third_idx < third_elements.size()) {\n            result[i] = third_elements[third_idx++];\n        }\n    }\n    \n    // Use SVE for copying non-third elements in parallel where possible\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements per vector\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    size_t i = 0;\n    while (i < len) {\n        if (i % 3 != 0 && i + vec_len <= len) {\n            svint32_t vec = svld1(pg, &l[i]);\n            svst1(pg, &result[i], vec);\n            i += vec_len;\n        } else {\n            i++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> third_elements;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) {\n            third_elements.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n    \n    // Put sorted elements back into positions divisible by 3\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len && third_idx < third_elements.size()) {\n            result[i] = third_elements[third_idx++];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n    std::vector<int> third_elements;\n    std::vector<size_t> third_indices;\n\n    // Collect elements and indices where index % 3 == 0\n    for (size_t i = 0; i < n; i += 3) {\n        if (i < n) {\n            third_elements.push_back(l[i]);\n            third_indices.push_back(i);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Put sorted elements back into result at corresponding indices\n    for (size_t i = 0; i < third_elements.size(); ++i) {\n        result[third_indices[i]] = third_elements[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    std::vector<size_t> third_indices;\n\n    // Collect elements and indices where index % 3 == 0\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) {\n            thirds.push_back(l[i]);\n            third_indices.push_back(i);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n\n    // Put sorted elements back into result at third indices\n    for (size_t i = 0; i < thirds.size(); ++i) {\n        result[third_indices[i]] = thirds[i];\n    }\n\n    // SVE processing for copying non-third elements\n    size_t vl = svcntw(); // Vector length in 32-bit elements\n    for (size_t i = 0; i < len; i += vl) {\n        // Create predicate for valid elements\n        svbool_t pg = svwhilelt_b32(i, len);\n        \n        // Create predicate for elements not divisible by 3\n        svbool_t not_third = svptrue_b32();\n        for (size_t j = i; j < std::min(i + vl, len); ++j) {\n            if (j % 3 == 0) {\n                not_third = svbic_b_z(svptrue_b32(), not_third, svptrue_pat_b32(SV_VL1, j - i));\n            }\n        }\n\n        // Load input vector\n        svint32_t vec = svld1(pg, &l[i]);\n        \n        // Store to result only for non-third indices\n        svst1(pg, &result[i], svsel(not_third, vec, svld1(pg, &result[i])));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n\n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) {\n            thirds.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n\n    // Put sorted elements back into positions divisible by 3\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) {\n            result[i] = thirds[third_idx++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    for (; i < len; i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    for (; i < len; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    for (; i < len; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_n_f32(l[0]);\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    size_t i = 0;\n\n    while (i < l.size()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, l.size());\n    }\n\n    float max_val = l[0];\n    float buffer[svcntw()];\n    svst1_f32(pg, buffer, max_vec);\n    for (size_t j = 0; j < svcntw() && i - svcntw() + j < l.size(); j++) {\n        if (buffer[j] > max_val) {\n            max_val = buffer[j];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(-std::numeric_limits<float>::infinity());\n    svbool_t pg = svptrue_b32();\n    size_t n = l.size();\n    size_t i = 0;\n    const float* data = l.data();\n\n    // Process vectorized chunks\n    while (i < n) {\n        svfloat32_t vec = svld1_f32(pg, data + i);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n        i += svcntw();\n        if (i >= n) break;\n    }\n\n    // Reduce the vector to a single maximum value\n    float max_val = svmaxv_f32(pg, max_vec);\n\n    // Handle remaining elements if any\n    for (; i < n; ++i) {\n        if (data[i] > max_val) {\n            max_val = data[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    svbool_t pg = svptrue_b32();\n    int32_t step = svcntw();\n\n    while (i < n) {\n        // Create a vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t valid = svwhilelt_b32_s32(i, n);\n        svbool_t active = svand_b_z(pg, pg, valid);\n\n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(active, indices, 11);\n        svint32_t mul11 = svmul_n_s32_z(active, div11, 11);\n        svbool_t is_div_11 = svcmpeq_s32(active, indices, mul11);\n\n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(active, indices, 13);\n        svint32_t mul13 = svmul_n_s32_z(active, div13, 13);\n        svbool_t is_div_13 = svcmpeq_s32(active, indices, mul13);\n\n        // Combine conditions (divisible by 11 or 13)\n        svbool_t condition = svorr_b_z(pg, is_div_11, is_div_13);\n\n        // Process numbers divisible by 11 or 13\n        if (svptest_any(pg, condition)) {\n            int32_t vec_size = svcntw();\n            int32_t temp_indices[vec_size];\n            svst1_s32(active, temp_indices, indices);\n\n            for (int j = 0; j < vec_size && i + j < n; j++) {\n                int num = temp_indices[j];\n                if ((num % 11 == 0 || num % 13 == 0) && num < n) {\n                    while (num > 0) {\n                        if (num % 10 == 7) {\n                            count++;\n                        }\n                        num /= 10;\n                    }\n                }\n            }\n        }\n\n        i += step;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in vectorized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Create predicate for valid indices < n\n        pg = svwhilelt_b32(i, n);\n        \n        // Check divisibility by 11\n        svuint32_t div11 = svdiv_n_u32_z(pg, indices, 11);\n        svbool_t is_div11 = svcmpeq_n_u32(pg, svmul_n_u32_z(pg, div11, 11), indices);\n        \n        // Check divisibility by 13\n        svuint32_t div13 = svdiv_n_u32_z(pg, indices, 13);\n        svbool_t is_div13 = svcmpeq_n_u32(pg, svmul_n_u32_z(pg, div13, 13), indices);\n        \n        // Combine divisibility conditions\n        svbool_t div_mask = svorr_b_z(pg, is_div11, is_div13);\n        \n        // Count digits of 7 in numbers divisible by 11 or 13\n        while (svptest_any(pg, div_mask)) {\n            uint32_t num = svsel_u32(svpfirst(div_mask, pg), indices);\n            div_mask = svnot_b_z(div_mask, div_mask);\n            \n            // Count 7s in the number\n            while (num > 0) {\n                if (num % 10 == 7) count++;\n                num /= 10;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in vector-sized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svint32_t div_11 = svdiv_n_s32_z(pg, indices, 11);\n        svbool_t div_11_mask = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div_11, 11), indices);\n        \n        // Check divisibility by 13\n        svint32_t div_13 = svdiv_n_s32_z(pg, indices, 13);\n        svbool_t div_13_mask = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div_13, 13), indices);\n        \n        // Combine divisibility masks\n        svbool_t div_mask = svorr_b_z(pg, div_11_mask, div_13_mask);\n        \n        // Count digit 7 in valid numbers\n        while (svptest_any(pg, div_mask)) {\n            int scalar_idx = i + svclz_x(svptrue_b32(), div_mask);\n            if (scalar_idx >= n) break;\n            \n            int num = scalar_idx;\n            while (num > 0) {\n                if (num % 10 == 7) count++;\n                num /= 10;\n            }\n            \n            // Clear the processed index\n            svbool_t single = svwhilelt_b32(scalar_idx - i, scalar_idx - i + 1);\n            div_mask = svbic_b_z(svptrue_b32(), div_mask, single);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in chunks based on vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(pg, indices, 11);\n        svbool_t mod11_zero = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div11, 11), indices);\n        \n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(pg, indices, 13);\n        svbool_t mod13_zero = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div13, 13), indices);\n        \n        // Combine divisibility conditions\n        svbool_t divisible = svorr_b_z(pg, mod11_zero, mod13_zero);\n        \n        // Count digits of 7 in numbers that are divisible\n        svint32_t num = indices;\n        svbool_t active = divisible;\n        \n        while (svptest_any(pg, active)) {\n            // Get last digit\n            svint32_t digit = svmod_n_s32_z(pg, num, 10);\n            // Count 7s\n            svbool_t is_seven = svcmpeq_n_s32(pg, digit, 7);\n            count += svcntp_b32(pg, svand_b_z(pg, active, is_seven));\n            \n            // Remove last digit\n            num = svdiv_n_s32_z(pg, num, 10);\n            // Update active lanes (stop when number becomes 0)\n            active = svand_b_z(pg, active, svcmpne_n_s32(pg, num, 0));\n        }\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    svbool_t pg = svptrue_b32();\n    const int vector_len = svcntw();\n\n    while (i < n) {\n        // Create a vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t active = svwhilelt_b32_s32(i, n);\n        active = svand_b_z(pg, active, pg);\n\n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(active, indices, 11);\n        svint32_t mul11 = svmul_n_s32_z(active, div11, 11);\n        svbool_t is_div11 = svcmpeq_s32(active, indices, mul11);\n\n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(active, indices, 13);\n        svint32_t mul13 = svmul_n_s32_z(active, div13, 13);\n        svbool_t is_div13 = svcmpeq_s32(active, indices, mul13);\n\n        // Combine conditions (divisible by 11 or 13)\n        svbool_t condition = svorr_b_z(pg, is_div11, is_div13);\n\n        // Process numbers divisible by 11 or 13\n        if (svptest_any(pg, condition)) {\n            int32_t buffer[vector_len];\n            svst1_s32(active, buffer, indices);\n\n            for (int j = 0; j < vector_len && i + j < n; j++) {\n                if (buffer[j] % 11 == 0 || buffer[j] % 13 == 0) {\n                    int num = buffer[j];\n                    while (num > 0) {\n                        if (num % 10 == 7) {\n                            count++;\n                        }\n                        num /= 10;\n                    }\n                }\n            }\n        }\n\n        i += vector_len;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // If length is less than 2, no even indices to sort\n    if (len < 2) {\n        return result;\n    }\n    \n    // Determine vector length for SVE\n    uint64_t vec_len = svcntw();\n    size_t even_count = (len + 1) / 2; // Number of even indices\n    \n    // Allocate temporary vectors for even indices\n    std::vector<float> even_vals(even_count);\n    for (size_t i = 0, j = 0; i < len; i += 2, j++) {\n        even_vals[j] = l[i];\n    }\n    \n    // Sort even values (sequential for simplicity, as SVE sorting is complex)\n    std::sort(even_vals.begin(), even_vals.end());\n    \n    // Put sorted even values back into result vector using SVE\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    for (; i + vec_len <= even_count; i += vec_len) {\n        svfloat32_t vec = svld1_f32(pg, &even_vals[i]);\n        svst1_f32(pg, &result[i * 2], vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < even_count; i++) {\n        result[i * 2] = even_vals[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n    if (n < 2) return result;\n\n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    size_t num_vectors = (n + vl - 1) / vl;\n\n    // Process even indices in chunks based on vector length\n    for (size_t i = 0; i < n; i += vl * 2) {\n        size_t remaining = std::min(vl * 2, n - i);\n        size_t half_vl = remaining / 2;\n\n        if (remaining < 2) break;\n\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32((uint32_t)0, (uint32_t)half_vl);\n\n        // Load even indices into a vector\n        float32_t data[vl];\n        for (size_t j = 0; j < half_vl; j++) {\n            if (i + j * 2 < n) {\n                data[j] = l[i + j * 2];\n            } else {\n                data[j] = 0.0f;\n            }\n        }\n        svfloat32_t vec_even = svld1(pg, data);\n\n        // Sort the vector (SVE does not have direct sort, emulate with pairwise comparisons)\n        // This is a placeholder for a sorting network or other parallel sort approach\n        // For simplicity, we use a basic approach (not fully optimal)\n        svfloat32_t sorted_vec = vec_even;\n\n        // Store sorted values back to even indices\n        svst1(pg, &result[i], sorted_vec);\n        for (size_t j = 0; j < half_vl; j++) {\n            if (i + j * 2 < n) {\n                result[i + j * 2] = data[j];\n            }\n        }\n    }\n\n    // Handle any remaining elements or final sorting if needed\n    // Extract even indices to a temporary vector for sorting\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < n; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    std::sort(even_vals.begin(), even_vals.end());\n\n    // Put sorted values back into even indices\n    for (size_t i = 0, j = 0; i < n; i += 2, j++) {\n        if (j < even_vals.size()) {\n            result[i] = even_vals[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n    \n    // Ensure the vector size is even for simplicity, pad if necessary\n    if (n % 2 != 0) {\n        n++;\n        l.push_back(0.0f);\n        result.push_back(0.0f);\n    }\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    size_t num_vectors = (n + vl - 1) / vl;\n\n    // Process even indices\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort even values (sequential for simplicity, as SVE sorting is complex)\n    std::sort(even_values.begin(), even_values.end());\n\n    // Put sorted even values back into result at even indices\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        result[i] = even_values[even_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // Handle empty or single-element vectors\n    if (len <= 1) return result;\n    \n    // Get vector length in elements\n    int64_t vec_len = svcntw();\n    \n    // Create predicate for even indices\n    svbool_t pg = svptrue_b32();\n    svbool_t even_mask = svzip1_b32(svpfalse(), svptrue_b32());\n    \n    // Extract even indices\n    std::vector<float> even_values((len + 1)/2);\n    size_t even_idx = 0;\n    \n    for (size_t i = 0; i < len; i += vec_len) {\n        // Load vector\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Select even indices\n        svfloat32_t even_vec = svsel_f32(even_mask, vec, svdup_f32(0.0f));\n        \n        // Store even values\n        svst1_f32(pg, &even_values[even_idx], even_vec);\n        \n        even_idx += svcntw() / 2;\n    }\n    \n    // Sort even values\n    std::sort(even_values.begin(), even_values.begin() + (len + 1)/2);\n    \n    // Put sorted even values back\n    even_idx = 0;\n    for (size_t i = 0; i < len; i += vec_len) {\n        // Load original vector\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Load sorted even values\n        svfloat32_t sorted_even = svld1_f32(pg, &even_values[even_idx]);\n        \n        // Merge sorted even values with original odd values\n        svfloat32_t result_vec = svsel_f32(even_mask, sorted_even, vec);\n        \n        // Store result\n        svst1_f32(pg, &result[i], result_vec);\n        \n        even_idx += svcntw() / 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    if (len < 2) return result;\n\n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    size_t step = vl;\n\n    // Process even indices in chunks based on vector length\n    for (size_t i = 0; i < len; i += step * 2) {\n        size_t remaining = std::min(step * 2, len - i);\n        if (remaining < 2) break;\n\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32(i, i + remaining);\n\n        // Load data into SVE vectors for even and odd positions\n        svfloat32_t vec_even = svundef_f32();\n        svfloat32_t vec_odd = svundef_f32();\n        if (i + step <= len) {\n            vec_even = svld1_f32(pg, &l[i]);\n        }\n        if (i + step < len) {\n            svbool_t pg_odd = svwhilelt_b32(i + step, i + step + std::min(step, len - i - step));\n            vec_odd = svld1_f32(pg_odd, &l[i + step]);\n        }\n\n        // Sort even indices (bubble sort or similar within vector)\n        // Note: SVE does not have a direct sort intrinsic, so we simulate pairwise comparison\n        for (size_t j = 0; j < step - 1; j++) {\n            svfloat32_t next_even = svundef_f32();\n            if (i + j + 1 < len) {\n                svbool_t pg_next = svwhilelt_b32(i + j + 1, i + remaining);\n                next_even = svld1_f32(pg_next, &l[i + j + 1]);\n                svbool_t cmp = svcmplt_f32(pg, vec_even, next_even);\n                svfloat32_t min_val = svsel_f32(cmp, vec_even, next_even);\n                svfloat32_t max_val = svsel_f32(cmp, next_even, vec_even);\n                vec_even = min_val;\n                svst1_f32(pg_next, &l[i + j + 1], max_val);\n            }\n        }\n\n        // Store back the sorted even indices\n        svst1_f32(pg, &result[i], vec_even);\n        if (i + step < len) {\n            svbool_t pg_odd = svwhilelt_b32(i + step, i + step + std::min(step, len - i - step));\n            svst1_f32(pg_odd, &result[i + step], vec_odd);\n        }\n    }\n\n    // Handle remaining elements if len is not a multiple of step*2\n    for (size_t i = step * 2 * (len / (step * 2)); i < len; i += 2) {\n        if (i + 1 < len) {\n            if (result[i] > result[i + 2]) {\n                std::swap(result[i], result[i + 2]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get vector length\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t vlen = svcntw();\n\n    // Process outer loop sequentially\n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = l[i];\n        \n        // Process middle loop sequentially\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int b = l[j];\n            int target = -(a + b);\n            \n            // Use SVE for inner loop\n            size_t k = j + 1;\n            while (k < n) {\n                // Load vector of elements\n                svbool_t pk = svwhilelt_b32(k, n);\n                svint32_t vec = svld1_s32(pk, &l[k]);\n                \n                // Compare with target\n                svbool_t eq = svcmpeq_s32(pk, vec, target);\n                \n                // If any match found\n                if (svptest_any(pg, eq)) {\n                    return true;\n                }\n                \n                k += vlen;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get vector length\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t vlen = svcntw();\n\n    // Iterate over i\n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = l[i];\n        // Iterate over j\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int b = l[j];\n            int target = -(a + b);\n\n            // Create SVE vector for target\n            svint32_t target_vec = svdup_s32(target);\n            size_t k = j + 1;\n\n            // Process k in vectorized chunks\n            while (k < n) {\n                // Load elements into SVE vector\n                svbool_t pk = svwhilelt_b32(k, n);\n                svint32_t vec = svld1_s32(pk, &l[k]);\n\n                // Compare with target\n                svbool_t match = svcmpeq_s32(pk, vec, target_vec);\n\n                // Check if any match found\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n\n                k += vlen;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Iterate over possible triplets using SVE for parallelism where possible\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int sum_ij = l[i] + l[j];\n            svint32_t sum_vec = svdup_s32(-sum_ij);\n            size_t k_start = j + 1;\n            size_t k_end = n;\n\n            // Process k in vectorized chunks\n            for (size_t k = k_start; k < k_end; k += vl) {\n                svbool_t pred = svwhilelt_b32(k, k_end);\n                svint32_t vec_k = svld1_s32(pred, &l[k]);\n                svbool_t match = sveq_s32(pred, vec_k, sum_vec);\n                if (svptest_any(pred, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Iterate over all possible triplets using a combination of scalar and vectorized approaches\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            // Use SVE to search for the target in the remaining elements\n            size_t k_start = j + 1;\n            size_t remaining = n - k_start;\n            size_t vec_end = k_start + (remaining / vl) * vl;\n\n            for (size_t k = k_start; k < vec_end; k += vl) {\n                svint32_t vec = svld1(pg, &l[k]);\n                svint32_t target_vec = svdup_n_s32(target);\n                svbool_t match = sveq_s32(pg, vec, target_vec);\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n            }\n\n            // Handle remaining elements scalarly\n            for (size_t k = vec_end; k < n; ++k) {\n                if (l[k] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Iterate over all possible triplets (i, j, k) with i < j < k\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k_start = j + 1;\n\n            // Process k in vectorized chunks\n            while (k_start < n) {\n                size_t remaining = n - k_start;\n                svbool_t p = svwhilelt_b32(0, remaining);\n                svint32_t vec_k = svld1_s32(p, &l[k_start]);\n                svint32_t target_vec = svdup_s32(target);\n                svbool_t match = svcmpeq_s32(p, vec_k, target_vec);\n\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n\n                k_start += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        // Increment each element by 1\n        svint32_t incremented = svadd_n_s32_z(pg, vec, 1);\n        // Store the result back to the output vector\n        svst1_s32(pg, &result[i], incremented);\n    }\n    \n    // Handle remaining elements (if any) that don't fit into a full vector\n    for (; i < len; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load vector from input\n        svint32_t vec = svld1(pg, &l[i]);\n        // Increment by 1\n        svint32_t inc_vec = svadd_x(pg, vec, 1);\n        // Store result\n        svst1(pg, &result[i], inc_vec);\n    }\n    \n    // Handle remaining elements\n    if (i < len) {\n        svbool_t pg_rem = svwhilelt_b32(i, len);\n        svint32_t vec = svld1(pg_rem, &l[i]);\n        svint32_t inc_vec = svadd_x(pg_rem, vec, 1);\n        svst1(pg_rem, &result[i], inc_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= l.size(); i += svcntw()) {\n        svint32_t vec = svld1(pg, &l[i]);\n        vec = svadd_n_s32_x(pg, vec, 1);\n        svst1(pg, &result[i], vec);\n    }\n\n    // Handle remaining elements\n    if (i < l.size()) {\n        svbool_t remain_pg = svwhilelt_b32(i, l.size());\n        svint32_t vec = svld1(remain_pg, &l[i]);\n        vec = svadd_n_s32_x(remain_pg, vec, 1);\n        svst1(remain_pg, &result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements in a vector\n    svint32_t vec_one = svdup_n_s32(1); // Create a vector of 1s\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1_s32(svptrue_b32(), &l[i]);\n        // Add 1 to each element\n        svint32_t vec_incr = svadd_s32_z(svptrue_b32(), vec, vec_one);\n        // Store the result back to the output vector\n        svst1_s32(svptrue_b32(), &result[i], vec_incr);\n    }\n\n    // Handle remaining elements (if any) scalar-wise\n    for (; i < len; i++) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    while (i < l.size()) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svint32_t inc_vec = svadd_n_s32_x(pg, vec, 1);\n        svst1_s32(pg, &result[i], inc_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process the vector in chunks based on SVE vector length\n    for (size_t i = 0; i < n; i++) {\n        int target = -l[i];\n        size_t j_start = i + 1;\n\n        // Process remaining elements in vectorized chunks\n        for (size_t j = j_start; j < n; j += vl) {\n            svbool_t active = svwhilelt_b32(j, n);\n            svint32_t vec = svld1_s32(active, &l[j]);\n            svbool_t match = sveq_s32(active, vec, target);\n            if (svptest_any(active, match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    \n    for (size_t i = 0; i < n; i += vec_len) {\n        // Load vector of values from array\n        svint32_t vec_i = svld1_s32(pg, &l[i]);\n        \n        for (size_t j = i + 1; j < n; j += vec_len) {\n            // Load second vector\n            svint32_t vec_j = svld1_s32(pg, &l[j]);\n            \n            // Compute sum of pairs\n            svint32_t sum = svadd_z(pg, vec_i, vec_j);\n            \n            // Check if any sum equals zero\n            svbool_t eq_zero = svcmpeq(pg, sum, 0);\n            \n            // If any sum is zero, check if elements are distinct\n            if (svptest_any(pg, eq_zero)) {\n                // Extract active lanes\n                int32_t sums[vec_len];\n                svst1_s32(pg, sums, sum);\n                \n                // Check each active lane\n                for (size_t k = 0; k < vec_len && (i + k) < n && (j + k) < n; k++) {\n                    if (sums[k] == 0 && l[i + k] != l[j + k]) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t zero = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i++) {\n        svint32_t vi = svdup_s32(l[i]);\n        size_t j = 0;\n\n        while (j < n) {\n            svbool_t pg_loop = svwhilelt_b32(j, n);\n            svint32_t vj = svld1_s32(pg_loop, &l[j]);\n            \n            // Compute sum of l[i] + l[j]\n            svint32_t sum = svadd_z(pg_loop, vi, vj);\n            \n            // Check if sum is zero and i != j\n            svbool_t eq_zero = svcmpeq(pg_loop, sum, zero);\n            svbool_t neq_idx = svcmpne(pg_loop, svindex_s32(j, 1), svdup_s32(i));\n            svbool_t match = svand_b_z(pg_loop, eq_zero, neq_idx);\n            \n            if (svptest_any(pg_loop, match)) {\n                return true;\n            }\n            \n            j += svcntw();\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process elements in chunks based on vector length\n    for (size_t i = 0; i < n; i++) {\n        int target = -l[i];\n        size_t j_start = i + 1;\n        size_t j_end = n;\n\n        for (size_t j = j_start; j < j_end; j += vl) {\n            // Calculate remaining elements\n            uint64_t remaining = j_end - j;\n            pg = svwhilelt_b32(0, remaining);\n\n            // Load elements into a vector\n            svint32_t vec = svld1(pg, &l[j]);\n\n            // Create a vector with the target value\n            svint32_t target_vec = svdup_s32(target);\n\n            // Compare the vector with the target\n            svbool_t eq_mask = svcmpeq(pg, vec, target_vec);\n\n            // Check if any element matches the target\n            if (svptest_any(pg, eq_mask)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t len = l.size();\n    if (len < 2) return false;\n\n    // Get vector length in elements\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vec_len = svcntw();\n\n    // Process array in vector-sized chunks\n    for (size_t i = 0; i < len; i += vec_len) {\n        // Load first vector\n        svbool_t pg_i = svwhilelt_b32(i, len);\n        svint32_t vec_i = svld1(pg_i, &l[i]);\n\n        // Compare with all subsequent elements\n        for (size_t j = i + 1; j < len; j += vec_len) {\n            svbool_t pg_j = svwhilelt_b32(j, len);\n            svint32_t vec_j = svld1(pg_j, &l[j]);\n\n            // Compute sum of vec_i with vec_j\n            svint32_t sum = svadd_z(pg_i, vec_i, vec_j);\n\n            // Check if any sum equals zero\n            svbool_t zero_mask = svcmpeq(pg_i, sum, 0);\n            if (svptest_any(pg_i, zero_mask)) {\n                // Verify distinct elements\n                svbool_t neq_mask = svcmpne(pg_i, vec_i, vec_j);\n                if (svptest_any(pg_i, svand_z(pg_i, zero_mask, neq_mask))) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Handle scalar remainder\n    for (size_t i = 0; i < len; i++) {\n        for (size_t j = i + 1; j < len; j++) {\n            if (l[i] + l[j] == 0 && l[i] != l[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Handle negative numbers\n    bool is_negative = x < 0;\n    if (is_negative) {\n        x = -x;\n    }\n\n    // Determine the maximum number of digits needed\n    const int max_digits = 64; // Enough for int64_t in base 2\n    int8_t digits[max_digits];\n    int digit_count = 0;\n\n    // Convert to the target base\n    while (x > 0 && digit_count < max_digits) {\n        digits[digit_count++] = x % base;\n        x /= base;\n    }\n\n    // Use SVE to convert digits to characters in parallel\n    char output[max_digits];\n    svbool_t pg = svwhilelt_b8(digit_count, max_digits);\n    svint8_t digit_vec = svld1_s8(pg, digits);\n    svint8_t char_vec = svadd_n_s8_x(pg, digit_vec, '0');\n    svst1_s8(pg, output, char_vec);\n\n    // Build the result string in reverse order\n    if (is_negative) {\n        result += '-';\n    }\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += output[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    if (x == 0) return \"0\";\n    if (x < 0) {\n        result = \"-\";\n        x = -x;\n    }\n\n    // Buffer to store digits in reverse order\n    char digits[64];\n    int digit_count = 0;\n\n    // Vectorized division and remainder calculation\n    while (x > 0) {\n        // Load the input number into a vector (replicated across lanes)\n        svint64_t vec_x = svdup_s64(x);\n        svint64_t vec_base = svdup_s64(base);\n        \n        // Compute quotient and remainder using SVE\n        svint64_t quotient = svdiv_s64_z(svptrue_b64(), vec_x, vec_base);\n        svint64_t remainder = svsub_s64_z(svptrue_b64(), vec_x, svmul_s64_z(svptrue_b64(), quotient, vec_base));\n        \n        // Extract the remainder (same across all lanes since input is scalar)\n        int64_t rem = svlasta_s64(svptrue_b64(), remainder);\n        digits[digit_count++] = '0' + rem;\n        \n        // Update x with quotient\n        x = svlasta_s64(svptrue_b64(), quotient);\n    }\n\n    // Build the result string in reverse order\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Handle negative numbers\n    bool is_negative = x < 0;\n    if (is_negative) {\n        x = -x;\n    }\n\n    // Buffer to store digits (assuming max 64-bit number conversion)\n    char digits[64];\n    int digit_count = 0;\n\n    // Vectorized division and remainder calculation\n    while (x > 0) {\n        // Load base into a vector for parallel processing\n        svint64_t vec_base = svdup_s64(base);\n        svint64_t vec_x = svdup_s64(x);\n        \n        // Compute remainder and quotient\n        svint64_t vec_remainder = svmod_s64_z(svptrue_b64(), vec_x, vec_base);\n        x = x / base;\n        \n        // Extract remainder (since it's a single value, we take the first lane)\n        int64_t remainder = svlasta_s64(svptrue_b64(), vec_remainder);\n        \n        // Convert remainder to character and store\n        digits[digit_count++] = '0' + remainder;\n    }\n\n    // Build the result string in reverse order\n    if (is_negative) {\n        result.push_back('-');\n    }\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result.push_back(digits[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Handle edge case: x = 0\n    if (x == 0) return \"0\";\n    \n    // Handle negative numbers\n    bool is_negative = x < 0;\n    if (is_negative) x = -x;\n    \n    // Maximum digits needed (log_base(x) + 1)\n    int max_digits = 64; // Sufficient for int64_t\n    int64_t digits[64] = {0};\n    int digit_count = 0;\n    \n    // SVE vector length\n    svbool_t pg = svwhilelt_b64(0, max_digits);\n    \n    // Initialize input vector with x\n    svint64_t vec_x = svdup_s64(x);\n    svint64_t vec_base = svdup_s64(base);\n    svint64_t vec_zero = svdup_s64(0);\n    \n    // Process digits in parallel\n    while (svptest_any(svptrue_b64(), svcmpgt_n_s64(pg, vec_x, 0))) {\n        // Compute remainder (x % base)\n        svint64_t vec_rem = svmod_n_s64(pg, vec_x, vec_base);\n        \n        // Store remainder in digits array\n        if (digit_count < max_digits) {\n            digits[digit_count] = svlasta_s64(svptrue_b64(), vec_rem);\n        }\n        \n        // Update x (x / base)\n        vec_x = svdiv_n_s64(pg, vec_x, vec_base);\n        digit_count++;\n    }\n    \n    // Convert digits to string (in reverse order)\n    std::string result;\n    if (is_negative) result += \"-\";\n    \n    for (int i = digit_count - 1; i >= 0; i--) {\n        result += static_cast<char>('0' + digits[i]);\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    if (x == 0) {\n        return \"0\";\n    }\n\n    // Handle negative numbers\n    bool is_negative = x < 0;\n    if (is_negative) {\n        x = -x;\n    }\n\n    // Buffer to store digits (assuming max 64-bit number conversion)\n    char digits[64];\n    int digit_count = 0;\n\n    // Vectorized division and remainder calculation\n    while (x > 0) {\n        // Use SVE to perform division and remainder in a vectorized way\n        // Load the input number into a vector (replicated)\n        svint64_t vec_x = svdup_s64(x);\n        svint64_t vec_base = svdup_s64(base);\n        \n        // Compute remainder and quotient\n        svint64_t vec_remainder = svmod_s64_z(svptrue_b64(), vec_x, vec_base);\n        x = x / base; // Update scalar x for next iteration\n        \n        // Extract remainder from vector (first element since it's replicated)\n        int64_t remainder = svlasta_s64(svptrue_b64(), vec_remainder);\n        \n        // Convert remainder to character and store\n        digits[digit_count++] = '0' + remainder;\n    }\n\n    // Build the result string in reverse order\n    if (is_negative) {\n        result.push_back('-');\n    }\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result.push_back(digits[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char *str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n\n    for (size_t i = 0; i < len / 2; i += vlen) {\n        // Load characters from start\n        svuint8_t vec_left = svld1_u8(pg, &str[i]);\n        // Load characters from end (reversed)\n        svuint8_t vec_right = svld1_u8(pg, &str[len - i - vlen]);\n        vec_right = svrev_u8(vec_right);\n\n        // Compare vectors\n        svbool_t cmp = svcmpeq_u8(pg, vec_left, vec_right);\n        if (!svptest_all(cmp)) return false;\n\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i + vlen, len - i - vlen);\n    }\n\n    // Handle remaining characters in the middle (if any)\n    size_t mid = len / 2;\n    for (size_t i = std::max((len / vlen) * vlen, len / 2); i < mid; ++i) {\n        if (str[i] != str[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Process characters from start and end in parallel\n    size_t half_len = (len + 1) / 2;\n    svuint8_t vec_left, vec_right;\n    svbool_t result = svptrue_b8();\n    \n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        // Load characters from start\n        size_t left_idx = i;\n        vec_left = svld1_u8(pg, &str[left_idx]);\n        \n        // Load characters from end (in reverse)\n        size_t right_idx = len - i - svcntb();\n        if (right_idx >= len) right_idx = 0;\n        vec_right = svld1_u8(pg, &str[right_idx]);\n        \n        // Compare characters\n        svbool_t cmp = svcmpeq_u8(pg, vec_left, vec_right);\n        result = svand_b_z(svptrue_b8(), result, cmp);\n        \n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Check if all comparisons were true\n    return svptest_any(svptrue_b8(), result);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    size_t len = text.length();\n    const char* str = text.c_str();\n    \n    // Calculate number of vectors needed\n    size_t vec_len = svcntb();\n    size_t num_vectors = (len + vec_len - 1) / vec_len;\n    \n    // Process string in vector chunks\n    for (size_t i = 0; i < (len + 1) / 2; i += vec_len) {\n        // Create predicate for valid elements\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load left side\n        svuint8_t left = svld1_u8(pg, (uint8_t*)(str + i));\n        \n        // Calculate right side index\n        size_t right_idx = len - i - vec_len;\n        svbool_t pg_right = svwhilelt_b8(right_idx, len);\n        \n        // Load right side and reverse\n        svuint8_t right = svld1_u8(pg_right, (uint8_t*)(str + right_idx));\n        right = svrev_u8(right);\n        \n        // Compare vectors\n        svbool_t eq = svcmpeq_u8(pg, left, right);\n        \n        // If any mismatch found, return false\n        if (!svptest_all(pg, eq)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len/2);\n    size_t half = len/2;\n    \n    // Load first half and second half reversed\n    svuint8_t vec_front = svld1(pg, str);\n    svuint8_t vec_back = svld1(pg, str + len - half);\n    svuint8_t vec_back_rev = svrev_u8(vec_back);\n    \n    // Compare vectors\n    svbool_t cmp = svcmpeq(pg, vec_front, vec_back_rev);\n    \n    // Check if all comparisons are true\n    return svptest_any(svptrue_b8(), cmp);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len/2);\n    \n    svuint8_t vec_left, vec_right;\n    size_t i = 0;\n    size_t j = len - 1;\n    \n    while (i < len/2) {\n        vec_left = svld1_u8(pg, &str[i]);\n        vec_right = svld1_u8(pg, &str[j]);\n        \n        svuint8_t reversed_right = svrev_u8(vec_right);\n        svbool_t cmp = svcmpeq_u8(pg, vec_left, reversed_right);\n        \n        if (!svptest_all_true(pg, cmp)) {\n            return false;\n        }\n        \n        i += svcntb();\n        j -= svcntb();\n        pg = svwhilelt_b8(i, len/2);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t len = s.length();\n    size_t vec_len = svcntb(); // Number of bytes in a vector\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        // Load input string characters into a vector\n        svuint8_t vec_in = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Decode by subtracting 5 and handling wrap-around with modulo 26\n        svuint8_t vec_shifted = svsub_n_u8_x(pg, vec_in, 5);\n        svuint8_t vec_a = svdup_n_u8('a');\n        svuint8_t vec_rel = svsub_u8_x(pg, vec_shifted, vec_a);\n        svuint8_t vec_mod = svand_n_u8_x(pg, vec_rel, 0x1F); // Modulo 26 approximation\n        svuint8_t vec_out = svadd_u8_x(pg, vec_mod, vec_a);\n\n        // Store the result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&out[i]), vec_out);\n\n        i += vec_len;\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char* in = s.c_str();\n    char* out_ptr = &out[0];\n    size_t len = s.length();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(in + i));\n        svuint8_t shifted = svsub_u8_x(pg, vec, svdup_u8(5));\n        svuint8_t mod = svsub_u8_x(pg, shifted, svdup_u8('a'));\n        mod = svmod_u8_x(pg, mod, svdup_u8(26));\n        svuint8_t result = svadd_u8_x(pg, mod, svdup_u8('a'));\n        svst1_u8(pg, (uint8_t*)(out_ptr + i), result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t len = s.length();\n    size_t vec_len = svcntb(); // Number of bytes in a vector\n    svbool_t pg = svptrue_b8(); // Predicate for full vector\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load a vector of characters from input string\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Decode by subtracting 5 and handling wrap-around modulo 26\n        svuint8_t shifted = svsub_n_u8_x(pg, vec, 5);\n        svuint8_t base_a = svdup_n_u8('a');\n        svuint8_t base_z = svdup_n_u8('z');\n        svbool_t under_a = svcmplt_u8(pg, shifted, base_a);\n        svuint8_t wrap_add = svdup_n_u8(26);\n        shifted = svsel_u8(under_a, svadd_n_u8_x(pg, shifted, 26), shifted);\n\n        // Store the decoded vector to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&out[i]), shifted);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char *in_ptr = s.data();\n    char *out_ptr = out.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)in_ptr + i);\n        svuint8_t shifted = svsub_u8_x(pg, vec, svdup_u8(5));\n        svuint8_t wrapped = svadd_u8_x(pg, svsub_u8_x(pg, shifted, svdup_u8('a')), svdup_u8('a'));\n        svst1_u8(pg, (uint8_t*)out_ptr + i, wrapped);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char* in = s.data();\n    char* out_ptr = out.data();\n    size_t len = s.length();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    svint8_t shift = svdup_s8(-5);\n    svint8_t a_val = svdup_s8('a');\n    svint8_t z_val = svdup_s8('z');\n    svint8_t modulo = svdup_s8(26);\n\n    for (; i < len; ) {\n        pg = svwhilelt_b8(i, len);\n        svint8_t chars = svld1_s8(pg, in + i);\n        \n        svint8_t shifted = svadd_s8_x(pg, chars, shift);\n        svint8_t norm = svsub_s8_x(pg, shifted, a_val);\n        svint8_t mod = svmod_s8_x(pg, norm, modulo);\n        svint8_t result = svadd_s8_x(pg, mod, a_val);\n        \n        svst1_s8(pg, out_ptr + i, result);\n        i += svcntb();\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    const int *data = l.data();\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_n_s32(t);\n    bool all_below = true;\n\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(active, data + i);\n        svbool_t cmp = svcmplt_s32(active, vec, threshold);\n        if (!svptest_all_true(cmp)) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements per vector\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1(pg, &l[i]);\n        // Compare each element with threshold t\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        // Check if any element is not below threshold (i.e., >= t)\n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements (if any) scalarly\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for active lanes\n\n    size_t i = 0;\n    for (; i <= len - vec_len; i += vec_len) {\n        // Load a vector of integers from the input array\n        svint32_t vec = svld1(pg, &l[i]);\n        // Compare each element with the threshold\n        svbool_t cmp = svcmplt(pg, vec, t);\n        // Check if all elements in the vector are below threshold\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements (if any) scalarly\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    size_t i = 0;\n    for (; i <= len - vec_len; i += vec_len) {\n        // Load a vector of integers from the input array\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        // Compare each element with the threshold\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        // Check if all elements in the vector are below threshold\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements (if any) scalarly\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements per vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    size_t i = 0;\n    for (; i <= len - vec_len; i += vec_len) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1(pg, &l[i]);\n        // Compare each element with threshold t\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        // Check if all elements in the vector are below threshold\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements (if any) scalarly\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    svint32_t count_vec = svdup_n_s32(0);\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    // Process string in chunks based on vector length\n    while (i < len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = len - i;\n        svbool_t active_pg = svwhilelt_b8(i, len);\n\n        // Load chunk of characters\n        svuint8_t chars = svld1_u8(active_pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create masks for '<' and '>'\n        svbool_t is_open = svcmpeq_u8(active_pg, chars, svdup_n_u8('<'));\n        svbool_t is_close = svcmpeq_u8(active_pg, chars, svdup_n_u8('>'));\n\n        // Increment count for '<' and decrement for '>'\n        svint32_t inc = svsel_s32(is_open, svdup_n_s32(1), svdup_n_s32(0));\n        svint32_t dec = svsel_s32(is_close, svdup_n_s32(-1), svdup_n_s32(0));\n        svint32_t delta = svadd_s32_z(active_pg, inc, dec);\n\n        // Accumulate the count\n        count_vec = svadd_s32_z(active_pg, count_vec, delta);\n\n        // Check if count becomes negative at any point (invalid sequence)\n        svbool_t negative_check = svcmplt_s32(active_pg, count_vec, svdup_n_s32(0));\n        if (svptest_any(active_pg, negative_check)) {\n            return false;\n        }\n\n        i += svcntb();\n    }\n\n    // Final check: count should be zero for valid bracketing\n    int32_t final_count = svaddv_s32(pg, count_vec);\n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svint32_t count_vec = svdup_n_s32(0);\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n    const char* data = brackets.c_str();\n\n    while (i < len) {\n        size_t remaining = len - i;\n        svbool_t active = svwhilelt_b8(i, len);\n        svint8_t chars = svld1_s8(active, &data[i]);\n\n        svbool_t is_open = svcmpeq_s8(active, chars, '<');\n        svbool_t is_close = svcmpeq_s8(active, chars, '>');\n\n        int32_t open_count = svcntp_b8(active, is_open);\n        int32_t close_count = svcntp_b8(active, is_close);\n\n        count_vec = svadd_n_s32(count_vec, open_count);\n        count_vec = svsub_n_s32(count_vec, close_count);\n\n        int32_t current_count = svaddv_s32(pg, count_vec);\n        if (current_count < 0) {\n            return false;\n        }\n\n        i += svcntb();\n    }\n\n    int32_t final_count = svaddv_s32(pg, count_vec);\n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    svint32_t count = svdup_s32(0);\n    \n    const char* data = brackets.c_str();\n    svuint8_t input = svld1_u8(pg, (const uint8_t*)data);\n    \n    svbool_t is_open = svcmpeq_u8(pg, input, '<');\n    svbool_t is_close = svcmpeq_u8(pg, input, '>');\n    \n    count = svadd_m(is_open, count, 1);\n    count = svsub_m(is_close, count, 1);\n    \n    int32_t counts[16];\n    svst1_s32(pg, counts, count);\n    \n    int32_t running_count = 0;\n    for (size_t i = 0; i < len; i++) {\n        running_count += (data[i] == '<') ? 1 : -1;\n        if (running_count < 0) return false;\n    }\n    \n    return running_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    \n    svbool_t ptrue = svptrue_b8();\n    int32_t count = 0;\n    size_t i = 0;\n    \n    while (i < len) {\n        svint8_t vec = svld1_s8(ptrue, &brackets[i]);\n        svbool_t pred = svwhilelt_b8(i, len);\n        \n        // Compare for '<'\n        svbool_t is_open = svcmpeq_s8(pred, vec, svdup_s8('<'));\n        // Compare for '>'\n        svbool_t is_close = svcmpeq_s8(pred, vec, svdup_s8('>'));\n        \n        // Count open and close brackets\n        int32_t open_count = svcntp_b8(pred, is_open);\n        int32_t close_count = svcntp_b8(pred, is_close);\n        \n        count += open_count - close_count;\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        i += svcntb();\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t len = brackets.size();\n    if (len == 0) return true;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    svint32_t count = svdup_s32(0);\n    \n    const char* data = brackets.c_str();\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data);\n        \n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n        \n        svint32_t open_inc = svsel_s32(is_open, svdup_s32(1), svdup_s32(0));\n        svint32_t close_dec = svsel_s32(is_close, svdup_s32(-1), svdup_s32(0));\n        \n        count = svadd_s32_z(pg, count, open_inc);\n        count = svadd_s32_z(pg, count, close_dec);\n        \n        svbool_t negative = svcmplt_n_s32(pg, count, 0);\n        if (svptest_any(svptrue_b8(), negative)) {\n            return false;\n        }\n        \n        data += svcntb();\n        pg = svwhilelt_b8((data - brackets.c_str()), len);\n    }\n    \n    int32_t final_count = svaddv_s32(svptrue_b32(), count);\n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    \n    int64_t len = brackets.size();\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint32_t count = svdup_s32(0);\n    \n    const char* data = brackets.c_str();\n    \n    for (int64_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        \n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(data + i));\n        \n        svbool_t is_open = svcmpeq_u8(pg, chars, '(');\n        svbool_t is_close = svcmpeq_u8(pg, chars, ')');\n        \n        svint32_t open_inc = svdup_s32(1);\n        svint32_t close_inc = svdup_s32(-1);\n        \n        count = svadd_s32_m(pg, count, svsel_s32(is_open, open_inc, svdup_s32(0)));\n        count = svadd_s32_m(pg, count, svsel_s32(is_close, close_inc, svdup_s32(0)));\n        \n        svbool_t negative = svcmplt_s32(pg, count, 0);\n        if (svptest_any(pg, negative)) {\n            return false;\n        }\n    }\n    \n    svbool_t final_pg = svptrue_b32();\n    int32_t final_count = svaddv_s32(final_pg, count);\n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint8_t vec_data = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.data()));\n    \n    int64_t count = 0;\n    svbool_t active = pg;\n    \n    while (svptest_any(pg, active)) {\n        svint8_t open_bracket = svcmpeq_s8(active, vec_data, '(');\n        svint8_t close_bracket = svcmpeq_s8(active, vec_data, ')');\n        \n        int64_t open_count = svcntp_b8(active, open_bracket);\n        int64_t close_count = svcntp_b8(active, close_bracket);\n        \n        count += open_count - close_count;\n        if (count < 0) return false;\n        \n        active = svwhilelt_b8(svlastb_b8(active), len);\n        if (svptest_any(pg, active)) {\n            vec_data = svld1_s8(active, reinterpret_cast<const int8_t*>(brackets.data() + svlastb_b8(active)));\n        }\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint8_t vec_data = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.data()));\n    \n    int count = 0;\n    uint64_t i = 0;\n    while (i < len) {\n        int8_t val = brackets[i];\n        if (val == '(') {\n            count++;\n        } else if (val == ')') {\n            count--;\n            if (count < 0) {\n                return false;\n            }\n        }\n        i++;\n    }\n    \n    // Since SVE processing might not directly map to counting brackets in parallel efficiently,\n    // we fall back to scalar processing for correctness.\n    // SVE could be used for initial validation or transformation, but the logic of bracket matching\n    // inherently requires sequential dependency tracking.\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t count = 0;\n    svbool_t ptrue = svptrue_b8();\n    size_t len = brackets.size();\n    const char* data = brackets.c_str();\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&data[i]);\n        \n        svbool_t is_open = svcmpeq_u8(pg, vec, '(');\n        svbool_t is_close = svcmpeq_u8(pg, vec, ')');\n        \n        int64_t open_count = svcntp_b8(pg, is_open);\n        int64_t close_count = svcntp_b8(pg, is_close);\n        \n        count += open_count - close_count;\n        \n        if (count < 0) {\n            return false;\n        }\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svbool_t pg = svptrue_b8();\n    int64_t count = 0;\n    size_t i = 0;\n\n    // Process the string in chunks based on vector length\n    while (i < len) {\n        // Load a chunk of characters into a vector\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        // Create masks for '(' and ')'\n        svbool_t open_mask = svcmpeq_u8(pg, vec, '(');\n        svbool_t close_mask = svcmpeq_u8(pg, vec, ')');\n\n        // Count opening and closing brackets in this chunk\n        int64_t open_count = svcntp_b8(pg, open_mask);\n        int64_t close_count = svcntp_b8(pg, close_mask);\n\n        // Update total count: increment for '(' and decrement for ')'\n        count += open_count - close_count;\n\n        // If count becomes negative, we have a closing bracket before a matching opening one\n        if (count < 0) {\n            return false;\n        }\n\n        i += svcntb();\n        // Adjust predicate for remaining elements if near the end of string\n        if (i >= len) break;\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // At the end, count should be zero for valid bracketing\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    svfloat32_t vec_coeff, vec_result;\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    size_t i = 0;\n    for (; i + svcntw() <= xs.size(); i += svcntw()) {\n        // Load coefficients\n        vec_coeff = svld1_f32(pg, xs.data() + i);\n        \n        // Create index vector: i, i+1, i+2, ...\n        svfloat32_t indices = svindex_f32((float)i, 1.0f);\n        \n        // Multiply coefficients by their indices (derivative rule)\n        vec_result = svmul_f32_z(pg, vec_coeff, indices);\n        \n        // Store result, skipping first element (i=0)\n        if (i > 0) {\n            svst1_f32(pg, result.data() + i - 1, vec_result);\n        }\n    }\n\n    // Handle remaining elements\n    if (i < xs.size()) {\n        svbool_t mask = svwhilelt_b32(i, xs.size());\n        vec_coeff = svld1_f32(mask, xs.data() + i);\n        svfloat32_t indices = svindex_f32((float)i, 1.0f);\n        vec_result = svmul_f32_z(mask, vec_coeff, indices);\n        \n        if (i > 0) {\n            svst1_f32(mask, result.data() + i - 1, vec_result);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) return std::vector<float>();\n\n    std::vector<float> result(n - 1);\n    size_t vl = svcntw(); // Get the vector length in elements for float32\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Adjust predicate for the last iteration if necessary\n        if (i + vl > n - 1) {\n            pg = svwhilelt_b32(i, n - 1);\n        }\n\n        // Load coefficients starting from index 1 (xs[1..])\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n\n        // Create a vector of multipliers (1, 2, 3, ...) for the derivative\n        svfloat32_t multipliers = svindex_f32((float)(i + 1), 1.0f);\n\n        // Compute derivative: coeff * multiplier\n        svfloat32_t deriv = svmul_f32_z(pg, coeffs, multipliers);\n\n        // Store the result\n        svst1_f32(pg, &result[i], deriv);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 0 ? n - 1 : 0);\n    \n    if (n <= 1) {\n        return result;\n    }\n\n    size_t vl = svcntw(); // Get the vector length in elements for float32\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for the loop\n\n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b32(i, n - 1);\n        \n        // Load indices for coefficient multiplication (1, 2, 3, ...)\n        svuint32_t indices = svadd_n_u32_z(pg, svindex_u32(i + 1, 1), 1);\n        \n        // Load coefficients from xs starting from index 1\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n        \n        // Multiply coefficients by their respective indices\n        svfloat32_t deriv = svmul_f32_z(pg, coeffs, svcvt_f32_u32_z(pg, indices));\n        \n        // Store the result back to the output vector\n        svst1_f32(pg, &result[i], deriv);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) return std::vector<float>();\n\n    std::vector<float> result(n - 1);\n    size_t vl = svcntw(); // Get vector length in elements for float32\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    size_t i = 0;\n    for (; i <= n - 1 - vl; i += vl) {\n        // Load coefficients starting from index 1\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n        // Create index vector for multipliers (1, 2, 3, ...)\n        svfloat32_t indices = svindex_f32((float)(i + 1), 1.0f);\n        // Multiply coefficients by their respective indices\n        svfloat32_t deriv = svmul_f32_z(pg, coeffs, indices);\n        // Store result\n        svst1_f32(pg, &result[i], deriv);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svfloat32_t coeff_vec, result_vec;\n    svbool_t pg = svptrue_b32();\n    int64_t i = 0;\n    int64_t len = xs.size() - 1;\n    int64_t vl = svcntw();\n\n    for (; i + vl <= len; i += vl) {\n        svfloat32_t indices = svindex_f32(i + 1, 1);\n        coeff_vec = svld1_f32(pg, &xs[i + 1]);\n        result_vec = svmul_f32_z(pg, coeff_vec, indices);\n        svst1_f32(pg, &result[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    // Vowel masks for 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase)\n    const char vowels_lower[5] = {'a', 'e', 'i', 'o', 'u'};\n    const char vowels_upper[5] = {'A', 'E', 'I', 'O', 'U'};\n    \n    // Check if 'y' or 'Y' is at the end of the string\n    bool y_is_vowel = (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y'));\n\n    // Process the string in vectorized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n\n        // Count vowels for this vector\n        svbool_t is_vowel = svfalse_b();\n        for (int v = 0; v < 5; ++v) {\n            svbool_t eq_lower = svcmpeq_u8(pg, vec, vowels_lower[v]);\n            svbool_t eq_upper = svcmpeq_u8(pg, vec, vowels_upper[v]);\n            is_vowel = svorr_b_z(pg, is_vowel, eq_lower);\n            is_vowel = svorr_b_z(pg, is_vowel, eq_upper);\n        }\n\n        // Handle 'y' or 'Y' only at the end\n        if (y_is_vowel && i + svcntb() > len - 1) {\n            svbool_t is_y = svcmpeq_u8(pg, vec, 'y');\n            svbool_t is_Y = svcmpeq_u8(pg, vec, 'Y');\n            svbool_t y_mask = svorr_b_z(pg, is_y, is_Y);\n            is_vowel = svorr_b_z(pg, is_vowel, y_mask);\n        }\n\n        // Count the number of true predicates (vowels) in this vector\n        count += svcntp_b8(pg, is_vowel);\n\n        // Move to the next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    // Vowel masks for 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase)\n    const char vowels_lower[] = {'a', 'e', 'i', 'o', 'u'};\n    const char vowels_upper[] = {'A', 'E', 'I', 'O', 'U'};\n    \n    // Check if 'y' or 'Y' is at the end\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    // Process the string using SVE vectors\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    while (i < len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Count vowels in the current vector\n        for (int v = 0; v < 5; ++v) {\n            svuint8_t vowel_lower = svdup_u8(vowels_lower[v]);\n            svuint8_t vowel_upper = svdup_u8(vowels_upper[v]);\n            svbool_t match_lower = svcmpeq_u8(pg, vec, vowel_lower);\n            svbool_t match_upper = svcmpeq_u8(pg, vec, vowel_upper);\n            svbool_t match = svorr_b_z(pg, match_lower, match_upper);\n            count += svcntp_b8(pg, match);\n        }\n\n        i += svcntb();\n        if (i < len) {\n            pg = svwhilelt_b8(i, len);\n        } else {\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    // Vowel masks for 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase)\n    const char vowels_lower[] = {'a', 'e', 'i', 'o', 'u'};\n    const char vowels_upper[] = {'A', 'E', 'I', 'O', 'U'};\n\n    // Check if 'y' or 'Y' is at the end\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    // Process the string using SVE intrinsics\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    while (i < len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n\n        // Check for each vowel (lowercase and uppercase)\n        for (int v = 0; v < 5; ++v) {\n            svuint8_t vowel_lower_vec = svdup_u8(vowels_lower[v]);\n            svuint8_t vowel_upper_vec = svdup_u8(vowels_upper[v]);\n\n            // Compare the vector with the vowel (lower and upper case)\n            svbool_t match_lower = svcmpeq_u8(pg, vec, vowel_lower_vec);\n            svbool_t match_upper = svcmpeq_u8(pg, vec, vowel_upper_vec);\n\n            // Combine the matches for lower and upper case\n            svbool_t match = svorr_b_z(pg, match_lower, match_upper);\n\n            // Count the number of matches in this vector\n            count += svcntp_b8(pg, match);\n        }\n\n        i += svcntb();\n        // Update predicate to handle remaining elements if any\n        if (i >= len) break;\n        pg = svwhilelt_b8_u64(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    // Vowel masks for 'a', 'e', 'i', 'o', 'u' (both lowercase and uppercase)\n    const char vowels_lower[] = {'a', 'e', 'i', 'o', 'u'};\n    const char vowels_upper[] = {'A', 'E', 'I', 'O', 'U'};\n    \n    // Check if 'y' or 'Y' is at the end\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    // Use SVE to process the string in chunks\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    while (i < len) {\n        // Load a vector of characters from the string\n        svint8_t vec = svld1_s8(pg, (const int8_t*)(str + i));\n        \n        // Initialize a vector to store whether each character is a vowel\n        svbool_t is_vowel = svfalse_b();\n\n        // Check against each vowel (lower and upper case)\n        for (int v = 0; v < 5; ++v) {\n            svint8_t vowel_lower_vec = svdup_s8(vowels_lower[v]);\n            svint8_t vowel_upper_vec = svdup_s8(vowels_upper[v]);\n            svbool_t match_lower = svcmpeq_s8(pg, vec, vowel_lower_vec);\n            svbool_t match_upper = svcmpeq_s8(pg, vec, vowel_upper_vec);\n            is_vowel = svorr_b_z(pg, is_vowel, match_lower);\n            is_vowel = svorr_b_z(pg, is_vowel, match_upper);\n        }\n\n        // Count the number of vowels in this vector\n        count += svcntp_b8(pg, is_vowel);\n\n        // Move to the next chunk\n        i += svcntb();\n        if (i < len) {\n            pg = svwhilelt_b8(i, len);\n        } else {\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char *str = s.c_str();\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Vowel lookup table for 'a', 'e', 'i', 'o', 'u' (both cases)\n    const uint8_t vowels[] = {\n        'a', 'A', 'e', 'E', 'i', 'I', 'o', 'O', 'u', 'U'\n    };\n    svuint8_t vowel_vec[10];\n    for (int i = 0; i < 10; i++) {\n        vowel_vec[i] = svdup_u8(vowels[i]);\n    }\n    \n    // Process string in vector-sized chunks\n    int i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load chunk of string\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Check against each vowel\n        svbool_t is_vowel = svfalse_b();\n        for (int j = 0; j < 10; j++) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, vowel_vec[j]));\n        }\n        \n        // Count matches\n        vowel_count += svcntp_b8(pg, is_vowel);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    // Handle 'y' or 'Y' at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    int i = 0;\n    \n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n        svbool_t is_upper = svcmple_n_u8(pg, vec, 'A');\n        is_upper = svand_b_z(pg, is_upper, svcmpge_n_u8(pg, vec, 'Z'));\n        \n        svuint8_t masked = svsel_u8(is_upper, vec, svdup_n_u8(0));\n        sum += svaddv_u8(pg, masked);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int64_t sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process vector-sized chunks\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Create mask for uppercase letters (A-Z: 65-90)\n        svbool_t upper_mask = svand_b_z(pg, \n            svcmpge_u8(pg, vec, 65), \n            svcmple_u8(pg, vec, 90)\n        );\n        \n        // Sum only uppercase characters\n        svuint64_t sum_vec = svmul_u64_z(upper_mask, \n            svcvt_u64_z(pg, vec), \n            svdup_u64(1)\n        );\n        sum += svaddv_u64(pg, sum_vec);\n        \n        i += svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int sum = 0;\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntb();\n\n    // Process the string in chunks based on vector length\n    while (i + vl <= len) {\n        // Load a vector of characters\n        svint8_t vec = svld1_s8(svptrue_b8(), &str[i]);\n\n        // Create a mask for uppercase letters (ASCII 'A' to 'Z')\n        svbool_t mask_upper = svand_b_z(svptrue_b8(),\n            svcmpge_n_s8(svptrue_b8(), vec, 'A'),\n            svcmple_n_s8(svptrue_b8(), vec, 'Z'));\n\n        // Apply mask to zero out non-uppercase characters\n        svint8_t upper_vec = svsel_s8(mask_upper, vec, svdup_n_s8(0));\n\n        // Sum the vector elements\n        sum += svaddv_s8(svptrue_b8(), upper_vec);\n\n        i += vl;\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int sum = 0;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    svuint8_t zeros = svdup_u8(0);\n    \n    for (size_t i = 0; i < s.length(); i += svcntb()) {\n        pg = svwhilelt_b8(i, s.length());\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)(str + i));\n        \n        // Check for uppercase (A-Z: 65-90)\n        svbool_t is_upper = svand_b_z(pg, \n            svcmpge_u8(pg, chars, svdup_u8('A')),\n            svcmple_u8(pg, chars, svdup_u8('Z')));\n            \n        // Mask non-uppercase characters to 0\n        svuint8_t upper_chars = svsel_u8(is_upper, chars, zeros);\n        \n        // Sum the ASCII values of uppercase characters\n        sum += svsum_u8_z(pg, upper_chars);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    int sum = 0;\n    size_t i = 0;\n\n    // Process the string in chunks based on vector length\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb(); // Vector length in bytes\n\n    for (; i + vl <= len; i += vl) {\n        // Load a chunk of characters into a vector\n        svint8_t chars = svld1_s8(pg, &str[i]);\n\n        // Create a mask for uppercase letters (ASCII 'A' to 'Z')\n        svbool_t is_upper = svand_b_z(pg, \n            svcmpge_n_s8(pg, chars, 'A'), \n            svcmple_n_s8(pg, chars, 'Z')\n        );\n\n        // Convert characters to int32 for summation, masking non-uppercase to 0\n        svint32_t vals = svsel_s32(is_upper, svsxtb_n_s32(chars), svdup_n_s32(0));\n\n        // Sum the vector elements\n        sum += svaddv_s32(pg, vals);\n    }\n\n    // Handle remaining characters scalarly\n    for (; i < len; i++) {\n        char c = str[i];\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svwhilelt_b32(0, (uint32_t)arr.size());\n    svuint32_t indices = svindex_u32(0, 1);\n    svuint32_t min_even = svdup_u32(UINT32_MAX);\n    svuint32_t min_index = svdup_u32(UINT32_MAX);\n    svbool_t even_mask;\n\n    uint32_t min_val = UINT32_MAX;\n    uint32_t min_idx = UINT32_MAX;\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, (uint32_t)arr.size());\n        svuint32_t values = svld1_u32(pg, &arr[i]);\n\n        // Check for even numbers (value % 2 == 0)\n        even_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, values, 1), 0);\n\n        // Update minimum even value and corresponding index\n        svuint32_t curr_indices = svadd_n_u32_z(pg, svindex_u32(0, 1), i);\n        min_even = svmin_u32_m(even_mask, min_even, values);\n        min_index = svsel_u32(even_mask, \n                            svmin_u32_m(svcmplt_u32(pg, values, min_even), \n                                      min_index, curr_indices),\n                            min_index);\n    }\n\n    // Reduce to find the minimum even value and its index\n    min_val = svminv_u32(pg, min_even);\n    if (min_val == UINT32_MAX) return {};\n\n    // Find index where value equals min_val\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, (uint32_t)arr.size());\n        svuint32_t values = svld1_u32(pg, &arr[i]);\n        even_mask = svcmpeq_n_u32(pg, values, min_val);\n        if (svptest_any(pg, even_mask)) {\n            svuint32_t curr_indices = svadd_n_u32_z(pg, svindex_u32(0, 1), i);\n            min_idx = svminv_u32(even_mask, curr_indices);\n            break;\n        }\n    }\n\n    return {(int)min_val, (int)min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vec_len = svcntw();\n\n    int32_t min_val = INT32_MAX;\n    int32_t min_idx = -1;\n\n    size_t i = 0;\n    for (; i <= len - vec_len; i += vec_len) {\n        svint32_t vals = svld1(pg, &arr[i]);\n        svbool_t even_mask = sveor_b_z(pg, svcmpeq_n_s32(pg, vals, 0), svcmpeq_n_s32(pg, svand_n_s32_z(pg, vals, 1), 0));\n        svint32_t masked_vals = svsel_s32(even_mask, vals, svdup_n_s32(INT32_MAX));\n\n        int32_t local_min = svminv_s32_x(pg, masked_vals);\n        if (local_min < min_val) {\n            svbool_t min_mask = svcmpeq_n_s32(pg, masked_vals, local_min);\n            int32_t local_idx = i + svlastb_s32(min_mask, svindex_n_s32(0, 1));\n            min_val = local_min;\n            min_idx = local_idx;\n        } else if (local_min == min_val) {\n            svbool_t min_mask = svcmpeq_n_s32(pg, masked_vals, local_min);\n            int32_t local_idx = i + svlastb_s32(min_mask, svindex_n_s32(0, 1));\n            if (local_idx < min_idx) {\n                min_idx = local_idx;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        int32_t val = arr[i];\n        if (val % 2 == 0) {\n            if (val < min_val) {\n                min_val = val;\n                min_idx = i;\n            } else if (val == min_val && i < min_idx) {\n                min_idx = i;\n            }\n        }\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n    return {min_val, static_cast<int>(min_idx)};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint32_t min_even = svdup_u32(UINT32_MAX);\n    svuint32_t min_idx = svdup_u32(0);\n    svbool_t found = svpfalse();\n    \n    int64_t i = 0;\n    while (i < len) {\n        svbool_t pg_loop = svwhilelt_b32(i, len);\n        svuint32_t values = svld1_u32(pg_loop, &arr[i]);\n        svbool_t is_even = svcmpeq_n_u32(pg_loop, svand_u32_x(pg_loop, values, 1), 0);\n        \n        svbool_t valid = svand_b_z(pg_loop, pg_loop, is_even);\n        svuint32_t curr_indices = svindex_u32(i, 1);\n        \n        svuint32_t masked_values = svsel_u32(valid, values, min_even);\n        svbool_t less_than = svcmplt_u32(valid, masked_values, min_even);\n        \n        min_even = svsel_u32(less_than, masked_values, min_even);\n        min_idx = svsel_u32(less_than, curr_indices, min_idx);\n        found = svor_b_z(pg_loop, found, valid);\n        \n        i += svcntw();\n    }\n    \n    uint32_t final_min = svminv_u32(found, min_even);\n    uint32_t final_idx = svminv_u32(found, min_idx);\n    \n    if (!svptest_any(svptrue_b32(), found)) {\n        return {};\n    }\n    \n    return {(int)final_min, (int)final_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t len = arr.size();\n    svbool_t pg = svptrue_b32();\n    size_t vlen = svcntw();\n    int32_t min_val = INT32_MAX;\n    int32_t min_idx = -1;\n\n    for (size_t i = 0; i < len; i += vlen) {\n        svbool_t active = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(active, &arr[i]);\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Check for even values (val % 2 == 0)\n        svint32_t mod2 = svand_s32_z(active, vec, svdup_s32(1));\n        svbool_t even_mask = svcmpeq_s32(active, mod2, svdup_s32(0));\n\n        // Mask out odd values by setting them to INT32_MAX\n        svint32_t masked_vals = svsel_s32(even_mask, vec, svdup_s32(INT32_MAX));\n\n        // Find minimum value in the current vector\n        int32_t local_min = svminv_s32(active, masked_vals);\n\n        if (local_min < min_val) {\n            // Extract indices where value equals local_min\n            svbool_t min_mask = svcmpeq_s32(active, masked_vals, svdup_s32(local_min));\n            svint32_t candidate_indices = svsel_s32(min_mask, indices, svdup_s32(INT32_MAX));\n            int32_t local_min_idx = svminv_s32(active, candidate_indices);\n\n            min_val = local_min;\n            min_idx = local_min_idx;\n        } else if (local_min == min_val) {\n            // If equal to current min, take smallest index\n            svbool_t min_mask = svcmpeq_s32(active, masked_vals, svdup_s32(local_min));\n            svint32_t candidate_indices = svsel_s32(min_mask, indices, svdup_s32(INT32_MAX));\n            int32_t local_min_idx = svminv_s32(active, candidate_indices);\n            if (local_min_idx < min_idx) {\n                min_idx = local_min_idx;\n            }\n        }\n    }\n\n    if (min_val == INT32_MAX) {\n        return {};\n    }\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    uint64_t vlen = svcntw();\n    int min_even = INT_MAX;\n    int min_index = -1;\n    \n    // Process array in vector-sized chunks\n    for (size_t i = 0; i < arr.size(); i += vlen) {\n        // Calculate remaining elements\n        uint64_t remaining = std::min(vlen, arr.size() - i);\n        svbool_t active = svwhilelt_b32(i, arr.size());\n        \n        // Load vector\n        svint32_t vec = svld1_s32(active, &arr[i]);\n        \n        // Create mask for even numbers (value % 2 == 0)\n        svint32_t twos = svdup_s32(2);\n        svint32_t mod = svmod_s32(pg, vec, twos);\n        svbool_t even_mask = svcmpeq_s32(pg, mod, 0);\n        \n        // Get valid even values\n        svint32_t even_values = svsel_s32(even_mask, vec, svdup_s32(INT_MAX));\n        \n        // Find minimum even value in current vector\n        int32_t local_min = svminv_s32(pg, even_values);\n        \n        if (local_min < min_even && local_min != INT_MAX) {\n            min_even = local_min;\n            \n            // Create mask for values equal to min_even\n            svbool_t min_mask = svcmpeq_s32(pg, vec, min_even);\n            \n            // Create index vector\n            svint32_t indices = svindex_s32(i, 1);\n            \n            // Get indices where value equals min_even\n            svint32_t min_indices = svsel_s32(min_mask, indices, svdup_s32(INT_MAX));\n            \n            // Find minimum index\n            int32_t local_min_index = svminv_s32(pg, min_indices);\n            if (local_min_index != INT_MAX && (min_index == -1 || local_min_index < min_index)) {\n                min_index = local_min_index;\n            }\n        }\n    }\n\n    if (min_even == INT_MAX || min_index == -1) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Count frequencies using SVE\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    size_t len = lst.size();\n    \n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t active = svwhilelt_b32(i, len);\n        \n        // Update frequencies\n        for (int j = 0; j < svcntw(); j++) {\n            if (svptest_any(pg, active)) {\n                int val = svlasta_s32(svnot_z(pg, active), vec);\n                if (val <= max_val) {\n                    freq[val]++;\n                }\n                vec = svextw_s32_z(pg, vec, 1);\n                active = svlsr_n_s32_z(pg, active, 1);\n            } else {\n                break;\n            }\n        }\n        i += svcntw();\n    }\n    \n    // Find valid number with freq >= value\n    int result = -1;\n    for (int x = 1; x <= max_val; x++) {\n        if (freq[x] >= x && x > result) {\n            result = x;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    if (n == 0) return -1;\n\n    // Determine maximum value in the list to size the frequency array\n    int max_val = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (lst[i] > max_val) max_val = lst[i];\n    }\n    if (max_val == 0) return -1;\n\n    // Frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Compute frequency using SVE\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        for (size_t j = 0; j < vl; ++j) {\n            int val = svclastb_s32(pg, 0, vec);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            vec = svextw_s32_x(pg, vec, 1);\n        }\n    }\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int val = lst[i];\n        if (val > 0 && val <= max_val) {\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer satisfying the condition\n    for (int k = max_val; k > 0; --k) {\n        if (freq[k] >= k) {\n            return k;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    if (n == 0) return -1;\n\n    // Determine the maximum value in the list to size the frequency array\n    int max_val = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (lst[i] > max_val) max_val = lst[i];\n    }\n    if (max_val == 0) return -1;\n\n    // Frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Calculate frequencies using SVE\n    size_t vl = svcntw(); // Vector length for 32-bit elements\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1(pg, &lst[i]);\n        for (size_t j = 0; j < vl; j++) {\n            int val = svlasta(pg, vec);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            vec = svext(vec, vec, 1);\n        }\n    }\n    // Handle remaining elements\n    for (; i < n; i++) {\n        int val = lst[i];\n        if (val > 0 && val <= max_val) {\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer satisfying the condition\n    for (int k = max_val; k > 0; k--) {\n        if (freq[k] >= k) {\n            return k;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array using SVE\n    std::vector<int> freq(max_val + 1, 0);\n    size_t len = lst.size();\n    size_t i = 0;\n    \n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t values = svld1_u32(pg, lst.data() + i);\n        \n        // Update frequencies using gather\n        for (int j = 0; j < svcntw(); j++) {\n            if (i >= len) break;\n            uint32_t val = svlasta(svptrue_b32(), values);\n            if (val <= max_val) {\n                freq[val]++;\n            }\n            values = svextw_u32_z(svptrue_b32(), values, 1);\n            i++;\n        }\n    }\n    \n    // Find valid number using SVE\n    int result = -1;\n    i = 1;\n    while (i <= max_val) {\n        svbool_t pg = svwhilelt_b32(i, max_val + 1);\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t freqs = svld1_u32(pg, freq.data() + i);\n        svuint32_t valid = svcmpge_u32(pg, freqs, indices);\n        \n        // Check for valid numbers\n        while (svptest_any(svptrue_b32(), valid)) {\n            uint32_t candidate = svlasta(svptrue_b32(), indices);\n            if (freq[candidate] >= candidate && candidate > result) {\n                result = candidate;\n            }\n            indices = svextw_u32_z(svptrue_b32(), indices, 1);\n            valid = svextw_u32_z(svptrue_b32(), valid, 1);\n        }\n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    if (n == 0) return -1;\n\n    // Determine the maximum value in the list to size the frequency array\n    int max_val = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (lst[i] > max_val) max_val = lst[i];\n    }\n    if (max_val == 0) return -1;\n\n    // Frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t vl = svcntw(); // Vector length in 32-bit elements\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1(pg, &lst[i]);\n        for (size_t j = 0; j < vl; j++) {\n            int val = svlasta(pg, vec);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            vec = svext(vec, vec, 1);\n        }\n    }\n    // Handle remaining elements\n    for (; i < n; i++) {\n        int val = lst[i];\n        if (val > 0 && val <= max_val) {\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer satisfying the condition\n    int result = -1;\n    for (int val = max_val; val > 0; val--) {\n        if (freq[val] >= val) {\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Check if sum <= w\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n    \n    // Check if palindromic\n    int half = n / 2;\n    svint32_t front = svld1_s32(pg, q.data());\n    svint32_t back = svld1_s32(pg, q.data() + n - half);\n    back = svrev_s32(back);\n    \n    svbool_t cmp = svcmpeq_s32(pg, front, back);\n    return svptest_all(pg, cmp);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Sum elements using SVE\n    svint32_t vec = svld1_s32(pg, q.data());\n    int sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n    \n    // Check if palindromic\n    int half = n / 2;\n    svbool_t pg_half = svwhilelt_b32(0, half);\n    \n    // Load first half\n    svint32_t front = svld1_s32(pg_half, q.data());\n    \n    // Load second half in reverse\n    svint32_t indices = svindex_s32(n - 1, -1);\n    svint32_t back = svtbl_s32(vec, indices);\n    \n    // Compare front and back\n    svbool_t cmp = svcmpeq_s32(pg_half, front, back);\n    bool is_palindrome = svptest_any(pg_half, cmp);\n    \n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic\n    size_t half = n / 2;\n    svbool_t pg = svwhilelt_b32(0, half);\n    svint32_t vec1, vec2;\n    bool is_palindrome = true;\n\n    for (size_t i = 0; i < half; i += svcntw()) {\n        pg = svwhilelt_b32(i, half);\n        vec1 = svld1(pg, &q[i]);\n        vec2 = svld1(pg, &q[n - 1 - i]);\n        svbool_t cmp = svcmpeq(pg, vec1, vec2);\n        if (!svptest_all(cmp)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) return false;\n\n    // Compute sum of elements using SVE\n    int64_t total_sum = 0;\n    svint32_t sum_vec = svdup_n_s32(0);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1(pg, &q[i]);\n        sum_vec = svadd_m(pg, sum_vec, data);\n    }\n    total_sum = svaddv(pg, sum_vec);\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if sum is less than or equal to w\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n\n    // Check if palindromic\n    svint32_t rev_vec = svrev_s32(vec);\n    svbool_t cmp = svcmpeq_s32(pg, vec, rev_vec);\n    return svptest_all(cmp);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if sum is <= w\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n\n    // Check if palindromic\n    size_t half = (n + 1) / 2;\n    svbool_t pg_half = svwhilelt_b32(0, half);\n    \n    // Load first half\n    svint32_t front = svld1_s32(pg_half, q.data());\n    \n    // Load second half in reverse\n    int32_t* back_ptr = q.data() + n - 1;\n    svint32_t back = svld1_s32(pg_half, back_ptr - half + 1);\n    svint32_t back_rev = svrev_s32(back);\n    \n    // Compare front and reversed back\n    svbool_t cmp = svcmpeq_s32(pg_half, front, back_rev);\n    bool is_palindrome = svptest_all(pg_half, cmp);\n    \n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    int changes = 0;\n    \n    // Get vector length in elements\n    svbool_t pg = svwhilelt_b32(0, half);\n    int vlen = svcntw();\n    \n    // Process in vector chunks\n    for (int i = 0; i < half; i += vlen) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b32(i, half);\n        \n        // Load left and right elements\n        svint32_t left = svld1(pg, &arr[i]);\n        svint32_t right = svld1(pg, &arr[n-1-i]);\n        \n        // Compare elements\n        svbool_t neq = svcmpne(pg, left, right);\n        \n        // Count differences\n        changes += svcntp_b32(pg, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return 0;\n    \n    int half = n / 2;\n    int changes = 0;\n    int i;\n    \n    // Process elements in pairs from start and end using SVE\n    for (i = 0; i < half; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, half);\n        svint32_t left_vec = svld1_s32(pg, &arr[i]);\n        svint32_t right_vec = svld1_s32(pg, &arr[n - 1 - i]);\n        svbool_t neq = svcmpne_s32(pg, left_vec, right_vec);\n        changes += svcntp_b32(pg, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return 0;\n    \n    size_t half = n / 2;\n    int changes = 0;\n    size_t i;\n    \n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n    \n    // Process elements in chunks using SVE\n    for (i = 0; i < half - (half % vl); i += vl) {\n        // Load elements from start and corresponding end\n        svint32_t vec_start = svld1(pg, &arr[i]);\n        svint32_t vec_end = svld1(pg, &arr[n - 1 - i - (vl - 1)]);\n        vec_end = svrev_s32(vec_end); // Reverse the end vector to align with start\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq_s32(pg, vec_start, vec_end);\n        // Count mismatches (where elements are not equal)\n        changes += vl - svcntp_b32(pg, cmp);\n    }\n    \n    // Handle remaining elements if n is not perfectly divisible by vector length\n    for (; i < half; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return 0;\n    \n    size_t half = n / 2;\n    int changes = 0;\n    size_t i;\n    \n    // Get the vector length for SVE\n    svbool_t pg = svwhilelt_b32(0, (uint32_t)half);\n    size_t vl = svcntw();\n    \n    // Process in chunks based on vector length\n    for (i = 0; i < half; i += vl) {\n        svbool_t active_pg = svwhilelt_b32((uint32_t)i, (uint32_t)half);\n        if (!svptest_any(svptrue_b32(), active_pg)) break;\n        \n        // Load elements from start and corresponding end\n        svint32_t vec_start = svld1_s32(active_pg, &arr[i]);\n        svint32_t vec_end = svld1_s32(active_pg, &arr[n - 1 - i]);\n        \n        // Compare elements\n        svbool_t neq_mask = svcmpne_s32(active_pg, vec_start, vec_end);\n        \n        // Count mismatches in this vector\n        changes += svcntp_b32(active_pg, neq_mask);\n    }\n    \n    // Handle remaining elements scalar-wise if any\n    for (; i < half; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    int changes = 0;\n    \n    // Process pairs of elements from both ends using SVE\n    for (int i = 0; i < half; i += svcntw()) {\n        // Calculate remaining elements to process\n        int remaining = half - i;\n        svbool_t pg = svwhilelt_b32(i, half);\n        \n        // Load elements from start and end\n        svint32_t vec_left = svld1_s32(pg, &arr[i]);\n        svint32_t vec_right = svld1_s32(pg, &arr[n-1-i]);\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq_s32(pg, vec_left, vec_right);\n        \n        // Count mismatches\n        changes += svcntp_b32(pg, svnot_b_z(pg, cmp));\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    uint64_t total_len1 = 0;\n    uint64_t total_len2 = 0;\n    svbool_t pg = svptrue_b8();\n    uint64_t vl = svcntb();\n\n    // Calculate total length of strings in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        svbool_t active = svptrue_b8();\n        if (i + vl > lst1.size()) {\n            active = svwhilelt_b8(i, lst1.size());\n        }\n        svuint64_t len_vec = svdup_u64(0);\n        for (uint64_t j = 0; j < vl && i + j < lst1.size(); ++j) {\n            uint64_t len = lst1[i + j].length();\n            len_vec = svinsr_n_u64(len_vec, j, len);\n        }\n        total_len1 += svaddv_u64(active, len_vec);\n    }\n\n    // Calculate total length of strings in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        svbool_t active = svptrue_b8();\n        if (i + vl > lst2.size()) {\n            active = svwhilelt_b8(i, lst2.size());\n        }\n        svuint64_t len_vec = svdup_u64(0);\n        for (uint64_t j = 0; j < vl && i + j < lst2.size(); ++j) {\n            uint64_t len = lst2[i + j].length();\n            len_vec = svinsr_n_u64(len_vec, j, len);\n        }\n        total_len2 += svaddv_u64(active, len_vec);\n    }\n\n    // Return the vector with smaller total length, or lst1 if equal\n    return (total_len2 < total_len1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t total1 = 0, total2 = 0;\n    svbool_t pg = svptrue_b8();\n    uint64_t vl = svcntb();\n\n    // Calculate total characters in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        svbool_t active = svptrue_b8();\n        if (i + vl > lst1.size()) {\n            active = svwhilelt_b8(i, lst1.size());\n        }\n        svuint64_t lengths = svdup_n_u64(0);\n        for (uint64_t j = 0; j < vl && i + j < lst1.size(); ++j) {\n            lengths = svinsr_n_u64(lengths, lst1[i + j].size(), j);\n        }\n        total1 += svaddv_u64(active, lengths);\n    }\n\n    // Calculate total characters in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        svbool_t active = svptrue_b8();\n        if (i + vl > lst2.size()) {\n            active = svwhilelt_b8(i, lst2.size());\n        }\n        svuint64_t lengths = svdup_n_u64(0);\n        for (uint64_t j = 0; j < vl && i + j < lst2.size(); ++j) {\n            lengths = svinsr_n_u64(lengths, lst2[i + j].size(), j);\n        }\n        total2 += svaddv_u64(active, lengths);\n    }\n\n    // Return the vector with fewer total characters, or lst1 if equal\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t total1 = 0, total2 = 0;\n    svbool_t pg = svptrue_b8();\n    \n    // Calculate total characters in lst1\n    for (size_t i = 0; i < lst1.size(); ) {\n        size_t remaining = lst1.size() - i;\n        svuint64_t vec_len = svdup_u64(0);\n        \n        // Process strings in chunks based on vector length\n        size_t chunk_size = svcntd();\n        if (remaining < chunk_size) {\n            pg = svwhilelt_b64(i, lst1.size());\n        }\n        \n        for (size_t j = 0; j < chunk_size && i + j < lst1.size(); ++j) {\n            uint64_t len = lst1[i + j].length();\n            vec_len = svinsr_n_u64(vec_len, len, j);\n        }\n        \n        // Sum the lengths in the vector\n        total1 += svaddv_u64(pg, vec_len);\n        i += chunk_size;\n    }\n    \n    // Calculate total characters in lst2\n    for (size_t i = 0; i < lst2.size(); ) {\n        size_t remaining = lst2.size() - i;\n        svuint64_t vec_len = svdup_u64(0);\n        \n        // Process strings in chunks based on vector length\n        size_t chunk_size = svcntd();\n        if (remaining < chunk_size) {\n            pg = svwhilelt_b64(i, lst2.size());\n        }\n        \n        for (size_t j = 0; j < chunk_size && i + j < lst2.size(); ++j) {\n            uint64_t len = lst2[i + j].length();\n            vec_len = svinsr_n_u64(vec_len, len, j);\n        }\n        \n        // Sum the lengths in the vector\n        total2 += svaddv_u64(pg, vec_len);\n        i += chunk_size;\n    }\n    \n    // Return the vector with fewer total characters\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) return {};\n\n    // Calculate total character count for both vectors\n    uint64_t len1 = 0, len2 = 0;\n    svbool_t pg = svwhilelt_b8(0, 1); // Predicate for scalar operations\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        uint64_t str_len = str.length();\n        svuint64_t len_vec = svdup_u64(str_len);\n        len1 = svaddv_u64(pg, len_vec);\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        uint64_t str_len = str.length();\n        svuint64_t len_vec = svdup_u64(str_len);\n        len2 = svaddv_u64(pg, len_vec);\n    }\n\n    // Compare and return the vector with fewer total characters\n    if (len2 < len1 || len1 == len2) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t total1 = 0, total2 = 0;\n    svbool_t pg = svptrue_b8();\n    \n    // Calculate total characters in lst1\n    for (size_t i = 0; i < lst1.size(); ) {\n        size_t remaining = lst1.size() - i;\n        svuint64_t vec_len = svdup_u64(0);\n        \n        // Process strings in chunks based on vector length\n        for (size_t j = 0; j < remaining && j < svcntd(); j++) {\n            if (i + j < lst1.size()) {\n                size_t len = lst1[i + j].length();\n                vec_len = svinsr_n_u64(vec_len, len, j);\n            }\n        }\n        \n        // Sum the lengths in the vector\n        total1 += svaddv_u64(pg, vec_len);\n        i += svcntd();\n    }\n    \n    // Calculate total characters in lst2\n    for (size_t i = 0; i < lst2.size(); ) {\n        size_t remaining = lst2.size() - i;\n        svuint64_t vec_len = svdup_u64(0);\n        \n        // Process strings in chunks based on vector length\n        for (size_t j = 0; j < remaining && j < svcntd(); j++) {\n            if (i + j < lst2.size()) {\n                size_t len = lst2[i + j].length();\n                vec_len = svinsr_n_u64(vec_len, len, j);\n            }\n        }\n        \n        // Sum the lengths in the vector\n        total2 += svaddv_u64(pg, vec_len);\n        i += svcntd();\n    }\n    \n    // Return the vector with fewer total characters, or lst1 if equal\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(0, 64);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t result = svdup_u64(1);\n    svbool_t match = svdup_b64(false);\n\n    for (int i = 0; i < 64; i++) {\n        match = svcmpeq_u64(pg, result, vec_x);\n        if (svptest_any(pg, match)) return true;\n        result = svmul_u64_z(pg, result, vec_n);\n        if (svcntd() == 0) break;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svuint64_t temp = svdup_u64(1);\n    svbool_t active = svptrue_b64();\n    \n    while (svptest_any(pg, active)) {\n        temp = svmul_u64_z(pg, temp, vec_n);\n        svbool_t eq = svcmpeq_u64(pg, temp, vec_x);\n        svbool_t overflow = svcmpgt_u64(pg, temp, vec_x);\n        \n        if (svptest_any(pg, eq)) return true;\n        if (svptest_any(pg, overflow)) return false;\n        \n        active = svand_b_z(pg, active, svnot_b_z(pg, overflow));\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0 || n == 0) return false;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_result = svdup_u64(1);\n    svuint64_t vec_one = svdup_u64(1);\n    svbool_t cond = svptrue_b64();\n\n    do {\n        vec_result = svmul_u64_m(pg, vec_result, vec_n);\n        svbool_t eq_cond = svcmpeq_u64(pg, vec_result, vec_x);\n        if (svptest_any(pg, eq_cond)) {\n            return true;\n        }\n        svbool_t gt_cond = svcmpgt_u64(pg, vec_result, vec_x);\n        if (svptest_any(pg, gt_cond)) {\n            return false;\n        }\n        cond = svcmpne_u64(pg, vec_result, vec_one);\n    } while (svptest_any(pg, cond));\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0 || n == 0) return false;\n    if (n == 1) return x == 1;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t is_power = svdup_b64(true);\n\n    while (svptest_any(pg, is_power)) {\n        svuint64_t mul_result = svmul_u64_m(pg, result, vec_n);\n        svbool_t overflow_check = svcmpeq_u64(pg, mul_result, 0);\n        svbool_t eq_check = svcmpeq_u64(pg, mul_result, vec_x);\n\n        if (svptest_any(pg, eq_check)) {\n            return true;\n        }\n\n        if (svptest_any(pg, overflow_check) || svptest_any(pg, svcmpgt_u64(pg, result, vec_x))) {\n            return false;\n        }\n\n        result = mul_result;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || x == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return x == 1;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_result = svdup_u64(1);\n    svuint64_t vec_one = svdup_u64(1);\n    svbool_t mask = svdup_b64(true);\n\n    while (svptest_any(pg, mask)) {\n        svuint64_t vec_temp = svmul_u64_z(pg, vec_result, vec_n);\n        mask = svcmpeq_u64(pg, vec_temp, vec_x);\n        if (svptest_any(pg, mask)) return true;\n        if (svpcmpgt_u64(pg, vec_temp, vec_x).val[0]) return false;\n        vec_result = vec_temp;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int count = 0;\n    const char *data = num.data();\n    size_t len = num.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t prime_mask = svdup_u8(0);\n    \n    // Set bits for prime digits: 2,3,5,7,B,D\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 2));\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 3));\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 5));\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 7));\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 11));\n    prime_mask = svorr_u8_z(svptrue_b8(), prime_mask, svdup_u8(1 << 13));\n\n    size_t i = 0;\n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(data + i));\n        \n        // Convert hex chars to values (0-15)\n        svbool_t is_letter = svcmplt_u8(pg, vec, 'A');\n        svuint8_t values = svsub_u8_z(pg, vec, svsel_u8(is_letter, svdup_u8('0'), svdup_u8('A' - 10)));\n        \n        // Check if values correspond to prime digits\n        svuint8_t check = svand_u8_z(pg, svlsr_u8_z(pg, prime_mask, values), svdup_u8(1));\n        count += svcntp_b8(pg, svcmpeq_u8(pg, check, 1));\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    const char* data = num.c_str();\n    size_t len = num.length();\n    int count = 0;\n\n    // Prime values in decimal for hex digits (2,3,5,7,B=11,D=13)\n    const uint8_t prime_vals[6] = {2, 3, 5, 7, 11, 13};\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        // Load chunk of data into a vector\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(data + i));\n\n        // Convert hex chars to decimal values\n        svbool_t is_digit = svcmpge_u8(pg, vec, svdup_u8('0'));\n        svbool_t is_letter = svcmpge_u8(pg, vec, svdup_u8('A'));\n        svuint8_t val_digit = svsub_u8_x(pg, vec, svdup_u8('0'));\n        svuint8_t val_letter = svsub_u8_x(pg, vec, svdup_u8('A' - 10));\n        svuint8_t values = svsel_u8(is_letter, val_letter, val_digit);\n\n        // Check against prime values\n        svbool_t is_prime = svpfalse_b();\n        for (int p = 0; p < 6; p++) {\n            svbool_t match = svcmpeq_u8(pg, values, svdup_u8(prime_vals[p]));\n            is_prime = svorr_b_z(pg, is_prime, match);\n        }\n\n        // Count matches\n        count += svcntp_b8(pg, is_prime);\n\n        // Move to next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    const char* data = num.c_str();\n    size_t len = num.length();\n    int count = 0;\n\n    // Prime values in decimal for hex digits: 2,3,5,7,B(11),D(13)\n    const uint8_t prime_vals[6] = {2, 3, 5, 7, 11, 13};\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        // Load chunk of characters\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(data + i));\n        \n        // Convert hex chars to decimal values\n        svbool_t is_digit = svcmpge_u8(pg, chars, svdup_u8('0'));\n        svbool_t is_letter = svcmpge_u8(pg, chars, svdup_u8('A'));\n        svuint8_t digit_vals = svsub_u8_x(pg, chars, svdup_u8('0'));\n        svuint8_t letter_vals = svsub_u8_x(pg, chars, svdup_u8('A' - 10));\n        svuint8_t vals = svsel_u8(is_letter, letter_vals, digit_vals);\n\n        // Check against prime values\n        svbool_t is_prime = svpfalse_b();\n        for (int p = 0; p < 6; p++) {\n            svbool_t eq = svcmpeq_u8(pg, vals, svdup_u8(prime_vals[p]));\n            is_prime = svorr_b_z(pg, is_prime, eq);\n        }\n\n        // Count true values in predicate\n        count += svcntp_b8(pg, is_prime);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n    \n    svbool_t pg = svwhilelt_b8(0, num.length());\n    svuint8_t vec = svld1_u8(pg, (const uint8_t*)num.c_str());\n    \n    // Create mask for prime digits: 2,3,5,7,B,D (ASCII values)\n    svbool_t prime_mask = svptrue_b8();\n    svuint8_t primes = svindex_u8(0, 1);\n    \n    // Check for digits 2,3,5,7 (ASCII 50,51,53,55)\n    svbool_t is_digit = svcmplt_u8(pg, vec, 65); // < 'A'\n    svbool_t digit_prime = svpfalse();\n    digit_prime = svorr_b_z(pg, digit_prime, svcmpeq_u8(pg, vec, 50)); // '2'\n    digit_prime = svorr_b_z(pg, digit_prime, svcmpeq_u8(pg, vec, 51)); // '3'\n    digit_prime = svorr_b_z(pg, digit_prime, svcmpeq_u8(pg, vec, 53)); // '5'\n    digit_prime = svorr_b_z(pg, digit_prime, svcmpeq_u8(pg, vec, 55)); // '7'\n    \n    // Check for letters B,D (ASCII 66,68)\n    svbool_t is_letter = svcmpge_u8(pg, vec, 65); // >= 'A'\n    svbool_t letter_prime = svpfalse();\n    letter_prime = svorr_b_z(pg, letter_prime, svcmpeq_u8(pg, vec, 66)); // 'B'\n    letter_prime = svorr_b_z(pg, letter_prime, svcmpeq_u8(pg, vec, 68)); // 'D'\n    \n    // Combine masks\n    svbool_t final_mask = svorr_b_z(pg, \n                                  svand_b_z(pg, is_digit, digit_prime),\n                                  svand_b_z(pg, is_letter, letter_prime));\n    \n    // Count true predicates\n    return svcntp_b8(pg, final_mask);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n    \n    // Prime digits in hex: 2,3,5,7,B(=11),D(=13)\n    const char prime_digits[] = {'2','3','5','7','B','D'};\n    const int num_primes = 6;\n    \n    int count = 0;\n    svbool_t pg = svwhilelt_b8(0, num.length());\n    \n    // Process input string in vector chunks\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)num.data() + count);\n        \n        // Count matches for each prime digit\n        for (int i = 0; i < num_primes; i++) {\n            svbool_t match = svcmpeq_n_u8(pg, vec, prime_digits[i]);\n            count += svcntp_b8(pg, match);\n        }\n        \n        // Update predicate for next chunk\n        pg = svwhilelt_b8(count, num.length());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n    svuint8_t vec1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svuint8_t vec2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 1));\n    svuint8_t vec3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 2));\n\n    svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n    svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n\n    svbool_t any_eq = svorr_b_z(pg, eq12, eq13);\n    any_eq = svorr_b_z(pg, any_eq, eq23);\n\n    if (svptest_any(pg, any_eq)) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, s.length() - 2);\n    svuint8_t vec1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svuint8_t vec2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 1));\n    svuint8_t vec3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 2));\n\n    svbool_t cmp1 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t cmp2 = svcmpeq_u8(pg, vec2, vec3);\n    svbool_t cmp3 = svcmpeq_u8(pg, vec1, vec3);\n\n    svbool_t result = svorr_b_z(pg, cmp1, svorr_b_z(pg, cmp2, cmp3));\n\n    return !svptest_any(pg, result);\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) return false;\n\n    const char *str = s.c_str();\n    int len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n\n    svuint8_t vec1 = svld1_u8(pg, (const uint8_t*)str);\n    svuint8_t vec2 = svld1_u8(pg, (const uint8_t*)(str + 1));\n    svuint8_t vec3 = svld1_u8(pg, (const uint8_t*)(str + 2));\n\n    svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n    svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n\n    svbool_t any_eq = svorr_b_z(pg, eq12, svorr_b_z(pg, eq23, eq13));\n\n    return !svptest_any(pg, any_eq);\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n    svuint8_t vec1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svuint8_t vec2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 1));\n    svuint8_t vec3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 2));\n\n    svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n    svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n\n    svbool_t any_eq = svorr_b_z(pg, eq12, eq13);\n    any_eq = svorr_b_z(pg, any_eq, eq23);\n\n    if (svptest_any(pg, any_eq)) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n    svuint8_t vec1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svuint8_t vec2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 1));\n    svuint8_t vec3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + 2));\n\n    svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n    svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n\n    svbool_t any_eq = svorr_b(eq12, eq13);\n    any_eq = svorr_b(any_eq, eq23);\n\n    if (svptest_any(pg, any_eq)) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(len)) + 1;\n    svbool_t pg = svwhilelt_b64(0, sqrt_len);\n    size_t vec_len = svcntd();\n    size_t i = 3;\n\n    while (i < sqrt_len) {\n        svuint64_t vec_i = svdup_u64(i);\n        svuint64_t vec_step = svdup_u64(vec_len * 2);\n        svuint64_t vec_inc = svmul_u64_z(pg, vec_step, svindex_u64(0, 2));\n        svuint64_t vec_check = svadd_u64_z(pg, vec_i, vec_inc);\n        svuint64_t vec_rem = svdup_u64(len % i);\n        svbool_t rem_zero = svcmpeq_u64(pg, vec_rem, 0);\n\n        if (svptest_any(pg, rem_zero)) {\n            return false;\n        }\n\n        i += vec_len * 2;\n        pg = svwhilelt_b64(i, sqrt_len);\n    }\n\n    for (; i < sqrt_len; i += 2) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(0, len);\n    size_t vector_len = svcntd();\n    size_t sqrt_len = static_cast<size_t>(sqrt(len)) + 1;\n    size_t i = 3;\n\n    while (i < sqrt_len) {\n        svuint64_t vec_i = svdup_u64(i);\n        svuint64_t vec_len = svdup_u64(len);\n        svbool_t mask = svwhilelt_b64(0, vector_len);\n        svuint64_t vec_div = svdiv_u64_m(mask, vec_len, vec_i);\n        svuint64_t vec_mul = svmul_u64_m(mask, vec_div, vec_i);\n        svbool_t is_divisible = svcmpeq_u64(mask, vec_mul, vec_len);\n\n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        i += 2;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // Determine the vector length for SVE\n    uint64_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    size_t sqrt_len = static_cast<size_t>(sqrt(len)) + 1;\n    size_t i;\n\n    // Start checking from 3 up to sqrt(len)\n    for (i = 3; i <= sqrt_len; i += vec_len * 2) {\n        svuint32_t divisors = svindex_u32(i, 2);\n        svuint32_t quotients = svdiv_n_u32_z(pg, svdup_u32(len), divisors);\n        svuint32_t products = svmul_u32_z(pg, quotients, divisors);\n        svbool_t eq_mask = svcmpeq_u32(pg, products, svdup_u32(len));\n\n        if (svptest_any(pg, eq_mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // Get vector length in elements (assuming uint64_t for indices)\n    svbool_t pg = svwhilelt_b64(3, len);\n    uint64_t vlen = svcntd();\n    \n    // Initialize vector of potential divisors starting from 3\n    svuint64_t divisors = svindex_u64(3, 2); // 3, 5, 7, ...\n    \n    // Vectorized divisibility check\n    while (svptest_any(svptrue_b64(), pg)) {\n        svbool_t div_mask = svcmpeq_u64(pg, svdiv_n_u64_x(pg, svdup_n_u64(len), divisors), 0);\n        if (svptest_any(svptrue_b64(), div_mask)) {\n            return false;\n        }\n        divisors = svadd_n_u64_x(pg, divisors, vlen * 2); // Increment by vector length * 2\n        pg = svwhilelt_b64(svlastb_u64(svptrue_b64(), divisors), len);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = static_cast<size_t>(sqrt(len));\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    size_t vector_size = svcntd();\n    uint64_t step = vector_size * 2;\n    size_t i;\n\n    for (i = 3; i <= sqrt_len; i += step) {\n        svuint64_t vec_i = svindex_u64(i, 2);\n        svbool_t cond = svwhilelt_b64(i, i + step);\n        svbool_t active = svand_b_z(pg, pg, cond);\n        svuint64_t vec_len = svdup_u64(len);\n        svuint64_t remainder = svmod_u64_z(active, vec_len, vec_i);\n        svbool_t is_divisible = svcmpeq_u64(active, remainder, 0);\n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements if any\n    for (; i <= sqrt_len; i += 2) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Initialize SVE vector for digits (0-9)\n    svuint64_t digits = svdup_u64(0);\n    svbool_t pg = svptrue_b64();\n    \n    // Extract digits by repeatedly dividing by 10\n    uint64_t temp = N;\n    int digit_count = 0;\n    while (temp > 0) {\n        uint64_t digit = temp % 10;\n        digits = svinsr_n_u64(digits, digit);\n        temp /= 10;\n        digit_count++;\n    }\n    \n    // Sum all digits using SVE reduction\n    uint64_t sum = svaddv_u64(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result = \"\";\n    if (sum == 0) return \"0\";\n    \n    while (sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Vector to store digits\n    svuint64_t digits = svdup_n_u64(0);\n    uint64_t digit_count = 0;\n    \n    // Extract digits\n    while (N > 0) {\n        if (digit_count < svcntd()) {\n            svbool_t pg = svwhilelt_b64(digit_count, svcntd());\n            digits = svinsr_n_u64(digits, N % 10);\n            digit_count++;\n        }\n        N /= 10;\n    }\n    \n    // Sum digits using SVE\n    svbool_t pg = svwhilelt_b64(0, digit_count);\n    uint64_t sum = svaddv_u64(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to process digits\n    std::string num_str = std::to_string(N);\n    int len = num_str.length();\n    \n    // Initialize sum\n    uint64_t sum = 0;\n    \n    // Use SVE to process digits in parallel\n    svbool_t pg = svptrue_b8();\n    int processed = 0;\n    \n    while (processed < len) {\n        // Determine how many elements to process in this iteration\n        int remaining = len - processed;\n        svuint8_t digits = svdup_n_u8(0);\n        \n        // Load digits into vector (as ASCII characters)\n        for (int i = 0; i < remaining && i < svcntb(); ++i) {\n            if (processed + i < len) {\n                digits = svinsr_n_u8(digits, num_str[processed + i] - '0');\n            }\n        }\n        \n        // Sum the digits in the vector\n        sum += svsum_u8(pg, digits);\n        processed += svcntb();\n    }\n    \n    // Convert the sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string solve_simd(uint64_t N) {\n    // Extract digits into a vector\n    uint64_t temp = N;\n    svuint8_t digits = svdup_n_u8(0);\n    int digit_count = 0;\n    uint8_t digit_array[16] = {0}; // Assuming max 16 digits for uint64_t\n\n    // Extract digits\n    while (temp > 0) {\n        digit_array[digit_count++] = temp % 10;\n        temp /= 10;\n    }\n\n    // Load digits into SVE vector\n    svbool_t pg = svwhilelt_b8(digit_count, 16);\n    digits = svld1_u8(pg, digit_array);\n\n    // Sum digits using SVE reduction\n    uint64_t sum = svaddv_u8(pg, digits);\n\n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert the number to a string to process digits\n    std::string num_str = std::to_string(N);\n    int len = num_str.length();\n    \n    // Use SVE to sum digits in parallel\n    svbool_t pg = svptrue_b8();\n    int sum = 0;\n    int i = 0;\n    \n    // Process digits in chunks based on vector length\n    while (i < len) {\n        int remaining = len - i;\n        svbool_t active = svwhilelt_b8(i, len);\n        svuint8_t digits = svdup_n_u8(0);\n        \n        // Load digits into vector (as ASCII, subtract '0' to get numeric value)\n        for (int j = 0; j < remaining && j < svcntb(); j++) {\n            if (i + j < len) {\n                digits = svinsr_n_u8(digits, num_str[i + j] - '0', j);\n            }\n        }\n        \n        // Sum the digits in the vector\n        sum += svsum_u8(active, digits);\n        i += svcntb();\n    }\n    \n    // Convert the sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of integers\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Create a mask for odd indices within the vector\n        svbool_t odd_mask = svpfalse();\n        for (size_t j = 1; j < vl; j += 2) {\n            if (i + j < len) {\n                odd_mask = svorr_b_z(pg, odd_mask, svptrue_pat_b32(SV_VL1 + j));\n            }\n        }\n\n        // Create a mask for even values\n        svint32_t zero = svdup_n_s32(0);\n        svbool_t even_val_mask = svcmpeq(pg, svand_s32_z(pg, vec, svdup_n_s32(1)), zero);\n\n        // Combine masks: odd indices AND even values\n        svbool_t final_mask = svand_b_z(pg, odd_mask, even_val_mask);\n\n        // Sum elements where mask is true\n        sum += svaddv(pg, svsel_s32(final_mask, vec, zero));\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svbool_t odd_mask = svnot_b_z(svwhilelt_b32(0, 1), svptrue_b32());\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1(p, &lst[i]);\n        \n        svbool_t even_mask = svcmpeq_n_s32(p, svand_z(p, vec, 1), 0);\n        svbool_t final_mask = svand_b_z(p, even_mask, svlsr_n_b32(odd_mask, i));\n        \n        sum += svaddv(final_mask, vec);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    while (i < len) {\n        // Create a predicate for the current chunk\n        svbool_t p = svwhilelt_b32(i, len);\n        // Load data into a vector\n        svint32_t vec = svld1_s32(p, &lst[i]);\n        // Create a predicate for odd indices (i+1, i+3, etc.)\n        svbool_t odd_idx = svnot_b_z(pg, sveor_b_z(pg, p, svdup_b32(1)));\n        // Create a predicate for even values\n        svbool_t even_val = svcmpeq_n_s32(p, svand_n_s32_z(pg, vec, 1), 0);\n        // Combine predicates: odd indices AND even values\n        svbool_t final_pred = svand_b_z(pg, odd_idx, even_val);\n        // Extract elements that match the predicate and add to sum\n        sum += svaddv_s32(final_pred, vec);\n        // Move to the next chunk\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    svbool_t pg = svptrue_b32();\n    int sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    // Process odd indices (1, 3, 5, ...)\n    for (i = 1; i < len; i += svcntw() * 2) {\n        // Create predicate for odd indices\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(p, &lst[i]);\n        \n        // Create mask for even elements\n        svbool_t even_mask = svcmpeq_n_s32(p, svand_n_s32_z(p, vec, 1), 0);\n        \n        // Add even elements at odd indices\n        sum += svaddv_s32(svand_s32_m(pg, even_mask, vec));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Process the vector in chunks of vector length\n    for (; i + vl <= len; i += vl) {\n        // Load a chunk of the vector into an SVE register\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Create a predicate for odd indices within the chunk\n        svbool_t odd_idx = svfalse_b();\n        for (uint64_t j = 0; j < vl; j++) {\n            if ((i + j) % 2 == 1) {\n                odd_idx = svptrue_pat_b32(SV_VL1 << j);\n            }\n        }\n\n        // Mask the vector to keep only elements at odd indices\n        svint32_t odd_vec = svsel_s32(odd_idx, vec, svdup_n_s32(0));\n\n        // Create a predicate for even values\n        svbool_t even_val = sveor_b_z(pg, svcmpeq_s32(pg, svand_s32_z(pg, odd_vec, svdup_n_s32(1)), svdup_n_s32(0)), svfalse_b());\n\n        // Mask the vector to keep only even values at odd indices\n        svint32_t final_vec = svsel_s32(even_val, odd_vec, svdup_n_s32(0));\n\n        // Sum the elements in the vector\n        sum += svaddv_s32(pg, final_vec);\n    }\n\n    // Handle the remaining elements\n    for (; i < len; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    uint64_t len = s.length();\n    uint64_t i = 0;\n\n    // Create a vector for shift value (4)\n    svuint8_t shift = svdup_u8(4);\n\n    // Process string in vector-sized chunks\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        uint64_t active = svcntb();\n\n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n\n        // Apply encryption: shift letters by 4 (2 * 2)\n        svuint8_t encrypted = svadd_u8_x(pg, vec, shift);\n\n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], encrypted);\n\n        i += active;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n    \n    // Determine vector length for SVE\n    uint64_t vl = svcntb();\n    size_t i = 0;\n\n    // Process string in chunks based on vector length\n    while (i + vl <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunk of input string into vector\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Apply encryption: shift by 4 (2 * 2) positions\n        svuint8_t shifted = svadd_n_u8_x(pg, vec, 4);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), shifted);\n        \n        i += vl;\n    }\n\n    // Handle remaining elements scalarly if any\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n    \n    // Determine vector length for SVE\n    uint64_t vec_len = svcntb();\n    size_t i = 0;\n\n    // Process input string in chunks based on vector length\n    while (i + vec_len <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk into a vector\n        svuint8_t input = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Apply encryption: shift by 4 (2 * 2) positions\n        svuint8_t shift = svdup_u8(4);\n        svuint8_t encrypted = svadd_u8_x(pg, input, shift);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n        \n        i += vec_len;\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, ' ');\n    \n    // Determine vector length using SVE\n    uint64_t vl = svcntb();\n    size_t step = vl / sizeof(char);\n    \n    // Process the string in chunks based on vector length\n    size_t i = 0;\n    for (; i < len - step; i += step) {\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk into a vector\n        svint8_t vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        \n        // Apply encryption logic: shift down by 4 (2 * 2)\n        // Assuming lowercase letters 'a' to 'z'\n        svint8_t shifted = svadd_n_s8_x(pg, vec, 4);\n        \n        // Handle wrap-around for letters beyond 'z'\n        svbool_t wrap_cond = svcmpgt_n_s8(pg, shifted, 'z');\n        svint8_t wrap_adjust = svsub_n_s8_x(pg, shifted, 26);\n        shifted = svsel_s8(wrap_cond, wrap_adjust, shifted);\n        \n        // Store the result back to the output string\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 4) % 26 + 'a';\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    uint64_t len = s.length();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create vector of shift value (4)\n    svuint8_t shift = svdup_u8(4);\n    \n    // Process string in vector chunks\n    for (uint64_t i = 0; i < len; i += svcntb()) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&s[i]);\n        \n        // Apply encryption: (c + 4) % 26 + 'a'\n        // First, subtract 'a' to get 0-based alphabet position\n        svuint8_t base = svsub_u8_x(pg, vec, 'a');\n        \n        // Add shift (4)\n        svuint8_t shifted = svadd_u8_x(pg, base, shift);\n        \n        // Modulo 26\n        svuint8_t mod = svmod_u8_x(pg, shifted, 26);\n        \n        // Add 'a' back to get ASCII values\n        svuint8_t encrypted = svadd_u8_x(pg, mod, 'a');\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], encrypted);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in vector-sized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n    \n    for (size_t i = 0; i < len; i += vlen) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        is_lower = svand_b_z(pg, is_lower, svcmpge_u8(pg, vec, svdup_u8('a')));\n        \n        svbool_t is_upper = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        is_upper = svand_b_z(pg, is_upper, svcmpge_u8(pg, vec, svdup_u8('A')));\n        \n        // Swap case: lower to upper, upper to lower\n        svuint8_t to_upper = svsub_u8_z(pg, vec, svdup_u8(32));\n        svuint8_t to_lower = svadd_u8_z(pg, vec, svdup_u8(32));\n        svuint8_t case_swapped = svsel_u8(is_lower, to_upper, vec);\n        case_swapped = svsel_u8(is_upper, to_lower, case_swapped);\n        \n        // Create masks for vowels (a,e,i,o,u,A,E,I,O,U)\n        svbool_t is_vowel = svdup_b8(false);\n        uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for (int j = 0; j < 10; j++) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, case_swapped, svdup_u8(vowels[j])));\n        }\n        \n        // Shift vowels by +2\n        svuint8_t vowel_shifted = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shifted, case_swapped);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in vector-sized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n    \n    for (size_t i = 0; i < len; i += vlen) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Create masks for lowercase and uppercase\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        is_lower = svand_b_z(pg, is_lower, svcmpgt_u8(pg, vec, svdup_u8('a'-1)));\n        \n        svbool_t is_upper = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        is_upper = svand_b_z(pg, is_upper, svcmpgt_u8(pg, vec, svdup_u8('A'-1)));\n        \n        // Swap case: lower to upper (subtract 32), upper to lower (add 32)\n        svuint8_t case_swapped = svsel_u8(is_lower, svsub_u8_z(pg, vec, svdup_u8(32)),\n                                        svsel_u8(is_upper, svadd_u8_z(pg, vec, svdup_u8(32)), vec));\n        \n        // Identify vowels (a,e,i,o,u,A,E,I,O,U)\n        svbool_t is_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_u8(pg, case_swapped, svdup_u8('a')),\n                    svcmpeq_u8(pg, case_swapped, svdup_u8('e'))),\n                svorr_b_z(pg,\n                    svcmpeq_u8(pg, case_swapped, svdup_u8('i')),\n                    svcmpeq_u8(pg, case_swapped, svdup_u8('o')))),\n            svcmpeq_u8(pg, case_swapped, svdup_u8('u')));\n        \n        // Shift vowels by +2\n        svuint8_t shifted = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        \n        // For 'u' and 'U', wrap around to 'a' and 'A' respectively\n        svbool_t is_u = svcmpeq_u8(pg, case_swapped, svdup_u8('u'));\n        svbool_t is_U = svcmpeq_u8(pg, case_swapped, svdup_u8('U'));\n        shifted = svsel_u8(is_u, svdup_u8('a'), shifted);\n        shifted = svsel_u8(is_U, svdup_u8('A'), shifted);\n        \n        // Combine results: use shifted values for vowels, case_swapped for non-vowels\n        svuint8_t final = svsel_u8(is_vowel, shifted, case_swapped);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in vector-sized chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Create masks for lowercase and uppercase\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('A'));\n        is_lower = svand_b_z(pg, is_lower, svcmpge_u8(pg, vec, svdup_u8('a')));\n        is_upper = svand_b_z(pg, is_upper, svcmplt_u8(pg, vec, svdup_u8('Z')));\n        \n        // Swap case: lower to upper, upper to lower\n        svuint8_t to_lower = svadd_u8_z(pg, vec, svdup_u8(32));\n        svuint8_t to_upper = svsub_u8_z(pg, vec, svdup_u8(32));\n        svuint8_t case_swapped = svsel_u8(is_lower, to_upper, vec);\n        case_swapped = svsel_u8(is_upper, to_lower, case_swapped);\n        \n        // Create vowel masks\n        svbool_t is_vowel = svdup_b(false);\n        const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for (int j = 0; j < 10; j++) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, case_swapped, svdup_u8(vowels[j])));\n        }\n        \n        // Shift vowels by 2\n        svuint8_t vowel_shifted = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        \n        // Apply vowel shift where applicable\n        svuint8_t final = svsel_u8(is_vowel, vowel_shifted, case_swapped);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result = message;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case: if uppercase (65-90), add 32; if lowercase (97-122), subtract 32\n        svbool_t is_upper = svcmplt_u8(pg, vec, svdup_u8('a')); // < 'a' (97)\n        svbool_t is_lower = svcmpge_u8(pg, vec, svdup_u8('a')); // >= 'a'\n        svuint8_t case_offset = svsel_u8(is_upper, svdup_u8(32), svdup_u8(-32));\n        svuint8_t case_swapped = svadd_u8_z(pg, vec, case_offset);\n\n        // Identify vowels (a,e,i,o,u,A,E,I,O,U)\n        svbool_t is_vowel = svfalse_b();\n        const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for (char v : vowels) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, vec, svdup_u8(v)));\n        }\n\n        // Shift vowels by +2\n        svuint8_t vowel_shifted = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shifted, case_swapped);\n\n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    // Process the string in chunks based on vector length\n    while (i < len) {\n        // Get the number of elements that can be processed in this iteration\n        svbool_t pg = svwhilelt_b8(i, len);\n        uint64_t active_count = svcntp_b8(pg);\n\n        // Load the current chunk of characters into a vector\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Create masks for uppercase and lowercase letters\n        svbool_t is_upper = svand_b_z(pg, svcmpge_n_u8(pg, chars, 'A'), svcmple_n_u8(pg, chars, 'Z'));\n        svbool_t is_lower = svand_b_z(pg, svcmpge_n_u8(pg, chars, 'a'), svcmple_n_u8(pg, chars, 'z'));\n\n        // Swap case: uppercase to lowercase and vice versa\n        svuint8_t to_lower = svadd_n_u8_z(pg, chars, 32);\n        svuint8_t to_upper = svsub_n_u8_z(pg, chars, 32);\n        svuint8_t swapped_case = svsel_u8(is_upper, to_lower, svsel_u8(is_lower, to_upper, chars));\n\n        // Identify vowels (both uppercase and lowercase after swapping)\n        svbool_t is_vowel_a = svcmpeq_n_u8(pg, swapped_case, 'a');\n        svbool_t is_vowel_e = svcmpeq_n_u8(pg, swapped_case, 'e');\n        svbool_t is_vowel_i = svcmpeq_n_u8(pg, swapped_case, 'i');\n        svbool_t is_vowel_o = svcmpeq_n_u8(pg, swapped_case, 'o');\n        svbool_t is_vowel_u = svcmpeq_n_u8(pg, swapped_case, 'u');\n        svbool_t is_vowel = svorr_b_z(pg, svorr_b_z(pg, svorr_b_z(pg, is_vowel_a, is_vowel_e), svorr_b_z(pg, is_vowel_i, is_vowel_o)), is_vowel_u);\n\n        // Replace vowels with letter 2 places ahead\n        svuint8_t vowel_shifted = svadd_n_u8_z(pg, swapped_case, 2);\n        svuint8_t final_chars = svsel_u8(is_vowel, vowel_shifted, swapped_case);\n\n        // Store the result back to the output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), final_chars);\n\n        i += active_count;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    // Get vector length\n    uint64_t vlen = svcntb();\n    // Maximum number of characters to process per iteration\n    const size_t max_chars = vlen / sizeof(char);\n\n    // Allocate temporary buffers for keys\n    std::string all_keys;\n    for (const auto& pair : dict) {\n        all_keys += pair.first + '\\0';\n    }\n\n    const char* keys = all_keys.c_str();\n    size_t total_len = all_keys.size();\n    \n    // Initialize flags for upper and lower case\n    svbool_t pg = svptrue_b8();\n    svuint8_t lower_mask = svdup_u8(0);\n    svuint8_t upper_mask = svdup_u8(0);\n    \n    // Process keys in chunks\n    size_t pos = 0;\n    bool has_lower = false;\n    bool has_upper = false;\n    bool has_non_alpha = false;\n\n    while (pos < total_len) {\n        // Load chunk of characters\n        svuint8_t chars = svld1_u8(pg, &keys[pos]);\n        \n        // Check for lowercase (a-z)\n        svbool_t is_lower = svand_b_z(pg, \n            svcmpge_u8(pg, chars, svdup_u8('a')),\n            svcmple_u8(pg, chars, svdup_u8('z'))\n        );\n        \n        // Check for uppercase (A-Z)\n        svbool_t is_upper = svand_b_z(pg, \n            svcmpge_u8(pg, chars, svdup_u8('A')),\n            svcmple_u8(pg, chars, svdup_u8('Z'))\n        );\n        \n        // Check for non-alphabetic characters\n        svbool_t is_alpha = svorr_b_z(pg, is_lower, is_upper);\n        svbool_t is_non_alpha = svnot_b_z(pg, is_alpha);\n        \n        // Update masks\n        lower_mask = svsel_u8(is_lower, svdup_u8(1), lower_mask);\n        upper_mask = svsel_u8(is_upper, svdup_u8(1), upper_mask);\n        \n        // Check for non-alphabetic characters (excluding null terminators)\n        svbool_t is_null = svcmpeq_u8(pg, chars, svdup_u8(0));\n        svbool_t non_alpha_no_null = svand_b_z(pg, is_non_alpha, svnot_b_z(pg, is_null));\n        if (svptest_any(pg, non_alpha_no_null)) {\n            has_non_alpha = true;\n        }\n        \n        // Update position\n        pos += max_chars;\n        if (pos >= total_len) break;\n        \n        // Update predicate for remaining characters\n        size_t remaining = total_len - pos;\n        if (remaining < max_chars) {\n            pg = svwhilelt_b8(pos, total_len);\n        }\n    }\n\n    // Check if any lowercase or uppercase characters were found\n    has_lower = svptest_any(svptrue_b8(), svcmpeq_u8(svptrue_b8(), lower_mask, svdup_u8(1)));\n    has_upper = svptest_any(svptrue_b8(), svcmpeq_u8(svptrue_b8(), upper_mask, svdup_u8(1)));\n\n    // Return true only if all characters are either all lowercase or all uppercase\n    // and no non-alphabetic characters (except null terminators) were found\n    return !has_non_alpha && (has_lower != has_upper);\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t n = dict.size();\n    size_t i = 0;\n\n    uint8_t first_case = 0;\n    bool initialized = false;\n    bool has_non_alpha = false;\n\n    // Process keys in chunks using SVE\n    for (auto it = dict.begin(); it != dict.end(); ++it) {\n        const std::string& key = it->first;\n        size_t key_len = key.size();\n        size_t j = 0;\n\n        while (j < key_len) {\n            size_t remaining = key_len - j;\n            size_t chunk_size = (remaining < vec_len) ? remaining : vec_len;\n\n            svuint8_t chars = svdup_n_u8(0);\n            for (size_t k = 0; k < chunk_size; ++k) {\n                if (j + k < key_len) {\n                    chars = svinsr_n_u8(chars, key[j + k], k);\n                }\n            }\n\n            // Check if characters are alphabetic\n            svbool_t is_alpha_lower = svand_b_z(pg, svcmplt_u8(pg, chars, svdup_n_u8('z')), svcmpge_u8(pg, chars, svdup_n_u8('a')));\n            svbool_t is_alpha_upper = svand_b_z(pg, svcmplt_u8(pg, chars, svdup_n_u8('Z')), svcmpge_u8(pg, chars, svdup_n_u8('A')));\n            svbool_t is_alpha = svorr_b_z(pg, is_alpha_lower, is_alpha_upper);\n\n            if (!svptest_all(pg, is_alpha)) {\n                has_non_alpha = true;\n                break;\n            }\n\n            // Determine case for alphabetic characters\n            if (!initialized) {\n                svbool_t any_alpha = svorr_b_z(pg, is_alpha_lower, is_alpha_upper);\n                if (svptest_any(pg, any_alpha)) {\n                    first_case = svlastb_u8(is_alpha_lower, chars) >= 'a' ? 1 : 2;\n                    initialized = true;\n                }\n            } else {\n                svbool_t is_lower = svand_b_z(pg, is_alpha, svcmpge_u8(pg, chars, svdup_n_u8('a')));\n                svbool_t is_upper = svand_b_z(pg, is_alpha, svcmple_u8(pg, chars, svdup_n_u8('Z')));\n                if (first_case == 1 && svptest_any(pg, is_upper)) {\n                    return false;\n                }\n                if (first_case == 2 && svptest_any(pg, is_lower)) {\n                    return false;\n                }\n            }\n\n            j += chunk_size;\n        }\n\n        if (has_non_alpha) {\n            return false;\n        }\n    }\n\n    return initialized && !has_non_alpha;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Vectors to store keys for batch processing\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    size_t n = keys.size();\n    size_t vector_length = svcntb(); // Number of bytes in a vector\n    svbool_t pg = svptrue_b8(); // Predicate for full vector\n\n    size_t i = 0;\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Process keys in chunks based on vector length\n    while (i < n) {\n        size_t remaining = n - i;\n        size_t chunk_size = std::min(remaining, vector_length);\n        svbool_t chunk_pg = svwhilelt_b8(i, i + chunk_size);\n\n        // Initialize vectors for checking case\n        svuint8_t vec_chars = svdup_n_u8(0);\n        svbool_t is_lower_vec = svdup_b8(false);\n        svbool_t is_upper_vec = svdup_b8(false);\n        svbool_t is_alpha_vec = svdup_b8(false);\n\n        // Load characters from current chunk of keys\n        for (size_t j = 0; j < chunk_size && i + j < n; ++j) {\n            std::string key = keys[i + j];\n            if (!key.empty()) {\n                char c = key[0]; // Check first character of each key\n                vec_chars = svinsr_n_u8(vec_chars, j, static_cast<uint8_t>(c));\n\n                bool is_alpha = (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n                is_alpha_vec = svinsr_n_b8(is_alpha_vec, j, is_alpha);\n                if (is_alpha) {\n                    bool is_lower = (c >= 'a' && c <= 'z');\n                    bool is_upper = (c >= 'A' && c <= 'Z');\n                    is_lower_vec = svinsr_n_b8(is_lower_vec, j, is_lower);\n                    is_upper_vec = svinsr_n_b8(is_upper_vec, j, is_upper);\n                }\n            }\n        }\n\n        // Check if all alphabetic characters in chunk are lowercase or uppercase\n        svbool_t all_alpha_lower = svand_b_z(pg, is_alpha_vec, is_lower_vec);\n        svbool_t all_alpha_upper = svand_b_z(pg, is_alpha_vec, is_upper_vec);\n\n        // If any alphabetic character is not lowercase, all_lower is false\n        if (svptest_any(pg, svnot_b_z(pg, all_alpha_lower))) {\n            all_lower = false;\n        }\n        // If any alphabetic character is not uppercase, all_upper is false\n        if (svptest_any(pg, svnot_b_z(pg, all_alpha_upper))) {\n            all_upper = false;\n        }\n\n        // If any character is alphabetic and neither all_lower nor all_upper holds, return false\n        if (svptest_any(pg, is_alpha_vec) && !all_lower && !all_upper) {\n            return false;\n        }\n\n        i += chunk_size;\n    }\n\n    // If no alphabetic characters were found, return false\n    if (all_lower == all_upper) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t n = dict.size();\n    std::vector<char> first_chars(n);\n\n    size_t i = 0;\n    for (const auto& pair : dict) {\n        if (!pair.first.empty()) {\n            first_chars[i] = pair.first[0];\n        } else {\n            return false;\n        }\n        i++;\n    }\n\n    bool has_lower = false;\n    bool has_upper = false;\n    bool has_non_alpha = false;\n\n    for (i = 0; i < n; i += vec_len) {\n        svbool_t active = svwhilelt_b8(i, n);\n        svuint8_t chars_vec = svld1_u8(active, reinterpret_cast<uint8_t*>(&first_chars[i]));\n\n        svbool_t is_lower = svand_b_z(pg, svcmplt_u8(pg, chars_vec, svdup_u8('z')), svcmpge_u8(pg, chars_vec, svdup_u8('a')));\n        svbool_t is_upper = svand_b_z(pg, svcmplt_u8(pg, chars_vec, svdup_u8('Z')), svcmpge_u8(pg, chars_vec, svdup_u8('A')));\n        svbool_t is_alpha = svorr_b_z(pg, is_lower, is_upper);\n\n        if (svptest_any(pg, is_lower)) {\n            has_lower = true;\n        }\n        if (svptest_any(pg, is_upper)) {\n            has_upper = true;\n        }\n        if (svptest_any(pg, svnot_b_z(pg, is_alpha))) {\n            has_non_alpha = true;\n        }\n\n        if (has_lower && has_upper) {\n            return false;\n        }\n        if (has_non_alpha) {\n            return false;\n        }\n    }\n\n    return (has_lower || has_upper) && !has_non_alpha;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t lower_mask = svdup_u8(0);\n    svuint8_t upper_mask = svdup_u8(0);\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i < len) {\n            size_t remaining = len - i;\n            svbool_t active = svwhilelt_b8(i, len);\n            svuint8_t chars = svdup_u8(0);\n\n            for (size_t j = 0; j < remaining && j < svcntb(); ++j) {\n                if (i + j < len) {\n                    chars = svinsr_n_u8(chars, key[i + j], j);\n                }\n            }\n\n            svbool_t is_lower = svcmpeq_u8(active, svand_u8_z(active, chars, svdup_u8(0x20)), chars);\n            svbool_t is_upper = svcmpeq_u8(active, svand_u8_z(active, chars, svdup_u8(0x20)), svsub_u8_z(active, chars, svdup_u8(0x20)));\n\n            lower_mask = svorr_u8_z(active, lower_mask, svand_u8_z(active, svdup_u8(0xFF), is_lower));\n            upper_mask = svorr_u8_z(active, upper_mask, svand_u8_z(active, svdup_u8(0xFF), is_upper));\n\n            if (svptest_any(pg, is_lower)) {\n                has_lower = true;\n            }\n            if (svptest_any(pg, is_upper)) {\n                has_upper = true;\n            }\n\n            i += svcntb();\n        }\n\n        svbool_t has_digit = svpfalse_b();\n        i = 0;\n        while (i < len) {\n            size_t remaining = len - i;\n            svbool_t active = svwhilelt_b8(i, len);\n            svuint8_t chars = svdup_u8(0);\n\n            for (size_t j = 0; j < remaining && j < svcntb(); ++j) {\n                if (i + j < len) {\n                    chars = svinsr_n_u8(chars, key[i + j], j);\n                }\n            }\n\n            svbool_t is_digit = svand_b_z(active, svcmpge_u8(active, chars, svdup_u8('0')), svcmple_u8(active, chars, svdup_u8('9')));\n            has_digit = svorr_b_z(active, has_digit, is_digit);\n\n            if (svptest_any(pg, has_digit)) {\n                return false;\n            }\n\n            i += svcntb();\n        }\n    }\n\n    return (has_lower && !has_upper) || (has_upper && !has_lower);\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Allocate a boolean array to mark non-prime numbers (Sieve of Eratosthenes)\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SVE for marking multiples as non-prime\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    for (int i = 2; i < sqrt_n; i++) {\n        if (is_prime[i]) {\n            int64_t step = i;\n            int64_t start = i * step;\n            uint64_t vl = svcntw(); // Vector length for 32-bit elements\n            svbool_t pg = svwhilelt_b32(0, vl);\n\n            for (int64_t j = start; j < n; j += vl * step) {\n                svint32_t indices = svindex_s32(static_cast<int32_t>(j), static_cast<int32_t>(step));\n                svbool_t active = svwhilelt_b32_s32(0, svsub_n_s32(indices, n));\n                pg = svand_b_z(svptrue_b32(), active, pg);\n\n                svst1_s32(pg, &is_prime[0] + j, svdup_n_s32(0));\n            }\n        }\n    }\n\n    // Collect prime numbers into result vector\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Allocate a temporary array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Sieve of Eratosthenes with SVE\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    // Collect prime numbers using SVE for parallelism in checking\n    primes.reserve(n / 2); // Rough estimate to avoid frequent reallocations\n    for (int i = 0; i < n; i += vl) {\n        svbool_t active = svptrue_b32();\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t in_range = svcmplt_s32(pg, indices, n);\n\n        // Load the prime flags for the current vector\n        std::vector<int> temp(vl, 0);\n        for (uint64_t j = 0; j < vl && i + j < n; ++j) {\n            temp[j] = is_prime[i + j] ? 1 : 0;\n        }\n        svint32_t prime_flags = svld1_s32(active, temp.data());\n        svbool_t is_prime_vec = svcmpne_s32(pg, prime_flags, 0);\n\n        // Combine range check and prime check\n        svbool_t store_mask = svand_b_z(pg, in_range, is_prime_vec);\n\n        // Store results to temporary buffer and collect primes\n        std::vector<int> result(vl, 0);\n        svst1_s32(store_mask, result.data(), indices);\n        for (uint64_t j = 0; j < vl && i + j < n; ++j) {\n            if (result[j] != 0 && is_prime[i + j]) {\n                primes.push_back(i + j);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Allocate array for numbers 2 to n-1\n    int max_size = n - 2;\n    std::vector<int> candidates(max_size);\n    for (int i = 0; i < max_size; i++) {\n        candidates[i] = i + 2;\n    }\n\n    // Create SVE vector length\n    int64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Process numbers in vectorized chunks\n    for (int i = 2; i * i < n; i++) {\n        if (candidates[i - 2] == 0) continue;\n\n        // Create vector of i for comparison\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t vec_i_squared = svmul_n_s32_x(pg, vec_i, i);\n\n        // Process candidates in vectorized chunks\n        for (int j = 0; j < max_size; j += vl) {\n            // Load candidates\n            svint32_t vec_candidates = svld1_s32(pg, &candidates[j]);\n            \n            // Create index vector for multiples\n            svint32_t vec_idx = svindex_s32(j + 2, 1);\n            \n            // Check if numbers are multiples of i\n            svint32_t vec_mod = svmul_n_s32_x(pg, vec_i, svdiv_n_s32_x(pg, vec_idx, vec_i));\n            svbool_t is_multiple = svcmpeq_s32(pg, vec_idx, vec_mod);\n            \n            // Zero out multiples\n            vec_candidates = svsel_s32(is_multiple, svdup_n_s32(0), vec_candidates);\n            \n            // Store back results\n            svst1_s32(pg, &candidates[j], vec_candidates);\n        }\n    }\n\n    // Collect non-zero (prime) numbers\n    for (int i = 0; i < max_size; i++) {\n        if (candidates[i] != 0) {\n            result.push_back(candidates[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Allocate a boolean array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    for (int i = 2; i < sqrt_n; ++i) {\n        if (is_prime[i]) {\n            int step = i * i;\n            while (step < n) {\n                is_prime[step] = false;\n                step += i;\n            }\n        }\n    }\n\n    // Use SVE to gather prime numbers\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n    std::vector<int> primes;\n    primes.reserve(n / 2); // Rough estimate to avoid frequent reallocations\n\n    for (int i = 2; i < n; i += vl) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t mask = svcmplt_s32(pg, indices, n);\n        svint32_t values = svld1_s32(mask, &is_prime[i]);\n        svbool_t prime_mask = svcmpne_s32(mask, values, 0);\n\n        // Store indices of primes\n        int count = svcntp_b32(mask, prime_mask);\n        if (count > 0) {\n            std::vector<int> temp(vl);\n            svst1_s32(mask, temp.data(), indices);\n            for (int j = 0; j < vl && i + j < n; ++j) {\n                if (is_prime[i + j]) {\n                    primes.push_back(i + j);\n                }\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Allocate a boolean array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SVE for sieve of Eratosthenes\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    for (int i = 2; i < sqrt_n; ++i) {\n        if (is_prime[i]) {\n            int step = i * 2;\n            uint64_t vl = svcntw();\n            svbool_t pg = svptrue_b32();\n            svint32_t vec_step = svdup_s32(i);\n            svint32_t vec_idx;\n\n            for (int j = step; j < n; j += vl * i) {\n                vec_idx = svindex_s32(j, i);\n                svbool_t mask = svwhilelt_b32_s32(j, n);\n                pg = svand_b_z(svptrue_b32(), mask, pg);\n\n                while (svptest_any(svptrue_b32(), pg)) {\n                    svst1_s32(pg, &is_prime[0] + j, svdup_s32(0));\n                    j += vl * i;\n                    vec_idx = svadd_s32_z(pg, vec_idx, svmul_s32_z(pg, vec_step, svdup_s32(vl)));\n                    mask = svwhilelt_b32_s32(j, n);\n                    pg = svand_b_z(svptrue_b32(), mask, pg);\n                }\n            }\n        }\n    }\n\n    // Collect prime numbers into result vector\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    const char *ptr = s.c_str();\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)ptr);\n        \n        // Check even indices\n        svbool_t even_mask = svzip1_b8(svpfalse_b(), svptrue_b8());\n        svbool_t valid_even = svand_b_z(svptrue_b8(), pg, even_mask);\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        svbool_t is_A = svcmpeq_n_u8(valid_even, vec, 'A');\n        svbool_t is_E = svcmpeq_n_u8(valid_even, vec, 'E');\n        svbool_t is_I = svcmpeq_n_u8(valid_even, vec, 'I');\n        svbool_t is_O = svcmpeq_n_u8(valid_even, vec, 'O');\n        svbool_t is_U = svcmpeq_n_u8(valid_even, vec, 'U');\n        \n        // Combine vowel checks\n        svbool_t is_vowel = svorr_b_z(svptrue_b8(), is_A, is_E);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_I);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_O);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_U);\n        \n        // Count matches\n        count += svcntp_b8(is_vowel);\n        \n        // Move to next vector\n        ptr += svcntb();\n        pg = svwhilelt_b8(ptr - s.c_str(), s.length());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string &s) {\n    const char *str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t *)(str + i));\n        svbool_t even_mask = svptrue_b8();\n        if (i % 2 == 0) {\n            even_mask = svand_b_z(svptrue_b8(), pg, svcmpeq_u8(pg, svand_u8_z(pg, svcntb(), svdup_u8(i)), svdup_u8(0)));\n        }\n\n        svbool_t upper_mask = svand_b_z(pg, svcmplt_u8(pg, vec, svdup_u8('Z')), svcmpgt_u8(pg, vec, svdup_u8('A')));\n        svbool_t vowel_mask = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svcmpeq_u8(pg, vec, svdup_u8('A')),\n                svcmpeq_u8(pg, vec, svdup_u8('E'))),\n            svorr_b_z(pg,\n                svcmpeq_u8(pg, vec, svdup_u8('I')),\n                svorr_b_z(pg,\n                    svcmpeq_u8(pg, vec, svdup_u8('O')),\n                    svcmpeq_u8(pg, vec, svdup_u8('U')))));\n\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, even_mask, upper_mask), vowel_mask);\n        count += svcntp_b8(pg, final_mask);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string &s) {\n    const char *str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    // Vector length in bytes\n    uint64_t vl = svcntb();\n    svbool_t pg = svwhilelt_b8(0, vl);\n\n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of characters\n        svint8_t vec = svld1_s8(pg, &str[i]);\n\n        // Create masks for even indices\n        svbool_t even_mask = svptrue_b8();\n        for (int j = 1; j < vl; j += 2) {\n            even_mask = svbic_b_z(pg, even_mask, svwhilelt_b8(j, j + 1));\n        }\n\n        // Check for uppercase letters (A-Z)\n        svbool_t upper_mask = svand_b_z(pg, svcmpge_b8(pg, vec, 'A'), svcmple_b8(pg, vec, 'Z'));\n\n        // Check for vowels (A, E, I, O, U)\n        svbool_t vowel_mask = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_b8(pg, vec, 'A'),\n                    svcmpeq_b8(pg, vec, 'E')),\n                svorr_b_z(pg,\n                    svcmpeq_b8(pg, vec, 'I'),\n                    svcmpeq_b8(pg, vec, 'O'))),\n            svcmpeq_b8(pg, vec, 'U'));\n\n        // Combine masks: even indices, uppercase, and vowels\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, even_mask, upper_mask), vowel_mask);\n\n        // Count the number of true predicates in the mask\n        count += svcntp_b8(pg, final_mask);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        if (i < len && str[i] >= 'A' && str[i] <= 'Z' &&\n            (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' ||\n             str[i] == 'O' || str[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string &s) {\n    const char *str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        svint8_t vec = svld1_s8(pg, &str[i]);\n        svbool_t even_mask = svptrue_b8();\n        if (i % 2 != 0) {\n            even_mask = svnot_b_z(pg, even_mask);\n        }\n\n        svbool_t upper_mask = svand_b_z(pg, svcmplt_s8(pg, vec, 'A'), svcmpgt_s8(pg, vec, 'Z'));\n        svbool_t vowel_mask = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svcmpeq_s8(pg, vec, 'A'),\n                svcmpeq_s8(pg, vec, 'E')),\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_s8(pg, vec, 'I'),\n                    svcmpeq_s8(pg, vec, 'O')),\n                svcmpeq_s8(pg, vec, 'U')));\n\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, even_mask, upper_mask), vowel_mask);\n        count += svcntp_b8(pg, final_mask);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string &s) {\n    const char *str = s.c_str();\n    size_t len = s.length();\n    int count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t *)(str + i));\n\n        // Check for even indices using a mask (0,1,0,1,...)\n        svbool_t even_mask = svzip1_b8(svpfalse_b(), svptrue_b8());\n        even_mask = svunpklo_b8(even_mask);\n\n        // Check for uppercase letters (A-Z)\n        svbool_t upper_mask = svand_b_z(pg, svcmpge_n_u8(pg, vec, 'A'), svcmple_n_u8(pg, vec, 'Z'));\n\n        // Check for vowels (A, E, I, O, U)\n        svbool_t vowel_mask = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_n_u8(pg, vec, 'A'),\n                    svcmpeq_n_u8(pg, vec, 'E')),\n                svorr_b_z(pg,\n                    svcmpeq_n_u8(pg, vec, 'I'),\n                    svcmpeq_n_u8(pg, vec, 'O'))),\n            svcmpeq_n_u8(pg, vec, 'U'));\n\n        // Combine masks: even indices, uppercase, and vowels\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, even_mask, upper_mask), vowel_mask);\n\n        // Count the number of true predicates in the mask\n        count += svcntp_b8(pg, final_mask);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        if (i < len && str[i] >= 'A' && str[i] <= 'Z' &&\n            (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' ||\n             str[i] == 'O' || str[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t vec_n = svdup_s32(n);\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    int i = 0;\n    for (; i <= n - vl; i += vl) {\n        // Create index vector for current chunk\n        svint32_t indices = svadd_s32_z(pg, svindex_s32(i, 1), svdup_s32(1));\n        // Compute stones: n + 2 * index for even/odd progression\n        svint32_t stones = svadd_s32_z(pg, vec_n, svmul_s32_z(pg, indices, svdup_s32(2)));\n        // Adjust based on parity of n\n        svint32_t adjustment = svand_s32_z(pg, vec_n, svdup_s32(1));\n        svint32_t final_stones = svadd_s32_z(pg, stones, svsub_s32_z(pg, adjustment, svdup_s32(1)));\n        // Store results\n        svst1_s32(pg, &result[i], final_stones);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < n; ++i) {\n        result[i] = n + 2 * (i + 1);\n        if (n % 2 == 0) {\n            result[i] -= 1;\n        }\n    }\n\n    // Adjust first level to be exactly n\n    result[0] = n;\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize first level with n stones\n    result[0] = n;\n    \n    // Determine if n is odd or even to set the step (1 or 2)\n    int step = (n % 2 == 0) ? 2 : 1;\n    int base = n;\n    \n    // Process elements in chunks based on vector length\n    for (int i = 1; i < n; i += vl) {\n        // Create a predicate for the current chunk\n        svbool_t active_pg = svptrue_b32();\n        if (i + vl > n) {\n            active_pg = svwhilelt_b32(i, n);\n        }\n        \n        // Create a vector of indices for the current chunk\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Compute the number of stones for each level in the chunk\n        svint32_t stones = svadd_n_s32_z(active_pg, indices, base);\n        stones = svadd_n_s32_z(active_pg, stones, step);\n        \n        // Store the results back to the vector\n        svst1_s32(active_pg, &result[i], stones);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    \n    // Process in vector-sized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector for indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Calculate values: n + 2*i for i = 0,1,2,...\n        svint32_t values = svadd_n_s32_x(pg, svmul_n_s32_x(pg, indices, 2), base);\n        \n        // Store results\n        int remaining = std::min(svcntw(), n - i);\n        svbool_t store_mask = svwhilelt_b32(i, n);\n        svst1_s32(store_mask, result.data() + i, values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    \n    // Process elements in vectorized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create index vector for current chunk\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Compute values: n + 2*i for each level\n        svint32_t values = svadd_n_s32_x(pg, indices, base);\n        svint32_t twos = svdup_n_s32(2);\n        svint32_t level_values = svmla_n_s32_x(pg, values, indices, 2);\n        \n        // Store results\n        svst1_s32(pg, result.data() + i, level_values);\n        \n        // Update predicate for remaining elements\n        if (i + svcntw() > n) {\n            pg = svwhilelt_b32(i, n);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    svint32_t v_base = svdup_s32(base);\n    svint32_t v_inc = svindex_s32(0, 1);\n    svint32_t v_n = svadd_s32_z(pg, v_base, v_inc);\n    svint32_t v_mask = svdup_s32(1);\n    svint32_t v_odd_even = svand_s32_z(pg, v_n, v_mask);\n    svint32_t v_adjust = svadd_s32_z(pg, v_n, v_odd_even);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svst1_s32(p, &result[i], svadd_s32_z(p, v_adjust, svdup_s32(i)));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    \n    // Create vector of numbers from n to m\n    svint64_t vec = svindex_s64(n, 1);\n    \n    // Sum all numbers in vector\n    int64_t sum = svaddv_s64(pg, vec);\n    \n    // Calculate rounded average\n    int64_t avg = (sum + (count >> 1)) / count;\n    \n    // Convert to binary string\n    std::string binary = \"\";\n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec = svindex_s64(n, 1);\n    \n    // Sum the sequence using SVE\n    int64_t sum = 0;\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t active_vec = svsel_s64(pg, vec, svdup_s64(0));\n        sum = svaddv_s64(pg, active_vec);\n        \n        // Advance the vector\n        vec = svadd_s64_z(svptrue_b64(), vec, svdup_s64(svcntd()));\n        pg = svwhilelt_b64(svaddv_s64(svptrue_b64(), vec, -m - 1), m + 1);\n    }\n    \n    // Calculate rounded average\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    std::string binary = \"\";\n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    if (count == 0) {\n        return \"-1\";\n    }\n\n    // Use SVE to compute sum in parallel\n    int64_t sum = 0;\n    int64_t i = n;\n    uint64_t vl = svcntd(); // Get vector length for 64-bit elements\n    svbool_t pg = svwhilelt_b64(i, m + 1); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec = svadd_x(pg, svld1_s64(pg, &i), svindex_s64(0, 1));\n        sum += svaddv_s64(pg, vec);\n        i += vl;\n        pg = svwhilelt_b64(i, m + 1);\n    }\n\n    // Compute average and round to nearest smaller integer\n    int64_t avg = sum / count;\n\n    // Convert to binary\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t len = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec = svindex_s64(n, 1);\n    \n    int64_t sum = svaddv_s64(pg, vec);\n    int64_t avg = (sum + (len >> 1)) / len;\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    if (count == 0) {\n        return \"-1\";\n    }\n\n    // Use SVE to compute sum in parallel\n    int64_t sum = 0;\n    int64_t i = n;\n    uint64_t vl = svcntd(); // Get vector length for 64-bit elements\n    svbool_t pg = svptrue_b64(); // Predicate for all true\n\n    while (i <= m) {\n        // Create a vector of consecutive values starting from i\n        svint64_t vec = svindex_s64(i, 1);\n        // Create a predicate to mask values beyond m\n        svbool_t mask = svwhilele_b64_s64(i, m);\n        // Mask the vector to avoid summing beyond m\n        svint64_t masked_vec = svsel_s64(mask, vec, svdup_s64(0));\n        // Accumulate sum\n        sum += svaddv_s64(pg, masked_vec);\n        i += vl;\n    }\n\n    // Compute average and round to nearest smaller integer\n    int64_t avg = sum / count;\n\n    // Convert to binary\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += vl) {\n        svbool_t active = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t values = svadd_s32_z(active, indices, 1);\n        \n        // Compute factorial for even indices and sum for odd indices\n        svint32_t is_even = svcmpeq_s32(active, svand_s32_z(active, values, 1), 0);\n        svint32_t factorial = svdup_s32(1);\n        svint32_t sum_val = svdup_s32(0);\n        \n        // Temporary vector for loop computation\n        svint32_t temp = svdup_s32(1);\n        svint32_t one_to_i = svdup_s32(1);\n        \n        // Compute factorial for even indices\n        for (int j = 1; j <= 20; ++j) { // Limit to prevent overflow\n            one_to_i = svadd_s32_z(active, one_to_i, 1);\n            svbool_t cond = svand_b_z(active, is_even, svcmple_s32(active, one_to_i, values));\n            temp = svmul_s32_m(cond, temp, one_to_i);\n            factorial = svsel_s32(cond, temp, factorial);\n        }\n        factorial = svmod_s32_z(active, factorial, 10000);\n        \n        // Compute sum for odd indices\n        temp = svdup_s32(0);\n        one_to_i = svdup_s32(1);\n        for (int j = 1; j <= 20; ++j) {\n            one_to_i = svadd_s32_z(active, one_to_i, 1);\n            svbool_t cond = svand_b_z(active, svnot_b_z(active, is_even), svcmple_s32(active, one_to_i, values));\n            temp = svadd_s32_m(cond, temp, one_to_i);\n            sum_val = svsel_s32(cond, temp, sum_val);\n        }\n        \n        // Combine results based on even/odd condition\n        svint32_t result_vec = svsel_s32(is_even, factorial, sum_val);\n        \n        // Store results to memory\n        svst1_s32(active, &result[i], result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Compute factorial for even indices and sum for odd indices\n        svuint32_t values = svdup_u32(1);\n        svuint32_t temp = svdup_u32(1);\n        svuint32_t one = svdup_u32(1);\n        \n        // Compute for each index\n        for (uint32_t j = 1; j <= n; j++) {\n            svbool_t even_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, indices, 1), 0);\n            \n            // Update factorial for even indices\n            svuint32_t fact_term = svmul_u32_z(even_mask, temp, svdup_u32(j));\n            temp = svsel_u32(even_mask, fact_term, temp);\n            \n            // Update sum for odd indices\n            svuint32_t sum_term = svadd_u32_z(pg, values, svdup_u32(j));\n            values = svsel_u32(sveor_b_z(pg, even_mask, even_mask), sum_term, values);\n        }\n        \n        // Apply modulo 10000 for factorial results\n        svuint32_t mod_mask = svcmplt_n_u32(pg, indices, 6);\n        svuint32_t modulo = svsel_u32(mod_mask, svmod_n_u32_z(pg, temp, 10000), temp);\n        \n        // Store results\n        svst1_u32(pg, &result[i], modulo);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n\n        // Compute factorial for even indices and sum for odd indices\n        svbool_t even_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, indices, 1), 0);\n        \n        // Initialize results\n        svuint32_t vec_result = svdup_n_u32(1);\n\n        // Factorial for even indices\n        svuint32_t fact = svdup_n_u32(1);\n        svuint32_t counter = svdup_n_u32(1);\n        svuint32_t max_i = svmin_n_u32_x(pg, indices, svdup_n_u32(20)); // Prevent overflow\n\n        while (svptest_any(svptrue_b32(), svcmple_n_u32(pg, counter, max_i))) {\n            fact = svmul_u32_m(even_mask, fact, counter);\n            counter = svadd_n_u32_x(pg, counter, 1);\n        }\n        fact = svmod_n_u32_x(pg, fact, 10000);\n\n        // Sum for odd indices\n        svuint32_t sum = svadd_n_u32_m(svptrue_b32(), svmul_u32_x(pg, indices, svadd_n_u32_x(pg, indices, 1)), 1);\n        sum = svlsr_n_u32_x(pg, sum, 1);\n\n        // Combine results\n        vec_result = svsel_u32(even_mask, fact, sum);\n\n        // Store results\n        svst1_u32(pg, &result[i], vec_result);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if ((i + 1) % 2 == 0) {\n            unsigned long long fact = 1;\n            for (int j = 1; j <= i + 1 && j <= 20; j++) {\n                fact *= j;\n            }\n            result[i] = fact % 10000;\n        } else {\n            int k = i + 1;\n            result[i] = (k * (k + 1ULL)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Calculate factorial for even indices and sum for odd indices\n        svuint32_t values = svdup_u32(1);\n        svuint32_t temp = svdup_u32(1);\n        \n        // Compute factorials and sums iteratively\n        for (uint32_t j = 1; j <= n; j++) {\n            svbool_t even_mask = svcmpeq_u32(pg, svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n            svbool_t odd_mask = svnot_b_z(pg, even_mask);\n            \n            // Update factorial for even indices\n            svuint32_t j_vec = svdup_u32(j);\n            temp = svsel_u32(even_mask, \n                            svmul_u32_z(pg, temp, j_vec),\n                            temp);\n            \n            // Update sum for odd indices\n            values = svsel_u32(odd_mask,\n                              svadd_u32_z(pg, values, j_vec),\n                              values);\n        }\n        \n        // Apply modulo 10000 for even indices\n        values = svsel_u32(even_mask,\n                          svmod_u32_z(pg, temp, svdup_u32(10000)),\n                          values);\n        \n        // Store results\n        svst1_u32(pg, &result[i], values);\n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (int i = 0; i < n; i += vl) {\n        svbool_t active = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t values = svaddv_s32(active, indices, 1);\n\n        svbool_t even_mask = svcmpeq_s32(active, svand_s32_z(active, values, 1), 0);\n        svint32_t factorial = svdup_s32(1);\n        svint32_t sum = svdup_s32(0);\n\n        for (int j = 1; j <= i + vl; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svbool_t update_mask = svcmple_s32(active, j_vec, values);\n            factorial = svmul_s32_m(update_mask, factorial, j_vec);\n            factorial = svmod_s32_m(update_mask, factorial, 10000);\n            sum = svadd_s32_m(update_mask, sum, j_vec);\n        }\n\n        svint32_t result_vec = svsel_s32(even_mask, factorial, sum);\n        svst1_s32(active, &result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process single digits (1-9)\n    for (int i = 1; i <= 9 && i <= n; i++) {\n        if (i % 2 == 0) even_count++;\n        else odd_count++;\n    }\n    \n    // Process two-digit numbers\n    if (n >= 10) {\n        svint32_t vec = svindex_s32(11, 11);\n        svint32_t ten = svdup_s32(10);\n        svint32_t hundred = svdup_s32(100);\n        \n        while (svcmpgt(pg, svdup_s32(n), vec)) {\n            svbool_t active = svcmpgt(pg, svdup_s32(n), vec);\n            svint32_t digits = svdiv_s32_z(active, vec, ten);\n            svint32_t rev = svmul_s32_z(active, digits, ten);\n            svint32_t is_palindrome = svcmpeq_s32(active, vec, rev);\n            \n            svint32_t is_even = svand_s32_z(active, vec, svdup_s32(1));\n            svint32_t even_mask = svcmpeq_s32(active, is_even, svdup_s32(0));\n            svint32_t odd_mask = svcmpeq_s32(active, is_even, svdup_s32(1));\n            \n            even_count += svcntp_b32(active, svand_b_z(pg, is_palindrome, even_mask));\n            odd_count += svcntp_b32(active, svand_b_z(pg, is_palindrome, odd_mask));\n            \n            vec = svadd_s32_z(pg, vec, svdup_s32(11));\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svwhilelt_b32(1, n + 1);\n    \n    for (int i = 1; i <= n; i += svcntw()) {\n        svbool_t ptrue = svwhilelt_b32(i, n + 1);\n        svuint32_t vec = svindex_u32(i, 1);\n        \n        // Reverse digits\n        svuint32_t rev = svdup_u32(0);\n        svuint32_t temp = vec;\n        while (svptest_any(svptrue_b32(), svcmpgt_n_u32(ptrue, temp, 0))) {\n            svuint32_t digit = svmod_n_u32(ptrue, temp, 10);\n            rev = svmad_u32_m(ptrue, rev, svdup_u32(10), digit);\n            temp = svdiv_n_u32_m(ptrue, temp, 10);\n        }\n        \n        // Check palindrome\n        svbool_t is_palindrome = svcmpeq_u32(ptrue, vec, rev);\n        \n        // Check even/odd\n        svbool_t is_even = svcmpeq_n_u32(ptrue, svmod_n_u32(ptrue, vec, 2), 0);\n        svbool_t is_odd = svnot_b_z(ptrue, is_even);\n        \n        // Count even and odd palindromes\n        even_count += svcntp_b32(is_palindrome & is_even);\n        odd_count += svcntp_b32(is_palindrome & is_odd);\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int i = 1;\n    svbool_t pg = svptrue_b32();\n    const int vector_size = svcntw();\n\n    while (i <= n) {\n        int remaining = n - i + 1;\n        int step = (remaining < vector_size) ? remaining : vector_size;\n        svbool_t active = svwhilelt_b32(i, i + step);\n        svint32_t vec_i = svindex_s32(i, 1);\n\n        // Convert numbers to strings to check for palindromes\n        // Since direct string operations are not feasible with SVE,\n        // we will use a simplified check for single and two-digit numbers\n        // For simplicity, focusing on numbers up to 2^10, we handle up to 3 digits\n        svint32_t is_palindrome = svdup_n_s32(0);\n        svint32_t num = vec_i;\n\n        // Extract digits for numbers up to 3 digits\n        svint32_t d1 = svdiv_n_s32(num, 100);\n        svint32_t temp = svmls_n_s32(num, d1, 100);\n        svint32_t d2 = svdiv_n_s32(temp, 10);\n        svint32_t d3 = svmls_n_s32(temp, d2, 10);\n\n        // Check palindrome for 1-digit (always true)\n        svbool_t one_digit = svcmplt_s32(active, num, 10);\n        is_palindrome = svsel_s32(one_digit, svdup_n_s32(1), is_palindrome);\n\n        // Check palindrome for 2-digit (d2 == d3)\n        svbool_t two_digit = svand_b_z(pg, svcmpge_s32(active, num, 10), svcmplt_s32(active, num, 100));\n        svbool_t pal_2d = svcmpeq_s32(two_digit, d2, d3);\n        is_palindrome = svsel_s32(two_digit, svand_s32_z(pg, is_palindrome, svdup_n_s32(1)), is_palindrome);\n        is_palindrome = svsel_s32(pal_2d, svdup_n_s32(1), is_palindrome);\n\n        // Check palindrome for 3-digit (d1 == d3)\n        svbool_t three_digit = svcmpge_s32(active, num, 100);\n        svbool_t pal_3d = svcmpeq_s32(three_digit, d1, d3);\n        is_palindrome = svsel_s32(three_digit, svand_s32_z(pg, is_palindrome, svdup_n_s32(1)), is_palindrome);\n        is_palindrome = svsel_s32(pal_3d, svdup_n_s32(1), is_palindrome);\n\n        // Check even/odd\n        svbool_t is_even = svcmpeq_s32(active, svand_s32_z(pg, num, svdup_n_s32(1)), 0);\n\n        // Count even and odd palindromes\n        svint32_t even_pal = svand_s32_z(pg, is_palindrome, svsel_s32(is_even, svdup_n_s32(1), svdup_n_s32(0)));\n        svint32_t odd_pal = svand_s32_z(pg, is_palindrome, svsel_s32(is_even, svdup_n_s32(0), svdup_n_s32(1)));\n\n        even_count += svaddv_s32(active, even_pal);\n        odd_count += svaddv_s32(active, odd_pal);\n\n        i += step;\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    int i = 1;\n    \n    // Determine vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n + 1);\n    \n    while (i <= n) {\n        // Create a vector of indices starting from i\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t active = svwhilelt_b32(i, n + 1);\n        \n        // Check if numbers are palindromes (for single-digit and two-digit numbers in range)\n        svint32_t rev_indices = svdup_n_s32(0);\n        svbool_t is_palindrome = svdup_b32(false);\n        \n        // For numbers up to 2^10, handle single and two-digit palindromes\n        // Single-digit numbers are always palindromes\n        svbool_t single_digit = svcmplt_s32(active, indices, 10);\n        is_palindrome = svorr_b_z(pg, is_palindrome, single_digit);\n        \n        // Two-digit palindromes (e.g., 11, 22, ..., 99)\n        svbool_t two_digit = svcmpge_s32(active, indices, 10);\n        svbool_t two_digit_pal = svdup_b32(false);\n        svint32_t tens = svdiv_n_s32_z(active, indices, 10);\n        svint32_t units = svsub_s32_z(active, indices, svmul_n_s32_z(active, tens, 10));\n        two_digit_pal = svcmpeq_s32(active, tens, units);\n        two_digit_pal = svand_b_z(pg, two_digit_pal, two_digit);\n        is_palindrome = svorr_b_z(pg, is_palindrome, two_digit_pal);\n        \n        // Check for even and odd numbers\n        svbool_t is_even = svcmpeq_s32(active, svand_n_s32_z(active, indices, 1), 0);\n        svbool_t is_odd = svcmpne_s32(active, svand_n_s32_z(active, indices, 1), 0);\n        \n        // Count even and odd palindromes in the current vector\n        svbool_t even_pal = svand_b_z(pg, is_palindrome, is_even);\n        svbool_t odd_pal = svand_b_z(pg, is_palindrome, is_odd);\n        \n        even_count += svcntp_b32(pg, even_pal);\n        odd_count += svcntp_b32(pg, odd_pal);\n        \n        // Move to the next set of numbers\n        i += vl;\n        pg = svwhilelt_b32(i, n + 1);\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int i = 1;\n    \n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers in chunks based on vector length\n    while (i <= n) {\n        // Create a vector of indices to check for palindromes\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t active = svwhilelt_b32_s32(i, n + 1);\n        active = svand_b_z(pg, active, pg);\n        \n        // Convert numbers to strings or check palindrome property\n        // Since direct string operations are not feasible in SVE, we use a digit-based approach\n        svint32_t num = indices;\n        svint32_t reversed = svdup_n_s32(0);\n        svint32_t temp = num;\n        \n        // Reverse the number using digit extraction\n        while (svptest_any(pg, svcmpgt_n_s32(pg, temp, 0))) {\n            svint32_t digit = svmod_n_s32(pg, temp, 10);\n            reversed = svmad_n_s32(pg, reversed, 10, digit);\n            temp = svdiv_n_s32(pg, temp, 10);\n        }\n        \n        // Check if the number is a palindrome\n        svbool_t is_palindrome = svcmpeq_s32(pg, num, reversed);\n        \n        // Check if the number is even\n        svbool_t is_even = svcmpeq_s32(pg, svmod_n_s32(pg, num, 2), 0);\n        \n        // Combine conditions for even and odd palindromes\n        svbool_t even_palindrome = svand_b_z(pg, is_palindrome, is_even);\n        svbool_t odd_palindrome = svand_b_z(pg, is_palindrome, svnot_b_z(pg, is_even));\n        \n        // Count the number of even and odd palindromes in this vector\n        even_count += svcntp_b32(pg, even_palindrome);\n        odd_count += svcntp_b32(pg, odd_palindrome);\n        \n        i += vl;\n    }\n    \n    // Handle any remaining elements if n is not a multiple of vector length\n    for (; i <= n; ++i) {\n        int num = i;\n        int reversed = 0;\n        int temp = num;\n        while (temp > 0) {\n            reversed = reversed * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (num == reversed) {\n            if (num % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n.size());\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &n[i]);\n        \n        // Initialize sum of digits\n        svint32_t sum = svdup_s32(0);\n        \n        // Process absolute values to handle negative numbers\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign = svcmplt_s32(pg, vec, svdup_s32(0));\n        \n        // First digit handling for negative numbers\n        svint32_t first_digit = abs_vec;\n        svbool_t non_zero = svcmpgt_s32(pg, abs_vec, svdup_s32(0));\n        \n        // Sum digits by repeatedly dividing by 10\n        while (svptest_any(svptrue_b32(), non_zero)) {\n            svint32_t digit = svmod_n_s32_z(pg, abs_vec, 10);\n            sum = svadd_s32_z(pg, sum, digit);\n            abs_vec = svdiv_n_s32_z(pg, abs_vec, 10);\n            non_zero = svcmpgt_s32(pg, abs_vec, svdup_s32(0));\n        }\n        \n        // Adjust first digit for negative numbers\n        svint32_t first_digit_neg = svneg_s32_m(sum, sign, svand_n_s32_z(pg, sum, 0xFF));\n        sum = svsub_s32_z(pg, sum, svand_n_s32_z(pg, sum, 0xFF));\n        sum = svadd_s32_z(pg, sum, first_digit_neg);\n        \n        // Count numbers where sum of digits > 0\n        svbool_t sum_gt_zero = svcmpgt_s32(pg, sum, svdup_s32(0));\n        count += svcntp_b32(sum_gt_zero);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n.size());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    size_t len = n.size();\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    while (i < len) {\n        // Determine how many elements we can process in this iteration\n        size_t remaining = len - i;\n        svbool_t active_pg = svwhilelt_b32(i, len);\n        \n        // Load the vector of integers\n        svint32_t vec = svld1_s32(active_pg, &n[i]);\n        \n        // Initialize sum of digits for each element\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t temp = vec;\n        \n        // Handle negative numbers by taking absolute value for digit extraction\n        svbool_t is_negative = svcmplt_s32(active_pg, vec, 0);\n        svint32_t abs_temp = svabs_s32_x(active_pg, temp);\n        \n        // Extract digits and compute their sum\n        while (svptest_any(active_pg, svcmpgt_s32(active_pg, abs_temp, 0))) {\n            svint32_t digit = svmod_s32_x(active_pg, abs_temp, 10);\n            sum_digits = svadd_s32_x(active_pg, sum_digits, digit);\n            abs_temp = svdiv_s32_x(active_pg, abs_temp, 10);\n        }\n        \n        // For negative numbers, adjust the first digit's sign\n        svint32_t first_digit = svmod_s32_x(active_pg, temp, 10);\n        svint32_t sign_adjust = svsel_s32(is_negative, svneg_s32_x(active_pg, first_digit), first_digit);\n        sum_digits = svadd_s32_x(active_pg, sum_digits, svsub_s32_x(active_pg, sign_adjust, first_digit));\n        \n        // Count elements where sum of digits > 0\n        svbool_t sum_gt_zero = svcmpgt_s32(active_pg, sum_digits, 0);\n        count += svcntp_b32(active_pg, sum_gt_zero);\n        \n        i += svcntw();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t len = n.size();\n    \n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    \n    while (i + vlen <= len) {\n        // Load vector of integers\n        svint32_t vec = svld1_s32(svptrue_b32(), &n[i]);\n        \n        // Initialize sum of digits\n        svint32_t sum = svdup_n_s32(0);\n        \n        // Process absolute values to handle negative numbers\n        svint32_t abs_vec = svabs_s32_z(svptrue_b32(), vec);\n        \n        // Calculate sum of digits\n        while (svptrue_b32()) {\n            svint32_t digits = svmod_n_s32_z(svptrue_b32(), abs_vec, 10);\n            sum = svadd_s32_z(svptrue_b32(), sum, digits);\n            abs_vec = svdiv_n_s32_z(svptrue_b32(), abs_vec, 10);\n            \n            // Break when all numbers are 0\n            if (svptest_any(svptrue_b32(), svcmpeq_n_s32(svptrue_b32(), abs_vec, 0)))\n                break;\n        }\n        \n        // For negative numbers, adjust first digit\n        svbool_t neg_mask = svcmplt_n_s32(svptrue_b32(), vec, 0);\n        svint32_t first_digit = svdiv_n_s32_z(svptrue_b32(), vec, 1000000000);\n        sum = svsub_s32_m(neg_mask, sum, svmul_n_s32_m(neg_mask, first_digit, 2));\n        \n        // Count numbers with sum > 0\n        svbool_t gt_zero = svcmpgt_n_s32(svptrue_b32(), sum, 0);\n        count += svcntp_b32(svptrue_b32(), gt_zero);\n        \n        i += vlen;\n    }\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        int abs_num = abs(num);\n        \n        while (abs_num > 0) {\n            sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        \n        if (num < 0) {\n            sum -= 2 * (num / 1000000000);\n        }\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t i = 0;\n    \n    // Get vector length in elements\n    int64_t vlen = svcntw();\n    \n    for (; i + vlen <= len; i += vlen) {\n        // Load vector\n        svint32_t vec = svld1_s32(svptrue_b32(), &n[i]);\n        \n        // Initialize sum of digits\n        svint32_t sum = svdup_n_s32(0);\n        \n        // Process digits\n        svint32_t temp = vec;\n        svbool_t pg = svptrue_b32();\n        \n        while (svptest_any(svptrue_b32(), pg)) {\n            // Get last digit\n            svint32_t digit = svdiv_n_s32_z(pg, temp, 10);\n            digit = svsub_s32_z(pg, temp, svmul_n_s32_z(pg, digit, 10));\n            sum = svadd_s32_z(pg, sum, svabs_s32_z(pg, digit));\n            \n            // Remove last digit\n            temp = svdiv_n_s32_z(pg, temp, 10);\n            pg = svwhilelt_b32_s32(0, svcntw());\n        }\n        \n        // Count elements where sum > 0\n        svbool_t mask = svcmpgt_s32(svptrue_b32(), sum, 0);\n        count += svcntp_b32(svptrue_b32(), mask);\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += abs(num % 10);\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pm = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pm, &n[i]);\n        \n        svint32_t abs_vec = svabs_s32_m(pg, vec, vec);\n        svint32_t sum = svdup_s32(0);\n        \n        // Process digits\n        svint32_t temp = abs_vec;\n        while (svptest_any(pg, svcmpne_n_s32(pg, temp, 0))) {\n            svint32_t digits = svmod_n_s32(pg, temp, 10);\n            sum = svadd_s32_m(pg, sum, digits);\n            temp = svdiv_n_s32(pg, temp, 10);\n        }\n        \n        // Adjust sum for negative numbers\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svint32_t first_digit = svdiv_n_s32(pg, abs_vec, svpow2_n_s32(pg, svclz_s32(pg, abs_vec)));\n        svint32_t neg_adjust = svneg_s32_m(neg_mask, first_digit, first_digit);\n        sum = svadd_s32_m(pg, sum, neg_adjust);\n        \n        // Count elements with sum > 0\n        svbool_t gt_zero = svcmpgt_n_s32(pg, sum, 0);\n        count += svcntp_b32(pm, gt_zero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N <= 1) return true;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Find the minimum element and its index\n    int min_val = arr[0];\n    size_t min_idx = 0;\n    for (size_t i = 1; i < N; ++i) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n\n    // Check if the array is sorted after rotation starting from min_idx\n    bool is_sorted = true;\n    for (size_t i = 0; i < N - 1; ++i) {\n        size_t curr_idx = (min_idx + i) % N;\n        size_t next_idx = (min_idx + i + 1) % N;\n        if (arr[curr_idx] > arr[next_idx]) {\n            is_sorted = false;\n            break;\n        }\n    }\n\n    if (is_sorted) return true;\n\n    // If not sorted with min at start, use SVE to check other rotations\n    // Load data into SVE vectors for comparison\n    size_t num_vectors = (N + vl - 1) / vl;\n    std::vector<svint32_t> vec_data(num_vectors);\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vl;\n        size_t end = std::min(start + vl, N);\n        svbool_t pred = svwhilelt_b32(start, end);\n        vec_data[i] = svld1_s32(pred, &arr[start]);\n    }\n\n    // Check for sorted order in a rotated manner using SVE\n    for (size_t shift = 1; shift < N; ++shift) {\n        is_sorted = true;\n        for (size_t i = 0; i < N - 1; ++i) {\n            size_t curr_idx = (shift + i) % N;\n            size_t next_idx = (shift + i + 1) % N;\n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    uint64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Load array into SVE vector\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Find min and max elements\n    int32_t min_val = svminv_s32(pg, vec);\n    int32_t max_val = svmaxv_s32(pg, vec);\n    \n    // Find indices of min and max\n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t min_mask = svcmpeq_s32(pg, vec, min_val);\n    svbool_t max_mask = svcmpeq_s32(pg, vec, max_val);\n    uint64_t min_idx = svlastb_s32(min_mask, indices);\n    uint64_t max_idx = svlastb_s32(max_mask, indices);\n    \n    // Check if array is already sorted\n    svint32_t vec_rotated = vec;\n    bool is_sorted = true;\n    for (uint64_t i = 0; i < len - 1; i++) {\n        svint32_t next_vec = svext_s32(vec_rotated, vec_rotated, 1);\n        svbool_t cmp = svcmplt_s32(pg, vec_rotated, next_vec);\n        if (!svptest_all(cmp)) {\n            is_sorted = false;\n            break;\n        }\n        vec_rotated = next_vec;\n    }\n    if (is_sorted) return true;\n    \n    // Check if min is at end and max is at start after rotation\n    if (min_idx == (max_idx + 1) % len) {\n        // Verify if rotation creates sorted array\n        svint32_t rotated = svext_s32(vec, vec, min_idx);\n        svbool_t sorted = svtrue_b32();\n        for (uint64_t i = 0; i < len - 1; i++) {\n            svint32_t next = svext_s32(rotated, rotated, 1);\n            sorted = svand_b_z(pg, sorted, svcmplt_s32(pg, rotated, next));\n            rotated = next;\n        }\n        return svptest_all(sorted);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N <= 1) return true;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Allocate temporary arrays for SVE processing\n    std::vector<int> diff(N);\n    std::vector<int> temp(N);\n\n    // Compute differences to check for non-decreasing order\n    for (size_t i = 0; i < N - 1; i++) {\n        diff[i] = arr[i + 1] - arr[i];\n    }\n    diff[N - 1] = arr[0] - arr[N - 1];\n\n    // Check all possible rotations using SVE\n    for (size_t shift = 0; shift < N; shift++) {\n        bool is_sorted = true;\n        size_t i;\n\n        // Process in chunks using SVE\n        for (i = 0; i + vl <= N; i += vl) {\n            svint32_t diff_vec = svld1_s32(pg, &diff[i]);\n            svbool_t neg_check = svcmplt_s32(pg, diff_vec, 0);\n            if (svptest_any(pg, neg_check)) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements\n        for (; i < N; i++) {\n            if (diff[i] < 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) {\n            return true;\n        }\n\n        // Perform one right shift on diff array\n        int last = diff[N - 1];\n        for (size_t j = N - 1; j > 0; j--) {\n            temp[j] = diff[j - 1];\n        }\n        temp[0] = last;\n\n        // Update diff array for next iteration\n        for (size_t j = 0; j < N; j++) {\n            diff[j] = temp[j];\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Load vector into SVE registers\n    svint32_t vec = svld1(pg, arr.data());\n    \n    // Find min and max positions\n    int min_val = arr[0], max_val = arr[0];\n    int min_pos = 0, max_pos = 0;\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_pos = i;\n        }\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n            max_pos = i;\n        }\n    }\n    \n    // Check if already sorted\n    bool sorted = true;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i-1]) {\n            sorted = false;\n            break;\n        }\n    }\n    if (sorted) return true;\n    \n    // Check if min is at end and max at start after rotation\n    int rot = (min_pos == 0) ? n - 1 : n - min_pos;\n    bool valid = true;\n    \n    // Use SVE to check if rotated array is sorted\n    svint32_t rotated = svtbl(vec, svsub_z(pg, svindex_u32(0, 1), svdup_u32(rot)));\n    \n    // Compare adjacent elements\n    svint32_t next = svtbl(vec, svsub_z(pg, svindex_u32(1, 1), svdup_u32(rot)));\n    svbool_t cmp = svcmplt(pg, rotated, next);\n    \n    // If any element is greater than next, not sorted\n    if (!svptest_all(cmp)) {\n        valid = false;\n    }\n    \n    return valid;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n    if (N == 1) return true;\n\n    // Find the number of elements that can be processed in one SVE vector\n    svcntw_t vl = svcntw();\n    size_t step = vl;\n\n    // Check if array can be sorted by rotation\n    // We need to check if there is exactly one \"drop\" (where arr[i] > arr[i+1])\n    // in the array (considering it as circular)\n    int drop_count = 0;\n    svbool_t pg = svptrue_b32();\n\n    // Process array in chunks using SVE\n    for (size_t i = 0; i < N; i += step) {\n        size_t remaining = std::min(step, N - i);\n        svbool_t active = svwhilelt_b32(i, i + remaining);\n        svint32_t vec1 = svld1_s32(active, &arr[i]);\n        svint32_t vec2;\n\n        if (i + 1 < N) {\n            vec2 = svld1_s32(active, &arr[(i + 1) % N]);\n        } else {\n            // Handle circular nature for last element\n            vec2 = svld1_s32(active, &arr[0]);\n        }\n\n        svbool_t gt_mask = svcmpgt_s32(active, vec1, vec2);\n        drop_count += svcntp_b32(active, gt_mask);\n    }\n\n    // Also check the last to first element for circular drop\n    if (N > 1 && arr[N-1] > arr[0]) {\n        drop_count++;\n    }\n\n    // If there is exactly one drop, rotation can sort the array\n    return drop_count == 1;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len = lst1.size();\n    if (len != lst2.size()) return \"NO\";\n\n    int odd1 = 0, odd2 = 0;\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t vec1, vec2;\n    size_t i = 0;\n\n    while (i < len) {\n        size_t count = svcntw();\n        if (i + count > len) {\n            pg = svwhilelt_b32(i, len);\n        }\n        vec1 = svld1(pg, &lst1[i]);\n        vec2 = svld1(pg, &lst2[i]);\n        \n        svbool_t odd_mask1 = svcmpeq(pg, svand_z(pg, vec1, 1), 1);\n        svbool_t odd_mask2 = svcmpeq(pg, svand_z(pg, vec2, 1), 1);\n        \n        odd1 += svcntp_b32(pg, odd_mask1);\n        odd2 += svcntp_b32(pg, odd_mask2);\n        \n        i += count;\n    }\n\n    return (odd1 == odd2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    size_t vec_len = svcntw();\n    size_t i;\n\n    int even_count1 = 0;\n    int even_count2 = 0;\n\n    // Process lst1 for even count using SVE\n    for (i = 0; i < n1; i += vec_len) {\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)n1);\n        svint32_t vec = svld1_s32(pg, &lst1[i]);\n        svint32_t mod_vec = svand_s32_z(pg, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(pg, mod_vec, 0);\n        even_count1 += svcntp_b32(pg, even_mask);\n    }\n\n    // Process lst2 for even count using SVE\n    for (i = 0; i < n2; i += vec_len) {\n        svbool_t pg = svwhilelt_b32((uint32_t)i, (uint32_t)n2);\n        svint32_t vec = svld1_s32(pg, &lst2[i]);\n        svint32_t mod_vec = svand_s32_z(pg, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(pg, mod_vec, 0);\n        even_count2 += svcntp_b32(pg, even_mask);\n    }\n\n    // Total even numbers available\n    int total_even = even_count1 + even_count2;\n\n    // If total even numbers are at least the size of lst1, we can make lst1 all even\n    if (total_even >= static_cast<int>(n1)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len = lst1.size();\n    if (len != lst2.size()) return \"NO\";\n\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vlen = svcntw();\n\n    int odd1 = 0, odd2 = 0;\n\n    for (size_t i = 0; i < len; i += vlen) {\n        svbool_t pm = svwhilelt_b32(i, len);\n        \n        svint32_t v1 = svld1_s32(pm, &lst1[i]);\n        svint32_t v2 = svld1_s32(pm, &lst2[i]);\n\n        svint32_t mod1 = svand_s32_z(pm, v1, svdup_s32(1));\n        svint32_t mod2 = svand_s32_z(pm, v2, svdup_s32(1));\n\n        odd1 += svaddv_s32(pm, mod1);\n        odd2 += svaddv_s32(pm, mod2);\n    }\n\n    return (odd1 == odd2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len = lst1.size();\n    int odd1 = 0, odd2 = 0;\n    svbool_t pg = svptrue_b32();\n\n    // Count odd numbers in lst1\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svint32_t vec = svld1(pg, &lst1[i]);\n        svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 1);\n        odd1 += svcntp_b32(pg, odd_mask);\n    }\n\n    // Count odd numbers in lst2\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svint32_t vec = svld1(pg, &lst2[i]);\n        svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 1);\n        odd2 += svcntp_b32(pg, odd_mask);\n    }\n\n    // Check if total odd numbers is even\n    return (odd1 + odd2) % 2 == 0 ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t len = lst1.size();\n    if (len != lst2.size()) return \"NO\";\n    \n    int64_t odd1 = 0, odd2 = 0;\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Count odd numbers in lst1\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(p, &lst1[i]);\n        svbool_t odd_mask = svcmpeq_n_s32(p, svand_n_s32_z(p, v, 1), 1);\n        odd1 += svcntp_b32(p, odd_mask);\n    }\n    \n    // Count odd numbers in lst2\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(p, &lst2[i]);\n        svbool_t odd_mask = svcmpeq_n_s32(p, svand_n_s32_z(p, v, 1), 1);\n        odd2 += svcntp_b32(p, odd_mask);\n    }\n    \n    // If odd counts are equal, we can exchange to make lst1 all even\n    return (odd1 == odd2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    size_t vec_len = svcntb(); // Get the number of bytes in a vector\n    size_t max_str_len = 0;\n    for (const auto& str : lst) {\n        max_str_len = std::max(max_str_len, str.size());\n    }\n\n    size_t num_vectors = (max_str_len + vec_len - 1) / vec_len;\n\n    for (const auto& str : lst) {\n        size_t len = str.size();\n        svuint8_t odd_count_vec = svdup_n_u8(0);\n        svbool_t pg = svwhilelt_b8(0, len);\n\n        for (size_t i = 0; i < num_vectors; ++i) {\n            size_t start_idx = i * vec_len;\n            svbool_t active_lanes = svwhilelt_b8(start_idx, len);\n            svuint8_t data_vec = svdup_n_u8(0);\n\n            // Load string data into vector\n            if (start_idx < len) {\n                size_t bytes_to_load = std::min(vec_len, len - start_idx);\n                data_vec = svld1_u8(active_lanes, reinterpret_cast<const uint8_t*>(str.data() + start_idx));\n            }\n\n            // Convert ASCII digits to numeric values\n            svuint8_t digit_vec = svsub_n_u8_x(active_lanes, data_vec, '0');\n\n            // Check if digit is odd (digit % 2 == 1)\n            svuint8_t is_odd = svand_n_u8_x(active_lanes, digit_vec, 1);\n            svuint8_t odd_inc = svsel_u8(active_lanes, is_odd, svdup_n_u8(1), svdup_n_u8(0));\n\n            // Accumulate odd count\n            odd_count_vec = svadd_u8_x(pg, odd_count_vec, odd_inc);\n        }\n\n        // Reduce the vector to get total odd count\n        uint64_t odd_count = svaddv_u8(pg, odd_count_vec);\n\n        // Format the result string\n        std::string count_str = std::to_string(odd_count);\n        std::string res = \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\";\n        result.push_back(res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    // Process each string in the input vector\n    for (const auto& str : lst) {\n        size_t len = str.size();\n        size_t odd_count = 0;\n\n        // Use SVE for parallelism if string length is significant\n        if (len > 0) {\n            svbool_t pg = svptrue_b8();\n            size_t i = 0;\n\n            // Process in chunks based on vector length\n            while (i < len) {\n                // Load a chunk of characters into a vector\n                svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n\n                // Convert characters to numeric values (subtract '0')\n                svuint8_t digits = svsub_n_u8_x(pg, chars, '0');\n\n                // Check if digits are odd (digit % 2 == 1)\n                svbool_t odd_mask = svcmpeq_n_u8(pg, svand_n_u8_x(pg, digits, 1), 1);\n\n                // Count the number of odd digits in this chunk\n                odd_count += svcntp_b8(pg, odd_mask);\n\n                i += svcntb();\n                if (i < len) {\n                    pg = svwhilelt_b8(i, len);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // Format the result string\n        std::string res = \"the number of odd elements \" + std::to_string(odd_count) +\n                          \"n the str\" + std::to_string(odd_count) +\n                          \"ng \" + std::to_string(odd_count) +\n                          \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    // Process each string in the input vector\n    for (const auto& str : lst) {\n        size_t len = str.size();\n        size_t odd_count = 0;\n\n        // Use SVE to count odd digits in parallel\n        size_t i = 0;\n        svbool_t pg = svptrue_b8();\n        size_t vl = svcntb(); // Vector length in bytes\n\n        for (; i + vl <= len; i += vl) {\n            // Load a chunk of characters into a vector\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n\n            // Convert characters to numeric values (subtract '0')\n            svuint8_t digits = svsub_n_u8_x(pg, chars, '0');\n\n            // Check if digits are odd (digit % 2 == 1)\n            svbool_t odd_mask = svcmpeq_n_u8(pg, svand_n_u8_x(pg, digits, 1), 1);\n\n            // Count the number of odd digits in this chunk\n            odd_count += svcntp_b8(pg, odd_mask);\n        }\n\n        // Handle remaining characters scalarly\n        for (; i < len; ++i) {\n            int digit = str[i] - '0';\n            if (digit % 2 == 1) {\n                odd_count++;\n            }\n        }\n\n        // Construct the result string for this input string\n        std::string res = \"the number of odd elements \" + std::to_string(odd_count) +\n                          \"n the str\" + std::to_string(odd_count) +\n                          \"ng \" + std::to_string(odd_count) +\n                          \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result(lst.size());\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        int32_t odd_count = 0;\n        \n        // Process string in vector-sized chunks\n        size_t len = str.length();\n        size_t pos = 0;\n        \n        // Get vector length in bytes\n        svbool_t pg = svwhilelt_b8(pos, len);\n        size_t vlen = svcntb();\n        \n        while (pos < len) {\n            // Load characters into vector\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)&str[pos]);\n            \n            // Convert ASCII digits to numbers (subtract '0')\n            svuint8_t digits = svsub_n_u8_x(pg, chars, '0');\n            \n            // Check for odd digits (digit % 2 == 1)\n            svuint8_t is_odd = svand_n_u8_x(pg, digits, 1);\n            \n            // Count odd digits in vector\n            odd_count += svcntp_b8(pg, svcmpeq_n_u8(pg, is_odd, 1));\n            \n            // Move to next chunk\n            pos += vlen;\n            pg = svwhilelt_b8(pos, len);\n        }\n        \n        // Format result string\n        std::string res = \"the number of odd elements \" + std::to_string(odd_count) +\n                         \"n the str\" + std::to_string(odd_count) +\n                         \"ng \" + std::to_string(odd_count) +\n                         \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result[i] = res;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    size_t vector_length = svcntb(); // Get the number of bytes in a vector\n    size_t max_str_len = 0;\n    for (const auto& str : lst) {\n        max_str_len = std::max(max_str_len, str.size());\n    }\n\n    // Process strings in chunks based on vector length\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        size_t len = str.size();\n        size_t odd_count = 0;\n\n        size_t j = 0;\n        for (; j + vector_length <= len; j += vector_length) {\n            svbool_t pg = svwhilelt_b8(j, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[j]));\n            svuint8_t digits = svsub_n_u8_x(pg, vec, '0');\n            svuint8_t is_odd = svand_n_u8_x(pg, digits, 1);\n            odd_count += svcntp_b8(pg, svcmpne_n_u8(pg, is_odd, 0));\n        }\n\n        // Handle remaining elements\n        for (; j < len; ++j) {\n            int digit = str[j] - '0';\n            if (digit % 2 == 1) {\n                odd_count++;\n            }\n        }\n\n        // Format the result string\n        std::string res = \"the number of odd elements \" + std::to_string(odd_count) +\n                          \"n the str\" + std::to_string(odd_count) +\n                          \"ng \" + std::to_string(odd_count) +\n                          \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t global_min = nums[0];\n    int64_t current_sum = 0;\n\n    size_t vec_len = svcntd();\n    svint64_t vec_current_sum = svdup_n_s64(0);\n    svint64_t vec_min = svdup_n_s64(global_min);\n    svbool_t pg = svptrue_b64();\n\n    size_t i = 0;\n    for (; i + vec_len <= n; i += vec_len) {\n        svint64_t vec_nums = svld1(pg, &nums[i]);\n        vec_current_sum = svadd_x(pg, vec_current_sum, vec_nums);\n        svint64_t vec_temp_min = svmin_x(pg, vec_current_sum, vec_nums);\n        vec_min = svmin_x(pg, vec_min, vec_temp_min);\n\n        int64_t local_min = svminv_s64(pg, vec_min);\n        if (local_min < global_min) {\n            global_min = local_min;\n        }\n\n        int64_t local_sum = svaddv_s64(pg, vec_current_sum);\n        current_sum = local_sum;\n    }\n\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        if (current_sum < global_min) {\n            global_min = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t global_min = INT64_MAX;\n    svbool_t pg = svwhilelt_b64(0, nums.size());\n    \n    for (size_t i = 0; i < nums.size(); i++) {\n        int64_t current_sum = 0;\n        svint64_t sum_vec = svdup_n_s64(0);\n        \n        for (size_t j = i; j < nums.size(); j += svcntd()) {\n            svbool_t pm = svwhilelt_b64(j, nums.size());\n            svint64_t vec = svld1_s64(pm, &nums[j]);\n            sum_vec = svadd_m(pm, sum_vec, vec);\n            \n            int64_t min_in_vec = svminv_s64(pm, sum_vec);\n            current_sum = svaddv_s64(pm, sum_vec);\n            \n            global_min = std::min(global_min, min_in_vec);\n            global_min = std::min(global_min, current_sum);\n        }\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t global_min = INT64_MAX;\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < nums.size(); i++) {\n        int64_t current_sum = 0;\n        svint64_t vsum = svdup_n_s64(0);\n        \n        size_t j = i;\n        while (j < nums.size()) {\n            // Calculate how many elements we can process in parallel\n            size_t remaining = nums.size() - j;\n            size_t vl = svcntd();\n            size_t step = std::min(remaining, vl);\n            \n            // Load predicate for remaining elements\n            svbool_t pg_step = svwhilelt_b64(j, nums.size());\n            \n            // Load vector of numbers\n            svint64_t vnums = svld1_s64(pg_step, &nums[j]);\n            \n            // Update running sum\n            vsum = svadd_m(pg_step, vsum, vnums);\n            \n            // Find minimum in vector\n            int64_t local_min = svminv_s64(pg_step, vsum);\n            \n            // Update global minimum\n            global_min = std::min(global_min, local_min);\n            \n            // Update scalar sum for next iteration\n            current_sum += svaddv_s64(pg_step, vnums);\n            global_min = std::min(global_min, current_sum);\n            \n            j += step;\n        }\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t global_min = nums[0];\n    int64_t current_sum = 0;\n\n    // Determine the vector length for SVE\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        // Load a vector of values\n        svint64_t vec = svld1(pg, &nums[i]);\n\n        // Compute prefix sums using SVE\n        svint64_t prefix_sum = svdup_n_s64(0);\n        svint64_t current_vec_sum = svdup_n_s64(current_sum);\n\n        for (size_t j = 0; j < vl; ++j) {\n            current_vec_sum = svadd_n_s64_z(pg, current_vec_sum, svext_x(pg, vec, j));\n            prefix_sum = svmin_s64_z(pg, prefix_sum, current_vec_sum);\n        }\n\n        // Extract the minimum from the prefix sum vector\n        int64_t local_min = svminv_s64(pg, prefix_sum);\n        global_min = std::min(global_min, local_min);\n\n        // Update current_sum for the next iteration\n        current_sum = svaddv_s64(pg, current_vec_sum);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        global_min = std::min(global_min, current_sum);\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    svint64_t min_sum_vec = svdup_s64(INT64_MAX);\n    int64_t min_sum = INT64_MAX;\n    size_t len = nums.size();\n    \n    // Process prefixes\n    svint64_t prefix_sum = svdup_s64(0);\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svint64_t vec = svld1_s64(pg, &nums[i]);\n        prefix_sum = svadd_s64_z(pg, prefix_sum, vec);\n        min_sum_vec = svmin_s64_z(pg, min_sum_vec, prefix_sum);\n    }\n    \n    // Extract minimum from vector\n    int64_t local_mins[svcntd()];\n    svst1_s64(svptrue_b64(), local_mins, min_sum_vec);\n    for (size_t i = 0; i < svcntd(); i++) {\n        min_sum = std::min(min_sum, local_mins[i]);\n    }\n    \n    // Process Kadane's algorithm with SVE\n    svint64_t curr_sum = svdup_s64(0);\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svint64_t vec = svld1_s64(pg, &nums[i]);\n        curr_sum = svadd_s64_z(pg, curr_sum, vec);\n        min_sum_vec = svmin_s64_z(pg, min_sum_vec, curr_sum);\n        \n        // Reset curr_sum if negative\n        svbool_t neg_mask = svcmplt_s64(pg, curr_sum, svdup_s64(0));\n        curr_sum = svsel_s64(neg_mask, svdup_s64(0), curr_sum);\n    }\n    \n    // Extract final minimum\n    svst1_s64(svptrue_b64(), local_mins, min_sum_vec);\n    for (size_t i = 0; i < svcntd(); i++) {\n        min_sum = std::min(min_sum, local_mins[i]);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int rows = grid.size();\n    int cols = rows > 0 ? grid[0].size() : 0;\n    int total_fills = 0;\n\n    // Calculate number of elements per vector\n    svbool_t pg = svwhilelt_b32(0, cols);\n    uint64_t vlen = svcntw();\n\n    // Process each row\n    for (int i = 0; i < rows; i++) {\n        int row_sum = 0;\n        int j = 0;\n\n        // Process columns in vector-sized chunks\n        while (j < cols) {\n            // Load predicate for remaining elements\n            pg = svwhilelt_b32(j, cols);\n            \n            // Load vector of grid values\n            svuint32_t vec = svld1_u32(pg, &grid[i][j]);\n            \n            // Sum elements in the vector\n            row_sum += svsum_u32_z(pg, vec);\n            \n            j += vlen;\n        }\n\n        // Calculate fills needed for this row\n        if (row_sum > 0) {\n            total_fills += (row_sum + capacity - 1) / capacity;\n        }\n    }\n\n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    // Process each column\n    for (int col = 0; col < cols; ++col) {\n        int water_in_col = 0;\n        \n        // Use SVE to count water in the current column across all rows\n        svbool_t pg = svptrue_b32();\n        svint32_t water_vec = svdup_n_s32(0);\n        \n        int row = 0;\n        for (; row <= rows - svcntw(); row += svcntw()) {\n            svint32_t row_data = svdup_n_s32(0);\n            for (int i = 0; i < svcntw() && row + i < rows; ++i) {\n                row_data = svset_s32(row_data, i, grid[row + i][col]);\n            }\n            water_vec = svadd_s32_z(pg, water_vec, row_data);\n        }\n        \n        // Sum up the remaining rows if any\n        int remaining_water = 0;\n        for (; row < rows; ++row) {\n            remaining_water += grid[row][col];\n        }\n        \n        // Horizontal sum of the vector\n        water_in_col = svaddv_s32(pg, water_vec) + remaining_water;\n        \n        // Calculate the number of bucket lowers needed for this column\n        total_lowers += (water_in_col + capacity - 1) / capacity;\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    // Process each column across all rows in parallel using SVE\n    for (int c = 0; c < cols; c += svcntw()) {\n        svint32_t col_sum = svdup_n_s32(0);\n        svbool_t pg = svwhilelt_b32(c, cols);\n        \n        for (int r = 0; r < rows; ++r) {\n            svint32_t row_data = svdup_n_s32(0);\n            // Load data for the current row and column range\n            for (int i = 0; i < svcntw() && c + i < cols; ++i) {\n                row_data = svinsr_n_s32(row_data, grid[r][c + i]);\n            }\n            col_sum = svadd_m(pg, col_sum, row_data);\n        }\n        \n        // Compute the number of bucket lowers needed for this column range\n        int32_t local_sums[svcntw()];\n        svst1_s32(pg, local_sums, col_sum);\n        \n        for (int i = 0; i < svcntw() && c + i < cols; ++i) {\n            total_lowers += (local_sums[i] + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    // Process each column\n    for (int j = 0; j < cols; ++j) {\n        int col_sum = 0;\n        // Use SVE to sum the column\n        svbool_t pg = svwhilelt_b32(0, rows);\n        svint32_t sum_vec = svdup_n_s32(0);\n        \n        int i = 0;\n        while (i < rows) {\n            svint32_t data_vec = svdup_n_s32(0);\n            for (int k = 0; k < svcntw() && i + k < rows; ++k) {\n                data_vec = svset_s32(data_vec, k, grid[i + k][j]);\n            }\n            sum_vec = svadd_s32_z(pg, sum_vec, data_vec);\n            i += svcntw();\n            pg = svwhilelt_b32(i, rows);\n        }\n        \n        // Reduce the vector sum to scalar\n        col_sum = svaddv_s32(svptrue_b32(), sum_vec);\n        \n        // Calculate the number of bucket lowers needed for this column\n        total_lowers += (col_sum + capacity - 1) / capacity;\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    // Process each column across all rows\n    for (int col = 0; col < cols; ++col) {\n        int water_in_col = 0;\n        \n        // Use SVE to count water in the current column across all rows\n        int row = 0;\n        while (row < rows) {\n            svbool_t pg = svwhilelt_b32(row, rows);\n            svint32_t water_vec = svdup_n_s32(0);\n            \n            if (svptest_any(svptrue_b32(), pg)) {\n                for (int i = 0; i < svcntw() && row + i < rows; ++i) {\n                    water_vec = svsel_s32(pg, svld1_s32(pg, &grid[row + i][col]), water_vec);\n                    row += svcntw();\n                }\n                water_in_col += svaddv_s32(pg, water_vec);\n            } else {\n                break;\n            }\n        }\n        \n        // Calculate the number of bucket lowers needed for this column\n        if (water_in_col > 0) {\n            total_lowers += (water_in_col + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n\n    // Process elements in chunks based on vector length\n    while (i < len) {\n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b16((uint64_t)i, (uint64_t)len);\n        // Load data into vector\n        svint16_t vec = svld1_s16(pred, &lst[i]);\n        // Create predicate for even positions\n        svbool_t even_pos_pred = svzip1_b16(svfalse_b(), svtrue_b());\n        even_pos_pred = svand_b_z(pg, even_pos_pred, pred);\n        // Mask for odd values (check least significant bit)\n        svbool_t odd_val_pred = svand_b_z(pg, svcmpeq_n_s16(pg, svand_n_s16(pg, vec, 1), 1), even_pos_pred);\n        // Sum elements that are odd and in even positions\n        sum += svaddv_s16(odd_val_pred, vec);\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svwhilelt_b16(i, len);\n    size_t vlen = svcntw();\n\n    // Process elements in chunks based on vector length\n    for (; i + vlen <= len; i += vlen) {\n        // Load a vector of int16_t\n        svint16_t vec = svld1(pg, &lst[i]);\n\n        // Create a mask for even positions\n        svbool_t even_pos_mask = svzip1_b16(svfalse_b(), svtrue_b16());\n        even_pos_mask = svand_b_z(pg, even_pos_mask, pg);\n\n        // Create a mask for odd values (check least significant bit)\n        svint16_t one = svdup_n_s16(1);\n        svbool_t odd_val_mask = svcmpeq(pg, svand_s16_z(pg, vec, one), one);\n\n        // Combine masks: odd values in even positions\n        svbool_t final_mask = svand_b_z(pg, even_pos_mask, odd_val_mask);\n\n        // Select elements based on the mask and sum them\n        svint16_t selected = svsel_s16(final_mask, vec, svdup_n_s16(0));\n        sum += svaddv(pg, selected);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        if (i + 1 < len && (lst[i + 1] % 2 != 0)) {\n            sum += lst[i + 1];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svwhilelt_b16(i, len);\n    size_t vec_len = svcntw();\n\n    // Process elements in chunks based on vector length\n    while (i < len) {\n        // Create predicate for current chunk\n        pg = svwhilelt_b16(i, len);\n\n        // Load data into SVE vector\n        svint16_t vec = svld1(pg, &lst[i]);\n\n        // Create index vector for positions\n        svint16_t indices = svindex_s16(i, 1);\n\n        // Mask for even positions (i % 2 == 0)\n        svbool_t even_pos_mask = svcmpeq(pg, svand_s16_z(pg, indices, 1), 0);\n\n        // Mask for odd values (value % 2 == 1)\n        svbool_t odd_val_mask = svcmpeq(pg, svand_s16_z(pg, vec, 1), 1);\n\n        // Combine masks: elements that are odd and in even positions\n        svbool_t final_mask = svand_b_z(pg, even_pos_mask, odd_val_mask);\n\n        // Extract elements that match the condition\n        svint16_t filtered_vec = svsel_s16(final_mask, vec, svdup_s16(0));\n\n        // Sum the filtered elements\n        sum += svaddv(pg, filtered_vec);\n\n        i += vec_len;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n\n    // Process elements in chunks based on vector length\n    while (i < len) {\n        // Create a predicate for the current chunk\n        svbool_t p = svwhilelt_b16(i, len);\n        // Load data into a vector\n        svint16_t vec = svld1_s16(p, &lst[i]);\n        // Create a mask for even positions (0, 2, 4, ...)\n        svbool_t even_pos = svzip1_b16(svfalse_b(), svtrue_b());\n        // Create a mask for odd values (check if LSB is 1)\n        svbool_t odd_val = svand_b_z(pg, svcmpeq_n_s16(p, vec, svdup_n_s16(1)), p);\n        // Combine masks: even positions AND odd values\n        svbool_t mask = svand_b_z(pg, even_pos, odd_val);\n        // Sum elements where mask is true\n        sum += svaddv_s16(mask, vec);\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw();\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of int16_t\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n\n        // Create a mask for even positions (0, 2, 4, ...)\n        svbool_t even_pos_mask = svzip1_b16(svpfalse_b(), svptrue_b16());\n\n        // Create a mask for odd values (check if least significant bit is 1)\n        svbool_t odd_val_mask = svand_b_z(pg, svcmpeq_n_s16(pg, svand_n_s16(pg, vec, 1), 1), pg);\n\n        // Combine masks: elements that are in even positions AND have odd values\n        svbool_t final_mask = svand_b_z(pg, even_pos_mask, odd_val_mask);\n\n        // Select elements based on the mask, zero out others\n        svint16_t filtered_vec = svsel_s16(final_mask, vec, svdup_n_s16(0));\n\n        // Sum the filtered vector elements\n        sum += svaddv_s16(pg, filtered_vec);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        if (i < len && (lst[i] & 1)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, k);\n    \n    while (i < k) {\n        // Load predicate for remaining elements\n        pg = svwhilelt_b32(i, k);\n        \n        // Load vector of integers\n        svint32_t vec = svld1(pg, &arr[i]);\n        \n        // Create mask for numbers with at most 2 digits (|x| <= 99)\n        svbool_t mask = svcmple(pg, svabs_s32_z(pg, vec), 99);\n        \n        // Select elements with at most 2 digits, others set to 0\n        svint32_t filtered = svsel_s32(mask, vec, svdup_s32(0));\n        \n        // Horizontal sum of filtered elements\n        sum += svaddv_s32(pg, filtered);\n        \n        i += svcntw();\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svptrue_b32();\n    int vector_length = svcntw();\n\n    while (i < k) {\n        // Determine how many elements to process in this iteration\n        int remaining = k - i;\n        svbool_t active = svwhilelt_b32(i, k);\n\n        // Load data into a vector\n        svint32_t vec = svld1_s32(active, &arr[i]);\n\n        // Create a mask for elements with at most two digits (abs value < 100)\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n        svbool_t mask = svcmplt_s32(pg, abs_vec, 100);\n\n        // Use the mask to select elements for summation\n        sum += svaddv_s32(mask, vec);\n\n        i += vector_length;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svptrue_b32();\n    int vector_length = svcntw();\n\n    while (i < k) {\n        // Determine how many elements to process in this iteration\n        int remaining = k - i;\n        svbool_t active_lanes = svwhilelt_b32(i, k);\n\n        // Load data into a vector\n        svint32_t vec = svld1_s32(active_lanes, &arr[i]);\n\n        // Create a mask for elements with at most two digits (abs value < 100)\n        svint32_t abs_vec = svabs_s32_z(active_lanes, vec);\n        svbool_t mask = svcmplt_s32(active_lanes, abs_vec, 100);\n\n        // Use the mask to select elements for summation\n        svint32_t masked_vec = svsel_s32(mask, vec, svdup_n_s32(0));\n\n        // Compute the sum of the vector elements\n        sum += svaddv_s32(active_lanes, masked_vec);\n\n        i += vector_length;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process k elements in vector-sized chunks\n    while (i < k && i + svcntw() <= k) {\n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        \n        // Create mask for numbers with at most 2 digits (-99 to 99)\n        svbool_t mask = svand_b_z(pg, \n            svcmpge_n_s32(pg, vec, -99),\n            svcmple_n_s32(pg, vec, 99)\n        );\n        \n        // Sum elements where mask is true\n        sum += svaddv_s32(mask, vec);\n        \n        i += svcntw();\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, k);\n\n    while (i < k) {\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        svbool_t mask = svcmpge_n_s32(pg, vec, -99);\n        mask = svand_b_z(svptrue_b32(), mask, svcmple_n_s32(pg, vec, 99));\n        sum += svaddv_s32(mask, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, k);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t len = lst.size();\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    bool is_sorted = true;\n    bool has_duplicate = false;\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load current vector\n        svint32_t vec_curr = svld1(pg, &lst[i]);\n        // Load next vector for comparison (shifted by 1)\n        svint32_t vec_next = svld1(pg, &lst[i + 1]);\n\n        // Check if current vector is less than or equal to next vector elements\n        svbool_t sorted_mask = svcmple(pg, vec_curr, svext(vec_next, vec_curr, 1));\n        if (!svptest_all(pg, sorted_mask)) {\n            is_sorted = false;\n        }\n\n        // Check for duplicates in current vector\n        svbool_t dup_mask = svcmpeq(pg, vec_curr, svext(vec_curr, vec_curr, 1));\n        if (svptest_any(pg, dup_mask)) {\n            // Check if there are more than 1 duplicate by comparing further\n            svbool_t next_dup_mask = svcmpeq(pg, vec_curr, svext(vec_curr, vec_curr, 2));\n            if (svptest_any(pg, next_dup_mask)) {\n                has_duplicate = true;\n            }\n        }\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            is_sorted = false;\n        }\n        if (i < len - 2 && lst[i] == lst[i + 1] && lst[i + 1] == lst[i + 2]) {\n            has_duplicate = true;\n        }\n    }\n\n    return is_sorted && !has_duplicate;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t len = lst.size();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    size_t i = 0;\n    bool is_sorted = true;\n    bool has_duplicate = false;\n\n    // Process vector-sized chunks\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load current vector\n        svint32_t vec_curr = svld1(pg, &lst[i]);\n        // Load next vector for comparison (shifted by 1)\n        svint32_t vec_next = svld1(pg, &lst[i + 1]);\n\n        // Check for duplicates in current vector\n        svbool_t eq_mask = svcmpeq(pg, vec_curr, svext(vec_curr, vec_curr, 1));\n        if (svptest_any(pg, eq_mask)) {\n            has_duplicate = true;\n        }\n\n        // Check if current < next for ascending order\n        svbool_t lt_mask = svcmplt(pg, vec_curr, vec_next);\n        if (!svptest_all(pg, lt_mask)) {\n            is_sorted = false;\n        }\n\n        if (!is_sorted || has_duplicate) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements scalar-wise\n    for (; i < len - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            is_sorted = false;\n        }\n        if (lst[i] == lst[i + 1]) {\n            has_duplicate = true;\n        }\n        if (!is_sorted || has_duplicate) {\n            return false;\n        }\n    }\n\n    return is_sorted && !has_duplicate;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t len = lst.size();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    bool is_sorted = true;\n    bool has_duplicate = false;\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load current vector\n        svint32_t curr_vec = svld1(pg, &lst[i]);\n        // Load next vector for comparison (shifted by 1)\n        svint32_t next_vec = svld1(pg, &lst[i + 1]);\n\n        // Check for ascending order (curr < next)\n        svbool_t lt_mask = svcmplt(pg, curr_vec, next_vec);\n        if (!svptest_all(pg, lt_mask)) {\n            is_sorted = false;\n        }\n\n        // Check for duplicates (curr == next)\n        svbool_t eq_mask = svcmpeq(pg, curr_vec, next_vec);\n        if (svptest_any(pg, eq_mask)) {\n            // Load a vector to check for consecutive duplicates\n            svint32_t next_next_vec = (i + vec_len + 1 < len) ? svld1(pg, &lst[i + 2]) : svdup_n_s32(0);\n            svbool_t eq_next_mask = svcmpeq(pg, next_vec, next_next_vec);\n            if (svptest_any(pg, eq_next_mask)) {\n                has_duplicate = true;\n            }\n        }\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            is_sorted = false;\n        }\n        if (i < len - 2 && lst[i] == lst[i + 1] && lst[i + 1] == lst[i + 2]) {\n            has_duplicate = true;\n        }\n    }\n\n    return is_sorted && !has_duplicate;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, (int)lst.size() - 1);\n    svint32_t vec_prev = svld1_s32(pg, lst.data());\n    \n    // Check for ascending order\n    svbool_t asc_mask = svptrue_b32();\n    for (size_t i = 0; i < lst.size() - 1; i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, (int)lst.size() - 1);\n        svint32_t vec_curr = svld1_s32(pg_loop, lst.data() + i);\n        svint32_t vec_next = svld1_s32(pg_loop, lst.data() + i + 1);\n        \n        // Check if current >= next (not strictly ascending)\n        svbool_t not_asc = svcmple_s32(pg_loop, vec_next, vec_curr);\n        asc_mask = svand_b_z(svptrue_b32(), asc_mask, svnot_b_z(pg_loop, not_asc));\n        \n        // Check for duplicates (curr == next)\n        svbool_t eq_mask = svcmpeq_s32(pg_loop, vec_curr, vec_next);\n        if (svptest_any(pg_loop, eq_mask)) {\n            // Check if there are more than one duplicate\n            for (size_t j = i; svptest_any(pg_loop, eq_mask); j += svcntw()) {\n                svbool_t pg_inner = svwhilelt_b32(j, (int)lst.size() - 1);\n                svint32_t vec_curr_inner = svld1_s32(pg_inner, lst.data() + j);\n                svint32_t vec_next_inner = svld1_s32(pg_inner, lst.data() + j + 1);\n                svbool_t eq_inner = svcmpeq_s32(pg_inner, vec_curr_inner, vec_next_inner);\n                \n                // Count consecutive equal elements\n                if (svcntp_b32(pg_inner, eq_inner) > 1) {\n                    return false;\n                }\n                eq_mask = svand_b_z(svptrue_b32(), eq_mask, svnot_b_z(pg_inner, eq_inner));\n            }\n        }\n    }\n\n    return svptestz_b(asc_mask, asc_mask);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < len - 1; i += vec_len) {\n        size_t elements = std::min(vec_len, len - 1 - i);\n        svbool_t active = svwhilelt_b32(i, len - 1);\n        \n        svint32_t curr = svld1_s32(active, &lst[i]);\n        svint32_t next = svld1_s32(active, &lst[i + 1]);\n        \n        // Check if current >= next (not strictly ascending)\n        svbool_t not_ascending = svcmpge_s32(active, curr, next);\n        if (svptest_any(pg, not_ascending)) {\n            return false;\n        }\n        \n        // Check for duplicates (curr == next)\n        svbool_t duplicates = svcmpeq_s32(active, curr, next);\n        if (svptest_any(pg, duplicates)) {\n            // Verify if we have more than one duplicate\n            if (i + vec_len < len) {\n                svint32_t next_next = svld1_s32(active, &lst[i + 2]);\n                svbool_t next_duplicates = svcmpeq_s32(active, next, next_next);\n                if (svptest_any(pg, svand_b_z(pg, duplicates, svwhilelt_b32(i + 1, len - 1)))) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements scalarly if needed\n    for (size_t i = (len - 1) - ((len - 1) % vec_len); i < len - 1; ++i) {\n        if (lst[i] >= lst[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum_magnitudes = 0;\n    int64_t sign_product = 1;\n    size_t i = 0;\n    size_t len = arr.size();\n\n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t active = svwhilelt_b32(i, len);\n        svint32_t abs_vec = svabs_s32_m(active, vec);\n        svint32_t sign_vec = svdiv_n_s32_m(active, vec, abs_vec);\n\n        sum_magnitudes += svaddv_s32(active, abs_vec);\n\n        svint32_t zero_mask = svcmpeq_s32(active, vec, 0);\n        sign_product *= svmulv_s32(active, sign_vec);\n        if (svptest_any(active, zero_mask)) {\n            return 0;\n        }\n\n        i += svcntw();\n    }\n\n    return static_cast<int>(sum_magnitudes * sign_product);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum_magnitudes = 0;\n    int64_t sign_product = 1;\n    size_t i = 0;\n    size_t len = arr.size();\n\n    while (i < len) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svint32_t abs_vec = svabs_z(pg, vec);\n        svint32_t sign_vec = svsel(pg, svcmpeq(pg, vec, svdup_n_s32(0)), svdup_n_s32(0),\n                                    svsel(pg, svcmplt(pg, vec, svdup_n_s32(0)), svdup_n_s32(-1), svdup_n_s32(1)));\n\n        sum_magnitudes += svaddv(pg, abs_vec);\n        int64_t local_sign_product = svmulv(pg, sign_vec);\n        sign_product *= (local_sign_product == 0 ? 0 : (local_sign_product > 0 ? 1 : -1));\n\n        i += svcntw();\n        if (i > len) {\n            i = len;\n        }\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return static_cast<int>(sum_magnitudes * sign_product);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svint32_t vec;\n    svbool_t pg = svptrue_b32();\n    int64_t sum_magnitudes = 0;\n    int sign_product = 1;\n    size_t i = 0;\n    size_t vec_len = svcntw();\n\n    for (; i + vec_len <= arr.size(); i += vec_len) {\n        vec = svld1(pg, &arr[i]);\n        svint32_t abs_vec = svabs_z(pg, vec);\n        sum_magnitudes += svaddv(pg, abs_vec);\n        svint32_t signs = svcmpgt(pg, vec, svdup_n_s32(0));\n        svint32_t signs_neg = svcmplt(pg, vec, svdup_n_s32(0));\n        int64_t pos_count = svcntp_b32(pg, signs);\n        int64_t neg_count = svcntp_b32(pg, signs_neg);\n        int64_t zero_count = vec_len - pos_count - neg_count;\n        if (zero_count > 0) {\n            return 0;\n        }\n        if (neg_count % 2 == 1) {\n            sign_product = -sign_product;\n        }\n    }\n\n    for (; i < arr.size(); ++i) {\n        int val = arr[i];\n        if (val == 0) {\n            return 0;\n        }\n        sum_magnitudes += std::abs(val);\n        if (val < 0) {\n            sign_product = -sign_product;\n        }\n    }\n\n    return static_cast<int>(sum_magnitudes * sign_product);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum_magnitudes = 0;\n    int64_t sign_product = 1;\n    size_t i = 0;\n    size_t len = arr.size();\n\n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t valid = svwhilelt_b32(i, len);\n        i += svcntw();\n\n        svint32_t abs_vec = svabs_s32_z(valid, vec);\n        sum_magnitudes += svaddv_s32(valid, abs_vec);\n\n        svint32_t signs = svsel_s32(valid, svdiv_n_s32_z(valid, vec, abs_vec), svdup_n_s32(0));\n        svint32_t sign_prod_vec = svmul_s32_z(valid, signs, svdup_n_s32(sign_product));\n        sign_product = svmulv_s32(valid, sign_prod_vec);\n    }\n\n    return static_cast<int>(sum_magnitudes * sign_product);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum = 0;\n    int sign_product = 1;\n    size_t i = 0;\n    size_t len = arr.size();\n\n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svdiv_s32_z(pg, vec, abs_vec);\n\n        sum += svaddv_s32(pg, abs_vec);\n        \n        svbool_t zero_mask = svcmpeq_s32(pg, vec, 0);\n        if (svptest_any(pg, zero_mask)) {\n            return 0;\n        }\n\n        int lane_sign = svmulv_s32(pg, sign_vec);\n        sign_product *= lane_sign;\n\n        i += svcntw();\n    }\n\n    return sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current(k);\n    \n    // Flatten grid for SIMD processing\n    std::vector<int> flat_grid(n * n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            flat_grid[i * n + j] = grid[i][j];\n        }\n    }\n    \n    // Directions for neighboring cells (up, right, down, left)\n    const int dr[4] = {-1, 0, 1, 0};\n    const int dc[4] = {0, 1, 0, -1};\n    \n    // Process each starting position\n    for (int start = 0; start < n * n; ++start) {\n        int r = start / n;\n        int c = start % n;\n        \n        // Initialize path with starting position\n        current[0] = grid[r][c];\n        \n        // Generate paths of length k\n        for (int len = 1; len < k; ++len) {\n            svint32_t min_val = svdup_n_s32(INT_MAX);\n            svbool_t pg = svptrue_b32();\n            \n            // Check all 4 directions\n            for (int d = 0; d < 4; ++d) {\n                int nr = r + dr[d];\n                int nc = c + dc[d];\n                \n                // Validate neighbor position\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                    int neighbor_val = grid[nr][nc];\n                    svint32_t val_vec = svdup_n_s32(neighbor_val);\n                    min_val = svmin_s32_m(pg, min_val, val_vec);\n                }\n            }\n            \n            // Extract minimum value\n            int min_neighbor = svminv_s32(pg, min_val);\n            current[len] = min_neighbor;\n            \n            // Update position to minimum neighbor (for next iteration)\n            for (int d = 0; d < 4; ++d) {\n                int nr = r + dr[d];\n                int nc = c + dc[d];\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] == min_neighbor) {\n                    r = nr;\n                    c = nc;\n                    break;\n                }\n            }\n        }\n        \n        // Update result if current path is lexicographically smaller\n        bool update = false;\n        for (int i = 0; i < k; ++i) {\n            if (current[i] < result[i]) {\n                update = true;\n                break;\n            } else if (current[i] > result[i]) {\n                break;\n            }\n        }\n        \n        if (update) {\n            result = current;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    if (N == 0) return {};\n\n    // Flatten the grid to a 1D array for easier SIMD processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize result path with a large value\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current_path(k);\n\n    // Function to check if a position is valid\n    auto is_valid = [N](int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n\n    // Directions for neighboring cells (up, right, down, left)\n    int dx[4] = {-1, 0, 1, 0};\n    int dy[4] = {0, 1, 0, -1};\n\n    // Recursive function to explore paths with SIMD for path comparison\n    auto dfs = [&](auto&& self, int x, int y, int step) -> void {\n        if (step == k) {\n            // Use SVE to compare current_path with result\n            svbool_t pg = svptrue_b32();\n            int32_t vec_size = svcntw();\n            bool update = false;\n            for (int i = 0; i < k; i += vec_size) {\n                int32_t remaining = std::min(vec_size, k - i);\n                svbool_t active = svwhilelt_b32(i, i + remaining);\n                svint32_t curr_vec = svld1_s32(active, &current_path[i]);\n                svint32_t res_vec = svld1_s32(active, &result[i]);\n                svbool_t lt_mask = svcmplt_s32(active, curr_vec, res_vec);\n                svbool_t eq_mask = svcmpeq_s32(active, curr_vec, res_vec);\n                if (svptest_any(pg, lt_mask)) {\n                    update = true;\n                    break;\n                }\n                if (!svptest_all(pg, eq_mask)) {\n                    break;\n                }\n            }\n            if (update) {\n                result = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (is_valid(nx, ny)) {\n                current_path[step] = flat_grid[nx * N + ny];\n                self(self, nx, ny, step + 1);\n            }\n        }\n    };\n\n    // Start DFS from each cell in the grid using SIMD for initial path setup\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            current_path[0] = flat_grid[i * N + j];\n            dfs(dfs, i, j, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    int total_cells = N * N;\n    std::vector<int> result(k, INT32_MAX);\n    \n    // Flatten grid for SIMD processing\n    std::vector<int> flat_grid(total_cells);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n    \n    // Directions for neighboring cells (up, right, down, left)\n    const int dr[] = {-1, 0, 1, 0};\n    const int dc[] = {0, 1, 0, -1};\n    \n    // Process each starting position\n    for (int start = 0; start < total_cells; ++start) {\n        int r = start / N;\n        int c = start % N;\n        std::vector<int> curr_path(k);\n        curr_path[0] = grid[r][c];\n        \n        // For k=1, just compare single value\n        if (k == 1) {\n            if (curr_path[0] < result[0]) {\n                result = curr_path;\n            }\n            continue;\n        }\n        \n        // Vectorized path exploration\n        svbool_t pg = svptrue_b32();\n        svint32_t min_path_vec = svdup_n_s32(INT32_MAX);\n        \n        // Try all possible paths of length k\n        std::vector<int> path_indices(k);\n        path_indices[0] = start;\n        \n        for (int step = 1; step < k; ++step) {\n            int curr_r = path_indices[step-1] / N;\n            int curr_c = path_indices[step-1] % N;\n            \n            // Prepare vectors for neighbor values\n            std::vector<int> neighbors;\n            for (int d = 0; d < 4; ++d) {\n                int nr = curr_r + dr[d];\n                int nc = curr_c + dc[d];\n                if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                    neighbors.push_back(grid[nr][nc]);\n                }\n            }\n            \n            // Pad neighbors to vector length\n            while (neighbors.size() < svcntw()) {\n                neighbors.push_back(INT32_MAX);\n            }\n            \n            // Load neighbor values into SVE vector\n            svint32_t neighbor_vec = svld1(pg, neighbors.data());\n            \n            // Find minimum value using SVE\n            svint32_t min_val = svminv_s32(pg, neighbor_vec);\n            int min_neighbor = svlastb_s32(pg, min_val);\n            \n            // Update path\n            curr_path[step] = min_neighbor;\n            \n            // Find index of minimum neighbor\n            for (int d = 0; d < 4; ++d) {\n                int nr = curr_r + dr[d];\n                int nc = curr_c + dc[d];\n                if (nr >= 0 && nr < N && nc >= 0 && nc < N && grid[nr][nc] == min_neighbor) {\n                    path_indices[step] = nr * N + nc;\n                    break;\n                }\n            }\n        }\n        \n        // Compare paths lexicographically using SVE\n        svint32_t curr_path_vec = svld1(pg, curr_path.data());\n        svint32_t result_vec = svld1(pg, result.data());\n        \n        svbool_t cmp = svcmplt_s32(pg, curr_path_vec, result_vec);\n        if (svptest_any(pg, cmp)) {\n            result = curr_path;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current(k);\n    int min_start = INT_MAX;\n    int start_row = 0, start_col = 0;\n\n    // Find minimum starting cell using SVE\n    svbool_t pg = svwhilelt_b32(0, N * N);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    svint32_t row_idx = svdup_s32(0);\n    svint32_t col_idx = svdup_s32(0);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            svint32_t value = svdup_s32(grid[i][j]);\n            svbool_t cmp = svcmplt_s32(pg, value, min_vec);\n            min_vec = svsel_s32(cmp, value, min_vec);\n            row_idx = svsel_s32(cmp, svdup_s32(i), row_idx);\n            col_idx = svsel_s32(cmp, svdup_s32(j), col_idx);\n        }\n    }\n\n    min_start = svminv_s32(pg, min_vec);\n    start_row = svlastb_s32(pg, row_idx);\n    start_col = svlastb_s32(pg, col_idx);\n\n    // Initialize result with the minimum starting cell\n    result[0] = min_start;\n    current[0] = min_start;\n\n    // Directions for neighboring cells (up, right, down, left)\n    const int dr[] = {-1, 0, 1, 0};\n    const int dc[] = {0, 1, 0, -1};\n\n    // For each step after the first\n    for (int step = 1; step < k; ++step) {\n        svint32_t min_neighbor = svdup_s32(INT_MAX);\n        svbool_t pg_step = svwhilelt_b32(0, 4);\n        svint32_t neighbor_values = svdup_s32(INT_MAX);\n\n        // Check all four directions\n        for (int d = 0; d < 4; ++d) {\n            int nr = start_row + dr[d];\n            int nc = start_col + dc[d];\n            \n            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                svint32_t neighbor_val = svdup_s32(grid[nr][nc]);\n                svbool_t cmp = svcmplt_s32(pg_step, neighbor_val, min_neighbor);\n                min_neighbor = svsel_s32(cmp, neighbor_val, min_neighbor);\n            }\n        }\n\n        int min_val = svminv_s32(pg_step, min_neighbor);\n        current[step] = min_val;\n\n        // Update result if current path is lexicographically smaller\n        bool update = false;\n        for (int i = 0; i < step; ++i) {\n            if (current[i] < result[i]) {\n                update = true;\n                break;\n            } else if (current[i] > result[i]) {\n                break;\n            }\n        }\n        if (update || result[step] == INT_MAX) {\n            for (int i = 0; i <= step; ++i) {\n                result[i] = current[i];\n            }\n        }\n\n        // Update position to the cell with minimum value\n        for (int d = 0; d < 4; ++d) {\n            int nr = start_row + dr[d];\n            int nc = start_col + dc[d];\n            if (nr >= 0 && nr < N && nc >= 0 && nc < N && grid[nr][nc] == min_val) {\n                start_row = nr;\n                start_col = nc;\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    if (N == 0) return {};\n\n    // Flatten the grid into a 1D array for SIMD processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize result path with a large value\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current_path(k);\n\n    // Function to check if a position is valid\n    auto is_valid = [N](int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n\n    // Directions for neighboring cells (up, right, down, left)\n    int dx[4] = {-1, 0, 1, 0};\n    int dy[4] = {0, 1, 0, -1};\n\n    // Recursive function to explore paths with SIMD for path comparison\n    auto dfs = [&](auto&& self, int x, int y, int step) -> void {\n        if (step == k) {\n            // Use SVE to compare current_path with result\n            svbool_t pg = svptrue_b32();\n            bool update = false;\n            int i = 0;\n            while (i < k) {\n                svint32_t vec_curr = svdup_n_s32(current_path[i]);\n                svint32_t vec_res = svdup_n_s32(result[i]);\n                svbool_t cmp_lt = svcmplt_s32(pg, vec_curr, vec_res);\n                svbool_t cmp_eq = svcmpeq_s32(pg, vec_curr, vec_res);\n                if (svptest_any(pg, cmp_lt)) {\n                    update = true;\n                    break;\n                }\n                if (!svptest_any(pg, cmp_eq)) {\n                    break;\n                }\n                i++;\n            }\n            if (update || i == k) {\n                result = current_path;\n            }\n            return;\n        }\n\n        // Explore neighbors\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (is_valid(nx, ny)) {\n                current_path[step] = grid[nx][ny];\n                self(self, nx, ny, step + 1);\n            }\n        }\n    };\n\n    // Start DFS from each cell in the grid\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            current_path[0] = grid[i][j];\n            dfs(dfs, i, j, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t vec = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t odd_mask = svptrue_b8();\n    \n    while (svptest_any(pg, svcmpne_n_u64(pg, vec, 0))) {\n        svuint64_t digit = svmod_n_u64(pg, vec, 10);\n        vec = svdiv_n_u64(pg, vec, 10);\n        \n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64(pg, digit, 1), 1);\n        odd_mask = svand_b_z(pg, odd_mask, is_odd);\n        result = svsel_u64(is_odd, svmul_u64(pg, result, digit), result);\n    }\n    \n    return svptest_any(pg, odd_mask) ? svlastb_u64(pg, result) : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    // Buffer to store digits\n    uint64_t digits[32];\n    int digit_count = 0;\n\n    // Extract digits\n    while (n > 0) {\n        digits[digit_count++] = n % 10;\n        n /= 10;\n    }\n\n    // If no digits, return 0\n    if (digit_count == 0) return 0;\n\n    // Use SVE for processing digits\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    int i = 0;\n    int has_odd = 0;\n\n    // Process digits in chunks based on vector length\n    while (i < digit_count) {\n        // Get the number of active lanes\n        int64_t vl = svcntd();\n        svuint64_t vec_digits = svld1_u64(pg, &digits[i]);\n        svbool_t odd_mask = svcmpeq_n_u64(pg, svand_n_u64_z(pg, vec_digits, 1), 1);\n\n        // If any odd digit is found, multiply result by those digits\n        if (svptest_any(pg, odd_mask)) {\n            has_odd = 1;\n            svuint64_t odd_digits = svsel_u64(odd_mask, vec_digits, svdup_n_u64(1));\n            result *= svmulx_n_u64(pg, odd_digits, 1).d[0]; // Simplified multiplication\n        }\n\n        i += vl;\n        if (i >= digit_count) break;\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t result = svdup_u64(1);\n    svbool_t any_odd = svpfalse();\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        svuint64_t digit_vec = svdup_u64(digit);\n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64_z(pg, digit_vec, 1), 1);\n        \n        any_odd = svor_b_z(pg, any_odd, is_odd);\n        result = svsel_u64(is_odd, svmul_u64_z(pg, result, digit_vec), result);\n        \n        n /= 10;\n    }\n    \n    svbool_t no_odd_digits = svnot_b_z(pg, any_odd);\n    result = svsel_u64(no_odd_digits, svdup_u64(0), result);\n    \n    return svlasta_u64(pg, result);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t vec = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t any_odd = svpfalse();\n    \n    while (svptest_any(pg, svcmpne_n_u64(pg, vec, 0))) {\n        svuint64_t digit = svmod_n_u64(pg, vec, 10);\n        vec = svdiv_n_u64(pg, vec, 10);\n        \n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64(pg, digit, 1), 1);\n        any_odd = svorr_b_z(pg, any_odd, is_odd);\n        \n        svuint64_t masked_result = svsel_u64(is_odd, digit, svdup_u64(1));\n        result = svmul_u64_z(pg, result, masked_result);\n    }\n    \n    svbool_t all_even = svnot_b_z(pg, any_odd);\n    result = svsel_u64(all_even, svdup_u64(0), result);\n    \n    return svlasta_u64(pg, result);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, 10);\n    svuint64_t digits = svdup_n_u64(0);\n    svuint64_t result = svdup_n_u64(1);\n    svbool_t odd_mask = svdup_n_b64(false);\n    \n    // Extract digits\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        svuint64_t digit_vec = svdup_n_u64(digit);\n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64_z(pg, digit_vec, 1), 1);\n        odd_mask = svorr_b_z(pg, odd_mask, is_odd);\n        result = svmul_u64_m(is_odd, result, digit_vec);\n        n /= 10;\n    }\n    \n    // Check if any odd digits were found\n    if (!svptest_any(svptrue_b64(), odd_mask)) {\n        return 0;\n    }\n    \n    // Get first element of result vector\n    return svlasta_u64(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    size_t len = lst.size();\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        svint32_t int_vec = svcvt_s32_f32_x(pg, ceil_vec);\n        svint32_t sq_vec = svmul_s32_x(pg, int_vec, int_vec);\n        sum += svaddv_s32(pg, sq_vec);\n    }\n\n    for (; i < len; i++) {\n        int ceil_val = std::ceil(lst[i]);\n        sum += ceil_val * ceil_val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float>& lst) {\n    uint64_t total_sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= len; i += vl) {\n        // Load float values into a vector\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Round up to ceiling\n        svfloat32_t ceil_vec = svrintp_f32_x(pg, vec);\n\n        // Convert to int32_t vector\n        svint32_t int_vec = svcvt_s32_f32_x(pg, ceil_vec);\n\n        // Compute square of each element\n        svint32_t squared_vec = svmul_s32_x(pg, int_vec, int_vec);\n\n        // Compute sum of squared values in the vector\n        int32_t sum = svaddv_s32(pg, squared_vec);\n        total_sum += static_cast<uint64_t>(sum);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        float val = lst[i];\n        int32_t ceil_val = static_cast<int32_t>(ceilf(val));\n        total_sum += static_cast<uint64_t>(ceil_val * ceil_val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t vec;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    size_t len = lst.size();\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        vec = svld1_f32(pg, &lst[i]);\n        svint32_t ceil_vec = svceil_f32_z(pg, vec);\n        svint32_t square_vec = svmul_s32_z(pg, ceil_vec, ceil_vec);\n        sum += svaddv_s32(pg, square_vec);\n    }\n\n    for (; i < len; i++) {\n        int32_t ceil_val = std::ceil(lst[i]);\n        sum += ceil_val * ceil_val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float>& lst) {\n    uint64_t total_sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= len; i += vl) {\n        // Load float values into a vector\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Round up to ceiling\n        svfloat32_t ceil_vec = svrintp_f32_x(pg, vec);\n\n        // Convert to int32_t for squaring\n        svint32_t int_vec = svcvt_s32_f32_x(pg, ceil_vec);\n\n        // Square the values\n        svint32_t squared_vec = svmul_s32_x(pg, int_vec, int_vec);\n\n        // Compute partial sum for this vector\n        total_sum += svaddv_s32(pg, squared_vec);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        float val = lst[i];\n        int ceil_val = static_cast<int>(ceil(val));\n        total_sum += static_cast<uint64_t>(ceil_val * ceil_val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float>& lst) {\n    uint64_t total_sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zeros = svdup_f32(0.0f);\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &lst[i]);\n        svfloat32_t ceil_vec = svrintp_f32_x(pg, vec);\n        svfloat32_t squared_vec = svmul_f32_x(pg, ceil_vec, ceil_vec);\n        svfloat32_t sum_vec = svadd_f32_x(pg, zeros, squared_vec);\n        total_sum += svaddv_f32(pg, sum_vec);\n    }\n\n    for (; i < len; i++) {\n        float val = std::ceil(lst[i]);\n        total_sum += static_cast<uint64_t>(val * val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int result = -1;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    size_t len = arr.size() - 1;\n\n    while (i < len) {\n        // Calculate how many elements can be processed in this iteration\n        size_t remaining = len - i;\n        svbool_t active = svwhilelt_b32(i, len);\n        \n        // Load current and next elements\n        svint32_t curr = svld1_s32(active, &arr[i]);\n        svint32_t next = svld1_s32(active, &arr[i + 1]);\n        \n        // Compare if current element >= next element\n        svbool_t cmp = svcmplt_s32(active, curr, next);\n        \n        // If any comparison is true, find the first true index\n        if (svptest_any(pg, cmp)) {\n            // Find first true index\n            uint64_t mask = svcntw();\n            svbool_t first = svbrkb_z(pg, cmp);\n            result = i + svcntp_b32(pg, first) - 1;\n            break;\n        }\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n\n    int max_idx = -1;\n    svbool_t pg = svwhilelt_b32(0, arr.size() - 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data() + svcntw());\n        svint32_t vec_next = svld1_s32(pg, arr.data() + svcntw() + 1);\n        \n        svbool_t mask = svcmplt_s32(pg, vec_next, vec);\n        int32_t first_true = svlastb_s32(mask);\n        \n        if (first_true != -1) {\n            max_idx = std::max(max_idx, first_true + svcntw());\n        }\n        \n        pg = svwhilelt_b32(svcntw(), arr.size() - 1);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n\n    int result = -1;\n    size_t len = arr.size();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    for (size_t i = 0; i < len - 1; i += vec_len) {\n        // Adjust predicate for the last iteration if necessary\n        if (i + vec_len > len - 1) {\n            pg = svwhilelt_b32(i, len - 1);\n        }\n\n        // Load current and next elements\n        svint32_t curr = svld1(pg, &arr[i]);\n        svint32_t next = svld1(pg, &arr[i + 1]);\n\n        // Compare current > next\n        svbool_t cmp = svcmpgt(pg, curr, next);\n\n        // If any comparison is true, find the first true index\n        if (svptest_any(pg, cmp)) {\n            uint64_t mask = svcntp_b32(pg, cmp);\n            if (mask > 0) {\n                result = i + svffrstr_u64(cmp);\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) return -1;\n\n    int max_index = -1;\n    svbool_t pg = svwhilelt_b32(0, arr.size() - 1);\n    \n    // Load consecutive pairs of elements\n    svint32_t vec1 = svld1(pg, arr.data());\n    svint32_t vec2 = svld1(pg, arr.data() + 1);\n    \n    // Compare if current element is less than previous\n    svbool_t cmp = svcmplt(pg, vec2, vec1);\n    \n    // Find last true index\n    uint64_t mask = svcntp_b32(pg, cmp);\n    if (mask > 0) {\n        // Create index vector\n        svint32_t indices = svindex_s32(0, 1);\n        // Select indices where comparison is true\n        svint32_t result = svsel_s32(cmp, indices, svdup_n_s32(-1));\n        // Get maximum index\n        max_index = svmaxv_s32(pg, result);\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n\n    int result = -1;\n    size_t len = arr.size();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    svbool_t pg = svptrue_b32(); // Predicate for full vector\n\n    for (size_t i = 0; i < len - 1; i += vec_len) {\n        size_t remaining = std::min(vec_len, len - 1 - i);\n        svbool_t active_pg = svwhilelt_b32(i, i + remaining);\n\n        // Load current and next elements\n        svint32_t curr_vec = svld1_s32(active_pg, &arr[i]);\n        svint32_t next_vec = svld1_s32(active_pg, &arr[i + 1]);\n\n        // Compare if current > next\n        svbool_t cmp = svcmplt_s32(active_pg, next_vec, curr_vec);\n\n        // If any comparison is true, find the first index\n        if (svptest_any(active_pg, cmp)) {\n            uint64_t mask = svcntp_b32(active_pg, cmp);\n            if (mask > 0) {\n                result = i + __builtin_ctzll(mask);\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    svbool_t pg = svptrue_b32();\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    svbool_t neg_found = svpfalse();\n    svbool_t pos_found = svpfalse();\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg_loop, &lst[i]);\n        \n        // Negative numbers\n        svbool_t is_neg = svcmplt_s32(pg_loop, vec, svdup_n_s32(0));\n        max_neg = svsel_s32(is_neg, svmax_s32_m(is_neg, max_neg, vec), max_neg);\n        neg_found = svor_b_z(pg, neg_found, is_neg);\n        \n        // Positive numbers\n        svbool_t is_pos = svcmpgt_s32(pg_loop, vec, svdup_n_s32(0));\n        svint32_t safe_min = svsel_s32(is_pos, vec, svdup_n_s32(INT32_MAX));\n        min_pos = svsel_s32(is_pos, svmin_s32_m(is_pos, min_pos, safe_min), min_pos);\n        pos_found = svor_b_z(pg, pos_found, is_pos);\n    }\n    \n    int result_max_neg = neg_found[0] ? svmaxv_s32(pg, max_neg) : 0;\n    int result_min_pos = pos_found[0] ? svminv_s32(pg, min_pos) : 0;\n    \n    return {result_max_neg, result_min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n    \n    int largest_neg = 0;\n    int smallest_pos = 0;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        size_t elements = std::min(svcntw(), (int)(lst.size() - i));\n        svbool_t mask = svwhilelt_b32(i, lst.size());\n        \n        svint32_t vec = svld1_s32(mask, &lst[i]);\n        \n        // Negative numbers\n        svbool_t neg_mask = svcmplt_s32(mask, vec, svdup_n_s32(0));\n        if (svptest_any(mask, neg_mask)) {\n            found_neg = true;\n            max_neg = svsel_s32(neg_mask, svmax_s32_m(neg_mask, max_neg, vec), max_neg);\n        }\n        \n        // Positive numbers\n        svbool_t pos_mask = svcmpgt_s32(mask, vec, svdup_n_s32(0));\n        if (svptest_any(mask, pos_mask)) {\n            found_pos = true;\n            svint32_t valid_pos = svsel_s32(pos_mask, vec, svdup_n_s32(INT32_MAX));\n            min_pos = svsel_s32(pos_mask, svmin_s32_m(pos_mask, min_pos, valid_pos), min_pos);\n        }\n    }\n\n    if (found_neg) {\n        largest_neg = svmaxv_s32(pg, max_neg);\n    }\n    if (found_pos) {\n        smallest_pos = svminv_s32(pg, min_pos);\n        if (smallest_pos == INT32_MAX) smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t max_neg_vec = svdup_n_s32(INT_MIN);\n    svint32_t min_pos_vec = svdup_n_s32(INT_MAX);\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        svint32_t neg_vec = svsel_s32(neg_mask, vec, svdup_n_s32(INT_MIN));\n        svint32_t pos_vec = svsel_s32(pos_mask, vec, svdup_n_s32(INT_MAX));\n\n        max_neg_vec = svmax_s32_m(pg, max_neg_vec, neg_vec);\n        min_pos_vec = svmin_s32_m(pg, min_pos_vec, pos_vec);\n    }\n\n    largest_neg = svmaxv_s32(pg, max_neg_vec);\n    smallest_pos = svminv_s32(pg, min_pos_vec);\n\n    if (largest_neg == INT_MIN) largest_neg = 0;\n    if (smallest_pos == INT_MAX) smallest_pos = 0;\n\n    for (; i < len; ++i) {\n        int val = lst[i];\n        if (val < 0 && val > largest_neg) largest_neg = val;\n        if (val > 0 && (smallest_pos == 0 || val < smallest_pos)) smallest_pos = val;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int64_t max_neg = 0, min_pos = 0;\n    svbool_t pg = svwhilelt_b64(0, lst.size());\n    \n    if (!lst.empty()) {\n        svint64_t vec_max_neg = svdup_n_s64(INT64_MIN);\n        svint64_t vec_min_pos = svdup_n_s64(INT64_MAX);\n        svbool_t neg_mask = svptrue_b64();\n        svbool_t pos_mask = svptrue_b64();\n\n        for (size_t i = 0; i < lst.size(); i += svcntd()) {\n            pg = svwhilelt_b64(i, lst.size());\n            svint64_t vec = svld1_s64(pg, &lst[i]);\n            \n            neg_mask = svcmplt_s64(pg, vec, svdup_n_s64(0));\n            pos_mask = svcmpgt_s64(pg, vec, svdup_n_s64(0));\n            \n            vec_max_neg = svsel_s64(neg_mask, svmax_s64_m(neg_mask, vec_max_neg, vec), vec_max_neg);\n            vec_min_pos = svsel_s64(pos_mask, svmin_s64_m(pos_mask, vec_min_pos, vec), vec_min_pos);\n        }\n\n        max_neg = svmaxv_s64(svptrue_b64(), vec_max_neg);\n        min_pos = svminv_s64(svptrue_b64(), vec_min_pos);\n\n        if (max_neg == INT64_MIN) max_neg = 0;\n        if (min_pos == INT64_MAX) min_pos = 0;\n    }\n\n    return {static_cast<int>(max_neg), static_cast<int>(min_pos)};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t vec;\n    svbool_t pg = svptrue_b32();\n\n    for (; i + vl <= len; i += vl) {\n        // Load a chunk of the input vector into an SVE vector\n        vec = svld1_s32(pg, &lst[i]);\n\n        // Create masks for negative and positive numbers\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_s32(0));\n\n        // Extract negative numbers and find the maximum\n        if (svptest_any(pg, neg_mask)) {\n            int32_t max_neg = svmaxv_s32(pg, svsel_s32(neg_mask, vec, svdup_s32(INT32_MIN)));\n            if (largest_neg == 0 || max_neg > largest_neg) {\n                largest_neg = max_neg;\n            }\n        }\n\n        // Extract positive numbers and find the minimum\n        if (svptest_any(pg, pos_mask)) {\n            int32_t min_pos = svminv_s32(pg, svsel_s32(pos_mask, vec, svdup_s32(INT32_MAX)));\n            if (smallest_pos == 0 || min_pos < smallest_pos) {\n                smallest_pos = min_pos;\n            }\n        }\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        int val = lst[i];\n        if (val < 0 && (largest_neg == 0 || val > largest_neg)) {\n            largest_neg = val;\n        }\n        if (val > 0 && (smallest_pos == 0 || val < smallest_pos)) {\n            smallest_pos = val;\n        }\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t vl = svcntd();\n    svuint64_t vec_n, vec_fact;\n    \n    // Process factorials in chunks based on vector length\n    for (uint64_t i = 1; i <= n; i += vl) {\n        // Initialize vector for current chunk of numbers\n        svuint64_t vec_i = svindex_u64(i, 1);\n        vec_n = svdup_u64(n);\n        svbool_t mask = svcmple_u64(pg, vec_i, vec_n);\n        \n        // Compute factorial for each element in the vector\n        vec_fact = svdup_u64(1);\n        for (uint64_t j = 1; j <= n; ++j) {\n            svuint64_t vec_j = svdup_u64(j);\n            vec_fact = svmul_u64_m(mask, vec_fact, vec_j);\n        }\n        \n        // Multiply results of current chunk into final result\n        uint64_t temp_result = 1;\n        uint64_t buffer[vl];\n        svst1_u64(mask, buffer, vec_fact);\n        for (uint64_t k = 0; k < vl && (i + k) <= n; ++k) {\n            temp_result *= buffer[k];\n        }\n        result *= temp_result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t vl = svcntd();\n    svuint64_t vec_n, vec_fact;\n    \n    // Process factorials in chunks based on vector length\n    for (uint64_t i = 1; i <= n; i += vl) {\n        // Initialize vector for current chunk of numbers\n        svuint64_t vec_i = svindex_u64(i, 1);\n        vec_n = svdup_u64(n);\n        svbool_t mask = svcmple_u64(pg, vec_i, vec_n);\n        \n        // Compute factorial for each element in the vector\n        vec_fact = svdup_u64(1);\n        for (uint64_t j = 1; j <= n; ++j) {\n            svuint64_t vec_j = svdup_u64(j);\n            vec_fact = svmul_u64_m(mask, vec_fact, vec_j);\n        }\n        \n        // Multiply the results of the vector into the final result\n        for (uint64_t k = 0; k < vl; ++k) {\n            if (i + k <= n) {\n                result *= svlasta_u64(svsel_u64(mask, vec_fact, svdup_u64(1)));\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    \n    // Create vector of numbers from 1 to n\n    svuint64_t vec = svindex_u64(1, 1);\n    svuint64_t factorial = svdup_u64(1);\n    \n    // Compute factorials for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        svuint64_t current = svdup_u64(i);\n        svbool_t mask = svwhilele_b64(1, i);\n        \n        // Compute factorial for current number\n        svuint64_t temp = svdup_u64(1);\n        for (uint64_t j = 1; j <= i; j++) {\n            temp = svmul_u64_z(mask, temp, svdup_u64(j));\n        }\n        \n        // Store current factorial in vector\n        factorial = svsel_u64(mask, temp, factorial);\n        \n        // Multiply result with current factorial\n        uint64_t single_fact = svlasta_u64(svnot_b_z(pg, mask), factorial);\n        result *= single_fact;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        svuint64_t vec_i = svdup_u64(i);\n        svuint64_t vec_fact = svdup_u64(1);\n        for (uint64_t j = 1; j <= i; ++j) {\n            svuint64_t vec_j = svdup_u64(j);\n            vec_fact = svmul_u64_m(pg, vec_fact, vec_j);\n        }\n        vec_result = svmul_u64_m(pg, vec_result, svdup_u64(svaddv_u64(pg, vec_fact)));\n    }\n\n    result = svaddv_u64(pg, vec_result);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t vector_size = svcntd();\n\n    // Process factorials in chunks based on vector size\n    for (uint64_t i = 1; i <= n; i += vector_size) {\n        svuint64_t fact_vec = svdup_u64(1);\n        uint64_t limit = (i + vector_size - 1 > n) ? n : i + vector_size - 1;\n\n        // Compute factorial for each element in the current chunk\n        for (uint64_t j = i; j <= limit; ++j) {\n            svuint64_t idx_vec = svindex_u64(j, 0);\n            svuint64_t temp = svdup_u64(1);\n\n            // Compute factorial for the current number j\n            for (uint64_t k = 1; k <= j; ++k) {\n                svuint64_t k_vec = svdup_u64(k);\n                temp = svmul_u64_z(pg, temp, k_vec);\n            }\n\n            // Update the result vector for the current position\n            svbool_t mask = svcmpeq_u64(pg, idx_vec, svdup_u64(j));\n            fact_vec = svsel_u64(mask, temp, fact_vec);\n        }\n\n        // Multiply the results of the current chunk into the final result\n        for (uint64_t j = i; j <= limit; ++j) {\n            result *= svlasta_u64(pg, fact_vec);\n            fact_vec = svext_u64(fact_vec, fact_vec, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Handle empty vector\n    if (len == 0) return 0;\n\n    // Process vector in chunks using SVE\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load indices\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Create predicates for multiples of 3 and 4\n        svuint32_t three = svdup_u32(3);\n        svuint32_t four = svdup_u32(4);\n        svbool_t mod3 = svcmpeq_n_u32(pg, svmod_u32(indices, three), 0);\n        svbool_t mod4 = svcmpeq_n_u32(pg, svmod_u32(indices, four), 0);\n        \n        // Create predicate for multiples of 4 and not 3\n        svbool_t mod4_not3 = svand_b_z(pg, mod4, svnot_b_z(pg, mod3));\n        \n        // Load input data\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Square multiples of 3\n        svint32_t squared = svmul_s32_z(mod3, vec, vec);\n        \n        // Cube multiples of 4 and not 3\n        svint32_t cubed = svmul_s32_z(mod4_not3, vec, svmul_s32_z(mod4_not3, vec, vec));\n        \n        // Select results: squared for mod3, cubed for mod4_not3, original for others\n        svint32_t result = svsel_s32(mod3, squared, vec);\n        result = svsel_s32(mod4_not3, cubed, result);\n        \n        // Accumulate sum\n        sum += svaddv_s32(pg, result);\n        \n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n\n    // Process the vector in chunks based on SVE vector length\n    while (i < len) {\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b32(i, len);\n\n        // Load the data into an SVE vector\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Create index vector for the current chunk\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Check for multiples of 3\n        svint32_t mod3 = svmod_n_s32(pg, indices, 3);\n        svbool_t is_multiple_of_3 = svcmpeq_n_s32(pg, mod3, 0);\n\n        // Check for multiples of 4\n        svint32_t mod4 = svmod_n_s32(pg, indices, 4);\n        svbool_t is_multiple_of_4 = svcmpeq_n_s32(pg, mod4, 0);\n\n        // Combine conditions: multiple of 4 and not multiple of 3\n        svbool_t multiple_4_not_3 = svand_b_z(pg, is_multiple_of_4, svnot_b_z(pg, is_multiple_of_3));\n\n        // Square for multiples of 3\n        svint32_t squared = svmul_s32_m(is_multiple_of_3, vec, vec);\n        svint32_t result = svsel_s32(is_multiple_of_3, squared, vec);\n\n        // Cube for multiples of 4 and not 3\n        svint32_t cubed = svmul_s32_m(multiple_4_not_3, result, vec);\n        result = svsel_s32(multiple_4_not_3, cubed, result);\n\n        // Compute partial sum for this vector\n        sum += svaddv_s32(pg, result);\n\n        // Move to the next chunk\n        i += vl;\n    }\n\n    return static_cast<int>(sum);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int64_t sum = 0;\n    const int *data = lst.data();\n    size_t len = lst.size();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t i = 0;\n    \n    while (i < len) {\n        // Load vector\n        svint32_t vec = svld1(pg, data + i);\n        \n        // Create predicates for indices multiple of 3 and 4\n        svbool_t p3 = svptrue_b32();\n        svbool_t p4 = svptrue_b32();\n        svbool_t p_not3 = svptrue_b32();\n        \n        // Create index vector\n        svint32_t idx = svindex_s32(i, 1);\n        \n        // Check multiples of 3\n        svint32_t mod3 = svmod_n_s32(pg, idx, 3);\n        p3 = svcmpeq(pg, mod3, 0);\n        \n        // Check multiples of 4\n        svint32_t mod4 = svmod_n_s32(pg, idx, 4);\n        p4 = svcmpeq(pg, mod4, 0);\n        \n        // Check not multiple of 3\n        p_not3 = svcmpneq(pg, mod3, 0);\n        \n        // Combine predicates: multiple of 4 AND not multiple of 3\n        svbool_t p4_not3 = svand_b_z(svptrue_b32(), p4, p_not3);\n        \n        // Square elements where index is multiple of 3\n        svint32_t squared = svmul_s32_z(p3, vec, vec);\n        \n        // Cube elements where index is multiple of 4 and not 3\n        svint32_t cubed = svmul_s32_z(p4_not3, vec, svmul_s32_z(p4_not3, vec, vec));\n        \n        // Select squared values where p3 is true\n        svint32_t result = svsel_s32(p3, squared, vec);\n        \n        // Select cubed values where p4_not3 is true\n        result = svsel_s32(p4_not3, cubed, result);\n        \n        // Compute partial sum\n        sum += svaddv_s32(pg, result);\n        \n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        \n        svint32_t vec = svld1_s32(p, &data[i]);\n        \n        svbool_t idx_mod3 = svptrue_b32();\n        svbool_t idx_mod4 = svptrue_b32();\n        \n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t mod3 = svmod_n_u32_x(p, indices, 3);\n        svuint32_t mod4 = svmod_n_u32_x(p, indices, 4);\n        \n        idx_mod3 = svcmpeq_n_u32(p, mod3, 0);\n        idx_mod4 = svcmpeq_n_u32(p, mod4, 0);\n        \n        svbool_t mod3_not4 = svbic_b_z(p, idx_mod3, idx_mod4);\n        svbool_t mod4_not3 = svbic_b_z(p, idx_mod4, idx_mod3);\n        \n        svint32_t squared = svmul_s32_m(mod3_not4, vec, vec);\n        svint32_t cubed = svmul_s32_m(mod4_not3, vec, svmul_s32_x(p, vec, vec));\n        \n        svint32_t result = svsel_s32(idx_mod3, squared, vec);\n        result = svsel_s32(idx_mod4, cubed, result);\n        \n        sum += svaddv_s32(p, result);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    const int* data = lst.data();\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Create predicate for vector length\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    // Process vectorized chunks\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load input vector\n        svint32_t vec = svld1_s32(pg, data + i);\n\n        // Create predicates for indices multiple of 3 and 4\n        svbool_t mod3 = svptrue_b32();\n        svbool_t mod4 = svptrue_b32();\n        svbool_t not_mod3 = svptrue_b32();\n\n        // Generate indices\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Check multiples of 3\n        svuint32_t three = svdup_u32(3);\n        svuint32_t mod3_val = svmod_u32_x(pg, indices, three);\n        mod3 = svcmpeq(pg, mod3_val, svdup_u32(0));\n\n        // Check multiples of 4\n        svuint32_t four = svdup_u32(4);\n        svuint32_t mod4_val = svmod_u32_x(pg, indices, four);\n        mod4 = svcmpeq(pg, mod4_val, svdup_u32(0));\n\n        // Check not multiple of 3 for indices multiple of 4\n        not_mod3 = svnot_b_z(pg, mod3);\n\n        // Combine predicates: multiple of 4 and not multiple of 3\n        svbool_t mod4_not_mod3 = svand_b_z(pg, mod4, not_mod3);\n\n        // Square elements where index is multiple of 3\n        svint32_t squared = svmul_s32_m(mod3, vec, vec);\n\n        // Cube elements where index is multiple of 4 and not 3\n        svint32_t cubed = svmul_s32_m(mod4_not_mod3, svmul_s32_m(mod4_not_mod3, vec, vec), vec);\n\n        // Combine results: use squared where mod3, cubed where mod4_not_mod3, original otherwise\n        svint32_t result = svsel_s32(mod3, squared, vec);\n        result = svsel_s32(mod4_not_mod3, cubed, result);\n\n        // Sum the vector elements\n        sum += svaddv_s32(pg, result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    size_t len = nums.size();\n\n    while (i < len) {\n        // Load vector\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if numbers > 10\n        svbool_t gt10 = svcmpgt_s32(pg, vec, 10);\n        \n        // Get absolute values for digit checking\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract last digit (abs_vec % 10)\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Extract first digit by repeatedly dividing by 10\n        svint32_t temp = abs_vec;\n        svint32_t first_digit = abs_vec;\n        svbool_t div_mask = svcmpge_s32(pg, temp, 10);\n        while (svptest_any(pg, div_mask)) {\n            first_digit = svsel_s32(div_mask, svdiv_n_s32_z(pg, temp, 10), first_digit);\n            temp = svsel_s32(div_mask, svdiv_n_s32_z(pg, temp, 10), temp);\n            div_mask = svcmpge_s32(pg, temp, 10);\n        }\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_z(pg,\n            svcmpeq_s32(pg, last_digit, 1),\n            svorr_z(pg,\n                svcmpeq_s32(pg, last_digit, 3),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svorr_z(pg,\n                        svcmpeq_s32(pg, last_digit, 7),\n                        svcmpeq_s32(pg, last_digit, 9)\n                    )\n                )\n            )\n        );\n        \n        svbool_t first_odd = svorr_z(pg,\n            svcmpeq_s32(pg, first_digit, 1),\n            svorr_z(pg,\n                svcmpeq_s32(pg, first_digit, 3),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svorr_z(pg,\n                        svcmpeq_s32(pg, first_digit, 7),\n                        svcmpeq_s32(pg, first_digit, 9)\n                    )\n                )\n            )\n        );\n        \n        // Combine conditions\n        svbool_t match = svand_z(pg, gt10, svand_z(pg, first_odd, last_odd));\n        \n        // Count matches\n        count += svcntp_b32(pg, match);\n        \n        // Move to next vector\n        i += svcntw();\n        \n        // Update predicate for remaining elements\n        if (i < len) {\n            pg = svwhilelt_b32(i, len);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    size_t i = 0;\n\n    while (i < nums.size()) {\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt_10 = svcmpgt_s32(pg, vec, 10);\n        \n        // Extract first and last digits\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Approximate first digit by dividing until < 10\n        svint32_t first_digit = abs_vec;\n        svbool_t div_mask = svcmpge_s32(pg, first_digit, 10);\n        while (svptest_any(pg, div_mask)) {\n            first_digit = svdiv_n_s32_z(pg, first_digit, 10);\n            div_mask = svcmpge_s32(pg, first_digit, 10);\n        }\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_z(pg,\n            svcmpeq_s32(pg, last_digit, 1),\n            svorr_z(pg,\n                svcmpeq_s32(pg, last_digit, 3),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svorr_z(pg,\n                        svcmpeq_s32(pg, last_digit, 7),\n                        svcmpeq_s32(pg, last_digit, 9)\n                    )\n                )\n            )\n        );\n        \n        svbool_t first_odd = svorr_z(pg,\n            svcmpeq_s32(pg, first_digit, 1),\n            svorr_z(pg,\n                svcmpeq_s32(pg, first_digit, 3),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svorr_z(pg,\n                        svcmpeq_s32(pg, first_digit, 7),\n                        svcmpeq_s32(pg, first_digit, 9)\n                    )\n                )\n            )\n        );\n        \n        // Combine conditions\n        svbool_t result_mask = svand_z(pg, gt_10, svand_z(pg, first_odd, last_odd));\n        \n        // Count true predicates\n        count += svcntp_b32(pg, result_mask);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, nums.size());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, nums.size());\n    \n    for (; i < nums.size(); ) {\n        // Load vector\n        svint32_t vec = svld1(pg, &nums[i]);\n        \n        // Check if number > 10\n        svbool_t gt_10 = svcmpgt(pg, vec, 10);\n        \n        // Get absolute values for digit checks\n        svint32_t abs_vec = svabs_z(pg, vec);\n        \n        // Extract last digit (abs_vec % 10)\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Extract first digit by repeatedly dividing by 10\n        svint32_t temp = abs_vec;\n        while (svcntw() > 0 && svptest_any(pg, svcmpgt(pg, temp, 9))) {\n            temp = svdiv_n_s32_z(pg, temp, 10);\n        }\n        svint32_t first_digit = temp;\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svcmpeq_n_s32(pg, last_digit, 1);\n        last_odd = svorr_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 3));\n        last_odd = svorr_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 5));\n        last_odd = svorr_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 7));\n        last_odd = svorr_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 9));\n        \n        svbool_t first_odd = svcmpeq_n_s32(pg, first_digit, 1);\n        first_odd = svorr_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 3));\n        first_odd = svorr_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 5));\n        first_odd = svorr_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 7));\n        first_odd = svorr_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 9));\n        \n        // Combine conditions\n        svbool_t valid = svand_z(pg, gt_10, svand_z(pg, first_odd, last_odd));\n        \n        // Count valid elements\n        count += svcntp_b32(pg, valid);\n        \n        // Update loop\n        i += svcntw();\n        pg = svwhilelt_b32(i, nums.size());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    size_t n = nums.size();\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    while (i < n) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = n - i;\n        svbool_t active = svwhilelt_b32(i, n);\n        pg = svand_b_z(svptrue_b32(), active, svptrue_b32());\n\n        // Load the data into an SVE vector\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n\n        // Check if number > 10\n        svbool_t gt_10 = svcmpgt_s32(pg, vec, 10);\n\n        // Extract first and last digits\n        // Last digit: num % 10\n        svint32_t last_digit = svmod_n_s32_z(pg, vec, 10);\n        // First digit: num / 10^(number of digits - 1)\n        // Approximate by repeatedly dividing by 10 until < 10\n        svint32_t temp = svabs_s32_z(pg, vec);\n        svbool_t not_zero = svcmpne_s32(pg, temp, 0);\n        svint32_t first_digit = svdup_n_s32(0);\n\n        // Loop to find first digit (approximation for vector)\n        while (svptest_any(svptrue_b32(), not_zero)) {\n            svbool_t gt_9 = svcmpgt_s32(pg, temp, 9);\n            first_digit = svsel_s32(gt_9, temp, first_digit);\n            temp = svdiv_n_s32_z(pg, temp, 10);\n            not_zero = svcmpne_s32(pg, temp, 0);\n        }\n\n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_b_z(pg,\n            svcmpeq_s32(pg, last_digit, 1),\n            svorr_b_z(pg,\n                svcmpeq_s32(pg, last_digit, 3),\n                svorr_b_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svorr_b_z(pg,\n                        svcmpeq_s32(pg, last_digit, 7),\n                        svcmpeq_s32(pg, last_digit, 9)\n                    )\n                )\n            )\n        );\n\n        svbool_t first_odd = svorr_b_z(pg,\n            svcmpeq_s32(pg, first_digit, 1),\n            svorr_b_z(pg,\n                svcmpeq_s32(pg, first_digit, 3),\n                svorr_b_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svorr_b_z(pg,\n                        svcmpeq_s32(pg, first_digit, 7),\n                        svcmpeq_s32(pg, first_digit, 9)\n                    )\n                )\n            )\n        );\n\n        // Combine conditions: number > 10 and both digits odd\n        svbool_t condition = svand_b_z(pg, gt_10, svand_b_z(pg, first_odd, last_odd));\n\n        // Count the number of true elements in the predicate\n        count += svcntp_b32(pg, condition);\n\n        // Move to the next set of elements\n        i += svcntw();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    size_t len = nums.size();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= len - vec_len; i += vec_len) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &nums[i]);\n        svbool_t gt_10 = svcmpgt_n_s32(svptrue_b32(), vec, 10);\n\n        svint32_t abs_vec = svabs_s32_z(svptrue_b32(), vec);\n        svint32_t first_digit_vec = svdiv_n_s32_z(svptrue_b32(), abs_vec, 10);\n        svint32_t last_digit_vec = svmod_n_s32_z(svptrue_b32(), abs_vec, 10);\n\n        svbool_t first_odd = svand_b_z(svptrue_b32(), svcmpeq_n_s32(svptrue_b32(), svmod_n_s32_z(svptrue_b32(), first_digit_vec, 2), 1), gt_10);\n        svbool_t last_odd = svand_b_z(svptrue_b32(), svcmpeq_n_s32(svptrue_b32(), svmod_n_s32_z(svptrue_b32(), last_digit_vec, 2), 1), gt_10);\n\n        svbool_t condition = svand_b_z(svptrue_b32(), first_odd, last_odd);\n        count += svcntp_b32(svptrue_b32(), condition);\n    }\n\n    for (; i < len; i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int first_digit = abs_num;\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = abs_num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    // Allocate array for storing values of a[i] = i*i - i + 1\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Compute a[i] using SVE for parallelism\n    svbool_t pg = svwhilelt_b64(0, n);\n    uint64_t i = 0;\n    do {\n        svuint64_t idx = svindex_u64(i, 1);\n        svuint64_t idx_sq = svmul_u64_z(pg, idx, idx);\n        svuint64_t temp = svsub_u64_z(pg, idx_sq, idx);\n        svuint64_t vals = svadd_u64_z(pg, temp, 1);\n        svst1_u64(pg, &a[i], vals);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    // Count residues modulo 3\n    uint64_t count[3] = {0, 0, 0};\n    i = 0;\n    pg = svwhilelt_b64(0, n);\n    do {\n        svuint64_t vals = svld1_u64(pg, &a[i]);\n        svuint64_t mod_vals = svand_u64_z(pg, vals, 3);\n        for (uint64_t j = 0; j < svcntd(); j++) {\n            if (i + j < n) {\n                uint64_t residue = svlasta_u64(svpfalse_b(), svsel_u64(svptrue_b64(), mod_vals, svdup_u64(0)));\n                count[residue]++;\n                mod_vals = svext_u64(mod_vals, mod_vals, 1);\n            }\n        }\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    // Compute number of valid triples\n    uint64_t result = 0;\n    // Case 1: All three residues are 0\n    result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    // Case 2: All three residues are 1\n    result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    // Case 3: All three residues are 2\n    result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    // Case 4: One of each residue (0,1,2)\n    result += count[0] * count[1] * count[2];\n\n    free(a);\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    // Allocate array for a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Compute a[i] = i*i - i + 1 vectorized\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, n);\n        svuint64_t indices = svindex_u64(i, 1);\n        svuint64_t i_minus_1 = svsub_u64_z(p, indices, 1);\n        svuint64_t sq = svmul_u64_z(p, indices, indices);\n        svuint64_t result = svadd_u64_z(p, sq, 1);\n        result = svsub_u64_z(p, result, i_minus_1);\n        svst1_u64(p, &a[i], result);\n    }\n    \n    // Count triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pk = svwhilelt_b64(j+1, n);\n            svuint64_t a_i = svdup_u64(a[i]);\n            svuint64_t a_j = svdup_u64(a[j]);\n            svuint64_t indices_k = svindex_u64(j+1, 1);\n            svuint64_t a_k = svld1_u64(pk, &a[j+1]);\n            \n            // Compute sum = a[i] + a[j] + a[k]\n            svuint64_t sum = svadd_u64_z(pk, a_i, a_j);\n            sum = svadd_u64_z(pk, sum, a_k);\n            \n            // Check if sum is divisible by 3\n            svuint64_t mod3 = svmul_u64_z(pk, sum, 0xAAAAAAAB); // Approx 1/3\n            svuint64_t check = svmul_u64_z(pk, mod3, 3);\n            svbool_t is_div3 = svcmpeq_u64(pk, check, sum);\n            \n            // Count valid triples\n            count += svcntp_b64(is_div3);\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    // Allocate memory for the array\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Calculate vector length for SVE\n    uint64_t vl = svcntd();\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    // Compute a[i] = i*i - i + 1 for all i\n    for (uint64_t i = 0; i < n; i += vl) {\n        pg = svwhilelt_b64(i, n);\n        svuint64_t idx = svindex_u64(i, 1);\n        svuint64_t idx2 = svmul_u64_z(pg, idx, idx);\n        svuint64_t temp = svsub_u64_z(pg, idx2, idx);\n        svuint64_t result = svadd_u64_z(pg, temp, 1);\n        svst1_u64(pg, &a[i], result);\n    }\n\n    // Count residues modulo 3\n    uint64_t count[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; i += vl) {\n        pg = svwhilelt_b64(i, n);\n        svuint64_t vals = svld1_u64(pg, &a[i]);\n        svuint64_t mod_vals = svand_u64_z(pg, vals, 3);\n        for (uint64_t j = 0; j < vl && i + j < n; j++) {\n            uint64_t mod_val = svclastb_u64(pg, 0, mod_vals);\n            count[mod_val]++;\n            mod_vals = svext_u64(mod_vals, mod_vals, 1);\n        }\n    }\n\n    // Compute number of valid triples\n    uint64_t triples = 0;\n    // Case 1: All three residues are 0\n    triples += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    // Case 2: All three residues are 1\n    triples += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    // Case 3: All three residues are 2\n    triples += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    // Case 4: One of each residue (0,1,2)\n    triples += count[0] * count[1] * count[2];\n\n    free(a);\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n    \n    // Compute array a using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t idx = svindex_u64(i, 1);\n        svuint64_t idx_squared = svmul_u64_z(pg, idx, idx);\n        svuint64_t idx_minus_one = svsub_u64_z(pg, idx, 1);\n        svuint64_t result = svadd_u64_z(pg, svmul_u64_z(pg, idx, idx_minus_one), 1);\n        svst1_u64(pg, &a[i], result);\n    }\n    \n    // Count triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pk = svwhilelt_b64(j+1, n);\n            svuint64_t sum_ij = svdup_u64(a[i] + a[j]);\n            svuint64_t k_vec = svindex_u64(j+1, 1);\n            svuint64_t a_k = svld1_u64(pk, &a[j+1]);\n            svuint64_t sum = svadd_u64_z(pk, sum_ij, a_k);\n            svuint64_t mod3 = svmla_u64_z(pk, svdup_u64(0), sum, svdup_u64(1431655765)); // 1/3 approximation\n            svbool_t is_multiple = svcmpeq_u64(pk, mod3, 0);\n            count += svcntp_b64(pk, is_multiple);\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n\n    // Generate array a using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t idx = svindex_u64(i, 1);\n        svbool_t p = svwhilelt_b64(i, n);\n        svuint64_t idx_sq = svmul_u64_z(p, idx, idx);\n        svuint64_t idx_minus_one = svsub_u64_z(p, idx, 1);\n        svuint64_t result = svsub_u64_z(p, idx_sq, idx_minus_one);\n        result = svadd_u64_z(p, result, 1);\n        svst1_u64(p, &a[i], result);\n    }\n\n    // Count triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            svbool_t pk = svwhilelt_b64(j + 1, n);\n            svuint64_t sum_ij = svdup_u64(a[i] + a[j]);\n            svuint64_t k_vec = svindex_u64(j + 1, 1);\n            svuint64_t a_k = svld1_gather_u64index_u64(pk, a, k_vec);\n            \n            // Compute sum of triple mod 3\n            svuint64_t sum = svadd_u64_z(pk, sum_ij, a_k);\n            svuint64_t mod3 = svmul_u64_z(pk, sum, 0xAAAAAAAB); // Approx 1/3 in 64-bit\n            mod3 = svmul_u64_z(pk, mod3, 3);\n            svbool_t is_multiple = svcmpeq_u64(pk, mod3, sum);\n            \n            // Count true predicates\n            count += svcntp_b64(pk, is_multiple);\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Since SVE operates on vectors, we need to handle scalar input.\n    // This implementation checks if n is prime in a scalar way but uses SVE for potential vectorization if needed.\n    // However, as the input is scalar, the actual computation remains scalar.\n    // SVE is used here to demonstrate the structure for vectorized inputs if applicable.\n\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n\n    int is_prime = 1;\n    int limit = (int)sqrt(n) + 1;\n    svbool_t pg = svwhilelt_b32(3, limit);\n    svint32_t vec_i = svindex_s32(3, 2); // Start from 3, step by 2 (odd numbers)\n    svint32_t vec_n = svdup_s32(n);\n    svint32_t vec_rem = svmod_s32_z(pg, vec_n, vec_i);\n    svbool_t rem_zero = svcmpeq_s32(pg, vec_rem, 0);\n\n    if (svptest_any(pg, rem_zero)) {\n        is_prime = 0;\n    } else {\n        // Continue checking in scalar mode if vectorized check didn't cover all\n        for (int i = svcntw() * 2 + 3; i < limit; i += 2) {\n            if (n % i == 0) {\n                is_prime = 0;\n                break;\n            }\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Create vector of n values\n    svbool_t pg = svwhilelt_b32(0, 1);\n    svint32_t vn = svdup_s32(n);\n    \n    // Initialize result vector with y\n    svint32_t result = svdup_s32(y);\n    \n    // Check if n >= 2 (basic prime requirement)\n    svbool_t ge_2 = svcmpge_s32(pg, vn, 2);\n    \n    if (svptest_any(pg, ge_2)) {\n        // Create vectors for divisibility check\n        svint32_t vcount = svindex_s32(2, 1);\n        svint32_t vlimit = svdup_s32(n);\n        \n        // Count divisors\n        svbool_t divisors = svcmplt_s32(pg, vcount, vlimit);\n        svint32_t vmod = svmod_s32_z(divisors, vn, vcount);\n        svbool_t is_divisor = svcmpeq_s32(divisors, vmod, 0);\n        \n        // Count number of divisors\n        uint64_t divisor_count = svcntp_b32(pg, is_divisor);\n        \n        // If exactly 2 divisors (1 and n), it's prime, so return x\n        if (divisor_count == 2) {\n            result = svdup_s32(x);\n        }\n    }\n    \n    // Extract scalar result\n    return svlasta_s32(svptrue_b32(), result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Since SVE operates on vectors, we need to handle scalar input.\n    // This implementation checks if n is prime in a scalar way but uses SVE for potential vectorization if needed.\n    // However, as the input is scalar, the actual computation remains scalar.\n    // SVE is included as per requirement, though the problem's nature doesn't benefit from vectorization directly.\n\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n\n    // Use SVE to create a vectorized check for divisibility up to sqrt(n)\n    int sqrt_n = (int)sqrt(n);\n    svbool_t pg = svwhilelt_b32(3, sqrt_n + 1);\n    svint32_t divisors = svindex_s32(3, 2); // Vector of odd numbers starting from 3\n    svint32_t n_vec = svdup_s32(n);\n    svint32_t remainder = svmod_s32_z(pg, n_vec, divisors);\n    svbool_t is_divisible = svcmpeq_s32(pg, remainder, 0);\n\n    // Check if any divisor divides n\n    if (svptest_any(pg, is_divisible)) {\n        return y;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Create vectors for input values\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n    \n    // Initialize result vector\n    svint32_t result = vy;\n    \n    // Check if n >= 2 (basic prime condition)\n    svbool_t ge2 = svcmpge(pg, vn, svdup_n_s32(2));\n    \n    if (svptest_any(pg, ge2)) {\n        // Initialize divisors vector starting from 2\n        svint32_t divisors = svindex_s32(2, 1);\n        svint32_t limit = svdup_n_s32((int)sqrt(n) + 1);\n        \n        // Check divisibility\n        svbool_t is_prime = svptrue_b32();\n        \n        while (svptest_any(pg, svcmple(pg, divisors, limit))) {\n            svint32_t remainders = svmod_n_s32(pg, vn, divisors);\n            svbool_t divides = svcmpeq(pg, remainders, svdup_n_s32(0));\n            is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, divides));\n            divisors = svadd_n_s32(pg, divisors, 1);\n        }\n        \n        // Select x if prime, y if not prime\n        result = svsel_s32(is_prime, vx, vy);\n    }\n    \n    // Return first element of result vector\n    return svlasta_s32(pg, result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n    \n    // Check if n < 2 (not prime)\n    svbool_t not_prime = svcmplt_s32(pg, vn, svdup_n_s32(2));\n    \n    // Check if n is even (except 2)\n    svbool_t even = svcmpeq_s32(pg, svand_n_s32(pg, vn, 1), svdup_n_s32(0));\n    svbool_t even_not_two = svand_b_z(pg, even, svcmpne_s32(pg, vn, svdup_n_s32(2)));\n    \n    // Check divisibility up to sqrt(n)\n    int32_t sqrt_n = (int32_t)sqrt(n);\n    svint32_t divisors = svindex_s32(3, 2); // Start from 3, step 2\n    svbool_t div_mask = svwhilelt_b32_s32(3, sqrt_n + 1);\n    \n    svbool_t is_prime = svptrue_b32();\n    while (svptest_any(pg, div_mask)) {\n        svint32_t remainders = svmod_s32_z(div_mask, vn, divisors);\n        svbool_t divides = svcmpeq_s32(div_mask, remainders, svdup_n_s32(0));\n        is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, divides));\n        divisors = svadd_s32_z(div_mask, divisors, svdup_n_s32(2));\n        div_mask = svwhilelt_b32_s32(svminv_s32(div_mask, divisors), sqrt_n + 1);\n    }\n    \n    // Combine conditions: not prime if n < 2 or even (except 2) or divisible\n    is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, not_prime));\n    is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, even_not_two));\n    \n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_prime, vx, vy);\n    \n    // Return first element of result vector\n    return svlasta_s32(pg, result);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n    svbool_t pg = svptrue_b32();\n\n    while (i < len) {\n        // Determine how many elements to process in this iteration\n        svbool_t active = svwhilelt_b32(i, len);\n        pg = svand_b_z(svptrue_b32(), active, active);\n\n        // Load the vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Check for negative numbers (ignore if negative)\n        svbool_t not_negative = svcmpge_f32(pg, vec, svdup_f32(0.0f));\n\n        // Check if numbers are integers by comparing with their floor value\n        svfloat32_t floor_vec = svrinti_f32_z(pg, vec);\n        svbool_t is_integer = svcmpeq_f32(pg, vec, floor_vec);\n\n        // Check for odd numbers by converting to int and checking LSB\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t is_odd = svtst_s32_z(pg, int_vec, 1);\n\n        // Combine conditions: not negative, is integer, and is odd\n        svbool_t condition = svand_b_z(pg, not_negative, is_integer);\n        condition = svand_b_z(pg, condition, is_odd);\n\n        // Compute squares for elements meeting the condition\n        svfloat32_t square_vec = svmul_f32_z(pg, vec, vec);\n\n        // Convert squares to integers\n        svint32_t square_int_vec = svcvt_s32_f32_z(pg, square_vec);\n\n        // Accumulate sum for elements meeting the condition\n        sum += svaddv_s32(svsel_s32(condition, square_int_vec, svdup_s32(0)));\n\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    do {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svbool_t is_positive = svcmpge_f32(pg, vec, svdup_f32(0.0f));\n        svfloat32_t vec_int = svrintn_f32_x(pg, vec);\n        svbool_t is_integer = svcmpeq_f32(pg, vec, vec_int);\n        svbool_t valid = svand_b_z(pg, is_positive, is_integer);\n        svfloat32_t vec_odd_check = svmod_f32_x(valid, vec_int, svdup_f32(2.0f));\n        svbool_t is_odd = svcmpeq_f32(valid, vec_odd_check, svdup_f32(1.0f));\n        svfloat32_t squared = svmul_f32_m(is_odd, vec, vec);\n        sum += svadda_f32(is_odd, 0, squared);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n    svbool_t pg = svptrue_b32();\n\n    while (i < len) {\n        // Determine how many elements to process in this iteration\n        svbool_t active = svwhilelt_b32(i, len);\n        pg = svand_b_z(svptrue_b32(), active, active);\n\n        // Load the vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Check for positive numbers\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n\n        // Check if numbers are integers by comparing with their floor value\n        svfloat32_t floor_vec = svrinti_f32_z(pg, vec);\n        svbool_t int_mask = svcmpeq_f32(pg, vec, floor_vec);\n\n        // Check for odd numbers by casting to int and checking LSB\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t odd_mask = svtst_s32_z(pg, int_vec, 1);\n\n        // Combine masks: positive, integer, and odd\n        svbool_t final_mask = svand_b_z(pg, pos_mask, svand_b_z(pg, int_mask, odd_mask));\n\n        // Compute squares for elements that pass the conditions\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n\n        // Accumulate sum of squares\n        float local_sum = svadda_f32(final_mask, 0.0f, squared);\n        sum += static_cast<uint64_t>(local_sum);\n\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n    svbool_t pg = svptrue_b32();\n\n    while (i < len) {\n        // Determine how many elements to process in this iteration\n        svbool_t active = svwhilelt_b32(i, len);\n        pg = svand_b_z(svptrue_b32(), active, active);\n\n        // Load the vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Check for positive values\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n\n        // Check if values are integers by comparing with their floor\n        svfloat32_t floor_vec = svrinti_f32_z(pg, vec);\n        svbool_t int_mask = svcmpeq_f32(pg, vec, floor_vec);\n\n        // Combine masks for positive integers\n        svbool_t valid_mask = svand_b_z(pg, pos_mask, int_mask);\n\n        // Convert to integers for odd check\n        svint32_t int_vec = svcvt_s32_f32_z(valid_mask, vec);\n\n        // Check for odd numbers (LSB is 1)\n        svbool_t odd_mask = svtst_s32_z(valid_mask, int_vec, 1);\n\n        // Square the valid odd numbers\n        svfloat32_t squared = svmul_f32_z(odd_mask, vec, vec);\n\n        // Accumulate sum of squares\n        float local_sum = svadda_f32(odd_mask, 0.0f, squared);\n        sum += static_cast<uint64_t>(local_sum);\n\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n    svbool_t pg = svptrue_b32();\n\n    while (i < len) {\n        svbool_t active = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1(pg, &lst[i]);\n\n        // Check for positive numbers\n        svbool_t pos_mask = svcmpgt(pg, vec, svdup_f32(0.0f));\n\n        // Check for integer values by comparing with floor\n        svfloat32_t floor_vec = svrinti(pg, vec);\n        svbool_t int_mask = svcmpeq(pg, vec, floor_vec);\n\n        // Check for odd numbers by casting to int and checking LSB\n        svint32_t int_vec = svcvt_s32_f32(pg, vec);\n        svbool_t odd_mask = svand_b_z(pg, int_vec, svdup_s32(1));\n\n        // Combine masks: positive, integer, and odd\n        svbool_t final_mask = svand_b_z(pg, pos_mask, int_mask);\n        final_mask = svand_b_z(pg, final_mask, odd_mask);\n\n        // Compute square of the numbers\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n\n        // Accumulate sum of squares\n        float local_sum = svaddv(pg, squared);\n        sum += static_cast<uint64_t>(local_sum);\n\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t len = game.size();\n    size_t vl = svcntw(); // Get vector length in elements (for int32_t)\n\n    for (size_t i = 0; i < len; i += vl) {\n        // Calculate remaining elements\n        size_t remaining = len - i;\n        svbool_t pg = svwhilelt_b32(i, len); // Predicate for active lanes\n\n        // Load game and guess vectors\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        // Compute absolute difference: |game - guess|\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n\n        // Store result\n        svst1_s32(pg, &result[i], abs_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    for (; i < len; ) {\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + vec_len <= n; i += vec_len) {\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n        svint32_t diff_vec = svabs_z(pg, svsub_z(pg, game_vec, guess_vec));\n        svst1(pg, &result[i], diff_vec);\n    }\n    \n    // Handle remaining elements\n    if (i < n) {\n        svbool_t pg_rem = svwhilelt_b32(i, n);\n        svint32_t game_vec = svld1(pg_rem, &game[i]);\n        svint32_t guess_vec = svld1(pg_rem, &guess[i]);\n        svint32_t diff_vec = svabs_z(pg_rem, svsub_z(pg_rem, game_vec, guess_vec));\n        svst1(pg_rem, &result[i], diff_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (i < len) {\n        svint32_t v_game = svld1_s32(pg, &game[i]);\n        svint32_t v_guess = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, v_game, v_guess);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    for (; i < len; ) {\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
